"```json:/contribute/plugin/_category_.json


{

  ""label"": ""WasmEdge Plugin System"",

  ""position"": 3,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""We will learn how to develop the plug-ins for WasmEdge.""

  }

}








```"
"The following is a markdown document located at /contribute/plugin/best_practice.md
------


---

sidebar_position: 6

---



# Best Practice



When developing a WasmEdge plugin, it's important to follow best practices to ensure the plugin is well purformed, reliable, and efficient. Here are some key best practices to follow:



## Using the Latest Version of WasmEdge



Always use the latest version of WasmEdge to take advantage of the most recent features, improvements, and security updates.



### Installing the Latest Version



To install the latest version of WasmEdge, follow the installation instructions in the [WasmEdge documentation](https://wasmedge.org/docs/start/install/).



### Updating Existing Plugins



If you have existing plugins that were developed with an older version of WasmEdge, you may need to update them to work with the latest version. This could involve updating the plugin code to use new features or changes in the [WasmEdge API](https://wasmedge.org/docs/category/api-reference/), or updating the build process to use the latest version of WasmEdge.



Remember, using the latest version of WasmEdge not only ensures that you're leveraging the most recent features, but also provides the latest security updates to protect your applications.



## Choosing the Appropriate Programming Language



WasmEdge plugins can be developed in several languages including [C](develop_plugin_c.md), [C++](develop_plugin_cpp.md), and [Rust](develop_plugin_rustsdk.md). The choice of language depends on the specific requirements of the plugin and the developer's expertise. The C API is recommended for most use cases due to its simplicity and wide support. However, complex plugins might benefit from the enhanced features of C++ or Rust.



## Writing and Compiling the Plugin



When creating a WasmEdge plugin:



   1. **Code Writing**: While develop your plugin, write clear, maintainable code, and document it well for easy understanding and future maintenance.



   2. **Compiling to Shared Library**: Use a compiler like `gcc` for C or `g++` for C++ to compile your code into a shared library. For example, in a Linux environment, you might use `gcc -shared -fPIC -o my_plugin.so my_plugin.c` for a C plugin.



   3. **Error Handling and Input Validation**: Efficitive error handling to catch and manage potential issues. Validate all inputs thoroughly to ensure the plugin's stability and security.



## Testing the Plugin



Testing is a crucial part of the plugin development process. It ensures that the plugin behaves as expected, meets the requirements, and performs optimally. WasmEdge provides a set of tests for various plugins in its [repository](https://github.com/WasmEdge/WasmEdge/tree/master/test/plugins) that you can use as references for writing your own tests.



To run tests for the WasmEdge plugin, you'll need to follow a few steps. In this case, we'll use the `wasmedge-image` plugin as an example.



- **Step 1: Build the WasmEdge Runtime and WasmEdge-image Plugin**

   First, you need to build both the [build WasmEdge](../source/build_from_src.md) and the [wasmedge-image](../source/plugin/image.md) plugin.



- **Step 2: Run the Tests**

   The WasmEdge repository provides a set of tests for various plugins, including `wasmedge-image`. You can find the test cases in the `test/plugins/wasmedge_image` directory of the repository.



   To run these tests, you can use the `ctest` command from the build directory:



   ```bash

   cd ../../../test/plugins/wasmedge_image

   mkdir build && cd build

   cmake ..

   make

   ctest

   ```



   This will run all the unit tests and integration tests for the `wasmedge-image`plugin. These tests ensure that the plugin behaves as expected, meets the requirements, and performs optimally. They also verify that the plugin correctly integrates with the WebAssembly program and that the WebAssembly program can call the plugin's functions correctly.



- **Step 3: Analyze the Test Results**

   After running the tests, analyze the results to identify any issues or bugs. If any test fails, you should debug the issue, fix the problem, and then rerun the tests to ensure that the fix works as expected.



By following these steps, you can effectively run tests for the `wasmedge-image` plugin or any other WasmEdge plugin.



<!-- prettier-ignore -->

:::note

If you want to develop your own tests follow [Writing Tests for WasmEdge Plugins](test_plugin.md) for details.

:::



## Securing the Plugin



Security is a vital part of any software development process. It involves several aspects, including securing the code, verifying inputs, handling errors properly, and using secure coding practices. When developing a WasmEdge plugin, it's essential to follow these best practices:



- **Validate Inputs:** Always validate the inputs to your functions. This can prevent many types of attacks, including buffer overflow attacks and code injection attacks.



   ```c

   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,

                        const WasmEdge_Value *In, WasmEdge_Value *Out) {

      if (In[0].Type != WasmEdge_ValType_I32 || In[1].Type != WasmEdge_ValType_I32) {

      return WasmEdge_Result_Error;

      }

      // Rest of the function...

   }

   ```



- **Handle Errors:** Always handle errors properly. Don't ignore return values that indicate an error, and don't continue execution after an error occurs.



   ```c

   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,

                        const WasmEdge_Value *In, WasmEdge_Value *Out) {

      // Check the input types...

      int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

      int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

      if (Val1 == INT32_MIN || Val2 == INT32_MIN) {

      return WasmEdge_Result_Error;

      }

      // Rest of the function...

   }

   ```



- **Use Secure Coding Practices:** Follow secure coding practices in your chosen language. For example, avoid using unsafe functions, use strong types, and avoid using global variables.



## Publishing the Plugin



Once you have developed, tested, and documented your WasmEdge plugin, it’s time to publish it for others to use. You need to follow following steps for publishing your plugin:



## Exporting the SDKs in Rust



In addition to C and C++ SDKs, you can also create an SDK for Rust developers. This involves creating a Rust library that provides a Rust interface to your plugin's functionality.



### Creating a Rust Library



You can create a Rust library that provides a Rust interface to your plugin's functionality. This involves writing Rust code that calls the functions in your plugin and provides a Rust-friendly API.



In the [wasmedge-image](../source/plugin/image.md) plugin's case, you might have something like this:



```rust

// lib.rs

extern crate wasmedge_image;



use wasmedge_image::Image;



pub fn load_image(path: &str) -> Result<Image, wasmedge_image::Error> {

Image::open(path)

}

```



In this Rust library, a single `load_image` function is provided that calls the `open` function from the `wasmedge-image` plugin.



### Building the Rust Library



You can build your Rust library using Cargo, the Rust package manager. This will produce a `.so` file that can be loaded by the WasmEdge runtime.



```bash

cargo build --release

```



### Packaging the Rust SDK



Package the Rust library and the header file into a tarball or a similar package format. This makes it easy for other developers to download and install your SDK.



```bash

tar czvf wasmedge_image_rust_sdk.tar.gz libwasmedge_image.so wasmedge_image.h

```



With this package, other rust developers can easily use your plugin in their applications. They just need to include your header file in their code, and link against your rust library when they compile their application.



Now, when you're ready to publish your plugin and the corresponding SDK, can publish your plugin on the official WasmEdge [plugin repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins) by creating a pull request into it or any other repository of your choice. Make sure to include the documentation and any other resources (like test files) with your plugin.



## Contributing to the WasmEdge Community



As an open-source contributor, you can share your plugin with the community by submitting it to the official [WasmEdge repository](https://github.com/WasmEdge/WasmEdge). This allows others to benefit from your work.



By following these best practices, you can ensure a successful and efficient plugin development process for WasmEdge.








------"
"The following is a markdown document located at /contribute/plugin/develop_plugin_c.md
------


---

sidebar_position: 2

---



# Develop WasmEdge Plug-in in C API



By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process. Here is a flowchart showing all the steps needed for developing WasmEdge Plug-in -



```mermaid

graph LR;

A[Developing WasmEdge Plug-in in C]

A --> B(Set up the development environment)

A --> C(Create a WasmEdge plug-in project)

A --> D(Write the plug-in code)

A --> E(Build the plug-in)

A --> F(Test and debug the plug-in)

B --> E

C --> D

D --> E

```



This flowchart illustrates developing a WasmEdge plug-in, showcasing the steps from choosing a programming language to finalizing and releasing the plug-in.



## Set up the development environment



To start developing WasmEdge plug-ins, it is essential to correctly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -



**Install a WasmEdge runtime**: You can download the latest version of WasmEdge from [GitHub repository](https://github.com/wasmEdge/wasmEdge). Follow the instructions in the [installation guide](../../start/install.md) for your specific operating system.



After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).



## Create a WasmEdge plug-in project



To create a WasmEdge plug-in project, follow these steps:



- **Set up the project directory**: Create a directory structure for your plug-in project. You can use a standard structure for the chosen language or create your structure. To create a project directory structure, use the following commands:



  ```bash

  mkdir testplugin

  cd testplugin

  mkdir src include build

  ```



- **Add configuration files**: Add configuration files specifying the plug-in name, version, and dependencies. The specific files and content depend on the chosen programming language and build system.



- **Add any necessary libraries or dependencies**: Include any required libraries or dependencies for your plug-in. Modify the configuration files created in the previous step to include the required dependencies.



## Write the plug-in code



To create a plug-in with host functions and modules, follow these steps:



- **Implement host function definitions**: In this step, you must define the host functions that will be imported when instantiating the WASM module. These functions will perform specific operations and return results.



  Therefore, developers can first implement their plug-in host functions, like the [host functions in WasmEdge C API](/embed/c/reference/latest.md#host-functions).



<!-- prettier-ignore -->

:::note

For more details about the [external data](/embed/c/host_function.md#host-data) and [calling frame context](/embed/c/host_function.md#calling-frame-context), please refer to the host function guide.

:::



Here's an example of two host functions, `HostFuncAdd` and `HostFuncSub`, that add and subtract two `int32_t` numbers, respectively:



```c

#include <wasmedge/wasmedge.h>



/* The host function definitions. */



/* The host function to add 2 int32_t numbers. */

WasmEdge_Result HostFuncAdd(void *Data,

                            const WasmEdge_CallingFrameContext *CallFrameCxt,

                            const WasmEdge_Value *In, WasmEdge_Value *Out) {

  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

  return WasmEdge_Result_Success;

}



/* The host function to sub 2 int32_t numbers. */

WasmEdge_Result HostFuncSub(void *Data,

                            const WasmEdge_CallingFrameContext *CallFrameCxt,

                            const WasmEdge_Value *In, WasmEdge_Value *Out) {

  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

  Out[0] = WasmEdge_ValueGenI32(Val1 - Val2);

  return WasmEdge_Result_Success;

}

```



- **Implement the module creation functions**: In this step, you need to implement the module creation function that creates an instance of the module. This function will be called when the plug-in is loaded.



  Here's an example of a module creation function named `CreateTestModule`:



  ```c

  /* The creation function of creating the module instance. */

  WasmEdge_ModuleInstanceContext *

  CreateTestModule(const struct WasmEdge_ModuleDescriptor *Desc) {

    /*

     * The `Desc` is the const pointer to the module descriptor struct:

     *

     *   typedef struct WasmEdge_ModuleDescriptor {

     *     const char *Name;

     *     const char *Description;

     *     WasmEdge_ModuleInstanceContext *(*Create)(

     *         const struct WasmEdge_ModuleDescriptor *);

     *   } WasmEdge_ModuleDescriptor;

     *

     * Developers can get the name and description from this descriptor.

     */



    /* Exported module name of this module instance. */

    WasmEdge_String ModuleName =

        WasmEdge_StringCreateByCString(""wasmedge_plugintest_c_module"");

    WasmEdge_ModuleInstanceContext *Mod =

        WasmEdge_ModuleInstanceCreate(ModuleName);

    WasmEdge_StringDelete(ModuleName);



    WasmEdge_String FuncName;

    WasmEdge_FunctionTypeContext *FType;

    WasmEdge_FunctionInstanceContext *FuncCxt;

    WasmEdge_ValType ParamTypes[2], ReturnTypes[1];

    ParamTypes[0] = WasmEdge_ValTypeGenI32();

    ParamTypes[1] = WasmEdge_ValTypeGenI32();

    ReturnTypes[0] = WasmEdge_ValTypeGenI32();



    /* Create and add the host function instances into the module instance. */

    FType = WasmEdge_FunctionTypeCreate(ParamTypes, 2, ReturnTypes, 1);

    FuncName = WasmEdge_StringCreateByCString(""add"");

    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncAdd, NULL, 0);

    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);

    WasmEdge_StringDelete(FuncName);

    FuncName = WasmEdge_StringCreateByCString(""sub"");

    FuncCxt = WasmEdge_FunctionInstanceCreate(FType, HostFuncSub, NULL, 0);

    WasmEdge_ModuleInstanceAddFunction(Mod, FuncName, FuncCxt);

    WasmEdge_StringDelete(FuncName);

    WasmEdge_FunctionTypeDelete(FType);



    return Mod;

  }

  ```



  There can be several module instances in a plug-in shared library. Here in the above code snippet, take a module named `wasmedge_plugintest_c_module` for the example.



- **Supply the plug-in descriptions**- In this step, you need to provide the descriptions of the plug-in and the modules it contains. These descriptions will be used for searching and creating the plug-in and module instances.



  Here's an example of the plug-in and module descriptors:



  ```c

  /* The module descriptor array. There can be multiple modules in a plug-in. */

  static WasmEdge_ModuleDescriptor ModuleDesc[] = {{

      /*

       * Module name. This is the name for searching and creating the module

       * instance context by the `WasmEdge_PluginCreateModule()` API.

       */

      .Name = ""wasmedge_plugintest_c_module"",

      /* Module description. */

      .Description = ""This is for the plugin tests in WasmEdge C API."",

      /* Creation function pointer. */

      .Create = CreateTestModule,

  }};



  /* The plug-in descriptor */

  static WasmEdge_PluginDescriptor Desc[] = {{

      /*

       * Plug-in name. This is the name for searching the plug-in context by the

       * `WasmEdge_PluginFind()` API.

       */

      .Name = ""wasmedge_plugintest_c"",

      /* Plug-in description. */

      .Description = """",

      /* Plug-in API version. */

      .APIVersion = WasmEdge_Plugin_CurrentAPIVersion,

      /* Plug-in version. Developers can define the version of this plug-in. */

      .Version =

          {

              .Major = 0,

              .Minor = 1,

              .Patch = 0,

              .Build = 0,

          },

      /* Module count in this plug-in. */

      .ModuleCount = 1,

      /* Plug-in option description count in this plug-in (Work in progress). */

      .ProgramOptionCount = 0,

      /* Pointer to the module description array. */

      .ModuleDescriptions = ModuleDesc,

      /* Pointer to the plug-in option description array (Work in progress). */

      .ProgramOptions = NULL,

  }};

  ```



  These descriptions define the name, description, version, and creation function of the plug-in and the name and description of the module it contains.



Remember to implement any additional functions or structures your plug-in requires to fulfill its functionality.



Following these steps and implementing the necessary functions and descriptors, you can create a plug-in with host functions and modules in WasmEdge C API. You can continue developing your plug-in by adding functionality and implementing the desired behavior.



- **Plug-in option** - _WORK IN PROGRESS. This section is reserved for the feature in the future._



## Build your plug-in



To build the WasmEdge plug-in shared library, you have two options: build it directly using the compiler or CMake. Here are the instructions for both methods:



- **Build with Command**: if you choose to build the plug-in using the command line, run the following command in the terminal:



  ```bash

  gcc -std=c11 -DWASMEDGE_PLUGIN -shared -o libwasmedgePluginTest.so testplugin.c

  ```



  This command compiles the `testplugin.c` file into a shared library named `libwasmedgePluginTest.so`. The `-std=c11` flag sets the C language standard to C11, and the `-DWASMEDGE_PLUGIN` flag defines the WASMEDGE_PLUGIN macro, which can be used in your code.



- **Build with CMake**: If you prefer to use CMake to build the plug-in, create a `CMakeLists.txt` file in the root directory of your project and add the following content to the CMakeLists.txt file:



  ```cmake

  add_library(wasmedgePluginTest

    SHARED

    testplugin.c

  )



  set_target_properties(wasmedgePluginTest PROPERTIES

    C_STANDARD 11

  )



  target_compile_options(wasmedgePluginTest

    PUBLIC

    -DWASMEDGE_PLUGIN

  )



  target_link_libraries(wasmedgePluginTest

    PRIVATE

    wasmedge

  )

  ```



  This CMake configuration sets up a build target called `wasmedgePluginTest`. It compiles the `testplugin.c` file into a shared library. The `C_STANDARD 11` property sets the C language standard to C11. The `target_compile_options` command defines the `WASMEDGE_PLUGIN` macro using the `-DWASMEDGE_PLUGIN` flag. Finally, the `target_link_libraries` command links the wasmedge library to the plug-in.



Once you have set up either the command-line build or the CMake build, you can execute the corresponding build command or generate build files using CMake, which will compile your plug-in source code and produce the shared library file `(libwasmedgePluginTest.so)`.








------"
"The following is a markdown document located at /contribute/plugin/develop_plugin_cpp.md
------


---

sidebar_position: 3

---



# Develop WasmEdge Plug-in in C++ API



By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process.



<!-- prettier-ignore -->

:::note

It is recommended that developers choose the WasmEdge [C API](develop_plugin_c.md) for plug-in development because of the support, compatibility, and flexibility the WasmEdge runtime provides.

:::



Here is a flowchart showing all the steps needed for developing WasmEdge Plug-in -



```mermaid

graph TD;

A[Develop WasmEdge Plug-in in C++ API]

A --> B(Set up development environment)

B --> C(Create project directory)

C --> D(Add configuration files)

D --> E(Install necessary tools and dependencies)

E --> F(Enable specific backends or components)

F --> G(Write plug-in code)

G --> H(Build plug-in)

C --> I(Define plug-in API)

H --> I

I --> J(Compile WasmEdge plug-in)

J --> K(Test and debug plug-in)

```



This flowchart illustrates developing a WasmEdge plug-in, showcasing the steps from choosing a programming language to finalizing and releasing the plug-in.



## Set up a development environment



To start developing WasmEdge plug-ins, it is essential to correctly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -



**Build WasmEdge from source**: For developing the WasmEdge plug-in in C++, you must build WasmEdge from source. Follow the[build WasmEdge from source](../source/build_from_src.md) for instructions.



After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).



## Create a WasmEdge plug-in project



To create a WasmEdge plug-in project, follow these steps:



- **Set up the project directory**: Create a directory structure for your plug-in project. You can use a standard structure for the chosen language or create your structure. To create a project directory structure, use the following commands:



  ```bash

  mkdir testplugin

  cd testplugin

  mkdir src include build

  ```



- **Add necessary libraries or dependencies**: Include any required libraries or dependencies for your plug-in. Modify the configuration files created in the previous step to include the required dependencies.



## Write plug-in code



To create a plug-in with host functions and modules, follow these steps:



- **Host Functions and Modules**: The plug-in aims to provide the host functions that can be imported when instantiating WASM. Therefore, developers should first implement their plug-in host functions in WasmEdge internal C++. Assume that the host function implementations are in the `testplugin.h`.



  ```cpp

  #pragma once



  #include ""plugin/plugin.h""



  #include <cstdint>

  #include <string>



  namespace WasmEdge {

  namespace Host {



  // The environment class. For the register object.

  class WasmEdgePluginTestEnv {

  public:

    WasmEdgePluginTestEnv() noexcept = default;



    static Plugin::PluginRegister Register;

  };



  // The host function base template class. For inheriting the environment class

  // reference.

  template <typename T>

  class WasmEdgePluginTestFunc : public Runtime::HostFunction<T> {

  public:

    WasmEdgePluginTestFunc(WasmEdgePluginTestEnv &HostEnv)

        : Runtime::HostFunction<T>(0), Env(HostEnv) {}



  protected:

    WasmEdgePluginTestEnv &Env;

  };



  // The host function to add 2 int32_t numbers.

  class WasmEdgePluginTestFuncAdd

      : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncAdd> {

  public:

    WasmEdgePluginTestFuncAdd(WasmEdgePluginTestEnv &HostEnv)

        : WasmEdgePluginTestFunc(HostEnv) {}

    Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {

      return A + B;

    }

  };



  // The host function to sub 2 int32_t numbers.

  class WasmEdgePluginTestFuncSub

      : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncSub> {

  public:

    WasmEdgePluginTestFuncSub(WasmEdgePluginTestEnv &HostEnv)

        : WasmEdgePluginTestFunc(HostEnv) {}

    Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {

      return A - B;

    }

  };



  // The host module class. There can be several modules in a plug-in.

  class WasmEdgePluginTestModule : public Runtime::Instance::ModuleInstance {

  public:

    WasmEdgePluginTestModule()

        : Runtime::Instance::ModuleInstance(""wasmedge_plugintest_cpp_module"") {

      addHostFunc(""add"", std::make_unique<WasmEdgePluginTestFuncAdd>(Env));

      addHostFunc(""sub"", std::make_unique<WasmEdgePluginTestFuncSub>(Env));

    }



    WasmEdgePluginTestEnv &getEnv() { return Env; }



  private:

    WasmEdgePluginTestEnv Env;

  };



  } // namespace Host

  } // namespace WasmEdge

  ```



- **Creation Functions for Modules**: Then developers should implement the module creation functions. Assume the following implementations are all in the `testplugin.cpp`.



  ```cpp

  #include ""testplugin.h""



  namespace WasmEdge {

  namespace Host {

  namespace {



  Runtime::Instance::ModuleInstance *

  create(const Plugin::PluginModule::ModuleDescriptor *) noexcept {

    // There can be several modules in a plug-in. For that, developers should

    // implement several `create` functions for each module.

    return new WasmEdgePluginTestModule;

  }



  } // namespace

  } // namespace Host

  } // namespace WasmEdge

  ```



- **Plug-in Descriptions**: For constructing the plug-in, developers should supply the descriptions of this plug-in and the modules.



  ```cpp

  namespace WasmEdge {

  namespace Host {

  namespace {



  Plugin::Plugin::PluginDescriptor Descriptor{

      //Plug-in name - for searching the plug-in context by the

      // `WasmEdge_PluginFind()` C API.

      .Name = ""wasmedge_plugintest_cpp"",

      //Plug-in description.

      .Description = """",

      //Plug-in API version.

      .APIVersion = Plugin::Plugin::CurrentAPIVersion,

      //Plug-in version.

      .Version = {0, 10, 0, 0},

      // Module count in this plug-in.

      .ModuleCount = 1,

      // Pointer to module description array.

      .ModuleDescriptions =

          // The module descriptor array.

          (Plugin::PluginModule::ModuleDescriptor[]){

              {

                  // Module name. This is the name for searching and creating the

                  // module instance context by the

                  // `WasmEdge_PluginCreateModule()` C API.

                  .Name = ""wasmedge_plugintest_cpp_module"",

                  // Module description.

                  .Description = ""This is for the plugin tests in WasmEdge."",

                  // Creation function pointer.

                  .Create = create,

              },

          },

      //Plug-in options (Work in progress).

      .AddOptions = nullptr,

  };



  } // namespace

  } // namespace Host

  } // namespace WasmEdge

  ```



- **Plug-in Options**: WORK IN PROGRESS. This section is reserved for the feature in the future.



- **Implement Plug-in Descriptor Registration**: The final step is to implement the `Plugin::PluginRegister` initialization with the plug-in descriptor.



```cpp

namespace WasmEdge {

namespace Host {



Plugin::PluginRegister WasmEdgePluginTestEnv::Register(&Descriptor);



} // namespace Host

} // namespace WasmEdge

```



Remember to implement any additional functions or structures your plug-in requires to fulfill its functionality.



Following these steps and implementing the necessary functions and descriptors, you can create a plug-in with host functions and modules in WasmEdge C++ API. You can continue developing your plug-in by adding functionality and implementing the desired behavior.



## Build plug-in



To build the plug-in shared library, developers should build in CMake with the WasmEdge source.



- Assume that the' test' folder is created under the `<PATH_TO_WASMEDGE_SOURCE>/plug-ins`. Add this line in the `<PATH_TO_WASMEDGE_SOURCE>/plugins/CMakeLists.txt`:



  ```cmake

  add_subdirectory(test)

  ```



- Copy the `testplugin.h` and `testplugin.cpp` into the `<PATH_TO_WASMEDGE_SOURCE>/plugins/test` directory. And then edit the file `<PATH_TO_WASMEDGE_SOURCE>/plugins/test/CMakeLists.txt`:



  ```cmake

  wasmedge_add_library(wasmedgePluginTest

    SHARED

    testplugin.cpp

  )



  target_compile_options(wasmedgePluginTest

    PUBLIC

    -DWASMEDGE_PLUGIN

  )



  target_include_directories(wasmedgePluginTest

    PUBLIC

    $<TARGET_PROPERTY:wasmedgePlugin,INCLUDE_DIRECTORIES>

    ${CMAKE_CURRENT_SOURCE_DIR}

  )



  if(WASMEDGE_LINK_PLUGINS_STATIC)

    target_link_libraries(wasmedgePluginTest

      PRIVATE

      wasmedgeCAPI

    )

  else()

    target_link_libraries(wasmedgePluginTest

      PRIVATE

      wasmedge_shared

    )

  endif()



  install(TARGETS wasmedgePluginTest DESTINATION ${CMAKE_INSTALL_LIBDIR}/wasmedge)

  ```



Follow the guide to [build WasmEdge from source](../source/os/linux.md), according to your specific operating system (e.g., Linux), which will include building the plug-in shared library along with WasmEdge.








------"
"The following is a markdown document located at /contribute/plugin/develop_plugin_rustsdk.md
------


---

sidebar_position: 4

---



# Develop WasmEdge Plug-in in Rust SDK with witc



By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a Rust-based API for registering extension modules and host functions.



```mermaid

graph TD

A[Build WasmEdge from source] -- witc --> B[Generate Rust Plug-in Code]

B -- SDK Crate --> C[Create SDK Crate]

C -- Module File --> D[Create Module File]

D -- Wrapper Functions --> E[Write Wrapper Functions in src/lib.rs]

```



<!-- prettier-ignore -->

:::note

It is recommended that developers choose the WasmEdge [C API](develop_plugin_c.md) for plug-in development because of the support, compatibility, and flexibility the WasmEdge runtime provides.

:::



## Set up the development environment



To start developing WasmEdge plug-ins, it is essential to properly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -



- **Build WasmEdge from source**: For developing the WasmEdge plug-in in C++, you must build WasmEdge from source. Follow the[build WasmEdge from source](../source/build_from_src.md) for instructions. Once you complete the C++ plug-in code, you can use witc[^1] to generate Rust Plug-in SDK.



After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the [build environment setup guide](../source/os/linux.md).



## Write the plug-in code



To develop a WasmEdge Plug-in in Rust using the witc tool, you can follow these steps:



- **Generate Rust Plug-in Code**: Consider you have a file named `wasmedge_opencvmini.wit` with the following content:



  ```wit

  imdecode: func(buf: list<u8>) -> u32

  imshow: func(window-name: string, mat-key: u32) -> unit

  waitkey: func(delay: u32) -> unit

  ```



  You can use the witc tool to generate Rust plug-in code for it by running the following command:



  ```shell

  witc plugin wasmedge_opencvmini.wit

  ```



- **Create SDK Crate**: You need to create an SDK crate for your plug-in. Run the following command to create a new crate named `opencvmini-sdk`:



  ```shell

  cargo new --lib opencvmini-sdk && cd opencvmini-sdk

  ```



- **Create Module File**: The witc tool puts the Rust code to stdout. To capture the generated code, create a new module file named `src/generated.rs` and run the following command:



  ```shell

  witc plugin wasmedge_opencvmini.wit > src/generated.rs

  ```



- **Write Wrapper Functions**: In the `src/lib.rs` file of your crate, write the following code of `mod generated` to access the generated code and create wrapper functions:



  ```rust

  mod generated;



  pub fn imdecode(buf: &[u8]) -> u32 {

      unsafe { generated::imdecode(buf.as_ptr(), buf.len()) }

  }

  pub fn imshow(window_name: &str, mat_key: u32) -> () {

      unsafe { generated::imshow(window_name.as_ptr(), window_name.len(), mat_key) }

  }

  pub fn waitkey(delay: u32) -> () {

      unsafe { generated::waitkey(delay) }

  }

  ```



  This code imports the generated module and provides safe wrapper functions for each generated function.



[^1]: <https://github.com/second-state/witc>








------"
"The following is a markdown document located at /contribute/plugin/intro.md
------


---

sidebar_position: 1

---



# WasmEdge Plug-in System Introduction



While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, developers should implement the host functions before compilation. However, for a more flexible and dynamic extension of the host functions, WasmEdge provides a plug-in architecture to load the plug-in shared library.



A WasmEdge plug-in is a software component that extends the functionality of the WasmEdge runtime. Currently, developers can follow the guides to implement the plug-ins in [C API](develop_plugin_c.md) (recommended), [C++](develop_plugin_cpp.md) and [Rust](develop_plugin_rustsdk.md). With the help of the WasmEdge SDKs in the supported languages, developers can load and register the host functions from the plug-in shared libraries, allowing them to seamlessly integrate the plug-ins into the WasmEdge runtime as if they were part of the core runtime.



```mermaid

graph LR

    A((Host Application)) -- Loads --> B((Plug-in Shared Library))

    B -- Registers --> C((Wasmedge Runtime))

```



## Benefits of Using WasmEdge Plug-in



WasmEdge plug-ins are designed to extend the functionality of the WasmEdge runtime and can be helpful for developers and end-users in several ways:



- **Customization:** WasmEdge plug-ins can be customized to suit the specific needs of a project. Developers can create plug-ins that integrate with other systems or tools or provide unique functionality unavailable in the core WasmEdge runtime.



- **Performance:** WasmEdge plug-ins are designed to work seamlessly with the core runtime, minimizing overhead and maximizing performance, which means they can provide additional functionality without sacrificing performance.



- **Ease of use:** WasmEdge plug-ins are easy to use and integrate with the WasmEdge runtime. Developers can load the plug-in into the runtime and use its functions as part of the core runtime.



- **Scalability:** Developers can compile their compute-intensive functions into host functions and package them into a plug-in to provide the better performance as running in native code.



WasmEdge plug-ins can provide developers and users with a versatile, customizable, high-performance, and secure way to extend the functionality of the WasmEdge runtime. WasmEdge plug-ins can also improve scalability and ease of use, making it easier to build and deploy complex applications on edge devices.



## Loadable Plug-in



Loadable plug-ins are standalone shared libraries (`.so`/`.dylib`/`.dll` files) that the WasmEdge runtime environment can load at runtime. These plug-ins can provide additional functionality to the WasmEdge runtime environment, such as new modules that can be imported by WebAssembly modules.



### Creating Loadable Plug-in



To create a loadable plug-in for WasmEdge, developers can use the WasmEdge Plug-in SDK, which provides a set of Rust, C, and C++ APIs for creating and registering plug-ins. The SDK also includes [example code](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/get-string) that demonstrates creating a simple plug-in that returns a string. By following the provided examples and leveraging the SDK's APIs, developers can quickly build custom plug-ins tailored to their specific needs.



### Loading plug-in from paths



To use the loadable plug-ins, developers need to load them from specific paths into the WasmEdge runtime environment. The loading process involves the following steps:



- Loadable plug-ins can be loaded from default paths by calling the `WasmEdge_PluginLoadWithDefaultPaths()` API. The default paths include:



  - The path specified in the environment variable `WASMEDGE_PLUGIN_PATH`.

  - The `./plugin/` directory relative to the WasmEdge installation path.

  - The `./wasmedge/` directory is located under the library path if WasmEdge is installed in a system directory such as `/usr` and `/usr/local`.



- If the plug-ins are located in a specific path or directory, developers can use the `WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plug-in.so"")` API to load the plug-ins from that particular location.



The WasmEdge runtime environment will search for the loadable plug-ins in the specified paths and load them if found.



The following flowchart shows the process of loading loadable plug-ins into the WasmEdge runtime environment from specific paths:



```mermaid

graph LR

    A((Start)) --> B(Loadable Plug-ins)

    B --> C{Load Plug-ins}

    C --> D[Load from Default Paths]

    C --> E[Load from Specific Path]

    C --> F[Load from Specific Directory]

    D --> G{Is Plug-in Found?}

    E --> G

    F --> G

    G -- Yes --> H(Load Plug-in)

    H --> I(End)

    G -- No --> I

```



The flowchart shows loading loadable plug-ins into the WasmEdge runtime environment. The process involves searching for plug-ins in default paths, a specific path, or a specific directory. If a plug-in is found in any of these locations, it is loaded into the runtime environment. The flowchart enables developers to quickly load plug-ins and extend the capabilities of the WasmEdge runtime.



By following this flowchart, developers can effectively load loadable plug-ins into the WasmEdge runtime environment from specific paths, expanding the runtime's functionality according to their requirements.



## WasmEdge Currently Released Plug-ins



Users can install the [WasmEdge official released plug-ins](../../start/wasmedge/extensions/plugins.md) from the installer, or build them from source.








------"
"The following is a markdown document located at /contribute/plugin/test_plugin.md
------


---

sidebar_position: 5

---



# Writing Tests for WasmEdge Plugins



This guide aims to help you write tests for your newly developed WasmEdge plugin. We will cover the steps of creating test cases, implementing the test cases in code, and executing them with Google Test, a popular C++ testing framework.



## Understanding Your Plugin



Before you start writing tests, make sure you understand your plugin's functionality and structure. The plugin code for WasmEdge typically consists of the following parts:



- **Plugin and Module Descriptions**: These are structures that provide metadata about the plugin and the modules it includes.

- **Host Functions and Modules**: These are the functionalities provided by the plugin, implemented as C++ classes and methods.

- **Module Creation Functions**: These functions create instances of the plugin's modules when the plugin is loaded by the WasmEdge runtime.



## Creating Test Cases



The first step in writing tests is to create test cases. Each test case should focus on a specific functionality of your plugin. For example, if your plugin provides a function to add two numbers, you might have test cases that cover normal inputs, edge cases (like the maximum possible integers), and error handling (like passing non-integer values).



## Implementing Test Cases



Once you have your test cases, you can start implementing them in code. Each test case should be implemented as a C++ function that uses Google Test macros to perform assertions.



Here's an example of how you might implement a test case:



    ```cpp

    #include ""gtest/gtest.h""

    #include ""your_plugin.h""



    TEST(YourPluginTest, ConvertsNormalString) {

    YourPlugin plugin;

    std::string input = ""123"";

    int expected = 123;

    EXPECT_EQ(expected, plugin.convert(input));

    }

    ```



In this example, `YourPluginTest` is the test suite name, and `ConvertsNormalString` is the test case name. The `EXPECT_EQ` macro is used to verify that the result of `plugin.convert(input)` is the same as `expected`.



## Compiling and Executing Tests



The final step is to compile and execute your tests. WasmEdge uses CMake to manage its build process, so you can add your test file to the `CMakeLists.txt` file in the test directory:



    ```cmake

    add_executable(your_plugin_test your_plugin_test.cpp)

    target_link_libraries(your_plugin_test gtest_main your_plugin)

    add_test(NAME your_plugin_test COMMAND your_plugin_test)

    ```



Then, you can build and run your tests with the following commands:



    ```bash

    mkdir build

    cd buildtest_plugin.md

    cmake ..

    make

    ctest

    ```



If everything is set up correctly, this will compile your tests, run them, and report the results.



Remember, testing is an iterative process. As you develop new features or fix bugs, you should also update your tests to reflect these changes. This will ensure that your plugin continues to work as expected as it evolves.



We hope this guide helps you get started with writing tests for your WasmEdge plugins!








------"
"```json:/contribute/source/os/android/_category_.json


{

  ""label"": ""Build and Run WasmEdge on Android"",

  ""position"": 4,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""we will learn how to build and run WasmEdge on Android.""

  }

}








```"
"The following is a markdown document located at /contribute/source/os/android/apk.md
------


---

sidebar_position: 4

---



# Call WasmEdge functions from an Android APK app



In this section, we will show you how to build a ""regular"" Android app (i.e., an APK file that can be installed on an Android device). The APK app embeds a WasmEdge Runtime. It can call WebAssembly functions through the embedded WasmEdge. The benefit is that developers can safely embed high-performance functions written in several different languages (e.g., Rust, JS, Grain, TinyGo etc) into a Kotlin application.



## Quickstart



The demo project is [available here](https://github.com/WasmEdge/WasmEdge/tree/master/utils/android/app). You can build the project using the Gradle tool or using the Android Studio IDE.



### Building Project with Gradle



1. Setup environment variable `ANDROID_HOME=path/to/your/android/sdk`

2. Run Command `./gradlew assembleRelease`

3. Sign your APK file with `apksigner`. The apk file is at `./app/build/outputs/apk/release`. The `apksigner` utility is at `$ANDROID_HOME/build-tools/$VERSION/apksigner`.



### Building Project with Android Studio



Open this folder with [Android Studio](https://developer.android.com/studio) 2020.3.1 or later.



For Release APK, click `Menu -> Build -> Generate Signed Bundle/APK`, select APK, setup keystore configuration and wait for build finished.



## Review of the source code



The Android UI app is written in Kotlin, and it uses JNI (Java Native Interface) to load a C shared library, which in turn embeds WasmEdge.



### Android UI



The Android UI application is [located here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/app/src/main/java/org/wasmedge/example_app/MainActivity.kt). It is written in Kotlin using the Android SDK.



```java

class MainActivity : AppCompatActivity() {

  lateinit var lib: NativeLib



  override fun onCreate(savedInstanceState: Bundle?) {

    super.onCreate(savedInstanceState)

    setContentView(R.layout.activity_main)



    val tv = findViewById<TextView>(R.id.tv_text)



    lib = NativeLib(this)



    Thread {

      val lines = Vector<String>()

      val idxArr = arrayOf(20, 25, 28, 30, 32)

      for (idx: Int in idxArr) {

        lines.add(""running fib(${idx}) ..."")

        runOnUiThread {

          tv.text = lines.joinToString(""\n"")

        }

        val begin = System.currentTimeMillis()

        val retVal = lib.wasmFibonacci(idx)

        val end = System.currentTimeMillis()

        lines.removeLast()

        lines.add(""fib(${idx}) -> ${retVal}, ${end - begin}ms"")

        runOnUiThread {

          tv.text = lines.joinToString(""\n"")

        }

      }

    }.start()

  }

}

```



### The native library



The Android UI app calls a `NativeLib` Kotlin object to access WasmEdge functions. The `NativeLib` source code is [available here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/java/org/wasmedge/native_lib/NativeLib.kt). It uses JNI (Java Native Interface) to load a C shared library called `wasmedge_lib`. It then calls the `nativeWasmFibonacci` function in `wasmedge_lib` to execute the `fibonacci.wasm` WebAssembly bytecode.



```java

class NativeLib(ctx : Context) {

  private external fun nativeWasmFibonacci(imageBytes : ByteArray, idx : Int ) : Int



  companion object {

    init {

      System.loadLibrary(""wasmedge_lib"")

    }

  }



  private var fibonacciWasmImageBytes : ByteArray = ctx.assets.open(""fibonacci.wasm"").readBytes()



  fun wasmFibonacci(idx : Int) : Int{

    return nativeWasmFibonacci(fibonacciWasmImageBytes, idx)

  }

}

```



### The C shared library



The C shared library source code `wasmedge_lib.cpp` is [available here](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/wasmedge_lib.cpp). It uses the WasmEdge C SDK to embed a WasmEdge VM and execute the WebAssembly function.



```c

extern ""C"" JNIEXPORT jint JNICALL

Java_org_wasmedge_native_1lib_NativeLib_nativeWasmFibonacci(

    JNIEnv *env, jobject, jbyteArray image_bytes, jint idx) {

  jsize buffer_size = env->GetArrayLength(image_bytes);

  jbyte *buffer = env->GetByteArrayElements(image_bytes, nullptr);



  WasmEdge_ConfigureContext *conf = WasmEdge_ConfigureCreate();

  WasmEdge_ConfigureAddHostRegistration(conf, WasmEdge_HostRegistration_Wasi);



  WasmEdge_VMContext *vm_ctx = WasmEdge_VMCreate(conf, nullptr);



  const WasmEdge_String &func_name = WasmEdge_StringCreateByCString(""fib"");

  std::array<WasmEdge_Value, 1> params{WasmEdge_ValueGenI32(idx)};

  std::array<WasmEdge_Value, 1> ret_val{};



  const WasmEdge_Result &res = WasmEdge_VMRunWasmFromBuffer(

      vm_ctx, (uint8_t *)buffer, buffer_size, func_name, params.data(),

      params.size(), ret_val.data(), ret_val.size());



  WasmEdge_VMDelete(vm_ctx);

  WasmEdge_ConfigureDelete(conf);

  WasmEdge_StringDelete(func_name);



  env->ReleaseByteArrayElements(image_bytes, buffer, 0);

  if (!WasmEdge_ResultOK(res)) {

    return -1;

  }

  return WasmEdge_ValueGetI32(ret_val[0]);

}

```



### The WebAssembly function



The `factorial.wat` is a [handwritten WebAssembly script](https://github.com/WasmEdge/WasmEdge/blob/master/examples/wasm/fibonacci.wat) to compute factorial numbers. It is compiled into WebAssembly using the [WABT tool](https://github.com/WebAssembly/wabt).



### Build dependencies



Android Studio and Gradle use CMake to build the C shared library. The [CMakeLists.txt file](https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/CMakeLists.txt) builds the WasmEdge source into Android shared library files and embeds them into the final APK application. In this case, there is no separate step to install WasmEdge share libraries onto the Android device.








------"
"The following is a markdown document located at /contribute/source/os/android/build.md
------


---

sidebar_position: 1

---



# Build WasmEdge for Android



The WasmEdge Runtime releases come with pre-built binaries for the Android OS. Why WasmEdge on Android?



- Native speed & sandbox safety for Android apps

- Support multiple dev languages — eg C, [Rust](/category/develop-wasm-apps-in-rust), [Go](../../../../category/develop-wasm-apps-in-go) & [JS](../../../../category/develop-wasm-apps-in-javascript)

- [Embed 3rd party functions](../../../../embed/overview.md) in your android app

- [Kubernetes managed](../../../../category/deploy-wasmedge-apps-in-kubernetes) android apps



However, the WasmEdge installer does not support Android. The user must download the release files to a computer, and then use the `adb` tool to transfer the files to an Android device or simulator. We will show you how to do that.



- [WasmEdge CLI tools for Android](./cli.md)

- [Call WasmEdge functions from an NDK native app](./ndk.md)

- [Call WasmEdge functions from an Android APK app](./apk.md)



## Build from source for Android platforms



Please follow this guide to build and test WasmEdge from source code with Android NDK.



<!-- prettier-ignore -->

:::note

In current state, we only support the runtime for the interpreter mode.

:::



## Prepare the Environment



We recommend developers to [use our Docker images](../linux.md##prepare-the-environment) and follow the steps to prepare the building environment.



- Download and extract the [Android NDK 23b](https://developer.android.com/ndk/downloads).

- Check the cmake for [CMake 3.21](https://cmake.org/download/) or greater version.

- Download and install the [ADB platform tools](https://developer.android.com/studio/releases/platform-tools).

  - If you use the debian or ubuntu Linux distributions, you can install the ADB platform tools via `apt`.

- An Android device which is [enabled developer options and USB debugging](https://developer.android.com/studio/debug/dev-options) and with at least Android 6.0 or higher system version.



## Build WasmEdge for Android platforms



Get the WasmEdge source code.



```bash

git clone https://github.com/WasmEdge/WasmEdge.git

cd WasmEdge

```



Add the Android NDK path into the environment variable.



```bash

export ANDROID_NDK_HOME=path/to/you/ndk/dir

```



Run the build script in WasmEdge source code. This script will automatically build the WasmEdge for Android, and the results are in the `build` folder.



```bash

./utils/android/standalone/build_for_android.sh

```



## Test the WasmEdge CLI on Android platforms



### Push the WasmEdge CLI and related test data onto Android platforms



1. Connect the device by using a USB cable or Wi-Fi. Then you can check the attached devices via the `adb devices` command.



   ```bash

   $ adb devices

   List of devices attached

   0a388e93      device

   ```



2. Use the `adb push` command to push the entire `build/tools/wasmedge` folder into the `/data/local/tmp` folder on your Android device.



   ```bash

   cp -r examples build/tools/wasmedge/examples

   cd build

   adb push ./tools/wasmedge /data/local/tmp

   ```



### Run WasmEdge CLI on Android platforms



1. Please use the `adb shell` command to access into the Android device.

2. Follow the steps to test the WasmEdge CLI on the Android device.



```bash

$ cd /data/local/tmp/wasmedge/examples

$ ../wasmedge hello.wasm 1 2 3

hello

1

2

3



$ ../wasmedge --reactor add.wasm add 2 2

4



$ ../wasmedge --reactor fibonacci.wasm fib 8

34



$ ../wasmedge --reactor factorial.wasm fac 12

479001600



$ cd js

$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3

Hello 1 2 3

```



## Notice



- For the Android 10 or greater versions, SELinux will disallow the untrusted applications' `exec()` system call to execute the binaries in `home` or `/data/local/tmp` folder.

- The Android SELinux policy will disallow the untrusted applications to access the `/data/local/tmp` folder.








------"
"The following is a markdown document located at /contribute/source/os/android/cli.md
------


---

sidebar_position: 2

---



# CLI Tools



In this section, we will show you how to use WasmEdge CLI tools on Android devices. We will showcase a full WasmEdge demo to perform image classification (Tensorflow-based AI inference) on an Android device.



<!-- prettier-ignore -->

:::note

The `WasmEdge-tensorflow-tools` has been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.

:::



## Install Android version of WasmEdge-TensorFlow-Tools



First, install WasmEdge-TensorFlow-Tools pre-release on your Android device. It works with the Android version of TensorFlow-Lite dynamic shared library.



### Preparation



#### Android developer options



Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with [developer options turned on](https://developer.android.com/studio/debug/dev-options). WasmEdge requires Android 6.0 and above.



#### Android development CLI



In Ubuntu Linux, you can use the `apt-get` command to install Android debugging and testing tool `adb`. Using the `adb shell` command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.



```bash

$ sudo apt-get install adb

$ adb devices

* daemon not running; starting now at tcp:5037

* daemon started successfully

List of devices attached

c657c643 device

$ adb shell

sirius:/ $

```



### Install WasmEdge-TensorFlow-Tools packages



Use the following commands on your Ubuntu dev machine to download the WasmEdge-TensorFlow-Tools pre-release packages.



```bash

$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.12.1/WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz

$ mkdir WasmEdge-tensorflow-tools && tar zxvf WasmEdge-tensorflow-tools-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools

show-tflite-tensor

wasmedge-tensorflow-lite

```



### Install Android version of the TensorFlow-Lite shared library



We provide an Android compatible version of TensorFlow-Lite dynamic shared library in the WasmEdge-Tensorflow-deps package. Download the package to your Ubuntu dev machine as follows.



```bash

$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz

$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools

libtensorflowlite_c.so

```



Next use the `adb` tool to push the downloaded WasmEdge-TensorFlow packages onto a connected Android device.



```bash

adb push WasmEdge-tensorflow-tools /data/local/tmp

```



## Try it out



### Sample application



In this example, we will demonstrate a standard [WasmEdge Tensorflow-Lite sample application](https://github.com/second-state/wasm-learning/tree/master/rust/birds_v1). It can recognize and classify the bird type from a JPG or PNG picture of a bird. The explanation of the source code can be [found here](/develop/rust/wasinn/tensorflow_lite).



```bash

git clone https://github.com/second-state/wasm-learning.git

cd wasm-learning/rust/birds_v1

```



Use the `cargo` command to build a WASM bytecode file from the Rust source code. The WASM file is located at `target/wasm32-wasi/release/birds_v1.wasm`.



```bash

rustup target add wasm32-wasi

cargo build --release --target=wasm32-wasi

```



Push the WASM bytecode file, tensorflow lite model file, and the test bird picture file onto the Android device using `adb`.



```bash

adb push target/wasm32-wasi/release/birds_v1.wasm /data/local/tmp/WasmEdge-tensorflow-tools

adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp/WasmEdge-tensorflow-tools

adb push bird.jpg /data/local/tmp/WasmEdge-tensorflow-tools

```



### Run the WasmEdge-TensorFlow-Tools



Type `adb shell` from the Ubuntu CLI to open a command shell for the connected Android device. Confirm that the tools, programs, and test image are all available on the Android device under the `/data/local/tmp/WasmEdge-tensorflow-tools` folder.



```bash

$ adb shell

sirius:/ $ cd /data/local/tmp/WasmEdge-tensorflow-tools

sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ls

bird.jpg               lite-model_aiy_vision_classifier_birds_V1_3.tflite

birds_v1.wasm          show-tflite-tensor

libtensorflowlite_c.so wasmedge-tensorflow-lite

```



Load the TensorFlow-Lite dynamic shared library, and use the `show-tflite-tensor` CLI tool to examine the Tensorflow Lite model file.



```bash

sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH

sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor

sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite

INFO: Initialized TensorFlow Lite runtime.

Input tensor nums: 1

    Input tensor name: module/hub_input/images_uint8

        dimensions: [1 , 224 , 224 , 3]

        data type: UInt8

        tensor byte size: 150528

Output tensor nums: 1

    Output tensor name: module/prediction

        dimensions: [1 , 965]

        data type: UInt8

        tensor byte size: 965

```



Use the extended WasmEdge Runtime in `wasmedge-tensorflow-lite` to execute the compiled WASM program on the Android device. It loads the Tensorflow Lite model and bird image, and outputs the bird classification and its confidence.



```bash

sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite

sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg

INFO: Initialized TensorFlow Lite runtime.

166 : 0.84705883

```



The result shows that the bird type is in [line 166 of the label file](https://github.com/second-state/wasm-learning/blob/master/rust/birds_v1/aiy_birds_V1_labels.txt#L166) (Sicalis flaveola) and the confidence level is 84.7%.








------"
"The following is a markdown document located at /contribute/source/os/android/ndk.md
------


---

sidebar_position: 3

---



# Call WasmEdge functions from an NDK native app



In this section, we will demonstrate how to build an Android native application using C and the Android SDK. The native application uses the WasmEdge C SDK to embed the WasmEdge Runtime, and call WASM functions through WasmEdge.



<!-- prettier-ignore -->

:::note

The `WasmEdge-Image`, `WasmEdge-Tensorflow`, and `WasmEdge-tensorflow-tools` have been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.

:::



## Prerequisite



### Android



Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with [developer options turned on](https://developer.android.com/studio/debug/dev-options). WasmEdge requires Android 6.0 and above.



### Android development CLI



In Ubuntu Linux, you can use the `apt-get` command to install Android debugging and testing tool `adb`. Using the `adb shell` command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.



```bash

sudo apt-get install adb

```



### Android NDK



To compile programs with the wasmedge-tensorflow c api, you need to install the [Android NDK](https://developer.android.google.cn/ndk/downloads). In this example, we use the latest LTS version (r23b).



## Review of source code



The [`test.c`](https://github.com/second-state/wasm-learning/blob/master/android/test.c) uses the wasmedge-tensorflow c api to run a WebAssembly function. The WebAssembly file `birds_v1.wasm` is compiled from Rust source code and [explained here](/develop/rust/wasinn/tensorflow_lite).



```c

#include <wasmedge/wasmedge.h>

#include <wasmedge/wasmedge-image.h>

#include <wasmedge/wasmedge-tensorflowlite.h>



#include <stdio.h>



int main(int argc, char *argv[]) {

  /*

   * argv[0]: ./a.out

   * argv[1]: WASM file

   * argv[2]: tflite model file

   * argv[3]: image file

   * Usage: ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg

   */



  /* Create the VM context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  WasmEdge_ConfigureDelete(ConfCxt);



  /* Create the image and TFLite import objects. */

  WasmEdge_ModuleInstanceContext *ImageImpObj = WasmEdge_Image_ModuleInstanceCreate();

  WasmEdge_ModuleInstanceContext *TFLiteImpObj = WasmEdge_TensorflowLite_ModuleInstanceCreate();

  WasmEdge_ModuleInstanceContext *TFDummyImpObj = WasmEdge_Tensorflow_ModuleInstanceCreateDummy();



  /* Register into VM. */

  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImageImpObj);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFLiteImpObj);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFDummyImpObj);



  /* Init WASI. */

  const char *Preopens[] = {"".:.""};

  const char *Args[] = {argv[1], argv[2], argv[3]};

  WasmEdge_ModuleInstanceContext *WASIImpObj = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);

  WasmEdge_ModuleInstanceInitWASI(WASIImpObj, Args, 3, NULL, 0, Preopens, 1);



  /* Run WASM file. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""_start"");

  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, argv[1], FuncName, NULL, 0, NULL, 0);

  WasmEdge_StringDelete(FuncName);



  /* Check the result. */

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Run WASM failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return -1;

  }



  WasmEdge_ModuleInstanceDelete(ImageImpObj);

  WasmEdge_ModuleInstanceDelete(TFLiteImpObj);

  WasmEdge_ModuleInstanceDelete(TFDummyImpObj);

  WasmEdge_VMDelete(VMCxt);

  return 0;

}

```



## Build



### Install dependencies



Use the following commands to download WasmEdge for Android on your Ubuntu dev machine.



```bash

wget https://github.com/WasmEdge/WasmEdge/releases/download/0.12.1/WasmEdge-0.12.1-android_aarch64.tar.gz

wget https://github.com/second-state/WasmEdge-image/releases/download/0.12.1/WasmEdge-image-0.12.1-android_aarch64.tar.gz

wget https://github.com/second-state/WasmEdge-tensorflow/releases/download/0.12.1/WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz

wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.12.1/WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz

tar -zxf WasmEdge-0.12.1-android_aarch64.tar.gz

tar -zxf WasmEdge-image-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/

tar -zxf WasmEdge-tensorflowlite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/

tar -zxf WasmEdge-tensorflow-deps-TFLite-0.12.1-android_aarch64.tar.gz -C WasmEdge-0.12.1-Android/lib/

```



### Compile



The following command compiles the C program to `a.out` on your Ubunu dev machine.



```bash

(/path/to/ndk)/toolchains/llvm/prebuilt/(HostPlatform)/bin/aarch64-linux-(AndroidApiVersion)-clang test.c -I./WasmEdge-0.12.1-Android/include -L./WasmEdge-0.12.1-Android/lib -lwasmedge-image_c -lwasmedge-tensorflowlite_c -ltensorflowlite_c -lwasmedge

```



## Run



### Push files onto Android



Install the compiled program, Tensorflow Lite model file, test image file, as well as WasmEdge shared library files for Android, onto the Android device using `adb` from your Ubuntu dev machine.



```bash

adb push a.out /data/local/tmp

adb push birds_v1.wasm /data/local/tmp

adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp

adb push bird.jpg /data/local/tmp

adb push ./WasmEdge-0.12.1-Android/lib /data/local/tmp

```



### Run the example



Now you can run the compiled C program on the Android device via a remote shell command. Run `adb shell` from your Ubuntu dev machine.



```bash

$ adb shell

sirius:/ $ cd /data/local/tmp

sirius:/data/local/tmp $ export LD_LIBRARY_PATH=/data/local/tmp/lib:$LD_LIBRARY_PATH

sirius:/data/local/tmp $ ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg

INFO: Initialized TensorFlow Lite runtime.

166 : 0.84705883

```








------"
"```json:/contribute/source/os/_category_.json


{

  ""label"": ""Supported Platforms"",

  ""position"": 3,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""We will learn how to build WasmEdge from source on different platfroms.""

  }

}








```"
"The following is a markdown document located at /contribute/source/os/linux.md
------


---

sidebar_position: 1

---



# Build on Linux



## Get the Source Code



```bash

git clone https://github.com/WasmEdge/WasmEdge.git

cd WasmEdge

```



## Prepare the Environment



### Docker Images



The easiest way to set up the environment is using the WasmEdge docker images.



You can use the following commands to get our latest docker image [from dockerhub](https://hub.docker.com/search?q=wasmedge):



```bash

docker pull wasmedge/wasmedge # Pulls the latest - wasmedge/wasmedge:latest

```



Or you can pull with the [available tags](../docker.md#docker-images-for-building-wasmedge).



### Install Dependencies on Ubuntu Manually



For the developers who don't want to use docker, they can set up the environment on Ubuntu Manually.



Please check that these dependencies are satisfied.



- LLVM 12.0.0 (>= 10.0.0)

- _(Optional)_ GCC 11.1.0 (>= 9.4.0), install it if you prefer to use GCC toolchain.



After `WasmEdge 0.13.0`, the `boost` dependency is not needed.



#### For Ubuntu 22.04



```bash

# Tools and libraries

sudo apt install -y \

   software-properties-common \

   cmake



# And you will need to install llvm for the AOT runtime

sudo apt install -y \

   llvm-14-dev \

   liblld-14-dev



# WasmEdge supports both clang++ and g++ compilers.

# You can choose one of them to build this project.

# If you prefer GCC, then:

sudo apt install -y gcc g++

# Or if you prefer clang, then:

sudo apt install -y clang-14

```



#### For Ubuntu 20.04



```bash

# Tools and libraries

sudo apt install -y \

   software-properties-common \

   cmake



# And you will need to install llvm for the AOT runtime

sudo apt install -y \

   llvm-12-dev \

   liblld-12-dev



# WasmEdge supports both clang++ and g++ compilers.

# You can choose one of them to build this project.

# If you prefer GCC, then:

sudo apt install -y gcc g++

# Or if you prefer clang, then:

sudo apt install -y clang-12

```



### Support for Legacy Operating Systems



Our development environment requires `libLLVM-12` and `>=GLIBCXX_3.4.33`.



If users use operating systems older than Ubuntu 20.04, please use our particular docker image to build WasmEdge. If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on `manylinux*` distributions.



| Docker Image | Base Image | Provided Requirements |

| --- | --- | --- |

| `wasmedge/wasmedge:manylinux2014_x86_64` | CentOS 7.9 | GLIBC <= 2.17<br/>CXXABI <= 1.3.7<br/>GLIBCXX <= 3.4.19<br/>GCC <= 4.8.0 |

| `wasmedge/wasmedge:manylinux2014_aarch64` | CentOS 7.9 | GLIBC <= 2.17<br/>CXXABI <= 1.3.7<br/>GLIBCXX <= 3.4.19<br/>GCC <= 4.8.0 |



## Build WasmEdge



Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.



```bash

# After pulling our wasmedge docker image

docker run -it --rm \

    -v <path/to/your/wasmedge/source/folder>:/root/wasmedge \

    wasmedge/wasmedge:latest

# In docker

cd /root/wasmedge

# If you don't use docker then you need to run only the following commands in the cloned repository root

mkdir -p build && cd build

cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. && make -j

```



## Run Tests



The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.



Users can use these tests to verify the correctness of WasmEdge binaries.



```bash

# In docker

cd <path/to/wasmedge/build_folder>

LD_LIBRARY_PATH=$(pwd)/lib/api ctest

```








------"
"The following is a markdown document located at /contribute/source/os/macos.md
------


---

sidebar_position: 2

---



# Build on macOS



Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on `Catalina`, `Big Sur`, and `Monterey`.



- Model:

  - Intel (x86_64)

  - M1, M2 (arm64)

- Operating System

  - Ventura

  - Monterey

  - Big Sur

  - Catalina



If you want to develop WasmEdge on MacOS, please follow this guide to build and test from source code.



## Get Source Code



```bash

git clone https://github.com/WasmEdge/WasmEdge.git

cd WasmEdge

```



## Requirements and Dependencies



WasmEdge will try to use the latest LLVM release to create our nightly build. If you want to build from source, you may need to install these dependencies yourself.



- LLVM 16.0.4 (>= 10.0.0)



```bash

# Tools and libraries

brew install cmake ninja llvm

export LLVM_DIR=""$(brew --prefix)/opt/llvm/lib/cmake""

export CC=clang

export CXX=clang++

```



## Build WasmEdge



Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.



```bash

cmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .

cmake --build build

```



If you don't want to link LLVM on MacOS dynamically, you can set the option `WASMEDGE_LINK_LLVM_STATIC` to `ON`.



## Run Tests



The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.



Users can use these tests to verify the correctness of WasmEdge binaries.



```bash

cd build

DYLD_LIBRARY_PATH=$(pwd)/lib/api ctest

```



## Known issues



The following tests can not pass on Macos, we are investigating these issues:



- wasmedgeWasiSocketTests



But we have an open issue working on it. Don't hesitate to leave your feedback for [this issue](https://github.com/WasmEdge/WasmEdge/issues/2438).








------"
"The following is a markdown document located at /contribute/source/os/openharmony.md
------


---

sidebar_position: 7

---



# Build on OpenHarmony



<!-- prettier-ignore -->

:::info

Work in Progress

:::

 For Chinese speakers, please [check out this instruction](https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md).








------"
"The following is a markdown document located at /contribute/source/os/openwrt.md
------


---

sidebar_position: 5

---



# Build on OpenWRT



Please follow this tutorial to build and test WasmEdge in OpenWrt(x86_64) from source code.



<!-- prettier-ignore -->

:::note

Currently, we only support the runtime for the interpreter mode.

:::



## Prepare the Environment



### OpenWrt



First, we need to obtain the source code of OpenWrt and install the relevant tools to compile OpenWrt. The following commands take Debian / Ubuntu system as an example. For commands to install OpenWrt compilation tools in other host systems, see [Building OpenWrt System Settings](https://openwrt.org/docs/guide-developer/toolchain/install-buildsystem).



```bash

$ git clone https://github.com/openwrt/openwrt

$ sudo apt update

$ sudo apt install build-essential ccache ecj fastjar file g++ gawk \

gettext git java-propose-classpath libelf-dev libncurses5-dev \

libncursesw5-dev libssl-dev python python2.7-dev python3 unzip wget \

python-distutils-extra python3-setuptools python3-dev rsync subversion \

swig time xsltproc zlib1g-dev

```



Then, obtain all the latest package definitions of OpenWrt and install the symlinks for all obtained packages.



```bash

cd openwrt

./scripts/feeds update -a

./scripts/feeds install -a

```



## Build WasmEdge



### Get WasmEdge source code



```bash

git clone https://github.com/WasmEdge/WasmEdge.git

cd WasmEdge

```



### Run the build script



Run the build script `build_for_openwrt.sh` in WasmEdge source code and input the path of the OpenWrt source code as parameter. This script will automatically add the WasmEdge into the packages list which will be built of OpenWrt, and build the OpenWrt firmware. The generated OpenWrt images are in the `openwrt/bin/targets/x86/64` folder.



```bash

./utils/openwrt/build_for_openwrt.sh ~/openwrt

```



When running the build script, the OpenWrt configuration interface will appear. In this interface, we need to set `Target System` to x86, `Target Profile` to Generic x86/64, and find `WasmEdge` in the `Runtime` column and check it. Once set up, the script automatically builds WasmEdge and compiles the OpenWrt system.



## Test



### Deploy OpenWrt in VMware



To verify the availability of WasmEdge, we use a VMware virtual machine to install the compiled OpenWrt image. Before creating a virtual machine, we must use the `QEMU` command to convert the OpenWrt image to vmdk format.



```bash

cd ~/openwrt/bin/targets/x86/64

sudo apt install qemu

gunzip openwrt-x86-64-generic-squashfs-combined.img.gz

qemu-img convert -f raw -O vmdk openwrt-x86-64-generic-squashfs-combined.img Openwrt.vmdk

```



After that, create a virtual machine in VMware and install the OpenWrt system.



### Upload the test files



After setting the IP address of OpenWrt according to the gateway of the host, use `scp` to transfer the wasm file on the host to the OpenWrt system.



For example, we set the IP address of OpenWrt as 192.168.0.111, then we use the following commands to upload [hello.wasm (compiled from this example)](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm) and [add.wasm (in text format)](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/add.wat) these two test files to OpenWrt.



```bash

scp hello.wasm root@192.168.0.111:/

scp add.wasm root@192.168.0.111:/

```



### Test the Wasmedge program



```bash

$ wasmedge hello.wasm second state

hello

second

state

$ wasmedge --reactor add.wasm add 2 2

4

```








------"
"The following is a markdown document located at /contribute/source/os/raspberrypi.md
------


---

sidebar_position: 9

---



# Build on Raspberry Pi



Raspberry Pi uses 64-bit processors starting from the 3 Model B. So WasmEdge can be executed on Raspberry Pi as well. For ARM, you can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu, or Manjaro. This document has been tested on the Manjaro for ARM distribution, and the hardware is the Raspberry Pi 3 Model B.



The installation steps are no different from the [installation document](../../../start/install.md#install), and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.



[![asciicast](https://asciinema.org/a/458453.svg)](https://asciinema.org/a/458453)








------"
"The following is a markdown document located at /contribute/source/os/riscv64.md
------


---

sidebar_position: 6

---



# Build on RISC-V 64



## Prepare the Environment



This tutorial is based on Ubuntu 22.04 host, and WasmEdge uses the [RISCV-Lab](https://gitee.com/tinylab/riscv-lab), which provides Ubuntu 22.04 system with riscv64 architecture. Here users can use their riscv64 environment.



### Install and run RISCV-Lab



```bash

git clone https://gitee.com/tinylab/cloud-lab.git

cd cloud-lab

LOGIN=bash tools/docker/run riscv-lab

```



Note that it will take a long time to pull the image here.



## Build WasmEdge



### Get Source code



```bash

ubuntu@riscv-lab:/labs/riscv-lab$ git clone https://github.com/WasmEdge/WasmEdge.git

ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge

```



### Dependencies



WasmEdge requires LLVM 12 at least and you may need to install the following dependencies yourself.



```bash

ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt-get update

ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y software-properties-common cmake

ubuntu@riscv-lab:/labs/riscv-lab$ sudo apt install -y llvm-12-dev liblld-12-dev

```



### Compile



Please refer to [here](../build_from_src.md#cmake-building-options) for the descriptions of all CMake options.



```bash

ubuntu@riscv-lab:/labs/riscv-lab$ cd WasmEdge

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge$ mkdir -p build && cd build

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cmake -DCMAKE_BUILD_TYPE=Release .. && make -j

```



## Test



### Execute the wasmedge tool



For the pure WebAssembly, the `wasmedge` CLI tool will execute it in interpreter mode.



```bash

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ sudo make install

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/build$ cd ../examples/wasm

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge -v

wasmedge version 0.12.0-alpha.1-13-g610cc21f

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor fibonacci.wasm fib 10

89

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge --reactor add.wasm add 2 2

4

```



### Execute wasmedge compile



To improve the performance, the `wasmedge compile` can compile WebAssembly into native machine code. After compiling with the `wasmedge compile` AOT compiler, the wasmedge tool can execute the WASM in AOT mode, which is much faster.



```bash

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ wasmedge compile fibonacci.wasm fibonacci_aot.wasm

[2023-02-01 22:39:15.807] [info] compile start

[2023-02-01 22:39:15.857] [info] verify start

[2023-02-01 22:39:15.866] [info] optimize start

[2023-02-01 22:39:16.188] [info] codegen start

[2023-02-01 22:39:16.403] [info] output start

[2023-02-01 22:39:16.559] [info] compile done

[2023-02-01 22:39:16.565] [info] output start

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci_aot.wasm fib 30

1346269

real    0m0.284s

user    0m0.282s

sys     0m0.005s

ubuntu@riscv-lab:/labs/riscv-lab/WasmEdge/examples/wasm$ time wasmedge --reactor fibonacci.wasm fib 30

1346269

real    0m1.814s

user    0m1.776s

sys     0m0.016s

```








------"
"The following is a markdown document located at /contribute/source/os/sel4.md
------


---

sidebar_position: 8

---



# Build on seL4 RTOS



[Video demo](https://youtu.be/2Qu-Trtkspk) | [Build logs](https://github.com/second-state/wasmedge-seL4/runs/3982081148?check_suite_focus=true) | [Build artifact](https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169)



In this article, we demonstrate how to run WasmEdge on the seL4 RTOS, there are two parts:



1. Guest Linux OS on seL4: This is the controller of WasmEdge runtime, which will send wasm program to WasmEdge runner that is a agent on seL4 to execute.

2. WasmEdge runner on seL4: This is the wasm program runtime, which will execute the given wasm program from Guest Linux OS.



The figure below illustrates the architecture of the system.



![wasmedge-sel4](wasmedge-sel4.png)



This demo is based on the seL4 simulator on Linux.



## Getting Started



### System requirements



Hardware:



- at least 4GB of RAM

- at least 20GB of disk storage (the wasmedge_sel4 directory will contain over 11 GB of data after the following installation completes)



Software: Ubuntu 20.04 with dev tools packages (ep. Python) installed. We recommend the [GitHub Actions Ubuntu 20.04 VM](https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md) (See a list of [installed apt packages](https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md#installed-apt-packages)). Or, you could use our Docker image (see the [Dockerfile](https://github.com/second-state/wasmedge-seL4/blob/main/docs/Dockerfile.sel4_build)).



```bash

$ docker pull wasmedge/sel4_build

$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build

(docker) root#

```



<!-- prettier-ignore -->

:::note

If you do not want to build the seL4 system simulator yourself, you can download the [build artifact](https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169) from our GitHub Actions, and skip directly to [Boot wasmedge-seL4](#boot-wasmedge-sel4)

:::



### Automatic installation: all-in-one script



Use our all-in-one build script:



```bash

wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash

```



And this will clone and build our wasmedge on seL4 to an image.



After finishing the build script, you will have a folder `sel4_wasmedge`.



If this automatic installation completed successfully, skip over the manual installation information and proceed to [boot wasmedge-sel4](https://github.com/second-state/wasmedge-seL4#boot-wasmedge-sel4)



### Manual installation: managing memory usage



The above all-in-one script will work in most cases. However, if your system resources were stressed and you encountered an error such as `ninja: build stopped: subcommand failed` please note that you can decrease the parallelization of the install by explicitly passing in a `-j` parameter to the `ninja` command (on the last line of the `build.sh` file). You see, Ninja runs the most amount of parallel processes by default and so the following procedure is a way to explicitly set/reduce parallelization.



Manually fetch the `wasmedge-sel4 repository.



```bash

cd ~

git clone https://github.com/second-state/wasmedge-seL4.git

cd wasmedge-seL4

```



Manually edit the `build.sh` file.



```bash

vi build.sh

```



Add the following `-j` parameter to the last line of the file i.e.



```bash

ninja -j 2

```



Make the `build.sh` file executable.



```bash

sudo chmod a+x build.sh

```



Run the edited `build.sh file.



```bash

./build.sh

```



Once this manual installation is complete, follow along with the following steps; boot wasmedge-sel4



### Boot wasmedge-seL4



```bash

cd sel4_wasmedge/build

./simulate

```



Expected output:



```bash

$ ./simulate: qemu-system-aarch64 -machine virt,virtualization=on,highmem=off,secure=off -cpu cortex-a53 -nographic  -m size=2048  -kernel images/capdl-loader-image-arm-qemu-arm-virt

ELF-loader started on CPU: ARM Ltd. Cortex-A53 r0p4

  paddr=[6abd8000..750cf0af]

No DTB passed in from boot loader.

Looking for DTB in CPIO archive...found at 6ad18f58.

Loaded DTB from 6ad18f58.

   paddr=[60243000..60244fff]

ELF-loading image 'kernel' to 60000000

  paddr=[60000000..60242fff]

  vaddr=[ff8060000000..ff8060242fff]

  virt_entry=ff8060000000

ELF-loading image 'capdl-loader' to 60245000

  paddr=[60245000..6a7ddfff]

  vaddr=[400000..a998fff]

  virt_entry=408f38

Enabling hypervisor MMU and paging

Jumping to kernel-image entry point...



Bootstrapping kernel

Warning: Could not infer GIC interrupt target ID, assuming 0.

Booting all finished, dropped to user space

<<seL4(CPU 0) [decodeUntypedInvocation/205 T0xff80bf85d400 ""rootserver"" @4006f8]: Untyped Retype: Insufficient memory (1 * 2097152 bytes needed, 0 bytes available).>>

Loading Linux: 'linux' dtb: 'linux-dtb'



...(omitted)...



Starting syslogd: OK

Starting klogd: OK

Running sysctl: OK

Initializing random number generator... [    3.512482] random: dd: uninitialized urandom read (512 bytes read)

done.

Starting network: OK

[    4.086059] connection: loading out-of-tree module taints kernel.

[    4.114686] Event Bar (dev-0) initalised

[    4.123771] 2 Dataports (dev-0) initalised

[    4.130626] Event Bar (dev-1) initalised

[    4.136096] 2 Dataports (dev-1) initalised



Welcome to Buildroot

buildroot login:

```



### Login on guest linux



Enter `root` to login



```bash

buildroot login: root

```



Expected output:



```bash

buildroot login: root

#

```



### Execute wasm examples



#### Example A: nbody-c.wasm



Run nbody simulation.



```bash

wasmedge_emit /usr/bin/nbody-c.wasm 10

```



Expected output:



```bash

[1900-01-00 00:00:00.000] [info] executing wasm file

-0.169075164

-0.169073022

[1900-01-00 00:00:00.000] [info] execution success, exit code:0

```



#### Example B: hello.wasm



Run an easy application to print `hello, sel4` and a simple calculation.



```bash

wasmedge_emit /usr/bin/hello.wasm

```



Expected output:



```bash

[1900-01-00 00:00:00.000] [info] executing wasm file

hello, sel4

1+2-3*4 = -9

[1900-01-00 00:00:00.000] [info] execution success, exit code:0

```








------"
"The following is a markdown document located at /contribute/source/os/windows.md
------


---

sidebar_position: 3

---



# Build on Windows 10



You can also find the details [here](https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/reusable-build-on-windows.yml#L37-L48).



## Get Source Code



```bash

git clone https://github.com/WasmEdge/WasmEdge.git

cd WasmEdge

```



## Requirements and Dependencies



WasmEdge requires LLVM 16 and you may need to install these following dependencies by yourself.



- [Chocolatey](https://chocolatey.org/install), we use it to install `cmake`, `ninja`, and `vswhere`.

- [Windows SDK 19041](https://blogs.windows.com/windowsdeveloper/2020/05/12/start-developing-on-windows-10-version-2004-today/)

- LLVM 16.0.6, download the pre-built files [here](https://github.com/WasmEdge/llvm-windows/releases) or you can just follow the `instructions/commands` to download automatically.



<!-- prettier-ignore -->

:::note

If you use the community version of Visual Studio, you may encounter errors like: `ninja: error: 'C:/Program Files/Microsoft Visual Studio/2022/Enterprise/DIA SDK/lib/amd64/diaguids.lib', needed by 'test/aot/wasmedgeAOTCoreTests.exe', missing and no known rule to make it`. You need to manually open the file `LLVM-16.0.6-win64/lib/cmake/llvm/LLVMExports.cmake`, search for the only occurrence of `Enterprise` and change it to `Community`. See [this issue](https://github.com/WasmEdge/WasmEdge/issues/1290#issuecomment-1056784554) for details.

:::



```powershell

# Install the required tools

choco install cmake ninja vswhere



$vsPath = (vswhere -latest -property installationPath)

# If vswhere.exe is not in PATH, try the following instead.

# $vsPath = (&""C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe"" -latest -property installationPath)



Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")

Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""



# Download our pre-built LLVM 16 binary

$llvm = ""LLVM-16.0.6-win64-MultiThreadedDLL.zip""

curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-16.0.6/LLVM-16.0.6-win64-MultiThreadedDLL.zip -o $llvm

Expand-Archive -Path $llvm



# Set LLVM environment

$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""

```



## Build WasmEdge



On Windows, either Clang-cl or MSVC can be used to build WasmEdge. To use MSVC, simply comment out the two lines that set the environment variables `CC` and `CXX`.



```powershell

$vsPath = (vswhere -latest -property installationPath)

Import-Module (Join-Path $vsPath ""Common7\Tools\Microsoft.VisualStudio.DevShell.dll"")

Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0""

# If you would like to use MSVC, and want to use a specific version of MSVC, set the arg `vcvars_ver` like the following.

# Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments ""-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0 -vcvars_ver=14.34.31933""



# Set LLVM path according to the download location

$llvm_dir = ""$pwd\LLVM-16.0.6-win64-MultiThreadedDLL\LLVM-16.0.6-win64\lib\cmake\llvm""



# Use clang-cl as the compiler.

# Comment out the following two lines to use MSVC.

$Env:CC = ""clang-cl""

$Env:CXX = ""clang-cl""



cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL ""-DLLVM_DIR=$llvm_dir"" -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=""ZIP"" .

cmake --build build

```



## Run Tests



The following tests are available only when the build option `WASMEDGE_BUILD_TESTS` was set to `ON`.



Users can use these tests to verify the correctness of WasmEdge binaries.



```powershell

$Env:PATH += "";$pwd\build\lib\api""

cd build

ctest --output-on-failure

cd -

```








------"
"```json:/contribute/source/plugin/_category_.json


{

  ""label"": ""Build Plug-ins"",

  ""position"": 4,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to build WasmEdge plug-ins from source.""

  }

}








```"
"The following is a markdown document located at /contribute/source/plugin/ebpf.md
------


---

sidebar_position: 7

---



# Build with eBPF Plug-in



The eBPF (extended Berkeley Packet Filter) plug-in provides an interface to execute eBPF programs in WasmEdge. It allows WasmEdge to execute eBPF code that is compiled into WebAssembly format. This guide will walk you through the steps to build WasmEdge with the eBPF plug-in.



## Build the eBPF Plug-in



### Prerequisites



Before building the eBPF plug-in, ensure that you have the following installed:



* WasmEdge - If you haven't installed it, follow the [follow the guide to build from source](../os/linux.md).

* libbpf - This plug-in requires `libbpf >= 1.2`. See [Building libbpf](https://github.com/libbpf/libbpf#building-libbpf) for details.



### Build steps



To build the eBPF plug-in, run the following commands at the root of the WasmEdge project:



```bash

cmake -DWASMEDGE_PLUGIN_WASM_BPF:BOOL=TRUE -B ./build -G ""Unix Makefiles""

cmake --build ./build

```



Make sure to set `WASMEDGE_PLUGIN_WASM_BPF` to `TRUE` in the command line. This toggle controls the build of the `wasm_bpf` plug-in.



## Use the eBPF Plug-in



### Download Examples



You can download examples of wasm-bpf programs from here:



```bash

wget https://eunomia-bpf.github.io/wasm-bpf/examples/runqlat/runqlat.wasm

```



### Build Examples



You can also build examples of wasm-bpf programs from the `wasm-bpf` repository:



1. Install the wasi-sdk if you don't have it:



   ```bash

   wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz

   tar -zxf wasi-sdk-17.0-linux.tar.gz

   sudo mkdir -p /opt/wasi-sdk/ && sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/

   ```



2. Build the examples:



   ```bash

   git clone https://github.com/eunomia-bpf/wasm-bpf

   cd wasm-bpf/examples

   git submodule update --init --recursive

   ```



3. For example, to build the execve example:



```bash

cd execve && make

```



The available examples are:



```bash

bootstrap  execve  go-execve  go-lsm  lsm   opensnoop runqlat  rust-bootstrap  sockfilter  sockops

```



### Run Examples



After building, you can find the plug-in at `./build/plugins/wasm_bpf/libwasmedgePluginWasmBpf.so` and the WasmEdge CLI tool at `./build/tools/wasmedge/wasmedge`.



To run the examples, set `WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/` and run wasmedge:



```bash

WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ ./build/tools/wasmedge/wasmedge execve.wasm

```



Adjust `WASMEDGE_PLUGIN_PATH` according to your build directory of the plug-in.



## Host Functions



This plug-in adds six host functions that give your Wasm application access to eBPF. All of these functions are in the module `wasm_bpf`, if you loaded this plug-in:



```c

/// lookup a bpf map fd by name.

i32 wasm_bpf_map_fd_by_name(u64 obj, u32 name);

/// detach and close a bpf program.

i32 wasm_close_bpf_object(u64 obj);

/// CO-RE load a bpf object into the kernel.

u64 wasm_load_bpf_object(u32 obj_buf, u32 obj_buf_sz);

/// attach a bpf program to a kernel hook.

i32 wasm_attach_bpf_program(u64 obj, u32 name,

                            u32 attach_target);

/// poll a bpf buffer, and call a wasm callback indicated by sample_func.

/// the first time to call this function will open and create a bpf buffer.

i32 wasm_bpf_buffer_poll(u64 program, i32 fd, u32 sample_func,

                         u32 ctx, u32 data, i32 max_size,

                         i32 timeout_ms);

/// lookup, update, delete, and get_next_key operations on a bpf map.

i32 wasm_bpf_map_operate(u64 fd, i32 cmd, u32 key, u32 value,

                         u32 next_key, u64 flags);

```



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_bpf).








------"
"The following is a markdown document located at /contribute/source/plugin/image.md
------


---

sidebar_position: 4

---



# Build WasmEdge With WasmEdge-Image Plug-in



The WasmEdge Image plug-in is a software component that extends the functionality of the WasmEdge runtime, enabling it to load and decode JPEG and PNG images and convert them into tensors. This plug-in is useful for developers who need to process image data within their WebAssembly applications.



## Prerequisites



The prerequisites of the WasmEdge-Image plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).



If developers build with their own environment, please ensure the `zlib` and `libboost-all-dev` are installed.



```bash

sudo apt update

sudo apt install zlib1g-dev libboost-all-dev

```



On MacOS platforms, the `libjpeg` and `libpng` are required.



```bash

brew install jpeg-turbo libpng

```



## Build WasmEdge with WasmEdge-Image Plug-in



To enable the WasmEdge WasmEdge-Image, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_IMAGE=On`.



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_IMAGE=On

cmake --build build

# For the WasmEdge-Image plug-in, you should install this project.

cmake --install build

```



<!-- prettier-ignore -->

:::note

If the built `wasmedge` CLI tool cannot find the WasmEdge-Image plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_image/`) to try to fix this issue.

:::



Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Image plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeImage.so` after installation.



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_image).








------"
"The following is a markdown document located at /contribute/source/plugin/process.md
------


---

sidebar_position: 3

---



# Build WasmEdge With WasmEdge-Process Plug-in



The WasmEdge Process plug-in provides a sandboxed environment to execute system processes in a secured manner. This guide will walk you through the steps to build the WasmEdge Process plug-in.



## Prerequisites



The prerequisites of the WasmEdge-Process plug-in is the same as the [WasmEdge building environment on the Linux platforms](../os/linux.md).



## Build WasmEdge with WasmEdge-Process Plug-in



To enable the WasmEdge WasmEdge-Process, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_PROCESS=On`.



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_PROCESS=On

cmake --build build

# For the WasmEdge-Process plug-in, you should install this project.

cmake --install build

```



<!-- prettier-ignore -->

:::note

If the built `wasmedge` CLI tool cannot find the WasmEdge-Process plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_process/`) to try to fix this issue.

:::



Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Process plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeProcess.so` after installation.



## Usage



To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:



```bash

wasmedge --dir .:. --reactor --process_plugin target/release/libwasmedge_process.so your_wasm_file.wasm

```



Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--process_plugin`flag specifies the path to the Process plug-in.



That's it! You have successfully built and installed the WasmEdge Process plug-in.



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_process).








------"
"The following is a markdown document located at /contribute/source/plugin/rusttls.md
------


---

sidebar_position: 8

---



# (DEPRECATED after `0.14.0`) Build with Rustls Plug-in



<!-- prettier-ignore -->

:::note

This plug-in has been deprecated after WasmEdge `0.14.0` because the `rustls` is replaced by [`reqwest`](../../../develop/rust/http_service/client.md#the-reqwest-api).

:::



The WasmEdge Rustls plug-in is a replacement for the OpenSSL plug-in in WasmEdge. It provides a Rust-friendly interface to the Rustls library, which is a modern, fast, and more secure alternative to OpenSSL.



Here's a step-by-step guide on how to build the WasmEdge Rustls plug-in:



## Prerequisites



Ensure the following dependencies are installed on your system:



- Rust: You can install it from the [official website](https://www.rust-lang.org/tools/install).

- CMake: Minimum version 3.12. Install it from the [official website](https://cmake.org/download/).



## Clone the WasmEdge Repository



First, clone the WasmEdge repository from GitHub:



```bash

git clone https://github.com/WasmEdge/WasmEdge.git

```



## Navigate to the Rustls Plug-in Directory



Navigate to the `wasmedge_rustls` directory within the cloned repository:



```bash

cd WasmEdge/plugins/wasmedge_rustls

```



## Build the Plug-in



Now you can build the Rustls plug-in. Run the following command:



```bash

cargo build --release

```



This command builds the plug-in in release mode. The compiled binary will be located in the `target/release` directory.



## Install the Plug-in



To install the plug-in, you can use the `cargo install` command:



```bash

cargo install --path .

```



This command will install the built plug-in into your Rust binary directory.



## Usage



To use the plug-in with WasmEdge, you need to specify it when starting the WasmEdge runtime:



```bash

wasmedge --dir .:. --reactor --rustls_plugin target/release/libwasmedge_rustls.so your_wasm_file.wasm

```



Replace `your_wasm_file.wasm` with the path to your WebAssembly file. The `--rustls_plugin` flag specifies the path to the Rustls plug-in.



That's it! You have successfully built and installed the WasmEdge Rustls plug-in. Please ensure to replace the OpenSSL plug-in with the Rustls plug-in in your WasmEdge runtime configuration if you were previously using OpenSSL.



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_rustls).








------"
"The following is a markdown document located at /contribute/source/plugin/tensorflow.md
------


---

sidebar_position: 5

---



# Build WasmEdge With WasmEdge-Tensorflow Plug-in



The WasmEdge-TensorFlow plug-in is a software component that extends the functionality of the WasmEdge runtime. It allows developers to perform TensorFlow model inference with similar APIs to Python. The plug-in is designed for Rust to WebAssembly applications and depends on the TensorFlow C library for its operations.



## Prerequisites



The prerequisites of the WasmEdge-Tensorflow plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).



## Build WasmEdge with WasmEdge-Tensorflow Plug-in



To enable the WasmEdge WasmEdge-Tensorflow, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOW=On`.



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOW=On

cmake --build build

# For the WasmEdge-Tensorflow plug-in, you should install this project.

cmake --install build

```



<!-- prettier-ignore -->

:::note

If the built `wasmedge` CLI tool cannot find the WasmEdge-Tensorflow plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflow/`) to try to fix this issue.

:::



Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-Tensorflow plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflow.so` after installation.



## Install the TensorFlow Dependency



Installing the necessary `libtensorflow_cc.so` and `libtensorflow_framework.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:



```bash

curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.

# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_x86_64.tar.gz`.

# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-darwin_arm64.tar.gz`.

tar -zxf WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

rm -f WasmEdge-tensorflow-deps-TF-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

```



The shared library will be extracted in the current directory `./libtensorflow_cc.so.2.12.0` and `./libtensorflow_framework.so.2.12.0` on `Linux` platforms, or `./libtensorflow_cc.2.12.0.dylib` and `./libtensorflow_framework.2.12.0.dylib` on `MacOS` platforms.



<!-- prettier-ignore -->

:::note

After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tf-src/` directory.

:::



Then you can move the library to the installation path and create the symbolic link:



```bash

mv libtensorflow_cc.so.2.12.0 /usr/local/lib

mv libtensorflow_framework.so.2.12.0 /usr/local/lib

ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2

ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so

ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2

ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so

```



If on `MacOS` platforms:



```bash

mv libtensorflow_cc.2.12.0.dylib /usr/local/lib

mv libtensorflow_framework.2.12.0.dylib /usr/local/lib

ln -s libtensorflow_cc.2.12.0.dylib /usr/local/lib/libtensorflow_cc.2.dylib

ln -s libtensorflow_cc.2.dylib /usr/local/lib/libtensorflow_cc.dylib

ln -s libtensorflow_framework.2.12.0.dylib /usr/local/lib/libtensorflow_framework.2.dylib

ln -s libtensorflow_framework.2.dylib /usr/local/lib/libtensorflow_framework.dylib

```



Or create the symbolic link in the current directory and set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflow).








------"
"The following is a markdown document located at /contribute/source/plugin/tensorflowlite.md
------


---

sidebar_position: 6

---



# Build WasmEdge With WasmEdge-TensorflowLite Plug-in



The WasmEdge-TensorflowLite plug-in is a software component that extends the functionality of the WasmEdge runtime to perform TensorFlow-Lite model inference. It allows WebAssembly applications to access TensorFlow-Lite functionality when executed on the WasmEdge runtime. The plugin provides a bridge between the WasmEdge runtime and the TensorFlow-Lite backend, allowing developers to execute machine learning models within WebAssembly applications.



## Prerequisites



The prerequisites of the WasmEdge-TensorflowLite plug-in is the same as the WasmEdge building environment on the [Linux platforms](../os/linux.md) or [MacOS platforms](../os/macos.md).



## Build WasmEdge with WasmEdge-TensorflowLite Plug-in



To enable the WasmEdge WasmEdge-TensorflowLite, developers need to [building the WasmEdge from source](../build_from_src.md) with the cmake option `-DWASMEDGE_PLUGIN_TENSORFLOWLITE=On`.



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_TENSORFLOWLITE=On

cmake --build build

# For the WasmEdge-TensorflowLite plug-in, you should install this project.

cmake --install build

```



<!-- prettier-ignore -->

:::note

If the built `wasmedge` CLI tool cannot find the WasmEdge-TensorflowLite plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasmedge_tensorflowlite/`) to try to fix this issue.

:::



Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WasmEdge-TensorflowLite plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasmEdgeTensorflowLite.so` after installation.



## Install the TensorFlowLite Dependency



Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Linux` and `MacOS` platforms, we recommend the following commands:



```bash

curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

# For the Linux aarch64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_aarch64.tar.gz`.

# For the MacOS x86_64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_x86_64.tar.gz`.

# For the MacOS arm64 platforms, please use the `WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-darwin_arm64.tar.gz`.

tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

```



The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so` on `Linux` platforms, or `./libtensorflowlite_c.dylib` and `./libtensorflowlite_flex.dylib` on `MacOS` platforms.



<!-- prettier-ignore -->

:::note

After building the plug-in, you can also find these shared libraries under the `build/_deps/wasmedge_tensorflow_lib_tflite-src/` directory.

:::



Then you can move the library to the installation path:



```bash

mv libtensorflowlite_c.so /usr/local/lib

mv libtensorflowlite_flex.so /usr/local/lib

```



If on `MacOS` platforms:



```bash

mv libtensorflowlite_c.dylib /usr/local/lib

mv libtensorflowlite_flex.dylib /usr/local/lib

```



Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_tensorflowlite).








------"
"The following is a markdown document located at /contribute/source/plugin/wasi_crypto.md
------


---

sidebar_position: 1

---



# Build with WASI-Crypto Plug-in



WebAssembly System Interface (WASI) Crypto is a proposal for a set of APIs that provide cryptographic operations for WebAssembly modules. It aims to provide a consistent, portable, and secure interface for cryptographic operations across different platforms. The WasmEdge WASI-Crypto plug-in is an implementation of this proposal, providing cryptographic functionalities to WebAssembly applications running on the WasmEdge runtime.



## Prerequisites



Currently, WasmEdge used `OpenSSL 1.1` or `3.0` for the WASI-Crypto implementation.



For installing `OpenSSL 1.1` development package on `Ubuntu 20.04`, we recommend the following commands:



```bash

sudo apt update

sudo apt install -y libssl-dev

```



For legacy systems such as `CensOS 7.6`, or if you want to build `OpenSSL 1.1` from source, you can refer to the following commands:



```bash

# Download and extract the OpenSSL source to the current directory.

curl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz

echo ""40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz"" | sha256sum -c

tar -xf openssl-1.1.1n.tar.gz

cd ./openssl-1.1.1n

# OpenSSL configure need newer perl.

curl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz

tar -xf perl-5.34.0.tar.gz

cd perl-5.34.0

mkdir localperl

./Configure -des -Dprefix=$(pwd)/localperl/

make -j

make install

export PATH=""$(pwd)/localperl/bin/:$PATH""

cd ..

# Configure by previous perl.

mkdir openssl

./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl

make -j

make test

make install

cd ..

# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.

# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.

```



For MacOS platforms, you should install the `openssl`:



```bash

brew install openssl

```



<!-- prettier-ignore -->

:::note

We'll soon update this chapter to use `OpenSSL 3.0`.

:::



## Build WasmEdge with WASI-Crypto Plug-in



To enable the WasmEdge WASI-Crypto, developers need to [building the WasmEdge from source](../os/linux.md) with the cmake option `-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON`.



```bash

cd <path/to/your/wasmedge/source/folder>

# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=<path/to/openssl>`.

# On MacOS, it may be: `-DOPENSSL_ROOT_DIR=$(brew --prefix)/opt/openssl`

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On

cmake --build build

# For the WASI-Crypto plug-in, you should install this project.

cmake --install build

```



<!-- prettier-ignore -->

:::note

If the built `wasmedge` CLI tool cannot find the WASI-Crypto plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_crypto/`) to try to fix this issue.

:::



Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Crypto plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiCrypto.so` after installation.



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_crypto).








------"
"The following is a markdown document located at /contribute/source/plugin/wasi_logging.md
------


---

sidebar_position: 1

---



# Build WasmEdge With WASI-Logging Plug-in



WASI-Logging allows WebAssembly applications to log messages in a standardized way. This becomes particularly helpful when debugging applications or understanding the flow of execution within them. The WASI-Logging plug-in is designed to be straightforward to use, enabling developers to focus more on their application logic and less on logging mechanics.



<!-- prettier-ignore -->

:::note

In WasmEdge `0.14.1` version, this plug-in is bundled into the WasmEdge library and not generate the plug-in shared library.

The plug-in building architecture will be refactored in the future. Therefore we reserve this page for documentation before `0.14.0` versions.

:::



## Prerequisites



The prerequisite of the Wasi-Logging plug-in is the same as the WasmEdge building environment on the [Linux](../os/linux.md) and [MacOS](../os/macos.md) platforms.



## Build WasmEdge with WASI-Logging Plug-in



To enable the WASI-Logging Plug-in, developers need to build the WasmEdge from source with the cmake option `-DWASMEDGE_PLUGIN_WASI_LOGGING=ON`.



```bash

cd <path/to/your/wasmedge/source/folder>

mkdir -p build && cd build

cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_LOGGING=ON .. && make -j

# For the WASI-Logging plug-in, you should install this project.

cmake --install .

```



<!-- prettier-ignore -->

:::note

If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (`/usr/local/lib/wasmedge`, or the built plug-in path `build/plugins/wasi_logging`) to try to fix this issue. You should find `libwasmedgePluginWasiLogging.so` in your `WASMEDGE_PLUGIN_PATH`

:::



Then you will have an executable `wasmedge` runtime under `/usr/local/bin` and the WASI-Logging plugin under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so` after installation.



## Loading WASI-Logging Plug-in



If the built `wasmedge` CLI tool cannot find the WASI-Logging plug-in, set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_logging/`) to resolve this issue 1.



After installation, the `wasmedge` runtime will be located under `/usr/local/bin` and the WASI-Logging plug-in under `/usr/local/lib/wasmedge/libwasmedgePluginWasiLogging.so`.



## Using WASI-Logging in Your Applications



You can use the WASI-Logging plug-in in your WebAssembly applications to log messages in a standardized way.



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/wasi-logging).








------"
"The following is a markdown document located at /contribute/source/plugin/wasi_nn.md
------


---

sidebar_position: 2

---



# Build with WASI-NN Plug-in



The WASI-NN plug-in is a proposed WebAssembly System Interface (WASI) API for machine learning. It allows WebAssembly programs to access host-provided machine learning functions.



## Prerequisites



Currently, WasmEdge supports following backends for WASI-NN proposal:



| Backend | Dependency | CMake Option |

|---------|------------|--------------|

| [OpenVINO](#build-wasmedge-with-wasi-nn-openvino-backend) | [OpenVINO™ (2023)](https://docs.openvino.ai/2023.0/openvino_docs_install_guides_installing_openvino_apt.html) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=OpenVINO` |

| [TensorFlow-Lite](#build-wasmedge-with-wasi-nn-tensorflow-lite-backend) | [TensorFlow Lite](https://www.tensorflow.org/install/lang_c) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=TensorFlowLite` |

| [PyTorch](#build-wasmedge-with-wasi-nn-pytorch-backend) | [PyTorch 1.8.2 LTS](https://pytorch.org/get-started/locally/) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=PyTorch` |

| [GGML](#build-wasmedge-with-wasi-nn-pytorch-backend) | [llama.cpp](https://github.com/ggerganov/llama.cpp) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=GGML` |

| [Piper](#build-wasmedge-with-wasi-nn-piper-backend) | [Piper](https://github.com/rhasspy/piper) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=Piper` |

| [Whisper](#build-wasmedge-with-wasi-nn-whisper-backend) | [whisper.cpp](https://github.com/ggerganov/whisper.cpp) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=Whisper` |

| [ChatTTS](#build-wasmedge-with-wasi-nn-chattts-backend) | [ChatTTS](https://github.com/2noise/ChatTTS) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ChatTTS` |

| [MLX](#build-wasmedge-with-wasi-nn-mlx-backend) | [MLX](https://github.com/ml-explore/mlx) | `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=MLX` |



Developers can [build the WasmEdge from source](../os/linux.md) with the cmake option `WASMEDGE_PLUGIN_WASI_NN_BACKEND` to enable the backends. For supporting multiple backends, developers can assign the option such as `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML;Whisper;TensorFlowLite""`.



After building, you will have the WASI-NN with specified backend(s) plug-in shared library under `<YOUR_BUILD_FOLDER>/plugins/wasi_nn/libwasmedgePluginWasiNN.so` (or `.dylib` extension on MacOS).



<!-- prettier-ignore -->

:::note

If the `wasmedge` CLI tool cannot find the WASI-NN plug-in, you can set the `WASMEDGE_PLUGIN_PATH` environment variable to the plug-in installation path (such as `/usr/local/lib/wasmedge/`, or the built plug-in path `build/plugins/wasi_nn/`) to try to fix this issue.

:::



For the `Burn.rs` backend, please use the cmake option `WASMEDGE_PLUGIN_WASI_NN_BURNRS_MODEL` to assign the model.



| Model for `Burn.rs` backend | CMake Option |

|-------|--------------|

| Squeezenet | `-WASMEDGE_PLUGIN_WASI_NN_BURNRS_MODEL=Squeezenet` |

| Whisper | `-WASMEDGE_PLUGIN_WASI_NN_BURNRS_MODEL=Whisper` |



After building, you will have the WASI-NN with specified backend(s) plug-in shared library under `<YOUR_BUILD_FOLDER>/plugins/wasi_nn_burnrs/libwasmedgePluginWasiNN.so` (or `.dylib` extension on MacOS).



<!-- prettier-ignore -->

:::note

The `WASI-NN Burn.rs` backend cannot build with other backends.

:::



## Build WasmEdge with WASI-NN OpenVINO Backend



For choosing and installing OpenVINO™ on `Ubuntu 20.04` for the backend, we recommend the following commands:



```bash

wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB

sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB

echo ""deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main"" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list

sudo apt update

sudo apt-get -y install openvino

ldconfig

```



Then build and install WasmEdge from source:



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""OpenVINO""

cmake --build build

```



## Build WasmEdge with WASI-NN PyTorch Backend



For choosing and installing PyTorch on `Ubuntu 20.04` for the backend, we recommend the following commands:



```bash

export PYTORCH_VERSION=""1.8.2""

curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip

unzip -q ""libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""

rm -f ""libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""

export LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}

export Torch_DIR=$(pwd)/libtorch

```



For the legacy operating system such as `CentOS 7.6`, please use the `pre-cxx11-abi` version of `libtorch` instead:



```bash

export PYTORCH_VERSION=""1.8.2""

curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip

unzip -q ""libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""

rm -f ""libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""

export LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}

export Torch_DIR=$(pwd)/libtorch

```



The PyTorch library will be extracted in the current directory `./libtorch`.



Then build and install WasmEdge from source:



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""PyTorch""

cmake --build build

```



## Build WasmEdge with WASI-NN TensorFlow-Lite Backend



You can build and install WasmEdge from source directly (on `Linux x86_64`, `Linux aarch64`, `MacOS x86_64`, or `MacOS arm64` platforms):



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""TensorflowLite""

cmake --build build

```



Installing the necessary `libtensorflowlite_c.so` and `libtensorflowlite_flex.so` on both `Ubuntu 20.04` and `manylinux2014` for the backend, we recommend the following commands:



```bash

curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

tar -zxf WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

rm -f WasmEdge-tensorflow-deps-TFLite-TF-2.12.0-CC-manylinux2014_x86_64.tar.gz

```



The shared library will be extracted in the current directory `./libtensorflowlite_c.so` and `./libtensorflowlite_flex.so`.



Then you can move the library to the installation path:



```bash

mv libtensorflowlite_c.so /usr/local/lib

mv libtensorflowlite_flex.so /usr/local/lib

```



Or set the environment variable `export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH}`.



<!-- prettier-ignore -->

:::note

We also provided the `darwin_x86_64`, `darwin_arm64`, and `manylinux_aarch64` versions of the TensorFlow-Lite pre-built shared libraries.

:::



For more information, you can refer to the [GitHub repository](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasi_nn).



## Build WasmEdge with WASI-NN llama.cpp Backend



You don't need to install any llama.cpp libraries. WasmEdge will download it during the building period.



Due to the acceleration frameworks being various, you will need to use different compilation options to build this plugin. Please make sure you are following the same OS section to do this.



### Build with llama.cpp Backend on MacOS



#### Intel Model



If you are using the Intel Model macOS, we won't enable any acceleration framework. It is a pure CPU mode plugin.



```bash

cd <path/to/your/wasmedge/source/folder>

# Disable BLAS and METAL on x86_64 macOS.

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \

  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=OFF \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \

  .

cmake --build build

```



#### Apple Silicon Model



You can build and install WasmEdge from source directly on the macOS arm64 platform. It will use the built-in GPU by default.



```bash

cd <path/to/your/wasmedge/source/folder>

# Enable METAL on arm64 macOS.

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \

  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_METAL=ON \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \

  .

cmake --build build

```



### Build with llama.cpp Backend on Linux



#### Ubuntu/Debian with CUDA 12



Please follow the official guide provided by NVIDIA for installing the CUDA framework: <https://developer.nvidia.com/cuda-12-2-0-download-archive>



```bash

cd <path/to/your/wasmedge/source/folder>



# You may need to install dependencies

apt update

apt install -y software-properties-common lsb-release \

  cmake unzip pkg-config



# Due to cuda-related files, it will produce some warning.

# Disable the warning as an error to avoid failures.

export CXXFLAGS=""-Wno-error""

# Please make sure you set up the correct CUDAARCHS.

# We use `60;61;70` for maximum compatibility.

export CUDAARCHS=""60;61;70""



# BLAS cannot work with CUBLAS

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \

  -DCMAKE_CUDA_ARCHITECTURES=""60;61;70"" \

  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \

  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \

  .



cmake --build build

```



#### Ubuntu on NVIDIA Jetson AGX Orin



You should use the pre-built OS image from the NVIDIA official site.



```bash

cd <path/to/your/wasmedge/source/folder>



# Due to cuda-related files, it will produce some warning.

# Disable the warning as an error to avoid failures.

export CXXFLAGS=""-Wno-error""

# Please make sure you set up the correct CUDAARCHS.

# 72 is for NVIDIA Jetson AGX Orin

export CUDAARCHS=72



# BLAS cannot work with CUBLAS

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \

  -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \

  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON \

  .



cmake --build build

```



#### Ubuntu/Debian with OpenBLAS



Please install OpenBLAS before building the plugin.



```bash

cd <path/to/your/wasmedge/source/folder>



# You may need to install dependencies

apt update

apt install -y software-properties-common lsb-release \

  cmake unzip pkg-config

# You must install OpenBLAS

apt install libopenblas-dev



cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \

  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=ON \

  .



cmake --build build

```



#### General Linux without any acceleration framework



```bash

cd <path/to/your/wasmedge/source/folder>



cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release \

  -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""GGML"" \

  -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_BLAS=OFF \

  .



cmake --build build

```



### Build with llama.cpp Backend on Windows



#### Install Dependencies for llama.cpp And Build on Windows



Developers can follow the steps for installing the requested dependencies.



1. (Optional, skip this deps if you don't need to use GPU) Download and install CUDA toolkit

    - We use CUDA Toolkit 12 for the release assets

    - Link: <https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=11&target_type=exe_local>



2. Download and install Visual Studio 2022 Community Edition

    - Link: <https://visualstudio.microsoft.com/vs/community/>

    - Select the following components in the installer:

        - msvc v143 - vs 2022 c++ x64/x86 build tools (latest)

        - windows 11 sdk (10.0.22621.0)

        - C++ ATL for v143 build tools (x86 & x64)



3. Download and install cmake

    - We use cmake 3.29.3 for the release assets

    - Link: <https://github.com/Kitware/CMake/releases/download/v3.29.3/cmake-3.29.3-windows-x86_64.msi>



4. Download and install git

    - We use git 2.45.1

    - Link: <https://github.com/git-for-windows/git/releases/download/v2.45.1.windows.1/Git-2.45.1-64-bit.exe>



5. Download and install ninja-build

    - We use ninja-build 1.12.1

    - Link: <https://github.com/ninja-build/ninja/releases/download/v1.12.1/ninja-win.zip>

    - Installation: just unzip it to a custom folder



Then developers can build by following the steps.



1. Open Developer PowerShell for VS 2022

    - Start -> Visual Studio 2022 -> Visual Studio Tools -> Developer PowerShell for VS 2022



2. Inside the PowerShell, use git to download wasmedge repo



    ```console

    cd $HOME

    git clone https://github.com/WasmEdge/WasmEdge.git

    cd WasmEdge

    ```



3. Compile wasmedge with enabling the `wasi_nn_ggml` related options, please use the following commands. To build the plugin, you don't need to enable AOT/LLVM related features, so set them to OFF.



   - If you want to enable CUDA:



      ```console

      # CUDA ENABLE:

      & ""C:\Program files\CMake\bin\cmake.exe"" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_PLUGIN_WASI_NN_GGML_LLAMA_CUBLAS=ON -DWASMEDGE_USE_LLVM=OFF .

      & ""<the ninja-build folder>\ninja.exe"" -C build

      ```



   - If you want to disable CUDA:



      ```console

      # CUDA DISABLE:

      & ""C:\Program files\CMake\bin\cmake.exe"" -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=ggml -DWASMEDGE_USE_LLVM=OFF .

      & ""<the ninja-build folder>\ninja.exe"" -C build

      ```



#### Execute the WASI-NN plugin with the llama example on Windows



1. Set the environment variables



    ```console

    $env:PATH += "";$pwd\build\lib\api""

    $env:WASMEDGE_PLUGIN_PATH = ""$pwd\build\plugins""

    ```



2. Download the wasm and run



    ```console

    wget https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/wasmedge-ggml/llama/wasmedge-ggml-llama.wasm

    wget https://huggingface.co/QuantFactory/Meta-Llama-3-8B-Instruct-GGUF/blob/main/Meta-Llama-3-8B-Instruct.Q5_K_M.gguf

    wasmedge --dir .:. --env llama3=true --env n_gpu_layers=100 --nn-preload default:GGML:AUTO:Meta-Llama-3-8B-Instruct.Q5_K_M.gguf wasmedge-ggml-llama.wasm default

    ```



### Appendix for llama.cpp backend



We also provided the pre-built ggml plugins on the following platforms:



- darwin\_x86\_64: Intel Model macOS

- darwin\_arm64: Apple Silicon Model macOS

- ubuntu20.04\_x86\_64: x86\_64 Linux (the glibc is using Ubuntu20.04 one)

- ubuntu20.04\_aarch64: aarch64 Linux (the glibc is using Ubuntu20.04 one)

- ubuntu20.04\_blas\_x86\_64: x86\_64 Linux with OpenBLAS support (the glibc is using Ubuntu20.04 one)

- ubuntu20.04\_blas\_aarch64: aarch64 Linux with OpenBLAS support (the glibc is using Ubuntu20.04 one)

- ubuntu20.04\_cuda\_x86\_64: x86\_64 Linux with CUDA 12 support (the glibc is using Ubuntu20.04 one)

- ubuntu20.04\_cuda\_aarch64: aarch64 Linux with CUDA 11 support (the glibc is using Ubuntu20.04 one), for NVIDIA Jetson AGX Orin

- manylinux2014\_x86\_64: x86\_64 Linux (the glibc is using CentOS 7 one)

- manylinux2014\_aarch64: aarch64 Linux (the glibc is using CentOS 7 one)



## Build WasmEdge with WASI-NN Piper Backend



Build and install WasmEdge from source:



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""Piper""

cmake --build build

```



## Build WasmEdge with WASI-NN Whisper Backend



Build and install WasmEdge from source:



```bash

cd <path/to/your/wasmedge/source/folder>

cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""Whisper""

cmake --build build

```



## Build WasmEdge with WASI-NN ChatTTS Backend



The ChatTTS backend relies on ChatTTS and Python library, we recommend the following commands to install dependencies.



```bash

sudo apt update

sudo apt upgrade

sudo apt install python3-dev

pip install chattts==0.1.1

```



Then build and install WasmEdge from source:



``` bash

cd <path/to/your/wasmedge/source/folder>



cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""chatTTS""

cmake --build build

```



## Build WasmEdge with WASI-NN MLX Backend



You can directly build and install WasmEdge from source or custom install mlx and set `CMAKE_INSTALL_PREFIX` variable.



Build and install WasmEdge from source:



``` bash

cd <path/to/your/wasmedge/source/folder>



cmake -GNinja -Bbuild -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=""mlx""

cmake --build build

```








------"
"```json:/contribute/source/_category_.json


{

  ""label"": ""Build WasmEdge from source"",

  ""position"": 2,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Here's the guides for building WasmEdge and its plug-ins from source on various platforms.""

  }

}








```"
"The following is a markdown document located at /contribute/source/build_from_src.md
------


---

sidebar_position: 1

---



# Build Guide



Please follow this guide to build and test WasmEdge from the source code.



- [Linux](os/linux.md)

- [MacOS](os/macos.md)

- [Windows](os/windows.md)

- [Android](/category/build-and-run-wasmedge-on-android)

- [OpenWrt](os/openwrt.md)

- [RISC-V](os/riscv64.md)

- [OpenHarmony](os/openharmony.md)

- [seL4](os/sel4)

- [Raspberry Pi](os/raspberrypi.md)



<!-- prettier-ignore -->

:::note

If you just want the latest builds from the `HEAD` of the `master` branch, and do not want to build it yourself, you can download the release package directly from our Github Action's CI artifact. [Here is an example](https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts).

:::



## What Will Be Built



WasmEdge provides various tools for enabling different runtime environments for optimal performance. You can find that there are several wasmedge related tools:



1. `wasmedge` is the general wasm runtime.

   - `wasmedge` executes a `WASM` file in the interpreter mode or a compiled `WASM` file in the ahead-of-time compilation mode.

   - To disable building all tools, you can set the CMake option `WASMEDGE_BUILD_TOOLS` to `OFF`.

2. `wasmedgec` is the ahead-of-time `WASM` compiler.



   - `wasmedgec` compiles a general `WASM` file into a compiled `WASM` file.

   - To disable building the ahead-of-time compiler only, you can set the CMake option `WASMEDGE_BUILD_AOT_RUNTIME` to `OFF`.



   <!-- prettier-ignore -->

   :::note

   The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.

   :::



3. `libwasmedge.so` is the WasmEdge C API shared library. (`libwasmedge.dylib` on MacOS and `wasmedge.dll` on Windows)

   - `libwasmedge.so`, `libwasmedge.dylib`, or `wasmedge.dll` provides the C API for the ahead-of-time compiler and the WASM runtime.

   - The APIs related to the ahead-of-time compiler will always fail if the CMake option `WASMEDGE_BUILD_AOT_RUNTIME` is set as `OFF`.

   - To disable building just the shared library, you can set the CMake option `WASMEDGE_BUILD_SHARED_LIB` to `OFF`.

4. `ssvm-qitc` is for AI applications and supports the ONNC runtime for AI models in the ONNX format.

   - If you want to try `ssvm-qitc`, please refer to [ONNC-Wasm](https://github.com/ONNC/onnc-wasm) project to set up the working environment and tryout several examples.

   - And here is our [tutorial for ONNC-WASM project(YouTube Video)](https://www.youtube.com/watch?v=cbiPuHMS-iQ).



## CMake Building Options



Developers can set the CMake options to customize the WasmEdge building.



1. `WASMEDGE_BUILD_TESTS`: build the WasmEdge tests. Default is `OFF`.

2. `WASMEDGE_USE_LLVM`: build with LLVM-based runtime for supporting Ahead-of-Time and Just-In-Time compiler. Default is `ON`.

3. `WASMEDGE_BUILD_SHARED_LIB`: build the WasmEdge shared library (`libwasmedge.so`, `libwasmedge.dylib`, or `wasmedge.dll`). Default is `ON`.

   - By default, the WasmEdge shared library will link to the LLVM shared library.

4. `WASMEDGE_BUILD_STATIC_LIB`: build the WasmEdge static library (`libwasmedge.a`, Linux and MacOS platforms, experimental). Default is `OFF`.

   - If this option is set as `ON`, the option `WASMEDGE_FORCE_DISABLE_LTO` will forcefully be set as `ON`.

   - If this option is set as `ON`, the `libz` and `libtinfo` on Linux platforms will be statically linked.

   - For linking with `libwasmedge.a`, developers should also add the `-ldl`, `-pthread`, `-lm`, and `-lstdc++` linker options on both Linux and MacOS platforms, and `-lrt` on Linux platforms.

5. `WASMEDGE_BUILD_TOOLS`: build the `wasmedge` and `wasmedgec` tools. Default is `ON`.

   - The `wasmedge` and `wasmedgec` tools will link to the WasmEdge shared library by default.

   - If this option is set as `ON` and `WASMEDGE_USE_LLVM` is set as `OFF`, the `wasmedgec` tool for the AOT compiler will not be built.

   - If this option is set as `ON` but the option `WASMEDGE_LINK_TOOLS_STATIC` is set as `OFF`, the option `WASMEDGE_BUILD_SHARED_LIB` will forcefully be set as `ON`.

   - If this option and the option `WASMEDGE_LINK_TOOLS_STATIC` are both set as `ON`, the `WASMEDGE_LINK_LLVM_STATIC` and `WASMEDGE_BUILD_STATIC_LIB` will both be set as `ON`, and the `wasmedge` and `wasmedgec` tools will link to the WasmEdge static library instead. In this case, the plug-ins will not work in tools.

6. `WASMEDGE_BUILD_PLUGINS`: build the WasmEdge plug-ins. Default is `ON`.

7. `WASMEDGE_BUILD_EXAMPLE`: build the WasmEdge examples. Default is `OFF`.

8. `WASMEDGE_FORCE_DISABLE_LTO`: forcefully turn off the link time optimization. Default is `OFF`.

9. `WASMEDGE_LINK_LLVM_STATIC`: link the LLVM and lld libraries statically (Linux and MacOS platforms only). Default is `OFF`.

10. `WASMEDGE_LINK_TOOLS_STATIC`: make the `wasmedge` and `wasmedgec` tools to link the WasmEdge library and LLVM libraries statically (Linux and MacOS platforms only). Default is `OFF`.

    - If the option `WASMEDGE_BUILD_TOOLS` and this option are both set as `ON`, the `WASMEDGE_LINK_LLVM_STATIC` will be set as `ON`.

11. `WASMEDGE_ENABLE_UB_SANITIZER`: enable the undefined behavior sanitizer. Default is `OFF`.

12. `WASMEDGE_PLUGIN_WASI_NN_BACKEND`: build the WasmEdge WASI-NN plug-in (Linux platforms only). Default is empty.

    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

    - To build the WASI-NN plug-in with backend, please use `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=<backend_name>`.

    - To build the WASI-NN plug-in with multiple backends, please use `-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=<backend_name1>,<backend_name2>`.

13. `WASMEDGE_PLUGIN_WASI_CRYPTO`: build the WasmEdge WASI-Crypto plug-in (Linux and MacOS platforms only). Default is `OFF`.

    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

14. `WASMEDGE_PLUGIN_WASI_LOGGING`: build the WasmEdge WASI-Logging plug-in (Linux and MacOS platforms only). Default is `ON`.

    - In WasmEdge `0.14.1`, the WASI-Logging plug-in is bundled into the WasmEdge library and will not generate the plug-in shared library target.

    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

15. `WASMEDGE_PLUGIN_WASM_BPF`: build the WasmEdge wasm_bpf plugin (Linux platforms only). Default is `OFF`.

    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

16. `WASMEDGE_PLUGIN_IMAGE`: build the WasmEdge image plugin (Linux and MacOS platforms only). Default is `OFF`.

    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

17. `WASMEDGE_PLUGIN_TENSORFLOW`: build the WasmEdge TensorFlow plugin (Linux and MacOS platforms only). Default is `OFF`.

    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.

18. `WASMEDGE_PLUGIN_TENSORFLOWLITE`: build the WasmEdge TensorFlow-Lite plug-in (Linux and MacOS platforms only). Default is `OFF`.

    - This option is useless if the option `WASMEDGE_BUILD_PLUGINS` is set as `OFF`.



## Build WasmEdge with Plug-ins



Developers can follow the steps to build WasmEdge with plug-ins from source.



- [WASI-NN (with several backends)](plugin/wasi_nn.md)

- [WASI-Crypto](plugin/wasi_crypto.md)

- [WasmEdge-Image](plugin/image.md)

- [WasmEdge-TensorFlow](plugin/tensorflow.md)

- [WasmEdge-TensorFlowLite](plugin/tensorflowlite.md)

- [WASI-Logging](plugin/wasi_logging.md)



## Run Tests



The tests are only available when the build option `WASMEDGE_BUILD_TESTS` is set to `ON`.



Users can use these tests to verify the correctness of WasmEdge binaries built.



```bash

cd <path/to/wasmedge/build_folder>

LD_LIBRARY_PATH=$(pwd)/lib/api ctest

```








------"
"The following is a markdown document located at /contribute/source/docker.md
------


---

sidebar_position: 2

---



# Docker Images for Building WasmEdge



WasmEdge supports a wide range of Linux distributions dated back to 2014. The official release contains statically linked binaries and libraries for older Linux systems.



The table below shows build targets in WasmEdge's official release packages.



Developers can use the `docker pull wasmedge/wasmedge:{tag_name}` command to pull the docker image for WasmEdge building.



| tag name | arch | based operating system | LLVM version | ENVs | compatibility | comments |

| --- | --- | --- | --- | --- | --- | --- |

| `latest` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |

| `ubuntu-build-gcc` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=gcc, CXX=g++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |

| `ubuntu-build-clang` | x86_64 | Ubuntu 22.04 LTS | 15.0.7 | CC=clang, CXX=clang++ | Ubuntu 22.04+ | This is for CI, will always use the latest Ubuntu LTS release |

| `ubuntu2004_x86_64` | x86_64 | Ubuntu 20.04 LTS | 10.0.0 | CC=gcc, CXX=g++ | Ubuntu 20.04+ | This is for developers who familiar with Ubuntu 20.04 LTS release |

| `ubuntu2104_armv7l` | armhf | Ubuntu 21.04 | 12.0.0 | CC=gcc, CXX=g++ | Ubuntu 21.04+ | This is for armhf release |

| `manylinux2014_x86_64` | x86_64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on x86_64 architecture |

| `manylinux2014_aarch64` | aarch64 | CentOS 7, 7.9.2009 | 16.0.5 | CC=gcc, CXX=g++ | Ubuntu 16.04+, CentOS 7+ | This is for developers who familiar with CentOS on aarch64 architecture |








------"
"The following is a markdown document located at /contribute/community.md
------


---

sidebar_position: 10

---



# Join WasmEdge Community



Everyone is welcome to join the WasmEdge community.



## Contact



If you have any questions, feel free to open a GitHub issue on a related project or to join the following channels:



- Mailing list: Send an email to [WasmEdge@googlegroups.com](https://groups.google.com/g/wasmedge/)

- Discord: Join the [WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)!

- Slack: Join the #WasmEdge channel on the [CNCF Slack](https://slack.cncf.io/)

- Twitter: Follow @realwasmedge on [Twitter](https://twitter.com/realwasmedge)



## Community Meeting



We host a monthly community meeting to showcase new features, demo new use cases, and a Q&A part. Everyone is welcome!



Time: The first Tuesday of each month at 11PM Hong Kong Time/ 7AM PST.



[Public meeting agenda/notes](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit#) | [Zoom link](https://us06web.zoom.us/j/88282362606?pwd=UFhOdzlVKyswdW43c21BKy9DdkdyUT09)








------"
"The following is a markdown document located at /contribute/contribute.md
------


---

sidebar_position: 8

---



# Contributing Guide



* [New Contributor Guide](#contributing-guide)

  * [Ways to Contribute](#ways-to-contribute)

  * [Find an Issue](#find-an-issue)

  * [Ask for Help](#ask-for-help)

  * [Pull Request Lifecycle](#pull-request-lifecycle)

  * [Development Environment Setup](#development-environment-setup)

  * [Sign Your Commits](#sign-your-commits)

  * [Pull Request Checklist](#pull-request-checklist)



Welcome! We are glad that you want to contribute to our project! 💖



As you get started, you are in the best position to give us feedback on areas of

the project that we need help with includes:



* Problems found during setting up a new developer environment

* Gaps in our Quickstart Guide or documentation

* Bugs in our automation scripts



If anything doesn't make sense, or doesn't work when you run it, please open a

bug report and let us know!



## Ways to Contribute



We welcome many different types of contributions including:



* New features

* Report a bug

* Builds, CI/CD

* Bug fixes

* Documentation

* Issue Triage

* Answering questions on Slack/Mailing List/GitHub issues

* Web design

* Communications / Social Media / Blog Posts

* Release management



Not everything happens through a GitHub pull request. Please come to our

[meetings](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit?usp=sharing) or [contact us](https://groups.google.com/g/wasmedge) and let's discuss how we can work

together.



### Come to Meetings



Absolutely everyone is welcome to come to any of our meetings. You never need an

invite to join us. In fact, we want you to join us, even if you don’t have

anything you feel like you want to contribute. Just being there is enough!



You can find out more about our meetings [here](https://docs.google.com/document/d/1iFlVl7R97Lze4RDykzElJGDjjWYDlkI8Rhf8g4dQ5Rk/edit?usp=sharing). You don’t have to turn on

your video. The first time you come, introducing yourself is more than enough.

Over time, we hope that you feel comfortable voicing your opinions, giving

feedback on others’ ideas, and even sharing your own ideas, and experiences.



## Find an Issue



We have good first issues for new contributors and help wanted issues suitable

for any contributor. [good first issue](https://github.com/WasmEdge/WasmEdge/labels/good%20first%20issue) has extra information to

help you make your first contribution. [help wanted](https://github.com/WasmEdge/WasmEdge/labels/help%20wanted) are issues

suitable for someone who isn't a core maintainer and is good to move onto after

your first pull request.



Sometimes there won’t be any issues with these labels. That’s ok! There is

likely still something for you to work on. If you want to contribute but

don’t know where to start or can't find a suitable issue, you can leave a comment under this issue like ""I'd like to work on this. Can you tell XYZ (list the stuff you want to communicate)"" or send your questions to our discord server or slack channel.



Once you see an issue that you'd like to work on, please post a comment saying

that you want to work on it. Something like ""I want to work on this"" is fine.



## Ask for Help



The best way to reach us with a question when contributing is to ask on:



* The original github issue

* Mailing list: Send an email to [our email list](https://groups.google.com/g/wasmedge)

* Discord: Join the [WasmEdge Discord server](https://discord.gg/h4KDyB8XTt)

* Slack: Join the #WasmEdge channel on the [CNCF Slack](https://slack.cncf.io/)



Before opening any issue, please look up the existing [issues](https://github.com/WasmEdge/WasmEdge/issues) to avoid submitting a duplication. If you find a match, you can ""subscribe"" to it to get notified of updates. If you have additional helpful information about the issue, please leave a comment.



When reporting issues, always include:



* Version of your system

* Configuration files of WasmEdge



Because the issues are open to the public, when submitting the log and configuration files, be sure to remove any sensitive information, e.g. user name, password, IP address, and company name. You can replace those parts with ""REDACTED"" or other strings like ""\*\*\*\*"". Be sure to include the steps to reproduce the problem if applicable. It can help us understand and fix your issue faster.



## Pull Request Lifecycle



Pull requests are always welcome, even if they only contain minor fixes like typos or a few lines of code. If there will be a significant effort, please document it as an issue and get a discussion going before starting to work on it.



Please submit a pull request broken down into small changes bit by bit. A pull request consisting of many features and code changes may take a lot of work to review. It is recommended to submit pull requests incrementally.



Generally, once your pull request has been opened, it will be assigned to one or more reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and coding style. If your PR is not ready to review, please mark your PR as a draft.



The reviewers will give you some feedback in three work days.



After the first review is done, the PR contributor is expected to review and make some changes based on the review in 5 workdays.



If you have finished the adjustments, mark the problem as solved, then the reviewers will review your PR again in 2 workdays.



If the PR contributor doesn't respond to the PR in 30 days, the maintainer will close the PR. The original PR contributor is welcome to open it again.



If the PR contributor doesn't want to maintain the PR due to some reason, please enable maintainers to edit this PR if you still want this PR to be merged.



When your PR is merged, your contribution will be implemented in the next release. And we will add the contributors' GitHub name in the release note.



## Development Environment Setup



The WasmEdge is developed on Ubuntu 20.04 to take advantage of advanced LLVM features for the AOT compiler. The WasmEdge team also builds and releases statically linked WasmEdge binaries for older Linux distributions.



Our development environment requires `libLLVM-12` and `>=GLIBCXX_3.4.26`.



If you use an operating system older than Ubuntu 20.04, please use our [special docker image] to build WasmEdge. If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on the `manylinux2014` distribution.



To build WasmEdge from the source, please refer to: [Build WasmEdge from source](/category/build-wasmedge-from-source).



## Sign Your Commits



### DCO



Licensing is important to open source projects. It provides some assurances that

the software will continue to be available based under the terms that the

author(s) desired. We require that contributors sign off on commits submitted to

our project's repositories. The [Developer Certificate of Origin

(DCO)](https://probot.github.io/apps/dco/) is a way to certify that you wrote and

have the right to contribute the code you are submitting to the project.



You sign-off by adding the following to your commit messages. Your sign-off must

match the git user and email associated with the commit.



    This is my commit message



    Signed-off-by: Your Name <your.name@example.com>



Git has a `-s` command line option to do this automatically:



    git commit -s -m 'This is my commit message'



If you forgot to do this and have not yet pushed your changes to the remote

repository, you can amend your commit with the sign-off by running



    git commit --amend -s 



## Pull Request Checklist



When you submit your pull request, or you push new commits to it, our automated

systems will run some checks on your new code. We require that your pull request

passes these checks, but we also have more criteria than just that before we can

accept and merge it. We recommend that you check the following things locally

before you submit your code:



* DCO: Did you sign off your commit

* Code of conduct: Did you follow the CNCF code of conduct



## Reporting issues



## Documenting



Update the documentation if you are creating or changing features. Good documentation is as necessary as the code itself. Documents are written with Markdown. See [Writing on GitHub](https://help.github.com/categories/writing-on-github/) for more details.



## Design new features



You can propose new designs for existing WasmEdge features. You can also design new features; please submit a proposal via the GitHub issues.



WasmEdge maintainers will review this proposal as soon as possible to ensure the overall architecture is consistent and to avoid duplicated work in the roadmap.



New features of WasmEdge will be discussed via a GitHub issue or the community meeting.








------"
"The following is a markdown document located at /contribute/fuzzing.md
------


---

sidebar_position: 5

---



# Fuzzing



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /contribute/installer.md
------


---

sidebar_position: 7

---



# Installer Guide



## Overview



WasmEdge installer is designed for installing the Core Tools (`wasmedge`, `wasmedge compile`), the Libraries (`libwasmedge`), the Extensions(`wasmedge-tensorflow`), and the Plugins(`wasi-nn`, `wasi-crytpo`).



## Dependencies



In the first version of the installer, WasmEdge provides a pure shell script implementation. However, it's not easy to maintain and unsuitable when we want to include the extensions and plugins matrix.



To reduce the maintenance cost and improve the development performance, we decided to move forward to a brand new installer written in python and compatible with both Python 2 and 3.



To be compatible with the old one, we use the same entry point, `install.sh`.



## Usage



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- ${OPTIONS}

```



## Roles



### `install.sh`



The installer entry point.



#### Process



1. Check if the `git` is installed; otherwise, exit with an error `Please install git`.

2. If `PYTHON_EXECUTABLE` is given, try to use `$PYTHON_EXECUTABLE` to execute the `install.py`. Otherwise, go to step 3.

3. If `PYTHON_EXECUTABLE` is not set, `which` command is needed to determine the python-X executable. If it is not found installer exits else, it moves on to the next step.

4. Check if the `python3` is installed. If so, go to step 6. Otherwise, go to step 5.

5. Check if the `python2` is installed. If so, go to step 6. Otherwise, go to step 6.

6. Check if the `python` is installed. If so, go to step 7. Otherwise, exit with an error `Please install python or provide python path via $PYTHON_EXECUTABLE`.

7. Print the detected python version `Using Python: $PYTHON_EXECUTABLE`.

8. Download `install.py` with `curl` or `wget`. If the URL of `install.py` is unreachable due to a network issue, exit with an error `$INSTALL_PY_URL not reachable`. If the `curl` and `wget` are unavailable, exit with an error `curl or wget could not be found`.

9. Execute the `install.py` with all received arguments.



### `install.py`



The actual installer handles all stuff. It supports python2.7 (not tested on earlier versions) and the latest python versions python3.x.



## Options



### Help Msg



- Short Option: `-h`

- Full Option: `--help`

- Description: Show this help message and exit.



### Verbose



- Short Option: `-D`

- Full Option: `--debug`

- Description: Enable verbosity debug



### Specify the version of WasmEdge to install



- Short Option: `-v VERSION`

- Full Option: `--version VERSION`

- Description: Install the given VERSION of WasmEdge

- Available Value: VERSION `{{ wasmedge_version }}` or other valid release versions.

- Note - If supplied an invalid or nonexistent version, the installer exists with an error.



### Installation path



- Short Option: `-p PATH`

- Full Option: `--path PATH`

- Description: Install WasmEdge into the given PATH. The default Path is `$HOME/.wasmedge`.

- Note - Any paths other than the ones starting with `/usr` are treated as non-system paths in the internals of the installer. The consequences are different directory structures for both.

- Note - If the path not exists, the folder will be created.



### Uninstallation



#### Run uninstaller before installing



- Short Option: `-r {yes,no}`

- Full Option: `--remove-old {yes, no}`

- Description: Run the uninstaller script before installing. Default `yes`.



#### Use a specific version of the uninstaller



- Short Option: `-u UNINSTALL_SCRIPT_TAG`

- Full Option: `--uninstall-script-tag UNINSTALL_SCRIPT_TAG`

- Description: Use the given GitHub tag to uninstall the script



### Install Extensions



- Short Option: `-e [EXTENSIONS [EXTENSIONS ...]]`

- Full Option: `--extension [EXTENSIONS [EXTENSIONS ...]]`

- Description: Install wasmedge-extension tools.

- Available Value (case sensitive): Supported Extensions `'tensorflow', 'image', 'all'`.



#### Tensorflow Extensions Library Version



- Full Option: `--tf-version TF_VERSION`

- Description: Install the given VERSION of the library of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.

- Note - It's the same as the WasmEdge version if not specified.



#### Tensorflow Extensions Dependencies Version



- Full Option: `--tf-deps-version TF_DEPS_VERSION`

- Description: Install the given VERSION of the dependencies of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.

- Note - It's the same as the WasmEdge version if not specified.



#### Tensorflow Extensions Tools Version



- Full Option: `--tf-tools-version TF_TOOLS_VERSION`

- Description: Install the given VERSION of the tools of the Tensorflow and Tensorflow lite extension. Only available when the `Extensions` is set to `all` or `tensorflow`.

- Note - It's the same as the WasmEdge version if not specified.



#### Image Extensions Version



- Full Option: `--image-version IMAGE_VERSION`

- Description: Install the given VERSION of the Image extension. Only available when the `Extensions` is set to `all` or `image`.

- Note - It's the same as the WasmEdge version if not specified.



### Plugins



- Note - Currently, `--plugins` is an experimental option.



- Full Option: `--plugins wasi_crypto:0.12.0`



- Note - The format for this argument is `<plugin_name>:<version_number>`. `<version_number>` is not compulsory. For example, `--plugins wasi_crypto` is a valid option.

- Note - `<plugin_name>` is cases sensitive. Allowed values are stated [here](plugin/intro.md) in the `Rust Crate` column. The logic is that the release name should be the same.

- Note - It's the same as the WasmEdge version if not specified.



### DIST



- Full Option: `--dist ubuntu20.04` or `--dist manylinux2014`

- Note - the `ubuntu20.04` and `manylinux2014` values are case insensitive and only these two are currently supported.

- Note - Specifying `--dist` value for `Darwin` has no effect.

- Note - For `Linux` platform if the distribution matches exactly as `Ubuntu 20.04`, which is checked using `lsb_release` and python's `platform.dist()` functionality is then set to `ubuntu20.04` if not specified, or it is used without questioning. However different release packages for WasmEdge are available only after `0.11.1` release, below which there is no effect of specifying this option.



### Platform and OS



- Full Option: `--platform PLATFORM` or `--os OS`

- Description: Install the given `PLATFORM` or `OS` version of WasmEdge. This value should be case insensitive to make the maximum compatibility.

- Available Value (case insensitive): ""Linux"", ""Darwin"", ""Windows"".



### Machine and Arch



- Full Option: `--machine MACHINE` or `--arch ARCH`

- Description: Install the `MACHINE` or `ARCH` version of WasmEdge.

- Available Value: ""x86_64"", ""aarch64"".



## Behavior



- If an installation exists at `$HOME/.wasmedge`, to be noted as the default installation path, it is removed with or without the uninstaller's invocation.

- WasmEdge installation appends all the files it installs to a file which is located in the installer directory named `env` with its path as `$INSTALLATION_PATH/env`.



### Shell and it's configuration



- Source string in shell configuration is given as `. $INSTALLATION_PATH/env` so that it exports the necessary environment variables for WasmEdge.

- Shell configuration file is appended with source string if it cannot find the source string in that file.

- Currently, it detects only `Bash` and `zsh` shells.

- If the above shells are found, then their respective configuration files `$HOME/.bashrc` and `$HOME/.zshrc` are updated along with `$HOME/.zprofile` and `$HOME/.bash_profile` in the case of Linux.

- In the case of `Darwin`, only `$HOME/.zprofile` is updated with the source string.








------"
"The following is a markdown document located at /contribute/internal.md
------


---

sidebar_position: 6

---



# WasmEdge Internal



## Overview of WasmEdge Execution Flow



```mermaid

graph TD

    A[WASM] -->|From files or buffers| B(Loader)

    B -->|Create WASM AST| C(Validator)

    C -->|Validate WASM Module| D[Instantiator]

    D -->|Create WASM instances| E{AOT section found?}

    E -->|Yes| F[AOT Engine]

    E -->|No| G[Interpreter Engine]

    F <-->|Execute WASM| H[WasmEdge Engine]

    G <-->|Execute WASM| H[WasmEdge Engine]

    H -->|Host Function Call / Access Runtime Data| H1[WasmEdge Runtime]

    H1 <-->|Call Host Functions| I[Host Functions]

    H1 <-->|Access Runtime Data| J[Runtime Data Manager]

    I <-->|System Call| I1[WASM System Interface, WASI]

    I <-->|AI-related Function Call| I2[WASI-NN]

    I <-->|Crypto-related Function Call| I3[WASI-Crypto]

    I <-->|Socket-related Function Call| I4[WasmEdge-WASI-Socket]

    J <-->|Access Memory| J1[Memory Manager]

    J <-->|Access Stack| J2[Stack Manager]

    J <-->|Access Cross Module| J3[Registered Module/Function Manager]

```








------"
"The following is a markdown document located at /contribute/overview.md
------


---

sidebar_position: 1

displayed_sidebar: contributeSidebar

---



# Contribute and Extend WasmEdge



Contribution is always welcome! The WebAssembly ecosystem is still in its early days. Hosted by CNCF, WasmEdge aims to become an open source “reference implementation” of WebAssembly and its edge-related extensions. WasmEdge is developed in the open, and is constantly being improved by our users, contributors, and maintainers. It is because of you that we can bring great software to the community.We are looking forward to working together with you!



To help new contributors understand WasmEdge development workflow, this guide will include



- [Build WasmEdge and WasmEdge plug-in from source on different platforms](/category/build-wasmedge-from-source)

- [WasmEdge Plug-in system introduction](/category/wasmedge-plugin-system)

- [Test WasmEdge](test.md)

- [WasmEdge Fuzzing](fuzzing.md)

- [WasmEdge internal explanation](internal.md)

- [WasmEdge installer system explanation](installer.md)

- [contributing steps](contribute.md)

- [WasmEdge release process](release.md)

- [Join WasmEdge community](community.md)



## Ideas for contributions



If you're looking for something to contribute, we have issues



- labeled with [`good first issue`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22), which are recommendations for developers to contribute to WasmEdge by working on some easy tasks. These tasks will help contributors to learn the WasmEdge development workflow.



- labeled with [`help wanted`](https://github.com/WasmEdge/WasmEdge/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22), for which are we need suggestions and opinions from the community.



- [Roadmap](https://github.com/WasmEdge/WasmEdge/blob/master/docs/ROADMAP.md) for every year, which elaborates the new features in the coming days. You are also welcome to pick one.



If you find something is missing, don't hesitate to create an issue and let us know. Again, WasmEdge is open in development.



## Mentoring



WasmEdge maintainers can provide mentoring for WasmEdge, WebAssembly, C++, Rust, compiler, etc. If you are interested in fixing one open issue, just let us know by commenting under the issue. WasmEdge maintainers will reply to your question in time.



Besides the regular GitHub issues, the WasmEdge project will participate in some open source mentoring projects like [Google Summer of Code (GSoC)](https://summerofcode.withgoogle.com/), [Google Season of Docs (GSoD)](https://developers.google.com/season-of-docs), [LFX Mentorship](https://mentorship.lfx.linuxfoundation.org/#projects_all), and [Open Source Promotion Plan (OSPP)](https://summer-ospp.ac.cn/). Join our [Discord server](https://discord.gg/U4B5sFTkFc) or follow [@realwasmedge](https://twitter.com/realwasmedge) on Twitter to get alerts on the application details.








------"
"The following is a markdown document located at /contribute/release.md
------


---

sidebar_position: 9

---



# Release Process



## Create the releasing process issue of the new version



- [ ] Keep adding new features, issues, and documents, and builds a checklist into the issue.

- [ ] Add the GitHub project of the new version.



## Write Changelog



- [ ] Make sure every change is written in the changelog.

- [ ] Make sure the `Changelog.md` has the correct version number and the release date.

- [ ] Copy the changelog of this version to `.CurrentChangelog.md`. (Our release CI will take this file as the release notes.)

- [ ] Record the contributor lists.

- [ ] Create a pull request, make sure the CI is all passed, and merge it.



## Create the Alpha Pre-Release



- [ ] In this step, the main features are completed. No more major features will be merged after the first Alpha pre-release.

- [ ] Make sure that the features in the releasing process issue are completed.

- [ ] Use git tag to create a new release tag `major.minor.patch-alpha.version`. And push this tag to GitHub.

- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.

- [ ] Check the `Pre-release` checkbox and publish the pre-release.

- [ ] This step will automatically close and turn into the Beta or RC phase in about 3 days if there are no critical issues.



## Create the Beta Pre-Release



- [ ] This step is for the issue fixing if needed. No more features will be accepted.

- [ ] Make sure all the features in the releasing process issue are completed.

- [ ] Use git tag to create a new release tag `major.minor.patch-beta.version`. And push this tag to GitHub.

- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.

- [ ] Check the `Pre-release` checkbox and publish the pre-release.

- [ ] This step will automatically close and turn into the RC phase in about 3 days if there are no critical issues.



## Create the RC Pre-Release



- [ ] In this step, the issue fixing is finished. The `RC` pre-releases are for installation, bindings, and package testing.

- [ ] Make sure that all the issues in the release process issue are completed.

- [ ] Update `WASMEDGE_CAPI_VERSION` in `CMakeLists.txt`.

- [ ] Update `wasmedge_version` in `docs/.env`.

- [ ] Use git tag to create a new release tag `major.minor.patch-rc.version`. And push this tag to GitHub.

- [ ] Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.

- [ ] Check the `Pre-release` checkbox and publish the pre-release.

- [ ] This step will automatically close and announce the official release in about three days if there are no critical issues.



## Create the Official Release



- [ ] Make sure the `Changelog.md` and `.CurrentChangelog.md` have the correct version number and the release date.

- [ ] Use git tag to create a new release tag `major.minor.patch`. And push this tag to GitHub.

- [ ] Wait for the CI builds and push the release binaries and release notes to the GitHub release page.

- [ ] Publish the release.

- [ ] Close the releasing process issue and the GitHub project.



## Update the Extensions



Following projects will be updated with the `Alpha`, `Beta`, and `RC` pre-releases and the official release:



- [ ] [WasmEdge-Go SDK](https://github.com/second-state/WasmEdge-go)

- [ ] [WasmEdge-core NAPI package](https://github.com/second-state/wasmedge-core)

- [ ] [WasmEdge-extensions NAPI package](https://github.com/second-state/wasmedge-extensions)








------"
"The following is a markdown document located at /contribute/test.md
------


---

sidebar_position: 4

---



# Testing



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /contribute/users.md
------


---

sidebar_position: 11

---



# WasmEdge Users and Collaborators



This list is constantly being updated. Please submit a PR to add your own item if we missed your use case. We appreciate our community members' contributions. Thank you!



| Name | Desciption | PR or Docs |

| --- | --- | --- |

| WebAssembly Languages Runtime maintained by VMWare | Use WasmEdge to run PHP and python programs | <https://github.com/vmware-labs/webassembly-language-runtimes/pull/19> |

| Cocos AI | WasmEdge is used for Confidential Computing inference of AI workloads in a secure TEE enclave | <https://github.com/ultravioletrs/cocos/pull/189> |

| WikiFunctions | Use WasmEdge to execute serverless functions to be embedded in Wikipedia | <https://www.wikifunctions.org/wiki/Wikifunctions:Status_updates/2024-08-23> |

| LF Edge eKuiper | Use WasmEdge to process data streamed from IoT devices | <https://github.com/lf-edge/ekuiper/pull/1449/> |

| crun | Use WasmEdge to run WASM containers | <https://github.com/containers/crun/pull/774> |

| youki | Use WasmEdge to run WASM containers | <https://github.com/containers/youki/pull/1320> |

| containerd and runwasi | Use WasmEdge to run WASM containers | <https://github.com/containerd/runwasi> |

| Kuasar | Use WasmEdge to run WASM containers | <https://github.com/kuasar-io/kuasar#wasm-sandboxer> |

| Proxy-wasm | Use WASM to process the proxy rules | <https://github.com/proxy-wasm/proxy-wasm-cpp-host/pull/193> |

| OpenYurt | Use WasmEdge to run WASM containers side by side with Linux containers in an OpenYurt network. | <https://www.cncf.io/blog/2022/02/07/wasmedge-and-openyurt-bring-cloud-computing-to-the-edge/> |

| SuperEdge | Use WasmEdge to run WASM containers side by side with Linux containers in a SuperEdge network. | <https://github.com/WasmEdge/WasmEdge/pull/1272> |

| OpenGauss | Use WasmEdge to support user-defined functions (UDF) in a database | <https://hub.docker.com/r/opengauss/wasmedge> |

| Essa-ra | Use WasmEdge to execute serverless functions on the essa-rs platform. | <https://github.com/essa-project/essa-rs> |

| Fedora Linux | Incorporated WasmEdge as an official RPM package since Fedora 37. | <https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html> |

| Polkadot | Provide WasmEdge as a smart contract runtime for parachains, and support WasmEdge as an alternative runtime for substrate nodes. | <https://github.com/second-state/substrate-wasmedge> |

| Apache Traffic Server | Use WasmEdge as a plug-in to process the traffic flow | <https://github.com/apache/trafficserver/pull/9390> |

| Enovy | Use WasmEdge as a plug-in to process the traffic flow | <https://github.com/envoyproxy/envoy/pull/24817/files> |

| Liquid Reply | Kubernetes operators for managing WasmEdge workloads for customers | <https://kwasm.sh/> |

| Docker | Use WasmEdge to support wasm containers in Docker Desktop tools | <https://www.docker.com/blog/docker-wasm-technical-preview/> |

| ByteDance | Use WasmEdge to run custom logic in service mesh proxies and sidecars | Internal use case |

| ByteDance | Use WasmEdge to run serverless functions | Internal use case |

| ByteDance | Use WasmEdge as a Ray node | <https://github.com/ray-project/enhancements/blob/main/reps/2023-02-01-wasm-on-ray.md> |

| Huawei Cloud | Use WasmEdge to run Serverless functions | Internal use case |

| 5miles | Use WasmEdge to run internal microservices | Internal use case |

| Bytetrade | Use WasmEdge to run microservices for automated crypto trading and marketing automation | Internal use case |

| FutureWei | Use WasmEdge on automobile and OpenHarmony | <https://github.com/WasmEdge/WasmEdge/pull/902> |

| WinSoft | Use WasmEdge to improve IDE’s user experience | <https://winsoft.sk/webassembly.htm> |

| ParaState | Use WasmEdge to execute smart contracts on the ParaState blockchain | <https://www.parastate.io/> |

| Plurigrid | Use WasmEdge to run client-side / edge simulations | <https://twitter.com/bmorphism/status/1606237485037674499> |

| XRPL Labs | Use WasmEdge to execute smart contracts on the Ripple blockchain | <https://github.com/XRPL-Labs/xrpld-hooks> |

| API7 | Run WasmEdge in OpenResty/Nginx | <https://github.com/api7/wasm-nginx-module> |

| YoMo | Use WasmEdge to support user-defined functions (UDF) in streaming data pipelines | [https://github.com/yomorun/yomo-wasmedge-tensorflow](https://github.com/yomorun/yomo) |

| libsql | Use WasmEdge to support user-defined functions (UDF) in a database | <https://github.com/libsql/libsql/pull/131> |

| Shifu | Use WasmEdge to support user-defined functions (UDF) in data streams from edge devices | <https://github.com/Edgenesis/wasm-shifu-demo> |

| Lnjoying | Offers WasmEdge as part of its edge cloud service. | Internal use case |

| Red Hat EPEL 9 | Offers support for wasmedge packages for Red Hat Linux 9 users | <https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html> |

| Open Interpreter| Use WasmEdge as the LLM runtime | <https://github.com/OpenInterpreter/01/tree/main/software/source/server/services/llm/llamaedge> |

| GaiaNet| Use WasmEdge as LLM runtime | <https://github.com/GaiaNet-AI/gaianet-node> |

| EigenLayer | Use WasmEdge to run an LLM that validates user submitted content | <https://x.com/sreeramkannan/status/1834313576133394438> |

| MoXin| Use WasmEdge as the LLM runtime | <https://github.com/project-robius/moxin> |

| CODA Bridge| Use WasmEdge as the container to run microservices | Internal use case |

| CloudEvents | Support the Rust SDK to be compiled into Wasm so that a Wasm app can send and receive cloud events | <https://github.com/cloudevents/sdk-rust/pull/202> |

| Kagome | A C++ implementation of Polkadot host which runs Wasm smart contracts on WasmEdge | <https://github.com/qdrvm/kagome/tree/master/core/runtime> |

| Sealos | A Cloud Operating System designed for managing cloud-native applications. It uses WasmEdge to run LLMs locally in its cluster | <https://github.com/labring-actions/cluster-image/blob/main/applications/runwasi-wasmedge/latest/install.sh> |








------"
"```json:/develop/c/_category_.json


{

  ""label"": ""Develop WASM Apps in C/C++"",

  ""position"": 6,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to create WASM apps in C/C++.""

  }

}








```"
"The following is a markdown document located at /develop/c/bpf.md
------


---

sidebar_position: 5

---



# Bpf userspace program example with wasm_bpf plug-in



There is a WasmEdge plug-in called `wasm_bpf`, which provided APIs to perform operations on eBPF program, such as loading, attaching and polling.



The detailed description can be found at [https://github.com/WasmEdge/WasmEdge/blob/master/plugins/wasm_bpf/README.md](https://github.com/WasmEdge/WasmEdge/blob/master/plugins/wasm_bpf/README.md).



Here we will provide several examples to demonstrate the `wasm_bpf` plug-in.



## Prerequisites



For simplicity, we will reuse the `Makefile` of [wasm-bpf](https://github.com/eunomia-bpf/wasm-bpf), since `wasmEdge_bpfPlugin` has the precisely same API as `wasm-bpf`



1. Clone the [`wasm-bpf`](https://github.com/eunomia-bpf/wasm-bpf) repo.

2. Run `make install-deps` and `make /opt/wasi-sdk` at the project's root. This will install the build prerequisites.

3. [Install WasmEdge](../../start/install.md#install)

4. Build and install the `wasm_bpf` plug-in. Currently, we have to build `wasm_bpf` plug-in manually. The building instructions could be found at [https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasm_bpf#build-wasm_bpf-plug-in](https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasm_bpf#build-wasm_bpf-plug-in)



## The bootstrap example



`bootstrap` is a simple eBPF program to track the entry and exit of all processes. It will print a line of message when there is an entry of an exiting event of a process.



Run `make` in `wasm-bpf/examples/bootstrap`, and you will find the `bootstrap.wasm`, which can be executed by `WasmEdge`.



```bash

WASMEDGE_PLUGIN_PATH=./build/plugins/wasm_bpf/ wasmedge bootstrap.wasm

```



`WASMEDGE_PLUGIN_PATH` should be changed due to your build directory of the plug-in.



Example output:



```bash

TIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE

13:38:00 EXEC  bash             121487  40189   /usr/bin/bash

13:38:00 EXEC  groups           121489  121487  /usr/bin/groups

13:38:00 EXIT  groups           121489  121487  [0] (3ms)

13:38:00 EXEC  lesspipe         121490  121487  /usr/bin/lesspipe

13:38:00 EXEC  basename         121491  121490  /usr/bin/basename

13:38:00 EXIT  basename         121491  121490  [0] (8ms)

13:38:00 EXEC  dirname          121493  121492  /usr/bin/dirname

13:38:00 EXIT  dirname          121493  121492  [0] (1ms)

13:38:00 EXIT  lesspipe         121492  121490  [0]

```



### Details of `bootstrap`



`bootstrap` was created in a similar spirit as libbpf-tools from BCC package but is designed to be more stand-alone and with a simpler Makefile to simplify adoption to users' particular needs. It demonstrates the use of typical BPF features:



Cooperating BPF programs (tracepoint handlers for process `exec` and `exit` events, in this particular case); BPF map for maintaining the state; BPF ring buffer for sending data to userspace; global variables for application behavior parameterization. It utilizes BPF CO-RE and vmlinux.h to read extra process information from kernel's struct task_struct.



#### Some code snippets



A bpf program from `bootstrap.bpf.c`. It tracks the execution of processes, wraps the event in a struct, and sends the struct to the userspace program through ringbuf.



```c

SEC(""tp/sched/sched_process_exec"")

int handle_exec(struct trace_event_raw_sched_process_exec* ctx) {

    struct task_struct* task;

    unsigned fname_off;

    struct event* e;

    pid_t pid;

    u64 ts;



    /* remember time exec() was executed for this PID */

    pid = bpf_get_current_pid_tgid() >> 32;

    ts = bpf_ktime_get_ns();

    bpf_map_update_elem(&exec_start, &pid, &ts, BPF_ANY);



    /* don't emit exec events when minimum duration is specified */

    if (min_duration_ns)

        return 0;



    /* reserve sample from BPF ringbuf */

    e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);

    if (!e)

        return 0;



    /* fill out the sample with data */

    task = (struct task_struct*)bpf_get_current_task();



    e->exit_event = false;

    e->pid = pid;

    e->ppid = BPF_CORE_READ(task, real_parent, tgid);

    bpf_get_current_comm(&e->comm, sizeof(e->comm));



    fname_off = ctx->__data_loc_filename & 0xFFFF;

    bpf_probe_read_str(&e->filename, sizeof(e->filename),

                       (void*)ctx + fname_off);



    /* successfully submit it to user-space for post-processing */

    bpf_ringbuf_submit(e, 0);

    return 0;

}

```



The userspace program's core process (compiled to Wasm). It invokes APIs from `wasm_bpf` to open, load, attach the bpf program, and poll data from the ringbuf.



```c

/* Load and verify BPF application */

    skel = bootstrap_bpf__open();

    if (!skel) {

        fprintf(stderr, ""Failed to open and load BPF skeleton\n"");

        return 1;

    }



    /* Parameterize BPF code with minimum duration parameter */

    skel->rodata->min_duration_ns = env.min_duration_ms * 1000000ULL;



    /* Load & verify BPF programs */

    err = bootstrap_bpf__load(skel);

    if (err) {

        fprintf(stderr, ""Failed to load and verify BPF skeleton\n"");

        goto cleanup;

    }



    /* Attach tracepoints */

    err = bootstrap_bpf__attach(skel);

    if (err) {

        fprintf(stderr, ""Failed to attach BPF skeleton\n"");

        goto cleanup;

    }



    /* Set up ring buffer polling */

    rb = bpf_buffer__open(skel->maps.rb, handle_event, NULL);

    if (!rb) {

        err = -1;

        fprintf(stderr, ""Failed to create ring buffer\n"");

        goto cleanup;

    }

    /* Process events */

    printf(""%-8s %-5s %-16s %-7s %-7s %s\n"", ""TIME"", ""EVENT"", ""COMM"", ""PID"",

           ""PPID"", ""FILENAME/EXIT CODE"");

    while (!exiting) {

        // poll buffer

        err = bpf_buffer__poll(rb, 100 /* timeout, ms */);

        /* Ctrl-C will cause -EINTR */

        if (err == -EINTR) {

            err = 0;

            break;

        }

        if (err < 0) {

            printf(""Error polling perf buffer: %d\n"", err);

            break;

        }

    }

```



## Other examples



Each directory under `wasm-bpf/examples` represents an example able to be run using `WasmEdge`. You can run `make` in their directory and run the corresponding WASM with `WasmEdge`.








------"
"The following is a markdown document located at /develop/c/hello_world.md
------


---

sidebar_position: 1

---



# Hello World



This chapter will take Hello World as an example to show how to compile a C program to WASM bytecode and run it in WasmEdge.



## Prerequisites



Before we start, make sure you have installed the following software:



1. [Install WasmEdge](../../start/install.md#install)



2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.



```bash

git clone --depth 1 https://github.com/emscripten-core/emsdk.git

cd emsdk

./emsdk install latest

./emsdk activate latest

source ./emsdk_env.sh

```



## Example: Hello World



### Compile the C code into Wasm



As the first step is always the ""Hello World"" program, given below is the C program implementation.



```c

// hello.c



#include<stdio.h>

int main(int argc,char **argv){

  printf(""Hello World!\n"");

  return 0;

}

```



Save it in any file and then compile it to WebAssembly with emscripten.



```bash

emcc hello.c -o hello.wasm

```



<!-- prettier-ignore -->

:::note

Make sure you either supply `-s STANDALONE_WASM` flag or specify output as wasm `-o your_file_name.wasm`

:::



Then run the wasm in wasmedge runtime.



```bash

$ wasmedge hello.wasm

Hello World

```



### Run in WasmEdge



Run the compiled wasm with WasmEdge CLI, and you will get the hello world output.



```bash

$ wasmedge hello.wasm

Hello, world!

```



### AoT mode



With WasmEdge's AoT compiler, you will get higher performance.



```bash

# Compile the wasm file with wasmedge aot compiler

$ wasmedgec hello.wasm hello.wasm

# Run the native binary with wasmedge

$ wasmedge hello.wasm

```



## Example: Add function



We can also pass cmd arguments. For example, add function takes two arguments and prints their sum in this example.



```c

// add.c



#include <stdio.h>

#include <stdlib.h>

int main(int argc, char *argv[])

{

  int a,b;

  if(argc==3){

    a = atoi(argv[1]);

    b = atoi(argv[2]);

    printf(""%d\n"",a+b);

  }

  return 0;

}

```



Again Compiling to wasm with emcc



```bash

emcc add.c -o add.wasm

```



Running the application in wasmedge runtime



```bash

$ wasmedge add.wasm 2 3

5

```



We can further improve performance by using wasmedge AOT compilation , this feature gives near native performance



```bash

$ wasmedgec add.wasm add_aot.wasm

$ wasmedge add_aot.wasm 4 9

13

```



## Example: Fibonacci function



We can also structure our project in separate header and implementation files.



```c

// fibonacci.h



int fib(int n);

```



```c

// fibonacci.c



#include <stdio.h>

#include ""fibonacci.h""



int fib(int n){

  int f1 = 0;

  int f2 = 1;

  if(n<=2){

    if(n==1) return f1;

    else return f2;

  }

  else

    for(int i=2; i<n; i++ ){

      int temp = f2;

      f2=f1+f2;

      f1=temp;

    }

  return f2;

}

```



```c

// main.c



#include <stdio.h>

#include <stdlib.h>

#include ""fibonacci.h""



int main(int argc, char *argv[])

{

  if (argc<2) {

    return 0;

  }

  int n = atoi(argv[1]);

  printf(""%d"",fib(n));

  return 0;

}

```



Compiling the program to wasm with emcc



```bash

emcc main.c fibonacci.c -o fib.wasm

```



Running in wasmedge runtime



```bash

$ wasmedge fib.wasm 6

5

```








------"
"The following is a markdown document located at /develop/c/networking.md
------


---

sidebar_position: 2

---



# Networking Socket



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /develop/c/simd.md
------


---

sidebar_position: 4

---



# WebAssembly SIMD Example in C



[128-bit packed Single Instruction Multiple Data (SIMD)](https://webassembly.github.io/simd/core/syntax/instructions.html#simd-instructions) instructions provide simultaneous computations over packed data in just one instruction. It's commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.



If you are interested in enabling the SIMD proposal will improve how much performance of the applications, please refer to our [wasm32-wasi benchmark](https://github.com/second-state/wasm32-wasi-benchmark) for more information. The Mandelbrot Set application can have a **2.65x** speedup in our benchmark.



We modified the Mandelbrot Set example from our [wasm32-wasi benchmark project](https://github.com/second-state/wasm32-wasi-benchmark/blob/master/src/mandelbrot.c). We will use this as an example in this article.



## Prerequisites



Before we start, make sure you have installed the following software:



1. [Install WasmEdge](../../start/install.md#install)



2. Emscripten, a toolchain for compiling C/C++ to WebAssembly. Please refer to the [emcc official repository](https://github.com/emscripten-core/emsdk) for detailed instructions.



```bash

git clone --depth 1 https://github.com/emscripten-core/emsdk.git

cd emsdk

./emsdk install latest

./emsdk activate latest

source ./emsdk_env.sh

```



## Compile the C-SIMD application to Wasm-SIMD binary with emcc



```bash

emcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \

  -mmutable-globals \

  -mnontrapping-fptoint \

  -msign-ext \

  mandelbrot-simd.c -o mandelbrot-simd.wasm

```



## Run with WasmEdge



```bash

wasmedge mandelbrot-simd.wasm 15000

```



## Ahead-of-Time mode



With WasmEdge's AoT compiler, you will get higher performance.



```bash

# Compile wasm-simd with wasmedge aot compiler

$ wasmedge compile mandelbrot-simd.wasm mandelbrot-simd-out.wasm

# Run the native binary with wasmedge

$ wasmedge mandelbrot-simd-out.wasm 15000

```








------"
"The following is a markdown document located at /develop/c/threads.md
------


---

sidebar_position: 3

---



# Thread



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"```json:/develop/deploy/cri-runtime/_category_.json


{

  ""label"": ""High level runtime support"",

  ""position"": 6,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will introduce integrations between WasmEdge and high level runtimes,like containerd and CRI-O.""

  }

}








```"
"The following is a markdown document located at /develop/deploy/cri-runtime/containerd-crun.md
------


---

sidebar_position: 2

---



# containerd + crun



## Quick start



The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on containerd.



- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml)

- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml)



In the sections below, we will explain the steps in the quick start scripts.



- [containerd + crun](#containerd--crun)

  - [Quick start](#quick-start)

  - [Install containerd](#install-containerd)

  - [Run a simple WebAssembly app](#run-a-simple-webassembly-app)

  - [Run a HTTP server app](#run-a-http-server-app)



## Install containerd



Use the following commands to install containerd on your system.



```bash

export VERSION=""1.5.7""

echo -e ""Version: $VERSION""

echo -e ""Installing libseccomp2 ...""

sudo apt install -y libseccomp2

echo -e ""Installing wget""

sudo apt install -y wget



wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum



sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz

sudo systemctl daemon-reload

```



Configure containerd to use `crun` as the underlying OCI runtime. It changes the `/etc/containerd/config.toml` file.



```bash

sudo mkdir -p /etc/containerd/

sudo bash -c ""containerd config default > /etc/containerd/config.toml""

wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff

sudo patch -d/ -p0 < containerd_config.diff

```



Start the containerd service.



```bash

sudo systemctl start containerd

```



Next, make sure that you have [built and installed the `crun` binary with WasmEdge support](../oci-runtime/crun.md) before running the following examples.



## Run a simple WebAssembly app



Now, we can run a simple WebAssembly program using containerd. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. This section will start pulling this WebAssembly-based container image from the Docker hub using containerd tools.



```bash

sudo ctr i pull docker.io/wasmedge/example-wasi:latest

```



Now, you can run the example in just one line with ctr (the containerd cli).



```bash

sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000

```



Starting the container would execute the WebAssembly program. You can see the output in the console.



```bash

Creating POD ...

Random number: -1678124602

Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

```



Next, you can run it in [Kubernetes](../kubernetes/kubernetes-containerd-crun.md#a-simple-webassembly-app)!



## Run a HTTP server app



Finally, we can run a simple WebAssembly-based HTTP micro-service in containerd. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. This section will start pulling this WebAssembly-based container image from the Docker hub using containerd tools.



```bash

sudo ctr i pull docker.io/wasmedge/example-wasi-http:latest

```



Now, you can run the example in just one line with ctr (the containerd cli). Notice that we are running the container with `--net-host` so that the HTTP server inside the WasmEdge container is accessible from the outside shell.



```bash

sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi-http:latest http-server-example /http_server.wasm

```



Starting the container would execute the WebAssembly program. You can see the output in the console.



```bash

new connection at 1234



# Test the HTTP service at that IP address

curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234

echo: name=WasmEdge

```



Next, you can run it in [Kubernetes](../kubernetes/kubernetes-containerd-crun.md#a-webassembly-based-http-service)!








------"
"The following is a markdown document located at /develop/deploy/cri-runtime/containerd.md
------


---

sidebar_position: 1

---



# Deploy with containerd's runwasi



The containerd-shim [runwasi](https://github.com/containerd/runwasi/) project supports WasmEdge.



## Prerequisites



1. [Install Rust](https://www.rust-lang.org/tools/install) because we need to compile the runwasi project.



2. Download the runwasi project



   ```bash

   git clone https://github.com/containerd/runwasi.git

   ```



3. Build and install the wasmedge-containerd-shim



   ```bash

   # Reference: https://github.com/containerd/runwasi/blob/main/CONTRIBUTING.md#setting-up-your-local-environment

   cd runwasi

   ./scripts/setup-linux.sh

   make build-wasmedge

   INSTALL=""sudo install"" LN=""sudo ln -sf"" make install-wasmedge

   ```



## Run a simple Wasi app



   ```bash

   make load

   sudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo 'hello'

   ```








------"
"The following is a markdown document located at /develop/deploy/cri-runtime/crio-crun.md
------


---

sidebar_position: 3

---



# CRI-O + crun



## Quick start



The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.



- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)

- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)



In the sections below, we will explain the steps in the quick start scripts.



- [CRI-O + crun](#cri-o--crun)

  - [Quick start](#quick-start)

  - [Install CRI-O](#install-cri-o)

  - [Configure CRI-O to use crun](#configure-cri-o-to-use-crun)

  - [Run a simple WebAssembly app](#run-a-simple-webassembly-app)

  - [Run a HTTP server app](#run-a-http-server-app)



## Install CRI-O



Use the following commands to install CRI-O on your system.



```bash

export OS=""xUbuntu_20.04""

export VERSION=""1.21""

apt update

apt install -y libseccomp2 || sudo apt update -y libseccomp2

echo ""deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /"" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list

echo ""deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /"" > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list



curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -

curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -



apt-get update

apt-get install criu libyajl2

apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins

systemctl start crio

```



## Configure CRI-O to use crun



CRI-O uses the `runc` runtime by default and we need to configure it to use `crun` instead. That is done by adding to two configuration files.



<!-- prettier-ignore -->

:::note

Before starting the following steps, ensure you have [built and installed the `crun` binary with WasmEdge support](../oci-runtime/crun.md).

:::



First, create a `/etc/crio/crio.conf` file and add the following lines as its content. It tells CRI-O to use `crun` by default.



```conf

[crio.runtime]

default_runtime = ""crun""

```



The `crun` runtime is in turn defined in the `/etc/crio/crio.conf.d/01-crio-runc.conf` file.



```conf

[crio.runtime.runtimes.runc]

runtime_path = ""/usr/lib/cri-o-runc/sbin/runc""

runtime_type = ""oci""

runtime_root = ""/run/runc""

# The above is the original content



# Add our crunw runtime here

[crio.runtime.runtimes.crun]

runtime_path = ""/usr/bin/crun""

runtime_type = ""oci""

runtime_root = ""/run/crun""

```



Next, restart CRI-O to apply the configuration changes.



```bash

systemctl restart crio

```



## Run a simple WebAssembly app



Now, we can run a simple WebAssembly program using CRI-O. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. In this section, we will start pulling this WebAssembly-based container image from the Docker hub using CRI-O tools.



```bash

sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation

```



Next, we must create two simple configuration files that specify how CRI-O should run this WebAssembly image in a sandbox. We already have those two files [container_wasi.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json) and [sandbox_config.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json). You can download them to your local directory as follows.



```bash

wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json

wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json

```



Now you can use CRI-O to create a pod and a container using the specified configurations.



```bash

# Create the POD. The output will be different from the example.

$ sudo crictl runp sandbox_config.json

7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Set a helper variable for later use.

$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4



# Create the container instance. The output will be different from the example.

$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json

# Set a helper variable for later use.

CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f

```



Starting the container would execute the WebAssembly program. You can see the output in the console.



```bash

# List the container; the state should be `Created`

$ sudo crictl ps -a

CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID

1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc



# Start the container

$ sudo crictl start $CONTAINER_ID



# recheck the container status.

# If the container is not finishing its job, you will see the Running state

# Because this example is very tiny. You may see Exited at this moment.

$ sudo crictl ps -a

CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID

1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc



# When the container is finished. You can see the state becomes Exited.

$ sudo crictl ps -a

CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID

1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc



# Check the container's logs. It should show outputs from the WebAssembly programs

$ sudo crictl logs $CONTAINER_ID



Test 1: Print Random Number

Random number: 960251471



Test 2: Print Random Bytes

Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]



Test 3: Call an echo function

Printed from wasi: This is from a main function

This is from a main function



Test 4: Print Environment Variables

The env vars are as follows.

PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

TERM: xterm

HOSTNAME: crictl_host

PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

The args are as follows.

/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm

50000000



Test 5: Create a file `/tmp.txt` with content `This is in a file`



Test 6: Read the content from the previous file

File content is This is in a file



Test 7: Delete the previous file

```



Next, you can try to run the app in [Kubernetes](../kubernetes/kubernetes-cri-o.md)!



## Run a HTTP server app



Finally, we can run a simple WebAssembly-based HTTP micro-service in CRI-O. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub. In this section, we will start off pulling this WebAssembly-based container image from Docker hub using CRI-O tools.



```bash

sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation

```



Next, we must create two simple configuration files that specify how CRI-O should run this WebAssembly image in a sandbox. We already have those two files [container_http_server.json](https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json) and [sandbox_config.json](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json). You can download them to your local directory as follows.



<!-- prettier-ignore -->

:::note

The `sandbox_config.json` file is the same for the simple WASI and HTTP server examples. The other `container_*.json` file is application specific as it contains the application's Docker Hub URL.

:::



```bash

wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json

wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json

```



Now you can use CRI-O to create a pod and a container using the specified configurations.



```bash

# Create the POD. Output will be different from example.

$ sudo crictl runp sandbox_config.json

7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Set a helper variable for later use.

$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4



# Create the container instance. The output will be different from the example.

$ sudo crictl create $POD_ID container_http_server.json sandbox_config.json

# Set a helper variable for later use.

CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f

```



Starting the container would execute the WebAssembly program. You can see the output in the console.



```bash

# Start the container

$ sudo crictl start $CONTAINER_ID



# Check the container status. It should be Running.

# If not, wait a few seconds and check again

$ sudo crictl ps -a

CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID

4eeddf8613691       wasmedge/example-wasi-http:latest              Less than a second ago   Running             http_server         0                   1d84f30e7012e



# Check the container's logs to see if the HTTP server is listening at port 1234

$ sudo crictl logs $CONTAINER_ID

new connection at 1234



# Get the IP address assigned to the container

$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'""' -f 2

10.85.0.2



# Test the HTTP service at that IP address

$ curl -d ""name=WasmEdge"" -X POST http://10.85.0.2:1234

echo: name=WasmEdge

```



Next, you can run it in [Kubernetes](../kubernetes/kubernetes-cri-o.md)!








------"
"```json:/develop/deploy/gpu/_category_.json


{

    ""label"": ""Manage LLM workloads on GPU"",

    ""position"": 7,

    ""link"": {

      ""type"": ""generated-index"",

      ""description"": ""In this chapter, we will demonstrate how to use container tools to mange LLM WasmEdge workloads on GPU.""

    }

  }

  






```"
"The following is a markdown document located at /develop/deploy/gpu/docker_wasm_gpu.md
------


---

sidebar_position: 5

---



# Docker + WASM + GPU



This is a completely new approach, adopting Docker + Crun with Wasmedge + [CDI](https://github.com/cncf-tags/container-device-interface) to enable the usage of host GPU devices. The reason for not continuing with the use of runwasi as the wasm runtime within Docker from the previous chapter is due to considerations of the current stage of support for CDI and the compatibility approach.



## Prerequisite



Before we start, you need



- GPU device (Here we will take NVIDIA graphics cards as our example and we have only conducted tests on NVIDIA GPUs on linux for now)

  - Install NVIDIA GPU Driver

  - Install either the NVIDIA Container Toolkit or you installed the nvidia-container-toolkit-base package.

- Docker version > 4.29 (which includes Moby 25)



Regarding the installation of the NVIDIA driver and toolkit, we won't go into detail here, but we could provide a few reference documents and the ways to verify your environment is ok.



[Nvidia drivers installation on ubuntu](https://ubuntu.com/server/docs/nvidia-drivers-installation), [Toolkit install guide](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html), [Nvidia CDI supoort reference](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html)



```bash

# check your driver and device

> nvidia-smi -L



# Check your toolkit

> nvidia-ctk --version

```



Install latest docker-ce



```bash

> curl -fsSL https://get.docker.com -o get-docker.sh

> sh get-docker.sh



# Check your docker

> docker --version

```



## CDI setup



[Generate the CDI specification file](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html#procedure)



```bash

> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml



# Check you cdi config is good

> nvidia-ctk cdi list



# Example output

INFO[0000] Found 2 CDI devices

nvidia.com/gpu=0

nvidia.com/gpu=all

```



[Enable CDI in docker config](https://docs.docker.com/reference/cli/dockerd/#enable-cdi-devices) (/etc/docker/daemon.json)



```json

{

  ""features"": {

     ""cdi"": true

  },

  ""cdi-spec-dirs"": [""/etc/cdi/"", ""/var/run/cdi""]

}

```



```bash

# Reload docker daemon

> sudo systemctl reload docker



# Test your cdi setup good

> docker run --rm --device nvidia.com/gpu=all ubuntu:22.04 nvidia-smi -L



# Example output 

GPU 0: NVIDIA GeForce GTX 1080 (UUID: GPU-********-****-****-****-************)

```



## Setup your container runtime (crun + wasmedge + plugin system)



Build crun with wasmedge enable



```bash

> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake



> git clone https://github.com/containers/crun

> cd crun

> ./autogen.sh

> ./configure --with-wasmedge

> make



# Check your crun

> ./crun --version

```



Replace container run time



```json

{

  ""runtimes"": {

    ""crun"": {

      ""path"": ""<The crun binary path is built by yourself>""

    }

  },

  ""features"": {

    ""cdi"": true

  },

  ""cdi-spec-dirs"": [""/etc/cdi/"", ""/var/run/cdi""]

}

```



```bash

# Reload docker daemon

> sudo systemctl reload docker

```



Download ggml plugin into host



```bash

> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml



# Make sure all your plugin dependencies is good

> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so

```



## Demo llama with our wasm application



> The demo image is built the Wasm application from [here](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-ggml/llama), and upload it to [here](https://github.com/captainvincent/runwasi/pkgs/container/runwasi-demo/195178675?tag=wasmedge-ggml-llama).



Download inference model



```bash

> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf

```



Docker run llama2 inference



```bash

docker run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \

  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \

  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \

  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \

  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \

  -v .:/resource \

  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \

  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \

  --env n_gpu_layers=100 \

  --rm --device nvidia.com/gpu=all --runtime=crun --annotation=module.wasm.image/variant=compat-smart --platform wasip1/wasm \

  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \

  $'[INST] <<SYS>>\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\n<</SYS>>\nWhat is the capital of Japan?[/INST]'

```



Example Result



```bash

ggml_init_cublas: GGML_CUDA_FORCE_MMQ:   no

ggml_init_cublas: CUDA_USE_TENSOR_CORES: yes

ggml_init_cublas: found 1 CUDA devices:

  Device 0: NVIDIA GeForce GTX 1080, compute capability 6.1, VMM: yes

Prompt:

[INST] <<SYS>>

You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.

<</SYS>>

What is the capital of Japan?[/INST]

Response:

[INFO] llama_commit: ""4ffcdce2""

[INFO] llama_build_number: 2334

[INFO] Number of input tokens: 140

Thank you for asking! The capital of Japan is Tokyo. I'm glad you asked! It's important to be informed and curious about different countries and their capitals. Is there anything else I can help you with?

[INFO] Number of input tokens: 140

[INFO] Number of output tokens: 48

```








------"
"The following is a markdown document located at /develop/deploy/gpu/podman_wasm_gpu.md
------


---

sidebar_position: 6

---



# Podman + WASM + GPU



Podman + Crun with Wasmedge + [CDI](https://github.com/cncf-tags/container-device-interface) to enable the usage of host GPU devices. Most of the steps are the same with [docker + wasm + gpu](./docker_wasm_gpu.md), except for the installation of Podman and execution command. If the following steps have already been executed before, you could just skip them.



## Prerequisite



Before we start, you need



- GPU device (Here we will take NVIDIA graphics cards as our example and we have only conducted tests on NVIDIA GPUs on linux for now)

  - Install NVIDIA GPU Driver

  - Install either the NVIDIA Container Toolkit or you installed the nvidia-container-toolkit-base package.

- Podman >= 4.x



Regarding the installation of the NVIDIA driver and toolkit, we won't go into detail here, but we could provide a few reference documents and the ways to verify your environment is ok.



[Nvidia drivers installation on ubuntu](https://ubuntu.com/server/docs/nvidia-drivers-installation), [Toolkit install guide](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html), [Nvidia CDI supoort reference](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html)



```bash

# check your driver and device

> nvidia-smi -L



# Check your toolkit

> nvidia-ctk --version

```



Install podman >= 4.0



The current testing phase involves directly installing Podman from Linuxbrew to meet version requirements. There may be more elegant methods in the future, and we will update the documentation accordingly.



```bash

> brew install podman



# Check your podman version and you could add it to your $PATH, too.

> $HOME/.linuxbrew/opt/podman/bin/podman --version

```



## CDI setup



[Generate the CDI specification file](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html#procedure)



```bash

> sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml



# Check you cdi config is good

> nvidia-ctk cdi list



# Example output

INFO[0000] Found 2 CDI devices

nvidia.com/gpu=0

nvidia.com/gpu=all

```



## Setup your container runtime (crun + wasmedge + plugin system)



Build crun with wasmedge enable



```bash

> sudo apt install -y make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake



> git clone https://github.com/containers/crun

> cd crun

> ./autogen.sh

> ./configure --with-wasmedge

> make



# Check your crun

> ./crun --version

```



Download ggml plugin into host



```bash

> curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml



# Make sure all your plugin dependencies is good

> ldd ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so

```



## Demo llama with our wasm application



> The demo image is built the Wasm application from [here](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-ggml/llama), and upload it to [here](https://github.com/captainvincent/runwasi/pkgs/container/runwasi-demo/195178675?tag=wasmedge-ggml-llama).



Download inference model



```bash

> curl -LO https://huggingface.co/second-state/Llama-2-7B-Chat-GGUF/resolve/main/llama-2-7b-chat.Q5_K_M.gguf

```



Podman run llama2 inference



> You need to replace the  `<podman path>` and `<crun path>` with your binary path in the following command.



```bash

sudo <podman path> run -v ~/.wasmedge/plugin/libwasmedgePluginWasiNN.so:/.wasmedge/plugin/libwasmedgePluginWasiNN.so \

  -v /usr/local/cuda/targets/x86_64-linux/lib/libcudart.so.12:/lib/x86_64-linux-gnu/libcudart.so.12 \

  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublas.so.12:/lib/x86_64-linux-gnu/libcublas.so.12 \

  -v /usr/local/cuda/targets/x86_64-linux/lib/libcublasLt.so.12:/lib/x86_64-linux-gnu/libcublasLt.so.12 \

  -v /lib/x86_64-linux-gnu/libcuda.so.1:/lib/x86_64-linux-gnu/libcuda.so.1 \

  -v .:/resource \

  --env WASMEDGE_PLUGIN_PATH=/.wasmedge/plugin \

  --env WASMEDGE_WASINN_PRELOAD=default:GGML:AUTO:/resource/llama-2-7b-chat.Q5_K_M.gguf \

  --env n_gpu_layers=100 \

  --rm --device nvidia.com/gpu=all --runtime <crun path> --annotation module.wasm.image/variant=compat-smart --platform wasip1/wasm \

  ghcr.io/captainvincent/runwasi-demo:wasmedge-ggml-llama default \

  $'[INST] <<SYS>>\nYou are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.\n<</SYS>>\nWhat is the capital of Japan?[/INST]'

```



Example Result



```bash

ggml_init_cublas: GGML_CUDA_FORCE_MMQ:   no

ggml_init_cublas: CUDA_USE_TENSOR_CORES: yes

ggml_init_cublas: found 1 CUDA devices:

  Device 0: NVIDIA GeForce GTX 1080, compute capability 6.1, VMM: yes

Prompt:

[INST] <<SYS>>

You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe.  Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature. If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you do not know the answer to a question, please do not share false information.

<</SYS>>

What is the capital of Japan?[/INST]

Response:

[INFO] llama_commit: ""4ffcdce2""

[INFO] llama_build_number: 2334

[INFO] Number of input tokens: 140

Thank you for your kind request! The capital of Japan is Tokyo. I'm glad to help! Please let me know if you have any other questions.

[INFO] Number of input tokens: 140

[INFO] Number of output tokens: 34

```








------"
"```json:/develop/deploy/kubernetes/_category_.json


{

  ""label"": ""Kubernetes Use Cases"",

  ""position"": 7,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will discuss how popular software applications embed WasmEdge to support extended functionalities.""

  }

}








```"
"The following is a markdown document located at /develop/deploy/kubernetes/docker-slim.md
------


---

sidebar_position: 11

---



# WasmEdge DockerSlim



The `wasmedge/slim:{version}` Docker images provide slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.



- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.

- Image `wasmedge/slim:{version}` includes the following command line utilities:

  - `wasmedge`

  - `wasmedge compile`

- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:

  - `wasmedge`

  - `wasmedge compile`

  - `wasmedge-tensorflow-lite`

  - `wasmedge-tensorflow`

  - `show-tflite-tensor`

- The working directory of the release docker image is `/app`.



<!-- prettier-ignore -->

:::note

The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.

:::



## Examples



Use `wasmedge compile` and `wasmedge` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm)):



```bash

$ docker pull wasmedge/slim:{{ wasmedge_version }}



$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm

[2022-07-07 08:15:49.154] [info] compile start

[2022-07-07 08:15:49.163] [info] verify start

[2022-07-07 08:15:49.169] [info] optimize start

[2022-07-07 08:15:49.808] [info] codegen start

[2022-07-07 08:15:50.419] [info] output start

[2022-07-07 08:15:50.421] [info] compile done

[2022-07-07 08:15:50.422] [info] output start



$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world

hello

world

```



Use `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):



```bash

$ docker pull wasmedge/slim-tf:{{ wasmedge_version }}

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js



$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:{{ wasmedge_version }} wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js

label:

Hot dog

confidence:

0.8941176470588236

```








------"
"The following is a markdown document located at /develop/deploy/kubernetes/kind.md
------


---

sidebar_position: 7

---



# Kind



KinD is a Kubernetes distribution that runs inside Docker and is well-suited for local development or integration testing. It runs containerd as CRI and crun as OCI Runtime.



<!-- prettier-ignore -->

:::note

This demo is based on containerd + crun.

:::



## Quick start



As a prerequisite, we need to install KinD first. To do that, the [quick start guide](https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries) and the [release page](https://github.com/kubernetes-sigs/kind/releases) can be used to install the latest version of the KinD CLI.



If KinD is installed, we can directly start with the example from [here](https://github.com/Liquid-Reply/kind-crun-wasm):



```bash

# Create a ""WASM in KinD"" Cluster

kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0

# Run the example

kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000

```



In the rest of this section, we will explain how to create a KinD node image with wasmedge support.



## Build crun



KinD uses the `kindest/node` image for the control plane and worker nodes. The image contains containerd as CRI and runc as OCI Runtime. To enable WasmEdge support, we replace `runc` with `crun`.



We only need the crun binary for the node image and not the entire build toolchain. Therefore we use a multistage dockerfile where we create crun in the first step and only copy the crun binary to the node image.



```Dockerfile

FROM ubuntu:21.10 AS builder

WORKDIR /data

RUN DEBIAN_FRONTEND=noninteractive apt update \

    && DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \

    && curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \

    && git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \

    && cd crun \

    && ./autogen.sh \

    && ./configure --with-wasmedge --enable-embedded-yajl\

    && make



...

```



Now we have a fresh `crun` binary with wasmedge enabled under `/data/crun/crun` that we can copy from this container in the next step.



## Replace crun and configure containerd



Both runc and crun implement the OCI runtime spec and have the same CLI parameters. Therefore we can replace the runc binary with our crun-wasmedge binary we created before.



Since crun is using shared libraries we need to install libyajl, wasmedge and criu to make our crun work.



Now we have a KinD that uses crun instead of runc. Now we need two config changes. The first one is in the `/etc/containerd/config.toml` where we add the `pod_annotations`that can be passed to the runtime:



```toml

[plugins.""io.containerd.grpc.v1.cri"".containerd.runtimes.runc]

  pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]

```



And the second one to the `/etc/containerd/cri-base.json` where we remove a hook that causes some issues.



The resulting dockerfile looks as follows:



```Dockerfile

...



FROM kindest/node:v1.23.0



COPY config.toml /etc/containerd/config.toml

COPY --from=builder /data/crun/crun /usr/local/sbin/runc

COPY --from=builder /usr/local/lib/libwasmedge.so /usr/local/lib/libwasmedge.so



RUN echo ""Installing Packages ..."" \

    && bash -c 'cat <<< $(jq ""del(.hooks.createContainer)"" /etc/containerd/cri-base.json) > /etc/containerd/cri-base.json' \

    && ldconfig

```



## Build and test



Finally, we can build a new `node-wasmedge` image. We create a kind cluster from that image and run the simple app example to test it.



```bash

docker build -t node-wasmedge .

kind create cluster --image node-wasmedge

# Now you can run the example to validate your cluster

kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000

```








------"
"The following is a markdown document located at /develop/deploy/kubernetes/knative.md
------


---

sidebar_position: 8

---



# Knative



Knative is a platform-agnostic solution for running serverless deployments.



## Quick start



You can refer to [Kubernetes + containerd] to build a Kubernetes cluster. However, as the default runtime is replaced from runc to crun in this document, it is not suitable for the existing k8s cluster.



Here we set up crun as a runtimeClass in the kubernetes cluster, **rather than replace the default runtime**. Then deploy Knative serving service and run a WASM serverless service.



## Compile crun



Please refer to the document [crun](../../deploy/oci-runtime/crun.md) to build and compile crun with WasmEdge support.



```bash

# Install dependencies

$ sudo apt update

$ sudo apt install -y make git gcc build-essential pkgconf libtool \

    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \

    go-md2man libtool autoconf python3 automake



# Compile crun

$ git clone https://github.com/containers/crun

$ cd crun

$ ./autogen.sh

$ ./configure --with-wasmedge

$ make

$ sudo make install

```



## Install and setup Containerd



To make things easy, we use apt to install containerd. Here is the [document for ubuntu](https://docs.docker.com/engine/install/ubuntu/) Once you have installed the containerd, edit the configuration `/etc/containerd/config.toml`.



```bash

$ cat /etc/containerd/config.toml



# comment this line to make cri wokrs

# disabled_plugins = [""cri""]



# add the following section to setup crun runtime, make sure the BinaryName equal to your crun binary path

[plugins]

  [plugins.cri]

    [plugins.cri.containerd]

      [plugins.cri.containerd.runtimes]

...

        [plugins.cri.containerd.runtimes.crun]

           runtime_type = ""io.containerd.runc.v2""

           pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]

           privileged_without_host_devices = false

           [plugins.cri.containerd.runtimes.crun.options]

             BinaryName = ""/usr/local/bin/crun""

...



# restart containerd service

$ sudo systemctl restart containerd



# check if crun works

$ ctr image pull docker.io/wasmedge/example-wasi:latest

$ ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000

Creating POD ...

Random number: -1678124602

Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

```



## Creating a cluster with kubeadm



Refering to the tree documents [Installing kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/), [Creating a cluster with kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/) and [Install flannel cni](https://github.com/flannel-io/flannel#deploying-flannel-manually), to create a kubernetes cluster.



```bash

# install kubeadm

$ sudo apt-get update

$ sudo apt-get install -y apt-transport-https ca-certificates curl

$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg

$ echo ""deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main"" | sudo tee /etc/apt/sources.list.d/kubernetes.list

$ sudo apt-get update

$ sudo apt-get install -y kubelet kubeadm kubectl

$ sudo apt-mark hold kubelet kubeadm kubectl



# create kubernetes cluster

$ swapoff -a

$ kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket unix:///var/run/containerd/containerd.sock

$ export KUBECONFIG=/etc/kubernetes/admin.conf



# install cni

$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml



# untaint master node

$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-



# add crun runtimeClass

$ cat > runtime.yaml <<EOF

apiVersion: node.k8s.io/v1

kind: RuntimeClass

metadata:

  name: crun

handler: crun

EOF

$ kubectl apply -f runtime.yaml



# Verify if the configuration works

$ kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true, ""runtimeClassName"": ""crun""}}' /wasi_example_main.wasm 50000000

Random number: 1534679888

Random bytes: [88, 170, 82, 181, 231, 47, 31, 34, 195, 243, 134, 247, 211, 145, 28, 30, 162, 127, 234, 208, 213, 192, 205, 141, 83, 161, 121, 206, 214, 163, 196, 141, 158, 96, 137, 151, 49, 172, 88, 234, 195, 137, 44, 152, 7, 130, 41, 33, 85, 144, 197, 25, 104, 236, 201, 91, 210, 17, 59, 248, 80, 164, 19, 10, 46, 116, 182, 111, 112, 239, 140, 16, 6, 249, 89, 176, 55, 6, 41, 62, 236, 132, 72, 70, 170, 7, 248, 176, 209, 218, 214, 160, 110, 93, 232, 175, 124, 199, 33, 144, 2, 147, 219, 236, 255, 95, 47, 15, 95, 192, 239, 63, 157, 103, 250, 200, 85, 237, 44, 119, 98, 211, 163, 26, 157, 248, 24, 0]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

pod ""wasi-demo"" deleted

```



## Setting up Knative Serving



Referring to [Installing Knative Serving using YAML files](https://knative.dev/docs/install/yaml-install/serving/install-serving-with-yaml/), install the knative serving service.



```bash

# install the Knative Serving component

$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-crds.yaml

$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-core.yaml



# install a networking layer

$ kubectl apply -f https://github.com/knative/net-kourier/releases/download/knative-v1.7.0/kourier.yaml

$ kubectl patch configmap/config-network \

  --namespace knative-serving \

  --type merge \

  --patch '{""data"":{""ingress-class"":""kourier.ingress.networking.knative.dev""}}'

$ kubectl --namespace kourier-system get service kourier



# verify the installation

$ kubectl get pods -n knative-serving



# open runtimeClass feature gate in Knative

$ kubectl patch configmap/config-features -n knative-serving --type merge --patch '{""data"":{""kubernetes.podspec-runtimeclassname"":""enabled""}}'

```



## WASM cases in Knative Serving



Now we can run a WASM serverless service.



```bash

# apply the serverless service configuration

# We need setup annotations, runtimeClassName, and ports.

$ cat > http-wasm-serverless.yaml <<EOF

apiVersion: serving.knative.dev/v1

kind: Service

metadata:

  name: http-wasm

  namespace: default

spec:

  template:

    metadata:

      annotations:

        module.wasm.image/variant: compat-smart

    spec:

      runtimeClassName: crun

      timeoutSeconds: 1

      containers:

      - name: http-server

        image: docker.io/wasmedge/example-wasi-http:latest

        ports:

        - containerPort: 1234

          protocol: TCP

        livenessProbe:

          tcpSocket:

            port: 1234

EOF



$ kubectl apply -f http-wasm-serverless.yaml



# wait for a while, and check if the serverless service is available

$ kubectl get ksvc http-wasm

NAME          URL                                              LATESTCREATED       LATESTREADY         READY   REASON

http-wasm     http://http-wasm.default.knative.example.com     http-wasm-00001     http-wasm-00001     True



# Try to call the service

# As we do not set up DNS, we can only call the service via Kourier, Knative Serving ingress port.

# get Kourier port which is 31997 in following example

$ kubectl --namespace kourier-system get service kourier

NAME      TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE

kourier   LoadBalancer   10.105.58.134                     80:31997/TCP,443:31019/TCP   53d

$ curl -H ""Host: http-wasm.default.knative.example.com"" -d ""name=WasmEdge"" -X POST http://localhost:31997



# check the new start pod

$ kubectl get pods

NAME                                           READY   STATUS    RESTARTS   AGE

http-wasm-00001-deployment-748bdc7cf-96l4r     2/2     Running   0          19s

```








------"
"The following is a markdown document located at /develop/deploy/kubernetes/kubedge.md
------


---

sidebar_position: 6

---



# KubeEdge



KubeEdge is an open-source system for extending native containerized application orchestration capabilities to hosts at Edge.



<!-- prettier-ignore -->

:::note

This demo is based on [crun's support](../../deploy/oci-runtime/crun.md)

:::



## 1. Setup Cloud Side (KubeEdge Master Node)



### Install Go



```bash

$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz

$ tar xzvf go1.17.3.linux-amd64.tar.gz



$ export PATH=/home/${user}/go/bin:$PATH

$ go version

go version go1.17.3 linux/amd64

```



### Install CRI-O



Please see [CRI-O Installation Instructions](https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o).



```bash

# Create the .conf file to load the modules at bootup

cat <<EOF | sudo tee /etc/modules-load.d/crio.conf

overlay

br_netfilter

EOF



sudo modprobe overlay

sudo modprobe br_netfilter



# Set up required sysctl params; these persist across reboots.

cat <<EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf

net.bridge.bridge-nf-call-iptables  = 1

net.ipv4.ip_forward                 = 1

net.bridge.bridge-nf-call-ip6tables = 1

EOF



sudo sysctl --system

export OS=""xUbuntu_20.04""

export VERSION=""1.21""

cat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list

deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /

EOF

cat <<EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /

EOF



curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -



sudo apt-get update

sudo apt-get install cri-o cri-o-runc



sudo systemctl daemon-reload

sudo systemctl enable crio --now

sudo systemctl status cri-o

```



output:



```bash

$ sudo systemctl status cri-o

● crio.service - Container Runtime Interface for OCI (CRI-O)

     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)

     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago

       Docs: https://github.com/cri-o/cri-o

   Main PID: 6868 (crio)

      Tasks: 14

     Memory: 133.2M

     CGroup: /system.slice/crio.service

             └─6868 /usr/bin/crio



Dec 07 06:04:13 master crio[6868]: time=""2021-12-07 06:04:13.694226800Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic>

Dec 07 06:04:13 master crio[6868]: time=""2021-12-07 06:04:13.695739507Z"" level=info msg=""Image status: &{0xc00047fdc0 map[]}"" id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta>

Dec 07 06:09:13 master crio[6868]: time=""2021-12-07 06:09:13.698823984Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic>

Dec 07 06:09:13 master crio[6868]: time=""2021-12-07 06:09:13.703259157Z"" level=info msg=""Image status: &{0xc0004d98f0 map[]}"" id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta>

Dec 07 06:14:13 master crio[6868]: time=""2021-12-07 06:14:13.707778419Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic>

Dec 07 06:14:13 master crio[6868]: time=""2021-12-07 06:14:13.709379469Z"" level=info msg=""Image status: &{0xc000035030 map[]}"" id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta>

Dec 07 06:19:13 master crio[6868]: time=""2021-12-07 06:19:13.713158978Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic>

Dec 07 06:19:13 master crio[6868]: time=""2021-12-07 06:19:13.714030148Z"" level=info msg=""Image status: &{0xc000162bd0 map[]}"" id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta>

Dec 07 06:24:13 master crio[6868]: time=""2021-12-07 06:24:13.716746612Z"" level=info msg=""Checking image status: registry.k8s.io/pause:3.4.1"" id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic>

Dec 07 06:24:13 master crio[6868]: time=""2021-12-07 06:24:13.717381882Z"" level=info msg=""Image status: &{0xc00042ce00 map[]}"" id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta>

```



### Install and Creating a cluster with kubeadm for K8s



Please see [Creating a cluster with kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/).



#### Install K8s



```bash

sudo apt-get update

sudo apt-get install -y apt-transport-https curl

echo ""deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main"" | sudo tee /etc/apt/sources.list.d/kubernetes.list



sudo apt update

K_VER=""1.21.0-00""

sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}

sudo apt-mark hold kubelet kubeadm kubectl

```



#### Create a cluster with kubeadm



```bash

#kubernetes scheduler requires this setting to be done.

$ sudo swapoff -a

$ sudo vim /etc/fstab

mark contain swapfile of row



$ cat /etc/cni/net.d/100-crio-bridge.conf

{

    ""cniVersion"": ""0.3.1"",

    ""name"": ""crio"",

    ""type"": ""bridge"",

    ""bridge"": ""cni0"",

    ""isGateway"": true,

    ""ipMasq"": true,

    ""hairpinMode"": true,

    ""ipam"": {

        ""type"": ""host-local"",

        ""routes"": [

            { ""dst"": ""0.0.0.0/0"" },

            { ""dst"": ""1100:200::1/24"" }

        ],

        ""ranges"": [

            [{ ""subnet"": ""10.85.0.0/16"" }],

            [{ ""subnet"": ""1100:200::/24"" }]

        ]

    }

}

$ export CIDR=10.85.0.0/16

$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock



$ mkdir -p $HOME/.kube

$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

$ sudo chown $(id -u):$(id -g) $HOME/.kube/config

```



output:



```bash

Your Kubernetes control-plane has initialized successfully!



To start using your cluster, you need to run the following as a regular user:



  mkdir -p $HOME/.kube

  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

  sudo chown $(id -u):$(id -g) $HOME/.kube/config



You should now deploy a Pod network to the cluster.

Run ""kubectl apply -f [podnetwork].yaml"" with one of the options listed at:

  /docs/concepts/cluster-administration/addons/



You can now join any number of machines by running the following on each node

as root:



  kubeadm join <control-plane-host>:<control-plane-port> --token <token> --discovery-token-ca-cert-hash sha256:<hash>

```



To make kubectl work for your non-root user, run these commands, which are also part of the kubeadm init output:



```bash

mkdir -p $HOME/.kube

sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

sudo chown $(id -u):$(id -g) $HOME/.kube/config

```



### Setup KubeEdge Master Node



Please see [Deploying using Keadm](https://kubeedge.io/en/docs/setup/keadm/).



1. At least one kubeconfig or master must be configured correctly so that it can be used to verify the version and other info of the k8s cluster.

2. Please make sure the edge node can connect to the cloud node using the local IP of the cloud node, or you need to specify the public IP of the cloud node with the --advertise-address flag.

3. --advertise-address(only worked since 1.3 release) is the address exposed by the cloud side (will be added to the SANs of the CloudCore certificate); the default value is the local IP.



```bash

wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz

tar xzvf keadm-v1.8.0-linux-amd64.tar.gz

cd keadm-v1.8.0-linux-amd64/keadm/

sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config

```



output:



```bash

Kubernetes version verification passed, KubeEdge installation will start...

...

KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log

```



## 2. Setup Edge Side (KubeEdge Worker Node)



You can use the CRI-O [install.sh] script to install CRI-O and `crun` on Ubuntu 20.04.



```bash

wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash

```



### Install Go on Edge Side



```bash

$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz

$ tar xzvf go1.17.3.linux-amd64.tar.gz



$ export PATH=/home/${user}/go/bin:$PATH

$ go version

go version go1.17.3 linux/amd64

```



### Get Token From Cloud Side



Run keadm gettoken on the cloud side will return the token, which will be used when joining edge nodes.



```bash

$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config

27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE

```



### Download KubeEdge and join edge nodes



Please see [Setting different container runtime with CRI](https://kubeedge.io/en/docs/advanced/cri/#cri-o) and [Deploying using Keadm](https://kubeedge.io/en/docs/setup/keadm/).



```bash

$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz

$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz

$ cd keadm-v1.8.0-linux-amd64/keadm/



$ sudo ./keadm join \

--cloudcore-ipport=192.168.122.160:10000 \

--edgenode-name=edge \

--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \

--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \

--runtimetype=remote \

--cgroupdriver=systemd

```



Output:



```bash

Host has mosquit+ already installed and running. Hence skipping the installation steps !!!

...

KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log

```



### Get Edge Node Status From Cloud Side



Output:



```bash

kubectl get node

NAME       STATUS    ROLES                  AGE   VERSION

edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2

master     Ready     control-plane,master   68m   v1.21.0

```



## 3. Enable kubectl logs Feature



Before metrics-server deployed, kubectl logs feature must be activated, please [see here](https://kubeedge.io/en/docs/setup/keadm/#enable-kubectl-logs-feature).



## 4. Run a simple WebAssembly app



We can run the WebAssembly-based image from Docker Hub in the Kubernetes cluster.



### Cloud Side



```bash

$ kubectl run -it --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000



Random number: -1694733782

Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

```



The WebAssembly app of the pod successfully deploys to the edge node.



```bash

$ kubectl describe pod wasi-demo



Name:         wasi-demo

Namespace:    default

Priority:     0

Node:         edge/192.168.122.229

Start Time:   Mon, 06 Dec 2021 15:45:34 +0000

Labels:       run=wasi-demo

Annotations:  module.wasm.image/variant: compat-smart

Status:       Succeeded

IP:

IPs:          <none>

Containers:

  wasi-demo:

    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069

    Image:         wasmedge/example-wasi:latest

    Image ID:      docker.io/wasmedge/example-wasi@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6

    Port:          <none>

    Host Port:     <none>

    Args:

      /wasi_example_main.wasm

      50000000

    State:          Terminated

      Reason:       Completed

      Exit Code:    0

      Started:      Mon, 06 Dec 2021 15:45:33 +0000

      Finished:     Mon, 06 Dec 2021 15:45:33 +0000

    Ready:          False

    Restart Count:  0

    Environment:    <none>

    Mounts:

      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)

Conditions:

  Type           Status

  Initialized    True

  Ready          False

  PodScheduled   True

Volumes:

  kube-api-access-bhszr:

    Type:                    Projected (a volume that contains injected data from multiple sources)

    TokenExpirationSeconds:  3607

    ConfigMapName:           kube-root-ca.crt

    ConfigMapOptional:       <nil>

    DownwardAPI:             true

QoS Class:                   BestEffort

Node-Selectors:              <none>

Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s

                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s

Events:

  Type    Reason     Age   From               Message

  ----    ------     ----  ----               -------

```



### Edge Side



```bash

$ sudo crictl ps -a

CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID

1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda

1e6c7cb6bc731       registry.k8s.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866

```



That's it.



## 5. Demo Run Screen Recording



[![asciicast](https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg)](https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh)








------"
"The following is a markdown document located at /develop/deploy/kubernetes/kubernetes-containerd-crun.md
------


---

sidebar_position: 1

---



# Kubernetes + containerd + crun



## Quick start



The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + containerd + crun.



- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml)

- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml)



In the rest of this section, we will explain the steps in detail.



We assume you have already [installed and configured containerd](../../deploy/cri-runtime/containerd-crun.md) to work with WasmEdge container images.



## Install and start Kubernetes



Run the following commands from a terminal window. It sets up Kubernetes for local development.



```bash

# Install go

$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz

$ sudo rm -rf /usr/local/go

$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz

$ source /home/${USER}/.profile



# Clone k8s

$ git clone https://github.com/kubernetes/kubernetes.git

$ cd kubernetes

$ git checkout v1.22.2



# Install etcd with hack script in k8s

$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh

$ export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""

$ sudo cp third_party/etcd/etcd* /usr/local/bin/



# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl



# Build and run k8s with containerd

$ sudo apt-get install -y build-essential

$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh



... ...

Local Kubernetes cluster is running. Press Ctrl-C to shut it down.

```



Do NOT close your terminal window. Kubernetes is running!



## Run WebAssembly container images in Kubernetes



Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.



```bash

export KUBERNETES_PROVIDER=local



sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt

sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt

sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself

sudo cluster/kubectl.sh config use-context local

sudo cluster/kubectl.sh

```



Let's check the status to make sure that the cluster is running.



```bash

$ sudo cluster/kubectl.sh cluster-info



# Expected output

Cluster ""local"" set.

User ""myself"" set.

Context ""local"" created.

Switched to context ""local"".

Kubernetes control plane is running at https://localhost:6443

CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy



To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.

```



### A simple WebAssembly app



[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.



```bash

sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000

```



The output from the containerized application is printed into the console.



```bash

Random number: 401583443

Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

pod ""wasi-demo-2"" deleted

```



### A WebAssembly-based HTTP service



[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.



```bash

sudo cluster/kubectl.sh run --restart=Never http-server --image=wasmedge/example-wasi-http:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}'

```



Since we are using `hostNetwork` in the `kubectl run` command, the HTTP server image is running on the local network with IP address `127.0.0.1`. Now, you can use the `curl` command to access the HTTP service.



```bash

$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234

echo: name=WasmEdge

```



That's it!








------"
"The following is a markdown document located at /develop/deploy/kubernetes/kubernetes-containerd-runwasi.md
------


---

sidebar_position: 3

---



# Kubernetes + Containerd + Runwasi



## Quick start



The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + containerd + runwasi.



- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml)

- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml)



In the rest of this section, we will explain the steps in detail.



## Prerequisites for this setup



Please ensure that you have completed the following steps before proceeding with this setup.



- Install the latest version of [Wasmedge](../../../start/install.md)

- Ensure that you have containerd setup following the [instructions here](../../deploy/cri-runtime/containerd-crun.md).

- Ensure that you have installed and [setup runwasi](../../deploy/cri-runtime/containerd.md) for containerd-shim-wasmedge



## Install and start Kubernetes



Run the following commands from a terminal window. It sets up Kubernetes for local development.



```bash

# Install go

$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz

$ sudo rm -rf /usr/local/go

$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz

$ source /home/${USER}/.profile



# Clone k8s

$ git clone https://github.com/kubernetes/kubernetes.git

$ cd kubernetes

$ git checkout v1.22.2



# Install etcd with hack script in k8s

$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/install-etcd.sh

$ export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""

$ sudo cp third_party/etcd/etcd* /usr/local/bin/



# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl



# Build and run k8s with containerd

$ sudo apt-get install -y build-essential

$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/containerd/containerd.sock' ./hack/local-up-cluster.sh



... ...

Local Kubernetes cluster is running. Press Ctrl-C to shut it down.

```



Do NOT close your terminal window. Kubernetes is running!



## Run and test the Kubernetes Cluster



Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.



```bash

export KUBERNETES_PROVIDER=local



sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt

sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt

sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself

sudo cluster/kubectl.sh config use-context local

sudo cluster/kubectl.sh

```



Let's check the status to make sure that the cluster is running.



```bash

$ sudo cluster/kubectl.sh cluster-info



# Expected output

Cluster ""local"" set.

User ""myself"" set.

Context ""local"" created.

Switched to context ""local"".

Kubernetes control plane is running at https://localhost:6443

CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy



To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.

```



## Configure containerd and Kubernetes for Wasmedge Runtime



Next we will configure containerd to add support for the containerd-shim-wasmedge.

Please ensure that you have [setup runwasi](../../deploy/cri-runtime/containerd.md) to work with WasmEdge container images.



```bash

# Run the following command as root user

sudo bash -c ""containerd config default > /etc/containerd/config.toml""

echo '[plugins.""io.containerd.grpc.v1.cri"".containerd.runtimes.wasmedge] runtime_type = ""io.containerd.wasmedge.v1""' | sudo tee -a /etc/containerd/config.toml > /dev/null

sudo systemctl restart containerd

```



Next we will create a RuntimeClass in Kubernetes to specify usage of wasmedge runtime for objects labeled as `runtime=wasm`



```bash

sudo cluster/kubectl.sh apply -f - <<< '{""apiVersion"":""node.k8s.io/v1"",""kind"":""RuntimeClass"",""metadata"":{""name"":""wasm""},""scheduling"":{""nodeSelector"":{""runtime"":""wasm""}},""handler"":""wasmedge""}'

```



Now we will label the kubernetes node as `runtime=wasm`. Note that the node where we changed the containerd configurations will be the one which we will label.



An example of how we can label the node is given below:



```bash

sudo cluster/kubectl.sh get nodes

# Sample output from the command above

NAME        STATUS     ROLES    AGE    VERSION

127.0.0.1   Ready   <none>   3h4m   v1.22.2

# Run the following command to label the node 

sudo cluster/kubectl.sh label nodes 127.0.0.1 runtime=wasm

# A successful output from the above command looks like this

node/127.0.0.1 labeled

```



### A WebAssembly-based HTTP service



[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.



```bash

sudo cluster/kubectl.sh apply -f - <<< '{""apiVersion"":""apps/v1"",""kind"":""Deployment"",""metadata"":{""name"":""http-server-deployment""},""spec"":{""replicas"":1,""selector"":{""matchLabels"":{""app"":""http-server""}},""template"":{""metadata"":{""labels"":{""app"":""http-server""}},""spec"":{""hostNetwork"":true,""runtimeClassName"":""wasm"",""containers"":[{""name"":""http-server"",""image"":""wasmedge/example-wasi-http:latest"",""ports"":[{""containerPort"":1234}]}]}}}}'

```



Since we are using `hostNetwork` in the `kubectl run` command, the HTTP server image is running on the local network with IP address `127.0.0.1`. Now, you can use the `curl` command to access the HTTP service.



```bash

$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234

echo: name=WasmEdge

```



That's it!








------"
"The following is a markdown document located at /develop/deploy/kubernetes/kubernetes-cri-o.md
------


---

sidebar_position: 2

---



# Kubernetes + CRI-O + crun



## Quick start



The [WasmEdge Containers Example](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on Kubernetes + CRI-O + crun.



- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml)

- WebAssembly-based HTTP service [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml)



In the rest of this section, we will explain the steps in detail. We assume you have already [installed and configured CRI-O](../../deploy/oci-runtime/crun.md) to work with WasmEdge container images.



## Install and start Kubernetes



Run the following commands from a terminal window. It sets up Kubernetes for local development.



```bash

# Install go

$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz

$ sudo rm -rf /usr/local/go

sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz

source /home/${USER}/.profile



# Clone k8s

git clone https://github.com/kubernetes/kubernetes.git

cd kubernetes

git checkout v1.22.2



# Install etcd with hack script in k8s

sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh

export PATH=""/home/${USER}/kubernetes/third_party/etcd:${PATH}""

sudo cp third_party/etcd/etcd* /usr/local/bin/



# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl



# Build and run k8s with CRI-O

sudo apt-get install -y build-essential

sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh



... ...

Local Kubernetes cluster is running. Press Ctrl-C to shut it down.

```



Do NOT close your terminal window. Kubernetes is running!



## Run WebAssembly container images in Kubernetes



Finally, we can run WebAssembly programs in Kubernetes as containers in pods. In this section, we will start from **another terminal window** and start using the cluster.



```bash

export KUBERNETES_PROVIDER=local



sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt

sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt

sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself

sudo cluster/kubectl.sh config use-context local

sudo cluster/kubectl.sh

```



Let's check the status to make sure that the cluster is running.



```bash

$ sudo cluster/kubectl.sh cluster-info



# Expected output

Cluster ""local"" set.

User ""myself"" set.

Context ""local"" created.

Switched to context ""local"".

Kubernetes control plane is running at https://localhost:6443

CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy



To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.

```



### A simple WebAssembly app



[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub. Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.



```bash

sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" /wasi_example_main.wasm 50000000

```



The output from the containerized application is printed into the console.



```bash

Random number: 401583443

Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

pod ""wasi-demo-2"" deleted

```



### A WebAssembly-based HTTP service



[A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md) explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub. Since the HTTP service container requires networking support provided by Kubernetes, we will use a [k8s-http_server.yaml](https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml) file to specify its exact configuration.



```yaml

apiVersion: v1

kind: Pod

metadata:

  name: http-server

  namespace: default

  annotations:

    module.wasm.image/variant: compat-smart

spec:

  hostNetwork: true

  containers:

    - name: http-server

      image: wasmedge/example-wasi-http:latest

      command: ['/http_server.wasm']

      ports:

        - containerPort: 1234

          protocol: TCP

      livenessProbe:

        tcpSocket:

          port: 1234

        initialDelaySeconds: 3

        periodSeconds: 30

```



Run the WebAssembly-based image from Docker Hub using the above `k8s-http_server.yaml` file in the Kubernetes cluster as follows.



```bash

sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml

```



The following command shows the running container applications and their IP addresses. Since we are using `hostNetwork` in the yaml configuration, the HTTP server image is running on the local network with IP address `127.0.0.1`.



```bash

$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide



NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES

default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   <none>           <none>

```



Now, you can use the `curl` command to access the HTTP service.



```bash

$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234

echo: name=WasmEdge

```



That's it!








------"
"The following is a markdown document located at /develop/deploy/kubernetes/kwasm.md
------


---

sidebar_position: 10

---



# Kwasm



[Kwasm](https://kwasm.sh/) is a Kubernetes Operator that adds WebAssembly support to your Kubernetes nodes.



## Quick start



You will need a running Kubernetes cluster to install Kwasm operator. Here we use a fresh cluster created by [kind](https://kind.sigs.k8s.io/):



```bash

kind create cluster

```



You will also need to [install helm](https://helm.sh/docs/intro/install/) to setup Kwasm:



```bash

helm repo add kwasm http://kwasm.sh/kwasm-operator/

helm repo update

helm install -n kwasm --create-namespace kwasm kwasm/kwasm-operator

kubectl annotate node --all kwasm.sh/kwasm-node=true

```



Apply the yaml file for the wasm job:



```bash

kubectl apply -f https://raw.githubusercontent.com/KWasm/kwasm-node-installer/main/example/test-job.yaml

```



After the job is finished, check the log:



```bash

kubectl logs job/wasm-test

```








------"
"The following is a markdown document located at /develop/deploy/kubernetes/openfunction.md
------


---

sidebar_position: 9

---



# OpenFunction



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /develop/deploy/kubernetes/openyurt.md
------


---

sidebar_position: 4

---



# OpenYurt



OpenYurt is an intelligent edge computing platform that aims to extend the Cloud Native ecosystem to edge computing and IoT scenarios.



This article will introduce how to run a WasmEdge simple demo app with Containerd over [OpenYurt](https://github.com/openyurtio/openyurt).



<!-- prettier-ignore -->

:::note

This demo is based on containerd + crun.

:::



## Set up an OpenYurt Cluster



Here, we introduce two ways to set up an OpenYurt Cluster. The first is to set up an OpenYurt Cluster from scratch, and use `yurtctl convert` to realize a K8s Cluster conversion to an OpenYurt Cluster. The second one is to use the ability of OpenYurt Experience Center, which is easy to achieve an OpenYurt Cluster.



### Prerequisite



|        | OS/kernel                           | Private IP/Public IP         |

| ------ | ----------------------------------- | ---------------------------- |

| Master | Ubuntu 20.04.3 LTS/5.4.0-91-generic | 192.168.3.169/120.55.126.18  |

| Node   | Ubuntu 20.04.3 LTS/5.4.0-91-generic | 192.168.3.170/121.43.113.152 |



Some steps may differ slightly depending on the operating system differences. Please refer to the installation of [OpenYurt](https://github.com/openyurtio/openyurt) and [crun](https://github.com/containers/crun).



We use `yurtctl convert` to convert a K8s Cluster to OpenYurt Cluster, so we should set up a K8s Cluster. If you use `yurtctl init/join` to set up an OpenYurt Cluster, you can skip this step, which introduces installing K8s.



Find the difference between `yurtctl convert/revert` and `yurtctl init/join`, you can refer to the following two articles.



[how to use `Yurtctl init/join`](https://openyurt.io/docs/v0.6.0/installation/yurtctl-init-join)



[Conversion between OpenYurt and Kubernetes:`yurtctl convert/revert`](https://openyurt.io/docs/v0.6.0/installation/yurtctl-convert-revert)



- Close the swap space of the master and node first.



```bash

sudo swapoff -a

//verify

free -m

```



- Configure the file /etc/hosts of two nodes as the following.



```bash

192.168.3.169  oy-master

120.55.126.18  oy-master

92.168.3.170   oy-node

121.43.113.152 oy-node

```



- Load the br_netfilter Kernel module and modify the Kernel parameter.



```bash

//load the module

sudo modprobe br_netfilter

//verify

lsmod | grep br_netfilter

// create k8s.conf

cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf

net.bridge.bridge-nf-call-ip6tables = 1

net.bridge.bridge-nf-call-iptables = 1

EOF

sudo sysctl --system

```



- Setup the value of rp-filter (adjusting the value of two parameters in `/etc/sysctl.d/10-network-security.conf` from 2 to 1 and setting up the value of /proc/sys/net/ipv4/ip_forward to 1)



```bash

sudo vi /etc/sysctl.d/10-network-security.conf

echo 1 > /proc/sys/net/ipv4/ip_forward

sudo sysctl --system

```



#### Install containerd and modify the default configure of containerd



Use the following commands to install containerd on your edge node to run a simple WasmEdge demo.



```bash

export VERSION=""1.5.7""

echo -e ""Version: $VERSION""

echo -e ""Installing libseccomp2 ...""

sudo apt install -y libseccomp2

echo -e ""Installing wget""

sudo apt install -y wget



wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum



sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz

sudo systemctl daemon-reload

```



As the crun project support WasmEdge as default, we need to configure the containerd configuration for runc. So we need to modify the runc parameters in /etc/containerd/config.toml to curn and add pod_annotation.



```bash

sudo mkdir -p /etc/containerd/

sudo bash -c ""containerd config default > /etc/containerd/config.toml""

wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff

sudo patch -d/ -p0 < containerd_config.diff

```



After that, restart containerd to make the configuration take effect.



```bash

systemctl start containerd

```



#### Install WasmEdge



Use the [simple install script](../../../start/install.md#install) to install WasmEdge on your edge node.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

```



#### Build and install crun



We need a crun binary that supports WasmEdge on the edge node. For now, the most straightforward approach is to build it yourself from the source. First, ensure that crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see [here](https://github.com/containers/crun#readme).



- Dependencies are required for the build



```bash

sudo apt update

sudo apt install -y make git gcc build-essential pkgconf libtool \

  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \

  go-md2man libtool autoconf python3 automake

```



- Configure, build, and install a crun binary with WasmEdge support.



```bash

git clone https://github.com/containers/crun

cd crun

./autogen.sh

./configure --with-wasmedge

make

sudo make install

```



### From scratch set up an OpenYurt Cluster



We will use two machines in this demo to set up an OpenYurt Cluster. One simulated cloud node is called Master, the other simulated edge node is called Node. These two nodes form the simplest OpenYurt Cluster, where OpenYurt components run on.



#### Set up a K8s Cluster



Kubernetes version 1.18.9



```bash

$ sudo apt-get update && sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https

// add K8s source

$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -

$ sudo tee /etc/apt/sources.list.d/kubernetes.list <<EOF

$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main

// install K8s components 1.18.9

$ sudo apt-get update && sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00

// Initialize the master node

$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \

--apiserver-advertise-address=192.168.3.167 \

--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers

// join the work node

$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \

   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195

```



#### Install yurtctl



Use the following command line to install yurtctl. The yurtctl CLI tool helps install/uninstall OpenYurt and convert a standard Kubernetes cluster to an OpenYurt cluster.



```bash

git clone https://github.com/openyurtio/openyurt.git

cd openyurt

make build WHAT=cmd/yurtctl

```



#### Install OpenYurt components



OpenYurt includes several components. YurtHub is the traffic proxy between the components on the node and Kube-apiserver. The YurtHub on the edge will cache the data returned from the cloud. Yurt controller supplements the upstream node controller to support edge computing requirements. TunnelServer connects with the TunnelAgent daemon running in each edge node via a reverse proxy to establish secure network access between the cloud site control plane and the edge nodes that are connected to the intranet. For more detailed information, refer to the [OpenYurt docs](https://github.com/openyurtio/openyurt).



```bash

yurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\

--yurt-controller-manager-image=""openyurt/yurt-controller-manager:v0.5.0""\

--yurt-tunnel-agent-image=""openyurt/yurt-tunnel-agent:v0.5.0""\

--yurt-tunnel-server-image=""openyurt/yurt-tunnel-server:v0.5.0""\

--node-servant-image=""openyurt/node-servant:latest""\

--yurthub-image=""openyurt/yurthub:v0.5.0""

```



We need to change the `openyurt/node-server-version` to latest here: `--node-servant-image=""openyurt/node-servant:latest""`



OpenYurt components 0.6.0 version is recommended to be installed and proved successful in running a WasmEdge demo. How to install OpenYurt:0.6.0, you can see [this](https://github.com/openyurtio/openyurt/releases/tag/v0.6.0)



### Use OpenYurt Experience Center to set up an OpenYurt Cluster quickly



An easier way to set up an OpenYurt Cluster is to use the OpenYurt Experience Center. All you need to do is to sign up for an account for testing, and then you will get an OpenYurt cluster. Next, you could use `yurtctl join` command line to join an edge node. See more OpenYurt Experience Center details [here](https://openyurt.io/docs/installation/openyurt-experience-center/overview/).



## Run a simple WebAssembly app



Next, let's run a WebAssembly program through the OpenYurt cluster as a container in the pod. This section will start by pulling this WebAssembly-based container image from the Docker hub. If you want to learn how to compile, package, and publish the WebAssembly program as a container image to the Docker hub, please refer to [WasmEdge Book](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md).



Because the kubectl run (version 1.18.9 ) missed annotations parameters, we need to adjust the command line here. If you use OpenYurt Experience Center with OpenYurt 0.6.0 and Kubernetes 1.20.11 by default, please refer to [the Kubernetes sections] in the WasmEdge book to run the wasm app.



```bash

// kubectl 1.18.9

$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest  --overrides='{""kind"":""Pod"",""metadata"":{""annotations"":{""module.wasm.image/variant"":""compat-smart""}} , ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000



// kubectl 1.20.11

$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=""module.wasm.image/variant=compat-smart"" --overrides='{""kind"":""Pod"", ""apiVersion"":""v1"", ""spec"": {""hostNetwork"": true}}' /wasi_example_main.wasm 50000000



```



The output from the containerized application is printed into the console. It is the same for all Kubernetes versions.



```bash

Random number: 1123434661

Random bytes: [25, 169, 202, 211, 22, 29, 128, 133, 168, 185, 114, 161, 48, 154, 56, 54, 99, 5, 229, 161, 225, 47, 85, 133, 90, 61, 156, 86, 3, 14, 10, 69, 185, 225, 226, 181, 141, 67, 44, 121, 157, 98, 247, 148, 201, 248, 236, 190, 217, 245, 131, 68, 124, 28, 193, 143, 215, 32, 184, 50, 71, 92, 148, 35, 180, 112, 125, 12, 152, 111, 32, 30, 86, 15, 107, 225, 39, 30, 178, 215, 182, 113, 216, 137, 98, 189, 72, 68, 107, 246, 108, 210, 148, 191, 28, 40, 233, 200, 222, 132, 247, 207, 239, 32, 79, 238, 18, 62, 67, 114, 186, 6, 212, 215, 31, 13, 53, 138, 97, 169, 28, 183, 235, 221, 218, 81, 84, 235]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

pod ""wasi-demo"" deleted

```



You can now check out the pod status through the Kubernetes command line.



```bash

crictl ps -a

```



The log shows the events from scheduling to running the WebAssembly workload.



```bash

CONTAINER           IMAGE               CREATED             STATE               NAME                 ATTEMPT             POD ID

0c176ed65599a       0423b8eb71e31       8 seconds ago       Exited              wasi-demo

```








------"
"The following is a markdown document located at /develop/deploy/kubernetes/superedge.md
------


---

sidebar_position: 5

---



# SuperEdge



SuperEdge is an open-source container management system for edge computing. It extends native Kubernetes to the edge in a non-intrusive way.



<!-- prettier-ignore -->

:::note

This demo is based on containerd + crun.

:::



## Install Superedge



- Download the installation package



<!-- prettier-ignore -->

:::note

Choose an installation package according to your installation node CPU architecture (amd64 or arm64).

:::



```bash

arch=amd64 version=v0.6.0 && rm -rf edgeadm-linux-* && wget https://superedge-1253687700.cos.ap-guangzhou.myqcloud.com/$version/$arch/edgeadm-linux-containerd-$arch-$version.tgz && tar -xzvf edgeadm-linux-* && cd edgeadm-linux-$arch-$version && ./edgeadm

```



- Install edge Kubernetes master node with containerd runtime



```bash

./edgeadm init --kubernetes-version=1.18.2 --image-repository superedge.tencentcloudcr.com/superedge --service-cidr=10.96.0.0/12 --pod-network-cidr=192.168.0.0/16 --install-pkg-path ./kube-linux-*.tar.gz --apiserver-cert-extra-sans=<Master Public IP> --apiserver-advertise-address=<Master Intranet IP> --enable-edge=true --runtime=containerd

```



- Join edge node with containerd runtime



```bash

./edgeadm join <Master Public/Intranet IP Or Domain>:Port --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxx --install-pkg-path <edgeadm kube-* install package address path> --enable-edge=true --runtime=containerd

```



For other installation, deployment, and administration, see our [**Tutorial**](https://superedge.io/docs/installation/)



## Install WasmEdge



Use the simple install script to install WasmEdge on your edge node.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

```



## Build and install Crun with WasmEdge



The [crun](https://github.com/containers/crun) project has WasmEdge support baked in. For now, the easiest approach is to build it yourself from source. First, let's ensure crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see [here](https://github.com/containers/crun#readme).



```bash

sudo apt update

sudo apt install -y make git gcc build-essential pkgconf libtool \

    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \

    go-md2man libtool autoconf python3 automake

```



Next, configure, build, and install a crun binary with WasmEdge support.



```bash

git clone https://github.com/containers/crun

cd crun

./autogen.sh

./configure --with-wasmedge

make

sudo make install

```



## Reconfigure containerd with crun runtime



Superedge containerd node has default config. We should modify the configuration file(/etc/containerd/config.toml) according to the following steps.



Firstly, we generate `config.toml.diff` diff file and patch it.



```bash

cat > config.toml.diff << EOF

--- /etc/containerd/config.toml 2022-02-14 15:05:40.061562127 +0800

+++ /etc/containerd/config.toml.crun    2022-02-14 15:03:35.846052853 +0800

@@ -24,17 +24,23 @@

   max_concurrent_downloads = 10



   [plugins.cri.containerd]

-        default_runtime_name = ""runc""

-    [plugins.cri.containerd.runtimes.runc]

+        default_runtime_name = ""crun""

+    [plugins.cri.containerd.runtimes.crun]

       runtime_type = ""io.containerd.runc.v2""

-      pod_annotations = []

+      pod_annotations = [""*.wasm.*"", ""wasm.*"", ""module.wasm.image/*"", ""*.module.wasm.image"", ""module.wasm.image/variant.*""]

       container_annotations = []

       privileged_without_host_devices = false

-      [plugins.cri.containerd.runtimes.runc.options]

-        BinaryName = ""runc""

+      [plugins.cri.containerd.runtimes.crun.options]

+        BinaryName = ""crun""

   # cni

   [plugins.cri.cni]

     bin_dir = ""/opt/cni/bin""

     conf_dir = ""/etc/cni/net.d""

     conf_template = """"



+  [plugins.""io.containerd.runtime.v1.linux""]

+    no_shim = false

+    runtime = ""crun""

+    runtime_root = """"

+    shim = ""containerd-shim""

+    shim_debug = false

EOF

```



```bash

sudo patch -d/ -p0 < config.toml.diff

sudo systemctl restart containerd

```



## Create Wasmedge application in Superedge



We can run a wasm image pushed to [dockerhub](https://hub.docker.com/r/hydai/wasm-wasi-example). If you want to learn how to compile, package, and publish the WebAssembly program as a container image to the Docker hub, please refer to [here](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md).



```bash

cat > wasmedge-app.yaml << EOF

apiVersion: v1

kind: Pod

metadata:

  annotations:

    module.wasm.image/variant: compat-smart

  labels:

    run: wasi-demo

  name: wasi-demo

spec:

  containers:

  - args:

    - /wasi_example_main.wasm

    - ""50000000""

    image: wasmedge/example-wasi:latest

    imagePullPolicy: IfNotPresent

    name: wasi-demo

  hostNetwork: true

  restartPolicy: Never

EOF



kubectl create -f wasmedge-app.yaml

```



The output will show by executing `kubectl logs wasi-demo` command.



```bash

Random number: -1643170076

Random bytes: [15, 223, 242, 238, 69, 114, 217, 106, 80, 214, 44, 225, 20, 182, 2, 189, 226, 184, 97, 40, 154, 6, 56, 202, 45, 89, 184, 80, 5, 89, 73, 222, 143, 132, 17, 79, 145, 64, 33, 17, 250, 102, 91, 94, 26, 200, 28, 161, 46, 93, 123, 36, 100, 167, 43, 159, 82, 112, 255, 165, 37, 232, 17, 139, 97, 14, 28, 169, 225, 156, 147, 22, 174, 148, 209, 57, 82, 213, 19, 215, 11, 18, 32, 217, 188, 142, 54, 127, 237, 237, 230, 137, 86, 162, 185, 66, 88, 95, 226, 53, 174, 76, 226, 25, 151, 186, 156, 16, 62, 63, 230, 148, 133, 102, 33, 138, 20, 83, 31, 60, 246, 90, 167, 189, 103, 238, 106, 51]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

/wasi_example_main.wasm

50000000

File content is This is in a file

```








------"
"```json:/develop/deploy/oci-runtime/_category_.json


{

  ""label"": ""Low level runtime support"",

  ""position"": 5,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will introduce integrations between WasmEdge and low level runtimes,like containerd and crun.""

  }

}








```"
"The following is a markdown document located at /develop/deploy/oci-runtime/crun.md
------


---

sidebar_position: 2

---



# Deploy with crun



The [crun project](https://github.com/containers/crun) has WasmEdge support baked in. This chapter will walk you through deploying WASM images with crun.



## Fedora Platform



The crun fedora package has WasmEdge as the default WebAssembly Runtime. So the easiest way to deploy WasmEdge with crun is on the Fedora Linux distribution. Please refer to the [next section](#other-linux-platforms) for the other Linux distributions.



First, install crun and WasmEdge on your fedora machine.



```bash

sudo dnf -y install wasmedge

sudo dnf -y install crun

```



Next, run `crun -v` to check if you installed successfully.



```bash

crun -v

# Output

crun version 1.7.2

commit: 0356bf4aff9a133d655dc13b1d9ac9424706cac4

rundir: /run/user/501/crun

spec: 1.0.0

+SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL

```



You can see that crun has WasmEdge package already.



Next, you can run WASM apps on your [fedora machine](../../../start/getting-started/quick_start_redhat.md).



## Other Linux Platforms



### Quick start



The [GitHub repo](https://github.com/second-state/wasmedge-containers-examples/) contains scripts and GitHub Actions for running our example apps on CRI-O.



- Simple WebAssembly example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml)

- HTTP service example [Quick start](https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md) | [Github Actions](https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml)



### Prerequisites



1. Make sure you have installed [WasmEdge](../../../start/install.md#install)



2. Build and configure crun with WasmEdge support



For now, the easiest approach is just built it yourself from source. First, let's ensure that `crun` dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please [see here](https://github.com/containers/crun#readme).



```bash

sudo apt update

sudo apt install -y make git gcc build-essential pkgconf libtool \

    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \

    go-md2man libtool autoconf python3 automake

```



Next, configure, build, and install a `crun` binary with WasmEdge support.



```bash

git clone https://github.com/containers/crun

cd crun

./autogen.sh

./configure --with-wasmedge

make

sudo make install

```








------"
"The following is a markdown document located at /develop/deploy/oci-runtime/quark.md
------


---

sidebar_position: 4

---



# Deploy with quark



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /develop/deploy/oci-runtime/youki.md
------


---

sidebar_position: 3

---



# Deploy with youki



youki is an OCI container runtime written in Rust. youki has WasmEdge baked in. This chapter will walk you through deploying WASM images with youki.



## Prerequisites



1. Build and configure youki with WasmEdge support



   We will use Ubuntu 20.04 as an example. For other OS, please [see here](https://containers.github.io/youki/user/basic_setup.html).



   Run the following command line to build and install youki on your machine.



   ```bash

   $ sudo apt-get install \

      curl                \

      git                 \

      pkg-config          \

      libsystemd-dev      \

      libdbus-glib-1-dev  \

      build-essential     \

      libelf-dev          \

      libzstd-dev         \

      libseccomp-dev      \

      libclang-dev



   # If you don't have the rust toolchain installed run:

   $ curl https://sh.rustup.rs -sSf | sudo sh -s -- -y

   ```



   Next, configure, build, and install a `youki` binary with WasmEdge support.



   ```bash

   git clone --recurse-submodules https://github.com/containers/youki.git

   cd youki

   ./scripts/build.sh -o . -r -f wasm-wasmedge

   ./youki -h

   export LD_LIBRARY_PATH=$HOME/.wasmedge/lib

   ```



2. [Install WasmEdge](../../../start/install.md#install)



3. Configure the `config.json` from youki to run WASM modules.



   To run a webassembly module with youki, the `config.json` has to include either runc.oci.handler or module.wasm.image/variant=compat"". It also needs you to specify a valid .wasm (webassembly binary) or .wat (webassembly test) module as an entrypoint for the container.



   ```json

   ""ociVersion"": ""1.0.2-dev"",

   ""annotations"": {

       ""run.oci.handler"": ""wasm""

   },

   ""process"": {

       ""args"": [

           ""wasi_example_main.wasm"",

           ],

   ```



## Run a simple WebAssembly app



Now we can run a simple WebAssembly app. [A separate article](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md) explains how to compile, package, and publish the WebAssembly program as a container image to Docker hub.



```bash

sudo ctr i pull docker.io/wasmedge/example-wasi:latest

```



Run the example with Youki and Podman.



```bash

sudo podman --runtime /PATH/WHARE/YOU/BUILT/WITH/WASM-WASMEDGE/youki run /wasi_example_main.wasm 50000000

```



That's it.








------"
"```json:/develop/deploy/_category_.json


{

  ""label"": ""Deploy WasmEdge apps in Kubernetes"",

  ""position"": 8,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will introduce how to depoloy WASM app using the exisiting container toolings.""

  }

}








```"
"The following is a markdown document located at /develop/deploy/docker_wasm.md
------


---

sidebar_position: 2

---



# Docker + Wasm



Docker announced its support for WebAssembly in partnership with WasmEdge. Now we can use one single command line `docker compose up` to run WASM Apps.



Please refer to the [Quick start with Docker](../../start/getting-started/quick_start_docker.md) part.








------"
"The following is a markdown document located at /develop/deploy/intro.md
------


---

sidebar_position: 1

---



# Introduction



WasmEdge could be integrated with the existing cloud-native infra seamlessly. So developers can leverage container tools such as Kubernetes, Docker, and CRI-O to deploy, manage, and run lightweight WebAssembly applications. This chapter will demonstrate how Kubernetes ecosystem tools work with WasmEdge WebAssembly applications.



Several options exist to manage WASM apps as “containers” under Kubernetes. Both options will give you a Kubernetes cluster that runs Linux containers and WASM containers side by side.



## With containerd-shim



**Option #1:** is to use a containerd-shim to start WASM ""containers"" via runwasi. Basically containerd could look at the image’s target platform. It uses runwasi if the image is wasm32 and runc if it is x86 / arm. Currently, Docker and Microsoft prefer this approach, which is also the basis for the [Docker + WASM preview](https://www.docker.com/blog/docker-wasm-technical-preview/). Based on containerd



The following image shows how it works.



![Containerd](containerd.png)



## With crun



Option #2 is to use an OCI runtime called crun (the C version of runc, mainly supported by Red Hat). crun decides whether an OCI image is wasm or Linux based on image annotations. If the image is annotated as wasm32, crun will bypass Linux container setup and just use WasmEdge to run it. Based on crun, we can get the entire Kubernetes stack CRI-O, containerd, Podman, kind, micro k8s, k8s etc to work with WASM images.



## With youki



Option #3 is to use an OCI runtime called youki (the Rust version of runc). Like crun, youki decides whether an OCI image is wasm or Linux based on image annotations. If the image is annotated as wasm32, youki will bypass Linux container setup and just use WasmEdge to run it. Based on youki, we can get the entire Kubernetes stack CRI-O, containerd, Podman, kind, micro k8s, k8s etc to work with WASM images.



Both crun and youki could use the following image to show how it works.



![Kubernetes](kubernetes.png)



## Examples we covered



This section will show how to manage WASM App in three different ways. The goal is to load and run WebAssembly OCI images alongside Linux OCI images (e.g., today's Docker containers) across the Kubernetes stack.



We will cover two different demos in most cases. We built them from Rust source code, built OCI images around them, and then published them to Docker Hub. You can find the more container example [here](https://github.com/second-state/wasmedge-containers-examples).



- [A simple WASI example](https://github.com/second-state/wasmedge-containers-examples/blob/main/simple_wasi_app.md)

- [A HTTP server example](https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md)



Since we have already built and published those demo apps on Docker Hub, you could also pull the images from Docker Hub. If you want to build your own WASM image, please refer to this article.



Since we have already built and published those demo apps on Docker Hub, you could also just go straight to the container runtime sections to use these images.



Let's get started.








------"
"The following is a markdown document located at /develop/deploy/podman.md
------


---

sidebar_position: 3

---



# Podman



## Fedora Platform



Fedora is the easiest platform to run the WASM app with container because the crun fedora package has supported WasmEdge as the default runtime. We don't need to make any changes to run WasmEdge apps on fedora platform. If you use other Linux distributions, go to [next section](#other-linux-distributions).



### Install podman and WasmEdge



```bash

sudo dnf -y install podman

sudo dnf -y install wasmedge

```



### Run A simple WASI app on Fedora



Now, we could run wasm apps.



```bash

podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000

```



That's it.



## Other Linux distributions



### Prerequisites



1. Install and configure Podman



   Use the following commands to install podman on your system. Here I use Ubuntu as an example. For more different types of podman, please refer to [Podman's installation instruction](https://podman.io/getting-started/installation).



   ```bash

   sudo apt-get -y update

   sudo apt-get -y install podman

   ```



2. [Install WasmEdge](../../start/install.md#install)



3. Build and configure crun with WasmEdge support



   Next, configure and build a `crun` binary with WasmEdge support.



   ```bash

   git clone https://github.com/containers/crun

   cd crun

   ./autogen.sh

   ./configure --with-wasmedge

   make

   sudo make install

   # replace crun (be careful, you may want to do a backup first)

   mv crun $(which crun)

   ```



   Then, you can use `crun -v` to check if crun is installed successfully.



   ```bash

   crun --version

   # Output

   crun version 1.7.2.0.0.0.26-51af

   commit: 51af1448f60b69326cf26e726e14b38fcb253943

   rundir: /run/user/0/crun

   spec: 1.0.0

   +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL

   ```



### Run A simple WASI app



Now, we could run wasm apps.



```bash

podman run --rm --annotation module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest /wasi_example_main.wasm 50000000

```



For more information, you could refer to [crun](../deploy/oci-runtime/crun) chapter.



A great open-source project introduces podman and WASM from a community called [Kwasm](https://github.com/KWasm/podman-wasm). Check it out!








------"
"The following is a markdown document located at /develop/deploy/using-wasmedge-in-docker.md
------


---

sidebar_position: 5

---



# Using WasmEdge in Docker



## What is the WasmEdge DockerSlim



An easy way to run WebAssembly applications in the Docker ecosystem is to embed the WebAssembly bytecode file in a Linux container image. Precisely, we trim down the Linux OS inside the container to the point where it is just enough to support the `wasmedge` runtime. This approach has many advantages.



- It works seamlessly with any Docker or container ecosystem tool since the WebAssembly application is wrapped in a regular container.

- The memory footprint of the entire image of Linux OS and WasmEdge can be reduced to as low as 4MB.

- The attack surface of the slimmed Linux OS is dramatically reduced from a regular Linux OS.

- The overall application security is managed by the WebAssembly sandbox. The software supply chain attack risk is greatly reduced since the WebAssembly sandbox only has access to explicitly declared capabilities.

- The above three advantages are amplified if the application is complex. For example, a WasmEdge AI inference application would NOT require a Python install. A WasmEdge node.js application would NOT require a Node.js and v8 install.



However, this approach still requires starting up a Linux container. The containerized Linux OS, however slim, still takes 80% of the total image size. There is still a lot of room for optimization. The performance and security of this approach would not be as great as running WebAssembly applications directly in [crun](/develop/deploy/oci-runtime/crun.md) or in a [containerd shim](/develop/deploy/cri-runtime/containerd.md).



## WasmEdge DockerSlim



The `wasmedge/slim:{version}` Docker images provide a slim WasmEdge images built with [DockerSlim](https://dockersl.im) every release.



- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.

- Image `wasmedge/slim:{version}` includes the following command line utilities:

  - `wasmedge`

  - `wasmedgec`

- Image `wasmedge/slim-tf:{version}` includes the following command line utilities:

  - `wasmedge`

  - `wasmedgec`

  - `wasmedge-tensorflow-lite`

  - `wasmedge-tensorflow`

  - `show-tflite-tensor`

- The working directory of the release docker image is `/app`.



## Run a simple WebAssembly app



We can run a simple WebAssembly program using Docker. A slim Linux image with WasmEdge installed is only 4MB instead of 30MB for a general Linux image for natively compiled applications. The Linux + WasmEdge image is similar to a unikernel OS image. It minimizes the footprint, performance overhead, and potential attack surface for WebAssembly applications.



[The sample application is here](https://github.com/second-state/wasm-learning/tree/master/cli/wasi). First, create a `Dockerfile` based on our release image. Include the [wasm application file](https://github.com/second-state/wasm-learning/raw/master/cli/wasi/wasi_example_main.wasm) in the new image, and run the `wasmedge` command at start up.



```shell

FROM wasmedge/slim-runtime:0.10.1

ADD wasi_example_main.wasm /

CMD [""wasmedge"", ""--dir"", "".:/"", ""/wasi_example_main.wasm""]

```



Run the WebAssembly application in Docker CLI as follows.



```shell

$ docker build -t wasmedge/myapp -f Dockerfile ./

... ...

Successfully tagged wasmedge/myapp:latest



$ docker run --rm wasmedge/myapp

Random number: -807910034

Random bytes: [113, 123, 78, 85, 63, 124, 68, 66, 151, 71, 91, 249, 242, 160, 164, 133, 35, 209, 106, 143, 202, 87, 147, 87, 236, 49, 238, 165, 125, 175, 172, 114, 136, 205, 200, 176, 30, 122, 149, 21, 39, 58, 221, 102, 165, 179, 124, 13, 60, 166, 188, 127, 83, 95, 145, 0, 25, 209, 226, 190, 10, 184, 139, 191, 243, 149, 197, 85, 186, 160, 162, 156, 181, 74, 255, 99, 203, 161, 108, 153, 90, 155, 247, 183, 106, 79, 48, 255, 172, 17, 193, 36, 245, 195, 170, 202, 119, 238, 104, 254, 214, 227, 149, 20, 8, 147, 105, 227, 114, 146, 246, 153, 251, 139, 130, 1, 219, 56, 228, 154, 146, 203, 205, 56, 27, 115, 79, 254]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

wasi_example_main.wasm

File content is This is in a file

```



## Run a HTTP server app



We can run a simple WebAssembly-based HTTP micro-service using the Docker CLI. The [sample application is here](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server). Follow the instructions to compile and build the `http_server.wasm` file.



Create a `Dockerfile` based on our release image. Include the `http_server.wasm` application file in the new image, and run the `wasmedge` command at startup.



```shell

FROM wasmedge/slim-runtime:0.10.1

ADD http_server.wasm /

CMD [""wasmedge"", ""--dir"", "".:/"", ""/http_server.wasm""]

```



Run the WebAssembly server application in Docker CLI as follows. Notice that we map the server port from the container to the host.



```shell

$ docker build -t wasmedge/myapp -f Dockerfile ./

... ...

Successfully tagged wasmedge/myapp:latest



$ docker run --rm -p 1234:1234 wasmedge/myapp

new connection at 1234

```



You can now access the server from another terminal.



```shell

$ curl -X POST http://127.0.0.1:1234 -d ""name=WasmEdge""

echo: name=WasmEdge

```



## Run a lightweight Node.js server



With WasmEdge QuickJS support for the Node.js API, we can run a lightweight and secure node.js server from Docker CLI. The slim Linux + WasmEdge + Node.js support image size is less than 15MB instead of over 350MB for a standard Node.js image. You will need to do the following.



- [Download the WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs.wasm) here. You will have the `wasmedge_quickjs.wasm` file.

- [Download the modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) directory from the WasmEdge QuickJS repo.

- Create a JavaScript file for the server. Below is an example `http_echo.js` file you can use.



```javascript

import { createServer, request, fetch } from 'http';



createServer((req, resp) => {

  req.on('data', (body) => {

    resp.write('echo:');

    resp.end(body);

  });

}).listen(8001, () => {

  print('listen 8001 ...\n');

});

```



Add those files to the Docker image and run the JavaScript file at startup.



```shell

FROM wasmedge/slim-runtime:0.10.1

ADD wasmedge_quickjs.wasm /

ADD http_echo.js /

ADD modules /modules

CMD [""wasmedge"", ""--dir"", "".:/"", ""/wasmedge_quickjs.wasm"", ""http_echo.js""]

```



Start the server from Docker CLI.



```shell

$ docker build -t wasmedge/myapp -f Dockerfile ./

... ...

Successfully tagged wasmedge/myapp:latest



$ docker run --rm -p 8001:8001 wasmedge/myapp

listen 8001 ...

```



You can now access the server from another terminal.



```shell

$ curl -X POST http://127.0.0.1:8001 -d ""WasmEdge""

echo:WasmEdge

```



## Run a lightweight Tensorflow inference application



A unique and powerful feature of the WasmEdge runtime is its support for AI frameworks. In this example, we will show you how to run an image recognition service from Docker CLI. [The sample application is here](https://github.com/WasmEdge/wasmedge_hyper_demo/tree/main/server-tflite). First, create a `Dockerfile` based on our `tensorflow` release image. Include the [wasm application file](https://github.com/WasmEdge/wasmedge_hyper_demo/raw/main/server-tflite/wasmedge_hyper_server_tflite.wasm) in the new image, and run the `wasmedge-tensorflow-lite` command at startup.



The Dockerfile is as follows. The whole package is 115MB. It is less than 1/4 of a typically Linux + Python + Tensorflow setup.



```shell

FROM wasmedge/slim-tf:0.10.1

ADD wasmedge_hyper_server_tflite.wasm /

CMD [""wasmedge-tensorflow-lite"", ""--dir"", "".:/"", ""/wasmedge_hyper_server_tflite.wasm""]

```



Start the server from Docker CLI.



```shell

$ docker build -t wasmedge/myapp -f Dockerfile ./

... ...

Successfully tagged wasmedge/myapp:latest



$ docker run --rm -p 3000:3000 wasmedge/myapp

listen 3000 ...

```



You can now access the server from another terminal.



```shell

$ curl http://localhost:3000/classify -X POST --data-binary ""@grace_hopper.jpg""

military uniform is detected with 206/255 confidence

```








------"
"```json:/develop/go/_category_.json


{

  ""label"": ""Develop WASM Apps in Go"",

  ""position"": 7,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to create WASM apps in Go.""

  }

}








```"
"The following is a markdown document located at /develop/go/hello_world.md
------


---

sidebar_position: 1

---



# TinyGo



The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using [TinyGo](https://tinygo.org/). In this article, we will show you how.



The Golang is adding WASI support. Stay tuned!



## Install TinyGo



You must have [Go already installed](https://go.dev/doc/install) on your machine before installing TinyGo. Go v1.17 or above is recommended. For Ubuntu or other Debian-based Linux systems on x86 processors, you could use the following command line to install TinyGo. For other platforms, please refer to [TinyGo docs](https://tinygo.org/getting-started/install/).



```bash

wget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb

sudo dpkg -i tinygo_0.21.0_amd64.deb`

```



Next, run the following command line to check if the installation succeeds.



```bash

$ tinygo version

tinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)

```



## Hello world



The simple Go app has a `main()` function to print a message to the console. The source code in `main.go` file is as follows.



```go

package main



func main() {

  println(""Hello TinyGo from WasmEdge!"")

}

```



<!-- prettier-ignore -->

:::note

Inside the `main()` function, you can use Go standard API to read / write files, and access command line arguments and `env` variables.

:::



### Hello world: Compile and build



Next, compile the `main.go` program to WebAssembly using TinyGo.



```bash

tinygo build -o hello.wasm -target wasi main.go

```



You will see a `hello.wasm` file in the same directory, a WebAssembly bytecode file.



### Hello world: Run



You can run it with the [WasmEdge CLI](../../start/build-and-run/cli.md).



```bash

$ wasmedge hello.wasm

Hello TinyGo from WasmEdge!

```



## A simple function



The second example is a Go function that takes a call parameter to compute a fibonacci number. However, for the Go application to set up proper access to the OS (e.g., to access the command line arguments), you must include an empty `main()` function in the source code.



```go

package main



func main(){

}



//export fibArray

func fibArray(n int32) int32{

  arr := make([]int32, n)

  for i := int32(0); i < n; i++ {

    switch {

    case i < 2:

      arr[i] = i

    default:

      arr[i] = arr[i-1] + arr[i-2]

    }

  }

  return arr[n-1]

}

```



### A simple function: Compile and build



Next, compile the `main.go` program to WebAssembly using TinyGo.



```bash

tinygo build -o fib.wasm -target wasi main.go

```



You will see a file named `fib.wasm` in the same directory, a WebAssembly bytecode file.



### A simple function: Run



You can run it with the [WasmEdge CLI](../../start/build-and-run/cli.md) in its `--reactor` mode. The command line arguments following the `wasm` file are the function name and call parameters.



```bash

$ wasmedge --reactor fib.wasm fibArray 10

34

```



## Improve performance



To achieve native Go performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program, then run it with the `wasmedge` command.



```bash

$ wasmedge compile hello.wasm hello.wasm



$ wasmedge hello.wasm

Hello TinyGo from WasmEdge!

```



For the `--reactor` mode,



```bash

$ wasmedge compile fib.wasm fib.wasm



$ wasmedge --reactor fib.wasm fibArray 10

34

```








------"
"```json:/develop/javascript/_category_.json


{

  ""label"": ""Develop WASM Apps in JavaScript"",

  ""position"": 5,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Yes! You could run JavaScript programs in WasmEdge.""

  }

}








```"
"The following is a markdown document located at /develop/javascript/es6.md
------


---

sidebar_position: 6

---



# ES6 Modules



The WasmEdge QuickJS runtime supports ES6 modules. The roll-up commands we used in the [React SSR](ssr) examples convert and bundle CommonJS and NPM modules into ES6 modules to execute in WasmEdge QuickJS. This article will show you how to use the ES6 module in WasmEdge.



## Prerequisites



[See here](./hello_world#prerequisites)



## Run the example



We will take the example in [example_js/es6_module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo) folder as an example. To run the example, you can do the following on the CLI.



```bash

$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js

hello from module_def.js

hello from module_def_async.js

./module_def_async.js `something` is  async thing

```



<!-- prettier-ignore -->

:::note

Make sure that you run those commands from the `wasmedge-quickjs` directory. [Here is why](./hello_world#prerequisites)

:::



## Code Explanation



The [module_def.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js) file defines and exports a simple JS function.



```javascript

function hello() {

  console.log('hello from module_def.js');

}



export { hello };

```



The [module_def_async.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js) file defines and exports an async function and a variable.



```javascript

export async function hello() {

  console.log('hello from module_def_async.js');

  return 'module_def_async.js : return value';

}



export var something = 'async thing';

```



The [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js) file imports functions and variables from those modules and executes them.



```javascript

import { hello as module_def_hello } from './module_def.js';



module_def_hello();



var f = async () => {

  let { hello, something } = await import('./module_def_async.js');

  await hello();

  console.log('./module_def_async.js `something` is ', something);

};



f();

```








------"
"The following is a markdown document located at /develop/javascript/hello_world.md
------


---

sidebar_position: 2

---



# Quickstart for JavaScript



## Prerequisites



[Install WasmEdge](../../start/install.md#install)



Clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and use it as the current directory.



```bash

git clone https://github.com/second-state/wasmedge-quickjs

cd wasmedge-quickjs

```



Then download the pre-built WasmEdge QuickJS Runtime program, and optionally, AOT compile it for better performance.



```bash

curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm

wasmedge compile wasmedge_quickjs.wasm wasmedge_quickjs.wasm

```



<!-- prettier-ignore -->

:::note

The reason to use `wasmedge-quickjs` as the current working directory is that `modules` in the repo are required for the QuickJS runtime.

:::



## Quick start



You can try a simple ""hello world"" JavaScript program ([example_js/hello.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js)), which prints out the command line arguments to the console.



```bash

$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime

Hello WasmEdge Runtime

```



<!-- prettier-ignore -->

:::note

The `--dir .:.` on the command line is to give `wasmedge` permission to read the local directory in the file system for the `hello.js` file.

:::



The JavaScript source code for the `hello.js` program is as follows.



```javascript

import * as os from 'os';

import * as std from 'std';



args = args.slice(1);

print('Hello', ...args);

setTimeout(() => {

  print('timeout 2s');

}, 2000);

```



## Build it yourself



This section is optional. Read on if you are interested in [adding custom built-in JavaScript APIs](rust) to the runtime.



Following the instructions, you can build a JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.



```bash

# Install GCC

sudo apt update

sudo apt install build-essential

```



Then, we could build the WasmEdge-Quickjs runtime.



Fork or clone [the wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).



```bash

# get the source code

git clone https://github.com/second-state/wasmedge-quickjs

cd wasmedge-quickjs



# Build the QuickJS JavaScript interpreter

cargo build --target wasm32-wasi --release

```



The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.



WasmEdge provides a `wasmedgec` utility to compile and add a native machine code section to the `wasm` file. You can use `wasmedge` to run the natively instrumented `wasm` file to get a much faster performance.



```bash

wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm

wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js

```



Next, we will discuss more advanced use cases for JavaScript in WasmEdge.








------"
"The following is a markdown document located at /develop/javascript/intro.md
------


---

sidebar_position: 1

---



# Introduction



WebAssembly started as a ""JavaScript alternative for browsers"". The idea is to safely run high-performance applications compiled from languages like C/C++ or Rust in browsers. In the browser, WebAssembly runs side by side with JavaScript.



As WebAssembly is increasingly used in the cloud, it is now a universal runtime for cloud-native applications. Compared with Linux containers, WebAssembly runtimes achieve higher performance with lower resource consumption.



In cloud-native use cases, developers often want to use JavaScript to write business applications. That means we must now support JavaScript in WebAssembly. Furthermore, we should support calling C/C++ or Rust functions from JavaScript in a WebAssembly runtime to maximize WebAssembly's computational efficiency. The WasmEdge WebAssembly runtime allows you to do exactly that.



![javascript](javascript.png)



## Why run JavaScript in WasmEdge



- Lightweight and secure JS runtime. Compared with V8 and Node.js, WasmEdge itself is a lightweight， high-performance JavaScript runtime。

- No need for Linux containers. WasmEdge could be a secure container without tons of dependencies.

- Node.js compatible. See the status [here](https://github.com/WasmEdge/WasmEdge/issues/1535).

- Use Rust to implement JS APIs. See the tutorial here.



This section will demonstrate how to run and enhance JavaScript in WasmEdge.



- [Getting started](hello_world) demonstrates how to run simple JavaScript programs in WasmEdge.

- [Networking sockets](networking) shows how to create non-blocking (async) HTTP clients, including the `fetch` API, and server applications in JavaScript.

- [Node.js compatibility](nodejs) describes Node.js APIs support in WasmEdge QuickJS.

- [ES6 modules](es6) shows how to incorporate ES6 modules in WasmEdge.

- [Node.js and NPM modules](npm) shows how to incorporate NPM modules in WasmEdge.

- [Built-in modules](modules) show how to add JavaScript functions into the WasmEdge runtime as built-in API functions.

- [Use Rust to implement JS API](rust) discusses using Rust to implement and support a JavaScript API.

- [React SSR](ssr) shows example React SSR applications, including streaming SSR support.



## A note on v8



Now, the choice of QuickJS as our JavaScript engine might raise the question of performance. Isn't QuickJS [a lot slower](https://bellard.org/quickjs/bench.html) than v8 due to a lack of JIT support? Yes, but ...



First of all, QuickJS is a lot smaller than v8. It only takes 1/40 (or 2.5%) of the runtime resources v8 consumes. You can run many more QuickJS functions than v8 functions on a single physical machine.



Second, for most business logic applications, raw performance is not critical. The application may have computationally intensive tasks, such as AI inference on the fly. WasmEdge allows the QuickJS applications to drop to high-performance WebAssembly for these tasks while adding such extensions modules is more challenging with v8.



Third, WasmEdge is [itself an OCI-compliant container](../deploy/intro). It is secure by default, supports resource isolation, and can be managed by container tools to run with Linux containers in a single k8s cluster.



Finally, v8 has a huge attack surface and requires [significant efforts](https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/) to run securely in a public cloud environment. It is known that [many JavaScript security issues arise from JIT](https://www.theregister.com/2021/08/06/edge_super_duper_security_mode/). Maybe turning off JIT in the cloud-native environment is not a bad idea!



In the end, running v8 in a cloud-native environment often requires a whole stack of software tools consisting of ""Linux container + guest OS + node or deno + v8"", which makes it much heavier and slower than a simple WasmEdge + QuickJS container runtime.








------"
"The following is a markdown document located at /develop/javascript/modules.md
------


---

sidebar_position: 7

---



# Built-in modules



The WasmEdge QuickJS runtime supports [ES6](es6) and [NPM](npm) modules for application developers. However, those approaches could be more convenient for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without using build tools like rollup.js. The WasmEdge QuickJS modules system allows developers to drop JavaScript files into a `modules` folder and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this module's system is to support [Node.js](nodejs) APIs in WasmEdge.



In this article, we will use the [wasmedge-quickjs/modules](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as an example to showcase how to import NodeJS API or a third-party module.



## Prerequisites



[See here](./hello_world#prerequisites)



## The modules system



The modules system collects JavaScript files in the `modules` directory in the WasmEdge QuickJS distribution. To use the JavaScript functions and APIs defined in those modules, you need to map this directory to the `/modules` directory inside the WasmEdge Runtime instance. The following example shows how to do this on the WasmEdge CLI. You can do this with any of the host language SDKs that support the embedded use of WasmEdge.



```bash

wasmedge --dir /modules:/host/os/path/to/modules wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime

```



## Add your own JavaScript modules



The [module_demo](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo) shows how you can use the modules system to add your own JavaScript APIs. To run the demo, first copy the two files in the demo's [modules](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo/modules) directory to your WasmEdge QuickJS's `modules` directory.



```bash

cp example_js/module_demo/modules/* modules/

```



The two JavaScript files in the `modules` directory provide two simple functions. Below is the [modules/my_mod_1.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_1.js) file.



```javascript

export function hello_mod_1() {

  console.log('hello from ""my_mod_1.js""');

}

```



And the [modules/my_mod_2.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_2.js) file.



```javascript

export function hello_mod_2() {

  console.log('hello from ""my_mod_2.js""');

}

```



Then, just run the [demo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/demo.js) file to call the two exported functions from the modules.



```javascript

import { hello_mod_1 } from 'my_mod_1';

import { hello_mod_2 } from 'my_mod_2';



hello_mod_1();

hello_mod_2();

```



Here is the command to run the demo and the output.



```bash

$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/module_demo/demo.js

hello from ""my_mod_1.js""

hello from ""my_mod_2.js""

```



Following the above tutorials, you can easily add third-party JavaScript functions and APIs to your WasmEdge QuickJS runtime.



We included JavaScript files to support [Node.js APIs](nodejs) for the official distribution. You can use [those files](https://github.com/second-state/wasmedge-quickjs/tree/main/modules) as further examples.








------"
"The following is a markdown document located at /develop/javascript/networking.md
------


---

sidebar_position: 3

---



# Networking



The QuickJS WasmEdge Runtime supports Node.js's `http` and `fetch` APIs via the WasmEdge [networking socket extension](https://github.com/second-state/wasmedge_wasi_socket). That enables WasmEdge developers to create HTTP server and client, as well as TCP/IP server and client, applications in JavaScript.



The networking API in WasmEdge is non-blocking and hence supports asynchronous I/O-intensive applications. With this API, the JavaScript program can open multiple connections concurrently. It polls those connections or registers async callback functions to process data whenever data comes in, without waiting for any one connection to complete its data transfer. That allows the single-threaded application to handle multiple, multiple concurrent requests.



- [Prerequisites](#prerequisites)

- [Fetch client](#fetch-client)

- [HTTP server](#http-server)

- [TCP server and client](#tcp-server-and-client)



## Prerequisites



[Install WasmEdge](../../start/install.md). To make HTTPS requests, install the [WasmEdge TLS plug-in](../../start/install.md#install-wasmedge-with-plug-ins).



[Install WasmEdge-QuickJS](./hello_world#prerequisites). Make sure that the `modules` directory is located in your local directory where you want to execute the `wasmedge` command.



## Fetch client



The `fetch` API is widely used in browser and node-based JavaScript applications to fetch content over the network. Building on top of its non-blocking async network socket API, the WasmEdge QuickJS runtime supports the `fetch` API. That makes many JS APIs and modules reusable out of the box.



The [example_js/wasi_http_fetch.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js) example demonstrates how to use the `fetch` API in WasmEdge.



```bash

wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_fetch.js

```



It takes a few seconds to complete all the HTTP requests in the program. Once they are done, you will see the HTTP responses printed to the console. Let's look into how the `wasi_http_fetch.js` JavaScript program works.



The code snippet below shows an async HTTP GET from the `httpbin.org` test server. While the program waits for and processes the GET content, it can start another request.



```javascript

async function test_fetch() {

  try {

    let r = await fetch('http://httpbin.org/get?id=1');

    print('test_fetch\n', await r.text());

  } catch (e) {

    print(e);

  }

}

test_fetch();

```



The code snippet below shows how to an sync HTTP POST to a remote server.



```javascript

async function test_fetch_post() {

  try {

    let r = await fetch('http://httpbin.org/post', {

      method: 'post',

      body: 'post_body',

    });

    print('test_fetch_post\n', await r.text());

  } catch (e) {

    print(e);

  }

}

test_fetch_post();

```



An async HTTP PUT request is as follows.



```javascript

async function test_fetch_put() {

  try {

    let r = await fetch('http://httpbin.org/put', {

      method: 'put',

      body: JSON.stringify({ a: 1 }),

      headers: { 'Context-type': 'application/json' },

    });

    print('test_fetch_put\n', await r.text());

  } catch (e) {

    print(e);

  }

}

test_fetch_put();

```



## HTTP server



If you want to run microservices in the WasmEdge runtime, you must create an HTTP server with it. The [example_js/wasi_http_echo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_server.js) example shows you how to create an HTTP server listening on port 8001 using Node.js compatible APIs.



```bash

wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_http_server.js

```



Use the following `curl` command to send an HTTP POST request to the server. It prepends ""echo:"" to any incoming request and sends it back as a response.



```bash

$ curl -d ""WasmEdge"" -X POST http://localhost:8001/

echo:WasmEdge

```



The JavaScript source code of the HTTP server is as follows.



```javascript

import { createServer, request, fetch } from 'http';



createServer((req, resp) => {

  req.on('data', (body) => {

    resp.write('echo:');

    resp.end(body);

  });

}).listen(8001, () => {

  print('listen 8001 ...\n');

});

```



## TCP server and client



The WasmEdge runtime goes beyond the Node.js API. The `WasiTcpServer` API can create a server that accepts non-HTTP requests. The [example_js/wasi_net_echo.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js) example shows you how to create a TCP server and then create a TCP client to send a request to it.



```bash

$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/wasi_net_echo.js

listen 8000 ...

server accept: 127.0.0.1:49040

server recv: hello

client recv: echo:hello

```



The TCP server in `wasi_net_echo.js` is as follows.



```javascript

import * as net from 'wasi_net';

import { TextDecoder } from 'util';



async function server_start() {

  print('listen 8000 ...');

  try {

    let s = new net.WasiTcpServer(8000);

    for (var i = 0; i < 100; i++) {

      let cs = await s.accept();

      handle_client(cs);

    }

  } catch (e) {

    print('server accept error:', e);

  }

}



server_start();

```



The `handle_client()` function contains the logic for processing and responding to incoming requests. You will need to read and parse the data stream in the request yourself in this function. In this example, it simply echoes the data back with a prefix.



```javascript

async function handle_client(cs) {

  print('server accept:', cs.peer());

  try {

    while (true) {

      let d = await cs.read();

      if (d == undefined || d.byteLength <= 0) {

        break;

      }

      let s = new TextDecoder().decode(d);

      print('server recv:', s);

      cs.write('echo:' + s);

    }

  } catch (e) {

    print('server handle_client error:', e);

  }

  print('server: conn close');

}

```



The TCP client uses WasmEdge's `WasiTcpConn` API to send in a request and receive the echoed response.



```javascript

async function connect_test() {

  try {

    let ss = await net.WasiTcpConn.connect('127.0.0.1:8000');

    ss.write('hello');

    let msg = (await ss.read()) || '';

    print('client recv:', new TextDecoder().decode(msg));

  } catch (e) {

    print('client catch:', e);

  } finally {

    nextTick(() => {

      exit(0);

    });

  }

}



connect_test();

```



With async HTTP networking, developers can create I/O intensive applications, such as database-driven microservices, in JavaScript and run them safely and efficiently in WasmEdge.








------"
"The following is a markdown document located at /develop/javascript/nodejs.md
------


---

sidebar_position: 5

---



# Node.js support



Many existing JavaScript apps use Node.js built-in APIs. To support and reuse these JavaScript apps, we are implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.



To use Node.js APIs in WasmEdge, you must make the `modules` directory from [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) accessible to the WasmEdge Runtime. The most straightforward approach is to clone the [wasmedge-quickjs](https://github.com/second-state/wasmedge-quickjs) repo and run the Node.js app from the repo's top directory.



```bash

# Clone the wasmedge-quickjs

git clone https://github.com/second-state/wasmedge-quickjs

# Use the wasmedge-quickjs directory as the working directory for modules access

cd wasmedge-quickjs

# Download a released WasmEdge QuickJS runtime

curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm

# Copy the nodejs project to the current working directory and run the nodejs app

cp -r /path/to/my_node_app .

wasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js

```



<!-- prettier-ignore -->

:::note

If you want to run `wasmedge` from a directory outside the repo, you will need to tell it where to find the `modules` directory using the `--dir` option. A typical command will look like this: `wasmedge --dir .:. --dir ./modules:/path/to/modules wasmedge_quickjs.wasm app.js`

:::



The progress of Node.js support in WasmEdge QuickJS is **[tracked in this issue](https://github.com/WasmEdge/WasmEdge/issues/1535).** There are two approaches for supporting Node.js APIs in WasmEdge QuickJS.



## The JavaScript modules



Some Node.js functions can be implemented in pure JavaScript using the [modules](modules) approach. For example,



- The [querystring](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/querystring.js) functions just perform string manipulations.

- The [buffer](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/buffer.js) functions manage and encode arrays and memory structures.

- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js) and [http](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js) functions support corresponding Node.js APIs by wrapping around [Rust internal modules](rust).



## The Rust internal modules



Other Node.js functions must be implemented using the [internal_module](rust) approach in Rust. There are two reasons for that. First, some Node.js API functions are CPU intensive (e.g., encoding) and is most efficiently implemented in Rust. Second, some Node.js API functions require access to the underlying system (e.g., networking and file system) through native host functions.



- The [core](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/core.rs) module provides OS-level functions such as `timeout`.

- The [encoding](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/encoding.rs) module provides high-performance encoding and decoding functions, which are in turn [wrapped into Node.js encoding APIs](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js).

- The [wasi_net_module](https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/wasi_net_module.rs) provides JavaScript networking functions implemented via the Rust-based WasmEdge WASI socket API. It is then wrapped into the [Node.js http module](https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js).



Node.js compatibility support in WasmEdge QuickJS is a work in progress. It is an excellent way for new developers to get familiar with WasmEdge QuickJS. Join us!








------"
"The following is a markdown document located at /develop/javascript/npm.md
------


---

sidebar_position: 8

---



# NodeJS and NPM modules



With [rollup.js](https://rollupjs.org/guide/en/), we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too.



## Prerequisites



[See here](./hello_world#prerequisites)



## Run the example



The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo shows how it works.



First, you will need to use the NPM command to roll up the dependency modules into a single JavaScript file.



```bash

cd example_js/simple_common_js_demo

npm install

npm run build

# Go back to the working directory

cd ../../

```



NPM generates a new JavaScript file at `example_js/simple_common_js_demo/dist/npm_main.mjs`, which is the file you can execute with the WasmEdge QuickJS runtime.



```bash

$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs

md5(message)= 78e731027d8fd50ed642340b7c9a63b3

sqrt(-4)= 2i

```



## Code explanation



The [simple_common_js_demo/npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) utilizes the third-party `md5` and `mathjs` modules.



```javascript

const md5 = require('md5');

console.log('md5(message)=', md5('message'));



const { sqrt } = require('mathjs');

console.log('sqrt(-4)=', sqrt(-4).toString());

```



To run it, we must first use the [rollup.js](https://rollupjs.org/guide/en/) tool to build all dependencies into a single file. In the process, `rollup.js` converts CommonJS modules into [WasmEdge-compatible ES6 modules](es6). The build script is [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js).



```javascript

const { babel } = require('@rollup/plugin-babel');

const nodeResolve = require('@rollup/plugin-node-resolve');

const commonjs = require('@rollup/plugin-commonjs');

const replace = require('@rollup/plugin-replace');



const globals = require('rollup-plugin-node-globals');

const builtins = require('rollup-plugin-node-builtins');

const plugin_async = require('rollup-plugin-async');



const babelOptions = {

  presets: ['@babel/preset-react'],

};



module.exports = [

  {

    input: './npm_main.js',

    output: {

      inlineDynamicImports: true,

      file: 'dist/npm_main.mjs',

      format: 'esm',

    },

    external: ['process', 'wasi_net', 'std'],

    plugins: [

      plugin_async(),

      nodeResolve(),

      commonjs({ ignoreDynamicRequires: false }),

      babel(babelOptions),

      globals(),

      builtins(),

      replace({

        'process.env.NODE_ENV': JSON.stringify('production'),

        'process.env.NODE_DEBUG': JSON.stringify(''),

      }),

    ],

  },

];

```



The [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json) file specifies the `rollup.js` dependencies and the command to build the [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into a single bundle.



```json

{

  ""dependencies"": {

    ""mathjs"": ""^9.5.1"",

    ""md5"": ""^2.3.0""

  },

  ""devDependencies"": {

    ""@babel/core"": ""^7.16.5"",

    ""@babel/preset-env"": ""^7.16.5"",

    ""@babel/preset-react"": ""^7.16.5"",

    ""@rollup/plugin-babel"": ""^5.3.0"",

    ""@rollup/plugin-commonjs"": ""^21.0.1"",

    ""@rollup/plugin-node-resolve"": ""^7.1.3"",

    ""@rollup/plugin-replace"": ""^3.0.0"",

    ""rollup"": ""^2.60.1"",

    ""rollup-plugin-babel"": ""^4.4.0"",

    ""rollup-plugin-node-builtins"": ""^2.1.2"",

    ""rollup-plugin-node-globals"": ""^1.4.0"",

    ""rollup-plugin-async"": ""^1.2.0""

  },

  ""scripts"": {

    ""build"": ""rollup -c rollup.config.js""

  }

}

```



Run the following NPM commands to build [npm_main.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js) demo program into `dist/npm_main.mjs`.



```bash

npm install

npm run build

```



You can import and run any NPM packages in WasmEdge this way.








------"
"The following is a markdown document located at /develop/javascript/rust.md
------


---

sidebar_position: 9

---



# Native JS API in Rust



For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in ""pure JavaScript"" yet still use the high-performance Rust functions. You can do precisely that with the [WasmEdge Runtime](https://github.com/WasmEdge/WasmEdge).



<!-- prettier-ignore -->

:::note

The [internal_module](https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module) folder in the official WasmEdge QuickJS distribution provides Rust-based implementations of some built-in JavaScript API functions. Those functions typically require interactions with host functions in the WasmEdge runtime (e.g., networking and TensorFlow), and hence cannot be accessed by pure JavaScript implementations in [modules](modules.md).

:::



## Prerequisites



- [Install the Rust toolchain](../rust/setup.md)

- [Install WasmEdge QuickJS and get ready](hello_world.md#prerequisites)



## Run the examples



The examples are in the `examples/embed_js` folder in the `wasmedge-quickjs` repo. You can build and run all the examples as follows.



```bash

cd examples/embed_js

cargo build --target wasm32-wasi --release

wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm

```



## Code explanation: embed JavaScript into a Rust program



The following Rust snippet evaluates the JavaScript code in the `code` variable.



```rust

fn js_hello(ctx: &mut Context) {

    println!(""\n<----run_simple_js---->"");

    let code = r#""print('hello quickjs')""#;

    let r = ctx.eval_global_str(code);

    println!(""return value:{:?}"", r);

}



... ...



fn main() {

    let mut ctx = Context::new();

    js_hello(&mut ctx);

    ... ...

}

```



## Code explanation: create a JavaScript function API



The following code snippet defines a Rust function that can be incorporated into the JavaScript interpreter as an API.



```rust

fn run_rust_function(ctx: &mut Context) {



  struct HelloFn;

  impl JsFn for HelloFn {

    fn call(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {

      println!(""hello from rust"");

      println!(""argv={:?}"", argv);

      JsValue::UnDefined

    }

  }



  ...

}

```



The following code snippet shows how to add this Rust function into the JavaScript interpreter, give the name `hi()` as its JavaScript API, and then call it from JavaScript code.



```rust

fn run_rust_function(ctx: &mut Context) {

  ...



  let f = ctx.new_function::<HelloFn>(""hello"");

  ctx.get_global().set(""hi"", f.into());

  let code = r#""hi(1,2,3)""#;

  let r = ctx.eval_global_str(code);

  println!(""return value:{:?}"", r);

}



... ...



fn main() {

    let mut ctx = Context::new();

    run_rust_function(&mut ctx);

    ... ...

}

```



The execution result is as follows.



```bash

hello from rust

argv=[Int(1), Int(2), Int(3)]

return value:UnDefined

```



You can create a JavaScript interpreter with customized API functions using this approach. The interpreter runs inside WasmEdge, and can execute JavaScript code, which calls such API functions from CLI or the network.



## Code explanation: create a JavaScript object API



In the JavaScript API design, we sometimes need to provide an object that encapsulates data and function. The following example defines a Rust function for the JavaScript API.



```rust

fn rust_new_object_and_js_call(ctx: &mut Context) {

  struct ObjectFn;

  impl JsFn for ObjectFn {

    fn call(_ctx: &mut Context, this_val: JsValue, argv: &[JsValue]) -> JsValue {

      println!(""hello from rust"");

      println!(""argv={:?}"", argv);

      if let JsValue::Object(obj) = this_val {

        let obj_map = obj.to_map();

        println!(""this={:#?}"", obj_map);

      }

      JsValue::UnDefined

    }

  }



  ...

}

```



We then create an ""object"" on the Rust side, set its data fields, and then register the Rust function as a JavaScript function associated with the objects.



```rust

let mut obj = ctx.new_object();

obj.set(""a"", 1.into());

obj.set(""b"", ctx.new_string(""abc"").into());



let f = ctx.new_function::<ObjectFn>(""anything"");

obj.set(""f"", f.into());

```



Next, we make the Rust ""object"" available as a JavaScript object `test_obj` in the JavaScript interpreter.



```rust

ctx.get_global().set(""test_obj"", obj.into());

```



You can now directly use `test_obj` in the JavaScript code as part of the API.



```rust

let code = r#""

  print('test_obj keys=',Object.keys(test_obj))

  print('test_obj.a=',test_obj.a)

  print('test_obj.b=',test_obj.b)

  test_obj.f(1,2,3,""hi"")

""#;



ctx.eval_global_str(code);

```



The execution result is as follows.



```bash

test_obj keys= a,b,f

test_obj.a= 1

test_obj.b= abc

hello from rust

argv=[Int(1), Int(2), Int(3), String(JsString(hi))]

this=Ok(

  {

    ""a"": Int(

      1,

    ),

    ""b"": String(

      JsString(

        abc,

      ),

    ),

    ""f"": Function(

      JsFunction(

        function anything() {

          [native code]

        },

      ),

    ),

  },

)

```



## A complete JavaScript object API



In the previous example, we demonstrated simple examples to create JavaScript APIs from Rust. In this example, we will create a complete Rust module and make it available as a JavaScript object API.



### Run the example



The project is in the [examples/embed_rust_module](https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module) folder. You can build and run it as a standard Rust application in WasmEdge.



```bash

cd examples/embed_rust_module

cargo build --target wasm32-wasi --release

wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm

```



### Code explanation



The Rust implementation of the object is a module as follows. It has data fields, constructor, getters and setters, and functions.



```rust

mod point {

  use wasmedge_quickjs::*;



  #[derive(Debug)]

  struct Point(i32, i32);



  struct PointDef;



  impl JsClassDef<Point> for PointDef {

    const CLASS_NAME: &'static str = ""Point\0"";

    const CONSTRUCTOR_ARGC: u8 = 2;



    fn constructor(_: &mut Context, argv: &[JsValue]) -> Option<Point> {

      println!(""rust-> new Point {:?}"", argv);

      let x = argv.get(0);

      let y = argv.get(1);

      if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {

        Some(Point(*x, *y))

      } else {

        None

      }

    }



    fn proto_init(p: &mut JsClassProto<Point, PointDef>) {

      struct X;

      impl JsClassGetterSetter<Point> for X {

        const NAME: &'static str = ""x\0"";



        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {

          println!(""rust-> get x"");

          this_val.0.into()

        }



        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {

          println!(""rust-> set x:{:?}"", val);

          if let JsValue::Int(x) = val {

            this_val.0 = x

          }

        }

      }



      struct Y;

      impl JsClassGetterSetter<Point> for Y {

        const NAME: &'static str = ""y\0"";



        fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {

          println!(""rust-> get y"");

          this_val.1.into()

        }



        fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {

          println!(""rust-> set y:{:?}"", val);

          if let JsValue::Int(y) = val {

            this_val.1 = y

          }

        }

      }



      struct FnPrint;

      impl JsMethod<Point> for FnPrint {

        const NAME: &'static str = ""pprint\0"";

        const LEN: u8 = 0;



        fn call(_: &mut Context, this_val: &mut Point, _argv: &[JsValue]) -> JsValue {

          println!(""rust-> pprint: {:?}"", this_val);

          JsValue::Int(1)

        }

      }



      p.add_getter_setter(X);

      p.add_getter_setter(Y);

      p.add_function(FnPrint);

    }

  }



  struct PointModule;

  impl ModuleInit for PointModule {

    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {

      m.add_export(""Point\0"", PointDef::class_value(ctx));

    }

  }



  pub fn init_point_module(ctx: &mut Context) {

    ctx.register_class(PointDef);

    ctx.register_module(""point\0"", PointModule, &[""Point\0""]);

  }

}

```



In the interpreter implementation, we call `point::init_point_module` first to register the Rust module with the JavaScript context, and then we can run a JavaScript program that uses the `point` object.



```rust

use wasmedge_quickjs::*;

fn main() {

  let mut ctx = Context::new();

  point::init_point_module(&mut ctx);



  let code = r#""

    import('point').then((point)=>{

    let p0 = new point.Point(1,2)

    print(""js->"",p0.x,p0.y)

    p0.pprint()

    try{

      let p = new point.Point()

      print(""js-> p:"",p)

      print(""js->"",p.x,p.y)

      p.x=2

      p.pprint()

    } catch(e) {

      print(""An error has been caught"");

      print(e)

    }

    })

  ""#;



  ctx.eval_global_str(code);

  ctx.promise_loop_poll();

}

```



The execution result from the above application is as follows.



```bash

rust-> new Point [Int(1), Int(2)]

rust-> get x

rust-> get y

js-> 1 2

rust-> pprint: Point(1, 2)

rust-> new Point []

js-> p: undefined

An error has been caught

TypeError: cannot read property 'x' of undefined

```



## Code reuse



We could create JavaScript classes that inherit (or extend) existing classes using the Rust API. That allows developers to develop complex JavaScript APIs by building on existing solutions using Rust. You can see [an example here](https://github.com/second-state/wasmedge-quickjs/blob/main/examples/js_extend.rs).



Next, you can see the Rust code in the [internal_module](https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module) folder for more examples of how to implement common JavaScript built-in functions, including [Node.js](nodejs.md) APIs.








------"
"The following is a markdown document located at /develop/javascript/ssr.md
------


---

sidebar_position: 10

---



# Example: SSR



[React](https://reactjs.org/) is a very popular JavaScript web UI framework. A React application is ""compiled"" into an HTML and JavaScript static website. The web UI is rendered through the generated JavaScript code. However, executing the complex generated JavaScript entirely in the browser is often too slow and resource consuming to build the interactive HTML DOM objects. [React Server Side Rendering (SSR)](https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55) delegates the JavaScript UI rendering to a server and has the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high-performance container to run React SSR functions on edge servers.



Server-side rendering (SSR) is a popular technique for rendering a client-side single-page application (SPA) on the server and then sending a fully rendered page to the client, allowing dynamic components to be served as static HTML markup. This approach can be useful for search engine optimization (SEO) when indexing does not handle JavaScript properly. It may also be beneficial when downloading a large JavaScript bundle is impaired by a slow network. -- [from Digital Ocean](https://www.digitalocean.com/community/tutorials/react-server-side-rendering).



This article will show you how to use the WasmEdge QuickJS runtime to implement a React SSR function. Compared with the Docker + Linux + nodejs + v8 approach, WasmEdge is safer (suitable for multi-tenancy environments) and much lighter (1% of the footprint) with similar performance.



We will start with a complete tutorial to create and deploy a simple React Streaming SSR web application and then move on to a full React 18 demo.



- [Getting started with React streaming SSR](#getting-started)

- [A full React 18 app](#a-full-react-18-app)

- [Appendix: the create-react-app template](#appendix-the-create-react-app-template)



## Getting started



The [example_js/react_ssr_stream](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream) folder in the GitHub repo contains the example's source code. It showcases how to render an HTML string from templates in a JavaScript app in WasmEdge.



The [component/LazyHome.jsx](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx) file is the main page template in React. It ""lazy"" loads the inner page template after a 2s delay once the outer HTML is rendered and returned to the user.



```javascript

import React, { Suspense } from 'react';

import * as LazyPage from './LazyPage.jsx';



async function sleep(ms) {

  return new Promise((r, _) => {

    setTimeout(() => r(), ms);

  });

}



async function loadLazyPage() {

  await sleep(2000);

  return LazyPage;

}



class LazyHome extends React.Component {

  render() {

    let LazyPage1 = React.lazy(() => loadLazyPage());

    return (

      <html lang=""en"">

        <head>

          <meta charSet=""utf-8"" />

          <title>Title</title>

        </head>

        <body>

          <div>

            <div> This is LazyHome </div>

            <Suspense fallback={<div> loading... </div>}>

              <LazyPage1 />

            </Suspense>

          </div>

        </body>

      </html>

    );

  }

}



export default LazyHome;

```



The [LazyPage.jsx](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx) is the inner page template. It is rendered 2s after the outer page is already returned to the user.



```javascript

import React from 'react';



class LazyPage extends React.Component {

  render() {

    return (

      <div>

        <div>This is lazy page</div>

      </div>

    );

  }

}



export default LazyPage;

```



The [main.mjs](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs) file starts a non-blocking HTTP server using standard Node.js APIs, and then renders the HTML page in multiple chunks to the response.



```javascript

import * as React from 'react';

import { renderToPipeableStream } from 'react-dom/server';

import { createServer } from 'http';



import LazyHome from './component/LazyHome.jsx';



createServer((req, res) => {

  res.setHeader('Content-type', 'text/html; charset=utf-8');

  renderToPipeableStream(<LazyHome />).pipe(res);

}).listen(8001, () => {

  print('listen 8001...');

});

```



The [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js) and [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json) files are to build the React SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the `npm` command to build it. The output is in the `dist/main.mjs` file.



```bash

npm install

npm run build

```



Copy over the system's `modules` to the working directory for Node.js API support as [noted here](nodejs.md).



```bash

cp -r ../../modules .

```



To run the example, do the following on the CLI to start the server.



```bash

nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &

```



Send the server an HTTP request via `curl` or the browser.



```bash

curl http://localhost:8001

```



The results are as follows. The service returns an HTML page with an empty inner section (i.e., the `loading` section), then 2s later, the HTML content for the inner section and the JavaScript to display.



```bash

  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current

                                 Dload  Upload   Total   Spent    Left  Speed



  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0

100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024

100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220

100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245

100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413



<!DOCTYPE html><html lang=""en""><head><meta charSet=""utf-8""/><title>Title</title></head><body><div><div> This is LazyHome </div><!--$?--><template id=""B:0""></template><div> loading... </div><!--/$--></div></body></html><div hidden id=""S:0""><template id=""P:1""></template></div><div hidden id=""S:1""><div><div>This is lazy page</div></div></div><script>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(""S:1"",""P:1"")</script><script>function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if(""/$""===d)if(0===e)break;else e--;else""$""!==d&&""$?""!==d&&""$!""!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=""$"";a._reactRetry&&a._reactRetry()}};$RC(""B:0"",""S:0"")</script>

```



## A full React 18 app



In this section, we will demonstrate a complete React 18 SSR application. It renders the web UI through streaming SSR. The [example_js/react18_ssr](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr) folder in the GitHub repo contains the example's source code. The [component](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/component) folder contains the entire React 18 application's source code, and the [public](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/public) folder contains the public resources (CSS and images) for the web application. The application also demonstrates a data provider for the UI.



The [main.mjs](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/main.mjs) file starts a non-blocking HTTP server, fetches data from a data provider, maps the `main.css` and `main.js` files in the `public` folder to web URLs, and then renders the HTML page for each request in `renderToPipeableStream()`.



```javascript

import * as React from 'react';

import { renderToPipeableStream } from 'react-dom/server';

import { createServer } from 'http';

import * as std from 'std';



import App from './component/App.js';

import { DataProvider } from './component/data.js';



let assets = {

  'main.js': '/main.js',

  'main.css': '/main.css',

};



const css = std.loadFile('./public/main.css');



function createServerData() {

  let done = false;

  let promise = null;

  return {

    read() {

      if (done) {

        return;

      }

      if (promise) {

        throw promise;

      }

      promise = new Promise((resolve) => {

        setTimeout(() => {

          done = true;

          promise = null;

          resolve();

        }, 2000);

      });

      throw promise;

    },

  };

}



createServer((req, res) => {

  print(req.url);

  if (req.url == '/main.css') {

    res.setHeader('Content-Type', 'text/css; charset=utf-8');

    res.end(css);

  } else if (req.url == '/favicon.ico') {

    res.end();

  } else {

    res.setHeader('Content-type', 'text/html');



    res.on('error', (e) => {

      print('res error', e);

    });

    let data = createServerData();

    print('createServerData');



    const stream = renderToPipeableStream(

      <DataProvider data={data}>

        <App assets={assets} />

      </DataProvider>,

      {

        onShellReady: () => {

          stream.pipe(res);

        },

        onShellError: (e) => {

          print('onShellError:', e);

        },

      },

    );

  }

}).listen(8002, () => {

  print('listen 8002...');

});

```



The [rollup.config.js](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/rollup.config.js) and [package.json](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/package.json) files are to build the React 18 SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the `npm` command to build it. The output is in the `dist/main.mjs` file.



```bash

npm install

npm run build

```



Copy over the system's `modules` to the working directory for Node.js API support as [noted here](nodejs).



```bash

cp -r ../../modules .

```



To run the example, do the following on the CLI to start the server.



```bash

nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &

```



Send the server an HTTP request via `curl` or the browser.



```bash

curl http://localhost:8002

```



The results are as follows. The service returns an HTML page with an empty inner section (i.e., the `loading` section), and then 2s later, the HTML content for the inner section and the JavaScript to display it.



```bash

  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current

                                 Dload  Upload   Total   Spent    Left  Speed



  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0

100   439    0   439    0     0   1202      0 --:--:-- --:--:-- --:--:--  1199

100  2556    0  2556    0     0   1150      0 --:--:--  0:00:02 --:--:--  1150

100  2556    0  2556    0     0    926      0 --:--:--  0:00:02 --:--:--   926

100  2806    0  2806    0     0    984      0 --:--:--  0:00:02 --:--:--   984

<!DOCTYPE html><html lang=""en""><head><meta charSet=""utf-8""/><meta name=""viewport

"" content=""width=device-width, initial-scale=1""/><link rel=""stylesheet"" href=""/m

ain.css""/><title>Hello</title></head><body><noscript><b>Enable JavaScript to run

 this app.</b></noscript><!--$--><main><nav><a href=""/"">Home</a></nav><aside cla

ss=""sidebar""><!--$?--><template id=""B:0""></template><div class=""spinner spinner-

-active"" role=""progressbar"" aria-busy=""true""></div><!--/$--></aside><article cla

ss=""post""><!--$?--><template id=""B:1""></template><div class=""spinner spinner--ac

tive"" role=""progressbar"" aria-busy=""true""></div><!--/$--><section class=""comment

s""><h2>Comments</h2><!--$?--><template id=""B:2""></template><div class=""spinner s

pinner--active"" role=""progressbar"" aria-busy=""true""></div><!--/$--></section><h2

>Thanks for reading!</h2></article></main><!--/$--><script>assetManifest = {""mai

n.js"":""/main.js"",""main.css"":""/main.css""};</script></body></html><div hidden id=""

S:0""><template id=""P:3""></template></div><div hidden id=""S:1""><template id=""P:4""

></template></div><div hidden id=""S:2""><template id=""P:5""></template></div><div

hidden id=""S:3""><h1>Archive</h1><ul><li>May 2021</li><li>April 2021</li><li>Marc

h 2021</li><li>February 2021</li><li>January 2021</li><li>December 2020</li><li>

November 2020</li><li>October 2020</li><li>September 2020</li></ul></div><script

>function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for

(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChil

d,b);b.parentNode.removeChild(b)};$RS(""S:3"",""P:3"")</script><script>function $RC(

a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.remo

veChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{i

f(c&&8===c.nodeType){var d=c.data;if(""/$""===d)if(0===e)break;else e--;else""$""!==

d&&""$?""!==d&&""$!""!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.

firstChild;)f.insertBefore(b.firstChild,c);a.data=""$"";a._reactRetry&&a._reactRet

ry()}};$RC(""B:0"",""S:0"")</script><div hidden id=""S:4""><h1>Hello world</h1><p>This

 demo is <!-- --><b>artificially slowed down</b>. Open<!-- --> <!-- --><code>ser

ver/delays.js</code> to adjust how much different things are slowed down.<!-- --

></p><p>Notice how HTML for comments &quot;streams in&quot; before the JS (or Re

act) has loaded on the page.</p><p>Also notice that the JS for comments and side

bar has been code-split, but HTML for it is still included in the server output.

</p></div><script>$RS(""S:4"",""P:4"")</script><script>$RC(""B:1"",""S:1"")</script><div

 hidden id=""S:5""><p class=""comment"">Wait, it doesn&#x27;t wait for React to load

?</p><p class=""comment"">How does this even work?</p><p class=""comment"">I like ma

rshmallows</p></div><script>$RS(""S:5"",""P:5"")</script><script>$RC(""B:2"",""S:2"")</s

cript>

```



The streaming SSR examples make use of WasmEdge's unique asynchronous networking capabilities and ES6 module support (i.e., the roll-up bundled JS file contains ES6 modules). You can learn more about [async networking](networking.md) and [ES6](es6.md) in this book.



## Appendix the create-react-app template



The `create-react-app` template is a popular starting point for many developers to create React apps. In this tutorial, we will provide a step-by-step guide on how to use it to create React streaming SSR applications that run on WasmEdge.



### Step 1 — Create the React App



First, use `npx` to create a new React app. Let’s name the app `react-ssr-example`.



```bash

npx create-react-app react-ssr-example

```



Then, `cd` into the directory for the newly created app.



```bash

cd react-ssr-example

```



Start the new app to verify the installation.



```bash

npm start

```



You should see the example React app displayed in your browser window. At this stage, the app is rendered in the browser. The browser runs the generated React JavaScript to build the HTML DOM UI.



Now to prepare for SSR, you will need to make some changes to the app's `index.js` file. Change ReactDOM's `render` method to `hydrate` to indicate to the DOM renderer that you intend to rehydrate the app after it is rendered on the server. Replace the contents of the `index.js` file with the following.



```javascript

import React from 'react';

import ReactDOM from 'react-dom';

import App from './App';

ReactDOM.hydrate(

  <React.StrictMode>

    <App />

  </React.StrictMode>,

  document.getElementById('root'),

);

```



<!-- prettier-ignore -->

:::note

You should import `React` redundantly in the `src/App.js`, so the server will recognize it.

:::



```js

import React from 'react';

//...

```



That concludes setting up the application. You can move on to setting up the server-side rendering functions.



### Step 2 — Create an WasmEdge QuickJS Server and Render the App Component



Now that you have the app in place let’s set up a server that will render the HTML DOM by running the React JavaScript and then send the rendered elements to the browser. We will use WasmEdge as a secure, high-performance, lightweight container to run React JavaScript.



Create a new `server` directory in the project's root directory.



```bash

mkdir server

```



Then, inside the `server` directory, create a new `index.js` file with the server code.



```javascript

import * as React from 'react';

import ReactDOMServer from 'react-dom/server';

import * as std from 'std';

import * as http from 'wasi_http';

import * as net from 'wasi_net';



import App from '../src/App.js';



async function handle_client(cs) {

  print('open:', cs.peer());

  let buffer = new http.Buffer();



  while (true) {

    try {

      let d = await cs.read();

      if (d == undefined || d.byteLength <= 0) {

        return;

      }

      buffer.append(d);

      let req = buffer.parseRequest();

      if (req instanceof http.WasiRequest) {

        handle_req(cs, req);

        break;

      }

    } catch (e) {

      print(e);

    }

  }

  print('end:', cs.peer());

}



function enlargeArray(oldArr, newLength) {

  let newArr = new Uint8Array(newLength);

  oldArr && newArr.set(oldArr, 0);

  return newArr;

}



async function handle_req(s, req) {

  print('uri:', req.uri);



  let resp = new http.WasiResponse();

  let content = '';

  if (req.uri == '/') {

    const app = ReactDOMServer.renderToString(<App />);

    content = std.loadFile('./build/index.html');

    content = content.replace(

      '<div id=""root""></div>',

      `<div id=""root"">${app}</div>`,

    );

  } else {

    let chunk = 1000; // Chunk size of each reading

    let length = 0; // The whole length of the file

    let byteArray = null; // File content as Uint8Array



    // Read file into byteArray by chunk

    let file = std.open('./build' + req.uri, 'r');

    while (true) {

      byteArray = enlargeArray(byteArray, length + chunk);

      let readLen = file.read(byteArray.buffer, length, chunk);

      length += readLen;

      if (readLen < chunk) {

        break;

      }

    }

    content = byteArray.slice(0, length).buffer;

    file.close();

  }

  let contentType = 'text/html; charset=utf-8';

  if (req.uri.endsWith('.css')) {

    contentType = 'text/css; charset=utf-8';

  } else if (req.uri.endsWith('.js')) {

    contentType = 'text/javascript; charset=utf-8';

  } else if (req.uri.endsWith('.json')) {

    contentType = 'text/json; charset=utf-8';

  } else if (req.uri.endsWith('.ico')) {

    contentType = 'image/vnd.microsoft.icon';

  } else if (req.uri.endsWith('.png')) {

    contentType = 'image/png';

  }

  resp.headers = {

    'Content-Type': contentType,

  };



  let r = resp.encode(content);

  s.write(r);

}



async function server_start() {

  print('listen 8002...');

  try {

    let s = new net.WasiTcpServer(8002);

    for (var i = 0; ; i++) {

      let cs = await s.accept();

      handle_client(cs);

    }

  } catch (e) {

    print(e);

  }

}



server_start();

```



The server renders the `<App>` component and then sends the rendered HTML string back to the browser. Three important things are taking place here.



- ReactDOMServer's `renderToString` is used to render the `<App/>` to an HTML string.

- The `index.html` file from the app's `build` output directory is loaded as a template. The app's content is injected into the `<div>` element with an id of `""root""`. It is then sent back as HTTP response.

- Other files from the `build` directory are read and served as needed at the requests of the browser.



### Step 3 — Build and deploy



For the server code to work, you will need to bundle and transpile it. This section will show you how to use Webpack and Babel. This next section will demonstrate an alternative (and potentially easier) approach using rollup.js.



Create a new Babel configuration file named `.babelrc.json` in the project's root directory and add the `env` and `react-app` presets.



```json

{

  ""presets"": [""@babel/preset-env"", ""@babel/preset-react""]

}

```



Create a webpack config for the server that uses Babel Loader to transpile the code. Create the `webpack.server.js` file in the project's root directory.



```js

const path = require('path');

module.exports = {

  entry: './server/index.js',

  externals: [

    { wasi_http: 'wasi_http' },

    { wasi_net: 'wasi_net' },

    { std: 'std' },

  ],

  output: {

    path: path.resolve('server-build'),

    filename: 'index.js',

    chunkFormat: 'module',

    library: {

      type: 'module',

    },

  },

  experiments: {

    outputModule: true,

  },

  module: {

    rules: [

      {

        test: /\.js$/,

        use: 'babel-loader',

      },

      {

        test: /\.css$/,

        use: ['css-loader'],

      },

      {

        test: /\.svg$/,

        use: ['svg-url-loader'],

      },

    ],

  },

};

```



With this configuration, the transpired server bundle will be output to the `server-build` folder in a file called `index.js`.



Next, add the `svg-url-loader` package by entering the following commands in your terminal.



```bash

npm install svg-url-loader --save-dev

```



This completes the dependency installation and webpack and Babel configuration.



Now, revisit `package.json` and add helper npm scripts. Add `dev:build-server`, `dev:start-server` scripts to the `package.json` file to build and serve the SSR application.



```json

""scripts"": {

  ""dev:build-server"": ""NODE_ENV=development webpack --config webpack.server.js --mode=development"",

  ""dev:start-server"": ""wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js"",

  // ...

},

```



- The `dev:build-server` script sets the environment to `""development""` and invokes webpack with the configuration file you created earlier.

- The `dev:start-server` script runs the WasmEdge server from the `wasmedge` CLI tool to serve the built output. The `wasmedge_quickjs.wasm` program contains the QuickJS runtime. [Learn more](hello_world.md)



Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start the server on `:8002`.



```bash

npm run build

npm run dev:build-server

npm run dev:start-server

```



Open `http://localhost:8002/` in your web browser and observe your server-side rendered app.



Previously, the HTML source in the browser is simply the template with SSR placeholders.



```html

Output

<div id=""root""></div>

```



Now, with the SSR function running on the server, the HTML source in the browser is as follows.



```html

Output

<div id=""root""><div class=""App"" data-reactroot="""">...</div></div>

```



### Step 4 (alternative) -- build and deploy with rollup.js



Alternatively, you could use the [rollup.js](https://rollupjs.org/guide/en/) tool to [package all application components and library modules](npm.md) into a single file for WasmEdge to execute.



Create a rollup config for the server that uses Babel Loader to transpile the code. Create the `rollup.config.js` file in the project's root directory.



```js

const { babel } = require('@rollup/plugin-babel');

const nodeResolve = require('@rollup/plugin-node-resolve');

const commonjs = require('@rollup/plugin-commonjs');

const replace = require('@rollup/plugin-replace');



const globals = require('rollup-plugin-node-globals');

const builtins = require('rollup-plugin-node-builtins');

const plugin_async = require('rollup-plugin-async');

const css = require('rollup-plugin-import-css');

const svg = require('rollup-plugin-svg');



const babelOptions = {

  babelrc: false,

  presets: ['@babel/preset-react'],

  babelHelpers: 'bundled',

};



module.exports = [

  {

    input: './server/index.js',

    output: {

      file: 'server-build/index.js',

      format: 'esm',

    },

    external: ['std', 'wasi_net', 'wasi_http'],

    plugins: [

      plugin_async(),

      babel(babelOptions),

      nodeResolve({ preferBuiltins: true }),

      commonjs({ ignoreDynamicRequires: false }),

      css(),

      svg({ base64: true }),

      globals(),

      builtins(),

      replace({

        preventAssignment: true,

        'process.env.NODE_ENV': JSON.stringify('production'),

        'process.env.NODE_DEBUG': JSON.stringify(''),

      }),

    ],

  },

];

```



With this configuration, the transpiled server bundle will be output to the `server-build` folder in a file called `index.js`.



Next, add the dependent packages to the `package.json` then install with `npm`.



```json

  ""devDependencies"": {

    //...

    ""@rollup/plugin-babel"": ""^5.3.0"",

    ""@rollup/plugin-commonjs"": ""^21.0.1"",

    ""@rollup/plugin-node-resolve"": ""^7.1.3"",

    ""@rollup/plugin-replace"": ""^3.0.0"",

    ""rollup"": ""^2.60.1"",

    ""rollup-plugin-async"": ""^1.2.0"",

    ""rollup-plugin-import-css"": ""^3.0.3"",

    ""rollup-plugin-node-builtins"": ""^2.1.2"",

    ""rollup-plugin-node-globals"": ""^1.4.0"",

    ""rollup-plugin-svg"": ""^2.0.0""

  }

```



```bash

npm install

```



This completes the dependency installation and rollup configuration.



Now, revisit `package.json` and add helper npm scripts. Add `dev:build-server`, `dev:start-server` scripts to the `package.json` file to build and serve the SSR application.



```json

""scripts"": {

  ""dev:build-server"": ""rollup -c rollup.config.js"",

  ""dev:start-server"": ""wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js"",

  // ...

},

```



- The `dev:build-server` script sets the environment to `""development""` and invokes webpack with the configuration file you created earlier.

- The `dev:start-server` script runs the WasmEdge server from the `wasmedge` CLI tool to serve the built output. The `wasmedge_quickjs.wasm` program contains the QuickJS runtime. [Learn more](hello_world.md)



Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start the server on `:8002`.



```bash

npm run build

npm run dev:build-server

npm run dev:start-server

```



Open `http://localhost:8002/` in your web browser and observe your server-side rendered app.



Previously, the HTML source in the browser was simply the template with SSR placeholders.



```html

Output

<div id=""root""></div>

```



Now, with the SSR function running on the server, the HTML source in the browser is as follows.



```html

Output

<div id=""root""><div class=""App"" data-reactroot="""">...</div></div>

```








------"
"The following is a markdown document located at /develop/javascript/tensorflow.md
------


---

sidebar_position: 4

---



# AI inference



The WasmEdge-QuickJs supports the WasmEdge WASI-NN plug-ins so your JavaScript can run inference on AI models.



## Prerequisites



Install WasmEdge with WASI-NN plug-in.



- [with the Tensorflow Lite backend](../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend)

- [with the PyTorch backend](../../start/install.md#wasi-nn-plug-in-with-pytorch-backend)



Instead of a [standard](hello_world.md#prerequisites) QuickJS setup, you need to get the WasmEdge QuickJS runtime with WASI NN support built-in. Clone the wasmedge-quickjs repo and use it as the current directory.



```bash

git clone https://github.com/second-state/wasmedge-quickjs

cd wasmedge-quickjs

```



Then download the pre-built [WasmEdge QuickJS + WASI NN Runtime program](#build-it-yourself), and optionally, AOT compiles it for better performance.



```bash

curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs_nn.wasm

wasmedgec wasmedge_quickjs_nn.wasm wasmedge_quickjs_nn.wasm

```



## A Tensorflow Lite example



Here is an example of JavaScript. You could find the full code from [example_js/tensorflow_lite_demo/wasi_nn_main.js](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo/wasi_nn_main.js).



```javascript

import { Image } from 'image';

import * as fs from 'fs';

import { NnGraph, NnContext, TENSOR_TYPE_U8 } from 'wasi_nn';



let img = new Image(__dirname + '/food.jpg');

let img_rgb = img.to_rgb().resize(192, 192);

let rgb_pix = img_rgb.pixels();



let data = fs.readFileSync(

  __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite',

);

let graph = new NnGraph([data.buffer], 'tensorflowlite', 'cpu');

let context = new NnContext(graph);

context.setInput(0, rgb_pix, [1, 192, 192, 3], TENSOR_TYPE_U8);

context.compute();



let output_view = new Uint8Array(2024);

context.getOutput(0, output_view.buffer);



let max = 0;

let max_idx = 0;

for (var i in output_view) {

  let v = output_view[i];

  if (v > max) {

    max = v;

    max_idx = i;

  }

}



let label_file = fs.readFileSync(

  __dirname + '/aiy_food_V1_labelmap.txt',

  'utf-8',

);

let lables = label_file.split(/\r?\n/);



let label = lables[max_idx];



print('label:');

print(label);

print('confidence:');

print(max / 255);

```



To run the JavaScript in the WasmEdge runtime, make sure that you have the [WASI-NN plug-in and Tensorflow Lite dependency libraries installed with WasmEdge](../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend). You should see the food item's name recognized by the TensorFlow lite ImageNet model.



```bash

$ wasmedge --dir .:. wasmedge_quickjs_nn.wasm example_js/tensorflow_lite_demo/wasi_nn_main.js

label:

Hot dog

confidence:

0.8941176470588236

```



## Build it yourself



Following the instructions, you can build a WASI-NN enabled JavaScript interpreter for WasmEdge. Make sure you have installed GCC. If you don't, run the following command line.



```bash

# Install GCC

sudo apt update

sudo apt install build-essential

```



Then, we could build the WasmEdge-Quickjs runtime. Fork or clone the [wasmedge-quickjs Github repository](https://github.com/second-state/wasmedge-quickjs).



```bash

# get the source code

git clone https://github.com/second-state/wasmedge-quickjs

cd wasmedge-quickjs



# Build the QuickJS JavaScript interpreter with WASI NN

cargo build --target wasm32-wasi --release --features=wasi_nn

```



The WebAssembly-based JavaScript interpreter program is located in the build `target` directory.



WasmEdge provides a `wasmedge compile` utility to compile and add a native machine code section to the wasm file. You can use wasmedge to run the natively instrumented wasm file to get much faster performance.



```bash

wasmedge compile target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs_nn.wasm

```








------"
"```json:/develop/python/_category_.json


{

  ""label"": ""Develop WASM Apps in Python"",

  ""position"": 6,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to create WASM apps in Python.""

  }

}








```"
"The following is a markdown document located at /develop/python/hello_world.md
------


---

sidebar_position: 1

---



# Python



Several different language implementations of the Python runtime exist, and some of them support WebAssembly. This document will describe how to run [RustPython](https://github.com/RustPython/RustPython) on WasmEdge to execute Python programs.



## Compile RustPython



To compile RustPython, you should install the Rust toolchain on your machine. And `wasm32-wasi` platform support should be enabled.



```bash

rustup target add wasm32-wasi

```



Then you could use the following command to clone and compile RustPython:



```bash

git clone https://github.com/RustPython/RustPython.git

cd RustPython

cargo build --release --target wasm32-wasi --features=""freeze-stdlib""

```



`freeze-stdlib` feature is enabled for including Python standard library inside the binary file. The output file should be at `target/wasm32-wasi/release/rustpython.wasm`.



## AOT Compile



WasmEdge supports compiling WebAssembly bytecode programs into native machine code for better performance. It is highly recommended to compile the RustPython to native machine code before running.



```bash

wasmedge compile ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm

```



## Run



```bash

wasmedge ./target/wasm32-wasi/release/rustpython.wasm

```



Then you could get a Python shell in WebAssembly!



## Grant file system access



You can pre-open directories to let WASI programs have permission to read and write files stored on the real machine. The following command mounted the current working directory to the WASI virtual file system.



```bash

wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm

```








------"
"```json:/develop/rust/database/_category_.json


{

  ""label"": ""Database drivers"",

  ""position"": 7,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Connect to databases from Rust apps in WasmEdge.""

  }

}








```"
"The following is a markdown document located at /develop/rust/database/my_sql_driver.md
------


---

sidebar_position: 1

---



# MySQL driver



The database connection is necessary for today's enterprise development. WasmEdge provides a MySQL driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.



<!-- prettier-ignore -->

:::note

Before we start, [you need to have Rust and WasmEdge installed](../setup.md).

Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.

:::



## Run the example



The [wasmedge-db-example/mysql_async](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/mysql_async) is a MySQL connector example written in Rust.



```bash

git clone https://github.com/WasmEdge/wasmedge-db-examples

cd wasmedge-db-examples/mysql_async



# Compile the rust code into WASM

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release



# Execute MySQL statements against a MySQL database at mysql://user:passwd@127.0.0.1:3306

wasmedge --env ""DATABASE_URL=mysql://user:passwd@127.0.0.1:3306/mysql"" target/wasm32-wasi/release/crud.wasm

```



<!-- prettier-ignore -->

:::note

Since we have TLS enabled by default in this example, you will need the [wasi-sdk version of clang](../setup#tls-on-macos) for compiling it on MacOS.

:::



To use TLS, you will need to turn on the `default-rustls` feature on the `mysql_async` crate in `Cargo.toml`.

Then, run the application as follows.



```toml

# Execute MySQL statements against an AWS RDS database that requires TLS

wasmedge --env ""DATABASE_SSL=1"" --env ""DATABASE_URL=mysql://user:passwd@mydb.123456789012.us-east-1.rds.amazonaws.com:3306/mysql"" crud.wasm

```



## Configuration



In order to compile the `mysql_async` and `tokio` crates, we will need to apply two patches to add

WasmEdge-specific socket APIs to those crates. The following example shows that the TLS connection is enabled.



```toml

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }



[dependencies]

mysql_async = { version = ""0.34"", default-features=false, features = [ ""default-rustls"" ], git=""https://github.com/blackbeam/mysql_async.git"" }

zstd-sys = ""=2.0.9""

tokio = { version = ""1"", features = [ ""io-util"", ""fs"", ""net"", ""time"", ""rt"", ""macros""] }

```



## Code example



The following code shows how to connect to a MySQL database server, and then insert, update, and delete records using SQL

statements.



Connect to a MySQL database.



```rust

    // Below we create a customized connection pool

    let opts = Opts::from_url(&*get_url()).unwrap();

    let mut builder = OptsBuilder::from_opts(opts);

    if std::env::var(""DATABASE_SSL"").is_ok() {

        builder = builder.ssl_opts(SslOpts::default());

    }

    // The connection pool will have a min of 5 and max of 10 connections.

    let constraints = PoolConstraints::new(5, 10).unwrap();

    let pool_opts = PoolOpts::default().with_constraints(constraints);



    let pool = Pool::new(builder.pool_opts(pool_opts));

    let mut conn = pool.get_conn().await.unwrap();

```



Create a table on the connected database.



```rust

    // create table if no tables exist

    let result = r""SHOW TABLES LIKE 'orders';""

        .with(())

        .map(&mut conn, |s: String| String::from(s))

        .await?;



    if result.len() == 0 {

        // table doesn't exist, create a new one

        r""CREATE TABLE orders (order_id INT, production_id INT, quantity INT, amount FLOAT, shipping FLOAT, tax FLOAT, shipping_address VARCHAR(20));"".ignore(&mut conn).await?;

        println!(""create new table"");

    } else {

        // delete all data from the table.

        println!(""delete all from orders"");

        r""DELETE FROM orders;"".ignore(&mut conn).await?;

    }

```



Insert some records into the MySQL database using SQL.



```rust

    let orders = vec![

        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(""Mataderos 2312"")),

        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(""1234 NW Bobcat"")),

        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(""20 Havelock"")),

        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(""224 Pandan Loop"")),

        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(""No.10 Jalan Besar"")),

    ];



    r""INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address)

      VALUES (:order_id, :production_id, :quantity, :amount, :shipping, :tax, :shipping_address)""

        .with(orders.iter().map(|order| {

            params! {

                ""order_id"" => order.order_id,

                ""production_id"" => order.production_id,

                ""quantity"" => order.quantity,

                ""amount"" => order.amount,

                ""shipping"" => order.shipping,

                ""tax"" => order.tax,

                ""shipping_address"" => &order.shipping_address,

            }

        }))

        .batch(&mut conn)

        .await?;

```



Query the database.



```rust

    // query data

    let loaded_orders = ""SELECT * FROM orders""

        .with(())

        .map(

            &mut conn,

            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {

                Order::new(

                    order_id,

                    production_id,

                    quantity,

                    amount,

                    shipping,

                    tax,

                    shipping_address,

                )

            },

        )

        .await?;

    dbg!(loaded_orders.len());

    dbg!(loaded_orders);

```



Delete some records from the database.



```rust

    // delete some data

    r""DELETE FROM orders WHERE order_id=4;""

        .ignore(&mut conn)

        .await?;



    // query data

    let loaded_orders = ""SELECT * FROM orders""

        .with(())

        .map(

            &mut conn,

            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {

                Order::new(

                    order_id,

                    production_id,

                    quantity,

                    amount,

                    shipping,

                    tax,

                    shipping_address,

                )

            },

        )

        .await?;

    dbg!(loaded_orders.len());

    dbg!(loaded_orders);

```



Update records in the MySQL database.



```rust

    // update some data

    r""UPDATE orders

    SET shipping_address = '8366 Elizabeth St.'

    WHERE order_id = 2;""

        .ignore(&mut conn)

        .await?;

    // query data

    let loaded_orders = ""SELECT * FROM orders""

        .with(())

        .map(

            &mut conn,

            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {

                Order::new(

                    order_id,

                    production_id,

                    quantity,

                    amount,

                    shipping,

                    tax,

                    shipping_address,

                )

            },

        )

        .await?;

    dbg!(loaded_orders.len());

    dbg!(loaded_orders);

```



Close the database connection.



```rust

    drop(conn);

    pool.disconnect().await.unwrap();

```








------"
"The following is a markdown document located at /develop/rust/database/postgres_driver.md
------


---

sidebar_position: 2

---



# PostgreSQL driver



A database connection is necessary for today's enterprise development. WasmEdge provides a PostgreSQL driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.



<!-- prettier-ignore -->

:::note

Before we start, [you need to have Rust and WasmEdge installed](../setup.md).

Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.

:::



## Run the example



The [wasmedge-db-example/postgres](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/postgres) is a PostgreSQL connector example written in Rust.



```bash

git clone https://github.com/WasmEdge/wasmedge-db-examples

cd wasmedge-db-examples/postgres



# Compile the rust code into WASM

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release



# Execute SQL statements against a PostgreSQL database at postgres://user:passwd@localhost/testdb

wasmedge --env ""DATABASE_URL=postgres://user:passwd@localhost/testdb"" target/wasm32-wasi/release/crud.wasm

```



## Configuration



In order to compile the `tokio-postgres` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.



```toml

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

tokio-postgres = { git = ""https://github.com/second-state/rust-postgres.git"" }



[dependencies]

tokio-postgres = ""0.7""

tokio = { version = ""1"", features = [

    ""io-util"",

    ""fs"",

    ""net"",

    ""time"",

    ""rt"",

    ""macros"",

] }

```



## Code explanation



We first use a Rust struct to represent the database table.



```rust

#[derive(Debug)]

struct Order {

    order_id: i32,

    production_id: i32,

    quantity: i32,

    amount: f32,

    shipping: f32,

    tax: f32,

    shipping_address: String,

}



impl Order {

    fn new(

        order_id: i32,

        production_id: i32,

        quantity: i32,

        amount: f32,

        shipping: f32,

        tax: f32,

        shipping_address: String,

    ) -> Self {

        Self {

            order_id,

            production_id,

            quantity,

            amount,

            shipping,

            tax,

            shipping_address,

        }

    }

}

```



Then, you can use the `tokio-postgres` API to access the database through its connection URL.

The code below shows how to perform basic CRUD operations using SQL commands.



```rust

#[tokio::main(flavor = ""current_thread"")]

async fn main() -> Result<(), Error> {

    // Connect to the database.

    let (client, connection) = tokio_postgres::connect(&*get_url(), NoTls).await?;



    // The connection object performs the actual communication with the database,

    // so spawn it off to run on its own.

    tokio::spawn(async move {

        if let Err(e) = connection.await {

            eprintln!(""connection error: {}"", e);

        }

    });



    client.execute(""CREATE TABLE IF NOT EXISTS orders (order_id INT, production_id INT, quantity INT, amount REAL, shipping REAL, tax REAL, shipping_address VARCHAR(256));"", &[]).await?;



    let orders = vec![

        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from(""Mataderos 2312"")),

        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from(""1234 NW Bobcat"")),

        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from(""20 Havelock"")),

        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from(""224 Pandan Loop"")),

        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from(""No.10 Jalan Besar"")),

    ];



    for order in orders.iter() {

        client.execute(

            ""INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address) VALUES ($1, $2, $3, $4, $5, $6, $7)"",

            &[&order.order_id, &order.production_id, &order.quantity, &order.amount, &order.shipping, &order.tax, &order.shipping_address]

        ).await?;

    }



    let rows = client.query(""SELECT * FROM orders;"", &[]).await?;

    for row in rows.iter() {

        let order_id : i32 = row.get(0);

        println!(""order_id {}"", order_id);



        let production_id : i32 = row.get(1);

        println!(""production_id {}"", production_id);



        let quantity : i32 = row.get(2);

        println!(""quantity {}"", quantity);



        let amount : f32 = row.get(3);

        println!(""amount {}"", amount);



        let shipping : f32 = row.get(4);

        println!(""shipping {}"", shipping);



        let tax : f32 = row.get(5);

        println!(""tax {}"", tax);



        let shipping_address : &str = row.get(6);

        println!(""shipping_address {}"", shipping_address);

    }



    client.execute(""DELETE FROM orders;"", &[]).await?;



    Ok(())

}

```








------"
"The following is a markdown document located at /develop/rust/database/qdrant_driver.md
------


---

sidebar_position: 4

---



# Qdrant driver



WasmEdge is emerging as a lightweight, portable, and embeddable runtime for large language models (LLMs). LLM inference applications, such as RAG chatbots and AI agents, can be developed on Mac or Windows, compiled to Wasm once, and then deployed across Nvidia / AMD / ARM-powered devices or servers, fully taking advantage of on-device GPUs, NPUs, and accelerators.



Hence, besides the LLM inference runtime, those LLM applications also need to manage embeddings in vector databases. The [qdrant-rest-client](https://crates.io/crates/qdrant_rest_client) crate allows you to access the Qdrant vector database from your portable Wasm apps!



<!-- prettier-ignore -->

:::note

Before we start, [you need to have Rust and WasmEdge installed](../setup.md).

Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.

:::



## Run the example



The [wasmedge-db-example/qdrant](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/qdrant) is a Qdrant client example written in Rust.



```bash

git clone https://github.com/WasmEdge/wasmedge-db-examples

cd wasmedge-db-examples/qdrant



# Compile the rust code into WASM

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release



# Perform vector data operations against a Qdrant at http://localhost:6333

wasmedge target/wasm32-wasi/release/qdrant_examples.wasm

```



## Configuration



In order to compile the `qdrant_rest_client` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.



```rust

[patch.crates-io]

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

reqwest = { git = ""https://github.com/second-state/wasi_reqwest.git"", branch = ""0.11.x"" }

hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }



[dependencies]

anyhow = ""1.0""

serde_json = ""1.0""

serde = { version = ""1.0"", features = [""derive""] }

url = ""2.3""

tokio = { version = ""1"", features = [""io-util"", ""fs"", ""net"", ""time"", ""rt"", ""macros""] }

qdrant_rest_client = ""0.1.0""

```



## Code explanation



The following program uses the `qdrant_rest_client` crate to access local Qdrant server through its RESTful API.

It first creates several points (vectors), saves those vectors to the Qdrant database, retrieves some vectors,

searches for vectors, and finally deletes them from the database.



```rust

#[tokio::main(flavor = ""current_thread"")]

async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {

    let client = qdrant::Qdrant::new();

    // Create a collection with 10-dimensional vectors

    let r = client.create_collection(""my_test"", 4).await;

    println!(""Create collection result is {:?}"", r);



    let mut points = Vec::<Point>::new();

    points.push(Point {

        id: PointId::Num(1),

        vector: vec![0.05, 0.61, 0.76, 0.74],

        payload: json!({""city"": ""Berlin""}).as_object().map(|m| m.to_owned()),

    });

    points.push(Point {

        id: PointId::Num(2),

        vector: vec![0.19, 0.81, 0.75, 0.11],

        payload: json!({""city"": ""London""}).as_object().map(|m| m.to_owned()),

    });

    points.push(Point {

        id: PointId::Num(3),

        vector: vec![0.36, 0.55, 0.47, 0.94],

        payload: json!({""city"": ""Moscow""}).as_object().map(|m| m.to_owned()),

    });

    points.push(Point {

        id: PointId::Num(4),

        vector: vec![0.18, 0.01, 0.85, 0.80],

        payload: json!({""city"": ""New York""})

            .as_object()

            .map(|m| m.to_owned()),

    });

    points.push(Point {

        id: PointId::Num(5),

        vector: vec![0.24, 0.18, 0.22, 0.44],

        payload: json!({""city"": ""Beijing""}).as_object().map(|m| m.to_owned()),

    });

    points.push(Point {

        id: PointId::Num(6),

        vector: vec![0.35, 0.08, 0.11, 0.44],

        payload: json!({""city"": ""Mumbai""}).as_object().map(|m| m.to_owned()),

    });



    let r = client.upsert_points(""my_test"", points).await;

    println!(""Upsert points result is {:?}"", r);



    println!(

        ""The collection size is {}"",

        client.collection_info(""my_test"").await

    );



    let p = client.get_point(""my_test"", 2).await;

    println!(""The second point is {:?}"", p);



    let ps = client.get_points(""my_test"", vec![1, 2, 3, 4, 5, 6]).await;

    println!(""The 1-6 points are {:?}"", ps);



    let q = vec![0.2, 0.1, 0.9, 0.7];

    let r = client.search_points(""my_test"", q, 2, None).await;

    println!(""Search result points are {:?}"", r);



    let r = client.delete_points(""my_test"", vec![1, 4]).await;

    println!(""Delete points result is {:?}"", r);



    println!(

        ""The collection size is {}"",

        client.collection_info(""my_test"").await

    );



    let q = vec![0.2, 0.1, 0.9, 0.7];

    let r = client.search_points(""my_test"", q, 2, None).await;

    println!(""Search result points are {:?}"", r);

    Ok(())

}

```








------"
"The following is a markdown document located at /develop/rust/database/redis_driver.md
------


---

sidebar_position: 3

---



# Redis driver



WasmEdge provides a Redis driver for Rust developers, enabling developers to build database applications in Rust and then running in WasmEdge.



<!-- prettier-ignore -->

:::note

Before we start, [you need to have Rust and WasmEdge installed](../setup.md).

Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.

:::



## Run the example



The [wasmedge-db-example/redis](https://github.com/WasmEdge/wasmedge-db-examples/tree/main/redis) is a Redis connector example written in Rust.



```bash

git clone https://github.com/WasmEdge/wasmedge-db-examples

cd wasmedge-db-examples/redis



# Compile the rust code into WASM

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release



# Execute Redis command against a Redis instance at redis://localhost/

wasmedge --env ""REDIS_URL=redis://localhost/"" target/wasm32-wasi/release/wasmedge-redis-client-examples.wasm

```



## Configuration



In order to compile the `redis` and `tokio` crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in `Cargo.toml`.



```rust

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }



[dependencies]

anyhow = ""1.0""

chrono = { version = ""0.4"", features = [""serde""] }

tokio = { version = ""1"", features = [""full""] }

redis = { version = ""0.25.4"", default-features = false, features = [

    ""tokio-comp"",

] }

```



## Code explanation



The following program uses the `redis` crate to access a Redis server through its connection URL.

It gets the current time, saves the timestamp object to the Redis server, and then reads it back for

display on the console.



```rust

#[tokio::main(flavor = ""current_thread"")]

async fn main() -> Result<()> {

    // connect to redis

    let client = redis::Client::open(&*get_url()).unwrap();

    let mut con = client.get_multiplexed_async_connection().await.unwrap();



    let time = format!(""{}"", chrono::Utc::now());

    // throw away the result, just make sure it does not fail

    let _: () = con.set(""current_time"", time).await.unwrap();



    // read back the key and return it.  Because the return value

    // from the function is a result for String, this will automatically

    // convert into one.

    let value: String = con.get(""current_time"").await.unwrap();

    println!(""Successfully GET `time`: {}"", value);



    Ok(())

}

```








------"
"```json:/develop/rust/http_service/_category_.json


{

  ""label"": ""HTTP services"",

  ""position"": 4,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Make HTTP requests and create HTTP servers in WasmEdge.""

  }

}








```"
"The following is a markdown document located at /develop/rust/http_service/client.md
------


---

sidebar_position: 1

---



# HTTP client



WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. This chapter will cover HTTP client APIs and libraries to access external web services from your WasmEdge app. For HTTP servers in WasmEdge, please see [the next chapter](server).



<!-- prettier-ignore -->

:::note

Before we start, [you need to have Rust and WasmEdge installed](../setup.md).

Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.

:::



We will discuss HTTP and HTTPS clients using popular Rust APIs.



- [The reqwest API](#the-reqwest-api)

- [The hyper API](#the-hyper-api)



## The reqwest API



The `reqwest` crate is a popular Rust library to create asynchronous HTTP clients. It is built on top of the `hyper` and `tokio` APIs. Many developers find it easier to use. But perhaps more importantly, many existing Rust applications use `reqwest`, and you can make them work in WasmEdge by simply patching the `reqwest` crate in `Cargo.toml` with simple patches! Build and run [the example](https://github.com/WasmEdge/wasmedge_reqwest_demo/) in WasmEdge as follows.



<!-- prettier-ignore -->

:::note

Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run much faster, even in a single-threaded environment.

:::



```bash

git clone https://github.com/WasmEdge/wasmedge_reqwest_demo

cd wasmedge_reqwest_demo



# Build the Rust code

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Use the AoT compiler to get better performance

wasmedge compile target/wasm32-wasi/release/http.wasm http.wasm

wasmedge compile target/wasm32-wasi/release/https.wasm https.wasm



# Run the HTTP GET and POST examples

wasmedge http.wasm



# Run the HTTPS GET and POST examples

wasmedge https.wasm

```



In your Rust application, import the standard [reqwest](https://crates.io/crates/reqwest) and [tokio](https://crates.io/crates/tokio) crates. You will also patch a few dependency crates to make them aware of the WasmEdge socket API. Just add the following lines to your `Cargo.toml`.



```toml

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }

reqwest = { git = ""https://github.com/second-state/wasi_reqwest.git"", branch = ""0.11.x"" }



[dependencies]

reqwest = { version = ""0.11"", default-features = false, features = [""rustls-tls""] }

tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time""] }

```



<!-- prettier-ignore -->

:::note

The `Cargo.toml` here shows that TLS is enabled. If you need to compile it on the MacOS, you will need the [wasi-sdk version of clang](../setup#tls-on-macos).

:::



The [example Rust code](https://github.com/WasmEdge/wasmedge_reqwest_demo/blob/main/src/http.rs) below shows an HTTP GET request.



```rust

use std::collections::HashMap;



#[tokio::main]

async fn main() -> Result<(), Box<dyn std::error::Error>> {

    let resp = reqwest::get(""http://eu.httpbin.org/ip"")

        .await?

        .json::<HashMap<String, String>>()

        .await?;

    println!(""{:#?}"", resp);

    Ok(())

}

```



And here is an HTTP POST request.



```rust

    let client = reqwest::Client::new();



    let res = client

        .post(""http://eu.httpbin.org/post"")

        .body(""msg=WasmEdge"")

        .send()

        .await?;

    let body = res.text().await?;



    println!(""POST: {}"", body);

```



## The hyper API



The [hyper crate](https://crates.io/crates/hyper) is a widely used Rust library to create HTTP and HTTPS networking applications for both clients and servers. A key feature of the `hyper` crate is that it is based on the `tokio` runtime, which supports asynchronous network connections. Asynchronous HTTP or HTTPS requests do not block the execution of the calling application. It allows an application to make multiple concurrent HTTP requests and to process responses as they are received. That enables high-performance networking applications in WasmEdge. Build and run [the hyper example](https://github.com/WasmEdge/wasmedge_hyper_demo/) in WasmEdge as follows.



```bash

git clone https://github.com/WasmEdge/wasmedge_hyper_demo

cd wasmedge_hyper_demo/client



# Build the Rust code

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Use the AoT compiler to get better performance

wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client.wasm wasmedge_hyper_client.wasm



# Run the example

wasmedge wasmedge_hyper_client.wasm

```



In your Rust application, import the [hyper](https://crates.io/crates/hyper) crate,

and patch it with WasmEdge sockets patches.

Just add the following line to your `Cargo.toml`.



```toml

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }



[dependencies]

hyper = { version = ""0.14"", features = [""full""] }

tokio = { version = ""1"", features = [ ""rt"", ""macros"", ""net"", ""time"", ""io-util"" ] }

```



The HTTPS version of the demo is as follows.



```bash

// Build

cd wasmedge_hyper_demo/client-https

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client_https.wasm wasmedge_hyper_client_https.wasm



// Run

wasmedge wasmedge_hyper_client_https.wasm

```



In the HTTPS version of `Cargo.toml`, you just need to import the standard [hyper-rustls](https://crates.io/crates/hyper-rustls), [rustls](https://crates.io/crates/rustls) and [webpki-roots](https://crates.io/crates/webpki-roots) crates with the same patches as above.



```toml

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }



[dependencies]

hyper = { version = ""0.14"", features = [""full""]}

hyper-rustls = { version = ""0.25"", default-features = false, features = [ ""http1"", ""tls12"", ""logging"", ""ring"", ""webpki-tokio"" ] }

rustls = { version = ""0.22"", default-features = false }

webpki-roots = ""0.26.1""



tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}

pretty_env_logger = ""0.4.0""

```



<!-- prettier-ignore -->

:::note

If you need to compile `rustls` as shown in the `Cargo.toml` above on the MacOS, you will need the [wasi-sdk version of clang](../setup#tls-on-macos).

:::



The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client/src/main.rs) below shows an HTTP GET request.



```rust

async fn fetch_url_return_str (url: hyper::Uri) -> Result<()> {

    let client = Client::new();

    let mut res = client.get(url).await?;



    let mut resp_data = Vec::new();

    while let Some(next) = res.data().await {

        let chunk = next?;

        resp_data.extend_from_slice(&chunk);

    }

    println!(""{}"", String::from_utf8_lossy(&resp_data));

```



The [HTTPS example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client-https/src/main.rs) is slightly more complex.



```rust

async fn fetch_https_url(url: hyper::Uri) -> Result<()> {

    let https = wasmedge_hyper_rustls::connector::new_https_connector(

        wasmedge_rustls_api::ClientConfig::default(),

    );

    let client = Client::builder().build::<_, hyper::Body>(https);

    let res = client.get(url).await?;



    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();

    println!(""{}"", String::from_utf8(body.into()).unwrap());

    Ok(())

}

```



And here is an HTTP POST request.



```rust

async fn post_url_return_str (url: hyper::Uri, post_body: &'static [u8]) -> Result<()> {

    let client = Client::new();

    let req = Request::builder()

        .method(Method::POST)

        .uri(url)

        .body(Body::from(post_body))?;

    let mut res = client.request(req).await?;



    let mut resp_data = Vec::new();

    while let Some(next) = res.data().await {

        let chunk = next?;

        resp_data.extend_from_slice(&chunk);

    }

    println!(""{}"", String::from_utf8_lossy(&resp_data));



    Ok(())

}

```








------"
"The following is a markdown document located at /develop/rust/http_service/server.md
------


---

sidebar_position: 2

---



# Server



For WasmEdge to become a cloud-native runtime for microservices, it needs to support HTTP servers. By its very nature, the HTTP server is always asynchronous (non-blocking -- so that it can handle concurrent requests). This chapter will cover HTTP servers using popular Rust APIs.



- [The axum API](#the-axum-api)

- [The hyper API](#the-hyper-api)



<!-- prettier-ignore -->

:::note

Before we start, [you need to have Rust and WasmEdge installed](../setup.md).

Make sure that you read the [special notes on networking apps](../setup#special-notes-for-networking-apps) especially if you are compiling Rust programs on a Mac.

:::



## The axum API



The [axum](https://github.com/tokio-rs/axum) crate is the most popular HTTP server framework in the Rust Tokio ecosystem.

It is also the web framework for many popular services such as the [flows.network](https://flows.network) serverless platform for workflow functions.



Use the axum API to create an asynchronous HTTP server. Build and run [the example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server-axum/) in WasmEdge as follows.



```bash

git clone https://github.com/WasmEdge/wasmedge_hyper_demo

cd wasmedge_hyper_demo/server-axum



# Build the Rust code

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Use the AoT compiler for better performance

wasmedge compile target/wasm32-wasi/release/wasmedge_axum_server.wasm wasmedge_axum_server.wasm



# Run the example

wasmedge wasmedge_axum_server.wasm

```



Then from another terminal, you can request the server. The HTTP server echoes the request data and sends back the response.



```bash

$ curl http://localhost:8080/echo -X POST -d ""WasmEdge""

WasmEdge

```



In your Rust application, you will apply a few patches developed by the WasmEdge community to replace

POSIX sockets with WasmEdge sockets in standard libraries. With those patches, you can then

use the official `tokio` and `axum` crates.



```toml

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }



[dependencies]

axum = ""0.6""

bytes = ""1""

futures-util = ""0.3.30""

tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}

```



The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server-axum/src/main.rs) below shows an HTTP server that responds to incoming requests for the `/` and `/echo` URL endpoints.



```rust

#[tokio::main(flavor = ""current_thread"")]

async fn main() {

    // build our application with a route

    let app = Router::new()

        .route(""/"", get(help))

        .route(""/echo"", post(echo));



    // run it

    let addr = ""0.0.0.0:8080"";

    let tcp_listener = TcpListener::bind(addr).await.unwrap();

    println!(""listening on {}"", addr);

    axum::Server::from_tcp(tcp_listener.into_std().unwrap())

        .unwrap()

        .serve(app.into_make_service())

        .await

        .unwrap();

}

```



The  `echo()` function is called when a `POST` request is received at `/echo`. The function receives and processes

the request body and returns bytes that are sent back as the response message.



```rust

async fn echo(mut stream: BodyStream) -> Bytes {

    if let Some(Ok(s)) = stream.next().await {

        s

    } else {

        Bytes::new()

    }

}

```



## The hyper API



The `hyper` crate is an excellent library for building HTTP servers using customizable low level APIs. Build and run [the example](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server/) in WasmEdge as follows.



```bash

git clone https://github.com/WasmEdge/wasmedge_hyper_demo

cd wasmedge_hyper_demo/server



# Build the Rust code

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

# Use the AoT compiler to get better performance

wasmedge compile target/wasm32-wasi/release/wasmedge_hyper_server.wasm wasmedge_hyper_server.wasm



# Run the example

wasmedge wasmedge_hyper_server.wasm

```



Then from another terminal, you can request the server. The HTTP server echoes the request data and sends back the response.



```bash

$ curl http://localhost:8080/echo -X POST -d ""WasmEdge""

WasmEdge

```



In your Rust application, import the [hyper](https://crates.io/crates/hyper) and [tokio](https://crates.io/crates/tokio) crates, as well as the WasmEdge patches. Just add the following lines to your `Cargo.toml`.



```toml

[patch.crates-io]

tokio = { git = ""https://github.com/second-state/wasi_tokio.git"", branch = ""v1.36.x"" }

socket2 = { git = ""https://github.com/second-state/socket2.git"", branch = ""v0.5.x"" }

hyper = { git = ""https://github.com/second-state/wasi_hyper.git"", branch = ""v0.14.x"" }



[dependencies]

hyper = { version = ""0.14"", features = [""full""]}

tokio = { version = ""1"", features = [""rt"", ""macros"", ""net"", ""time"", ""io-util""]}

```



The [Rust example code](https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/server/src/main.rs) below shows an HTTP server that echoes back any incoming request.



```rust

async fn echo(req: Request<Body>) -> Result<Response<Body>, hyper::Error> {

    match (req.method(), req.uri().path()) {

        // Serve some instructions at /

        (&Method::GET, ""/"") => Ok(Response::new(Body::from(

            ""Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`"",

        ))),



        // Simply echo the body back to the client.

        (&Method::POST, ""/echo"") => Ok(Response::new(req.into_body())),



        (&Method::POST, ""/echo/reversed"") => {

            let whole_body = hyper::body::to_bytes(req.into_body()).await?;



            let reversed_body = whole_body.iter().rev().cloned().collect::<Vec<u8>>();

            Ok(Response::new(Body::from(reversed_body)))

        }



        // Return the 404 Not Found for other routes.

        _ => {

            let mut not_found = Response::default();

            *not_found.status_mut() = StatusCode::NOT_FOUND;

            Ok(not_found)

        }

    }

}

```








------"
"```json:/develop/rust/socket_networking/_category_.json


{

  ""label"": ""Socket networking"",

  ""position"": 5,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Run Tokio-based async Rust applications in WasmEdge.""

  }

}








```"
"The following is a markdown document located at /develop/rust/socket_networking/client.md
------


---

sidebar_position: 1

---



# Socket client



It is possible for WasmEdge applications to open TCP/IP or UDP network sockets in the host system to communicate directly with external applications. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single-threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection. The [wasmedge_wasi_socket](https://github.com/second-state/wasmedge_wasi_socket) crate enables Rust developers to work on the network socket level.



In this chapter, we will show you how to build HTTP clients on TCP sockets. The reason is that the HTTP protocol is relatively simple and could be demonstrated easily. If you use HTTP clients in production, we recommend checking out the [HTTP client](../http_service/client.md) chapter in this book.



- [A simple HTTP client based on TCP sockets](#a-simple-http-client)

- [A non-blocking HTTP client based on TCP sockets](#a-non-blocking-http-client-example)



<!-- prettier-ignore -->

:::note

Before we start, ensure [you have Rust and WasmEdge installed](../setup.md).

:::



## A Simple HTTP Client



You can build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client) in WasmEdge as follows.



```bash

git clone https://github.com/second-state/wasmedge_wasi_socket.git

cd wasmedge_wasi_socket/http_client/



# Build the Rust Code

cargo build --target wasm32-wasi --release

# Use the AoT compiler to get better performance

wasmedge compile target/wasm32-wasi/release/http_client.wasm http_client.wasm



# Run the example

wasmedge http_client.wasm

```



The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client) for the HTTP client is available as follows.



```rust

use wasmedge_http_req::request;



fn main() {

  let mut writer = Vec::new(); //container for body of a response

  let res = request::get(""http://127.0.0.1:1234/get"", &mut writer).unwrap();



  println!(""GET"");

  println!(""Status: {} {}"", res.status_code(), res.reason());

  println!(""Headers {}"", res.headers());

  println!(""{}"", String::from_utf8_lossy(&writer));



  let mut writer = Vec::new(); //container for body of a response

  const BODY: &[u8; 27] = b""field1=value1&field2=value2"";

  // let res = request::post(""https://httpbin.org/post"", BODY, &mut writer).unwrap();

  // no https , no dns

  let res = request::post(""http://127.0.0.1:1234/post"", BODY, &mut writer).unwrap();



  println!(""POST"");

  println!(""Status: {} {}"", res.status_code(), res.reason());

  println!(""Headers {}"", res.headers());

  println!(""{}"", String::from_utf8_lossy(&writer));

}

```



## A non-blocking HTTP client example



You can build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client) in WasmEdge as follows.



```bash

git clone https://github.com/second-state/wasmedge_wasi_socket

cd wasmedge_wasi_socket/nonblock_http_client/



# Build the Rust Code

cargo build --target wasm32-wasi --release

# Use the AoT compiler for better performance

wasmedge compile target/wasm32-wasi/release/nonblock_http_client.wasm nonblock_http_client.wasm



# Run the example

wasmedge nonblock_http_client.wasm

```



<!-- prettier-ignore -->

:::note

Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run faster, even in a single-threaded environment.

:::



The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client) for a non-blocking HTTP client application is available. The following `main()` function starts two HTTP connections. The program keeps both connections open and alternatingly checks for incoming data. In other words, the two connections are not blocking each other. Their data are handled concurrently (or alternatingly) as the data comes in.



```rust

use httparse::{Response, EMPTY_HEADER};

use std::io::{self, Read, Write};

use std::str::from_utf8;

use wasmedge_wasi_socket::TcpStream;



fn main() {

    let req = ""GET / HTTP/1.0\n\n"";

    let mut first_connection = TcpStream::connect(""127.0.0.1:80"").unwrap();

    first_connection.set_nonblocking(true).unwrap();

    first_connection.write_all(req.as_bytes()).unwrap();



    let mut second_connection = TcpStream::connect(""127.0.0.1:80"").unwrap();

    second_connection.set_nonblocking(true).unwrap();

    second_connection.write_all(req.as_bytes()).unwrap();



    let mut first_buf = vec![0; 4096];

    let mut first_bytes_read = 0;

    let mut second_buf = vec![0; 4096];

    let mut second_bytes_read = 0;



    loop {

        let mut first_complete = false;

        let mut second_complete = false;

        if !first_complete {

            match read_data(&mut first_connection, &mut first_buf, first_bytes_read) {

                Ok((bytes_read, false)) => {

                    first_bytes_read = bytes_read;

                }

                Ok((bytes_read, true)) => {

                    println!(""First connection completed"");

                    if bytes_read != 0 {

                        parse_data(&first_buf, bytes_read);

                    }

                    first_complete = true;

                }

                Err(e) => {

                    println!(""First connection error: {}"", e);

                    first_complete = true;

                }

            }

        }

        if !second_complete {

            match read_data(&mut second_connection, &mut second_buf, second_bytes_read) {

                Ok((bytes_read, false)) => {

                    second_bytes_read = bytes_read;

                }

                Ok((bytes_read, true)) => {

                    println!(""Second connection completed"");

                    if bytes_read != 0 {

                        parse_data(&second_buf, bytes_read);

                    }

                    second_complete = true;

                }

                Err(e) => {

                    println!(""Second connection error: {}"", e);

                    second_complete = true;

                }

            }

        }

        if first_complete && second_complete {

            break;

        }

    }

}

```








------"
"The following is a markdown document located at /develop/rust/socket_networking/server.md
------


---

sidebar_position: 2

---



# Socket server



As we described in the [client](client.md) chapter, with the WasmEdge socket API, it is possible for Rust developers to work directly on the TCP and UDP socket level. In this chapter, we will show how to create HTTP servers with the TCP socket API. We chose HTTP here for demonstration purposes due to the simplicity of the HTTP protocol. If you need a production-ready HTTP server, check out the [HTTP server](../http_service/server.md) chapter.



- [An HTTP server example](#an-http-server-example)

- [A non-blocking HTTP server example](#a-non-blocking-http-server-example)



<!-- prettier-ignore -->

:::note

Before we start, ensure [you have Rust and WasmEdge installed](../setup.md).

:::



## An HTTP server example



Build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server) in WasmEdge.



```bash

git clone https://github.com/second-state/wasmedge_wasi_socket

cd wasmedge_wasi_socket/http_server



# Build the Rust code

cargo build --target wasm32-wasi --release

# Use the AoT compiler for better performance

wasmedge compile target/wasm32-wasi/release/http_server.wasm http_server.wasm



# Run the example

$wasmedge http_server.wasm

new connection at 1234

```



To test the HTTP server, you can submit an HTTP request via `curl`.



```bash

$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234

echo: name=WasmEdge

```



The [source code](https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server) for the HTTP server application is available as follows. The example below shows an HTTP server that echoes back any incoming request.



```rust

use bytecodec::DecodeExt;

use httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};

use std::io::{Read, Write};

#[cfg(feature = ""std"")]

use std::net::{Shutdown, TcpListener, TcpStream};

#[cfg(not(feature = ""std""))]

use wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};



fn handle_http(req: Request<String>) -> bytecodec::Result<Response<String>> {

  Ok(Response::new(

    HttpVersion::V1_0,

    StatusCode::new(200)?,

    ReasonPhrase::new("""")?,

    format!(""echo: {}"", req.body()),

  ))

}



fn handle_client(mut stream: TcpStream) -> std::io::Result<()> {

  let mut buff = [0u8; 1024];

  let mut data = Vec::new();



  loop {

    let n = stream.read(&mut buff)?;

    data.extend_from_slice(&buff[0..n]);

    if n < 1024 {

      break;

    }

  }



  let mut decoder =

    RequestDecoder::<httpcodec::BodyDecoder<bytecodec::bytes::Utf8Decoder>>::default();



  let req = match decoder.decode_from_bytes(data.as_slice()) {

    Ok(req) => handle_http(req),

    Err(e) => Err(e),

  };



  let r = match req {

    Ok(r) => r,

    Err(e) => {

      let err = format!(""{:?}"", e);

      Response::new(

        HttpVersion::V1_0,

        StatusCode::new(500).unwrap(),

        ReasonPhrase::new(err.as_str()).unwrap(),

        err.clone(),

      )

    }

  };



  let write_buf = r.to_string();

  stream.write(write_buf.as_bytes())?;

  stream.shutdown(Shutdown::Both)?;

  Ok(())

}



fn main() -> std::io::Result<()> {

  let port = std::env::var(""PORT"").unwrap_or(1234.to_string());

  println!(""new connection at {}"", port);

  let listener = TcpListener::bind(format!(""0.0.0.0:{}"", port))?;

  loop {

    let _ = handle_client(listener.accept()?.0);

  }

}

```



## A non-blocking HTTP server example



Build and run [the example](https://github.com/second-state/wasmedge_wasi_socket/) in WasmEdge as follows.



```bash

git clone https://github.com/second-state/wasmedge_wasi_socket

cd wasmedge_wasi_socket



# Build the Rust code

cargo build --target wasm32-wasi --release

# Use the AoT compiler for better performance

wasmedge compile target/wasm32-wasi/release/poll_tcp_listener.wasm poll_tcp_listener.wasm



# Run the example

wasmedge poll_tcp_listener.wasm

```



You can submit an HTTP request via `curl` to test the HTTP server.



```bash

$ curl -d ""name=WasmEdge"" -X POST http://127.0.0.1:1234

echo: name=WasmEdge

```



The [source code](https://github.com/second-state/wasmedge_wasi_socket/blob/main/examples/poll_tcp_listener.rs) for a non-blocking HTTP server application is available. The following `main()` function starts an HTTP server. It receives events from multiple open connections and processes them as they are received by calling the async handler functions registered to each connection. This server can process events from multiple open connections concurrently.



```rust

fn main() -> std::io::Result<()> {

    let mut connects = Connects::new();

    let server = TcpListener::bind(""127.0.0.1:1234"", true)?;

    connects.add(NetConn::Server(server));



    loop {

        let subs = connects_to_subscriptions(&connects);

        let events = poll::poll(&subs)?;



        for event in events {

            let conn_id = event.userdata as usize;

            match connects.get_mut(conn_id) {

                Some(NetConn::Server(server)) => match event.event_type {

                    poll::EventType::Timeout => unreachable!(),

                    poll::EventType::Error(e) => {

                        return Err(e);

                    }

                    poll::EventType::Read => {

                        let (mut tcp_client, addr) = server.accept(true)?;

                        println!(""accept from {}"", addr);



                        match tcp_client.write(DATA) {

                            Ok(n) if n < DATA.len() => {

                                println!(

                                    ""write hello error: {}"",

                                    io::Error::from(io::ErrorKind::WriteZero)

                                );

                                continue;

                            }

                            Ok(_) => {}

                            Err(ref err) if would_block(err) => {}

                            Err(ref err) if interrupted(err) => {}

                            Err(err) => {

                                println!(""write hello error: {}"", err);

                                continue;

                            }

                        }



                        let id = connects.add(NetConn::Client(tcp_client));

                        println!(""add conn[{}]"", id);

                    }

                    poll::EventType::Write => unreachable!(),

                },

                Some(NetConn::Client(client)) => {

                    match event.event_type {

                        poll::EventType::Timeout => {

                            // if Subscription timeout is not None.

                            unreachable!()

                        }

                        poll::EventType::Error(e) => {

                            println!(""tcp_client[{}] recv a io error: {}"", conn_id, e);

                            connects.remove(conn_id);

                        }

                        poll::EventType::Read => match handle_connection_read(client) {

                            Ok(true) => {

                                println!(""tcp_client[{}] is closed"", conn_id);

                                connects.remove(conn_id);

                            }

                            Err(e) => {

                                println!(""tcp_client[{}] recv a io error: {}"", conn_id, e);

                                connects.remove(conn_id);

                            }

                            _ => {}

                        },

                        poll::EventType::Write => unreachable!(),

                    }

                }

                _ => {}

            }

        }

    }

}

```



The `handle_connection()` function processes the data from those open connections. In this case, it just writes the request body into the response. It is also done asynchronously -- meaning that the `handle_connection()` function creates an event for the response and puts it in the queue. The main application loop processes the event and sends the response while waiting for data from other connections.



```rust

fn handle_connection_read(connection: &mut TcpStream) -> io::Result<bool> {

    let mut connection_closed = false;

    let mut received_buff = [0u8; 2048];



    let mut received_data = Vec::with_capacity(2048);

    loop {

        match connection.read(&mut received_buff) {

            Ok(0) => {

                connection_closed = true;

                break;

            }

            Ok(n) => {

                received_data.extend_from_slice(&received_buff[0..n]);

            }

            Err(ref err) if would_block(err) => break,

            Err(ref err) if interrupted(err) => continue,

            Err(err) => return Err(err),

        }

    }



    if !received_data.is_empty() {

        if let Ok(str_buf) = std::str::from_utf8(&received_data) {

            println!(""Received data: {}"", str_buf.trim_end());

        } else {

            println!(""Received (none UTF-8) data: {:?}"", received_data);

        }

    }



    if connection_closed {

        return Ok(true);

    }



    Ok(false)

}

```








------"
"```json:/develop/rust/wasinn/_category_.json


{

  ""label"": ""AI inference"",

  ""position"": 6,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Create AI inference functions in Rust, and run them in WasmEdge. Complete inference functions for mediapipe model libraries. Pytorch, Tensorflow, Tensorflow Lite, and OpenVINO model formats are supported.""

  }

}








```"
"The following is a markdown document located at /develop/rust/wasinn/llm_inference.md
------


---

sidebar_position: 1

---



# LLM inference



WasmEdge now supports running open-source Large Language Models (LLMs) in Rust. We will use [this example project](https://github.com/second-state/LlamaEdge/tree/main/chat) to show how to make AI inferences with the llama-3.1-8B model in WasmEdge and Rust.



Furthermore, WasmEdge can support any open-source LLMs. Please check [the supported models](https://github.com/second-state/LlamaEdge/blob/main/models.md) for details.



## Prerequisite



Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with ggml installed](../../../start/install.md#wasi-nn-plug-in-with-ggml-backend).



## Quick start



Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly.



First, get the latest llama-chat wasm application



```bash

curl -LO https://github.com/LlamaEdge/LlamaEdge/releases/latest/download/llama-chat.wasm

```



Next, let's get the model. In this example, we are going to use the llama-3.1-8B model in GGUF format. You can also use other kinds of LLMs, check out [here](https://github.com/second-state/llamaedge/blob/main/chat/README.md#get-model).



```bash

curl -LO https://huggingface.co/second-state/Meta-Llama-3.1-8B-Instruct-GGUF/resolve/main/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf

```



Run the inference application in WasmEdge.



```bash

wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat

```



After executing the command, you may need to wait a moment for the input prompt to appear. You can enter your question once you see the `[USER]:` prompt:



```bash

[USER]:

I have two apples, each costing 5 dollars. What is the total cost of these apples?

[ASSISTANT]:

The total cost of the two apples is 10 dollars.

[USER]:

How about four apples?

[ASSISTANT]:

The total cost of four apples is 20 dollars.

```



## Build and run



Let's build the wasm file from the rust source code. First, git clone the `llamaedge` repo.



```bash

git clone https://github.com/LlamaEdge/LlamaEdge.git

cd chat

```



Second, use `cargo` to build the example project.



```bash

cargo build --target wasm32-wasi --release

```



The output WASM file is `target/wasm32-wasi/release/llama-chat.wasm`. Next, use WasmEdge to load the llama-3.1-8b model and then ask the model questions.



```bash

wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat

```



After executing the command, you may need to wait a moment for the input prompt to appear. You can enter your question once you see the `[You]:` prompt:



```bash

[You]:

Which one is greater? 9.11 or 9.8?



[Bot]:

9.11 is greater.



[You]:

why



[Bot]:

11 is greater than 8.

```



## Options



You can configure the chat inference application through CLI options.



```bash

  -m, --model-alias <ALIAS>

          Model alias [default: default]

  -c, --ctx-size <CTX_SIZE>

          Size of the prompt context [default: 512]

  -n, --n-predict <N_PRDICT>

          Number of tokens to predict [default: 1024]

  -g, --n-gpu-layers <N_GPU_LAYERS>

          Number of layers to run on the GPU [default: 100]

  -b, --batch-size <BATCH_SIZE>

          Batch size for prompt processing [default: 512]

  -r, --reverse-prompt <REVERSE_PROMPT>

          Halt generation at PROMPT, return control.

  -s, --system-prompt <SYSTEM_PROMPT>

          System prompt message string [default: ""[Default system message for the prompt template]""]

  -p, --prompt-template <TEMPLATE>

          Prompt template. [default: llama-2-chat] [possible values: llama-2-chat, codellama-instruct, mistral-instruct-v0.1, mistrallite, openchat, belle-llama-2-chat, vicuna-chat, chatml]

      --log-prompts

          Print prompt strings to stdout

      --log-stat

          Print statistics to stdout

      --log-all

          Print all log information to stdout

      --stream-stdout

          Print the output to stdout in the streaming way

  -h, --help

          Print help

```



The `--prompt-template` option is perhaps the most interesting. It allows the application to support different open source LLM models beyond llama2. Check out more prompt templates [here](https://github.com/LlamaEdge/LlamaEdge/tree/main/api-server/chat-prompts).



The `--ctx-size` option specifies the context windows size of the application. It is limited by the model's intrinsic context window size.



The `--log-stat` tells WasmEdge to print out logs and statistics of the model at runtime.



```bash

wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf \

  llama-chat.wasm --prompt-template llama-3-chat --log-stat

..................................................................................................

llama_new_context_with_model: n_ctx      = 512

llama_new_context_with_model: freq_base  = 10000.0

llama_new_context_with_model: freq_scale = 1

llama_new_context_with_model: kv self size  =  256.00 MB

llama_new_context_with_model: compute buffer total size = 76.63 MB

[2023-11-07 02:07:44.019] [info] [WASI-NN] GGML backend: llama_system_info: AVX = 0 | AVX2 = 0 | AVX512 = 0 | AVX512_VBMI = 0 | AVX512_VNNI = 0 | FMA = 0 | NEON = 1 | ARM_FMA = 1 | F16C = 0 | FP16_VA = 1 | WASM_SIMD = 0 | BLAS = 0 | SSE3 = 0 | SSSE3 = 0 | VSX = 0 | 



llama_print_timings:        load time =   11523.19 ms

llama_print_timings:      sample time =       2.62 ms /   102 runs   (    0.03 ms per token, 38961.04 tokens per second)

llama_print_timings: prompt eval time =   11479.27 ms /    49 tokens (  234.27 ms per token,     4.27 tokens per second)

llama_print_timings:        eval time =   13571.37 ms /   101 runs   (  134.37 ms per token,     7.44 tokens per second)

llama_print_timings:       total time =   25104.57 ms

[ASSISTANT]:

Ah, a fellow Peanuts enthusiast! Snoopy is Charlie Brown's lovable and imaginative beagle, known for his wild and wacky adventures in the comic strip and television specials. He's a loyal companion to Charlie Brown and the rest of the Peanuts gang, and his antics often provide comic relief in the series. Is there anything else you'd like to know about Snoopy? 🐶

```



## Improving performance



You can make the inference program run faster by AOT compiling the wasm file first.



```bash

wasmedge compile llama-chat.wasm llama-chat.wasm

wasmedge --dir .:.  --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-chat.wasm -p llama-3-chat

```



## Understand the code



The [main.rs](https://github.com/second-state/llamaedge/blob/main/chat/src/main.rs) is the full Rust code to create an interactive chatbot using a LLM. The Rust program manages the user input, tracks the conversation history, transforms the text into the model’s chat templates, and runs the inference operations using the WASI NN standard API. The code logic for the chat interaction is somewhat complex. In this section, we will use the [simple example](https://github.com/second-state/llamaedge/tree/main/simple) to explain how to set up and perform one inference round trip. Here is how you use the simple example.



```bash

# Download the compiled simple inference wasm

curl -LO https://github.com/second-state/llamaedge/releases/latest/download/llama-simple.wasm



# Give it a prompt and ask it to use the model to complete it.

wasmedge --dir .:. --nn-preload default:GGML:AUTO:Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf llama-simple.wasm \

  --prompt 'Robert Oppenheimer most important achievement is ' --ctx-size 512



output: in 1942, when he led the team that developed the first atomic bomb, which was dropped on Hiroshima, Japan in 1945.

```



First, let's parse command line arguments to customize the chatbot's behavior using `Command` struct. It extracts the following parameters: `prompt` (a prompt that guides the conversation), `model_alias` (a list for the loaded model), and `ctx_size` (the size of the chat context).



```rust

fn main() -> Result<(), String> {

    let matches = Command::new(""Simple LLM inference"")

        .arg(

            Arg::new(""prompt"")

                .short('p')

                .long(""prompt"")

                .value_name(""PROMPT"")

                .help(""Sets the prompt."")

                .required(true),

        )

        .arg(

            Arg::new(""model_alias"")

                .short('m')

                .long(""model-alias"")

                .value_name(""ALIAS"")

                .help(""Sets the model alias"")

                .default_value(""default""),

        )

        .arg(

            Arg::new(""ctx_size"")

                .short('c')

                .long(""ctx-size"")

                .value_parser(clap::value_parser!(u32))

                .value_name(""CTX_SIZE"")

                .help(""Sets the prompt context size"")

                .default_value(DEFAULT_CTX_SIZE),

        )

        .get_matches();



    // model alias

    let model_name = matches

        .get_one::<String>(""model_alias"")

        .unwrap()

        .to_string();



    // prompt context size

    let ctx_size = matches.get_one::<u32>(""ctx_size"").unwrap();

    CTX_SIZE

        .set(*ctx_size as usize)

        .expect(""Fail to parse prompt context size"");



    // prompt

    let prompt = matches.get_one::<String>(""prompt"").unwrap().to_string();

```



After that, the program will create a new Graph using the `GraphBuilder` and loads the model specified by the `model_name` .



```rust

// load the model to wasi-nn

     let graph =

        wasi_nn::GraphBuilder::new(wasi_nn::GraphEncoding::Ggml, wasi_nn::ExecutionTarget::AUTO)

            .build_from_cache(&model_name)

            .expect(""Failed to load the model"");

```



Next, We create an execution context from the loaded Graph. The context is mutable because we will be changing it when we set the input tensor and execute the inference.



```rust

 // initialize the execution context

    let mut context = graph

        .init_execution_context()

        .expect(""Failed to init context"");

```



Next, The prompt is converted into bytes and set as the input tensor for the model inference.



```rust

 // set input tensor

    let tensor_data = prompt.as_str().as_bytes().to_vec();

    context

        .set_input(0, wasi_nn::TensorType::U8, &[1], &tensor_data)

        .expect(""Failed to set prompt as the input tensor"");

```



Next, execute the model inference.



```rust

  // execute the inference

    context.compute().expect(""Failed to complete inference"");

```



After the inference is finished, extract the result from the computation context and losing invalid UTF8 sequences handled by converting the output to a string using `String::from_utf8_lossy`.



```rust

  let mut output_buffer = vec![0u8; *CTX_SIZE.get().unwrap()];

    let mut output_size = context

        .get_output(0, &mut output_buffer)

        .expect(""Failed to get output tensor"");

    output_size = std::cmp::min(*CTX_SIZE.get().unwrap(), output_size);

    let output = String::from_utf8_lossy(&output_buffer[..output_size]).to_string();

```



Finally, print the prompt and the inference output to the console.



```rust

println!(""\nprompt: {}"", &prompt);

println!(""\noutput: {}"", output);

```



## Resources



* If you're looking for multi-turn conversations with llama models, please check out the above mentioned chat example source code [here](https://github.com/second-state/llamaedge/tree/main/chat).

* If you want to construct OpenAI-compatible APIs specifically for your llama2 model, or the Llama2 model itself, please check out the source code [for the API server](https://github.com/second-state/llamaedge/tree/main/api-server).

* To learn more, please check out [this article](https://medium.com/stackademic/fast-and-portable-llama2-inference-on-the-heterogeneous-edge-a62508e82359).








------"
"The following is a markdown document located at /develop/rust/wasinn/mediapipe.md
------


---

sidebar_position: 2

---



# Mediapipe solutions



Mediapipe is a collection of highly popular AI models developed by Google. They focus on intelligent processing of media files and streams. The `mediapipe-rs` crate is a Rust library for data processing using the Mediapipe suite of models. The crate provides Rust APIs to pre-process the data in media files or streams, run AI model inference to analyze the data, and then post-process or manipulate the media data based on the AI output.



## Prerequisite



Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with TensorFlow Lite installed](../../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend).



## Quick start



Clone the following demo project to your local computer or dev environment.



```bash

git clone https://github.com/juntao/demo-object-detection

cd demo-object-detection/

```



Build an inference application using the Mediapipe object detection model.



```bash

cargo build --target wasm32-wasi --release

wasmedge compile target/wasm32-wasi/release/demo-object-detection.wasm demo-object-detection.wasm

```



Run the inference application against an image. The input `example.jpg` image is shown below.



![The input image](https://raw.githubusercontent.com/juntao/demo-object-detection/main/example.jpg)



```bash

wasmedge --dir .:. demo-object-detection.wasm example.jpg output.jpg

```



The inference result `output.jpg` image is shown below.



![The output image](https://raw.githubusercontent.com/WasmEdge/mediapipe-rs/main/assets/doc/cat_and_dog_detection.jpg)



The console output from the above inference command shows the detected objects and their boundaries.



```bash

DetectionResult:

  Detection #0:

    Box: (left: 0.47665566, top: 0.05484602, right: 0.87270254, bottom: 0.87143743)

    Category #0:

      Category name: ""dog""

      Display name:  None

      Score:         0.7421875

      Index:         18

  Detection #1:

    Box: (left: 0.12402746, top: 0.37931007, right: 0.5297544, bottom: 0.8517805)

    Category #0:

      Category name: ""cat""

      Display name:  None

      Score:         0.7421875

      Index:         17

```



## Understand the code



The [main.rs](https://github.com/juntao/demo-object-detection/blob/main/src/main.rs) is the complete example Rust source. All `mediapipe-rs` APIs follow a common pattern. A Rust struct is designed to work with a model. It contains functions required to pre- and post-process data for the model. For example, we can create an `detector` instance using the builder pattern, which can build from any ""object detection"" model in the Mediapipe model library.



```rust

let model_data: &[u8] = include_bytes!(""mobilenetv2_ssd_256_uint8.tflite"");

let detector = ObjectDetectorBuilder::new()

        .max_results(2)

        .build_from_buffer(model_data)?;

```



The `detect()` function takes in an image, pre-processes it into a tensor array, runs inference on the mediapipe object detection model, and the post-processes the returned tensor array into a human readable format stored in the `detection_result`.



```rust

let mut input_img = image::open(img_path)?;

let detection_result = detector.detect(&input_img)?;

println!(""{}"", detection_result);

```



Furthermore, the `mediapipe-rs` crate provides additional utility functions to post-process the data. For example, the `draw_detection()` utility function draws the data in `detection_result` onto the input image.



```rust

draw_detection(&mut input_img, &detection_result);

input_img.save(output_path)?;

```



## Available mediapipe models



`AudioClassifierBuilder` builds from an audio classification model and uses `classify()` to process audio data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/audio_classification.rs).



`GestureRecognizerBuilder` builds from a hand gesture recognition model and uses `recognize()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/gesture_recognition.rs).



`ImageClassifierBuilder` builds from an image classification model and uses `classify()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/image_classification.rs).



`ImageEmbedderBuilder` builds from an image embedding model and uses `embed()` to compute a vector representation (embedding) for an input image. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/image_embedding.rs).



`ObjectDetectorBuilder` builds from an object detection model and uses `detect()` to process image data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/object_detection.rs).



`TextClassifierBuilder` builds from a text classification model and uses `classify()` to process text data. [See an example](https://github.com/WasmEdge/mediapipe-rs/blob/main/examples/text_classification.rs).








------"
"The following is a markdown document located at /develop/rust/wasinn/openvino.md
------


---

sidebar_position: 3

---



# OpenVINO Backend



We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image) to show how to make AI inference with an OpenVINO model in WasmEdge and Rust.



## Prerequisite



Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with OpenVINO installed](../../../start/install.md#wasi-nn-plug-in-with-openvino-backend).



## Quick start



Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/openvino-mobilenet-image/

```



Download the model files in OpenVINO format and then run the inference application in WasmEdge.



```bash

# download the fixture files (OpenVINO model files)

./download_mobilenet.sh

wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg

```



If everything goes well, you should have the terminal output:



```bash

Read graph XML, size in bytes: 143525

Read graph weights, size in bytes: 13956476

Loaded graph into wasi-nn with ID: 0

Created wasi-nn execution context with ID: 0

Read input tensor, size in bytes: 602112

Executed graph inference

   1.) [954](0.9789)banana

   2.) [940](0.0074)spaghetti squash

   3.) [951](0.0014)lemon

   4.) [969](0.0005)eggnog

   5.) [942](0.0005)butternut squash

```



## Build and run



Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/openvino-mobilenet-image/rust/

```



Second, use `cargo` to build the template project.



```bash

cargo build --target wasm32-wasi --release

```



The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-mobilenet-image.wasm`. Download the OpenVINO model files. Next, use WasmEdge to load the OpenVINO model and then use it to classify objects in your image.



```bash

./download_mobilenet.sh

wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.xml mobilenet.bin input.jpg

```



You can replace `input.jpg` with your image file.



## Improve performance



You can make the inference program run faster by AOT compiling the `wasm` file first.



```bash

wasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm

wasmedge --dir .:. out.wasm mobilenet.xml mobilenet.bin input.jpg

```



## Understand the code



The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image/rust/src/main.rs) is the full example Rust source. First, read the image file and OpenVINO model file names from the command line.



```rust

let args: Vec<String> = env::args().collect();

let model_xml_name: &str = &args[1]; // File name for the model xml

let model_bin_name: &str = &args[2]; // File name for the weights

let image_name: &str = &args[3]; // File name for the input image

```



We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `F32`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.



```rust

// load model

let graph = GraphBuilder::new(

    GraphEncoding::Openvino,

    ExecutionTarget::CPU

).build_from_files([model_xml_path, model_bin_path])?;

let mut context = graph.init_execution_context()?;



// Load a tensor that precisely matches the graph input tensor

let input_dims = vec![1, 3, 224, 224];

let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);

context.set_input(0, TensorType::F32, &input_dims, tensor_data)?;



// Execute the inference.

context.compute()?;



// Retrieve the output.

let mut output_buffer = vec![0f32; 1001];

let size_in_bytes = context.get_output(0, &mut output_buffer)?;

```



In the above code, `GraphEncoding::Openvino` means using the OpenVINO backend, and `ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results.



```rust

let results = sort_results(&output_buffer);

for i in 0..5 {

    println!(

        ""   {}.) [{}]({:.4}){}"",

        i + 1,

        results[i].0,

        results[i].1,

        imagenet_classes::IMAGENET_CLASSES[results[i].0]

    );

}

```



## More Examples



There is also an example that [using OpenVINO to do road segmentation ADAS](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-road-segmentation-adas/rust). Welcome to give it a try. You are also welcome to contribute your own examples.








------"
"The following is a markdown document located at /develop/rust/wasinn/piper.md
------


---

sidebar_position: 6

---



# Piper Backend



We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/wasmedge-piper) to show how to make AI inference with a Piper model in WasmEdge and Rust.



## Prerequisite



Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with Piper installed](../../../start/install.md#wasi-nn-plug-in-with-piper-backend).



## Quick start



Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/wasmedge-piper/

```



Please follow the `README.md` to run the example.








------"
"The following is a markdown document located at /develop/rust/wasinn/pytorch.md
------


---

sidebar_position: 5

---



# PyTorch Backend



We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image) to show how to make AI inference with a PyTorch model in WasmEdge and Rust.



## Prerequisite



Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [Wasi-NN plugin with PyTorch installed](../../../start/install.md#wasi-nn-plug-in-with-pytorch-backend).



## Quick start



Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/pytorch-mobilenet-image/

```



Run the inference application in WasmEdge.



```bash

wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg

```



If everything goes well, you should have the terminal output:



```bash

Read torchscript binaries, size in bytes: 14376924

Loaded graph into wasi-nn with ID: 0

Created wasi-nn execution context with ID: 0

Read input tensor, size in bytes: 602112

Executed graph inference

   1.) [954](20.6681)banana

   2.) [940](12.1483)spaghetti squash

   3.) [951](11.5748)lemon

   4.) [950](10.4899)orange

   5.) [953](9.4834)pineapple, ananas

```



## Build and run



Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/pytorch-mobilenet-image/rust

```



Second, use `cargo` to build the example project.



```bash

cargo build --target wasm32-wasi --release

```



The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-mobilenet-image.wasm`. Next, use WasmEdge to load the PyTorch model and then use it to classify objects in your image.



```bash

wasmedge --dir .:. wasmedge-wasinn-example-mobilenet-image.wasm mobilenet.pt input.jpg

```



You can replace `input.jpg` with your image file.



## Improve performance



You can make the inference program run faster by AOT compiling the `wasm` file first.



```bash

wasmedge compile wasmedge-wasinn-example-mobilenet.wasm out.wasm

wasmedge --dir .:. out.wasm mobilenet.pt input.jpg

```



## Understand the code



The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image/rust/src/main.rs) is the complete example Rust source. First, read the image file and PyTorch model file names from the command line.



```rust

let args: Vec<String> = env::args().collect();

let model_bin_name: &str = &args[1]; // File name for the PyTorch model

let image_name: &str = &args[2]; // File name for the input image

```



We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `F32`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.



```rust

// load model

let graph = wasi_nn::GraphBuilder::new(

    wasi_nn::GraphEncoding::Pytorch,

    wasi_nn::ExecutionTarget::CPU,

).build_from_files([model_bin_name]).unwrap();

let mut context = graph.init_execution_context().unwrap();



// Load a tensor that precisely matches the graph input tensor

let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);

context.set_input(0, wasi_nn::TensorType::F32, &[1, 3, 224, 224], &tensor_data).unwrap();



// Execute the inference.

context.compute().unwrap();



// Retrieve the output.

let mut output_buffer = vec![0f32; 1000];

context.get_output(0, &mut output_buffer).unwrap();

```



In the above code, `wasi_nn::GraphEncoding::Pytorch` means using the PyTorch backend, and `wasi_nn::ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results.



```rust

let results = sort_results(&output_buffer);

for i in 0..5 {

  println!(

    ""   {}.) [{}]({:.4}){}"",

    i + 1,

    results[i].0,

    results[i].1,

    imagenet_classes::IMAGENET_CLASSES[results[i].0]

  );

}

```








------"
"The following is a markdown document located at /develop/rust/wasinn/tensorflow_lite.md
------


---

sidebar_position: 4

---



# TensorFlow Lite Backend



We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/tflite-birds_v1-image) to show how to make AI inference with a TensorFlow Lite model in WasmEdge and Rust.



## Prerequisite



Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with TensorFlow Lite installed](../../../start/install.md#wasi-nn-plug-in-with-tensorflow-lite-backend).



## Quick start



Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/tflite-birds_v1-image/

```



Run the inference application in WasmEdge.



```bash

wasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg

```



If everything goes well, you should have the terminal output:



```bash

Read graph weights, size in bytes: 3561598

Loaded graph into wasi-nn with ID: 0

Created wasi-nn execution context with ID: 0

Read input tensor, size in bytes: 150528

Executed graph inference

   1.) [166](198)Aix galericulata

   2.) [158](2)Coccothraustes coccothraustes

   3.) [34](1)Gallus gallus domesticus

   4.) [778](1)Sitta europaea

   5.) [819](1)Anas platyrhynchos

```



## Build and run



Let's build the wasm file from the rust source code. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/tflite-birds_v1-image/rust/

```



Second, use `cargo` to build the example project.



```bash

cargo build --target wasm32-wasi --release

```



The output WASM file is `target/wasm32-wasi/release/wasmedge-wasinn-example-tflite-bird-image.wasm`. Next, let's use WasmEdge to load the Tensorflow Lite model and then use it to classify objects in your image.



```bash

wasmedge --dir .:. wasmedge-wasinn-example-tflite-bird-image.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg

```



You can replace `bird.jpg` with your image file.



## Improve performance



You can make the inference program run faster by AOT compiling the `wasm` file first.



```bash

wasmedge compile wasmedge-wasinn-example-tflite-bird-image.wasm out.wasm

wasmedge --dir .:. out.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg

```



## Understand the code



The [main.rs](https://github.com/second-state/WasmEdge-WASINN-examples/blob/master/tflite-birds_v1-image/rust/tflite-bird/src/main.rs) is the complete example Rust source. First, read the image file and Tensorflow Lite (tflite) model file names from the command line.



```rust

let args: Vec<String> = env::args().collect();

let model_bin_name: &str = &args[1]; // File name for the TFLite model

let image_name: &str = &args[2]; // File name for the input image

```



We use a helper function called `image_to_tensor()` to convert the input image into tensor data (the tensor type is `U8`). Now we can load the model, feed the tensor array from the image to the model, and get the inference output tensor array.



```rust

// load model

let weights = fs::read(model_bin_name)?;

let graph = GraphBuilder::new(

    GraphEncoding::TensorflowLite,

    ExecutionTarget::CPU,

).build_from_bytes(&[&weights])?;

let mut ctx = graph.init_execution_context()?;



// Load a tensor that precisely matches the graph input tensor

let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);

ctx.set_input(0, TensorType::U8, &[1, 224, 224, 3], &tensor_data)?;



// Execute the inference.

ctx.compute().unwrap();



// Retrieve the output.

let mut output_buffer = vec![0u8; imagenet_classes::AIY_BIRDS_V1.len()];

_ = ctx.get_output(0, &mut output_buffer)?;

```



In the above code, `GraphEncoding::TensorflowLite` means using the PyTorch backend, and `ExecutionTarget::CPU` means running the computation on the CPU. Finally, we sort the output and then print the top-5 classification results. Finally, we sort the output and then print the top-5 classification results:



```rust

let results = sort_results(&output_buffer);

for i in 0..5 {

    println!(

        ""   {}.) [{}]({:.4}){}"",

        i + 1,

        results[i].0,

        results[i].1,

        imagenet_classes::AIY_BIRDS_V1[results[i].0]

    );

}

```








------"
"The following is a markdown document located at /develop/rust/wasinn/tf_plugin.md
------


---

sidebar_position: 8

---



# TensorFlow And TensorFlow-Lite Plug-in For WasmEdge



Developers can use [WASI-NN](https://github.com/WebAssembly/wasi-nn) to inference the models. However, for the TensorFlow and TensorFlow-Lite users, the WASI-NN APIs could be more friendly to retrieve the input and output tensors. Therefore WasmEdge provides the TensorFlow-related plug-in and rust SDK for inferencing models in WASM.



<!-- prettier-ignore -->

:::info

This is not a WASI-NN compatible plug-in. If you are finding the plug-ins working with the [WASI-NN crate](https://crates.io/crates/wasi-nn), please follow the [tensorflow-lite backend](tensorflow_lite.md) instead.

:::



## Prerequisite



Please ensure that you [Rust and WasmEdge installed](../setup.md).



Developers will add the [`wasmedge_tensorflow_interface` crate](https://crates.io/crates/wasmedge_tensorflow_interface) as a dependency to their `Rust -> Wasm` applications. For example, add the following line to the application's `Cargo.toml` file.



```toml

[dependencies]

wasmedge_tensorflow_interface = ""0.3.0""

```



Developers will bring the functions of `wasmedge_tensorflow_interface` into scope within their `Rust -> Wasm` application's code. For example, adding the following code to the top of their `main.rs`.



```rust

use wasmedge_tensorflow_interface;

```



## Image Loading And Conversion



In this crate, we provide several functions to decode and convert images into tensors using the `WasmEdge-Image` host functions.



To use these functions in WASM and execute in WasmEdge, users should [install WasmEdge with WasmEdge-Image plug-in](../../../start/install.md#wasmedge-image-plug-in).



For decoding the `JPEG` images, there are:



```rust

// Function to decode JPEG from buffer and resize to RGB8 format.

pub fn load_jpg_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>

// Function to decode JPEG from buffer and resize to BGR8 format.

pub fn load_jpg_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>

// Function to decode JPEG from buffer and resize to RGB32F format.

pub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>

// Function to decode JPEG from buffer and resize to BGR32F format.

pub fn load_jpg_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>

```



For decoding the `PNG` images, there are:



```rust

// Function to decode PNG from buffer and resize to RGB8 format.

pub fn load_png_image_to_rgb8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>

// Function to decode PNG from buffer and resize to BGR8 format.

pub fn load_png_image_to_bgr8(img_buf: &[u8], w: u32, h: u32) -> Vec<u8>

// Function to decode PNG from buffer and resize to RGB32F format.

pub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>

// Function to decode PNG from buffer and resize to BGR32F format.

pub fn load_png_image_to_rgb32f(img_buf: &[u8], w: u32, h: u32) -> Vec<f32>

```



Developers can load, decode, and resize image as following:



```rust

let mut file_img = File::open(""sample.jpg"").unwrap();

let mut img_buf = Vec::new();

file_img.read_to_end(&mut img_buf).unwrap();

let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb32f(&img_buf, 224, 224);

// The flat_img is a vec<f32> which contains normalized image in rgb32f format and resized to 224x224.

```



## Inferring TensorFlow And TensorFlow-Lite Models



For using the `TFSession` struct to inference the TensorFlow models and executing in WasmEdge, users should install the [WasmEdge-TensorFlow plug-in with dependencies](../../../start/install.md#wasmedge-tensorflow-plug-in).



For using the `TFLiteSession` struct and to inference the TensorFlow-Lite models executing in WasmEdge, users should install the [WasmEdge-TensorFlowLite plug-in with dependencies](../../../start/install.md#wasmedge-tensorflow-lite-plug-in).



### Create Session



First, developers should create a session to load the TensorFlow or TensorFlow-Lite model.



```rust

// The mod_buf is a vec<u8> which contains the model data.

let mut session = wasmedge_tensorflow_interface::TFSession::new(&mod_buf);

```



The above function creates the session for TensorFlow frozen models. Developers can use the `new_from_saved_model` function to create from saved-models:



```rust

// The mod_path is a &str which is the path to saved-model directory.

// The second argument is the list of tags.

let mut session = wasmedge_tensorflow_interface::TFSession::new_from_saved_model(model_path, &[""serve""]);

```



Or use the `TFLiteSession` to create a session for inferring the `tflite` models.



```rust

// The mod_buf is a vec<u8> which contains the model data.

let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(&mod_buf);

```



### Prepare Input Tensors



```rust

// The flat_img is a vec<f32> which contains normalized image in rgb32f format.

session.add_input(""input"", &flat_img, &[1, 224, 224, 3])

       .add_output(""MobilenetV2/Predictions/Softmax"");

```



### Run TensorFlow Models



```rust

session.run();

```



### Convert Output Tensors



```rust

let res_vec: Vec<f32> = session.get_output(""MobilenetV2/Predictions/Softmax"");

```



## Build And Execution



After completing your code, you can follow the command to compile into WASM.



```bash

cargo build --target=wasm32-wasi

```



The output WASM file will be at `target/wasm32-wasi/debug/` or `target/wasm32-wasi/release`.



Please refer to [WasmEdge CLI](../../../start/build-and-run/cli.md) for WASM execution.



## Examples



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /develop/rust/wasinn/whisper.md
------


---

sidebar_position: 7

---



# Whisper Backend



We will use [this example project](https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/whisper-basic) to show how to make AI inference with a Whisper model in WasmEdge and Rust.



## Prerequisite



Besides the [regular WasmEdge and Rust requirements](../../rust/setup.md), please make sure that you have the [WASI-NN plugin with Whisper installed](../../../start/install.md#install-wasmedge-with-plug-ins).



## Quick start



Because the example already includes a compiled WASM file from the Rust code, we could use WasmEdge CLI to execute the example directly. First, git clone the `WasmEdge-WASINN-examples` repo.



```bash

git clone https://github.com/second-state/WasmEdge-WASINN-examples.git

cd WasmEdge-WASINN-examples/whisper-basic/

```



Please follow the `README.md` to run the example.








------"
"```json:/develop/rust/_category_.json


{

  ""label"": ""Develop WASM Apps in Rust"",

  ""position"": 4,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Rust is well supported in the WebAssembly ecosystem. In this chapter, you will learn how to create Wasm apps in Rust.""

  }

}








```"
"The following is a markdown document located at /develop/rust/bindgen.md
------


---

sidebar_position: 10

---



# Bindgen of Rust Functions



If your Rust program has a `main()` function, you could compile it into WebAssembly, and run it using the `wasmedge` CLI tool as a standalone application. However, a far more common use case is to compile a Rust function into WebAssembly, and then call it from a host application. That is known as an embedded WASM function. The host application uses WasmEdge language SDKs (e.g., [Go](/category/go-sdk-for-embedding-wasmedge), [Rust](/category/rust-sdk-for-embedding-wasmedge), [C](/category/c-sdk-for-embedding-wasmedge), Python (WIP) and Java (WIP)) to call those WASM functions compiled from Rust source code. In this chapter, we will cover a little about WasmEdge-bindgen, and you can find more information [here](/category/passing-complex-data)



All the WasmEdge host language SDKs support simple function calls. However, the WASM spec only supports simple data types as call parameters and return values, such as `i32`, `i64`, `f32`, `f64`, and `v128`. The `wasmedge-bindgen` crate would transform parameters and return values of Rust functions into simple integer types when the Rust function is compiled into WASM. For example, a string is automatically converted into two integers, a memory address and a length, which the standard WASM spec can handle. It is very easy to do this in Rust source code. Just annotate your function with the `#[wasmedge-bindgen]` macro. You can compile the annotated Rust code using the standard Rust compiler toolchain (e.g., the latest `Cargo`).



```rust

use wasmedge_bindgen::*;

use wasmedge_bindgen_macro::*;



#[wasmedge_bindgen]

pub fn say(s: String) -> Result<Vec<u8>, String> {

  let r = String::from(""hello "");

  return Ok((r + s.as_str()).as_bytes().to_vec());

}

```



Of course, once the above Rust code is compiled into WASM, the function `say()` no longer takes the `String` parameter nor returns the `Vec<u8>`. So, the caller (i.e., the host application) must also deconstruct the call parameter into the memory pointer first before the call and assemble the return value from the memory pointer after the call. These actions can be handled automatically by the WasmEdge language SDKs. To see a complete example, including the Rust WASM function and the Go host application, check out our tutorial in the Go SDK documentation.



[A complete wasmedge-bindgen example in Rust (WASM) and Go (host)](../../embed/go/function.md)



Of course, the developer could do `wasmedge-bindgen`'s work by hand and pass a memory pointer directly. If you are interested in this approach to call Rust compiled WASM functions, check out our [examples in the Go SDK](../../embed/go/passing_data.md).








------"
"The following is a markdown document located at /develop/rust/command.md
------


---

sidebar_position: 11

---



# Command interface



WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts. The program cannot access resources (e.g., file folders) that are not explicitly allowed.



Now, why limit ourselves to standard library functions? The same approach can call just any host function from WebAssembly. WasmEdge provides a WASI-like extension to access command line programs in the host operating system.



The command line program can



- Take input via command line arguments and the `STDIN` stream.

- Return value and data via the `STDOUT` stream.



Application developers for WasmEdge can use our Rust interface crate to access this functionality. In `Cargo.toml`, ensure you have this dependency.



```toml

[dependencies]

wasmedge_process_interface = ""0.2.1""

```



In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the `arg()` method as well as via the `STDIN`, and receives the return values via the `STDOUT`.



```rust

let mut cmd = Command::new(""http_proxy"");



cmd.arg(""post"")

   .arg(""https://api.sendgrid.com/v3/mail/send"")

   .arg(auth_header);

cmd.stdin_u8vec(payload.to_string().as_bytes());



let out = cmd.output();

```



The Rust function is then compiled into WebAssembly and can run in the WasmEdge like the [hello world](hello_world.md) chapter.








------"
"The following is a markdown document located at /develop/rust/dapr.md
------


---

sidebar_position: 8

---



# Dapr services



Second State launched a new [WebAssembly-based SDK for the Dapr API](https://github.com/second-state/dapr-sdk-wasi), which provides an easy way for Rust-based microservices in WasmEdge to interact with Dapr APIs and sidecar services.



The figure below shows a Dapr-enabled microservice running inside the WasmEdge sandbox.



![Dapr WASM rust API](dapr_wasm_rust_api.png)



## Prerequisites



Before we start, ensure [you have Rust and WasmEdge installed](setup.md).



You also need to install the following tools.



- [Dapr CLI installed](https://docs.dapr.io/getting-started/install-dapr-cli/)

- An [MySQL](https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/) or [MariaDB](https://mariadb.com/kb/en/getting-installing-and-upgrading-mariadb/) or [TiDB](https://docs.pingcap.com/tidb/dev/quick-start-with-tidb) database installed



## The template project explanation



The template application showcases how [Dapr](https://dapr.io/) and [WasmEdge](https://github.com/WasmEdge/) work together to support [lightweight WebAssembly-based microservices](https://github.com/second-state/microservice-rust-mysql) in a cloud-native environment. The microservices are all written in Rust and compiled into WebAssembly.



This application consists of three microservices and a standalone web page that enables users to interact with the microservices using an HTML+JavaScript UI. It is a very typical JAMstack setup. Each microservice is attached to a Dapr sidecar, which provides a suite of valuable services commonly required by cloud-native microservices.



![Dapr and WasmEdge](dapr-wasmedge.png)



The WasmEdge's Dapr SDK is used to access Dapr sidecars from the microservice apps. Specifically, the [grayscale](https://github.com/second-state/dapr-wasm/tree/main/image-api-grayscale) microservice takes an image from an HTTP POST, turns it into grayscale, and returns the result image data in the HTTP response.



- It uses Dapr to discover and invoke the [events](https://github.com/second-state/dapr-wasm/tree/main/events-service) microservice to record every successful user request.

- It also stores each user’s IP address and last timestamp data in its Dapr sidecar’s state database. That allows the service to rate limit users if needed.



The [classify](https://github.com/second-state/dapr-wasm/tree/main/image-api-classify) microservices takes an image from an HTTP POST, runs a Tensorflow model against it to classify the object on the image, and returns the result as a text label in the HTTP response. You can learn more about AI inference in Rust and WasmEdge [here](/category/ai-inference). It uses its own Dapr sidecar like the [grayscale](https://github.com/second-state/dapr-wasm/tree/main/image-api-grayscale) microservice.



The [events](https://github.com/second-state/dapr-wasm/tree/main/events-service) microservice takes JSON data from an HTTP POST and saves it to an external MySQL database for later analysis.



- It uses Dapr to make itself discoverable by name by other microservices that need to record events.

- It also uses its Dapr sidecar to store secrets such as MySQL database credentials.



Ok, enough concepts for the template project. Let's go ahead.



[Live Demo](http://dapr-demo.secondstate.co) | [Tutorial video](https://www.youtube.com/watch?v=3v37pAT9iK8)



## Build and deploy these microservices in Dapr



First, start the database and place the connection string in the [config/secrets.json](https://github.com/second-state/dapr-wasm/blob/main/config/secrets.json) file under `DB_URL:MYSQL`.



Next, start Dapr with the following commands.



```bash

dapr init

```



### The image grayscale microservice



Build.



```bash

cd image-api-grayscale

cargo build --target wasm32-wasi --release

wasmedgec ./target/wasm32-wasi/release/image-api-grayscale.wasm image-api-grayscale.wasm

```



Deploy.



```bash

dapr run --app-id image-api-grayscale \

        --app-protocol http \

        --app-port 9005 \

        --dapr-http-port 3503 \

        --components-path ../config \

        --log-level debug \

 wasmedge image-api-grayscale.wasm

```



### The image classification microservice



Build.



```bash

cd image-api-classify

cargo build --target wasm32-wasi --release

wasmedgec target/wasm32-wasi/release/wasmedge_hyper_server_tflite.wasm wasmedge_hyper_server_tflite.wasm

```



Deploy.



```bash

dapr run --app-id image-api-classify \

        --app-protocol http \

        --app-port 9006 \

        --dapr-http-port 3504 \

        --log-level debug \

        --components-path ../config \

        wasmedge-tensorflow-lite wasmedge_hyper_server_tflite.wasm

```



### The events recorder microservice



Build.



```bash

cd events-service

cargo build --target wasm32-wasi --release

wasmedgec target/wasm32-wasi/release/events_service.wasm events_service.wasm

```



Deploy.



```bash

dapr run --app-id events-service \

        --app-protocol http \

        --app-port 9007 \

        --dapr-http-port 3505 \

        --log-level debug \

        --components-path ../config \

        wasmedge events_service.wasm

```



## Test



To test the services, you can use the [static web page UI](http://dapr-demo.secondstate.co/) or `curl`.



Initialize the events database table.



```bash

$ curl http://localhost:9007/init

{""status"":true}



$ curl http://localhost:9007/events

[]

```



Use the grayscale microservice. The return data is base64 encoded grayscale image.



```bash

$ cd docs

$ curl http://localhost:9005/grayscale -X POST --data-binary '@food.jpg'

ABCDEFG ...

```



Use the image classification microservice.



```bash

$ cd docs

$ curl http://localhost:9006/classify -X POST --data-binary '@food.jpg'

hotdog is detected with 255/255 confidence

```



Query the events database again.



```bash

$ curl http://localhost:9007/events

[{""id"":1,""event_ts"":1665358852918,""op_type"":""grayscale"",""input_size"":68016},{""id"":2,""event_ts"":1665358853114,""op_type"":""classify"",""input_size"":68016}]

```



Next, you could use WasmEdge and WasmEdge's Dapr Rust API to create lightweight microservices with better security, faster performance, and smaller footprints.








------"
"The following is a markdown document located at /develop/rust/hello_world.md
------


---

sidebar_position: 2

---



# Hello world



Before we start, ensure [you have Rust and WasmEdge installed](setup.md).



## A simple main app



The Hello World example is a standalone Rust application that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md). The full source code for the Rust [main.rs](https://github.com/second-state/rust-examples/tree/main/hello) file is as follows. It echoes the command line arguments passed to this program at runtime.



```rust

fn main() {

  let s : &str = ""Hello WasmEdge!"";

  println!(""{}"", s);

}

```



Build the WASM bytecode:



```bash

cargo build --target wasm32-wasi --release

```



We will use the `wasmedge` command to run the program.



```bash

wasmedge target/wasm32-wasi/release/hello.wasm

```



## A simple function



### The code



The [add example](https://github.com/second-state/wasm-learning/tree/master/cli/add) is a Rust library function that can be executed by the [WasmEdge CLI](../../start/build-and-run/cli.md) in the reactor mode.



The full source code for the Rust [lib.rs](https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs) file is as follows. It provides a simple `add()` function.



```rust

#[no_mangle]

pub fn add(a: i32, b: i32) -> i32 {

  return a + b;

}

```



### Build the WASM bytecode



```bash

cargo build --target wasm32-wasi --release

```



### Run the application from command line



We will use `wasmedge` in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.



```bash

wasmedge --reactor target/wasm32-wasi/release/add.wasm add 2 2

```



## Pass parameters with complex data types



Of course, in most cases, you will not call functions using CLI arguments. Instead, you will probably need to use a [language SDK from WasmEdge] to call the function, pass call parameters, and receive return values. Below are some SDK examples for complex call parameters and return values.



- [Use wasmedge-bindgen in a Go host app](../../embed/go/bindgen.md)

- [Use direct memory passing in a Go host app](../../embed/go/passing_data.md)



## Improve the performance



If we don't have extra notes for AoT, all the WASM file will be executed in the interpreter mode, which is much slower. To achieve native Rust performance for those applications, you could use the `wasmedge compile` command to AOT compile the `wasm` program and then run it with the `wasmedge` command.



```bash

wasmedge compile hello.wasm hello_aot.wasm

wasmedge hello_aot.wasm second state

```



For the `--reactor` mode,



```bash

wasmedge compile add.wasm add_aot.wasm

wasmedge --reactor add_aot.wasm add 2 2

```








------"
"The following is a markdown document located at /develop/rust/os.md
------


---

sidebar_position: 3

---



# Access OS services



The WASI (WebAssembly Systems Interface) standard is designed to allow WebAssembly applications to access operating system services. The `wasm32-wasi` target in the Rust compiler supports WASI. This section will use [an example project](https://github.com/second-state/rust-examples/tree/main/wasi) to show how to use Rust standard APIs to access operating system services.



<!-- prettier-ignore -->

:::note

Before we start, ensure [you have Rust and WasmEdge installed](setup.md).

:::



## Random numbers



The WebAssembly VM is a pure software construct. It does not have a hardware entropy source for random numbers. That's why WASI defines a function for WebAssembly programs to call its host operating system to get a random seed. As a Rust developer, you only need to use the popular (de facto standard) `rand` and/or `getrandom` crates. With the `wasm32-wasi` compiler backend, these crates generate the correct WASI calls in the WebAssembly bytecode. The `Cargo.toml` dependencies are as follows.



```toml

[dependencies]

rand = ""0.7.3""

getrandom = ""0.1.14""

```



The Rust code to get random numbers from WebAssembly is this.



```rust

use rand::prelude::*;



pub fn get_random_i32() -> i32 {

  let x: i32 = random();

  return x;

}



pub fn get_random_bytes() -> Vec<u8> {

  let mut rng = thread_rng();

  let mut arr = [0u8; 128];

  rng.fill(&mut arr[..]);

  return arr.to_vec();

}

```



## Printing and debugging from Rust



The Rust `println!` marco works in WASI. The statements print to the `STDOUT` of the process that runs the WasmEdge.



```rust

pub fn echo(content: &str) -> String {

  println!(""Printed from wasi: {}"", content);

  return content.to_string();

}

```



## Arguments and environment variables



Passing CLI arguments to and accessing OS environment variables in a WasmEdge application is possible. They are just `env::args()` and `env::vars()` arrays in Rust.



```rust

use std::env;



pub fn print_env() {

  println!(""The env vars are as follows."");

  for (key, value) in env::vars() {

    println!(""{}: {}"", key, value);

  }



  println!(""The args are as follows."");

  for argument in env::args() {

    println!(""{}"", argument);

  }

}

```



## Reading and writing files



WASI allows your Rust functions to access the host computer's file system through the standard Rust `std::fs` API. In the Rust program, you operate on files through a relative path. The relative path's root is specified when you start the WasmEdge runtime.



```rust

use std::fs;

use std::fs::File;

use std::io::{Write, Read};



pub fn create_file(path: &str, content: &str) {

  let mut output = File::create(path).unwrap();

  output.write_all(content.as_bytes()).unwrap();

}



pub fn read_file(path: &str) -> String {

  let mut f = File::open(path).unwrap();

  let mut s = String::new();

  match f.read_to_string(&mut s) {

    Ok(_) => s,

    Err(e) => e.to_string(),

  }

}



pub fn del_file(path: &str) {

  fs::remove_file(path).expect(""Unable to delete"");

}

```



## A main() app



With a `main()` function, the Rust program can be compiled into a standalone WebAssembly program.



```rust

fn main() {

  println!(""Random number: {}"", get_random_i32());

  println!(""Random bytes: {:?}"", get_random_bytes());

  println!(""{}"", echo(""This is from a main function""));

  print_env();

  create_file(""tmp.txt"", ""This is in a file"");

  println!(""File content is {}"", read_file(""tmp.txt""));

  del_file(""tmp.txt"");

}

```



Use the command below to compile [the Rust project](https://github.com/second-state/rust-examples/blob/main/wasi/).



```bash

cargo build --target wasm32-wasi --release

```



To run it in `wasmedge`, do the following. The `--dir` option maps the current directory of the command shell to the file system's current directory inside the WebAssembly app.



```bash

$ wasmedge --dir .:. target/wasm32-wasi/release/wasi.wasm

Random number: -1157533356

Random bytes: [159, 159, 9, 119, 106, 172, 207, 82, 173, 145, 233, 214, 104, 35, 23, 53, 155, 12, 102, 231, 117, 67, 192, 215, 207, 202, 128, 198, 213, 41, 235, 57, 89, 223, 138, 70, 185, 137, 74, 162, 42, 20, 226, 177, 114, 170, 172, 39, 149, 99, 122, 68, 115, 205, 155, 202, 4, 48, 178, 224, 124, 42, 24, 56, 215, 90, 203, 150, 106, 128, 127, 201, 177, 187, 20, 195, 172, 56, 72, 28, 53, 163, 59, 36, 129, 160, 69, 203, 196, 72, 113, 61, 46, 249, 81, 134, 94, 134, 159, 51, 233, 247, 253, 116, 202, 210, 100, 75, 74, 95, 197, 44, 81, 87, 89, 115, 20, 226, 143, 139, 50, 60, 196, 59, 206, 105, 161, 226]

Printed from wasi: This is from a main function

This is from a main function

The env vars are as follows.

The args are as follows.

wasi.wasm

File content is This is in a file

```



## Functions



As [we have seen](hello_world.md#a-simple-function), you can create WebAssembly functions in a Rust `lib.rs` project. You can also use WASI functions in those functions. However, an important caveat is that, without a `main()` function, you will need to explicitly call a helper function to initialize the environment for WASI functions to work properly.



Add a helper crate in Cargo.toml in the Rust program so that the WASI initialization code can be applied to your exported public library functions.



```toml

[dependencies]

... ...

wasmedge-wasi-helper = ""=0.2.0""

```



In the Rust function, we need to call `_initialize()` before we access any arguments and environment variables or operate any files.



```rust

pub fn print_env() -> i32 {

  _initialize();

  ... ...

}



pub fn create_file(path: &str, content: &str) -> String {

  _initialize();

  ... ...

}



pub fn read_file(path: &str) -> String {

  _initialize();

  ... ...

}



pub fn del_file(path: &str) -> String {

  _initialize();

  ... ...

}

```








------"
"The following is a markdown document located at /develop/rust/setup.md
------


---

sidebar_position: 1

---



# Set up Rust toolchain



In the following chapters, we will show how to build and compile Rust programs into WASM bytecode and then run them in WasmEdge.



Before we start, let's set up the software we need.



## Install WasmEdge



Use the following command line to install WasmEdge on your machine. If you use Windows or other non-Unix-like platforms, please refer to the [WasmEdge installation](../../start/install.md#install).



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

```



## Install Rust



Use the following command line to install Rust on your machine. If you use Windows or other non-Unix-like platforms, please refer to the [Rust installation instruction](https://www.rust-lang.org/tools/install).



```bash

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

```



## Set up the Rust compiler's target



To build a WASM file running in server-side WebAssembly like WasmEdge, we need to add the `wasm32-wasi` target for the Rust compiler after Rust is installed.



```bash

rustup target add wasm32-wasi

```



## Special notes for networking apps



### Tokio support



WasmEdge supports async networking APIs provided by [Tokio](https://tokio.rs/) and related crates. If you have tokio in your `Cargo.toml`, you

need to add a few config flags to help the Rust compiler choose the correct feature branches in the library source code. Here is an example of `cargo build` command for compiling a tokio app to Wasm.



```bash

RUSTFLAGS=""--cfg wasmedge --cfg tokio_unstable"" cargo build --target wasm32-wasi --release

```



Alternatively, you could add these lines to the `.cargo/config.toml` file.



```toml

[build]

target = ""wasm32-wasi""

rustflags = [""--cfg"", ""wasmedge"", ""--cfg"", ""tokio_unstable""]

```



Once you have these lines in `.cargo/config.toml`, you can simply use the regular `cargo` command.



```bash

cargo build --target wasm32-wasi --release

```



### TLS on MacOS



The standard `cargo` toolchain can support the [Rust TLS](https://github.com/rustls/rustls) library on Linux. However,

on MacOS, you need a special version of the Clang tool, released from the official [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), in order to support TLS libraries.



> When you compile Rust TLS source code to Wasm on Linux, the result Wasm file is cross-platform and can run correctly on any platform with WasmEdge installed. This section is only applicable when you need to **compile** Rust TLS source code on MacOS.



[Download the latest wasi-sdk release](https://github.com/WebAssembly/wasi-sdk/releases) for your platform and

expand it into a directory. Point the `WASI_SDK_PATH` variable to this directory and export a `CC` variable for the default Clang.



```bash

export WASI_SDK_PATH /path/to/wasi-sdk-22.0

export CC=""${WASI_SDK_PATH}/bin/clang --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot""

```



That's it. Now you can use the `cargo` tools on MacOS to compile tokio libraries with `rust-tls` feature turned on.








------"
"The following is a markdown document located at /develop/rust/ssr.md
------


---

sidebar_position: 12

---



# Server-side rendering



Frontend web frameworks allow developers to create web apps in a high-level language and component model. The web app is built into a static website to be rendered in the browser. While many frontend web frameworks are based on JavaScript, such as React and Vue, Rust-based frameworks are also emerging as the Rust language gains traction among developers. Those web frameworks render the HTML DOM UI using the WebAssembly, compiled from Rust source code. They use [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) to tie the Rust to the HTML DOM. While these frameworks send `.wasm` files to the browser to render the UI on the client side, some provide the additional choice for [Server-side rendering](https://en.wikipedia.org/wiki/Server-side_scripting). That is to run the WebAssembly code, build the HTML DOM UI on the server, and stream the HTML content to the browser for faster performance and startup time on slow devices and networks.



<!-- prettier-ignore -->

:::note

If you are interested in JavaScript-based Jamstack and SSR frameworks, such as React, please [check out our JavaScript SSR chapter](../javascript/ssr.md).

:::



This article will explore how to render the web UI on the server using WasmEdge. We pick [Percy](https://github.com/chinedufn/percy) as our framework because it is relatively mature in SSR and [Hydration](<https://en.wikipedia.org/wiki/Hydration_(web_development)>). Percy already provides an [example](https://github.com/chinedufn/percy/tree/master/examples/isomorphic) for SSR. It's highly recommended to read it first to understand how it works. The default SSR setup with Percy utilizes a native Rust web server. The Rust code is compiled to machine native code for the server. However, we need a sandbox to host user applications on the server. While we could run native code inside a Linux container (Docker), a far more efficient (and safer) approach is to run the compiled code in a WebAssembly VM on the server, especially considering the rendering code is already compiled into WebAssembly.



Let's go through the steps to run a Percy SSR service in a WasmEdge server.



Assuming we are in the `examples/isomorphic` directory, make a new crate beside the existing `server`.



```bash

cargo new server-wasmedge

```



You'll receive a warning to let you put the new crate into the workspace, so insert below into `members` of `[workspace]`. The file is `../../Cargo.toml`.



```toml

""examples/isomorphic/server-wasmedge""

```



With the file open, put these two lines in the bottom:



```toml

[patch.crates-io]

wasm-bindgen = { git = ""https://github.com/KernelErr/wasm-bindgen.git"", branch = ""wasi-compat"" }

```



<!-- prettier-ignore -->

:::note

Why do we need a forked `wasm-bindgen`? That is because `wasm-bindgen` is the required glue between Rust and HTML in the browser. On the server, however, we need to build the Rust code to the `wasm32-wasi` target, which is incompatible with `wasm-bindgen`. Our forked `wasm-bindgen` has conditional configs that remove browser-specific code in the generated `.wasm` file for the `wasm32-wasi` target.

:::



Then replace the crate's `Cargo.toml` with the following content.



```toml

[package]

name = ""isomorphic-server-wasmedge""

version = ""0.1.0""

edition = ""2021""



# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html



[dependencies]

wasmedge_wasi_socket = ""0""

querystring = ""1.1.0""

parsed = { version = ""0.3"", features = [""http""] }

anyhow = ""1""

serde = { version = ""1.0"", features = [""derive""] }

isomorphic-app = { path = ""../app"" }

```



The `wasmedge_wasi_socket` crate is the socket API of WasmEdge. This project is under development. Next, copy the `index.html` file into the crate's root.



```bash

cp server/src/index.html server-wasmedge/src/

```



Then let's create some Rust code to start a web service in WasmEdge! The `main.rs` program listens to the request and sends the response via the stream.



```rust

use std::io::Write;

use wasmedge_wasi_socket::{Shutdown, TcpListener};



mod handler;

mod mime;

mod response;



fn main() {

    let server = TcpListener::bind(""127.0.0.1:3000"", false).unwrap();

    println!(""Server listening on 127.0.0.1:3000"");



    // Simple single-thread HTTP server

    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server

    loop {

        let (mut stream, addr) = server.accept(0).unwrap();

        println!(""Accepted connection from {}"", addr);

        match handler::handle_req(&mut stream, addr) {

            Ok((res, binary)) => {

                let res: String = res.into();

                let bytes = res.as_bytes();

                stream.write_all(bytes).unwrap();

                if let Some(binary) = binary {

                    stream.write_all(&binary).unwrap();

                }

            }

            Err(e) => {

                println!(""Error: {:?}"", e);

            }

        };

        stream.shutdown(Shutdown::Both).unwrap();

    }

}

```



The `handler.rs` parses the received data to the path and queries objects and returns the corresponding response.



```rust

use crate::response;

use anyhow::Result;

use parsed::http::Response;

use std::io::Read;

use wasmedge_wasi_socket::{SocketAddr, TcpStream};



pub fn handle_req(stream: &mut TcpStream, addr: SocketAddr) -> Result<(Response, Option<Vec<u8>>)> {

    let mut buf = [0u8; 1024];

    let mut received_data: Vec<u8> = Vec::new();



    loop {

        let n = stream.read(&mut buf)?;

        received_data.extend_from_slice(&buf[..n]);

        if n < 1024 {

            break;

        }

    }



    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {

        Ok(s) => s.into(),

        Err(_) => return Ok((response::bad_request(), None)),

    };



    let req = match parsed::http::parse_http_request(&mut bs) {

        Some(req) => req,

        None => return Ok((response::bad_request(), None)),

    };



    println!(""{:?} request: {:?} {:?}"", addr, req.method, req.path);



    let mut path_split = req.path.split(""?"");

    let path = path_split.next().unwrap_or(""/"");

    let query_str = path_split.next().unwrap_or("""");

    let query = querystring::querify(&query_str);

    let mut init_count: Option<u32> = None;

    for (k, v) in query {

        if k.eq(""init"") {

            match v.parse::<u32>() {

                Ok(v) => init_count = Some(v),

                Err(_) => return Ok((response::bad_request(), None)),

            }

        }

    }



    let (res, binary) = if path.starts_with(""/static"") {

        response::file(&path)

    } else {

        // render page

        response::ssr(&path, init_count)

    }

    .unwrap_or_else(|_| response::internal_error());



    Ok((res, binary))

}

```



The `response.rs` program packs the response object for static assets and server-rendered content. For the latter, you could see that SSR happens at `app.render().to_string()`, the result string is put into HTML by replacing the placeholder text.



```rust

use crate::mime::MimeType;

use anyhow::Result;

use parsed::http::{Header, Response};

use std::fs::{read};

use std::path::Path;

use isomorphic_app::App;



const HTML_PLACEHOLDER: &str = ""#HTML_INSERTED_HERE_BY_SERVER#"";

const STATE_PLACEHOLDER: &str = ""#INITIAL_STATE_JSON#"";



pub fn ssr(path: &str, init: Option<u32>) -> Result<(Response, Option<Vec<u8>>)> {

    let html = format!(""{}"", include_str!(""./index.html""));



    let app = App::new(init.unwrap_or(1001), path.to_string());

    let state = app.store.borrow();



    let html = html.replace(HTML_PLACEHOLDER, &app.render().to_string());

    let html = html.replace(STATE_PLACEHOLDER, &state.to_json());



    Ok((Response {

        protocol: ""HTTP/1.0"".to_string(),

        code: 200,

        message: ""OK"".to_string(),

        headers: vec![

            Header {

                name: ""content-type"".to_string(),

                value: MimeType::from_ext(""html"").get(),

            },

            Header {

                name: ""content-length"".to_string(),

                value: html.len().to_string(),

            },

        ],

        content: html.into_bytes(),

    }, None))

}



/// Get raw file content

pub fn file(path: &str) -> Result<(Response, Option<Vec<u8>>)> {

    let path = Path::new(&path);

    if path.exists() {

        let content_type: MimeType = match path.extension() {

            Some(ext) => MimeType::from_ext(ext.to_str().get_or_insert("""")),

            None => MimeType::from_ext(""""),

        };

        let content = read(path)?;



        Ok((Response {

            protocol: ""HTTP/1.0"".to_string(),

            code: 200,

            message: ""OK"".to_string(),

            headers: vec![

                Header {

                    name: ""content-type"".to_string(),

                    value: content_type.get(),

                },

                Header {

                    name: ""content-length"".to_string(),

                    value: content.len().to_string(),

                },

            ],

            content: vec![],

        }, Some(content)))

    } else {

        Ok((Response {

            protocol: ""HTTP/1.0"".to_string(),

            code: 404,

            message: ""Not Found"".to_string(),

            headers: vec![],

            content: vec![],

        }, None))

    }

}



/// Bad Request

pub fn bad_request() -> Response {

    Response {

        protocol: ""HTTP/1.0"".to_string(),

        code: 400,

        message: ""Bad Request"".to_string(),

        headers: vec![],

        content: vec![],

    }

}



/// Internal Server Error

pub fn internal_error() -> (Response, Option<Vec<u8>>) {

    (Response {

        protocol: ""HTTP/1.0"".to_owned(),

        code: 500,

        message: ""Internal Server Error"".to_owned(),

        headers: vec![],

        content: vec![],

    }, None)

}

```



The `mime.rs` program is a map for assets' extension names and the Mime type.



```rust

pub struct MimeType {

    pub r#type: String,

}



impl MimeType {

    pub fn new(r#type: &str) -> Self {

        MimeType {

            r#type: r#type.to_string(),

        }

    }



    pub fn from_ext(ext: &str) -> Self {

        match ext {

            ""html"" => MimeType::new(""text/html""),

            ""css"" => MimeType::new(""text/css""),

            ""map"" => MimeType::new(""application/json""),

            ""js"" => MimeType::new(""application/javascript""),

            ""json"" => MimeType::new(""application/json""),

            ""svg"" => MimeType::new(""image/svg+xml""),

            ""wasm"" => MimeType::new(""application/wasm""),

            _ => MimeType::new(""text/plain""),

        }

    }



    pub fn get(self) -> String {

        self.r#type

    }

}

```



That's it! Now let's build and run the web application. If you have tested the original example, you have already built the client WebAssembly.



```bash

cd client

./build-wasm.sh

```



Next, build and run the server.



```bash

cd ../server-wasmedge

cargo build --target wasm32-wasi

OUTPUT_CSS=""$(pwd)/../client/build/app.css"" wasmedge --dir /static:../client/build ../../../target/wasm32-wasi/debug/isomorphic-server-wasmedge.wasm

```



Navigate to `http://127.0.0.1:3000`, and you will see the web application in action.



Furthermore, you can place all the steps into a shell script `../start-wasmedge.sh`.



```bash

#!/bin/bash



cd $(dirname $0)



cd ./client



./build-wasm.sh



cd ../server-wasmedge



OUTPUT_CSS=""$(pwd)/../client/build/app.css"" cargo run -p isomorphic-server-wasmedge

```



Add the following to the `.cargo/config.toml` file.



```toml

[build]

target = ""wasm32-wasi""



[target.wasm32-wasi]

runner = ""wasmedge --dir /static:../client/build""

```



After that, a single CLI command `./start-wasmedge.sh` would perform all the tasks to build and run the web application!



We forked the Percy repository and made a ready-to-build [server-wasmedge](https://github.com/second-state/percy/tree/master/examples/isomorphic/server-wasmedge) example project for you. Happy coding!








------"
"The following is a markdown document located at /develop/rust/wasicrypto.md
------


---

sidebar_position: 9

---



# Crypto for WASI



While optimizing compilers could allow efficient implementation of cryptographic features in WebAssembly, there are several occasions where a host implementation is more desirable. [WASI-crypto](https://github.com/WebAssembly/wasi-crypto/blob/main/docs/HighLevelGoals.md) aims to fill those gaps by defining a standard interface as a set of APIs. Currently not support Android.



Make sure [you have Rust and WasmEdge installed](setup.md) and [the WASI-crypto plugin](../../start/install.md#wasi-crypto-plug-in) installed.



## Write WebAssembly Using WASI-Crypto



### _(Optional)_ Rust Installation



For importing WASI-Crypto in rust, you should use the [wasi-crypto binding](https://github.com/WebAssembly/wasi-crypto/tree/main/implementations/bindings/rust) in your cargo.toml



```toml

[dependencies]

wasi-crypto = ""0.1.5""

```



### High-Level Operations



#### Hash Function



| Identifier    | Algorithm                                    |

| ------------- | -------------------------------------------- |

| `SHA-256`     | SHA-256 hash function                        |

| `SHA-512`     | SHA-512 hash function                        |

| `SHA-512/256` | SHA-512/256 hash function with a specific IV |



```rust

// hash ""test"" by SHA-256

let hash : Vec<u8> = Hash::hash(""SHA-256"", b""test"", 32, None)?;

assert_eq!(hash.len(), 32);

```



#### Message Authentications function



| Identifier     | Algorithm                                   |

| -------------- | ------------------------------------------- |

| `HMAC/SHA-256` | RFC2104 MAC using the SHA-256 hash function |

| `HMAC/SHA-512` | RFC2104 MAC using the SHA-512 hash function |



```rust

// generate key

let key = AuthKey::generate(""HMAC/SHA-512"")?;

// generate tag

let tag = Auth::auth(""test"", &key)?;

// verify

Auth::auth_verify(""test"", &key, tag)?;

```



#### Key Driven function



| Identifier | Algorithm |

| --- | --- |

| `HKDF-EXTRACT/SHA-256` | RFC5869 `EXTRACT` function using the SHA-256 hash function |

| `HKDF-EXTRACT/SHA-512` | RFC5869 `EXTRACT` function using the SHA-512 hash function |

| `HKDF-EXPAND/SHA-256` | RFC5869 `EXPAND` function using the SHA-256 hash function |

| `HKDF-EXPAND/SHA-512` | RFC5869 `EXPAND` function using the SHA-512 hash function |



Example:



```rust

let key = HkdfKey::generate(""HKDF-EXTRACT/SHA-512"")?;

let prk = Hkdf::new(""HKDF-EXPAND/SHA-512"", &key, Some(b""salt""))?;

let derived_key = prk.expand(""info"", 100)?;

assert_eq!(derived_key.len(), 100);

```



#### Signatures Operation



| Identifier | Algorithm |

| --- | --- |

| `ECDSA_P256_SHA256` | ECDSA over the NIST p256 curve with the SHA-256 hash function |

| `ECDSA_K256_SHA256` | ECDSA over the secp256k1 curve with the SHA-256 hash function |

| `Ed25519` | Edwards Curve signatures over Edwards25519 (pure EdDSA) as specified in RFC8032 |

| `RSA_PKCS1_2048_SHA256` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-256 hash function |

| `RSA_PKCS1_2048_SHA384` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-384 hash function |

| `RSA_PKCS1_2048_SHA512` | RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-512 hash function |

| `RSA_PKCS1_3072_SHA384` | RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-384 hash function |

| `RSA_PKCS1_3072_SHA512` | RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-512 hash function |

| `RSA_PKCS1_4096_SHA512` | RSA signatures with a 4096 bit modulus, PKCS1 padding and the SHA-512 hash function |

| `RSA_PSS_2048_SHA256` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-256 hash function |

| `RSA_PSS_2048_SHA384` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function |

| `RSA_PSS_2048_SHA512` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-512 hash function |

| `RSA_PSS_3072_SHA384` | RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function |

| `RSA_PSS_3072_SHA512` | RSA signatures with a 3072 bit modulus, PSS padding and the SHA-512 hash function |

| `RSA_PSS_4096_SHA512` | RSA signatures with a 4096 bit modulus, PSS padding and the SHA-512 hash function |



Example:



```rust

let pk = SignaturePublicKey::from_raw(""Ed25519"", &[0; 32])?;



let kp = SignatureKeyPair::generate(""Ed25519"")?;

let signature = kp.sign(""hello"")?;



kp.publickey()?.signature_verify(""hello"", &signature)?;

```








------"
"The following is a markdown document located at /develop/overview.md
------


---

sidebar_position: 1

displayed_sidebar: developSidebar

---



# Develop WASM Apps



A fundamental value proposition of WebAssembly is that it supports multiple programming languages. WebAssembly is a ""managed runtime"" for many programming languages including [C/C++](/category/develop-wasm-apps-in-cc), [Rust](/category/develop-wasm-apps-in-rust), [Go](/category/develop-wasm-apps-in-go), and even [JavaScript](/category/develop-wasm-apps-in-javascript) and [Python](/category/develop-wasm-apps-in-python).



- For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).

- For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime instead of Docker + guest OS + native interpreter.



This chapter will discuss how to compile sources into WebAssembly in different languages and run them in WasmEdge.



- Develop WebAssembly apps from your programming languages from [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.

- [Deploy WASM Apps with the existing container toolings](/category/deploy-wasmedge-apps-in-kubernetes)



Besides this, we also have two more guides for [Embedding WASM Functions](../embed/overview.md) and [Contributing](../contribute/overview.md) to WasmEdge.








------"
"```json:/embed/c/reference/_category_.json


{

  ""label"": ""API Reference"",

  ""position"": 6,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will discuss the WasmEdge C API Reference.""

  }

}








```"
"The following is a markdown document located at /embed/c/reference/0.10.x.md
------


---

sidebar_position: 9

---



# C API 0.10.1 Documentation



[WasmEdge C API](https://github.com/WasmEdge/WasmEdge/blob/0.10.1/include/api/wasmedge/wasmedge.h) denotes an interface to access the WasmEdge runtime at version `0.10.1`. The following are the guides to working with the C APIs of WasmEdge.



**Developers can refer to [here to upgrade to 0.11.0](upgrade_to_0.11.0.md).**



## Table of Contents



- [WasmEdge Installation](#wasmedge-installation)

  - [Download And Install](#download-and-install)

  - [Compile Sources](#compile-sources)

- [WasmEdge Basics](#wasmedge-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Strings](#strings)

  - [Results](#results)

  - [Contexts](#contexts)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

  - [Tools driver](#tools-driver)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Context](#wasm-execution-example-with-vm-context)

  - [VM Creations](#vm-creations)

  - [Preregistrations](#preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## WasmEdge Installation



### Download And Install



The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `wget` as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.10.1

```



For more details, please refer to the [Installation Guide](../../../start/install.md#install) for the WasmEdge installation.



### Compile Sources



After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.



1. Prepare the test C file (and assumed saved as `test.c`):



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

     return 0;

   }

   ```



2. Compile the file with `gcc` or `clang`.



   ```bash

   gcc test.c -lwasmedge_c

   ```



3. Run and get the expected output.



   ```bash

   $ ./a.out

   WasmEdge version: 0.10.1

   ```



## WasmEdge Basics



In this part, we will introduce the utilities and concepts of WasmEdge shared library.



### Version



The `Version` related APIs provide developers to check for the WasmEdge shared library version.



```c

#include <wasmedge/wasmedge.h>

printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

printf(""WasmEdge version major: %u\n"", WasmEdge_VersionGetMajor());

printf(""WasmEdge version minor: %u\n"", WasmEdge_VersionGetMinor());

printf(""WasmEdge version patch: %u\n"", WasmEdge_VersionGetPatch());

```



### Logging Settings



The `WasmEdge_LogSetErrorLevel()` and `WasmEdge_LogSetDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



### Value Types



In WasmEdge, developers should convert the values to `WasmEdge_Value` objects through APIs for matching to the WASM value types.



1. Number types: `i32`, `i64`, `f32`, `f64`, and `v128` for the `SIMD` proposal



   ```c

   WasmEdge_Value Val;

   Val = WasmEdge_ValueGenI32(123456);

   printf(""%d\n"", WasmEdge_ValueGetI32(Val));

   /* Will print ""123456"" */

   Val = WasmEdge_ValueGenI64(1234567890123LL);

   printf(""%ld\n"", WasmEdge_ValueGetI64(Val));

   /* Will print ""1234567890123"" */

   Val = WasmEdge_ValueGenF32(123.456f);

   printf(""%f\n"", WasmEdge_ValueGetF32(Val));

   /* Will print ""123.456001"" */

   Val = WasmEdge_ValueGenF64(123456.123456789);

   printf(""%.10f\n"", WasmEdge_ValueGetF64(Val));

   /* Will print ""123456.1234567890"" */

   ```



2. Reference types: `funcref` and `externref` for the `Reference-Types` proposal



   ```c

   WasmEdge_Value Val;

   void *Ptr;

   bool IsNull;

   uint32_t Num = 10;

   /* Generate a externref to NULL. */

   Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);

   IsNull = WasmEdge_ValueIsNullRef(Val);

   /* The `IsNull` will be `TRUE`. */

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `NULL`. */



   /* Get the function instance by creation or from module instance. */

   const WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   /* Generate a funcref with the given function instance context. */

   Val = WasmEdge_ValueGenFuncRef(FuncCxt);

   const WasmEdge_FunctionInstanceContext *GotFuncCxt = WasmEdge_ValueGetFuncRef(Val);

   /* The `GotFuncCxt` will be the same as `FuncCxt`. */



   /* Generate a externref to `Num`. */

   Val = WasmEdge_ValueGenExternRef(&Num);

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `&Num`. */

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""10"" */

   Num += 55;

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""65"" */

   ```



### Strings



The `WasmEdge_String` object is for the instance names when invoking a WASM function or finding the contexts of instances.



1. Create a `WasmEdge_String` from a C string (`const char *` with NULL termination) or a buffer with length.



   The content of the C string or buffer will be copied into the `WasmEdge_String` object.



   ```c

   char Buf[4] = {50, 55, 60, 65};

   WasmEdge_String Str1 = WasmEdge_StringCreateByCString(""test"");

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   /* The objects should be deleted by `WasmEdge_StringDelete()`. */

   WasmEdge_StringDelete(Str1);

   WasmEdge_StringDelete(Str2);

   ```



2. Wrap a `WasmEdge_String` to a buffer with length.



   The content will not be copied, and the caller should guarantee the life cycle of the input buffer.



   ```c

   const char CStr[] = ""test"";

   WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);

   /* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */

   ```



3. String comparison



   ```c

   const char CStr[] = ""abcd"";

   char Buf[4] = {0x61, 0x62, 0x63, 0x64};

   WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);

   /* The `IsEq` will be `TRUE`. */

   WasmEdge_StringDelete(Str2);

   ```



4. Convert to C string



   ```c

   char Buf[256];

   WasmEdge_String Str = WasmEdge_StringCreateByCString(""test_wasmedge_string"");

   uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));

   /* StrLength will be 20 */

   printf(""String: %s\n"", Buf);

   /* Will print ""test_wasmedge_string"". */

   ```



### Results



The `WasmEdge_Result` object specifies the execution status. APIs about WASM execution will return the `WasmEdge_Result` to denote the status.



```c

WasmEdge_Result Res = WasmEdge_Result_Success;

bool IsSucceeded = WasmEdge_ResultOK(Res);

/* The `IsSucceeded` will be `TRUE`. */

uint32_t Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 0. */

const char *Msg = WasmEdge_ResultGetMessage(Res);

/* The `Msg` will be ""success"". */

```



### Contexts



The objects, such as `VM`, `Store`, and `Function`, are composed of `Context`s. All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.



```c

/* Create the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Delete the configure context. */

WasmEdge_ConfigureDelete(ConfCxt);

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `WasmEdge_Limit` struct is defined in the header:



   ```c

   /// Struct of WASM limit.

   typedef struct WasmEdge_Limit {

     /// Boolean to describe has max value or not.

     bool HasMax;

     /// Boolean to describe is shared memory or not.

     bool Shared;

     /// Minimum value.

     uint32_t Min;

     /// Maximum value. Will be ignored if the `HasMax` is false.

     uint32_t Max;

   } WasmEdge_Limit;

   ```



   Developers can initialize the struct by assigning it's value, and the `Max` value is needed to be larger or equal to the `Min` value. The API `WasmEdge_LimitIsEqual()` is provided to compare with 2 `WasmEdge_Limit` structs.



2. Function type context



   The `Function Type` context is used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `Function Type` context APIs to get the parameter or return value types information.



   ```c

   enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };

   enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };

   WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



   enum WasmEdge_ValType Buf[16];

   uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);

   /* `ParamLen` will be 2. */

   uint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);

   /* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as `ParamList`. */

   uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);

   /* `ReturnLen` will be 1. */

   uint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);

   /* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`. */



   WasmEdge_FunctionTypeDelete(FuncTypeCxt);

   ```



3. Table type context



   The `Table Type` context is used for `Table` instance creation or getting information from `Table` instances.



   ```c

   WasmEdge_Limit TabLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);



   enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `GotRefType` will be WasmEdge_RefType_ExternRef. */

   WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);

   /* `GotTabLim` will be the same value as `TabLim`. */



   WasmEdge_TableTypeDelete(TabTypeCxt);

   ```



4. Memory type context



   The `Memory Type` context is used for `Memory` instance creation or getting information from `Memory` instances.



   ```c

   WasmEdge_Limit MemLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);



   WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);

   /* `GotMemLim` will be the same value as `MemLim`. */



   WasmEdge_MemoryTypeDelete(MemTypeCxt)

   ```



5. Global type context



   The `Global Type` context is used for `Global` instance creation or getting information from `Global` instances.



   ```c

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);



   WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `GotValType` will be WasmEdge_ValType_F64. */

   WasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `GotValMut` will be WasmEdge_Mutability_Var. */



   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   ```



6. Import type context



   The `Import Type` context is used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `Import Type` context. The details about querying `Import Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */

   const WasmEdge_ImportTypeContext *ImpType = ...;

   /* Assume that `ImpType` is queried from the `ASTCxt` for the import. */



   enum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,

    * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);

   WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);

   /* The `ModName` and `ExtName` should not be destroyed and the string buffers are binded into the `ASTCxt`. */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */

   const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */

   const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */

   ```



7. Export type context



   The `Export Type` context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `Export Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */

   const WasmEdge_ExportTypeContext *ExpType = ...;

   /* Assume that `ExpType` is queried from the `ASTCxt` for the export. */



   enum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,

    * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);

   /* The `ExtName` should not be destroyed and the string buffer is binded into the `ASTCxt`. */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */

   const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */

   const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `WasmEdge_Async` object. Developers own the object and should call the `WasmEdge_AsyncDelete()` API to destroy it.



1. Wait for the asynchronous execution



   Developers can wait the execution until finished:



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution. */

   WasmEdge_AsyncWait(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   Or developers can wait for a time limit. If the time limit exceeded, developers can choose to cancel the execution. For the interruptible execution in AOT mode, developers should set `TRUE` through the `WasmEdge_ConfigureCompilerSetInterruptible()` API into the configure context for the AOT compiler.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution for 1 second. */

   bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);

   if (IsEnd) {

     /* The execution finished. Developers can get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);

   } else {

     /* The time limit exceeded. Developers can keep waiting or cancel the execution. */

     WasmEdge_AsyncCancel(Async);

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);

     /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */

   }

   WasmEdge_AsyncDelete(Async);

   ```



2. Get the execution result of the asynchronous execution



   Developers can use the `WasmEdge_AsyncGetReturnsLength()` API to get the return value list length. This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return `0`. This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the `WasmEdge_AsyncGet()` API to get the result.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return value list length. */

   uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   The `WasmEdge_AsyncGet()` API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return values. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_Value Buf[BUF_LEN];

   WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);

   WasmEdge_AsyncDelete(Async);

   ```



### Configurations



The configuration context, `WasmEdge_ConfigureContext`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` context to create other runtime contexts.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` context.



   ```c

   enum WasmEdge_Proposal {

     WasmEdge_Proposal_ImportExportMutGlobals = 0,

     WasmEdge_Proposal_NonTrapFloatToIntConversions,

     WasmEdge_Proposal_SignExtensionOperators,

     WasmEdge_Proposal_MultiValue,

     WasmEdge_Proposal_BulkMemoryOperations,

     WasmEdge_Proposal_ReferenceTypes,

     WasmEdge_Proposal_SIMD,

     WasmEdge_Proposal_TailCall,

     WasmEdge_Proposal_MultiMemories,

     WasmEdge_Proposal_Annotations,

     WasmEdge_Proposal_Memory64,

     WasmEdge_Proposal_ExceptionHandling,

     WasmEdge_Proposal_ExtendedConst,

     WasmEdge_Proposal_Threads,

     WasmEdge_Proposal_FunctionReferences

   };

   ```



   Developers can add or remove the proposals into the `Configure` context.



   ```c

   /*

    * By default, the following proposals have turned on initially:

    * * Import/Export of mutable globals

    * * Non-trapping float-to-int conversions

    * * Sign-extension operators

    * * Multi-value returns

    * * Bulk memory operations

    * * Reference types

    * * Fixed-width SIMD

    *

    * For the current WasmEdge version, the following proposals are supported

    * (turned of by default) additionally:

    * * Tail-call

    * * Multiple memories

    * * Extended-const

    * * Threads

    */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);

   WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);

   bool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);

   /* The `IsBulkMem` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` or `wasmedge_process` supports and only effective in `VM` contexts.



   ```c

   enum WasmEdge_HostRegistration {

     WasmEdge_HostRegistration_Wasi = 0,

     WasmEdge_HostRegistration_WasmEdge_Process

   };

   ```



   The details will be introduced in the [preregistrations of VM context](#preregistrations).



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `FALSE`. */

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* By default, the maximum memory page size is 65536. */

   WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);

   /* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */

   PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* The `PageSize` will be 1024. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



4. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```c

   enum WasmEdge_CompilerOptimizationLevel {

     // Disable as many optimizations as possible.

     WasmEdge_CompilerOptimizationLevel_O0 = 0,

     // Optimize quickly without destroying debuggability.

     WasmEdge_CompilerOptimizationLevel_O1,

     // Optimize for fast execution as much as possible without triggering

     // significant incremental compile time or code size growth.

     WasmEdge_CompilerOptimizationLevel_O2,

     // Optimize for fast execution as much as possible.

     WasmEdge_CompilerOptimizationLevel_O3,

     // Optimize for small code size as much as possible without triggering

     // significant incremental compile time or execution time slowdowns.

     WasmEdge_CompilerOptimizationLevel_Os,

     // Optimize for small code size as much as possible.

     WasmEdge_CompilerOptimizationLevel_Oz

   };



   enum WasmEdge_CompilerOutputFormat {

     // Native dynamic library format.

     WasmEdge_CompilerOutputFormat_Native = 0,

     // WebAssembly with AOT compiled codes in custom section.

     WasmEdge_CompilerOutputFormat_Wasm

   };

   ```



   These configurations are only effective in `Compiler` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the optimization level is O3. */

   WasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);

   /* By default, the output format is universal WASM. */

   WasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);

   /* By default, the dump IR is `FALSE`. */

   WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);

   /* By default, the generic binary is `FALSE`. */

   WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);

   /* By default, the interruptible is `FALSE`.

   /* Set this option to `TRUE` to support the interruptible execution in AOT mode. */

   WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



5. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the instruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */

   WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);

   /* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */

   WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);

   /* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */

   WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



### Statistics



The statistics context, `WasmEdge_StatisticsContext`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` context from the `VM` context, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);

   double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` context. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   uint64_t CostTable[16] = {

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0

   };

   /* Developers can set the costs of each instruction. The value not covered will be 0. */

   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



### Tools Driver



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API. The API arguments are the same as the command line arguments of the CLI tools.



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge AOT compiler. */

  return WasmEdge_Driver_Compiler(argc, argv);

}

```



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge runtime tool. */

  return WasmEdge_Driver_Tool(argc, argv);

}

```



## WasmEdge VM



In this partition, we will introduce the functions of `WasmEdge_VMContext` object and show examples of executing WASM functions.



### WASM Execution Example With VM Context



The following shows the example of running the WASM for getting the Fibonacci. This example uses the binary format of [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat), and developers can convert it into the WASM file by the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Run the WASM function from file. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, ""fibonacci.wasm"", FuncName, Params, 1, Returns, 1);

     /*

      * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.

      */



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 8

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need the WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to replace the

      * instantiated one. In this case, the old module will be cleared, but the registered

      * modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 89

   ```



   The following graph explains the status of the `VM` context.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or module instances in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation API accepts the `Configure` context and the `Store` context. If developers only need the default settings, just pass `NULL` to the creation API. The details of the `Store` context will be introduced in [Store](#store).



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);

/* The caller should guarantee the life cycle if the store context. */

WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);

/* The VM context already contains the statistics context and can be retrieved by this API. */

/*

 * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs

 * should __NOT__ be destroyed and owned by the VM contexts.

 */

WasmEdge_VMDelete(VMCxt);

WasmEdge_StoreDelete(StoreCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Preregistrations



WasmEdge provides the following built-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` context.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /* The following API can retrieve the pre-registration module instances from the VM context. */

   /* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */

   WasmEdge_ModuleInstanceContext *WasiModule =

     WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);

   /* Initialize the WASI. */

   WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WASI module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. [WasmEdge_Process](https://crates.io/crates/wasmedge_process_interface)



   This pre-registration is for the process interface for WasmEdge on `Rust` sources. After turning on this pre-registration, the VM will support the `wasmedge_process` plugin.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /* The following API can retrieve the pre-registration module instances from the VM context. */

   /* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */

   WasmEdge_ModuleInstanceContext *ProcModule =

     WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);

   /* Initialize the WasmEdge_Process. */

   WasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */ );

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WasmEdge_Process module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



3. [WASI-NN proposal](https://github.com/WebAssembly/wasi-nn) (`0.10.1` or upper only)



   Developers can turn on the WASI-NN proposal support for VM in the `Configure` context.



   > Note: Please check that the [dependencies and prerequisites](../../../start/install.md#wasi-nn-plug-in-with-openvino-backend) are satisfied.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiNN);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /* The following API can retrieve the pre-registration module instances from the VM context. */

   /* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */

   WasmEdge_ModuleInstanceContext *NNModule =

     WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiNN);

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WASI-NN module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



4. [WASI-Crypto proposal](https://github.com/WebAssembly/wasi-crypto) (`0.10.1` or upper only)



   Developers can turn on the WASI-Crypto proposal support for VM in the `Configure` context.



   > Note: Please check that the [dependencies and prerequisites](../../../start/install.md#wasi-crypto-plug-in) are satisfied.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* The WASI-Crypto related configures are suggested to turn on together. */

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /* The following API can retrieve the pre-registration module instances from the VM context. */

   /* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */

   WasmEdge_ModuleInstanceContext *CryptoCommonModule =

     WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WASI-Crypto module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, the host functions are composed into host modules as `WasmEdge_ModuleInstanceContext` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` context.



```c

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

WasmEdge_ModuleInstanceContext *WasiModule =

  WasmEdge_ModuleInstanceCreateWASI( /* ... ignored ... */ );

/* You can also create and register the WASI host modules by this API. */

WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);

/* The result status should be checked. */



/* ... */



WasmEdge_ModuleInstanceDelete(WasiModule);

/* The created module instances should be deleted by the developers when the VM deallocation. */

WasmEdge_VMDelete(VMCxt);

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

   /*

    * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,

    * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.

    */

   /*

    * The result status should be checked.

    * The error will occur if the WASM module instantiation failed or the module name conflicts.

    */

   WasmEdge_StringDelete(ModName);

   WasmEdge_VMDelete(VMCxt);

   ```



2. Execute the functions in registered WASM modules



   Assume that the C file `test.c` is as follows:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };

     WasmEdge_Value Returns[1];

     /* Names. */

     WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Register the WASM module into VM. */

     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

     /*

     * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,

     * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.

     */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

     * The function ""fib"" in the ""fibonacci.wasm"" was exported with the module name ""mod"".

     * As the same as host functions, other modules can import the function `""mod"" ""fib""`.

     */



     /*

     * Execute WASM functions in registered modules.

     * Unlike the execution of functions, the registered functions can be invoked without

     * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.

     * Developers can also invoke the host functions directly with this API.

     */

     Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     WasmEdge_StringDelete(ModName);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 10946

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, ""fibonacci.wasm"", FuncName, Params, 1);

     /*

      * Developers can run the WASM binary from buffer with the `WasmEdge_VMAsyncRunWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMAsyncRunWasmFromASTModule()` API.

      */



     /* Wait for the execution. */

     WasmEdge_AsyncWait(Async);

     /*

      * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or `WasmEdge_AsyncGet()` APIs

      * to wait for the asynchronous execution. These APIs will wait until the execution finished.

      */



     /* Check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */



     /* Get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to replace the

      * instantiated one. In this case, the old module will be cleared, but the registered

      * modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);

     /*

      * Developers can execute functions repeatedly after instantiation.

      * For invoking the registered functions, you can use the `WasmEdge_VMAsyncExecuteRegistered()` API.

      */



     /* Wait and check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */



     /* Get the result. */

     Res = WasmEdge_AsyncGet(Async, Returns, Arity);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

   }

   ```



   Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` context supplies the APIs to retrieve the instances.



1. Store



   If the `VM` context is created without assigning a `Store` context, the `VM` context will allocate and own a `Store` context.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */

   WasmEdge_VMDelete(VMCxt);

   ```



   Developers can also create the `VM` context with a `Store` context. In this case, developers should guarantee the life cycle of the `Store` context. Please refer to the [Store Contexts](#store) for the details about the `Store` context APIs.



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

   WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);

   /* The `StoreCxt` and the `StoreCxtMock` are the same. */

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `WasmEdge_VMExecute()` API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);



     WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     WasmEdge_VMValidate(VMCxt);

     WasmEdge_VMInstantiate(VMCxt);



     /* List the exported functions. */

     /* Get the number of exported functions. */

     uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);

     /* Create the name buffers and the function type buffers. */

     const uint32_t BUF_LEN = 256;

     WasmEdge_String FuncNames[BUF_LEN];

     WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];

     /*

      * Get the export function list.

      * If the function list length is larger than the buffer length, the overflowed data will be discarded.

      * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.

      */

     uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);



     for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

       char Buf[BUF_LEN];

       uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

       printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

       /*

        * The function names should be __NOT__ destroyed.

        * The returned function type contexts should __NOT__ be destroyed.

        */

     }

     return 0;

   }

   ```



   Then you can compile and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get exported function string length: 3, name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` context from the `VM` context and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` context provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   const WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);

   /*

    * Developers can get the function types of functions in the registered modules

    * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.

    * If the function is not found, these APIs will return `NULL`.

    * The returned function type contexts should __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` context. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `WasmEdge_VMGetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);

   /*

    * If there's no WASM module instantiated, this API will return `NULL`.

    * The returned module instance context should __NOT__ be destroyed.

    */

   ```



5. Get the components



   The `VM` context is composed by the `Loader`, `Validator`, and `Executor` contexts. For the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the `VM` context. The get contexts are owned by the `VM` context, and developers should not call their delete functions.



   ```c

   WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */

   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` context](#wasmedge-vm), developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` contexts. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */

  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

  /* Create the store context. The store context is the object to link the modules for imports and exports. */

  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Result. */

  WasmEdge_Result Res;



  /* Create the loader context. The configure context can be NULL. */

  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

  /* Create the validator context. The configure context can be NULL. */

  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

  /* Create the executor context. The configure context and the statistics context can be NULL. */

  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);



  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */

  WasmEdge_ASTModuleContext *ASTCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Validate the WASM module. */

  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Instantiate the WASM module into store context. */

  WasmEdge_ModuleInstanceContext *ModCxt = NULL;

  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  /* Try to list the exported functions of the instantiated WASM module. */

  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

  /* Create the name buffers. */

  const uint32_t BUF_LEN = 256;

  WasmEdge_String FuncNames[BUF_LEN];

  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */

  uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

    char Buf[BUF_LEN];

    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

    printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

    /* The function names should __NOT__ be destroyed. */

  }



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

  /* Find the exported function by function name. */

  WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

  if (FuncCxt == NULL) {

    printf(""Function `fib` not found.\n"");

    return 1;

  }

  /* Invoke the WASM function. */

  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_StringDelete(FuncName);

  WasmEdge_ASTModuleDelete(ASTCxt);

  WasmEdge_ModuleInstanceDelete(ModCxt);

  WasmEdge_LoaderDelete(LoadCxt);

  WasmEdge_ValidatorDelete(ValidCxt);

  WasmEdge_ExecutorDelete(ExecCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  WasmEdge_StoreDelete(StoreCxt);

  WasmEdge_StatisticsDelete(StatCxt);

  return 0;

}

```



Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)



```bash

$ gcc test.c -lwasmedge_c

$ ./a.out

Get exported function string length: 3, name: fib

Get the result: 4181

```



### Loader



The `Loader` context loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```c

uint8_t Buf[4096];

/* ... Read the WASM code to the buffer. */

uint32_t FileSize = ...;

/* The `FileSize` is the length of the WASM code. */



/* Developers can adjust settings in the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);



WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;



/* Load WASM or compiled-WASM from the file. */

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



/* Load WASM or compiled-WASM from the buffer. */

Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Validator



The `Validator` context can validate the WASM module. Every WASM module should be validated before instantiation.



```c

/*

 * ...

 * Assume that the `ASTCxt` is the output AST module context from the loader context.

 * Assume that the `ConfCxt` is the configure context.

 */

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

WasmEdge_ValidatorDelete(ValidCxt);

```



### Executor



The `Executor` context is the executor for both WASM and compiled-WASM. This object should work base on the `Store` context. For the details of the `Store` context, please refer to the [next chapter](#store).



1. Instantiate and register an `AST module` as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` contexts, developers can instantiate and register an `AST module` contexts into the `Store` context as a named `Module` instance by the `Executor` APIs. After the registration, the result `Module` instance is exported with the given module name and can be linked when instantiating another module. For the details about the `Module` instances APIs, please refer to the [Instances](#instances).



   ```c

   /*

   * ...

   * Assume that the `ASTCxt` is the output AST module context from the loader context

   * and has passed the validation.

   * Assume that the `ConfCxt` is the configure context.

   */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /* Create the executor context. The configure and the statistics contexts can be NULL. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /* Create the store context. The store context is the object to link the modules for imports and exports. */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /* Register the WASM module into the store with the export module name ""mod"". */

   Res = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   WasmEdge_StringDelete(ModName);



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST module` contexts, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```c

   /*

   * ...

   * Assume that the `ASTCxt` is the output AST module context from the loader context

   * and has passed the validation.

   * Assume that the `ConfCxt` is the configure context.

   */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /* Create the executor context. The configure and the statistics contexts can be NULL. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /* Create the store context. The store context is the object to link the modules for imports and exports. */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   /* Create a module instance for host functions. */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""host-module"");

   WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ModName);

   WasmEdge_StringDelete(ModName);

   /*

    * ...

    * Create and add the host functions, tables, memories, and globals into the module instance.

    */



   /* Register the module instance into store with the exported module name. */

   /* The export module name is in the module instance already. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



3. Instantiate an `AST module` to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` context for linking.



   ```c

   /*

   * ...

   * Assume that the `ASTCxt` is the output AST module context from the loader context

   * and has passed the validation.

   * Assume that the `ConfCxt` is the configure context.

   */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /* Create the executor context. The configure and the statistics contexts can be NULL. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /* Create the store context. The store context is the object to link the modules for imports and exports. */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /* Instantiate the WASM module. */

   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM instantiation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `WasmEdge_ExecutorInvoke()` API.



### AST Module



The `AST Module` context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST Module` context.



```c

WasmEdge_ASTModuleContext *ASTCxt = ...;

/* Assume that a WASM is loaded into an AST module context. */



/* Create the import type context buffers. */

const uint32_t BUF_LEN = 256;

const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];

uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);

/* If the list length is larger than the buffer length, the overflowed data will be discarded. */

uint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {

  /* Working with the import type `ImpTypes[I]` ... */

}



/* Create the export type context buffers. */

const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];

uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);

/* If the list length is larger than the buffer length, the overflowed data will be discarded. */

uint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {

  /* Working with the export type `ExpTypes[I]` ... */

}



WasmEdge_ASTModuleDelete(ASTCxt);

/* After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be accessed. */

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` context in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context.



```c

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



/*

 * ...

 * Register a WASM module via the executor context.

 */



/* Try to list the registered WASM modules. */

uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);

/* Create the name buffers. */

const uint32_t BUF_LEN = 256;

WasmEdge_String ModNames[BUF_LEN];

/* If the list length is larger than the buffer length, the overflowed data will be discarded. */

uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);

for (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {

  /* Working with the module name `ModNames[I]` ... */

  /* The module names should __NOT__ be destroyed. */

}



/* Find named module by name. */

WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");

const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_StoreFindModule(StoreCxt, ModName);

/* If the module with name not found, the `ModCxt` will be NULL. */

WasmEdge_StringDelete(ModName);

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST module` context, developers will get a `Module` instance as the result, and have the responsibility to destroy it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```c

   /*

   * ...

   * Instantiate a WASM module via the executor context and get the `ModCxt` as the output module instance.

   */



   /* Try to list the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String FuncNames[BUF_LEN];

   /* If the list length is larger than the buffer length, the overflowed data will be discarded. */

   uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

   for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

     /* Working with the function name `FuncNames[I]` ... */

     /* The function names should __NOT__ be destroyed. */

   }



   /* Try to find the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   /* Function name. */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

   /* `FuncCxt` will be `NULL` if the function not found. */

   /* The returned instance is owned by the module instance context and should __NOT__ be destroyed. */

   WasmEdge_StringDelete(FuncName);

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` contexts for host functions and add them into an `Module` instance context for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` contexts through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```c

   /* Retrieve the function instance from the module instance context. */

   WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);

   /* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */



   /* For the function instance creation, please refer to the `Host Function` guide. */

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Table` contexts supply APIs to control the data in table instances.



   ```c

   WasmEdge_Limit TabLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   /* Create the table type with limit and the `FuncRef` element type. */

   WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);

   /* Create the table instance with table type. */

   WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);

   /* Delete the table type. */

   WasmEdge_TableTypeDelete(TabTypeCxt);

   WasmEdge_Result Res;

   WasmEdge_Value Data;



   TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);

   /* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */

   enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `RefType` will be `WasmEdge_RefType_FuncRef`. */

   Data = WasmEdge_ValueGenFuncRef(5);

   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);

   /* Set the function index 5 to the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);

    */

   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);

   /* Get the FuncRef value of the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);

    */



   uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);

   /* `Size` will be 10. */

   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

   /* Grow the table size of 6, the table size will be 16. */

   /*

    * This will get an ""out of bounds table access"" error because

    * the size (16 + 6) will reach the table limit(20):

    *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

    */



   WasmEdge_TableInstanceDelete(HostTable);

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Memory` contexts supply APIs to control the data in memory instances.



   ```c

   WasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 5};

   /* Create the memory type with limit. The memory page size is 64KiB. */

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);

   /* Create the memory instance with memory type. */

   WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);

   /* Delete the memory type. */

   WasmEdge_MemoryTypeDelete(MemTypeCxt);

   WasmEdge_Result Res;

   uint8_t Buf[256];



   Buf[0] = 0xAA;

   Buf[1] = 0xBB;

   Buf[2] = 0xCC;

   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);

   /* Set the data[0:2] to the memory[4096:4098]. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */

   Buf[0] = 0;

   Buf[1] = 0;

   Buf[2] = 0;

   Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);

   /* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */



   uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);

   /* `PageSize` will be 1. */

   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);

   /* Grow the page size of 2, the page size of the memory instance will be 3. */

   /*

    * This will get an ""out of bounds memory access"" error because

    * the page size (3 + 3) will reach the memory limit(5):

    *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);

    */



   WasmEdge_MemoryInstanceDelete(HostMemory);

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Global` contexts supply APIs to control the value in global instances.



   ```c

   WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);

   /* Create the global type with value type and mutation. */

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);

   /* Create the global instance with value and global type. */

   WasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);

   /* Delete the global type. */

   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   WasmEdge_Result Res;



   GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);

   /* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */

   enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `ValType` will be `WasmEdge_ValType_I64`. */

   enum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `ValMut` will be `WasmEdge_Mutability_Var`. */



   WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));

   /*

    * Set the value u64(888) to the global.

    * This function will do nothing if the value type mismatched or

    * the global mutability is `WasmEdge_Mutability_Const`.

    */

   WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);

   /* Get the value (888 now) of the global context. */



   WasmEdge_GlobalInstanceDelete(HostGlobal);

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define C functions with the following function signature as the host function body:



   ```c

   typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

     void *Data,

     WasmEdge_MemoryInstanceContext *MemCxt,

     const WasmEdge_Value *Params,

     WasmEdge_Value *Returns);

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```c

   WasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /*

     * Params: {i32, i32}

     * Returns: {i32}

     * Developers should take care about the function type.

     */

     /* Retrieve the value 1. */

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     /* Retrieve the value 2. */

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     /* Output value 1 is Val1 + Val2. */

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Return the status of success. */

     return WasmEdge_Result_Success;

   }

   ```



   Then developers can create `Function` context with the host function body and the function type:



   ```c

   enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

   enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

   /* Create a function type: {i32, i32} -> {i32}. */

   WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   /*

    * Create a function context with the function type and host function body.

    * The `Cost` parameter can be 0 if developers do not need the cost measuring.

    */

   WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostType);



   /* If the function instance is not added into a module instance context, it should be deleted. */

   WasmEdge_FunctionInstanceDelete(HostFunc);

   ```



2. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```c

   /* Host function body definition. */

   WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   /* Create a module instance. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);

   WasmEdge_StringDelete(ExportName);



   /* Create and add a function instance into the module instance. */

   enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

   enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

   WasmEdge_FunctionTypeContext *HostFType =

     WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   WasmEdge_FunctionInstanceContext *HostFunc =

     WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data object.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostFType);

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

   WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);

   WasmEdge_StringDelete(FuncName);



   /* Create and add a table instance into the import object. */

   WasmEdge_Limit TableLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *HostTType =

     WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);

   WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);

   WasmEdge_TableTypeDelete(HostTType);

   WasmEdge_String TableName = WasmEdge_StringCreateByCString(""table"");

   WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);

   WasmEdge_StringDelete(TableName);



   /* Create and add a memory instance into the import object. */

   WasmEdge_Limit MemoryLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};

   WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);

   WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);

   WasmEdge_MemoryTypeDelete(HostMType);

   WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(""memory"");

   WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);

   WasmEdge_StringDelete(MemoryName);



   /* Create and add a global instance into the module instance. */

   WasmEdge_GlobalTypeContext *HostGType =

     WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);

   WasmEdge_GlobalInstanceContext *HostGlobal =

     WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));

   WasmEdge_GlobalTypeDelete(HostGType);

   WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(""global"");

   WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);

   WasmEdge_StringDelete(GlobalName);



   /*

    * The module instance should be deleted.

    * Developers should __NOT__ destroy the instances added into the module instance contexts.

    */

   WasmEdge_ModuleInstanceDelete(HostModCxt);

   ```



3. Specified module instance



   `WasmEdge_ModuleInstanceCreateWASI()` API can create and initialize the `WASI` module instance.



   `WasmEdge_ModuleInstanceCreateWasiNN()` API can create and initialize the `wasi_ephemeral_nn` module instance for `WASI-NN` plugin (`0.10.1` or upper only).



   `WasmEdge_ModuleInstanceCreateWasiCryptoCommon()` API can create and initialize the `wasi_ephemeral_crypto_common` module instance for `WASI-Crypto` plugin (`0.10.1` or upper only).



   `WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()` API can create and initialize the `wasi_ephemeral_crypto_asymmetric_common` module instance for `WASI-Crypto` plugin (`0.10.1` or upper only).



   `WasmEdge_ModuleInstanceCreateWasiCryptoKx()` API can create and initialize the `wasi_ephemeral_crypto_kx` module instance for `WASI-Crypto` plugin (`0.10.1` or upper only).



   `WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()` API can create and initialize the `wasi_ephemeral_crypto_signatures` module instance for `WASI-Crypto` plugin (`0.10.1` or upper only).



   `WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()` API can create and initialize the `wasi_ephemeral_crypto_symmetric` module instance for `WASI-Crypto` plugin (`0.10.1` or upper only).



   `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()` API can create and initialize the `wasmedge_process` module instance for `wasmedge_process` plugin.



   Developers can create these module instance contexts and register them into the `Store` or `VM` contexts rather than adjust the settings in the `Configure` contexts.



   > Note: For the `WASI-NN` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-nn-plug-in-with-openvino-backend) are satisfied. Note: For the `WASI-Crypto` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-crypto-plug-in) are satisfied. And the 5 modules are recommended to all be created and registered together.



   ```c

   WasmEdge_ModuleInstanceContext *WasiModCxt = WasmEdge_ModuleInstanceCreateWASI( /* ... ignored */ );

   WasmEdge_ModuleInstanceContext *ProcModCxt = WasmEdge_ModuleInstanceCreateWasmEdgeProcess( /* ... ignored */ );

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   /* Register the WASI and WasmEdge_Process into the VM context. */

   WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);

   WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);

   /* Get the WASI exit code. */

   uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);

   /*

    * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.

    * Otherwise, it will return with the related exit code.

    */

   WasmEdge_VMDelete(VMCxt);

   /* The module instances should be deleted. */

   WasmEdge_ModuleInstanceDelete(WasiModCxt);

   WasmEdge_ModuleInstanceDelete(ProcModCxt);

   ```



4. Example



   Assume that a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B

     };



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

     enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

     WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

       VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   ```



5. Host Data Example



   Developers can set a external data object to the `Function` context, and access to the object in the function body. Assume that a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Also set the result to the data. */

     int32_t *DataPtr = (int32_t *)Data;

     *DataPtr = Val1 + Val2;

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B

     };



     /* The external data object: an integer. */

     int32_t Data;



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

     enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

     WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

       VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     printf(""Data value: %d\n"", Data);



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   Data value: 6912

   ```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options.



WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* ... Adjust settings in the configure context. */

  /* Result. */

  WasmEdge_Result Res;



  /* Create the compiler context. The configure context can be NULL. */

  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);

  /* Compile the WASM file with input and output paths. */

  Res = WasmEdge_CompilerCompile(CompilerCxt, ""fibonacci.wasm"", ""fibonacci.wasm.so"");

  if (!WasmEdge_ResultOK(Res)) {

      printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

      return 1;

  }



  WasmEdge_CompilerDelete(CompilerCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  return 0;

}

```



Then you can compile and run (the output file is ""fibonacci.wasm.so""):



```bash

$ gcc test.c -lwasmedge_c

$ ./a.out

[2021-07-02 11:08:08.651] [info] compile start

[2021-07-02 11:08:08.653] [info] verify start

[2021-07-02 11:08:08.653] [info] optimize start

[2021-07-02 11:08:08.670] [info] codegen start

[2021-07-02 11:08:08.706] [info] compile done

```



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```c

/// AOT compiler optimization level enumeration.

enum WasmEdge_CompilerOptimizationLevel {

  /// Disable as many optimizations as possible.

  WasmEdge_CompilerOptimizationLevel_O0 = 0,

  /// Optimize quickly without destroying debuggability.

  WasmEdge_CompilerOptimizationLevel_O1,

  /// Optimize for fast execution as much as possible without triggering

  /// significant incremental compile time or code size growth.

  WasmEdge_CompilerOptimizationLevel_O2,

  /// Optimize for fast execution as much as possible.

  WasmEdge_CompilerOptimizationLevel_O3,

  /// Optimize for small code size as much as possible without triggering

  /// significant incremental compile time or execution time slowdowns.

  WasmEdge_CompilerOptimizationLevel_Os,

  /// Optimize for small code size as much as possible.

  WasmEdge_CompilerOptimizationLevel_Oz

};



/// AOT compiler output binary format enumeration.

enum WasmEdge_CompilerOutputFormat {

  /// Native dynamic library format.

  WasmEdge_CompilerOutputFormat_Native = 0,

  /// WebAssembly with AOT compiled codes in custom sections.

  WasmEdge_CompilerOutputFormat_Wasm

};

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/c/reference/0.11.x.md
------


---

sidebar_position: 7

---



# C API 0.11.2 Documentation



[WasmEdge C API](https://github.com/WasmEdge/WasmEdge/blob/0.11.2/include/api/wasmedge/wasmedge.h) denotes an interface to access the WasmEdge runtime at version `0.11.2`. The following are the guides to working with the C APIs of WasmEdge.



**Please notice that the WasmEdge C API provides SONAME and SOVERSION after the `0.11.0` release.**



**Please notice that `libwasmedge_c.so` is renamed to `libwasmedge.so` after the `0.11.0` release. Please use `-lwasmedge` instead of `-lwasmedge_c` for the linker option.**



**Developers can refer to [here to upgrade to 0.12.0](upgrade_to_0.12.0.md).**



## Table of Contents



- [WasmEdge Installation](#wasmedge-installation)

  - [Download And Install](#download-and-install)

  - [Compile Sources](#compile-sources)

  - [ABI Compatibility](#abi-compatibility)

- [WasmEdge Basics](#wasmedge-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Strings](#strings)

  - [Results](#results)

  - [Contexts](#contexts)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

  - [Tools driver](#tools-driver)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Context](#wasm-execution-example-with-vm-context)

  - [VM Creations](#vm-creations)

  - [Preregistrations](#preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## WasmEdge Installation



### Download And Install



The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `wget` as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.2

```



For more details, please refer to the [Installation Guide](../../../start/install.md#install) for the WasmEdge installation.



### Compile Sources



After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.



1. Prepare the test C file (and assumed saved as `test.c`):



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

     return 0;

   }

   ```



2. Compile the file with `gcc` or `clang`.



   ```bash

   gcc test.c -lwasmedge

   ```



3. Run and get the expected output.



   ```bash

   $ ./a.out

   WasmEdge version: 0.11.2

   ```



### ABI Compatibility



WasmEdge C API introduces SONAME and SOVERSION in the 0.11.0 release to present the compatibility between different C API versions.



The releases before 0.11.0 are all unversioned. Please make sure the library version is the same as the corresponding C API version you used.



| WasmEdge Version | WasmEdge C API Library Name | WasmEdge C API SONAME | WasmEdge C API SOVERSION |

| --- | --- | --- | --- |

| < 0.11.0 | libwasmedge_c.so | Unversioned | Unversioned |

| 0.11.0 to 0.11.1 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.0 |

| since 0.11.2 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.1 |



## WasmEdge Basics



In this part, we will introduce the utilities and concepts of WasmEdge shared library.



### Version



The `Version` related APIs provide developers to check for the WasmEdge shared library version.



```c

#include <wasmedge/wasmedge.h>

printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

printf(""WasmEdge version major: %u\n"", WasmEdge_VersionGetMajor());

printf(""WasmEdge version minor: %u\n"", WasmEdge_VersionGetMinor());

printf(""WasmEdge version patch: %u\n"", WasmEdge_VersionGetPatch());

```



### Logging Settings



The `WasmEdge_LogSetErrorLevel()` and `WasmEdge_LogSetDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



Developers can also use the `WasmEdge_LogOff()` API to disable all logging. (`0.11.2` or upper only)



### Value Types



In WasmEdge, developers should convert the values to `WasmEdge_Value` objects through APIs for matching to the WASM value types.



1. Number types: `i32`, `i64`, `f32`, `f64`, and `v128` for the `SIMD` proposal



   ```c

   WasmEdge_Value Val;

   Val = WasmEdge_ValueGenI32(123456);

   printf(""%d\n"", WasmEdge_ValueGetI32(Val));

   /* Will print ""123456"" */

   Val = WasmEdge_ValueGenI64(1234567890123LL);

   printf(""%ld\n"", WasmEdge_ValueGetI64(Val));

   /* Will print ""1234567890123"" */

   Val = WasmEdge_ValueGenF32(123.456f);

   printf(""%f\n"", WasmEdge_ValueGetF32(Val));

   /* Will print ""123.456001"" */

   Val = WasmEdge_ValueGenF64(123456.123456789);

   printf(""%.10f\n"", WasmEdge_ValueGetF64(Val));

   /* Will print ""123456.1234567890"" */

   ```



2. Reference types: `funcref` and `externref` for the `Reference-Types` proposal



   ```c

   WasmEdge_Value Val;

   void *Ptr;

   bool IsNull;

   uint32_t Num = 10;

   /* Generate a externref to NULL. */

   Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);

   IsNull = WasmEdge_ValueIsNullRef(Val);

   /* The `IsNull` will be `TRUE`. */

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `NULL`. */



   /* Get the function instance by creation or from module instance. */

   const WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   /* Generate a funcref with the given function instance context. */

   Val = WasmEdge_ValueGenFuncRef(FuncCxt);

   const WasmEdge_FunctionInstanceContext *GotFuncCxt =

       WasmEdge_ValueGetFuncRef(Val);

   /* The `GotFuncCxt` will be the same as `FuncCxt`. */



   /* Generate a externref to `Num`. */

   Val = WasmEdge_ValueGenExternRef(&Num);

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `&Num`. */

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""10"" */

   Num += 55;

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""65"" */

   ```



### Strings



The `WasmEdge_String` object is for the instance names when invoking a WASM function or finding the contexts of instances.



1. Create a `WasmEdge_String` from a C string (`const char *` with NULL termination) or a buffer with length.



   The content of the C string or buffer will be copied into the `WasmEdge_String` object.



   ```c

   char Buf[4] = {50, 55, 60, 65};

   WasmEdge_String Str1 = WasmEdge_StringCreateByCString(""test"");

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   /* The objects should be deleted by `WasmEdge_StringDelete()`. */

   WasmEdge_StringDelete(Str1);

   WasmEdge_StringDelete(Str2);

   ```



2. Wrap a `WasmEdge_String` to a buffer with length.



   The content will not be copied, and the caller should guarantee the life cycle of the input buffer.



   ```c

   const char CStr[] = ""test"";

   WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);

   /* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */

   ```



3. String comparison



   ```c

   const char CStr[] = ""abcd"";

   char Buf[4] = {0x61, 0x62, 0x63, 0x64};

   WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);

   /* The `IsEq` will be `TRUE`. */

   WasmEdge_StringDelete(Str2);

   ```



4. Convert to C string



   ```c

   char Buf[256];

   WasmEdge_String Str =

       WasmEdge_StringCreateByCString(""test_wasmedge_string"");

   uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));

   /* StrLength will be 20 */

   printf(""String: %s\n"", Buf);

   /* Will print ""test_wasmedge_string"". */

   ```



### Results



The `WasmEdge_Result` object specifies the execution status. APIs about WASM execution will return the `WasmEdge_Result` to denote the status.



```c

WasmEdge_Result Res = WasmEdge_Result_Success;

bool IsSucceeded = WasmEdge_ResultOK(Res);

/* The `IsSucceeded` will be `TRUE`. */

uint32_t Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 0. */

const char *Msg = WasmEdge_ResultGetMessage(Res);

/* The `Msg` will be ""success"". */

enum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_WASM. */



Res = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);

/* Generate the user-defined result with code. */

Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 123. */

Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */

```



### Contexts



The objects, such as `VM`, `Store`, and `Function`, are composed of `Context`s. All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.



```c

/* Create the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Delete the configure context. */

WasmEdge_ConfigureDelete(ConfCxt);

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `WasmEdge_Limit` struct is defined in the header:



   ```c

   /// Struct of WASM limit.

   typedef struct WasmEdge_Limit {

     /// Boolean to describe has max value or not.

     bool HasMax;

     /// Boolean to describe is shared memory or not.

     bool Shared;

     /// Minimum value.

     uint32_t Min;

     /// Maximum value. Will be ignored if the `HasMax` is false.

     uint32_t Max;

   } WasmEdge_Limit;

   ```



   Developers can initialize the struct by assigning it's value, and the `Max` value is needed to be larger or equal to the `Min` value. The API `WasmEdge_LimitIsEqual()` is provided to compare with 2 `WasmEdge_Limit` structs.



2. Function type context



   The `Function Type` context is used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `Function Type` context APIs to get the parameter or return value types information.



   ```c

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I64};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



   enum WasmEdge_ValType Buf[16];

   uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);

   /* `ParamLen` will be 2. */

   uint32_t GotParamLen =

       WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);

   /* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as

    * `ParamList`. */

   uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);

   /* `ReturnLen` will be 1. */

   uint32_t GotReturnLen =

       WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);

   /* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.

    */



   WasmEdge_FunctionTypeDelete(FuncTypeCxt);

   ```



3. Table type context



   The `Table Type` context is used for `Table` instance creation or getting information from `Table` instances.



   ```c

   WasmEdge_Limit TabLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);



   enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `GotRefType` will be WasmEdge_RefType_ExternRef. */

   WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);

   /* `GotTabLim` will be the same value as `TabLim`. */



   WasmEdge_TableTypeDelete(TabTypeCxt);

   ```



4. Memory type context



   The `Memory Type` context is used for `Memory` instance creation or getting information from `Memory` instances.



   ```c

   WasmEdge_Limit MemLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);



   WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);

   /* `GotMemLim` will be the same value as `MemLim`. */



   WasmEdge_MemoryTypeDelete(MemTypeCxt)

   ```



5. Global type context



   The `Global Type` context is used for `Global` instance creation or getting information from `Global` instances.



   ```c

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_F64, WasmEdge_Mutability_Var);



   WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `GotValType` will be WasmEdge_ValType_F64. */

   WasmEdge_Mutability GotValMut =

       WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `GotValMut` will be WasmEdge_Mutability_Var. */



   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   ```



6. Import type context



   The `Import Type` context is used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `Import Type` context. The details about querying `Import Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ImportTypeContext *ImpType = ...;

   /* Assume that `ImpType` is queried from the `ASTCxt` for the import. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ImportTypeGetExternalType(ImpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or

    * `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);

   WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);

   /*

    * The `ModName` and `ExtName` should not be destroyed and the string

    * buffers are binded into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



7. Export type context



   The `Export Type` context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `Export Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ExportTypeContext *ExpType = ...;

   /* Assume that `ExpType` is queried from the `ASTCxt` for the export. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ExportTypeGetExternalType(ExpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or

    * `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);

   /*

    * The `ExtName` should not be destroyed and the string buffer is binded

    * into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `WasmEdge_Async` object. Developers own the object and should call the `WasmEdge_AsyncDelete()` API to destroy it.



1. Wait for the asynchronous execution



   Developers can wait the execution until finished:



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution. */

   WasmEdge_AsyncWait(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   Or developers can wait for a time limit. If the time limit exceeded, developers can choose to cancel the execution. For the interruptible execution in AOT mode, developers should set `TRUE` through the `WasmEdge_ConfigureCompilerSetInterruptible()` API into the configure context for the AOT compiler.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution for 1 second. */

   bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);

   if (IsEnd) {

     /* The execution finished. Developers can get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);

   } else {

     /*

      * The time limit exceeded. Developers can keep waiting or cancel the

      * execution.

      */

     WasmEdge_AsyncCancel(Async);

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);

     /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */

   }

   WasmEdge_AsyncDelete(Async);

   ```



2. Get the execution result of the asynchronous execution



   Developers can use the `WasmEdge_AsyncGetReturnsLength()` API to get the return value list length. This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return `0`. This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the `WasmEdge_AsyncGet()` API to get the result.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /*

    * Blocking and waiting for the execution and get the return value list

    * length.

    */

   uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   The `WasmEdge_AsyncGet()` API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return values. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_Value Buf[BUF_LEN];

   WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);

   WasmEdge_AsyncDelete(Async);

   ```



### Configurations



The configuration context, `WasmEdge_ConfigureContext`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` context to create other runtime contexts.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` context.



   ```c

   enum WasmEdge_Proposal {

     WasmEdge_Proposal_ImportExportMutGlobals = 0,

     WasmEdge_Proposal_NonTrapFloatToIntConversions,

     WasmEdge_Proposal_SignExtensionOperators,

     WasmEdge_Proposal_MultiValue,

     WasmEdge_Proposal_BulkMemoryOperations,

     WasmEdge_Proposal_ReferenceTypes,

     WasmEdge_Proposal_SIMD,

     WasmEdge_Proposal_TailCall,

     WasmEdge_Proposal_MultiMemories,

     WasmEdge_Proposal_Annotations,

     WasmEdge_Proposal_Memory64,

     WasmEdge_Proposal_ExceptionHandling,

     WasmEdge_Proposal_ExtendedConst,

     WasmEdge_Proposal_Threads,

     WasmEdge_Proposal_FunctionReferences

   };

   ```



   Developers can add or remove the proposals into the `Configure` context.



   ```c

   /*

    * By default, the following proposals have turned on initially:

    * * Import/Export of mutable globals

    * * Non-trapping float-to-int conversions

    * * Sign-extension operators

    * * Multi-value returns

    * * Bulk memory operations

    * * Reference types

    * * Fixed-width SIMD

    *

    * For the current WasmEdge version, the following proposals are supported

    * (turned off by default) additionally:

    * * Tail-call

    * * Multiple memories

    * * Extended-const

    * * Threads

    */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);

   WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);

   bool IsBulkMem = WasmEdge_ConfigureHasProposal(

       ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);

   /* The `IsBulkMem` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` or `wasmedge_process` supports and only effective in `VM` contexts.



   ```c

   enum WasmEdge_HostRegistration {

     WasmEdge_HostRegistration_Wasi = 0,

     WasmEdge_HostRegistration_WasmEdge_Process

   };

   ```



   The details will be introduced in the [preregistrations of VM context](#preregistrations).



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `FALSE`. */

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* By default, the maximum memory page size is 65536. */

   WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);

   /*

    * Limit the memory size of each memory instance with not larger than 1024

    * pages (64 MiB).

    */

   PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* The `PageSize` will be 1024. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



4. Forcibly interpreter mode (`0.11.2` or upper only)



   If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* By default, The `IsForceInterp` will be `FALSE`. */

   WasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);

   IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* The `IsForceInterp` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



5. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```c

   enum WasmEdge_CompilerOptimizationLevel {

     // Disable as many optimizations as possible.

     WasmEdge_CompilerOptimizationLevel_O0 = 0,

     // Optimize quickly without destroying debuggability.

     WasmEdge_CompilerOptimizationLevel_O1,

     // Optimize for fast execution as much as possible without triggering

     // significant incremental compile time or code size growth.

     WasmEdge_CompilerOptimizationLevel_O2,

     // Optimize for fast execution as much as possible.

     WasmEdge_CompilerOptimizationLevel_O3,

     // Optimize for small code size as much as possible without triggering

     // significant incremental compile time or execution time slowdowns.

     WasmEdge_CompilerOptimizationLevel_Os,

     // Optimize for small code size as much as possible.

     WasmEdge_CompilerOptimizationLevel_Oz

   };



   enum WasmEdge_CompilerOutputFormat {

     // Native dynamic library format.

     WasmEdge_CompilerOutputFormat_Native = 0,

     // WebAssembly with AOT compiled codes in custom section.

     WasmEdge_CompilerOutputFormat_Wasm

   };

   ```



   These configurations are only effective in `Compiler` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the optimization level is O3. */

   WasmEdge_ConfigureCompilerSetOptimizationLevel(

       ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);

   /* By default, the output format is universal WASM. */

   WasmEdge_ConfigureCompilerSetOutputFormat(

       ConfCxt, WasmEdge_CompilerOutputFormat_Native);

   /* By default, the dump IR is `FALSE`. */

   WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);

   /* By default, the generic binary is `FALSE`. */

   WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);

   /* By default, the interruptible is `FALSE`.

   /* Set this option to `TRUE` to support the interruptible execution in AOT

   mode. */

   WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



6. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /*

    * By default, the instruction counting is `FALSE` when running a

    * compiled-WASM or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);

   /*

    * By default, the cost measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);

   /*

    * By default, the time measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



### Statistics



The statistics context, `WasmEdge_StatisticsContext`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` context from the `VM` context, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);

   double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` context. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   uint64_t CostTable[16] = {

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0

   };

   /*

    * Developers can set the costs of each instruction. The value not

    * covered will be 0.

    */

   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



### Tools Driver



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API. The API arguments are the same as the command line arguments of the CLI tools.



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge AOT compiler. */

  return WasmEdge_Driver_Compiler(argc, argv);

}

```



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge runtime tool. */

  return WasmEdge_Driver_Tool(argc, argv);

}

```



## WasmEdge VM



In this partition, we will introduce the functions of `WasmEdge_VMContext` object and show examples of executing WASM functions.



### WASM Execution Example With VM Context



The following shows the example of running the WASM for getting the Fibonacci. This example uses the binary format of [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat), and developers can convert it into the WASM file by the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Run the WASM function from file. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1, Returns, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMRunWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRunWasmFromASTModule()` API.

      */



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 8

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need the WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * Step 4: Execute WASM functions. You can execute functions repeatedly

      * after instantiation.

      */

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 89

   ```



   The following graph explains the status of the `VM` context.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or module instances in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation API accepts the `Configure` context and the `Store` context. If developers only need the default settings, just pass `NULL` to the creation API. The details of the `Store` context will be introduced in [Store](#store).



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);

/* The caller should guarantee the life cycle if the store context. */

WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);

/*

 * The VM context already contains the statistics context and can be retrieved

 * by this API.

 */

/*

 * Note that the retrieved store and statistics contexts from the VM contexts by

 * VM APIs should __NOT__ be destroyed and owned by the VM contexts.

 */

WasmEdge_VMDelete(VMCxt);

WasmEdge_StoreDelete(StoreCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Preregistrations



WasmEdge provides the following built-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` context.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /*

    * The following API can retrieve the pre-registration module instances from

    * the VM context.

    */

   /*

    * This API will return `NULL` if the corresponding pre-registration is not

    * set into the configuration.

    */

   WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetImportModuleContext(VMCxt,

                                         WasmEdge_HostRegistration_Wasi);

   /* Initialize the WASI. */

   WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WASI module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. [WasmEdge_Process](https://crates.io/crates/wasmedge_process_interface)



   This pre-registration is for the process interface for WasmEdge on `Rust` sources. After turning on this pre-registration, the VM will support the `wasmedge_process` plugin.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /*

    * The following API can retrieve the pre-registration module instances from

    * the VM context.

    */

   /*

    * This API will return `NULL` if the corresponding pre-registration is not

    * set into the configuration or the plugin load failed.

    */

   WasmEdge_ModuleInstanceContext *ProcModule =

       WasmEdge_VMGetImportModuleContext(

           VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);

   /* Initialize the WasmEdge_Process. */

   WasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */);

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WasmEdge_Process module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



3. [WASI-NN proposal](https://github.com/WebAssembly/wasi-nn)



   Developers can turn on the WASI-NN proposal support for VM in the `Configure` context.



   > Note: Please check that the [dependencies and prerequisites](../../../start/install.md#wasi-nn-plug-in) are satisfied.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_WasiNN);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /*

    * The following API can retrieve the pre-registration module instances from

    * the VM context.

    */

   /*

    * This API will return `NULL` if the corresponding pre-registration is not

    * set into the configuration or the plugin load failed.

    */

   WasmEdge_ModuleInstanceContext *NNModule =

       WasmEdge_VMGetImportModuleContext(VMCxt,

                                         WasmEdge_HostRegistration_WasiNN);

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WASI-NN module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



4. [WASI-Crypto proposal](https://github.com/WebAssembly/wasi-crypto)



   Developers can turn on the WASI-Crypto proposal support for VM in the `Configure` context.



   > Note: Please check that the [dependencies and prerequisites](../../../start/install.md#wasi-crypto-plug-in) are satisfied.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* The WASI-Crypto related configures are suggested to turn on together. */

   WasmEdge_ConfigureAddHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);

   WasmEdge_ConfigureAddHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);

   WasmEdge_ConfigureAddHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);

   WasmEdge_ConfigureAddHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);

   WasmEdge_ConfigureAddHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /*

    * The following API can retrieve the pre-registration module instances from

    * the VM context.

     */

   /*

    * This API will return `NULL` if the corresponding pre-registration is not

    * set into the configuration or the plugin load failed.

     */

   WasmEdge_ModuleInstanceContext *CryptoCommonModule =

       WasmEdge_VMGetImportModuleContext(

           VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WASI-Crypto module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, the host functions are composed into host modules as `WasmEdge_ModuleInstanceContext` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` context.



```c

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

WasmEdge_ModuleInstanceContext *WasiModule =

    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);

/* You can also create and register the WASI host modules by this API. */

WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);

/* The result status should be checked. */



/* ... */



WasmEdge_ModuleInstanceDelete(WasiModule);

/*

 * The created module instances should be deleted by the developers when the VM

 * deallocation.

 */

WasmEdge_VMDelete(VMCxt);

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   WasmEdge_Result Res =

       WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

   /*

    * Developers can register the WASM module from buffer with the

    * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from

    * `WasmEdge_ASTModuleContext` object with the

    * `WasmEdge_VMRegisterModuleFromASTModule()` API.

    */

   /*

    * The result status should be checked.

    * The error will occur if the WASM module instantiation failed or the

    * module name conflicts.

    */

   WasmEdge_StringDelete(ModName);

   WasmEdge_VMDelete(VMCxt);

   ```



2. Execute the functions in registered WASM modules



   Assume that the C file `test.c` is as follows:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Names. */

     WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Register the WASM module into VM. */

     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

     /*

      * Developers can register the WASM module from buffer with the

      * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRegisterModuleFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""WASM registration failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

      * name ""mod"". As the same as host functions, other modules can import the

      * function `""mod"" ""fib""`.

      */



     /*

      * Execute WASM functions in registered modules.

      * Unlike the execution of functions, the registered functions can be

      * invoked without `WasmEdge_VMInstantiate()` because the WASM module was

      * instantiated when registering. Developers can also invoke the host

      * functions directly with this API.

      */

     Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,

                                        Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     WasmEdge_StringDelete(ModName);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Asynchronously run the WASM function from file and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.

      */



     /* Wait for the execution. */

     WasmEdge_AsyncWait(Async);

     /*

      * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or

      * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.

      * These APIs will wait until the execution finished.

      */



     /* Check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Asynchronously execute the WASM function and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async =

         WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);

     /*

      * Developers can execute functions repeatedly after instantiation.

      * For invoking the registered functions, you can use the

      * `WasmEdge_VMAsyncExecuteRegistered()` API.

      */



     /* Wait and check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     Res = WasmEdge_AsyncGet(Async, Returns, Arity);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

   }

   ```



   Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` context supplies the APIs to retrieve the instances.



1. Store



   If the `VM` context is created without assigning a `Store` context, the `VM` context will allocate and own a `Store` context.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */

   WasmEdge_VMDelete(VMCxt);

   ```



   Developers can also create the `VM` context with a `Store` context. In this case, developers should guarantee the life cycle of the `Store` context. Please refer to the [Store Contexts](#store) for the details about the `Store` context APIs.



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

   WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);

   /* The `StoreCxt` and the `StoreCxtMock` are the same. */

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `WasmEdge_VMExecute()` API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);



     WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     WasmEdge_VMValidate(VMCxt);

     WasmEdge_VMInstantiate(VMCxt);



     /* List the exported functions. */

     /* Get the number of exported functions. */

     uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);

     /* Create the name buffers and the function type buffers. */

     const uint32_t BUF_LEN = 256;

     WasmEdge_String FuncNames[BUF_LEN];

     WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];

     /*

      * Get the export function list.

      * If the function list length is larger than the buffer length, the

      * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can

      * be NULL if developers don't need them.

      */

     uint32_t RealFuncNum =

         WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);



     for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

       char Buf[BUF_LEN];

       uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

       printf(""Get exported function string length: %u, name: %s\n"", Size,

              Buf);

       /*

        * The function names should be __NOT__ destroyed.

        * The returned function type contexts should __NOT__ be destroyed.

        */

     }

     WasmEdge_StoreDelete(StoreCxt);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get exported function string length: 3, name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` context from the `VM` context and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` context provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   const WasmEdge_FunctionTypeContext *FuncType =

       WasmEdge_VMGetFunctionType(VMCxt, FuncName);

   /*

    * Developers can get the function types of functions in the registered

    * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the

    * module name. If the function is not found, these APIs will return `NULL`.

    * The returned function type contexts should __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` context. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `WasmEdge_VMGetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   const WasmEdge_ModuleInstanceContext *ModCxt =

       WasmEdge_VMGetActiveModule(VMCxt);

   /*

    * If there's no WASM module instantiated, this API will return `NULL`.

    * The returned module instance context should __NOT__ be destroyed.

    */

   ```



5. Get the components



   The `VM` context is composed by the `Loader`, `Validator`, and `Executor` contexts. For the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the `VM` context. The get contexts are owned by the `VM` context, and developers should not call their delete functions.



   ```c

   WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */

   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` context](#wasmedge-vm), developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` contexts. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /*

   * Create the configure context. This step is not necessary because we didn't

   * adjust any setting.

   */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /*

   * Create the statistics context. This step is not necessary if the statistics

   * in runtime is not needed.

   */

  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

  /*

   * Create the store context. The store context is the object to link the

   * modules for imports and exports.

   */

  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Result. */

  WasmEdge_Result Res;



  /* Create the loader context. The configure context can be NULL. */

  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

  /* Create the validator context. The configure context can be NULL. */

  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

  /*

   * Create the executor context. The configure context and the statistics

   * context can be NULL.

   */

  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);



  /*

   * Load the WASM file or the compiled-WASM file and convert into the AST

   * module context.

   */

  WasmEdge_ASTModuleContext *ASTCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Validate the WASM module. */

  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Instantiate the WASM module into store context. */

  WasmEdge_ModuleInstanceContext *ModCxt = NULL;

  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  /* Try to list the exported functions of the instantiated WASM module. */

  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

  /* Create the name buffers. */

  const uint32_t BUF_LEN = 256;

  WasmEdge_String FuncNames[BUF_LEN];

  /*

   * If the list length is larger than the buffer length, the overflowed data

   * will be discarded.

   */

  uint32_t RealFuncNum =

      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

    char Buf[BUF_LEN];

    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

    printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

    /* The function names should __NOT__ be destroyed. */

  }



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

  /* Find the exported function by function name. */

  WasmEdge_FunctionInstanceContext *FuncCxt =

      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

  if (FuncCxt == NULL) {

    printf(""Function `fib` not found.\n"");

    return 1;

  }

  /* Invoke the WASM function. */

  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_StringDelete(FuncName);

  WasmEdge_ASTModuleDelete(ASTCxt);

  WasmEdge_ModuleInstanceDelete(ModCxt);

  WasmEdge_LoaderDelete(LoadCxt);

  WasmEdge_ValidatorDelete(ValidCxt);

  WasmEdge_ExecutorDelete(ExecCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  WasmEdge_StoreDelete(StoreCxt);

  WasmEdge_StatisticsDelete(StatCxt);

  return 0;

}

```



Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)



```bash

$ gcc test.c -lwasmedge

$ ./a.out

Get exported function string length: 3, name: fib

Get the result: 4181

```



### Loader



The `Loader` context loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```c

uint8_t Buf[4096];

/* ... Read the WASM code to the buffer. */

uint32_t FileSize = ...;

/* The `FileSize` is the length of the WASM code. */



/* Developers can adjust settings in the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);



WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;



/* Load WASM or compiled-WASM from the file. */

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



/* Load WASM or compiled-WASM from the buffer. */

Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Validator



The `Validator` context can validate the WASM module. Every WASM module should be validated before instantiation.



```c

/*

 * ...

 * Assume that the `ASTCxt` is the output AST module context from the loader

 * context.

 * Assume that the `ConfCxt` is the configure context.

 */

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

WasmEdge_ValidatorDelete(ValidCxt);

```



### Executor



The `Executor` context is the executor for both WASM and compiled-WASM. This object should work base on the `Store` context. For the details of the `Store` context, please refer to the [next chapter](#store).



1. Instantiate and register an `AST module` as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` contexts, developers can instantiate and register an `AST module` contexts into the `Store` context as a named `Module` instance by the `Executor` APIs. After the registration, the result `Module` instance is exported with the given module name and can be linked when instantiating another module. For the details about the `Module` instances APIs, please refer to the [Instances](#instances).



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /*

    * Register the WASM module into the store with the export module name

    * ""mod"".

    */

   Res =

       WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   WasmEdge_StringDelete(ModName);



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST module` contexts, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   /* Create a module instance for host functions. */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""host-module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ModName);

   WasmEdge_StringDelete(ModName);

   /*

    * ...

    * Create and add the host functions, tables, memories, and globals into the

    * module instance.

    */



   /* Register the module instance into store with the exported module name. */

   /* The export module name is in the module instance already. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



3. Instantiate an `AST module` to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` context for linking.



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /* Instantiate the WASM module. */

   WasmEdge_Result Res =

       WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM instantiation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `WasmEdge_ExecutorInvoke()` API.



### AST Module



The `AST Module` context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST Module` context.



```c

WasmEdge_ASTModuleContext *ASTCxt = ...;

/* Assume that a WASM is loaded into an AST module context. */



/* Create the import type context buffers. */

const uint32_t BUF_LEN = 256;

const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];

uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealImportNum =

    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {

  /* Working with the import type `ImpTypes[I]` ... */

}



/* Create the export type context buffers. */

const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];

uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealExportNum =

    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {

  /* Working with the export type `ExpTypes[I]` ... */

}



WasmEdge_ASTModuleDelete(ASTCxt);

/*

 * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be

 * accessed.

 */

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` context in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context.



```c

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



/*

 * ...

 * Register a WASM module via the executor context.

 */



/* Try to list the registered WASM modules. */

uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);

/* Create the name buffers. */

const uint32_t BUF_LEN = 256;

WasmEdge_String ModNames[BUF_LEN];

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);

for (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {

  /* Working with the module name `ModNames[I]` ... */

  /* The module names should __NOT__ be destroyed. */

}



/* Find named module by name. */

WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");

const WasmEdge_ModuleInstanceContext *ModCxt =

    WasmEdge_StoreFindModule(StoreCxt, ModName);

/* If the module with name not found, the `ModCxt` will be NULL. */

WasmEdge_StringDelete(ModName);

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST module` context, developers will get a `Module` instance as the result, and have the responsibility to destroy it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```c

   /*

    * ...

    * Instantiate a WASM module via the executor context and get the `ModCxt`

    * as the output module instance.

    */



   /* Try to list the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String FuncNames[BUF_LEN];

   /*

    * If the list length is larger than the buffer length, the overflowed data

    * will be discarded.

    */

   uint32_t RealFuncNum =

       WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

   for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

     /* Working with the function name `FuncNames[I]` ... */

     /* The function names should __NOT__ be destroyed. */

   }



   /* Try to find the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   /* Function name. */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_FunctionInstanceContext *FuncCxt =

       WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

   /* `FuncCxt` will be `NULL` if the function not found. */

   /*

    * The returned instance is owned by the module instance context and should

    * __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` contexts for host functions and add them into an `Module` instance context for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` contexts through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```c

   /* Retrieve the function instance from the module instance context. */

   WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);

   /*

    * The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be

    * destroyed.

    */



   /*

    * For the function instance creation, please refer to the `Host Function`

    * guide.

    */

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Table` contexts supply APIs to control the data in table instances.



   ```c

   WasmEdge_Limit TabLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   /* Create the table type with limit and the `FuncRef` element type. */

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);

   /* Create the table instance with table type. */

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(TabTypeCxt);

   /* Delete the table type. */

   WasmEdge_TableTypeDelete(TabTypeCxt);

   WasmEdge_Result Res;

   WasmEdge_Value Data;



   TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);

   /*

    * The `TabTypeCxt` got from table instance is owned by the `HostTable` and

    * should __NOT__ be destroyed.

    */

   enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `RefType` will be `WasmEdge_RefType_FuncRef`. */

   Data = WasmEdge_ValueGenFuncRef(5);

   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);

   /* Set the function index 5 to the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);

    */

   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);

   /* Get the FuncRef value of the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);

    */



   uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);

   /* `Size` will be 10. */

   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

   /* Grow the table size of 6, the table size will be 16. */

   /*

    * This will get an ""out of bounds table access"" error because

    * the size (16 + 6) will reach the table limit(20):

    *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

    */



   WasmEdge_TableInstanceDelete(HostTable);

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Memory` contexts supply APIs to control the data in memory instances.



   ```c

   WasmEdge_Limit MemLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 5};

   /* Create the memory type with limit. The memory page size is 64KiB. */

   WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_MemoryTypeCreate(MemLimit);

   /* Create the memory instance with memory type. */

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(MemTypeCxt);

   /* Delete the memory type. */

   WasmEdge_MemoryTypeDelete(MemTypeCxt);

   WasmEdge_Result Res;

   uint8_t Buf[256];



   Buf[0] = 0xAA;

   Buf[1] = 0xBB;

   Buf[2] = 0xCC;

   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);

   /* Set the data[0:2] to the memory[4096:4098]. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */

   Buf[0] = 0;

   Buf[1] = 0;

   Buf[2] = 0;

   Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);

   /* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */



   uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);

   /* `PageSize` will be 1. */

   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);

   /* Grow the page size of 2, the page size of the memory instance will be 3.

    */

   /*

    * This will get an ""out of bounds memory access"" error because

    * the page size (3 + 3) will reach the memory limit(5):

    *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);

    */



   WasmEdge_MemoryInstanceDelete(HostMemory);

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Global` contexts supply APIs to control the value in global instances.



   ```c

   WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);

   /* Create the global type with value type and mutation. */

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_I64, WasmEdge_Mutability_Var);

   /* Create the global instance with value and global type. */

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);

   /* Delete the global type. */

   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   WasmEdge_Result Res;



   GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);

   /* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal`

    * and should __NOT__ be destroyed. */

   enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `ValType` will be `WasmEdge_ValType_I64`. */

   enum WasmEdge_Mutability ValMut =

       WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `ValMut` will be `WasmEdge_Mutability_Var`. */



   WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));

   /*

    * Set the value u64(888) to the global.

    * This function will do nothing if the value type mismatched or

    * the global mutability is `WasmEdge_Mutability_Const`.

    */

   WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);

   /* Get the value (888 now) of the global context. */



   WasmEdge_GlobalInstanceDelete(HostGlobal);

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define C functions with the following function signature as the host function body:



   ```c

   typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

       void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

       const WasmEdge_Value *Params, WasmEdge_Value *Returns);

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```c

   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /*

     * Params: {i32, i32}

     * Returns: {i32}

     * Developers should take care about the function type.

     */

     /* Retrieve the value 1. */

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     /* Retrieve the value 2. */

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     /* Output value 1 is Val1 + Val2. */

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Return the status of success. */

     return WasmEdge_Result_Success;

   }

   ```



   Then developers can create `Function` context with the host function body and the function type:



   ```c

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I32};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

   /* Create a function type: {i32, i32} -> {i32}. */

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   /*

    * Create a function context with the function type and host function body.

    * The `Cost` parameter can be 0 if developers do not need the cost

    * measuring.

    */

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostType);



   /*

    * If the function instance is __NOT__ added into a module instance context,

    * it should be deleted.

    */

   WasmEdge_FunctionInstanceDelete(HostFunc);

   ```



2. Calling frame context



   The `WasmEdge_CallingFrameContext` is the context to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



   ```c

   WasmEdge_Result LoadOffset(void *Data,

                              const WasmEdge_CallingFrameContext *CallFrameCxt,

                              const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /* Function type: {i32} -> {} */

     uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

     uint32_t Num = 0;



     /*

      * Get the 0-th memory instance of the module instance of the top frame on

      * stack.

      */

     WasmEdge_MemoryInstanceContext *MemCxt =

         WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);



     WasmEdge_Result Res =

         WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

     if (WasmEdge_ResultOK(Res)) {

       printf(""u32 at memory[%lu]: %lu\n"", Offset, Num);

     } else {

       return Res;

     }

     return WasmEdge_Result_Success;

   }

   ```



   Besides using the `WasmEdge_CallingFrameGetMemoryInstance()` API to get the memory instance by index in the module instance, developers can use the `WasmEdge_CallingFrameGetModuleInstance()` to get the module instance directly. Therefore, developers can retrieve the exported contexts by the `WasmEdge_ModuleInstanceContext` APIs. And also, developers can use the `WasmEdge_CallingFrameGetExecutor()` API to get the currently used executor context.



3. User-defined error code of the host functions



   In host functions, WasmEdge provides `WasmEdge_Result_Success` to return success, `WasmEdge_Result_Terminate` to terminate the WASM execution, and `WasmEdge_Result_Fail` to return fail. WasmEdge also provides the usage of returning the user-specified codes. Developers can use the `WasmEdge_ResultGen()` API to generate the `WasmEdge_Result` with error code, and use the `WasmEdge_ResultGetCode()` API to get the error code.



   > Notice: The error code only supports 24-bit integer (0 ~ 16777216 in `uint32_t`). The values larger than 24-bit will be truncated.



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32)))

     (import ""extern"" ""trap"" (func $f-trap (type $t0)))

     (func (export ""trap"") (param i32)

       local.get 0

       call $f-trap)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Trap(void *Data,

                        const WasmEdge_CallingFrameContext *CallFrameCxt,

                        const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val = WasmEdge_ValueGetI32(In[0]);

     /* Return the error code from the param[0]. */

     return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x05, 0x01,

                       /* function type {i32} -> {} */

                       0x60, 0x01, 0x7F, 0x00,

                       /* Import section */

                       0x02, 0x0F, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x08, 0x01,

                       /* export name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x08, 0x01,

                       /* code body */

                       0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 1, NULL, 0);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Trap, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""trap"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5566)};

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""trap"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 1, NULL, 0);



     /* Get the result code and print. */

     printf(""Get the error code: %u\n"", WasmEdge_ResultGetCode(Res));



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (giving the expected error code `5566`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   [2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be

   [2022-08-26 15:06:40.384] [error]     When executing function name: ""trap""

   Get the error code: 5566

   ```



4. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```c

   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   /* Create a module instance. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ExportName);

   WasmEdge_StringDelete(ExportName);



   /* Create and add a function instance into the module instance. */

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I32};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data object.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostFType);

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

   WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);

   WasmEdge_StringDelete(FuncName);



   /* Create and add a table instance into the import object. */

   WasmEdge_Limit TableLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *HostTType =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(HostTType);

   WasmEdge_TableTypeDelete(HostTType);

   WasmEdge_String TableName = WasmEdge_StringCreateByCString(""table"");

   WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);

   WasmEdge_StringDelete(TableName);



   /* Create and add a memory instance into the import object. */

   WasmEdge_Limit MemoryLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 2};

   WasmEdge_MemoryTypeContext *HostMType =

       WasmEdge_MemoryTypeCreate(MemoryLimit);

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(HostMType);

   WasmEdge_MemoryTypeDelete(HostMType);

   WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(""memory"");

   WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);

   WasmEdge_StringDelete(MemoryName);



   /* Create and add a global instance into the module instance. */

   WasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_I32, WasmEdge_Mutability_Var);

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));

   WasmEdge_GlobalTypeDelete(HostGType);

   WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(""global"");

   WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);

   WasmEdge_StringDelete(GlobalName);



   /*

    * The module instance should be deleted.

    * Developers should __NOT__ destroy the instances added into the module

    * instance contexts.

    */

   WasmEdge_ModuleInstanceDelete(HostModCxt);

   ```



5. Specified module instance



   `WasmEdge_ModuleInstanceCreateWASI()` API can create and initialize the `WASI` module instance.



   `WasmEdge_ModuleInstanceCreateWasiNN()` API can create and initialize the `wasi_ephemeral_nn` module instance for `WASI-NN` plugin.



   `WasmEdge_ModuleInstanceCreateWasiCryptoCommon()` API can create and initialize the `wasi_ephemeral_crypto_common` module instance for `WASI-Crypto` plugin.



   `WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()` API can create and initialize the `wasi_ephemeral_crypto_asymmetric_common` module instance for `WASI-Crypto` plugin.



   `WasmEdge_ModuleInstanceCreateWasiCryptoKx()` API can create and initialize the `wasi_ephemeral_crypto_kx` module instance for `WASI-Crypto` plugin.



   `WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()` API can create and initialize the `wasi_ephemeral_crypto_signatures` module instance for `WASI-Crypto` plugin.



   `WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()` API can create and initialize the `wasi_ephemeral_crypto_symmetric` module instance for `WASI-Crypto` plugin.



   `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()` API can create and initialize the `wasmedge_process` module instance for `wasmedge_process` plugin.



   Developers can create these module instance contexts and register them into the `Store` or `VM` contexts rather than adjust the settings in the `Configure` contexts.



   > Note: For the `WASI-NN` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-nn-plug-in) are satisfied. Note: For the `WASI-Crypto` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-crypto-plug-in) are satisfied. And the 5 modules are recommended to all be created and registered together.



   ```c

   WasmEdge_ModuleInstanceContext *WasiModCxt =

       WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);

   WasmEdge_ModuleInstanceContext *ProcModCxt =

       WasmEdge_ModuleInstanceCreateWasmEdgeProcess(/* ... ignored */);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   /* Register the WASI and WasmEdge_Process into the VM context. */

   WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);

   WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);

   /* Get the WASI exit code. */

   uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);

   /*

    * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.

    * Otherwise, it will return with the related exit code.

    */

   WasmEdge_VMDelete(VMCxt);

   /* The module instances should be deleted. */

   WasmEdge_ModuleInstanceDelete(WasiModCxt);

   WasmEdge_ModuleInstanceDelete(ProcModCxt);

   ```



6. Example



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                           WasmEdge_ValType_I32};

     enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   ```



7. Host Data Example



   Developers can set a external data object to the `Function` context, and access to the object in the function body. Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Also set the result to the data. */

     int32_t *DataPtr = (int32_t *)Data;

     *DataPtr = Val1 + Val2;

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* The external data object: an integer. */

     int32_t Data;



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                           WasmEdge_ValType_I32};

     enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     printf(""Data value: %d\n"", Data);



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   Data value: 6912

   ```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options.



WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* ... Adjust settings in the configure context. */

  /* Result. */

  WasmEdge_Result Res;



  /* Create the compiler context. The configure context can be NULL. */

  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);

  /* Compile the WASM file with input and output paths. */

  Res = WasmEdge_CompilerCompile(CompilerCxt, ""fibonacci.wasm"",

                                 ""fibonacci-aot.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  WasmEdge_CompilerDelete(CompilerCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  return 0;

}

```



Then you can compile and run (the output file is ""fibonacci-aot.wasm""):



```bash

$ gcc test.c -lwasmedge

$ ./a.out

[2021-07-02 11:08:08.651] [info] compile start

[2021-07-02 11:08:08.653] [info] verify start

[2021-07-02 11:08:08.653] [info] optimize start

[2021-07-02 11:08:08.670] [info] codegen start

[2021-07-02 11:08:08.706] [info] compile done

```



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```c

/// AOT compiler optimization level enumeration.

enum WasmEdge_CompilerOptimizationLevel {

  /// Disable as many optimizations as possible.

  WasmEdge_CompilerOptimizationLevel_O0 = 0,

  /// Optimize quickly without destroying debuggability.

  WasmEdge_CompilerOptimizationLevel_O1,

  /// Optimize for fast execution as much as possible without triggering

  /// significant incremental compile time or code size growth.

  WasmEdge_CompilerOptimizationLevel_O2,

  /// Optimize for fast execution as much as possible.

  WasmEdge_CompilerOptimizationLevel_O3,

  /// Optimize for small code size as much as possible without triggering

  /// significant incremental compile time or execution time slowdowns.

  WasmEdge_CompilerOptimizationLevel_Os,

  /// Optimize for small code size as much as possible.

  WasmEdge_CompilerOptimizationLevel_Oz

};



/// AOT compiler output binary format enumeration.

enum WasmEdge_CompilerOutputFormat {

  /// Native dynamic library format.

  WasmEdge_CompilerOutputFormat_Native = 0,

  /// WebAssembly with AOT compiled codes in custom sections.

  WasmEdge_CompilerOutputFormat_Wasm

};

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/c/reference/0.12.x.md
------


---

sidebar_position: 5

---



# C API 0.12.1 Documentation



[WasmEdge C API](https://github.com/WasmEdge/WasmEdge/blob/0.12.1/include/api/wasmedge/wasmedge.h) denotes an interface to access the WasmEdge runtime at version `0.12.1`. The following are the guides to working with the C APIs of WasmEdge.



**Developers can refer to [here to upgrade to 0.13.0](upgrade_to_0.13.0.md).**



## Table of Contents



- [WasmEdge Installation](#wasmedge-installation)

  - [Download And Install](#download-and-install)

  - [Compile Sources](#compile-sources)

  - [ABI Compatibility](#abi-compatibility)

- [WasmEdge Basics](#wasmedge-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Strings](#strings)

  - [Results](#results)

  - [Contexts](#contexts)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

  - [Tools driver](#tools-driver)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Context](#wasm-execution-example-with-vm-context)

  - [VM Creations](#vm-creations)

  - [Built-in Host Modules and Plug-in Preregistrations](#built-in-host-modules-and-plug-in-preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

  - [Plug-ins](#plug-ins)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## WasmEdge Installation



### Download And Install



The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `wget` as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.12.1

```



For more details, please refer to the [Installation Guide](../../../start/install.md#install) for the WasmEdge installation.



### Compile Sources



After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.



1. Prepare the test C file (and assumed saved as `test.c`):



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

     return 0;

   }

   ```



2. Compile the file with `gcc` or `clang`.



   ```bash

   gcc test.c -lwasmedge

   ```



3. Run and get the expected output.



   ```bash

   $ ./a.out

   WasmEdge version: 0.12.1

   ```



### ABI Compatibility



WasmEdge C API introduces SONAME and SOVERSION since the `0.11.0` release to present the compatibility between different C API versions.



The releases before 0.11.0 are all unversioned. Please make sure the library version is the same as the corresponding C API version you used.



| WasmEdge Version | WasmEdge C API Library Name | WasmEdge C API SONAME | WasmEdge C API SOVERSION |

| --- | --- | --- | --- |

| < 0.11.0 | libwasmedge_c.so | Unversioned | Unversioned |

| 0.11.0 to 0.11.1 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.0 |

| 0.11.2 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.1 |

| Since 0.12.0 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.2 |



## WasmEdge Basics



In this part, we will introduce the utilities and concepts of WasmEdge shared library.



### Version



The `Version` related APIs provide developers to check for the WasmEdge shared library version.



```c

#include <wasmedge/wasmedge.h>

printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

printf(""WasmEdge version major: %u\n"", WasmEdge_VersionGetMajor());

printf(""WasmEdge version minor: %u\n"", WasmEdge_VersionGetMinor());

printf(""WasmEdge version patch: %u\n"", WasmEdge_VersionGetPatch());

```



### Logging Settings



The `WasmEdge_LogSetErrorLevel()` and `WasmEdge_LogSetDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



Developers can also use the `WasmEdge_LogOff()` API to disable all logging.



### Value Types



In WasmEdge, developers should convert the values to `WasmEdge_Value` objects through APIs for matching to the WASM value types.



1. Number types: `i32`, `i64`, `f32`, `f64`, and `v128` for the `SIMD` proposal



   ```c

   WasmEdge_Value Val;

   Val = WasmEdge_ValueGenI32(123456);

   printf(""%d\n"", WasmEdge_ValueGetI32(Val));

   /* Will print ""123456"" */

   Val = WasmEdge_ValueGenI64(1234567890123LL);

   printf(""%ld\n"", WasmEdge_ValueGetI64(Val));

   /* Will print ""1234567890123"" */

   Val = WasmEdge_ValueGenF32(123.456f);

   printf(""%f\n"", WasmEdge_ValueGetF32(Val));

   /* Will print ""123.456001"" */

   Val = WasmEdge_ValueGenF64(123456.123456789);

   printf(""%.10f\n"", WasmEdge_ValueGetF64(Val));

   /* Will print ""123456.1234567890"" */

   ```



2. Reference types: `funcref` and `externref` for the `Reference-Types` proposal



   ```c

   WasmEdge_Value Val;

   void *Ptr;

   bool IsNull;

   uint32_t Num = 10;

   /* Generate a externref to NULL. */

   Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);

   IsNull = WasmEdge_ValueIsNullRef(Val);

   /* The `IsNull` will be `TRUE`. */

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `NULL`. */



   /* Get the function instance by creation or from module instance. */

   const WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   /* Generate a funcref with the given function instance context. */

   Val = WasmEdge_ValueGenFuncRef(FuncCxt);

   const WasmEdge_FunctionInstanceContext *GotFuncCxt =

       WasmEdge_ValueGetFuncRef(Val);

   /* The `GotFuncCxt` will be the same as `FuncCxt`. */



   /* Generate a externref to `Num`. */

   Val = WasmEdge_ValueGenExternRef(&Num);

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `&Num`. */

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""10"" */

   Num += 55;

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""65"" */

   ```



### Strings



The `WasmEdge_String` object is for the instance names when invoking a WASM function or finding the contexts of instances.



1. Create a `WasmEdge_String` from a C string (`const char *` with NULL termination) or a buffer with length.



   The content of the C string or buffer will be copied into the `WasmEdge_String` object.



   ```c

   char Buf[4] = {50, 55, 60, 65};

   WasmEdge_String Str1 = WasmEdge_StringCreateByCString(""test"");

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   /* The objects should be deleted by `WasmEdge_StringDelete()`. */

   WasmEdge_StringDelete(Str1);

   WasmEdge_StringDelete(Str2);

   ```



2. Wrap a `WasmEdge_String` to a buffer with length.



   The content will not be copied, and the caller should guarantee the life cycle of the input buffer.



   ```c

   const char CStr[] = ""test"";

   WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);

   /* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */

   ```



3. String comparison



   ```c

   const char CStr[] = ""abcd"";

   char Buf[4] = {0x61, 0x62, 0x63, 0x64};

   WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);

   /* The `IsEq` will be `TRUE`. */

   WasmEdge_StringDelete(Str2);

   ```



4. Convert to C string



   ```c

   char Buf[256];

   WasmEdge_String Str =

       WasmEdge_StringCreateByCString(""test_wasmedge_string"");

   uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));

   /* StrLength will be 20 */

   printf(""String: %s\n"", Buf);

   /* Will print ""test_wasmedge_string"". */

   ```



### Results



The `WasmEdge_Result` object specifies the execution status. APIs about WASM execution will return the `WasmEdge_Result` to denote the status.



```c

WasmEdge_Result Res = WasmEdge_Result_Success;

bool IsSucceeded = WasmEdge_ResultOK(Res);

/* The `IsSucceeded` will be `TRUE`. */

uint32_t Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 0. */

const char *Msg = WasmEdge_ResultGetMessage(Res);

/* The `Msg` will be ""success"". */

enum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_WASM. */



Res = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);

/* Generate the user-defined result with code. */

Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 123. */

Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */

```



### Contexts



The objects, such as `VM`, `Store`, and `Function`, are composed of `Context`s. All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.



```c

/* Create the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Delete the configure context. */

WasmEdge_ConfigureDelete(ConfCxt);

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `WasmEdge_Limit` struct is defined in the header:



   ```c

   /// Struct of WASM limit.

   typedef struct WasmEdge_Limit {

     /// Boolean to describe has max value or not.

     bool HasMax;

     /// Boolean to describe is shared memory or not.

     bool Shared;

     /// Minimum value.

     uint32_t Min;

     /// Maximum value. Will be ignored if the `HasMax` is false.

     uint32_t Max;

   } WasmEdge_Limit;

   ```



   Developers can initialize the struct by assigning it's value, and the `Max` value is needed to be larger or equal to the `Min` value. The API `WasmEdge_LimitIsEqual()` is provided to compare with 2 `WasmEdge_Limit` structs.



2. Function type context



   The `Function Type` context is used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `Function Type` context APIs to get the parameter or return value types information.



   ```c

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I64};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



   enum WasmEdge_ValType Buf[16];

   uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);

   /* `ParamLen` will be 2. */

   uint32_t GotParamLen =

       WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);

   /* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as

    * `ParamList`. */

   uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);

   /* `ReturnLen` will be 1. */

   uint32_t GotReturnLen =

       WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);

   /* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.

    */



   WasmEdge_FunctionTypeDelete(FuncTypeCxt);

   ```



3. Table type context



   The `Table Type` context is used for `Table` instance creation or getting information from `Table` instances.



   ```c

   WasmEdge_Limit TabLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);



   enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `GotRefType` will be WasmEdge_RefType_ExternRef. */

   WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);

   /* `GotTabLim` will be the same value as `TabLim`. */



   WasmEdge_TableTypeDelete(TabTypeCxt);

   ```



4. Memory type context



   The `Memory Type` context is used for `Memory` instance creation or getting information from `Memory` instances.



   ```c

   WasmEdge_Limit MemLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);



   WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);

   /* `GotMemLim` will be the same value as `MemLim`. */



   WasmEdge_MemoryTypeDelete(MemTypeCxt)

   ```



5. Global type context



   The `Global Type` context is used for `Global` instance creation or getting information from `Global` instances.



   ```c

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_F64, WasmEdge_Mutability_Var);



   WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `GotValType` will be WasmEdge_ValType_F64. */

   WasmEdge_Mutability GotValMut =

       WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `GotValMut` will be WasmEdge_Mutability_Var. */



   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   ```



6. Import type context



   The `Import Type` context is used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `Import Type` context. The details about querying `Import Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ImportTypeContext *ImpType = ...;

   /* Assume that `ImpType` is queried from the `ASTCxt` for the import. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ImportTypeGetExternalType(ImpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or

    * `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);

   WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);

   /*

    * The `ModName` and `ExtName` should not be destroyed and the string

    * buffers are binded into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



7. Export type context



   The `Export Type` context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `Export Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ExportTypeContext *ExpType = ...;

   /* Assume that `ExpType` is queried from the `ASTCxt` for the export. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ExportTypeGetExternalType(ExpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or

    * `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);

   /*

    * The `ExtName` should not be destroyed and the string buffer is binded

    * into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `WasmEdge_Async` object. Developers own the object and should call the `WasmEdge_AsyncDelete()` API to destroy it.



1. Wait for the asynchronous execution



   Developers can wait the execution until finished:



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution. */

   WasmEdge_AsyncWait(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   Or developers can wait for a time limit. If the time limit exceeded, developers can choose to cancel the execution. For the interruptible execution in AOT mode, developers should set `TRUE` through the `WasmEdge_ConfigureCompilerSetInterruptible()` API into the configure context for the AOT compiler.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution for 1 second. */

   bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);

   if (IsEnd) {

     /* The execution finished. Developers can get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);

   } else {

     /*

      * The time limit exceeded. Developers can keep waiting or cancel the

      * execution.

      */

     WasmEdge_AsyncCancel(Async);

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);

     /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */

   }

   WasmEdge_AsyncDelete(Async);

   ```



2. Get the execution result of the asynchronous execution



   Developers can use the `WasmEdge_AsyncGetReturnsLength()` API to get the return value list length. This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return `0`. This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the `WasmEdge_AsyncGet()` API to get the result.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /*

    * Blocking and waiting for the execution and get the return value list

    * length.

    */

   uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   The `WasmEdge_AsyncGet()` API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return values. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_Value Buf[BUF_LEN];

   WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);

   WasmEdge_AsyncDelete(Async);

   ```



### Configurations



The configuration context, `WasmEdge_ConfigureContext`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` context to create other runtime contexts.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` context.



   ```c

   enum WasmEdge_Proposal {

     WasmEdge_Proposal_ImportExportMutGlobals = 0,

     WasmEdge_Proposal_NonTrapFloatToIntConversions,

     WasmEdge_Proposal_SignExtensionOperators,

     WasmEdge_Proposal_MultiValue,

     WasmEdge_Proposal_BulkMemoryOperations,

     WasmEdge_Proposal_ReferenceTypes,

     WasmEdge_Proposal_SIMD,

     WasmEdge_Proposal_TailCall,

     WasmEdge_Proposal_MultiMemories,

     WasmEdge_Proposal_Annotations,

     WasmEdge_Proposal_Memory64,

     WasmEdge_Proposal_ExceptionHandling,

     WasmEdge_Proposal_ExtendedConst,

     WasmEdge_Proposal_Threads,

     WasmEdge_Proposal_FunctionReferences

   };

   ```



   Developers can add or remove the proposals into the `Configure` context.



   ```c

   /*

    * By default, the following proposals have turned on initially:

    * * Import/Export of mutable globals

    * * Non-trapping float-to-int conversions

    * * Sign-extension operators

    * * Multi-value returns

    * * Bulk memory operations

    * * Reference types

    * * Fixed-width SIMD

    *

    * For the current WasmEdge version, the following proposals are supported

    * (turned off by default) additionally:

    * * Tail-call

    * * Multiple memories

    * * Extended-const

    * * Threads

    */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);

   WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);

   bool IsBulkMem = WasmEdge_ConfigureHasProposal(

       ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);

   /* The `IsBulkMem` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` supports and only effective in `VM` contexts.



   The element of this enum is reserved for the other built-in host functions (such as `wasi-socket`) in the future.



   ```c

   enum WasmEdge_HostRegistration {

     WasmEdge_HostRegistration_Wasi = 0

   };

   ```



   The details will be introduced in the [preregistrations of VM context](#built-in-host-modules-and-plug-in-preregistrations).



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `FALSE`. */

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* By default, the maximum memory page size is 65536. */

   WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);

   /*

    * Limit the memory size of each memory instance with not larger than 1024

    * pages (64 MiB).

    */

   PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* The `PageSize` will be 1024. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



4. Forcibly interpreter mode



   If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* By default, The `IsForceInterp` will be `FALSE`. */

   WasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);

   IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* The `IsForceInterp` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



5. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```c

   enum WasmEdge_CompilerOptimizationLevel {

     // Disable as many optimizations as possible.

     WasmEdge_CompilerOptimizationLevel_O0 = 0,

     // Optimize quickly without destroying debuggability.

     WasmEdge_CompilerOptimizationLevel_O1,

     // Optimize for fast execution as much as possible without triggering

     // significant incremental compile time or code size growth.

     WasmEdge_CompilerOptimizationLevel_O2,

     // Optimize for fast execution as much as possible.

     WasmEdge_CompilerOptimizationLevel_O3,

     // Optimize for small code size as much as possible without triggering

     // significant incremental compile time or execution time slowdowns.

     WasmEdge_CompilerOptimizationLevel_Os,

     // Optimize for small code size as much as possible.

     WasmEdge_CompilerOptimizationLevel_Oz

   };



   enum WasmEdge_CompilerOutputFormat {

     // Native dynamic library format.

     WasmEdge_CompilerOutputFormat_Native = 0,

     // WebAssembly with AOT compiled codes in custom section.

     WasmEdge_CompilerOutputFormat_Wasm

   };

   ```



   These configurations are only effective in `Compiler` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the optimization level is O3. */

   WasmEdge_ConfigureCompilerSetOptimizationLevel(

       ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);

   /* By default, the output format is universal WASM. */

   WasmEdge_ConfigureCompilerSetOutputFormat(

       ConfCxt, WasmEdge_CompilerOutputFormat_Native);

   /* By default, the dump IR is `FALSE`. */

   WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);

   /* By default, the generic binary is `FALSE`. */

   WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);

   /* By default, the interruptible is `FALSE`.

   /* Set this option to `TRUE` to support the interruptible execution in AOT

   mode. */

   WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



6. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /*

    * By default, the instruction counting is `FALSE` when running a

    * compiled-WASM or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);

   /*

    * By default, the cost measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);

   /*

    * By default, the time measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



### Statistics



The statistics context, `WasmEdge_StatisticsContext`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` context from the `VM` context, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);

   double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` context. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   uint64_t CostTable[16] = {

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0

   };

   /*

    * Developers can set the costs of each instruction. The value not

    * covered will be 0.

    */

   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



### Tools Driver



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API. The API arguments are the same as the command line arguments of the CLI tools.



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge AOT compiler. */

  return WasmEdge_Driver_Compiler(argc, argv);

}

```



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge runtime tool. */

  return WasmEdge_Driver_Tool(argc, argv);

}

```



## WasmEdge VM



In this partition, we will introduce the functions of `WasmEdge_VMContext` object and show examples of executing WASM functions.



### WASM Execution Example With VM Context



The following shows the example of running the WASM for getting the Fibonacci. This example uses the binary format of [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat), and developers can convert it into the WASM file by the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Run the WASM function from file. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1, Returns, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMRunWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRunWasmFromASTModule()` API.

      */



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 8

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need the WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * Step 4: Execute WASM functions. You can execute functions repeatedly

      * after instantiation.

      */

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 89

   ```



   The following graph explains the status of the `VM` context.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or module instances in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation API accepts the `Configure` context and the `Store` context. If developers only need the default settings, just pass `NULL` to the creation API. The details of the `Store` context will be introduced in [Store](#store).



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);

/* The caller should guarantee the life cycle if the store context. */

WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);

/*

 * The VM context already contains the statistics context and can be retrieved

 * by this API.

 */

/*

 * Note that the retrieved store and statistics contexts from the VM contexts by

 * VM APIs should __NOT__ be destroyed and owned by the VM contexts.

 */

WasmEdge_VMDelete(VMCxt);

WasmEdge_StoreDelete(StoreCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Built-in Host Modules and Plug-in Preregistrations



WasmEdge provides the following built-in host modules and plug-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` context.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   WasmEdge_ConfigureDelete(ConfCxt);

   /*

    * The following API can retrieve the built-in registered module instances

    * from the VM context.

    */

   /*

    * This API will return `NULL` if the corresponding configuration is not set

    * when creating the VM context.

    */

   WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetImportModuleContext(VMCxt,

                                         WasmEdge_HostRegistration_Wasi);

   /* Initialize the WASI. */

   WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);

   WasmEdge_VMDelete(VMCxt);

   ```



   And also can create the WASI module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. Plug-ins



   There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](../../../start/install.md#install-wasmedge-plug-ins-and-dependencies).



   Before using the plug-ins, developers should [load the plug-ins from paths](#load-plug-ins-from-paths).



   The `VM` context will automatically create and register the module of the loaded plug-ins when creation. Furthermore, the following host modules will be mocked if the plug-in not loaded:



   - `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)

   - `wasi_ephemeral_nn`

   - `wasi_snapshot_preview1`

   - `wasmedge_httpsreq`

   - `wasmedge_process`

   - `wasi:logging/logging` (for the `WASI-Logging`)



   When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.



   ```c

   /* Load the plug-ins in the default paths first. */

   WasmEdge_PluginLoadWithDefaultPaths();

   /* Create the configure context and add the WASI configuration. */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   WasmEdge_ConfigureDelete(ConfCxt);

   /*

    * The following API can retrieve the registered modules in the VM context,

    * includes the built-in WASI and the plug-ins.

    */

   /*

    * This API will return `NULL` if the module instance not found.

    */

   WasmEdge_String WasiName =

       WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");

   /* The `WasiModule` will not be `NULL` because the configuration was set. */

   const WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);

   WasmEdge_StringDelete(WasiName);

   WasmEdge_String WasiNNName =

       WasmEdge_StringCreateByCString(""wasi_ephemeral_nn"");

   /*

    * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not

    * installed, because the VM context will mock and register the host

    * modules.

    */

   const WasmEdge_ModuleInstanceContext *WasiNNModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);

   WasmEdge_StringDelete(WasiNNName);



   WasmEdge_VMDelete(VMCxt);

   ```



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, the host functions are composed into host modules as `WasmEdge_ModuleInstanceContext` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` context.



```c

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

WasmEdge_ModuleInstanceContext *WasiModule =

    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);

/* You can also create and register the WASI host modules by this API. */

WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);

/* The result status should be checked. */



/* ... */



WasmEdge_ModuleInstanceDelete(WasiModule);

/*

 * The created module instances should be deleted by the developers when the VM

 * deallocation.

 */

WasmEdge_VMDelete(VMCxt);

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   WasmEdge_Result Res =

       WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

   /*

    * Developers can register the WASM module from buffer with the

    * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from

    * `WasmEdge_ASTModuleContext` object with the

    * `WasmEdge_VMRegisterModuleFromASTModule()` API.

    */

   /*

    * The result status should be checked.

    * The error will occur if the WASM module instantiation failed or the

    * module name conflicts.

    */

   WasmEdge_StringDelete(ModName);

   WasmEdge_VMDelete(VMCxt);

   ```



2. Execute the functions in registered WASM modules



   Assume that the C file `test.c` is as follows:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Names. */

     WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Register the WASM module into VM. */

     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

     /*

      * Developers can register the WASM module from buffer with the

      * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRegisterModuleFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""WASM registration failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

      * name ""mod"". As the same as host functions, other modules can import the

      * function `""mod"" ""fib""`.

      */



     /*

      * Execute WASM functions in registered modules.

      * Unlike the execution of functions, the registered functions can be

      * invoked without `WasmEdge_VMInstantiate()` because the WASM module was

      * instantiated when registering. Developers can also invoke the host

      * functions directly with this API.

      */

     Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,

                                        Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     WasmEdge_StringDelete(ModName);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Asynchronously run the WASM function from file and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.

      */



     /* Wait for the execution. */

     WasmEdge_AsyncWait(Async);

     /*

      * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or

      * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.

      * These APIs will wait until the execution finished.

      */



     /* Check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Asynchronously execute the WASM function and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async =

         WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);

     /*

      * Developers can execute functions repeatedly after instantiation.

      * For invoking the registered functions, you can use the

      * `WasmEdge_VMAsyncExecuteRegistered()` API.

      */



     /* Wait and check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     Res = WasmEdge_AsyncGet(Async, Returns, Arity);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

   }

   ```



   Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` context supplies the APIs to retrieve the instances.



1. Store



   If the `VM` context is created without assigning a `Store` context, the `VM` context will allocate and own a `Store` context.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */

   WasmEdge_VMDelete(VMCxt);

   ```



   Developers can also create the `VM` context with a `Store` context. In this case, developers should guarantee the life cycle of the `Store` context. Please refer to the [Store Contexts](#store) for the details about the `Store` context APIs.



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

   WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);

   /* The `StoreCxt` and the `StoreCxtMock` are the same. */

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `WasmEdge_VMExecute()` API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);



     WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     WasmEdge_VMValidate(VMCxt);

     WasmEdge_VMInstantiate(VMCxt);



     /* List the exported functions. */

     /* Get the number of exported functions. */

     uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);

     /* Create the name buffers and the function type buffers. */

     const uint32_t BUF_LEN = 256;

     WasmEdge_String FuncNames[BUF_LEN];

     WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];

     /*

      * Get the export function list.

      * If the function list length is larger than the buffer length, the

      * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can

      * be NULL if developers don't need them.

      */

     uint32_t RealFuncNum =

         WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);



     for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

       char Buf[BUF_LEN];

       uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

       printf(""Get exported function string length: %u, name: %s\n"", Size,

              Buf);

       /*

        * The function names should be __NOT__ destroyed.

        * The returned function type contexts should __NOT__ be destroyed.

        */

     }

     WasmEdge_StoreDelete(StoreCxt);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get exported function string length: 3, name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` context from the `VM` context and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` context provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   const WasmEdge_FunctionTypeContext *FuncType =

       WasmEdge_VMGetFunctionType(VMCxt, FuncName);

   /*

    * Developers can get the function types of functions in the registered

    * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the

    * module name. If the function is not found, these APIs will return `NULL`.

    * The returned function type contexts should __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` context. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `WasmEdge_VMGetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   const WasmEdge_ModuleInstanceContext *ModCxt =

       WasmEdge_VMGetActiveModule(VMCxt);

   /*

    * If there's no WASM module instantiated, this API will return `NULL`.

    * The returned module instance context should __NOT__ be destroyed.

    */

   ```



5. List and get the registered modules



   To list and retrieve the registered modules in the `VM` context, besides accessing the `store` context of the `VM`, developers can use the following APIs.



   ```c

   /*

    * ...

    * Assume that the `VMCxt` is created.

    */

   WasmEdge_String Names[32];

   uint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);

   for (uint32_t I = 0; I < ModuleLen; I++) {

     /* Will print the registered module names in the VM context. */

     printf(""%s\n"", Names[I].Buf);

   }



   WasmEdge_String WasiName =

       WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");

   /* The `WasiModule` will not be `NULL` because the configuration was set. */

   const WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);

   WasmEdge_StringDelete(WasiName);

   ```



6. Get the components



   The `VM` context is composed by the `Loader`, `Validator`, and `Executor` contexts. For the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the `VM` context. The get contexts are owned by the `VM` context, and developers should not call their delete functions.



   ```c

   WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */

   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` context](#wasmedge-vm), developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` contexts. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /*

   * Create the configure context. This step is not necessary because we didn't

   * adjust any setting.

   */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /*

   * Create the statistics context. This step is not necessary if the statistics

   * in runtime is not needed.

   */

  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

  /*

   * Create the store context. The store context is the object to link the

   * modules for imports and exports.

   */

  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Result. */

  WasmEdge_Result Res;



  /* Create the loader context. The configure context can be NULL. */

  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

  /* Create the validator context. The configure context can be NULL. */

  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

  /*

   * Create the executor context. The configure context and the statistics

   * context can be NULL.

   */

  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);



  /*

   * Load the WASM file or the compiled-WASM file and convert into the AST

   * module context.

   */

  WasmEdge_ASTModuleContext *ASTCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Validate the WASM module. */

  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Instantiate the WASM module into store context. */

  WasmEdge_ModuleInstanceContext *ModCxt = NULL;

  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  /* Try to list the exported functions of the instantiated WASM module. */

  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

  /* Create the name buffers. */

  const uint32_t BUF_LEN = 256;

  WasmEdge_String FuncNames[BUF_LEN];

  /*

   * If the list length is larger than the buffer length, the overflowed data

   * will be discarded.

   */

  uint32_t RealFuncNum =

      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

    char Buf[BUF_LEN];

    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

    printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

    /* The function names should __NOT__ be destroyed. */

  }



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

  /* Find the exported function by function name. */

  WasmEdge_FunctionInstanceContext *FuncCxt =

      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

  if (FuncCxt == NULL) {

    printf(""Function `fib` not found.\n"");

    return 1;

  }

  /* Invoke the WASM function. */

  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_StringDelete(FuncName);

  WasmEdge_ASTModuleDelete(ASTCxt);

  WasmEdge_ModuleInstanceDelete(ModCxt);

  WasmEdge_LoaderDelete(LoadCxt);

  WasmEdge_ValidatorDelete(ValidCxt);

  WasmEdge_ExecutorDelete(ExecCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  WasmEdge_StoreDelete(StoreCxt);

  WasmEdge_StatisticsDelete(StatCxt);

  return 0;

}

```



Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)



```bash

$ gcc test.c -lwasmedge

$ ./a.out

Get exported function string length: 3, name: fib

Get the result: 4181

```



### Loader



The `Loader` context loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```c

uint8_t Buf[4096];

/* ... Read the WASM code to the buffer. */

uint32_t FileSize = ...;

/* The `FileSize` is the length of the WASM code. */



/* Developers can adjust settings in the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);



WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;



/* Load WASM or compiled-WASM from the file. */

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



/* Load WASM or compiled-WASM from the buffer. */

Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Validator



The `Validator` context can validate the WASM module. Every WASM module should be validated before instantiation.



```c

/*

 * ...

 * Assume that the `ASTCxt` is the output AST module context from the loader

 * context.

 * Assume that the `ConfCxt` is the configure context.

 */

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

WasmEdge_ValidatorDelete(ValidCxt);

```



### Executor



The `Executor` context is the executor for both WASM and compiled-WASM. This object should work base on the `Store` context. For the details of the `Store` context, please refer to the [next chapter](#store).



1. Instantiate and register an `AST module` as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` contexts, developers can instantiate and register an `AST module` contexts into the `Store` context as a named `Module` instance by the `Executor` APIs. After the registration, the result `Module` instance is exported with the given module name and can be linked when instantiating another module. For the details about the `Module` instances APIs, please refer to the [Instances](#instances).



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /*

    * Register the WASM module into the store with the export module name

    * ""mod"".

    */

   Res =

       WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   WasmEdge_StringDelete(ModName);



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST module` contexts, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   /* Create a module instance for host functions. */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""host-module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ModName);

   WasmEdge_StringDelete(ModName);

   /*

    * ...

    * Create and add the host functions, tables, memories, and globals into the

    * module instance.

    */



   /* Register the module instance into store with the exported module name. */

   /* The export module name is in the module instance already. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



3. Instantiate an `AST module` to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` context for linking.



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /* Instantiate the WASM module. */

   WasmEdge_Result Res =

       WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM instantiation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `WasmEdge_ExecutorInvoke()` API.



### AST Module



The `AST Module` context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST Module` context.



```c

WasmEdge_ASTModuleContext *ASTCxt = ...;

/* Assume that a WASM is loaded into an AST module context. */



/* Create the import type context buffers. */

const uint32_t BUF_LEN = 256;

const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];

uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealImportNum =

    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {

  /* Working with the import type `ImpTypes[I]` ... */

}



/* Create the export type context buffers. */

const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];

uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealExportNum =

    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {

  /* Working with the export type `ExpTypes[I]` ... */

}



WasmEdge_ASTModuleDelete(ASTCxt);

/*

 * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be

 * accessed.

 */

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` context in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context.



```c

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



/*

 * ...

 * Register a WASM module via the executor context.

 */



/* Try to list the registered WASM modules. */

uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);

/* Create the name buffers. */

const uint32_t BUF_LEN = 256;

WasmEdge_String ModNames[BUF_LEN];

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);

for (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {

  /* Working with the module name `ModNames[I]` ... */

  /* The module names should __NOT__ be destroyed. */

}



/* Find named module by name. */

WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");

const WasmEdge_ModuleInstanceContext *ModCxt =

    WasmEdge_StoreFindModule(StoreCxt, ModName);

/* If the module with name not found, the `ModCxt` will be NULL. */

WasmEdge_StringDelete(ModName);

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST module` context, developers will get a `Module` instance as the result, and have the responsibility to destroy it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```c

   /*

    * ...

    * Instantiate a WASM module via the executor context and get the `ModCxt`

    * as the output module instance.

    */



   /* Try to list the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String FuncNames[BUF_LEN];

   /*

    * If the list length is larger than the buffer length, the overflowed data

    * will be discarded.

    */

   uint32_t RealFuncNum =

       WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

   for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

     /* Working with the function name `FuncNames[I]` ... */

     /* The function names should __NOT__ be destroyed. */

   }



   /* Try to find the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   /* Function name. */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_FunctionInstanceContext *FuncCxt =

       WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

   /* `FuncCxt` will be `NULL` if the function not found. */

   /*

    * The returned instance is owned by the module instance context and should

    * __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` contexts for host functions and add them into an `Module` instance context for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` contexts through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```c

   /* Retrieve the function instance from the module instance context. */

   WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);

   /*

    * The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be

    * destroyed.

    */



   /*

    * For the function instance creation, please refer to the `Host Function`

    * guide.

    */

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Table` contexts supply APIs to control the data in table instances.



   ```c

   WasmEdge_Limit TabLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   /* Create the table type with limit and the `FuncRef` element type. */

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);

   /* Create the table instance with table type. */

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(TabTypeCxt);

   /* Delete the table type. */

   WasmEdge_TableTypeDelete(TabTypeCxt);

   WasmEdge_Result Res;

   WasmEdge_Value Data;



   TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);

   /*

    * The `TabTypeCxt` got from table instance is owned by the `HostTable` and

    * should __NOT__ be destroyed.

    */

   enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `RefType` will be `WasmEdge_RefType_FuncRef`. */

   Data = WasmEdge_ValueGenFuncRef(5);

   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);

   /* Set the function index 5 to the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);

    */

   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);

   /* Get the FuncRef value of the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);

    */



   uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);

   /* `Size` will be 10. */

   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

   /* Grow the table size of 6, the table size will be 16. */

   /*

    * This will get an ""out of bounds table access"" error because

    * the size (16 + 6) will reach the table limit(20):

    *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

    */



   WasmEdge_TableInstanceDelete(HostTable);

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Memory` contexts supply APIs to control the data in memory instances.



   ```c

   WasmEdge_Limit MemLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 5};

   /* Create the memory type with limit. The memory page size is 64KiB. */

   WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_MemoryTypeCreate(MemLimit);

   /* Create the memory instance with memory type. */

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(MemTypeCxt);

   /* Delete the memory type. */

   WasmEdge_MemoryTypeDelete(MemTypeCxt);

   WasmEdge_Result Res;

   uint8_t Buf[256];



   Buf[0] = 0xAA;

   Buf[1] = 0xBB;

   Buf[2] = 0xCC;

   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);

   /* Set the data[0:2] to the memory[4096:4098]. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */

   Buf[0] = 0;

   Buf[1] = 0;

   Buf[2] = 0;

   Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);

   /* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */



   uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);

   /* `PageSize` will be 1. */

   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);

   /* Grow the page size of 2, the page size of the memory instance will be 3.

    */

   /*

    * This will get an ""out of bounds memory access"" error because

    * the page size (3 + 3) will reach the memory limit(5):

    *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);

    */



   WasmEdge_MemoryInstanceDelete(HostMemory);

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Global` contexts supply APIs to control the value in global instances.



   ```c

   WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);

   /* Create the global type with value type and mutation. */

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_I64, WasmEdge_Mutability_Var);

   /* Create the global instance with value and global type. */

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);

   /* Delete the global type. */

   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   WasmEdge_Result Res;



   GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);

   /* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal`

    * and should __NOT__ be destroyed. */

   enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `ValType` will be `WasmEdge_ValType_I64`. */

   enum WasmEdge_Mutability ValMut =

       WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `ValMut` will be `WasmEdge_Mutability_Var`. */



   WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));

   /*

    * Set the value u64(888) to the global.

    * This function will do nothing if the value type mismatched or

    * the global mutability is `WasmEdge_Mutability_Const`.

    */

   WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);

   /* Get the value (888 now) of the global context. */



   WasmEdge_GlobalInstanceDelete(HostGlobal);

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define C functions with the following function signature as the host function body:



   ```c

   typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

       void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

       const WasmEdge_Value *Params, WasmEdge_Value *Returns);

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```c

   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /*

     * Params: {i32, i32}

     * Returns: {i32}

     * Developers should take care about the function type.

     */

     /* Retrieve the value 1. */

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     /* Retrieve the value 2. */

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     /* Output value 1 is Val1 + Val2. */

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Return the status of success. */

     return WasmEdge_Result_Success;

   }

   ```



   Then developers can create `Function` context with the host function body and the function type:



   ```c

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I32};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

   /* Create a function type: {i32, i32} -> {i32}. */

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   /*

    * Create a function context with the function type and host function body.

    * The `Cost` parameter can be 0 if developers do not need the cost

    * measuring.

    */

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostType);



   /*

    * If the function instance is __NOT__ added into a module instance context,

    * it should be deleted.

    */

   WasmEdge_FunctionInstanceDelete(HostFunc);

   ```



2. Calling frame context



   The `WasmEdge_CallingFrameContext` is the context to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



   ```c

   WasmEdge_Result LoadOffset(void *Data,

                              const WasmEdge_CallingFrameContext *CallFrameCxt,

                              const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /* Function type: {i32} -> {} */

     uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

     uint32_t Num = 0;



     /*

      * Get the 0-th memory instance of the module instance of the top frame on

      * stack.

      */

     WasmEdge_MemoryInstanceContext *MemCxt =

         WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);



     WasmEdge_Result Res =

         WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

     if (WasmEdge_ResultOK(Res)) {

       printf(""u32 at memory[%lu]: %lu\n"", Offset, Num);

     } else {

       return Res;

     }

     return WasmEdge_Result_Success;

   }

   ```



   Besides using the `WasmEdge_CallingFrameGetMemoryInstance()` API to get the memory instance by index in the module instance, developers can use the `WasmEdge_CallingFrameGetModuleInstance()` to get the module instance directly. Therefore, developers can retrieve the exported contexts by the `WasmEdge_ModuleInstanceContext` APIs. And also, developers can use the `WasmEdge_CallingFrameGetExecutor()` API to get the currently used executor context.



3. User-defined error code of the host functions



   In host functions, WasmEdge provides `WasmEdge_Result_Success` to return success, `WasmEdge_Result_Terminate` to terminate the WASM execution, and `WasmEdge_Result_Fail` to return fail. WasmEdge also provides the usage of returning the user-specified codes. Developers can use the `WasmEdge_ResultGen()` API to generate the `WasmEdge_Result` with error code, and use the `WasmEdge_ResultGetCode()` API to get the error code.



   > Notice: The error code only supports 24-bit integer (0 ~ 16777216 in `uint32_t`). The values larger than 24-bit will be truncated.



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32)))

     (import ""extern"" ""trap"" (func $f-trap (type $t0)))

     (func (export ""trap"") (param i32)

       local.get 0

       call $f-trap)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Trap(void *Data,

                        const WasmEdge_CallingFrameContext *CallFrameCxt,

                        const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val = WasmEdge_ValueGetI32(In[0]);

     /* Return the error code from the param[0]. */

     return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x05, 0x01,

                       /* function type {i32} -> {} */

                       0x60, 0x01, 0x7F, 0x00,

                       /* Import section */

                       0x02, 0x0F, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x08, 0x01,

                       /* export name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x08, 0x01,

                       /* code body */

                       0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 1, NULL, 0);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Trap, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""trap"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5566)};

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""trap"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 1, NULL, 0);



     /* Get the result code and print. */

     printf(""Get the error code: %u\n"", WasmEdge_ResultGetCode(Res));



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (giving the expected error code `5566`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   [2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be

   [2022-08-26 15:06:40.384] [error]     When executing function name: ""trap""

   Get the error code: 5566

   ```



4. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```c

   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   /* Create a module instance. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ExportName);

   WasmEdge_StringDelete(ExportName);



   /* Create and add a function instance into the module instance. */

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I32};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data object.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostFType);

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

   WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);

   WasmEdge_StringDelete(FuncName);



   /* Create and add a table instance into the import object. */

   WasmEdge_Limit TableLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *HostTType =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(HostTType);

   WasmEdge_TableTypeDelete(HostTType);

   WasmEdge_String TableName = WasmEdge_StringCreateByCString(""table"");

   WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);

   WasmEdge_StringDelete(TableName);



   /* Create and add a memory instance into the import object. */

   WasmEdge_Limit MemoryLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 2};

   WasmEdge_MemoryTypeContext *HostMType =

       WasmEdge_MemoryTypeCreate(MemoryLimit);

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(HostMType);

   WasmEdge_MemoryTypeDelete(HostMType);

   WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(""memory"");

   WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);

   WasmEdge_StringDelete(MemoryName);



   /* Create and add a global instance into the module instance. */

   WasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_I32, WasmEdge_Mutability_Var);

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));

   WasmEdge_GlobalTypeDelete(HostGType);

   WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(""global"");

   WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);

   WasmEdge_StringDelete(GlobalName);



   /*

    * The module instance should be deleted.

    * Developers should __NOT__ destroy the instances added into the module

    * instance contexts.

    */

   WasmEdge_ModuleInstanceDelete(HostModCxt);

   ```



5. Specified module instance



   `WasmEdge_ModuleInstanceCreateWASI()` API can create and initialize the `WASI` module instance.



   Developers can create these module instance contexts and register them into the `Store` or `VM` contexts rather than adjust the settings in the `Configure` contexts.



   ```c

   WasmEdge_ModuleInstanceContext *WasiModCxt =

       WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   /* Register the WASI and WasmEdge_Process into the VM context. */

   WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);

   /* Get the WASI exit code. */

   uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);

   /*

    * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.

    * Otherwise, it will return with the related exit code.

    */

   WasmEdge_VMDelete(VMCxt);

   /* The module instances should be deleted. */

   WasmEdge_ModuleInstanceDelete(WasiModCxt);

   ```



6. Example



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                           WasmEdge_ValType_I32};

     enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   ```



7. Host Data Example



   Developers can set a external data object to the `Function` context, and access to the object in the function body. Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Also set the result to the data. */

     int32_t *DataPtr = (int32_t *)Data;

     *DataPtr = Val1 + Val2;

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* The external data object: an integer. */

     int32_t Data;



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                           WasmEdge_ValType_I32};

     enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     printf(""Data value: %d\n"", Data);



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   Data value: 6912

   ```



### Plug-ins



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



#### Load plug-ins from paths



To use the plug-ins, developers should load the plug-ins from paths first.



```c

WasmEdge_PluginLoadWithDefaultPaths();

```



After calling this API, the plug-ins in the default paths will be loaded. The default paths are:



1. The path given in the environment variable `WASMEDGE_PLUGIN_PATH`.

2. The `../plugin/` directory related to the WasmEdge installation path.

3. The `./wasmedge/` directory under the library path if the WasmEdge is installed under the system directory (such as `/usr` and `/usr/local`).



To load the plug-ins from a specific path or under a specific directory, developers can use this API:



```c

WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plugin.so"");

```



#### Get the plug-in by name



After loading the plug-ins, developers can list the loaded plug-in names.



```c

WasmEdge_PluginLoadWithDefaultPaths();

printf(""Number of loaded plug-ins: %d\n"", WasmEdge_PluginListPluginsLength());



WasmEdge_String Names[20];

uint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);

for (int I = 0; I < NumPlugins; I++) {

  printf(""plug-in %d name: %s\n"", I, Names[I].Buf);

}

```



And developers can retrieve the plug-in context by its name.



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();



const char PluginName[] = ""wasi_crypto"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(PluginName, strlen(PluginName));

const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);

```



#### Create the module instance from a plug-in



With the plug-in context, developers can create the module instances by the module name.



```c

/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */



/* List the available host modules in the plug-in. */

WasmEdge_String Names[20];

uint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);

for (uint32_t I = 0; I < ModuleLen; I++) {

  /* Will print the available host module names in the plug-in. */

  printf(""%s\n"", Names[I].Buf);

}

/*

 * Will print here for the WASI-Crypto plug-in here:

 * wasi_ephemeral_crypto_asymmetric_common

 * wasi_ephemeral_crypto_common

 * wasi_ephemeral_crypto_kx

 * wasi_ephemeral_crypto_signatures

 * wasi_ephemeral_crypto_symmetric

 */



/* Create a module instance from the plug-in by the module name. */

const char ModuleName[] = ""wasi_ephemeral_crypto_common"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));

WasmEdge_ModuleInstance *ModCxt =

    WasmEdge_PluginCreateModule(PluginCxt, NameString);



WasmEdge_ModuleInstanceDelete(ModCxt);

```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options.



WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* ... Adjust settings in the configure context. */

  /* Result. */

  WasmEdge_Result Res;



  /* Create the compiler context. The configure context can be NULL. */

  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);

  /* Compile the WASM file with input and output paths. */

  Res = WasmEdge_CompilerCompile(CompilerCxt, ""fibonacci.wasm"",

                                 ""fibonacci-aot.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  WasmEdge_CompilerDelete(CompilerCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  return 0;

}

```



Then you can compile and run (the output file is ""fibonacci-aot.wasm""):



```bash

$ gcc test.c -lwasmedge

$ ./a.out

[2021-07-02 11:08:08.651] [info] compile start

[2021-07-02 11:08:08.653] [info] verify start

[2021-07-02 11:08:08.653] [info] optimize start

[2021-07-02 11:08:08.670] [info] codegen start

[2021-07-02 11:08:08.706] [info] compile done

```



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```c

/// AOT compiler optimization level enumeration.

enum WasmEdge_CompilerOptimizationLevel {

  /// Disable as many optimizations as possible.

  WasmEdge_CompilerOptimizationLevel_O0 = 0,

  /// Optimize quickly without destroying debuggability.

  WasmEdge_CompilerOptimizationLevel_O1,

  /// Optimize for fast execution as much as possible without triggering

  /// significant incremental compile time or code size growth.

  WasmEdge_CompilerOptimizationLevel_O2,

  /// Optimize for fast execution as much as possible.

  WasmEdge_CompilerOptimizationLevel_O3,

  /// Optimize for small code size as much as possible without triggering

  /// significant incremental compile time or execution time slowdowns.

  WasmEdge_CompilerOptimizationLevel_Os,

  /// Optimize for small code size as much as possible.

  WasmEdge_CompilerOptimizationLevel_Oz

};



/// AOT compiler output binary format enumeration.

enum WasmEdge_CompilerOutputFormat {

  /// Native dynamic library format.

  WasmEdge_CompilerOutputFormat_Native = 0,

  /// WebAssembly with AOT compiled codes in custom sections.

  WasmEdge_CompilerOutputFormat_Wasm

};

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/c/reference/0.13.x.md
------


---

sidebar_position: 3

---



# C API 0.13.5 Documentation



[WasmEdge C API](https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h) denotes an interface to access the WasmEdge runtime at version `0.13.5`. The following are the guides to working with the C APIs of WasmEdge.



## WasmEdge Installation



### Download And Install



The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `wget` as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.13.5

```



For more details, please refer to the [Installation Guide](../../../start/install.md#install) for the WasmEdge installation.



### Compile Sources



After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.



1. Prepare the test C file (and assumed saved as `test.c`):



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

     return 0;

   }

   ```



2. Compile the file with `gcc` or `clang`.



   ```bash

   gcc test.c -lwasmedge

   ```



3. Run and get the expected output.



   ```bash

   $ ./a.out

   WasmEdge version: 0.13.5

   ```



### ABI Compatibility



WasmEdge C API introduces SONAME and SOVERSION since the `0.11.0` release to present the compatibility between different C API versions.



The releases before 0.11.0 are all unversioned. Please make sure the library version is the same as the corresponding C API version you used.



| WasmEdge Version | WasmEdge C API Library Name | WasmEdge C API SONAME | WasmEdge C API SOVERSION |

| --- | --- | --- | --- |

| < 0.11.0 | libwasmedge_c.so | Unversioned | Unversioned |

| 0.11.0 to 0.11.1 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.0 |

| 0.11.2 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.1 |

| 0.12.0 to 0.12.1 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.2 |

| Since 0.13.0 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.3 |



## WasmEdge Basics



In this part, we will introduce the utilities and concepts of WasmEdge shared library.



### Version



The `Version` related APIs provide developers to check for the WasmEdge shared library version.



```c

#include <wasmedge/wasmedge.h>

printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

printf(""WasmEdge version major: %u\n"", WasmEdge_VersionGetMajor());

printf(""WasmEdge version minor: %u\n"", WasmEdge_VersionGetMinor());

printf(""WasmEdge version patch: %u\n"", WasmEdge_VersionGetPatch());

```



### Logging Settings



The `WasmEdge_LogSetErrorLevel()` and `WasmEdge_LogSetDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



Developers can also use the `WasmEdge_LogOff()` API to disable all logging.



### Value Types



In WasmEdge, developers should convert the values to `WasmEdge_Value` objects through APIs for matching to the WASM value types.



1. Number types: `i32`, `i64`, `f32`, `f64`, and `v128` for the `SIMD` proposal



   ```c

   WasmEdge_Value Val;

   Val = WasmEdge_ValueGenI32(123456);

   printf(""%d\n"", WasmEdge_ValueGetI32(Val));

   /* Will print ""123456"" */

   Val = WasmEdge_ValueGenI64(1234567890123LL);

   printf(""%ld\n"", WasmEdge_ValueGetI64(Val));

   /* Will print ""1234567890123"" */

   Val = WasmEdge_ValueGenF32(123.456f);

   printf(""%f\n"", WasmEdge_ValueGetF32(Val));

   /* Will print ""123.456001"" */

   Val = WasmEdge_ValueGenF64(123456.123456789);

   printf(""%.10f\n"", WasmEdge_ValueGetF64(Val));

   /* Will print ""123456.1234567890"" */

   ```



2. Reference types: `funcref` and `externref` for the `Reference-Types` proposal



   ```c

   WasmEdge_Value Val;

   void *Ptr;

   bool IsNull;

   uint32_t Num = 10;

   /* Generate a externref to NULL. */

   Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);

   IsNull = WasmEdge_ValueIsNullRef(Val);

   /* The `IsNull` will be `TRUE`. */

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `NULL`. */



   /* Get the function instance by creation or from module instance. */

   const WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   /* Generate a funcref with the given function instance context. */

   Val = WasmEdge_ValueGenFuncRef(FuncCxt);

   const WasmEdge_FunctionInstanceContext *GotFuncCxt =

       WasmEdge_ValueGetFuncRef(Val);

   /* The `GotFuncCxt` will be the same as `FuncCxt`. */



   /* Generate a externref to `Num`. */

   Val = WasmEdge_ValueGenExternRef(&Num);

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `&Num`. */

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""10"" */

   Num += 55;

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""65"" */

   ```



### Strings



The `WasmEdge_String` object is for the instance names when invoking a WASM function or finding the contexts of instances.



1. Create a `WasmEdge_String` from a C string (`const char *` with NULL termination) or a buffer with length.



   The content of the C string or buffer will be copied into the `WasmEdge_String` object.



   ```c

   char Buf[4] = {50, 55, 60, 65};

   WasmEdge_String Str1 = WasmEdge_StringCreateByCString(""test"");

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   /* The objects should be deleted by `WasmEdge_StringDelete()`. */

   WasmEdge_StringDelete(Str1);

   WasmEdge_StringDelete(Str2);

   ```



2. Wrap a `WasmEdge_String` to a buffer with length.



   The content will not be copied, and the caller should guarantee the life cycle of the input buffer.



   ```c

   const char CStr[] = ""test"";

   WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);

   /* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */

   ```



3. String comparison



   ```c

   const char CStr[] = ""abcd"";

   char Buf[4] = {0x61, 0x62, 0x63, 0x64};

   WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);

   /* The `IsEq` will be `TRUE`. */

   WasmEdge_StringDelete(Str2);

   ```



4. Convert to C string



   ```c

   char Buf[256];

   WasmEdge_String Str =

       WasmEdge_StringCreateByCString(""test_wasmedge_string"");

   uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));

   /* StrLength will be 20 */

   printf(""String: %s\n"", Buf);

   /* Will print ""test_wasmedge_string"". */

   ```



### Results



The `WasmEdge_Result` object specifies the execution status. APIs about WASM execution will return the `WasmEdge_Result` to denote the status.



```c

WasmEdge_Result Res = WasmEdge_Result_Success;

bool IsSucceeded = WasmEdge_ResultOK(Res);

/* The `IsSucceeded` will be `TRUE`. */

uint32_t Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 0. */

const char *Msg = WasmEdge_ResultGetMessage(Res);

/* The `Msg` will be ""success"". */

enum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_WASM. */



Res = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);

/* Generate the user-defined result with code. */

Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 123. */

Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */

```



### Contexts



The objects, such as `VM`, `Store`, and `Function`, are composed of `Context`s. All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.



```c

/* Create the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Delete the configure context. */

WasmEdge_ConfigureDelete(ConfCxt);

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `WasmEdge_Limit` struct is defined in the header:



   ```c

   /// Struct of WASM limit.

   typedef struct WasmEdge_Limit {

     /// Boolean to describe has max value or not.

     bool HasMax;

     /// Boolean to describe is shared memory or not.

     bool Shared;

     /// Minimum value.

     uint32_t Min;

     /// Maximum value. Will be ignored if the `HasMax` is false.

     uint32_t Max;

   } WasmEdge_Limit;

   ```



   Developers can initialize the struct by assigning it's value, and the `Max` value is needed to be larger or equal to the `Min` value. The API `WasmEdge_LimitIsEqual()` is provided to compare with 2 `WasmEdge_Limit` structs.



2. Function type context



   The `Function Type` context is used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `Function Type` context APIs to get the parameter or return value types information.



   ```c

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I64};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



   enum WasmEdge_ValType Buf[16];

   uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);

   /* `ParamLen` will be 2. */

   uint32_t GotParamLen =

       WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);

   /* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as

    * `ParamList`. */

   uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);

   /* `ReturnLen` will be 1. */

   uint32_t GotReturnLen =

       WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);

   /* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.

    */



   WasmEdge_FunctionTypeDelete(FuncTypeCxt);

   ```



3. Table type context



   The `Table Type` context is used for `Table` instance creation or getting information from `Table` instances.



   ```c

   WasmEdge_Limit TabLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);



   enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `GotRefType` will be WasmEdge_RefType_ExternRef. */

   WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);

   /* `GotTabLim` will be the same value as `TabLim`. */



   WasmEdge_TableTypeDelete(TabTypeCxt);

   ```



4. Memory type context



   The `Memory Type` context is used for `Memory` instance creation or getting information from `Memory` instances.



   ```c

   WasmEdge_Limit MemLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);



   WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);

   /* `GotMemLim` will be the same value as `MemLim`. */



   WasmEdge_MemoryTypeDelete(MemTypeCxt)

   ```



5. Global type context



   The `Global Type` context is used for `Global` instance creation or getting information from `Global` instances.



   ```c

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_F64, WasmEdge_Mutability_Var);



   WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `GotValType` will be WasmEdge_ValType_F64. */

   WasmEdge_Mutability GotValMut =

       WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `GotValMut` will be WasmEdge_Mutability_Var. */



   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   ```



6. Import type context



   The `Import Type` context is used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `Import Type` context. The details about querying `Import Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ImportTypeContext *ImpType = ...;

   /* Assume that `ImpType` is queried from the `ASTCxt` for the import. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ImportTypeGetExternalType(ImpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or

    * `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);

   WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);

   /*

    * The `ModName` and `ExtName` should not be destroyed and the string

    * buffers are binded into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



7. Export type context



   The `Export Type` context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `Export Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ExportTypeContext *ExpType = ...;

   /* Assume that `ExpType` is queried from the `ASTCxt` for the export. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ExportTypeGetExternalType(ExpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or

    * `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);

   /*

    * The `ExtName` should not be destroyed and the string buffer is binded

    * into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `WasmEdge_Async` object. Developers own the object and should call the `WasmEdge_AsyncDelete()` API to destroy it.



1. Wait for the asynchronous execution



   Developers can wait the execution until finished:



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution. */

   WasmEdge_AsyncWait(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   Or developers can wait for a time limit. If the time limit exceeded, developers can choose to cancel the execution. For the interruptible execution in AOT mode, developers should set `TRUE` through the `WasmEdge_ConfigureCompilerSetInterruptible()` API into the configure context for the AOT compiler.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution for 1 second. */

   bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);

   if (IsEnd) {

     /* The execution finished. Developers can get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);

   } else {

     /*

      * The time limit exceeded. Developers can keep waiting or cancel the

      * execution.

      */

     WasmEdge_AsyncCancel(Async);

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);

     /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */

   }

   WasmEdge_AsyncDelete(Async);

   ```



2. Get the execution result of the asynchronous execution



   Developers can use the `WasmEdge_AsyncGetReturnsLength()` API to get the return value list length. This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return `0`. This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the `WasmEdge_AsyncGet()` API to get the result.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /*

    * Blocking and waiting for the execution and get the return value list

    * length.

    */

   uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   The `WasmEdge_AsyncGet()` API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return values. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_Value Buf[BUF_LEN];

   WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);

   WasmEdge_AsyncDelete(Async);

   ```



### Configurations



The configuration context, `WasmEdge_ConfigureContext`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler` contexts. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` context to create the runtime contexts.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` context.



   ```c

   enum WasmEdge_Proposal {

     WasmEdge_Proposal_ImportExportMutGlobals = 0,

     WasmEdge_Proposal_NonTrapFloatToIntConversions,

     WasmEdge_Proposal_SignExtensionOperators,

     WasmEdge_Proposal_MultiValue,

     WasmEdge_Proposal_BulkMemoryOperations,

     WasmEdge_Proposal_ReferenceTypes,

     WasmEdge_Proposal_SIMD,

     WasmEdge_Proposal_TailCall,

     WasmEdge_Proposal_MultiMemories,

     WasmEdge_Proposal_Annotations,

     WasmEdge_Proposal_Memory64,

     WasmEdge_Proposal_ExceptionHandling,

     WasmEdge_Proposal_ExtendedConst,

     WasmEdge_Proposal_Threads,

     WasmEdge_Proposal_FunctionReferences

   };

   ```



   Developers can add or remove the proposals into the `Configure` context.



   ```c

   /*

    * By default, the following proposals have turned on initially:

    * * Import/Export of mutable globals

    * * Non-trapping float-to-int conversions

    * * Sign-extension operators

    * * Multi-value returns

    * * Bulk memory operations

    * * Reference types

    * * Fixed-width SIMD

    *

    * For the current WasmEdge version, the following proposals are supported

    * (turned off by default) additionally:

    * * Tail-call

    * * Multiple memories

    * * Extended-const

    * * Threads

    */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);

   WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);

   bool IsBulkMem = WasmEdge_ConfigureHasProposal(

       ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);

   /* The `IsBulkMem` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` supports and only effective in `VM` contexts.



   The element of this enum is reserved for the other built-in host functions (such as `wasi-socket`) in the future.



   ```c

   enum WasmEdge_HostRegistration {

     WasmEdge_HostRegistration_Wasi = 0

   };

   ```



   The details will be introduced in the [preregistrations of VM context](#built-in-host-modules-and-plug-in-preregistrations).



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `FALSE`. */

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* By default, the maximum memory page size is 65536. */

   WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);

   /*

    * Limit the memory size of each memory instance with not larger than 1024

    * pages (64 MiB).

    */

   PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* The `PageSize` will be 1024. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



4. Forcibly interpreter mode



   If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* By default, The `IsForceInterp` will be `FALSE`. */

   WasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);

   IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* The `IsForceInterp` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



5. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```c

   enum WasmEdge_CompilerOptimizationLevel {

     // Disable as many optimizations as possible.

     WasmEdge_CompilerOptimizationLevel_O0 = 0,

     // Optimize quickly without destroying debuggability.

     WasmEdge_CompilerOptimizationLevel_O1,

     // Optimize for fast execution as much as possible without triggering

     // significant incremental compile time or code size growth.

     WasmEdge_CompilerOptimizationLevel_O2,

     // Optimize for fast execution as much as possible.

     WasmEdge_CompilerOptimizationLevel_O3,

     // Optimize for small code size as much as possible without triggering

     // significant incremental compile time or execution time slowdowns.

     WasmEdge_CompilerOptimizationLevel_Os,

     // Optimize for small code size as much as possible.

     WasmEdge_CompilerOptimizationLevel_Oz

   };



   enum WasmEdge_CompilerOutputFormat {

     // Native dynamic library format.

     WasmEdge_CompilerOutputFormat_Native = 0,

     // WebAssembly with AOT compiled codes in custom section.

     WasmEdge_CompilerOutputFormat_Wasm

   };

   ```



   These configurations are only effective in `Compiler` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the optimization level is O3. */

   WasmEdge_ConfigureCompilerSetOptimizationLevel(

       ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);

   /* By default, the output format is universal WASM. */

   WasmEdge_ConfigureCompilerSetOutputFormat(

       ConfCxt, WasmEdge_CompilerOutputFormat_Native);

   /* By default, the dump IR is `FALSE`. */

   WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);

   /* By default, the generic binary is `FALSE`. */

   WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);

   /* By default, the interruptible is `FALSE`.

   /* Set this option to `TRUE` to support the interruptible execution in AOT

   mode. */

   WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



6. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /*

    * By default, the instruction counting is `FALSE` when running a

    * compiled-WASM or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);

   /*

    * By default, the cost measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);

   /*

    * By default, the time measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



### Statistics



The statistics context, `WasmEdge_StatisticsContext`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` context from the `VM` context, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);

   double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` context. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   uint64_t CostTable[16] = {

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0

   };

   /*

    * Developers can set the costs of each instruction. The value not

    * covered will be 0.

    */

   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



## WasmEdge VM



In this partition, we will introduce the functions of `WasmEdge_VMContext` object and show examples of executing WASM functions.



### WASM Execution Example With VM Context



The following shows the example of running the WASM for getting the Fibonacci. This example uses the binary format of [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat), and developers can convert it into the WASM file by the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Run the WASM function from file. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1, Returns, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMRunWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRunWasmFromASTModule()` API.

      */



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 8

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need the WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * Step 4: Execute WASM functions. You can execute functions repeatedly

      * after instantiation.

      */

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 89

   ```



   The following graph explains the status of the `VM` context.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or module instances in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation API accepts the `Configure` context and the `Store` context. If developers only need the default settings, just pass `NULL` to the creation API. The details of the `Store` context will be introduced in [Store](#store).



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);

/* The caller should guarantee the life cycle if the store context. */

WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);

/*

 * The VM context already contains the statistics context and can be retrieved

 * by this API.

 */

/*

 * Note that the retrieved store and statistics contexts from the VM contexts by

 * VM APIs should __NOT__ be destroyed and owned by the VM contexts.

 */

WasmEdge_VMDelete(VMCxt);

WasmEdge_StoreDelete(StoreCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Built-in Host Modules and Plug-in Preregistrations



WasmEdge provides the following built-in host modules and plug-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` context.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   WasmEdge_ConfigureDelete(ConfCxt);

   /*

    * The following API can retrieve the built-in registered module instances

    * from the VM context.

    */

   /*

    * This API will return `NULL` if the corresponding configuration is not set

    * when creating the VM context.

    */

   WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetImportModuleContext(VMCxt,

                                         WasmEdge_HostRegistration_Wasi);

   /* Initialize the WASI. */

   WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);

   WasmEdge_VMDelete(VMCxt);

   ```



   And also can create the WASI module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. Plug-ins



   There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](../../../start/install.md#install-wasmedge-plug-ins-and-dependencies).



   Before using the plug-ins, developers should [load the plug-ins from paths](#load-plug-ins-from-paths).



   The `VM` context will automatically create and register the module of the loaded plug-ins when creation. Furthermore, the following host modules will be mocked if the plug-in not loaded:



   - `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)

   - `wasi_ephemeral_nn`

   - `wasi_snapshot_preview1`

   - `wasmedge_httpsreq`

   - `wasmedge_process`



   When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.



   ```c

   /* Load the plug-ins in the default paths first. */

   WasmEdge_PluginLoadWithDefaultPaths();

   /* Create the configure context and add the WASI configuration. */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   WasmEdge_ConfigureDelete(ConfCxt);

   /*

    * The following API can retrieve the registered modules in the VM context,

    * includes the built-in WASI and the plug-ins.

    */

   /*

    * This API will return `NULL` if the module instance not found.

    */

   WasmEdge_String WasiName =

       WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");

   /* The `WasiModule` will not be `NULL` because the configuration was set. */

   const WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);

   WasmEdge_StringDelete(WasiName);

   WasmEdge_String WasiNNName =

       WasmEdge_StringCreateByCString(""wasi_ephemeral_nn"");

   /*

    * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not

    * installed, because the VM context will mock and register the host

    * modules.

    */

   const WasmEdge_ModuleInstanceContext *WasiNNModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);

   WasmEdge_StringDelete(WasiNNName);



   WasmEdge_VMDelete(VMCxt);

   ```



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, the host functions are composed into host modules as `WasmEdge_ModuleInstanceContext` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details.



In this chapter, we show the example for registering the host modules into a `VM` context. Noticed that the developers should guarantee the availability of the registered module instance, and should delete the module instance when it will not be used.



```c

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

WasmEdge_ModuleInstanceContext *WasiModule =

    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);

/* You can also create and register the WASI host modules by this API. */

WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);

/* The result status should be checked. */



/* ... */



WasmEdge_VMDelete(VMCxt);

WasmEdge_ModuleInstanceDelete(WasiModule);

/*

 * The created module instances should be deleted by the developers when the VM

 * deallocation.

 */

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   WasmEdge_Result Res =

       WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

   /*

    * Developers can register the WASM module from buffer with the

    * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from

    * `WasmEdge_ASTModuleContext` object with the

    * `WasmEdge_VMRegisterModuleFromASTModule()` API.

    */

   /*

    * The result status should be checked.

    * The error will occur if the WASM module instantiation failed or the

    * module name conflicts.

    */

   WasmEdge_StringDelete(ModName);

   WasmEdge_VMDelete(VMCxt);

   ```



2. Execute the functions in registered WASM modules



   Assume that the C file `test.c` is as follows:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Names. */

     WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Register the WASM module into VM. */

     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

     /*

      * Developers can register the WASM module from buffer with the

      * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRegisterModuleFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""WASM registration failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

      * name ""mod"". As the same as host functions, other modules can import the

      * function `""mod"" ""fib""`.

      */



     /*

      * Execute WASM functions in registered modules.

      * Unlike the execution of functions, the registered functions can be

      * invoked without `WasmEdge_VMInstantiate()` because the WASM module was

      * instantiated when registering. Developers can also invoke the host

      * functions directly with this API.

      */

     Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,

                                        Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     WasmEdge_StringDelete(ModName);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Asynchronously run the WASM function from file and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.

      */



     /* Wait for the execution. */

     WasmEdge_AsyncWait(Async);

     /*

      * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or

      * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.

      * These APIs will wait until the execution finished.

      */



     /* Check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBuffer()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Asynchronously execute the WASM function and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async =

         WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);

     /*

      * Developers can execute functions repeatedly after instantiation.

      * For invoking the registered functions, you can use the

      * `WasmEdge_VMAsyncExecuteRegistered()` API.

      */



     /* Wait and check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     Res = WasmEdge_AsyncGet(Async, Returns, Arity);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

   }

   ```



   Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` context supplies the APIs to retrieve the instances.



1. Store



   If the `VM` context is created without assigning a `Store` context, the `VM` context will allocate and own a `Store` context.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */

   WasmEdge_VMDelete(VMCxt);

   ```



   Developers can also create the `VM` context with a `Store` context. In this case, developers should guarantee the life cycle of the `Store` context. Please refer to the [Store Contexts](#store) for the details about the `Store` context APIs.



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

   WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);

   /* The `StoreCxt` and the `StoreCxtMock` are the same. */

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `WasmEdge_VMExecute()` API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);



     WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     WasmEdge_VMValidate(VMCxt);

     WasmEdge_VMInstantiate(VMCxt);



     /* List the exported functions. */

     /* Get the number of exported functions. */

     uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);

     /* Create the name buffers and the function type buffers. */

     const uint32_t BUF_LEN = 256;

     WasmEdge_String FuncNames[BUF_LEN];

     WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];

     /*

      * Get the export function list.

      * If the function list length is larger than the buffer length, the

      * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can

      * be NULL if developers don't need them.

      */

     uint32_t RealFuncNum =

         WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);



     for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

       char Buf[BUF_LEN];

       uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

       printf(""Get exported function string length: %u, name: %s\n"", Size,

              Buf);

       /*

        * The function names should be __NOT__ destroyed.

        * The returned function type contexts should __NOT__ be destroyed.

        */

     }

     WasmEdge_StoreDelete(StoreCxt);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get exported function string length: 3, name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` context from the `VM` context and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` context provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   const WasmEdge_FunctionTypeContext *FuncType =

       WasmEdge_VMGetFunctionType(VMCxt, FuncName);

   /*

    * Developers can get the function types of functions in the registered

    * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the

    * module name. If the function is not found, these APIs will return `NULL`.

    * The returned function type contexts should __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` context. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `WasmEdge_VMGetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   const WasmEdge_ModuleInstanceContext *ModCxt =

       WasmEdge_VMGetActiveModule(VMCxt);

   /*

    * If there's no WASM module instantiated, this API will return `NULL`.

    * The returned module instance context should __NOT__ be destroyed.

    */

   ```



5. List and get the registered modules



   To list and retrieve the registered modules in the `VM` context, besides accessing the `store` context of the `VM`, developers can use the following APIs.



   ```c

   /*

    * ...

    * Assume that the `VMCxt` is created.

    */

   WasmEdge_String Names[32];

   uint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);

   for (uint32_t I = 0; I < ModuleLen; I++) {

     /* Will print the registered module names in the VM context. */

     printf(""%s\n"", Names[I].Buf);

   }



   WasmEdge_String WasiName =

       WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");

   /* The `WasiModule` will not be `NULL` because the configuration was set. */

   const WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);

   WasmEdge_StringDelete(WasiName);

   ```



6. Get the components



   The `VM` context is composed by the `Loader`, `Validator`, and `Executor` contexts. For the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the `VM` context. The get contexts are owned by the `VM` context, and developers should not call their delete functions.



   ```c

   WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */

   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` context](#wasmedge-vm), developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` contexts. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /*

   * Create the configure context. This step is not necessary because we didn't

   * adjust any setting.

   */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /*

   * Create the statistics context. This step is not necessary if the statistics

   * in runtime is not needed.

   */

  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

  /*

   * Create the store context. The store context is the object to link the

   * modules for imports and exports.

   */

  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Result. */

  WasmEdge_Result Res;



  /* Create the loader context. The configure context can be NULL. */

  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

  /* Create the validator context. The configure context can be NULL. */

  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

  /*

   * Create the executor context. The configure context and the statistics

   * context can be NULL.

   */

  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);



  /*

   * Load the WASM file or the compiled-WASM file and convert into the AST

   * module context.

   */

  WasmEdge_ASTModuleContext *ASTCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Validate the WASM module. */

  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Instantiate the WASM module into store context. */

  WasmEdge_ModuleInstanceContext *ModCxt = NULL;

  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  /* Try to list the exported functions of the instantiated WASM module. */

  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

  /* Create the name buffers. */

  const uint32_t BUF_LEN = 256;

  WasmEdge_String FuncNames[BUF_LEN];

  /*

   * If the list length is larger than the buffer length, the overflowed data

   * will be discarded.

   */

  uint32_t RealFuncNum =

      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

    char Buf[BUF_LEN];

    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

    printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

    /* The function names should __NOT__ be destroyed. */

  }



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

  /* Find the exported function by function name. */

  WasmEdge_FunctionInstanceContext *FuncCxt =

      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

  if (FuncCxt == NULL) {

    printf(""Function `fib` not found.\n"");

    return 1;

  }

  /* Invoke the WASM function. */

  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_StringDelete(FuncName);

  WasmEdge_ASTModuleDelete(ASTCxt);

  WasmEdge_ModuleInstanceDelete(ModCxt);

  WasmEdge_LoaderDelete(LoadCxt);

  WasmEdge_ValidatorDelete(ValidCxt);

  WasmEdge_ExecutorDelete(ExecCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  WasmEdge_StoreDelete(StoreCxt);

  WasmEdge_StatisticsDelete(StatCxt);

  return 0;

}

```



Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)



```bash

$ gcc test.c -lwasmedge

$ ./a.out

Get exported function string length: 3, name: fib

Get the result: 4181

```



### Loader



The `Loader` context loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```c

uint8_t Buf[4096];

/* ... Read the WASM code to the buffer. */

uint32_t FileSize = ...;

/* The `FileSize` is the length of the WASM code. */



/* Developers can adjust settings in the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);



WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;



/* Load WASM or compiled-WASM from the file. */

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



/* Load WASM or compiled-WASM from the buffer. */

Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Validator



The `Validator` context can validate the WASM module. Every WASM module should be validated before instantiation.



```c

/*

 * ...

 * Assume that the `ASTCxt` is the output AST module context from the loader

 * context.

 * Assume that the `ConfCxt` is the configure context.

 */

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

WasmEdge_ValidatorDelete(ValidCxt);

```



### Executor



The `Executor` context is the executor for both WASM and compiled-WASM. This object should work base on the `Store` context. For the details of the `Store` context, please refer to the [next chapter](#store).



1. Instantiate and register an `AST module` as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` contexts, developers can instantiate an `AST module` contexts into a named `Module` instance, and register it into the `Store` context. After the registration, the result `Module` instance is exported to the `Store` with the given module name and can be linked when instantiating another module.



   For the details about the `Module` instances APIs, please refer to the [Instances](#instances). The `Store` context is only the linker for searching and linking the exported modules when instantiation. Developers should delete the output `Module` instance when it will no longer be used. When the `Module` instance being deleted, it will automatically unlink to all linked `Store` contexts.



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /*

    * Register the WASM module into the store with the export module name

    * ""mod"".

    */

   Res =

       WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   WasmEdge_StringDelete(ModName);



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST module` contexts, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   /* Create a module instance for host functions. */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""host-module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ModName);

   WasmEdge_StringDelete(ModName);

   /*

    * ...

    * Create and add the host functions, tables, memories, and globals into the

    * module instance.

    */



   /* Register the module instance into store with the exported module name. */

   /* The export module name is in the module instance already. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



3. Instantiate an `AST module` to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` context for linking.



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /* Instantiate the WASM module. */

   WasmEdge_Result Res =

       WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM instantiation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `WasmEdge_ExecutorInvoke()` API.



5. Asynchronously invoke functions



   Such as [executing WASM functions in VM asynchronously](#asynchronous-execution), developers can also invoke a function asynchronously by `Executor` contexts API.



   After getting the `Function` instance, developers will get the `Async` context by calling the `WasmEdge_ExecutorAsyncInvoke()` API. Please refer to the [Async](#async) chapter to work with this context for getting the results.



### AST Module



The `AST Module` context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST Module` context.



```c

WasmEdge_ASTModuleContext *ASTCxt = ...;

/* Assume that a WASM is loaded into an AST module context. */



/* Create the import type context buffers. */

const uint32_t BUF_LEN = 256;

const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];

uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealImportNum =

    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {

  /* Working with the import type `ImpTypes[I]` ... */

}



/* Create the export type context buffers. */

const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];

uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealExportNum =

    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {

  /* Working with the export type `ExpTypes[I]` ... */

}



WasmEdge_ASTModuleDelete(ASTCxt);

/*

 * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be

 * accessed.

 */

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` context in WasmEdge is an object which present the linker to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context, and should delete the `Module` instances registered into the `Store` context if they will not be used anymore.



When the `Store` context being deleted, the linked `Module` instances will automatically unlink to this `Store` context. When a `Module` instance being deleted, it will automatically unlink to all the linked `Store` contexts.



```c

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



/*

 * ...

 * Register a WASM module via the executor context.

 */



/* Try to list the registered WASM modules. */

uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);

/* Create the name buffers. */

const uint32_t BUF_LEN = 256;

WasmEdge_String ModNames[BUF_LEN];

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);

for (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {

  /* Working with the module name `ModNames[I]` ... */

  /* The module names should __NOT__ be destroyed. */

}



/* Find named module by name. */

WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");

const WasmEdge_ModuleInstanceContext *ModCxt =

    WasmEdge_StoreFindModule(StoreCxt, ModName);

/* If the module with name not found, the `ModCxt` will be NULL. */

WasmEdge_StringDelete(ModName);

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST module` context, developers will get a `Module` instance as the result, and have the responsibility to destroy it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```c

   /*

    * ...

    * Instantiate a WASM module via the executor context and get the `ModCxt`

    * as the output module instance.

    */



   /* Try to list the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String FuncNames[BUF_LEN];

   /*

    * If the list length is larger than the buffer length, the overflowed data

    * will be discarded.

    */

   uint32_t RealFuncNum =

       WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

   for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

     /* Working with the function name `FuncNames[I]` ... */

     /* The function names should __NOT__ be destroyed. */

   }



   /* Try to find the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   /* Function name. */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_FunctionInstanceContext *FuncCxt =

       WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

   /* `FuncCxt` will be `NULL` if the function not found. */

   /*

    * The returned instance is owned by the module instance context and should

    * __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` contexts for host functions and add them into an `Module` instance context for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` contexts through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```c

   /* Retrieve the function instance from the module instance context. */

   WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);

   /*

    * The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be

    * destroyed.

    */



   /*

    * For the function instance creation, please refer to the `Host Function`

    * guide.

    */

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Table` contexts supply APIs to control the data in table instances.



   ```c

   WasmEdge_Limit TabLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   /* Create the table type with limit and the `FuncRef` element type. */

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);

   /* Create the table instance with table type. */

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(TabTypeCxt);

   /* Delete the table type. */

   WasmEdge_TableTypeDelete(TabTypeCxt);

   WasmEdge_Result Res;

   WasmEdge_Value Data;



   TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);

   /*

    * The `TabTypeCxt` got from table instance is owned by the `HostTable` and

    * should __NOT__ be destroyed.

    */

   enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `RefType` will be `WasmEdge_RefType_FuncRef`. */

   Data = WasmEdge_ValueGenFuncRef(5);

   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);

   /* Set the function index 5 to the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);

    */

   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);

   /* Get the FuncRef value of the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);

    */



   uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);

   /* `Size` will be 10. */

   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

   /* Grow the table size of 6, the table size will be 16. */

   /*

    * This will get an ""out of bounds table access"" error because

    * the size (16 + 6) will reach the table limit(20):

    *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

    */



   WasmEdge_TableInstanceDelete(HostTable);

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Memory` contexts supply APIs to control the data in memory instances.



   ```c

   WasmEdge_Limit MemLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 5};

   /* Create the memory type with limit. The memory page size is 64KiB. */

   WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_MemoryTypeCreate(MemLimit);

   /* Create the memory instance with memory type. */

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(MemTypeCxt);

   /* Delete the memory type. */

   WasmEdge_MemoryTypeDelete(MemTypeCxt);

   WasmEdge_Result Res;

   uint8_t Buf[256];



   Buf[0] = 0xAA;

   Buf[1] = 0xBB;

   Buf[2] = 0xCC;

   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);

   /* Set the data[0:2] to the memory[4096:4098]. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */

   Buf[0] = 0;

   Buf[1] = 0;

   Buf[2] = 0;

   Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);

   /* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */



   uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);

   /* `PageSize` will be 1. */

   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);

   /* Grow the page size of 2, the page size of the memory instance will be 3.

    */

   /*

    * This will get an ""out of bounds memory access"" error because

    * the page size (3 + 3) will reach the memory limit(5):

    *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);

    */



   WasmEdge_MemoryInstanceDelete(HostMemory);

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Global` contexts supply APIs to control the value in global instances.



   ```c

   WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);

   /* Create the global type with value type and mutation. */

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_I64, WasmEdge_Mutability_Var);

   /* Create the global instance with value and global type. */

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);

   /* Delete the global type. */

   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   WasmEdge_Result Res;



   GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);

   /* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal`

    * and should __NOT__ be destroyed. */

   enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `ValType` will be `WasmEdge_ValType_I64`. */

   enum WasmEdge_Mutability ValMut =

       WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `ValMut` will be `WasmEdge_Mutability_Var`. */



   WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));

   /*

    * Set the value u64(888) to the global.

    * This function will do nothing if the value type mismatched or

    * the global mutability is `WasmEdge_Mutability_Const`.

    */

   WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);

   /* Get the value (888 now) of the global context. */



   WasmEdge_GlobalInstanceDelete(HostGlobal);

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define C functions with the following function signature as the host function body:



   ```c

   typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

       void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

       const WasmEdge_Value *Params, WasmEdge_Value *Returns);

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```c

   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /*

     * Params: {i32, i32}

     * Returns: {i32}

     * Developers should take care about the function type.

     */

     /* Retrieve the value 1. */

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     /* Retrieve the value 2. */

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     /* Output value 1 is Val1 + Val2. */

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Return the status of success. */

     return WasmEdge_Result_Success;

   }

   ```



   Then developers can create `Function` context with the host function body and the function type:



   ```c

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I32};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

   /* Create a function type: {i32, i32} -> {i32}. */

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   /*

    * Create a function context with the function type and host function body.

    * The `Cost` parameter can be 0 if developers do not need the cost

    * measuring.

    */

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostType);



   /*

    * If the function instance is __NOT__ added into a module instance context,

    * it should be deleted.

    */

   WasmEdge_FunctionInstanceDelete(HostFunc);

   ```



2. Calling frame context



   The `WasmEdge_CallingFrameContext` is the context to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



   ```c

   WasmEdge_Result LoadOffset(void *Data,

                              const WasmEdge_CallingFrameContext *CallFrameCxt,

                              const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /* Function type: {i32} -> {} */

     uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

     uint32_t Num = 0;



     /*

      * Get the 0-th memory instance of the module instance of the top frame on

      * stack.

      */

     WasmEdge_MemoryInstanceContext *MemCxt =

         WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);



     WasmEdge_Result Res =

         WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

     if (WasmEdge_ResultOK(Res)) {

       printf(""u32 at memory[%lu]: %lu\n"", Offset, Num);

     } else {

       return Res;

     }

     return WasmEdge_Result_Success;

   }

   ```



   Besides using the `WasmEdge_CallingFrameGetMemoryInstance()` API to get the memory instance by index in the module instance, developers can use the `WasmEdge_CallingFrameGetModuleInstance()` to get the module instance directly. Therefore, developers can retrieve the exported contexts by the `WasmEdge_ModuleInstanceContext` APIs. And also, developers can use the `WasmEdge_CallingFrameGetExecutor()` API to get the currently used executor context.



3. User-defined error code of the host functions



   In host functions, WasmEdge provides `WasmEdge_Result_Success` to return success, `WasmEdge_Result_Terminate` to terminate the WASM execution, and `WasmEdge_Result_Fail` to return fail. WasmEdge also provides the usage of returning the user-specified codes. Developers can use the `WasmEdge_ResultGen()` API to generate the `WasmEdge_Result` with error code, and use the `WasmEdge_ResultGetCode()` API to get the error code.



   > Notice: The error code only supports 24-bit integer (0 ~ 16777216 in `uint32_t`). The values larger than 24-bit will be truncated.



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32)))

     (import ""extern"" ""trap"" (func $f-trap (type $t0)))

     (func (export ""trap"") (param i32)

       local.get 0

       call $f-trap)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Trap(void *Data,

                        const WasmEdge_CallingFrameContext *CallFrameCxt,

                        const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val = WasmEdge_ValueGetI32(In[0]);

     /* Return the error code from the param[0]. */

     return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x05, 0x01,

                       /* function type {i32} -> {} */

                       0x60, 0x01, 0x7F, 0x00,

                       /* Import section */

                       0x02, 0x0F, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x08, 0x01,

                       /* export name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x08, 0x01,

                       /* code body */

                       0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 1, NULL, 0);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Trap, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""trap"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5566)};

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""trap"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 1, NULL, 0);



     /* Get the result code and print. */

     printf(""Get the error code: %u\n"", WasmEdge_ResultGetCode(Res));



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (giving the expected error code `5566`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   [2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be

   [2022-08-26 15:06:40.384] [error]     When executing function name: ""trap""

   Get the error code: 5566

   ```



4. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```c

   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   /* Create a module instance. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ExportName);

   /*

    * Developers can also use the WasmEdge_ModuleInstanceCreateWithData() to

    * create the module instance with the data and its finalizer. It will be

    * introduced later.

    */

   WasmEdge_StringDelete(ExportName);



   /* Create and add a function instance into the module instance. */

   enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                         WasmEdge_ValType_I32};

   enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data object.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostFType);

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

   WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);

   WasmEdge_StringDelete(FuncName);



   /* Create and add a table instance into the import object. */

   WasmEdge_Limit TableLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *HostTType =

       WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(HostTType);

   WasmEdge_TableTypeDelete(HostTType);

   WasmEdge_String TableName = WasmEdge_StringCreateByCString(""table"");

   WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);

   WasmEdge_StringDelete(TableName);



   /* Create and add a memory instance into the import object. */

   WasmEdge_Limit MemoryLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 2};

   WasmEdge_MemoryTypeContext *HostMType =

       WasmEdge_MemoryTypeCreate(MemoryLimit);

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(HostMType);

   WasmEdge_MemoryTypeDelete(HostMType);

   WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(""memory"");

   WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);

   WasmEdge_StringDelete(MemoryName);



   /* Create and add a global instance into the module instance. */

   WasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValType_I32, WasmEdge_Mutability_Var);

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));

   WasmEdge_GlobalTypeDelete(HostGType);

   WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(""global"");

   WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);

   WasmEdge_StringDelete(GlobalName);



   /*

    * The module instance should be deleted.

    * Developers should __NOT__ destroy the instances added into the module

    * instance contexts.

    */

   WasmEdge_ModuleInstanceDelete(HostModCxt);

   ```



5. Specified module instance



   `WasmEdge_ModuleInstanceCreateWASI()` API can create and initialize the `WASI` module instance.



   Developers can create these module instance contexts and register them into the `Store` or `VM` contexts rather than adjust the settings in the `Configure` contexts.



   ```c

   WasmEdge_ModuleInstanceContext *WasiModCxt =

       WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   /* Register the WASI and WasmEdge_Process into the VM context. */

   WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);

   /* Get the WASI exit code. */

   uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);

   /*

    * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.

    * Otherwise, it will return with the related exit code.

    */

   WasmEdge_VMDelete(VMCxt);

   /* The module instances should be deleted. */

   WasmEdge_ModuleInstanceDelete(WasiModCxt);

   ```



6. Example



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                           WasmEdge_ValType_I32};

     enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   ```



7. Host Data Example



   Developers can set a external data object to the `Function` context, and access to the object in the function body. Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Also set the result to the data. */

     int32_t *DataPtr = (int32_t *)Data;

     *DataPtr = Val1 + Val2;

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* The external data object: an integer. */

     int32_t Data;



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                           WasmEdge_ValType_I32};

     enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

         VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     printf(""Data value: %d\n"", Data);



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   Data value: 6912

   ```



8. Host Data in Module Instance with Finalizer



   Besides setting host data into a host function, developers can set and move ownership of host data into a `Module` instance context with its finalizer. This may be useful when implementing the plug-ins.



   ```c

   /* Struct definition. */

   typedef struct Point {

     int X;

     int Y;

   } Point;



   /* Host function body definition. */

   WasmEdge_Result Print(void *Data,

                         const WasmEdge_CallingFrameContext *CallFrameCxt,

                         const WasmEdge_Value *In, WasmEdge_Value *Out) {

     Point *P = (Point *)In;

     printf(""Point: (%d, %d)\n"", P->X, P->Y);

     return WasmEdge_Result_Success;

   }



   /* Finalizer definition. */

   void PointFinalizer(void *Data) {

     if (Data) {

       free((Point *)Data);

     }

   }



   /* Create a module instance with host data and its finalizer. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   Point *Data = (Point *)malloc(sizeof(Point));

   Data->X = 5;

   Data->Y = -5;

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);

   /*

   * When the `HostModCxt` being destroyed, the finalizer will be invoked and the

   * `Data` will be its argument.

   */

   WasmEdge_StringDelete(ExportName);

   ```



### Plug-ins



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



#### Load plug-ins from paths



To use the plug-ins, developers should load the plug-ins from paths first.



```c

WasmEdge_PluginLoadWithDefaultPaths();

```



After calling this API, the plug-ins in the default paths will be loaded. The default paths are:



1. The path given in the environment variable `WASMEDGE_PLUGIN_PATH`.

2. The `../plugin/` directory related to the WasmEdge installation path.

3. The `./wasmedge/` directory under the library path if the WasmEdge is installed under the system directory (such as `/usr` and `/usr/local`).



To load the plug-ins from a specific path or under a specific directory, developers can use this API:



```c

WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plugin.so"");

```



#### Get the plug-in by name



After loading the plug-ins, developers can list the loaded plug-in names.



```c

WasmEdge_PluginLoadWithDefaultPaths();

printf(""Number of loaded plug-ins: %d\n"", WasmEdge_PluginListPluginsLength());



WasmEdge_String Names[20];

uint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);

for (int I = 0; I < NumPlugins; I++) {

  printf(""plug-in %d name: %s\n"", I, Names[I].Buf);

}

```



And developers can retrieve the plug-in context by its name.



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();



const char PluginName[] = ""wasi_crypto"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(PluginName, strlen(PluginName));

const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);

```



#### Create the module instance from a plug-in



With the plug-in context, developers can create the module instances by the module name.



```c

/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */



/* List the available host modules in the plug-in. */

WasmEdge_String Names[20];

uint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);

for (uint32_t I = 0; I < ModuleLen; I++) {

  /* Will print the available host module names in the plug-in. */

  printf(""%s\n"", Names[I].Buf);

}

/*

 * Will print here for the WASI-Crypto plug-in here:

 * wasi_ephemeral_crypto_asymmetric_common

 * wasi_ephemeral_crypto_common

 * wasi_ephemeral_crypto_kx

 * wasi_ephemeral_crypto_signatures

 * wasi_ephemeral_crypto_symmetric

 */



/* Create a module instance from the plug-in by the module name. */

const char ModuleName[] = ""wasi_ephemeral_crypto_common"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));

WasmEdge_ModuleInstance *ModCxt =

    WasmEdge_PluginCreateModule(PluginCxt, NameString);



WasmEdge_ModuleInstanceDelete(ModCxt);

```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options.



WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* ... Adjust settings in the configure context. */

  /* Result. */

  WasmEdge_Result Res;



  /* Create the compiler context. The configure context can be NULL. */

  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);

  /* Compile the WASM file with input and output paths. */

  Res = WasmEdge_CompilerCompile(CompilerCxt, ""fibonacci.wasm"",

                                 ""fibonacci-aot.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  WasmEdge_CompilerDelete(CompilerCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  return 0;

}

```



Then you can compile and run (the output file is ""fibonacci-aot.wasm""):



```bash

$ gcc test.c -lwasmedge

$ ./a.out

[2021-07-02 11:08:08.651] [info] compile start

[2021-07-02 11:08:08.653] [info] verify start

[2021-07-02 11:08:08.653] [info] optimize start

[2021-07-02 11:08:08.670] [info] codegen start

[2021-07-02 11:08:08.706] [info] compile done

```



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```c

/// AOT compiler optimization level enumeration.

enum WasmEdge_CompilerOptimizationLevel {

  /// Disable as many optimizations as possible.

  WasmEdge_CompilerOptimizationLevel_O0 = 0,

  /// Optimize quickly without destroying debuggability.

  WasmEdge_CompilerOptimizationLevel_O1,

  /// Optimize for fast execution as much as possible without triggering

  /// significant incremental compile time or code size growth.

  WasmEdge_CompilerOptimizationLevel_O2,

  /// Optimize for fast execution as much as possible.

  WasmEdge_CompilerOptimizationLevel_O3,

  /// Optimize for small code size as much as possible without triggering

  /// significant incremental compile time or execution time slowdowns.

  WasmEdge_CompilerOptimizationLevel_Os,

  /// Optimize for small code size as much as possible.

  WasmEdge_CompilerOptimizationLevel_Oz

};



/// AOT compiler output binary format enumeration.

enum WasmEdge_CompilerOutputFormat {

  /// Native dynamic library format.

  WasmEdge_CompilerOutputFormat_Native = 0,

  /// WebAssembly with AOT compiled codes in custom sections.

  WasmEdge_CompilerOutputFormat_Wasm

};

```



Please refer to the [AOT compiler options configuration](#configurations) for details.



## WasmEdge CLI Tools



In this partition, we will introduce the C API for triggering the WasmEdge CLI tools.



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API. The API arguments are the same as the command line arguments of the CLI tools.



### Runtime CLI



The `WasmEdge_Driver_Tool()` API presents the same function as running the [`wasmedge run` command](../../../start/build-and-run/run.md).



Noticed that this API presents the old `wasmedge` CLI tool, which is the same as the `wasmedge run` command. For the current unified `wasmedge` CLI, please refer to the [API below](#unified-cli).



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge runtime tool. */

  return WasmEdge_Driver_Tool(argc, argv);

}

```



### Compiler CLI



The `WasmEdge_Driver_Compiler()` API presents the same function as running the [`wasmedge compile` tool](../../../start/build-and-run/aot.md).



Noticed that this API presents the old `wasmedgec` CLI tool, which is the same as the `wasmedge compile` command. For the current unified `wasmedge` CLI, please refer to the [API below](#unified-cli).



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge AOT compiler. */

  return WasmEdge_Driver_Compiler(argc, argv);

}

```



### Unified CLI



The `WasmEdge_Driver_UniTool()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge unified tool. */

  /* (Within both runtime and AOT compiler) */

  return WasmEdge_Driver_UniTool(argc, argv);

}

```



### CLI Helpers for Windows



On Windows platforms, developers can use the `WasmEdge_Driver_ArgvCreate()` and `WasmEdge_Driver_ArgvDelete()` APIs to convert and handle the `UTF-8` command line arguments, or use the `WasmEdge_Driver_SetConsoleOutputCPtoUTF8()` API to set the console output code page to `UTF-8`.








------"
"The following is a markdown document located at /embed/c/reference/0.9.x.md
------


---

sidebar_position: 11

---



# C API 0.9.1 Documentation



[WasmEdge C API](https://github.com/WasmEdge/WasmEdge/blob/0.9.1/include/api/wasmedge/wasmedge.h) denotes an interface to access the WasmEdge runtime at version `0.9.1`. The following are the guides to working with the C APIs of WasmEdge.



**Developers can refer [here to upgrade to 0.10.0](upgrade_to_0.10.0.md).**



## Table of Contents



- [WasmEdge Installation](#wasmedge-installation)

  - [Download And Install](#download-and-install)

  - [Compile Sources](#compile-sources)

- [WasmEdge Basics](#wasmedge-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Strings](#strings)

  - [Results](#results)

  - [Contexts](#contexts)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Context](#wasm-execution-example-with-vm-context)

  - [VM Creations](#vm-creations)

  - [Preregistrations](#preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## WasmEdge Installation



### Download And Install



The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `wget` as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1

```



For more details, please refer to the [Installation Guide](../../../start/install.md#install) for the WasmEdge installation.



### Compile Sources



After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.



1. Prepare the test C file (and assumed saved as `test.c`):



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

     return 0;

   }

   ```



2. Compile the file with `gcc` or `clang`.



   ```bash

   gcc test.c -lwasmedge_c

   ```



3. Run and get the expected output.



   ```bash

   $ ./a.out

   WasmEdge version: 0.9.1

   ```



## WasmEdge Basics



In this part, we will introduce the utilities and concepts of WasmEdge shared library.



### Version



The `Version` related APIs provide developers to check for the WasmEdge shared library version.



```c

#include <wasmedge/wasmedge.h>

printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

printf(""WasmEdge version major: %u\n"", WasmEdge_VersionGetMajor());

printf(""WasmEdge version minor: %u\n"", WasmEdge_VersionGetMinor());

printf(""WasmEdge version patch: %u\n"", WasmEdge_VersionGetPatch());

```



### Logging Settings



The `WasmEdge_LogSetErrorLevel()` and `WasmEdge_LogSetDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



### Value Types



In WasmEdge, developers should convert the values to `WasmEdge_Value` objects through APIs for matching to the WASM value types.



1. Number types: `i32`, `i64`, `f32`, `f64`, and `v128` for the `SIMD` proposal



   ```c

   WasmEdge_Value Val;

   Val = WasmEdge_ValueGenI32(123456);

   printf(""%d\n"", WasmEdge_ValueGetI32(Val));

   /* Will print ""123456"" */

   Val = WasmEdge_ValueGenI64(1234567890123LL);

   printf(""%ld\n"", WasmEdge_ValueGetI64(Val));

   /* Will print ""1234567890123"" */

   Val = WasmEdge_ValueGenF32(123.456f);

   printf(""%f\n"", WasmEdge_ValueGetF32(Val));

   /* Will print ""123.456001"" */

   Val = WasmEdge_ValueGenF64(123456.123456789);

   printf(""%.10f\n"", WasmEdge_ValueGetF64(Val));

   /* Will print ""123456.1234567890"" */

   ```



2. Reference types: `funcref` and `externref` for the `Reference-Types` proposal



   ```c

   WasmEdge_Value Val;

   void *Ptr;

   bool IsNull;

   uint32_t Num = 10;

   /* Generate a externref to NULL. */

   Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);

   IsNull = WasmEdge_ValueIsNullRef(Val);

   /* The `IsNull` will be `TRUE`. */

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `NULL`. */



   /* Generate a funcref with function index 20. */

   Val = WasmEdge_ValueGenFuncRef(20);

   uint32_t FuncIdx = WasmEdge_ValueGetFuncIdx(Val);

   /* The `FuncIdx` will be 20. */



   /* Generate a externref to `Num`. */

   Val = WasmEdge_ValueGenExternRef(&Num);

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `&Num`. */

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""10"" */

   Num += 55;

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""65"" */

   ```



### Strings



The `WasmEdge_String` object is for the instance names when invoking a WASM function or finding the contexts of instances.



1. Create a `WasmEdge_String` from a C string (`const char *` with NULL termination) or a buffer with length.



   The content of the C string or buffer will be copied into the `WasmEdge_String` object.



   ```c

   char Buf[4] = {50, 55, 60, 65};

   WasmEdge_String Str1 = WasmEdge_StringCreateByCString(""test"");

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   /* The objects should be deleted by `WasmEdge_StringDelete()`. */

   WasmEdge_StringDelete(Str1);

   WasmEdge_StringDelete(Str2);

   ```



2. Wrap a `WasmEdge_String` to a buffer with length.



   The content will not be copied, and the caller should guarantee the life cycle of the input buffer.



   ```c

   const char CStr[] = ""test"";

   WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);

   /* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */

   ```



3. String comparison



   ```c

   const char CStr[] = ""abcd"";

   char Buf[4] = {0x61, 0x62, 0x63, 0x64};

   WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);

   /* The `IsEq` will be `TRUE`. */

   WasmEdge_StringDelete(Str2);

   ```



4. Convert to C string



   ```c

   char Buf[256];

   WasmEdge_String Str = WasmEdge_StringCreateByCString(""test_wasmedge_string"");

   uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));

   /* StrLength will be 20 */

   printf(""String: %s\n"", Buf);

   /* Will print ""test_wasmedge_string"". */

   ```



### Results



The `WasmEdge_Result` object specifies the execution status. APIs about WASM execution will return the `WasmEdge_Result` to denote the status.



```c

WasmEdge_Result Res = WasmEdge_Result_Success;

bool IsSucceeded = WasmEdge_ResultOK(Res);

/* The `IsSucceeded` will be `TRUE`. */

uint32_t Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 0. */

const char *Msg = WasmEdge_ResultGetMessage(Res);

/* The `Msg` will be ""success"". */

```



### Contexts



The objects, such as `VM`, `Store`, and `Function`, are composed of `Context`s. All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.



```c

/* Create the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Delete the configure context. */

WasmEdge_ConfigureDelete(ConfCxt);

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `WasmEdge_Limit` struct is defined in the header:



   ```c

   /// Struct of WASM limit.

   typedef struct WasmEdge_Limit {

     /// Boolean to describe has max value or not.

     bool HasMax;

     /// Minimum value.

     uint32_t Min;

     /// Maximum value. Will be ignored if the `HasMax` is false.

     uint32_t Max;

   } WasmEdge_Limit;

   ```



   Developers can initialize the struct by assigning it's value, and the `Max` value is needed to be larger or equal to the `Min` value. The API `WasmEdge_LimitIsEqual()` is provided to compare with 2 `WasmEdge_Limit` structs.



2. Function type context



   The `Function Type` context is used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `Function Type` context APIs to get the parameter or return value types information.



   ```c

   enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };

   enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };

   WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



   enum WasmEdge_ValType Buf[16];

   uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);

   /* `ParamLen` will be 2. */

   uint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);

   /* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as `ParamList`. */

   uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);

   /* `ReturnLen` will be 1. */

   uint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);

   /* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`. */



   WasmEdge_FunctionTypeDelete(FuncTypeCxt);

   ```



3. Table type context



   The `Table Type` context is used for `Table` instance creation or getting information from `Table` instances.



   ```c

   WasmEdge_Limit TabLim = {.HasMax = true, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);



   enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `GotRefType` will be WasmEdge_RefType_ExternRef. */

   WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);

   /* `GotTabLim` will be the same value as `TabLim`. */



   WasmEdge_TableTypeDelete(TabTypeCxt);

   ```



4. Memory type context



   The `Memory Type` context is used for `Memory` instance creation or getting information from `Memory` instances.



   ```c

   WasmEdge_Limit MemLim = {.HasMax = true, .Min = 10, .Max = 20};

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);



   WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);

   /* `GotMemLim` will be the same value as `MemLim`. */



   WasmEdge_MemoryTypeDelete(MemTypeCxt)

   ```



5. Global type context



   The `Global Type` context is used for `Global` instance creation or getting information from `Global` instances.



   ```c

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);



   WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `GotValType` will be WasmEdge_ValType_F64. */

   WasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `GotValMut` will be WasmEdge_Mutability_Var. */



   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   ```



6. Import type context



   The `Import Type` context is used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `Import Type` context. The details about querying `Import Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */

   const WasmEdge_ImportTypeContext *ImpType = ...;

   /* Assume that `ImpType` is queried from the `ASTCxt` for the import. */



   enum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,

    * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);

   WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);

   /* The `ModName` and `ExtName` should not be destroyed and the string buffers are binded into the `ASTCxt`. */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */

   const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */

   const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */

   ```



7. Export type context



   The `Export Type` context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `Export Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */

   const WasmEdge_ExportTypeContext *ExpType = ...;

   /* Assume that `ExpType` is queried from the `ASTCxt` for the export. */



   enum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,

    * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);

   /* The `ExtName` should not be destroyed and the string buffer is binded into the `ASTCxt`. */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */

   const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */

   const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);

   /* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `WasmEdge_Async` object. Developers own the object and should call the `WasmEdge_AsyncDelete()` API to destroy it.



1. Wait for the asynchronous execution



   Developers can wait the execution until finished:



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution. */

   WasmEdge_AsyncWait(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   Or developers can wait for a time limit. If the time limit exceeded, developers can choose to cancel the execution. For the interruptible execution in AOT mode, developers should set `TRUE` through the `WasmEdge_ConfigureCompilerSetInterruptible()` API into the configure context for the AOT compiler.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution for 1 second. */

   bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);

   if (IsEnd) {

     /* The execution finished. Developers can get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);

   } else {

     /* The time limit exceeded. Developers can keep waiting or cancel the execution. */

     WasmEdge_AsyncCancel(Async);

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);

     /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */

   }

   WasmEdge_AsyncDelete(Async);

   ```



2. Get the execution result of the asynchronous execution



   Developers can use the `WasmEdge_AsyncGetReturnsLength()` API to get the return value list length. This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return `0`. This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the `WasmEdge_AsyncGet()` API to get the result.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return value list length. */

   uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   The `WasmEdge_AsyncGet()` API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return values. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_Value Buf[BUF_LEN];

   WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);

   WasmEdge_AsyncDelete(Async);

   ```



### Configurations



The configuration context, `WasmEdge_ConfigureContext`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` context to create other runtime contexts.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` context.



   ```c

   enum WasmEdge_Proposal {

     WasmEdge_Proposal_ImportExportMutGlobals = 0,

     WasmEdge_Proposal_NonTrapFloatToIntConversions,

     WasmEdge_Proposal_SignExtensionOperators,

     WasmEdge_Proposal_MultiValue,

     WasmEdge_Proposal_BulkMemoryOperations,

     WasmEdge_Proposal_ReferenceTypes,

     WasmEdge_Proposal_SIMD,

     WasmEdge_Proposal_TailCall,

     WasmEdge_Proposal_MultiMemories,

     WasmEdge_Proposal_Annotations,

     WasmEdge_Proposal_Memory64,

     WasmEdge_Proposal_ExceptionHandling,

     WasmEdge_Proposal_Threads,

     WasmEdge_Proposal_FunctionReferences

   };

   ```



   Developers can add or remove the proposals into the `Configure` context.



   ```c

   /*

    * By default, the following proposals have turned on initially:

    * * Import/Export of mutable globals

    * * Non-trapping float-to-int conversions

    * * Sign-extension operators

    * * Multi-value returns

    * * Bulk memory operations

    * * Reference types

    * * Fixed-width SIMD

    */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);

   WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);

   bool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);

   /* The `IsBulkMem` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` or `wasmedge_process` supports and only effective in `VM` contexts.



   ```c

   enum WasmEdge_HostRegistration {

     WasmEdge_HostRegistration_Wasi = 0,

     WasmEdge_HostRegistration_WasmEdge_Process

   };

   ```



   The details will be introduced in the [preregistrations of VM context](#preregistrations).



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `FALSE`. */

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* By default, the maximum memory page size is 65536. */

   WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);

   /* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */

   PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* The `PageSize` will be 1024. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



4. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```c

   enum WasmEdge_CompilerOptimizationLevel {

     /// Disable as many optimizations as possible.

     WasmEdge_CompilerOptimizationLevel_O0 = 0,

     /// Optimize quickly without destroying debuggability.

     WasmEdge_CompilerOptimizationLevel_O1,

     /// Optimize for fast execution as much as possible without triggering

     /// significant incremental compile time or code size growth.

     WasmEdge_CompilerOptimizationLevel_O2,

     /// Optimize for fast execution as much as possible.

     WasmEdge_CompilerOptimizationLevel_O3,

     /// Optimize for small code size as much as possible without triggering

     /// significant incremental compile time or execution time slowdowns.

     WasmEdge_CompilerOptimizationLevel_Os,

     /// Optimize for small code size as much as possible.

     WasmEdge_CompilerOptimizationLevel_Oz

   };



   enum WasmEdge_CompilerOutputFormat {

     /// Native dynamic library format.

     WasmEdge_CompilerOutputFormat_Native = 0,

     /// WebAssembly with AOT compiled codes in custom section.

     WasmEdge_CompilerOutputFormat_Wasm

   };

   ```



   These configurations are only effective in `Compiler` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the optimization level is O3. */

   WasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);

   /* By default, the output format is universal WASM. */

   WasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);

   /* By default, the dump IR is `FALSE`. */

   WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);

   /* By default, the generic binary is `FALSE`. */

   WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);

   /* By default, the interruptible is `FALSE`.

   /* Set this option to `TRUE` to support the interruptible execution in AOT mode. */

   WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



5. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the instruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */

   WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);

   /* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */

   WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);

   /* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */

   WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



### Statistics



The statistics context, `WasmEdge_StatisticsContext`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` context from the `VM` context, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /* ....

    * After running the WASM functions with the `Statistics` context

    */

   uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);

   double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` context. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   uint64_t CostTable[16] = {

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0

   };

   /* Developers can set the costs of each instruction. The value not covered will be 0. */

   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);

   /* ....

    * After running the WASM functions with the `Statistics` context

    */

   uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



## WasmEdge VM



In this partition, we will introduce the functions of `WasmEdge_VMContext` object and show examples of executing WASM functions.



### WASM Execution Example With VM Context



The following shows the example of running the WASM for getting the Fibonacci. This example uses the binary format of [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat), and developers can convert it into the WASM file by the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.



```wasm

(module

 (export ""fib"" (func $fib))

 (func $fib (param $n i32) (result i32)

  (if

   (i32.lt_s (get_local $n)(i32.const 2))

   (return (i32.const 1))

  )

  (return

   (i32.add

    (call $fib (i32.sub (get_local $n)(i32.const 2)))

    (call $fib (i32.sub (get_local $n)(i32.const 1)))

   )

  )

 )

)

```



1. Run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Run the WASM function from file. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, ""fibonacci.wasm"", FuncName, Params, 1, Returns, 1);

     /*

      * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.

      */



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 8

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need the WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to replace the

      * instantiated one. In this case, the old module will be cleared, but the registered

      * modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 89

   ```



   The following graph explains the status of the `VM` context.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or import objects in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation API accepts the `Configure` context and the `Store` context. If developers only need the default settings, just pass `NULL` to the creation API. The details of the `Store` context will be introduced in [Store](#store).



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);

/* The caller should guarantee the life cycle if the store context. */

WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);

/* The VM context already contains the statistics context and can be retrieved by this API. */

/*

 * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs

 * should __NOT__ be destroyed and owned by the VM contexts.

 */

WasmEdge_VMDelete(VMCxt);

WasmEdge_StoreDelete(StoreCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Preregistrations



WasmEdge provides the following built-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` context.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /* The following API can retrieve the pre-registration import objects from the VM context. */

   /* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */

   WasmEdge_ImportObjectContext *WasiObject =

     WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);

   /* Initialize the WASI. */

   WasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WASI import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. [WasmEdge_Process](https://crates.io/crates/wasmedge_process_interface)



   This pre-registration is for the process interface for WasmEdge on `Rust` sources. After turning on this pre-registration, the VM will support the `wasmedge_process` host functions.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   /* The following API can retrieve the pre-registration import objects from the VM context. */

   /* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */

   WasmEdge_ImportObjectContext *ProcObject =

     WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);

   /* Initialize the WasmEdge_Process. */

   WasmEdge_ImportObjectInitWasmEdgeProcess(ProcObject, /* ... ignored */ );

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



   And also can create the WasmEdge_Process import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, the host functions are composed into host modules as `WasmEdge_ImportObjectContext` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` context.



```c

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

WasmEdge_ImportObjectContext *WasiObject =

  WasmEdge_ImportObjectCreateWASI( /* ... ignored ... */ );

/* You can also create and register the WASI host modules by this API. */

WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObject);

/* The result status should be checked. */

WasmEdge_ImportObjectDelete(WasiObject);

/* The created import objects should be deleted. */

WasmEdge_VMDelete(VMCxt);

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

   /*

    * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,

    * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.

    */

   /*

    * The result status should be checked.

    * The error will occur if the WASM module instantiation failed or the module name conflicts.

    */

   WasmEdge_StringDelete(ModName);

   WasmEdge_VMDelete(VMCxt);

   ```



2. Execute the functions in registered WASM modules



   Assume that the C file `test.c` is as follows:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };

     WasmEdge_Value Returns[1];

     /* Names. */

     WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Register the WASM module into VM. */

     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

     /*

     * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,

     * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.

     */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

     * The function ""fib"" in the ""fibonacci.wasm"" was exported with the module name ""mod"".

     * As the same as host functions, other modules can import the function `""mod"" ""fib""`.

     */



     /*

     * Execute WASM functions in registered modules.

     * Unlike the execution of functions, the registered functions can be invoked without

     * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.

     * Developers can also invoke the host functions directly with this API.

     */

     Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     WasmEdge_StringDelete(ModName);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 10946

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, ""fibonacci.wasm"", FuncName, Params, 1);

     /*

      * Developers can run the WASM binary from buffer with the `WasmEdge_VMAsyncRunWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMAsyncRunWasmFromASTModule()` API.

      */



     /* Wait for the execution. */

     WasmEdge_AsyncWait(Async);

     /*

      * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or `WasmEdge_AsyncGet()` APIs

      * to wait for the asynchronous execution. These APIs will wait until the execution finished.

      */



     /* Check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */



     /* Get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,

      * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to replace the

      * instantiated one. In this case, the old module will be cleared, but the registered

      * modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);

     /*

      * Developers can execute functions repeatedly after instantiation.

      * For invoking the registered functions, you can use the `WasmEdge_VMAsyncExecuteRegistered()` API.

      */



     /* Wait and check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */



     /* Get the result. */

     Res = WasmEdge_AsyncGet(Async, Returns, Arity);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

   }

   ```



   Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` context supplies the APIs to retrieve the instances.



1. Store



   If the `VM` context is created without assigning a `Store` context, the `VM` context will allocate and own a `Store` context.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */

   WasmEdge_VMDelete(VMCxt);

   ```



   Developers can also create the `VM` context with a `Store` context. In this case, developers should guarantee the life cycle of the `Store` context. Please refer to the [Store Contexts](#store) for the details about the `Store` context APIs.



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

   WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);

   /* The `StoreCxt` and the `StoreCxtMock` are the same. */

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `WasmEdge_VMExecute()` API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);



     WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     WasmEdge_VMValidate(VMCxt);

     WasmEdge_VMInstantiate(VMCxt);



     /* List the exported functions. */

     /* Get the number of exported functions. */

     uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);

     /* Create the name buffers and the function type buffers. */

     const uint32_t BUF_LEN = 256;

     WasmEdge_String FuncNames[BUF_LEN];

     WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];

     /*

      * Get the export function list.

      * If the function list length is larger than the buffer length, the overflowed data will be discarded.

      * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.

      */

     uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);



     for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

       char Buf[BUF_LEN];

       uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

       printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

       /*

        * The function names should be __NOT__ destroyed.

        * The returned function type contexts should __NOT__ be destroyed.

        */

     }

     return 0;

   }

   ```



   Then you can compile and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Get exported function string length: 3, name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` context from the `VM` context and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` context provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   const WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);

   /*

    * Developers can get the function types of functions in the registered modules

    * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.

    * If the function is not found, these APIs will return `NULL`.

    * The returned function type contexts should __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` context](#wasmedge-vm), developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` contexts. Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */

  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

  /* Create the store context. The store context is the WASM runtime structure core. */

  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Result. */

  WasmEdge_Result Res;



  /* Create the loader context. The configure context can be NULL. */

  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

  /* Create the validator context. The configure context can be NULL. */

  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

  /* Create the executor context. The configure context and the statistics context can be NULL. */

  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);



  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */

  WasmEdge_ASTModuleContext *ASTCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Validate the WASM module. */

  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Instantiate the WASM module into store context. */

  Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  /* Try to list the exported functions of the instantiated WASM module. */

  uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);

  /* Create the name buffers. */

  const uint32_t BUF_LEN = 256;

  WasmEdge_String FuncNames[BUF_LEN];

  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */

  uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);

  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

    char Buf[BUF_LEN];

    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

    printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

    /* The function names should __NOT__ be destroyed. */

  }



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

  /* Invoke the WASM function. */

  Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_StringDelete(FuncName);

  WasmEdge_ASTModuleDelete(ASTCxt);

  WasmEdge_LoaderDelete(LoadCxt);

  WasmEdge_ValidatorDelete(ValidCxt);

  WasmEdge_ExecutorDelete(ExecCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  WasmEdge_StoreDelete(StoreCxt);

  WasmEdge_StatisticsDelete(StatCxt);

  return 0;

}

```



Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)



```bash

$ gcc test.c -lwasmedge_c

$ ./a.out

Get exported function string length: 3, name: fib

Get the result: 4181

```



### Loader



The `Loader` context loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```c

uint8_t Buf[4096];

/* ... Read the WASM code to the buffer. */

uint32_t FileSize = ...;

/* The `FileSize` is the length of the WASM code. */



/* Developers can adjust settings in the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);



WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;



/* Load WASM or compiled-WASM from the file. */

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



/* Load WASM or compiled-WASM from the buffer. */

Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Validator



The `Validator` context can validate the WASM module. Every WASM module should be validated before instantiation.



```c

/*

 * ...

 * Assume that the `ASTCxt` is the output AST module context from the loader context.

 * Assume that the `ConfCxt` is the configure context.

 */

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

WasmEdge_ValidatorDelete(ValidCxt);

```



### Executor



The `Executor` context is the executor for both WASM and compiled-WASM. This object should work base on the `Store` context. For the details of the `Store` context, please refer to the [next chapter](#store).



1. Register modules



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` context, developers can register `Import Object` or `AST module` contexts into the `Store` context by the `Executor` APIs. For the details of import objects, please refer to the [Host Functions](#host-functions).



   ```c

   /*

   * ...

   * Assume that the `ASTCxt` is the output AST module context from the loader context

   * and has passed the validation.

   * Assume that the `ConfCxt` is the configure context.

   */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /* Create the executor context. The configure and the statistics contexts can be NULL. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /* Create the store context. The store context is the WASM runtime structure core. */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   /* Register the WASM module into store with the export module name ""mod"". */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   WasmEdge_StringDelete(ModName);



   /*

    * Assume that the `ImpCxt` is the import object context for host functions.

    */

   WasmEdge_ImportObjectContext *ImpCxt = ...;

   /* The import module context has already contained the export module name. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Import object registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }



   WasmEdge_ImportObjectDelete(ImpCxt);

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



2. Instantiate modules



   WASM or compiled-WASM modules should be instantiated before the function invocation. Note that developers can only instantiate one module into the `Store` context, and in that case, the old instantiated module will be cleaned. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` context.



   ```c

   /*

   * ...

   * Assume that the `ASTCxt` is the output AST module context from the loader context

   * and has passed the validation.

   * Assume that the `ConfCxt` is the configure context.

   */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /* Create the executor context. The configure and the statistics contexts can be NULL. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /* Create the store context. The store context is the WASM runtime structure core. */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



   /* Instantiate the WASM module. */

   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM instantiation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }



   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



3. Invoke functions



   As the same as function invocation via the `VM` context, developers can invoke the functions of the instantiated or registered modules. The APIs, `WasmEdge_ExecutorInvoke()` and `WasmEdge_ExecutorInvokeRegistered()`, are similar as the APIs of the `VM` context. Please refer to the [VM context workflows](#wasm-execution-example-with-vm-context) for details.



### AST Module



The `AST Module` context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST Module` context.



```c

WasmEdge_ASTModuleContext *ASTCxt = ...;

/* Assume that a WASM is loaded into an AST module context. */



/* Create the import type context buffers. */

const uint32_t BUF_LEN = 256;

const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];

uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);

/* If the list length is larger than the buffer length, the overflowed data will be discarded. */

uint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {

  /* Working with the import type `ImpTypes[I]` ... */

}



/* Create the export type context buffers. */

const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];

uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);

/* If the list length is larger than the buffer length, the overflowed data will be discarded. */

uint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {

  /* Working with the export type `ExpTypes[I]` ... */

}



WasmEdge_ASTModuleDelete(ASTCxt);

/* After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be accessed. */

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all instances of `Function`s, `Table`s, `Memory`s, and `Global`s that have been allocated during the lifetime of the abstract machine. The `Store` context in WasmEdge provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into `Store` contexts, please instantiate or register WASM modules or `Import Object` contexts via the `Executor` context.



1. List instances



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* ... Instantiate a WASM module via the executor context. */

   ...



   /* Try to list the exported functions of the instantiated WASM module. */

   /* Take the function instances for example here. */

   uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String FuncNames[BUF_LEN];

   /* If the list length is larger than the buffer length, the overflowed data will be discarded. */

   uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);

   for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

     /* Working with the function name `FuncNames[I]` ... */

     /* The function names should __NOT__ be destroyed. */

   }

   ```



   Developers can list the function instance exported names of the registered modules via the `WasmEdge_StoreListFunctionRegisteredLength()` and the `WasmEdge_StoreListFunctionRegistered()` APIs with the module name.



2. Find instances



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* ... Instantiate a WASM module via the executor context. */

   ...



   /* Try to find the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   /* Function name. */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);

   /* `FuncCxt` will be `NULL` if the function not found. */

   /* The returned instance is owned by the store context and should __NOT__ be destroyed. */

   WasmEdge_StringDelete(FuncName);

   ```



   Developers can retrieve the exported function instances of the registered modules via the `WasmEdge_StoreFindFunctionRegistered()` API with the module name.



3. List registered modules



   With the module names, developers can list the exported instances of the registered modules with their names.



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* ... Register a WASM module via the executor context. */

   ...



   /* Try to list the registered WASM modules. */

   uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String ModNames[BUF_LEN];

   /* If the list length is larger than the buffer length, the overflowed data will be discarded. */

   uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);

   for (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {

     /* Working with the module name `ModNames[I]` ... */

     /* The module names should __NOT__ be destroyed. */

   }

   ```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the instances from the `Store` contexts. The `Store` contexts will allocate instances when a WASM module or `Import Object` is registered or instantiated through the `Executor`. A single instance can be allocated by its creation function. Developers can construct instances into an `Import Object` for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed, EXCEPT they are added into an `Import Object` context.



1. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` contexts for host functions and add them into an `Import Object` context for registering into a `VM` or a `Store`. For both host functions and the functions get from `Store`, developers can retrieve the `Function Type` from the `Function` contexts. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```c

   /* Retrieve the function instance from the store context. */

   WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);

   /* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */

   ```



2. Table instance



   In WasmEdge, developers can create the `Table` contexts and add them into an `Import Object` context for registering into a `VM` or a `Store`. The `Table` contexts supply APIs to control the data in table instances.



   ```c

   WasmEdge_Limit TabLimit = {.HasMax = true, .Min = 10, .Max = 20};

   /* Create the table type with limit and the `FuncRef` element type. */

   WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);

   /* Create the table instance with table type. */

   WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);

   /* Delete the table type. */

   WasmEdge_TableTypeDelete(TabTypeCxt);

   WasmEdge_Result Res;

   WasmEdge_Value Data;



   TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);

   /* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */

   enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   /* `RefType` will be `WasmEdge_RefType_FuncRef`. */

   Data = WasmEdge_ValueGenFuncRef(5);

   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);

   /* Set the function index 5 to the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);

    */

   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);

   /* Get the FuncRef value of the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);

    */



   uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);

   /* `Size` will be 10. */

   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

   /* Grow the table size of 6, the table size will be 16. */

   /*

    * This will get an ""out of bounds table access"" error because

    * the size (16 + 6) will reach the table limit(20):

    *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

    */



   WasmEdge_TableInstanceDelete(HostTable);

   ```



3. Memory instance



   In WasmEdge, developers can create the `Memory` contexts and add them into an `Import Object` context for registering into a `VM` or a `Store`. The `Memory` contexts supply APIs to control the data in memory instances.



   ```c

   WasmEdge_Limit MemLimit = {.HasMax = true, .Min = 1, .Max = 5};

   /* Create the memory type with limit. The memory page size is 64KiB. */

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);

   /* Create the memory instance with memory type. */

   WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);

   /* Delete the memory type. */

   WasmEdge_MemoryTypeDelete(MemTypeCxt);

   WasmEdge_Result Res;

   uint8_t Buf[256];



   Buf[0] = 0xAA;

   Buf[1] = 0xBB;

   Buf[2] = 0xCC;

   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);

   /* Set the data[0:2] to the memory[4096:4098]. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */

   Buf[0] = 0;

   Buf[1] = 0;

   Buf[2] = 0;

   Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);

   /* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */



   uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);

   /* `PageSize` will be 1. */

   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);

   /* Grow the page size of 2, the page size of the memory instance will be 3. */

   /*

    * This will get an ""out of bounds memory access"" error because

    * the page size (3 + 3) will reach the memory limit(5):

    *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);

    */



   WasmEdge_MemoryInstanceDelete(HostMemory);

   ```



4. Global instance



   In WasmEdge, developers can create the `Global` contexts and add them into an `Import Object` context for registering into a `VM` or a `Store`. The `Global` contexts supply APIs to control the value in global instances.



   ```c

   WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);

   /* Create the global type with value type and mutation. */

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);

   /* Create the global instance with value and global type. */

   WasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);

   /* Delete the global type. */

   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   WasmEdge_Result Res;



   GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);

   /* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */

   enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   /* `ValType` will be `WasmEdge_ValType_I64`. */

   enum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `ValMut` will be `WasmEdge_Mutability_Var`. */



   WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));

   /*

    * Set the value u64(888) to the global.

    * This function will do nothing if the value type mismatched or

    * the global mutability is `WasmEdge_Mutability_Const`.

    */

   WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);

   /* Get the value (888 now) of the global context. */



   WasmEdge_GlobalInstanceDelete(HostGlobal);

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` contexts and add them into an `Import Object` context for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define C functions with the following function signature as the host function body:



   ```c

   typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

     void *Data,

     WasmEdge_MemoryInstanceContext *MemCxt,

     const WasmEdge_Value *Params,

     WasmEdge_Value *Returns);

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```c

   WasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /*

     * Params: {i32, i32}

     * Returns: {i32}

     * Developers should take care about the function type.

     */

     /* Retrieve the value 1. */

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     /* Retrieve the value 2. */

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     /* Output value 1 is Val1 + Val2. */

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Return the status of success. */

     return WasmEdge_Result_Success;

   }

   ```



   Then developers can create `Function` context with the host function body and function type:



   ```c

   enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

   enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

   /* Create a function type: {i32, i32} -> {i32}. */

   HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   /*

    * Create a function context with the function type and host function body.

    * The `Cost` parameter can be 0 if developers do not need the cost measuring.

    */

   WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */



   /* If the function instance is not added into an import object context, it should be deleted. */

   WasmEdge_FunctionInstanceDelete(HostFunc);

   ```



2. Import object context



   The `Import Object` context holds an exporting module name and the instances. Developers can add the `Function`, `Memory`, `Table`, and `Global` instances with their exporting names.



   ```c

   /* Host function body definition. */

   WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   /* Create the import object. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);

   WasmEdge_StringDelete(ExportName);



   /* Create and add a function instance into the import object. */

   enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

   enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

   WasmEdge_FunctionTypeContext *HostFType =

     WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   WasmEdge_FunctionInstanceContext *HostFunc =

     WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data object.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostFType);

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

   WasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);

   WasmEdge_StringDelete(FuncName);



   /* Create and add a table instance into the import object. */

   WasmEdge_Limit TableLimit = {.HasMax = true, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *HostTType =

     WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);

   WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);

   WasmEdge_TableTypeDelete(HostTType);

   WasmEdge_String TableName = WasmEdge_StringCreateByCString(""table"");

   WasmEdge_ImportObjectAddTable(ImpObj, TableName, HostTable);

   WasmEdge_StringDelete(TableName);



   /* Create and add a memory instance into the import object. */

   WasmEdge_Limit MemoryLimit = {.HasMax = true, .Min = 1, .Max = 2};

   WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);

   WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);

   WasmEdge_MemoryTypeDelete(HostMType);

   WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(""memory"");

   WasmEdge_ImportObjectAddMemory(ImpObj, MemoryName, HostMemory);

   WasmEdge_StringDelete(MemoryName);



   /* Create and add a global instance into the import object. */

   WasmEdge_GlobalTypeContext *HostGType =

     WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);

   WasmEdge_GlobalInstanceContext *HostGlobal =

     WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));

   WasmEdge_GlobalTypeDelete(HostGType);

   WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(""global"");

   WasmEdge_ImportObjectAddGlobal(ImpObj, GlobalName, HostGlobal);

   WasmEdge_StringDelete(GlobalName);



   /*

    * The import objects should be deleted.

    * Developers should __NOT__ destroy the instances added into the import object contexts.

    */

   WasmEdge_ImportObjectDelete(ImpObj);

   ```



3. Specified import object



   `WasmEdge_ImportObjectCreateWASI()` API can create and initialize the `WASI` import object. `WasmEdge_ImportObjectCreateWasmEdgeProcess()` API can create and initialize the `wasmedge_process` import object. Developers can create these import object contexts and register them into the `Store` or `VM` contexts rather than adjust the settings in the `Configure` contexts.



   ```c

   WasmEdge_ImportObjectContext *WasiObj = WasmEdge_ImportObjectCreateWASI( /* ... ignored */ );

   WasmEdge_ImportObjectContext *ProcObj = WasmEdge_ImportObjectCreateWasmEdgeProcess( /* ... ignored */ );

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   /* Register the WASI and WasmEdge_Process into the VM context. */

   WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObj);

   WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcObj);

   /* Get the WASI exit code. */

   uint32_t ExitCode = WasmEdge_ImportObjectWASIGetExitCode(WasiObj);

   /*

    * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.

    * Otherwise, it will return with the related exit code.

    */

   WasmEdge_VMDelete(VMCxt);

   /* The import objects should be deleted. */

   WasmEdge_ImportObjectDelete(WasiObj);

   WasmEdge_ImportObjectDelete(ProcObj);

   ```



4. Example



   Assume that a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B

     };



     /* Create the import object. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

     enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

     WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

       VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ImportObjectDelete(ImpObj);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   ```



5. Host Data Example



   Developers can set a external data object to the function context, and access to the object in the function body. Assume that a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Also set the result to the data. */

     int32_t *DataPtr = (int32_t *)Data;

     *DataPtr = Val1 + Val2;

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B

     };



     /* The external data object: an integer. */

     int32_t Data;



     /* Create the import object. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);

     enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

     enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

     WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from buffer. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

       VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     printf(""Data value: %d\n"", Data);



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ImportObjectDelete(ImpObj);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge_c

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   Data value: 6912

   ```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options.



WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* ... Adjust settings in the configure context. */

  /* Result. */

  WasmEdge_Result Res;



  /* Create the compiler context. The configure context can be NULL. */

  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);

  /* Compile the WASM file with input and output paths. */

  Res = WasmEdge_CompilerCompile(CompilerCxt, ""fibonacci.wasm"", ""fibonacci.wasm.so"");

  if (!WasmEdge_ResultOK(Res)) {

      printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

      return 1;

  }



  WasmEdge_CompilerDelete(CompilerCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  return 0;

}

```



Then you can compile and run (the output file is ""fibonacci.wasm.so""):



```bash

$ gcc test.c -lwasmedge_c

$ ./a.out

[2021-07-02 11:08:08.651] [info] compile start

[2021-07-02 11:08:08.653] [info] verify start

[2021-07-02 11:08:08.653] [info] optimize start

[2021-07-02 11:08:08.670] [info] codegen start

[2021-07-02 11:08:08.706] [info] compile done

```



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```c

/// AOT compiler optimization level enumeration.

enum WasmEdge_CompilerOptimizationLevel {

  /// Disable as many optimizations as possible.

  WasmEdge_CompilerOptimizationLevel_O0 = 0,

  /// Optimize quickly without destroying debuggability.

  WasmEdge_CompilerOptimizationLevel_O1,

  /// Optimize for fast execution as much as possible without triggering

  /// significant incremental compile time or code size growth.

  WasmEdge_CompilerOptimizationLevel_O2,

  /// Optimize for fast execution as much as possible.

  WasmEdge_CompilerOptimizationLevel_O3,

  /// Optimize for small code size as much as possible without triggering

  /// significant incremental compile time or execution time slowdowns.

  WasmEdge_CompilerOptimizationLevel_Os,

  /// Optimize for small code size as much as possible.

  WasmEdge_CompilerOptimizationLevel_Oz

};



/// AOT compiler output binary format enumeration.

enum WasmEdge_CompilerOutputFormat {

  /// Native dynamic library format.

  WasmEdge_CompilerOutputFormat_Native = 0,

  /// WebAssembly with AOT compiled codes in custom sections.

  WasmEdge_CompilerOutputFormat_Wasm

};

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/c/reference/latest.md
------


---

sidebar_position: 1

---



# C API 0.14.1 Documentation



[WasmEdge C API](https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h) denotes an interface to access the WasmEdge runtime at version `{{ wasmedge_version }}`. The following are the guides to working with the C APIs of WasmEdge.



## WasmEdge Installation



### Download And Install



The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `wget` as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_version }}

```



For more details, please refer to the [Installation Guide](../../../start/install.md#install) for the WasmEdge installation.



### Compile Sources



After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.



1. Prepare the test C file (and assumed saved as `test.c`):



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

     return 0;

   }

   ```



2. Compile the file with `gcc` or `clang`.



   ```bash

   gcc test.c -lwasmedge

   ```



3. Run and get the expected output.



   ```bash

   $ ./a.out

   WasmEdge version: {{ wasmedge_version }}

   ```



### ABI Compatibility



WasmEdge C API introduces SONAME and SOVERSION since the `0.11.0` release to present the compatibility between different C API versions.



The releases before 0.11.0 are all unversioned. Please make sure the library version is the same as the corresponding C API version you used.



| WasmEdge Version | WasmEdge C API Library Name | WasmEdge C API SONAME | WasmEdge C API SOVERSION |

| --- | --- | --- | --- |

| < 0.11.0 | libwasmedge_c.so | Unversioned | Unversioned |

| 0.11.0 to 0.11.1 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.0 |

| 0.11.2 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.1 |

| 0.12.0 to 0.12.1 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.2 |

| 0.13.0 to 0.13.5 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.0.3 |

| Since 0.14.0 | libwasmedge.so | libwasmedge.so.0 | libwasmedge.so.0.1.0 |



## WasmEdge Basics



In this part, we will introduce the utilities and concepts of WasmEdge shared library.



### Version



The `Version` related APIs provide developers to check for the WasmEdge shared library version.



```c

#include <wasmedge/wasmedge.h>

printf(""WasmEdge version: %s\n"", WasmEdge_VersionGet());

printf(""WasmEdge version major: %u\n"", WasmEdge_VersionGetMajor());

printf(""WasmEdge version minor: %u\n"", WasmEdge_VersionGetMinor());

printf(""WasmEdge version patch: %u\n"", WasmEdge_VersionGetPatch());

```



### Logging Settings



The `WasmEdge_LogSetErrorLevel()` and `WasmEdge_LogSetDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



Developers can also use the `WasmEdge_LogOff()` API to disable all logging.



### Value Types



To describe the value types in WASM, WasmEdge uses the `WasmEdge_ValType` struct to encode the value types.



1. Number types: `i32`, `i64`, `f32`, `f64`, and `v128` for the `SIMD` proposal



   ```c

   WasmEdge_ValType ValType;

   ValType = WasmEdge_ValTypeGenI32();

   bool IsTypeI32 = WasmEdge_ValTypeIsI32(ValType);

   /* The `IsTypeI32` will be `TRUE`. */

   ValType = WasmEdge_ValTypeGenI64();

   bool IsTypeI64 = WasmEdge_ValTypeIsI64(ValType);

   /* The `IsTypeI64` will be `TRUE`. */

   ValType = WasmEdge_ValTypeGenF32();

   bool IsTypeF32 = WasmEdge_ValTypeIsF32(ValType);

   /* The `IsTypeF32` will be `TRUE`. */

   ValType = WasmEdge_ValTypeGenF64();

   bool IsTypeF64 = WasmEdge_ValTypeIsF64(ValType);

   /* The `IsTypeF64` will be `TRUE`. */

   ValType = WasmEdge_ValTypeGenV128();

   bool IsTypeV128 = WasmEdge_ValTypeIsV128(ValType);

   /* The `IsTypeV128` will be `TRUE`. */

   ```



2. Reference types: `funcref` and `externref` for the `Reference-Types` or `Typed-Function References` proposal



   ```c

   WasmEdge_ValType ValType;



   ValType = WasmEdge_ValTypeGenFuncRef();

   /* The nullable funcref type is generated. */

   bool IsTypeFuncRef = WasmEdge_ValTypeIsFuncRef(ValType);

   /* The `IsTypeFuncRef` will be `TRUE`. */

   bool IsTypeRef = WasmEdge_ValTypeIsRef(ValType);

   /* The `IsTypeRef` will be `TRUE`. */

   bool IsTypeNullableRef = WasmEdge_ValTypeIsRefNull(ValType);

   /* The `IsTypeNullableRef` will be `TRUE`. */



   ValType = WasmEdge_ValTypeGenExternRef();

   /* The nullable externref type is generated. */

   bool IsTypeExternRef = WasmEdge_ValTypeIsExternRef(ValType);

   /* The `IsTypeExternRef` will be `TRUE`. */

   IsTypeRef = WasmEdge_ValTypeIsRef(ValType);

   /* The `IsTypeRef` will be `TRUE`. */

   IsTypeNullableRef = WasmEdge_ValTypeIsRefNull(ValType);

   /* The `IsTypeNullableRef` will be `TRUE`. */

   ```



### Values



In WasmEdge, developers should convert the values to `WasmEdge_Value` objects through APIs for matching to the WASM values for the arguments or returns. With the APIs, the output `WasmEdge_Value` objects will record the correct value types with values.



1. Number types: `i32`, `i64`, `f32`, `f64`, and `v128` for the `SIMD` proposal



   ```c

   WasmEdge_Value Val;



   Val = WasmEdge_ValueGenI32(123456);

   bool IsTypeI32 = WasmEdge_ValTypeIsI32(Val.Type);

   /* The `IsTypeI32` will be `TRUE`. */

   printf(""%d\n"", WasmEdge_ValueGetI32(Val));

   /* Will print ""123456"" */



   Val = WasmEdge_ValueGenI64(1234567890123LL);

   bool IsTypeI64 = WasmEdge_ValTypeIsI64(Val.Type);

   /* The `IsTypeI64` will be `TRUE`. */

   printf(""%ld\n"", WasmEdge_ValueGetI64(Val));

   /* Will print ""1234567890123"" */



   Val = WasmEdge_ValueGenF32(123.456f);

   bool IsTypeF32 = WasmEdge_ValTypeIsF32(Val.Type);

   /* The `IsTypeF32` will be `TRUE`. */

   printf(""%f\n"", WasmEdge_ValueGetF32(Val));

   /* Will print ""123.456001"" */



   Val = WasmEdge_ValueGenF64(123456.123456789);

   bool IsTypeF64 = WasmEdge_ValTypeIsF64(Val.Type);

   /* The `IsTypeF64` will be `TRUE`. */

   printf(""%.10f\n"", WasmEdge_ValueGetF64(Val));

   /* Will print ""123456.1234567890"" */

   ```



2. Reference types: `funcref` and `externref` for the `Reference-Types` or `Typed-Function References` proposal



   ```c

   WasmEdge_Value Val;

   void *Ptr;

   uint32_t Num = 10;

   /* Generate an externref to NULL. */

   Val = WasmEdge_ValueGenExternRef(NULL);

   bool IsNull = WasmEdge_ValueIsNullRef(Val);

   /* The `IsNull` will be `TRUE`. */

   bool IsTypeExternRef = WasmEdge_ValTypeIsExternRef(Val.Type);

   /* The `IsTypeExternRef` will be `TRUE`. */

   bool IsTypeRef = WasmEdge_ValTypeIsRef(Val.Type);

   /* The `IsTypeRef` will be `TRUE`. */

   bool IsTypeNullableRef = WasmEdge_ValTypeIsRefNull(Val.Type);

   /* The `IsTypeNullableRef` will be `TRUE`. */

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `NULL`. */



   /* Get the function instance by creation or from module instance. */

   const WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   /* Generate a funcref with the given function instance context. */

   Val = WasmEdge_ValueGenFuncRef(FuncCxt);

   bool IsTypeFuncRef = WasmEdge_ValTypeIsFuncRef(Val.Type);

   /* The `IsTypeFuncRef` will be `TRUE`. */

   IsTypeRef = WasmEdge_ValTypeIsRef(Val.Type);

   /* The `IsTypeRef` will be `TRUE`. */

   IsTypeNullableRef = WasmEdge_ValTypeIsRefNull(Val.Type);

   /* The `IsTypeNullableRef` will be `TRUE`. */

   const WasmEdge_FunctionInstanceContext *GotFuncCxt =

       WasmEdge_ValueGetFuncRef(Val);

   /* The `GotFuncCxt` will be the same as `FuncCxt`. */



   /* Generate a externref to `Num`. */

   Val = WasmEdge_ValueGenExternRef(&Num);

   Ptr = WasmEdge_ValueGetExternRef(Val);

   /* The `Ptr` will be `&Num`. */

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""10"" */

   Num += 55;

   printf(""%u\n"", *(uint32_t *)Ptr);

   /* Will print ""65"" */

   ```



### Buffers



The `WasmEdge_Bytes` object is for the input buffer of loading or compiling module from memory, or the output buffer of serializing a module.



<!-- prettier-ignore -->

:::note

This object is designed for replacing raw buffer as input and output of WasmEdge C API. We recommand developers to use the `WasmEdge_Bytes` related APIs than the raw buffer, such as using `WasmEdge_LoaderParseFromBytes()` instead of `WasmEdge_LoaderParseFromBuffer()`.

:::



1. Create a `WasmEdge_Bytes` from a buffer with length.



   ```c

   uint8_t Buf[4] = {1, 2, 3, 4};

   WasmEdge_Bytes Bytes = WasmEdge_BytesCreate(Buf, 4);

   /* The objects should be deleted by `WasmEdge_BytesDelete()`. */

   WasmEdge_BytesDelete(Bytes);

   ```



2. Wrap a `WasmEdge_Bytes` to a buffer with length.



   The content will not be copied, and the caller should guarantee the life cycle of the input buffer.



   ```c

   uint8_t Buf[4] = {1, 2, 3, 4};

   WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(Buf, 4);

   /* The object should __NOT__ be deleted by `WasmEdge_BytesDelete()`. */

   ```



### Strings



The `WasmEdge_String` object is for the instance names when invoking a WASM function or finding the contexts of instances.



1. Create a `WasmEdge_String` from a C string (`const char *` with NULL termination) or a buffer with length.



   The content of the C string or buffer will be copied into the `WasmEdge_String` object.



   ```c

   char Buf[4] = {50, 55, 60, 65};

   WasmEdge_String Str1 = WasmEdge_StringCreateByCString(""test"");

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   /* The objects should be deleted by `WasmEdge_StringDelete()`. */

   WasmEdge_StringDelete(Str1);

   WasmEdge_StringDelete(Str2);

   ```



2. Wrap a `WasmEdge_String` to a buffer with length.



   The content will not be copied, and the caller should guarantee the life cycle of the input buffer.



   ```c

   const char CStr[] = ""test"";

   WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);

   /* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */

   ```



3. String comparison



   ```c

   const char CStr[] = ""abcd"";

   char Buf[4] = {0x61, 0x62, 0x63, 0x64};

   WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);

   WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);

   bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);

   /* The `IsEq` will be `TRUE`. */

   WasmEdge_StringDelete(Str2);

   ```



4. Convert to C string



   ```c

   char Buf[256];

   WasmEdge_String Str =

       WasmEdge_StringCreateByCString(""test_wasmedge_string"");

   uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));

   /* StrLength will be 20 */

   printf(""String: %s\n"", Buf);

   /* Will print ""test_wasmedge_string"". */

   ```



### Results



The `WasmEdge_Result` object specifies the execution status. APIs about WASM execution will return the `WasmEdge_Result` to denote the status.



```c

WasmEdge_Result Res = WasmEdge_Result_Success;

bool IsSucceeded = WasmEdge_ResultOK(Res);

/* The `IsSucceeded` will be `TRUE`. */

uint32_t Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 0. */

const char *Msg = WasmEdge_ResultGetMessage(Res);

/* The `Msg` will be ""success"". */

enum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_WASM. */



Res = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);

/* Generate the user-defined result with code. */

Code = WasmEdge_ResultGetCode(Res);

/* The `Code` will be 123. */

Category = WasmEdge_ResultGetCategory(Res);

/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */

```



### Contexts



The objects, such as `VM`, `Store`, and `Function`, are composed of `Context`s. All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.



```c

/* Create the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Delete the configure context. */

WasmEdge_ConfigureDelete(ConfCxt);

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `WasmEdge_Limit` struct is defined in the header:



   ```c

   /// Struct of WASM limit.

   typedef struct WasmEdge_Limit {

     /// Boolean to describe has max value or not.

     bool HasMax;

     /// Boolean to describe is shared memory or not.

     bool Shared;

     /// Minimum value.

     uint32_t Min;

     /// Maximum value. Will be ignored if the `HasMax` is false.

     uint32_t Max;

   } WasmEdge_Limit;

   ```



   Developers can initialize the struct by assigning it's value, and the `Max` value is needed to be larger or equal to the `Min` value. The API `WasmEdge_LimitIsEqual()` is provided to compare with 2 `WasmEdge_Limit` structs.



2. Function type context



   The `Function Type` context is used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `Function Type` context APIs to get the parameter or return value types information.



   ```c

   WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),

                                    WasmEdge_ValTypeGenI64()};

   WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenFuncRef()};

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



   WasmEdge_ValType Buf[16];

   uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);

   /* `ParamLen` will be 2. */

   uint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);

   /*

    * `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as

    * `ParamList`.

    */

   uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);

   /* `ReturnLen` will be 1. */

   uint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);

   /*

    * `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.

    */



   WasmEdge_FunctionTypeDelete(FuncTypeCxt);

   ```



3. Table type context



   The `Table Type` context is used for `Table` instance creation or getting information from `Table` instances.



   ```c

   WasmEdge_Limit TabLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenExternRef(), TabLim);



   WasmEdge_ValType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);

   bool IsTypeExternRef = WasmEdge_ValTypeIsExternRef(GotRefType);

   /* `IsTypeExternRef` will be `TRUE`. */

   bool IsTypeRef = WasmEdge_ValTypeIsRef(GotRefType);

   /* `IsTypeRef` will be `TRUE`. */

   bool IsTypeNullableRef = WasmEdge_ValTypeIsRefNull(GotRefType);

   /* `IsTypeNullableRef` will be `TRUE`. */

   WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);

   /* `GotTabLim` will be the same value as `TabLim`. */



   WasmEdge_TableTypeDelete(TabTypeCxt);

   ```



4. Memory type context



   The `Memory Type` context is used for `Memory` instance creation or getting information from `Memory` instances.



   ```c

   WasmEdge_Limit MemLim = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);



   WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);

   /* `GotMemLim` will be the same value as `MemLim`. */



   WasmEdge_MemoryTypeDelete(MemTypeCxt)

   ```



5. Global type context



   The `Global Type` context is used for `Global` instance creation or getting information from `Global` instances.



   ```c

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValTypeGenF64(), WasmEdge_Mutability_Var);



   WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);

   bool IsTypeF64 = WasmEdge_ValTypeIsF64(GotValType);

   /* `IsTypeF64` will be `TRUE`. */

   WasmEdge_Mutability GotValMut =

       WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);

   /* `GotValMut` will be WasmEdge_Mutability_Var. */



   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   ```



6. Tag type context



   The `Tag Type` context is used for getting information from `Tag` instances.

   This will only usable if the `Exception Handling` proposal turned on.



   ```c

   /* Get the tag type from a tag instance. */

   const WasmEdge_TagTypeContext *TagTypeCxt = WasmEdge_TagInstanceGetTagType(...);



   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_TagTypeGetFunctionType(TagTypeCxt);

   ```



7. Import type context



   The `Import Type` context is used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, `tag`, or `global`), import module name, and external name from an `Import Type` context. The details about querying `Import Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ImportTypeContext *ImpType = ...;

   /* Assume that `ImpType` is queried from the `ASTCxt` for the import. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ImportTypeGetExternalType(ImpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`,

    * `WasmEdge_ExternalType_Tag`, or `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);

   WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);

   /*

    * The `ModName` and `ExtName` should not be destroyed and the string

    * buffers are binded into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_TagTypeContext *TagTypeCxt =

       WasmEdge_ImportTypeGetTagType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Tag`, the `TagTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



8. Export type context



   The `Export Type` context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, `tag`, or `global`) and external name from an `Export Type` context. The details about querying `Export Type` contexts will be introduced in the [AST Module](#ast-module).



   ```c

   WasmEdge_ASTModuleContext *ASTCxt = ...;

   /*

    * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the

    * result of loading a WASM file.

    */

   const WasmEdge_ExportTypeContext *ExpType = ...;

   /* Assume that `ExpType` is queried from the `ASTCxt` for the export. */



   enum WasmEdge_ExternalType ExtType =

       WasmEdge_ExportTypeGetExternalType(ExpType);

   /*

    * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,

    * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`,

    * `WasmEdge_ExternalType_Tag`, or `WasmEdge_ExternalType_Global`.

    */

   WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);

   /*

    * The `ExtName` should not be destroyed and the string buffer is binded

    * into the `ASTCxt`.

    */

   const WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the

    * `FuncTypeCxt` will be NULL.

    */

   const WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`

    * will be NULL.

    */

   const WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`

    * will be NULL.

    */

   const WasmEdge_TagTypeContext *TagTypeCxt =

       WasmEdge_ExportTypeGetTagType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Tag`, the `TagTypeCxt`

    * will be NULL.

    */

   const WasmEdge_GlobalTypeContext *GlobTypeCxt =

       WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);

   /*

    * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`

    * will be NULL.

    */

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `WasmEdge_Async` object. Developers own the object and should call the `WasmEdge_AsyncDelete()` API to destroy it.



1. Wait for the asynchronous execution



   Developers can wait the execution until finished:



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution. */

   WasmEdge_AsyncWait(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   Or developers can wait for a time limit. If the time limit exceeded, developers can choose to cancel the execution. For the interruptible execution in AOT mode, developers should set `TRUE` through the `WasmEdge_ConfigureCompilerSetInterruptible()` API into the configure context for the AOT compiler.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution for 1 second. */

   bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);

   if (IsEnd) {

     /* The execution finished. Developers can get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);

   } else {

     /*

      * The time limit exceeded. Developers can keep waiting or cancel the

      * execution.

      */

     WasmEdge_AsyncCancel(Async);

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);

     /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */

   }

   WasmEdge_AsyncDelete(Async);

   ```



2. Get the execution result of the asynchronous execution



   Developers can use the `WasmEdge_AsyncGetReturnsLength()` API to get the return value list length. This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return `0`. This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the `WasmEdge_AsyncGet()` API to get the result.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /*

    * Blocking and waiting for the execution and get the return value list

    * length.

    */

   uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

   WasmEdge_AsyncDelete(Async);

   ```



   The `WasmEdge_AsyncGet()` API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.



   ```c

   WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */

   /* Blocking and waiting for the execution and get the return values. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_Value Buf[BUF_LEN];

   WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);

   WasmEdge_AsyncDelete(Async);

   ```



### Configurations



The configuration context, `WasmEdge_ConfigureContext`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler` contexts. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` context to create the runtime contexts.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` context.



   ```c

   enum WasmEdge_Proposal {

     WasmEdge_Proposal_ImportExportMutGlobals = 0,

     WasmEdge_Proposal_NonTrapFloatToIntConversions,

     WasmEdge_Proposal_SignExtensionOperators,

     WasmEdge_Proposal_MultiValue,

     WasmEdge_Proposal_BulkMemoryOperations,

     WasmEdge_Proposal_ReferenceTypes,

     WasmEdge_Proposal_SIMD,

     WasmEdge_Proposal_TailCall,

     WasmEdge_Proposal_ExtendedConst,

     WasmEdge_Proposal_FunctionReferences,

     WasmEdge_Proposal_GC,

     WasmEdge_Proposal_MultiMemories,

     WasmEdge_Proposal_Threads,

     WasmEdge_Proposal_RelaxSIMD,

     WasmEdge_Proposal_Annotations,

     WasmEdge_Proposal_Memory64,

     WasmEdge_Proposal_ExceptionHandling,

     WasmEdge_Proposal_Component,

   };

   ```



   Developers can add or remove the proposals into the `Configure` context.



   ```c

   /*

    * By default, the following proposals have turned on initially:

    * * Import/Export of mutable globals

    * * Non-trapping float-to-int conversions

    * * Sign-extension operators

    * * Multi-value returns

    * * Bulk memory operations

    * * Reference types

    * * Fixed-width SIMD

    *

    * For the current WasmEdge version, the following proposals are supported

    * (turned off by default) additionally:

    * * Tail-call

    * * Extended-const

    * * Typed-function references

    * * GC (interpreter only)

    * * Multiple memories

    * * Threads

    * * Exception handling (interpreter only)

    * * Component model (loader phase only)

    */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);

   WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);

   bool IsBulkMem = WasmEdge_ConfigureHasProposal(

       ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);

   /* The `IsBulkMem` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` supports and only effective in `VM` contexts.



   The element of this enum is reserved for the other built-in host functions (such as `wasi-socket`) in the future.



   ```c

   enum WasmEdge_HostRegistration {

     WasmEdge_HostRegistration_Wasi = 0

   };

   ```



   The details will be introduced in the [preregistrations of VM context](#built-in-host-modules-and-plug-in-preregistrations).



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `FALSE`. */

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   IsHostWasi = WasmEdge_ConfigureHasHostRegistration(

       ConfCxt, WasmEdge_HostRegistration_Wasi);

   /* The `IsHostWasi` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* By default, the maximum memory page size is 65536. */

   WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);

   /*

    * Limit the memory size of each memory instance with not larger than 1024

    * pages (64 MiB).

    */

   PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);

   /* The `PageSize` will be 1024. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



4. Forcibly interpreter mode



   If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   bool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* By default, The `IsForceInterp` will be `FALSE`. */

   WasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);

   IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);

   /* The `IsForceInterp` will be `TRUE`. */

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



5. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```c

   enum WasmEdge_CompilerOptimizationLevel {

     // Disable as many optimizations as possible.

     WasmEdge_CompilerOptimizationLevel_O0 = 0,

     // Optimize quickly without destroying debuggability.

     WasmEdge_CompilerOptimizationLevel_O1,

     // Optimize for fast execution as much as possible without triggering

     // significant incremental compile time or code size growth.

     WasmEdge_CompilerOptimizationLevel_O2,

     // Optimize for fast execution as much as possible.

     WasmEdge_CompilerOptimizationLevel_O3,

     // Optimize for small code size as much as possible without triggering

     // significant incremental compile time or execution time slowdowns.

     WasmEdge_CompilerOptimizationLevel_Os,

     // Optimize for small code size as much as possible.

     WasmEdge_CompilerOptimizationLevel_Oz

   };



   enum WasmEdge_CompilerOutputFormat {

     // Native dynamic library format.

     WasmEdge_CompilerOutputFormat_Native = 0,

     // WebAssembly with AOT compiled codes in custom section.

     WasmEdge_CompilerOutputFormat_Wasm

   };

   ```



   These configurations are only effective in `Compiler` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /* By default, the optimization level is O3. */

   WasmEdge_ConfigureCompilerSetOptimizationLevel(

       ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);

   /* By default, the output format is universal WASM. */

   WasmEdge_ConfigureCompilerSetOutputFormat(

       ConfCxt, WasmEdge_CompilerOutputFormat_Native);

   /* By default, the dump IR is `FALSE`. */

   WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);

   /* By default, the generic binary is `FALSE`. */

   WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);

   /* By default, the interruptible is `FALSE`.

   /* Set this option to `TRUE` to support the interruptible execution in AOT

   mode. */

   WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



6. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` contexts.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   /*

    * By default, the instruction counting is `FALSE` when running a

    * compiled-WASM or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);

   /*

    * By default, the cost measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);

   /*

    * By default, the time measurement is `FALSE` when running a compiled-WASM

    * or a pure-WASM.

    */

   WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);

   WasmEdge_ConfigureDelete(ConfCxt);

   ```



### Statistics



The statistics context, `WasmEdge_StatisticsContext`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` context from the `VM` context, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);

   double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` context. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   uint64_t CostTable[16] = {

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0

   };

   /*

    * Developers can set the costs of each instruction. The value not

    * covered will be 0.

    */

   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);

   /*

    * ...

    * After running the WASM functions with the `Statistics` context

    */

   uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   ```



## WasmEdge VM



In this partition, we will introduce the functions of `WasmEdge_VMContext` object and show examples of executing WASM functions.



### WASM Execution Example With VM Context



The following shows the example of running the WASM for getting the Fibonacci. This example uses the [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



<!-- prettier-ignore -->

:::note

`fibonacci.wat` file is provided in text format. Users should convert it into corresponding WASM binary format by using [WABT tool](https://github.com/WebAssembly/wabt).

:::



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Assume that the WASM file [`fibonacci.wasm`](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   <!-- prettier-ignore -->

   :::note

   `fibonacci.wat` file is provided in text format. Users should convert it into corresponding WASM binary format by using [WABT tool](https://github.com/WebAssembly/wabt).

   :::



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Run the WASM function from file. */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1, Returns, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMRunWasmFromBytes()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRunWasmFromASTModule()` API.

      */



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 8

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the configure context and add the WASI support. */

     /* This step is not necessary unless you need the WASI support. */

     WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

     WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                           WasmEdge_HostRegistration_Wasi);

     /* The configure and store context to the VM creation can be NULL. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBytes()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * Step 4: Execute WASM functions. You can execute functions repeatedly

      * after instantiation.

      */

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_ConfigureDelete(ConfCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 89

   ```



   The following graph explains the status of the `VM` context.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or module instances in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation API accepts the `Configure` context and the `Store` context. If developers only need the default settings, just pass `NULL` to the creation API. The details of the `Store` context will be introduced in [Store](#store).



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);

/* The caller should guarantee the life cycle if the store context. */

WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);

/*

 * The VM context already contains the statistics context and can be retrieved

 * by this API.

 */

/*

 * Note that the retrieved store and statistics contexts from the VM contexts by

 * VM APIs should __NOT__ be destroyed and owned by the VM contexts.

 */

WasmEdge_VMDelete(VMCxt);

WasmEdge_StoreDelete(StoreCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Built-in Host Modules and Plug-in Preregistrations



WasmEdge provides the following built-in host modules and plug-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` context.



   ```c

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   WasmEdge_ConfigureDelete(ConfCxt);

   /*

    * The following API can retrieve the built-in registered module instances

    * from the VM context.

    */

   /*

    * This API will return `NULL` if the corresponding configuration is not set

    * when creating the VM context.

    */

   WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetImportModuleContext(VMCxt,

                                         WasmEdge_HostRegistration_Wasi);

   /* Initialize the WASI. */

   WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);

   WasmEdge_VMDelete(VMCxt);

   ```



   And also can create the WASI module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. Plug-ins



   There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](../../../start/install.md#install-wasmedge-plug-ins-and-dependencies).



   Before using the plug-ins, developers should [load the plug-ins from paths](#load-plug-ins-from-paths).



   The `VM` context will automatically create and register the module of the loaded plug-ins when creation. Furthermore, the following host modules will be mocked if the plug-in not loaded:



   - `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)

   - `wasi_ephemeral_nn`

   - `wasi_snapshot_preview1`

   - `wasmedge_httpsreq`

   - `wasmedge_process`



   When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.



   ```c

   /* Load the plug-ins in the default paths first. */

   WasmEdge_PluginLoadWithDefaultPaths();

   /* Create the configure context and add the WASI configuration. */

   WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

   WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                         WasmEdge_HostRegistration_Wasi);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

   WasmEdge_ConfigureDelete(ConfCxt);

   /*

    * The following API can retrieve the registered modules in the VM context,

    * includes the built-in WASI and the plug-ins.

    */

   /*

    * This API will return `NULL` if the module instance not found.

    */

   WasmEdge_String WasiName =

       WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");

   /* The `WasiModule` will not be `NULL` because the configuration was set. */

   const WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);

   WasmEdge_StringDelete(WasiName);

   WasmEdge_String WasiNNName =

       WasmEdge_StringCreateByCString(""wasi_ephemeral_nn"");

   /*

    * The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not

    * installed, because the VM context will mock and register the host

    * modules.

    */

   const WasmEdge_ModuleInstanceContext *WasiNNModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);

   WasmEdge_StringDelete(WasiNNName);



   WasmEdge_VMDelete(VMCxt);

   ```



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, the host functions are composed into host modules as `WasmEdge_ModuleInstanceContext` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details.



In this chapter, we show the example for registering the host modules into a `VM` context. Noticed that the developers should guarantee the availability of the registered module instance, and should delete the module instance when it will not be used.



```c

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

WasmEdge_ModuleInstanceContext *WasiModule =

    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);

/* You can also create and register the WASI host modules by this API. */

WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);

/* The result status should be checked. */



/* ... */



WasmEdge_VMDelete(VMCxt);

WasmEdge_ModuleInstanceDelete(WasiModule);

/*

 * The created module instances should be deleted by the developers when the VM

 * deallocation.

 */

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering.



   Assume that the WASM file [`fibonacci.wasm`](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   <!-- prettier-ignore -->

   :::note

   `fibonacci.wat` file is provided in text format. Users should convert it into corresponding WASM binary format by using [WABT tool](https://github.com/WebAssembly/wabt).

   :::



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   WasmEdge_Result Res =

       WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

   /*

    * Developers can register the WASM module from buffer with the

    * `WasmEdge_VMRegisterModuleFromBytes()` API, or from

    * `WasmEdge_ASTModuleContext` object with the

    * `WasmEdge_VMRegisterModuleFromASTModule()` API.

    */

   /*

    * The result status should be checked.

    * The error will occur if the WASM module instantiation failed or the

    * module name conflicts.

    */

   WasmEdge_StringDelete(ModName);

   WasmEdge_VMDelete(VMCxt);

   ```



2. Execute the functions in registered WASM modules



   Assume that the C file `test.c` is as follows:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Names. */

     WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Register the WASM module into VM. */

     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, ""fibonacci.wasm"");

     /*

      * Developers can register the WASM module from buffer with the

      * `WasmEdge_VMRegisterModuleFromBytes()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMRegisterModuleFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""WASM registration failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /*

      * The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

      * name ""mod"". As the same as host functions, other modules can import the

      * function `""mod"" ""fib""`.

      */



     /*

      * Execute WASM functions in registered modules.

      * Unlike the execution of functions, the registered functions can be

      * invoked without `WasmEdge_VMInstantiate()` because the WASM module was

      * instantiated when registering. Developers can also invoke the host

      * functions directly with this API.

      */

     Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,

                                        Returns, 1);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     WasmEdge_StringDelete(ModName);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that the WASM file [`fibonacci.wasm`](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   <!-- prettier-ignore -->

   :::note

   `fibonacci.wat` file is provided in text format. Users should convert it into corresponding WASM binary format by using [WABT tool](https://github.com/WebAssembly/wabt).

   :::



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Asynchronously run the WASM function from file and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(

         VMCxt, ""fibonacci.wasm"", FuncName, Params, 1);

     /*

      * Developers can run the WASM binary from buffer with the

      * `WasmEdge_VMAsyncRunWasmFromBytes()` API, or from

      * `WasmEdge_ASTModuleContext` object with the

      * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.

      */



     /* Wait for the execution. */

     WasmEdge_AsyncWait(Async);

     /*

      * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or

      * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.

      * These APIs will wait until the execution finished.

      */



     /* Check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     return 0;

   }

   ```



   Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

     /* Result. */

     WasmEdge_Result Res;



     /* Step 1: Load WASM file. */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     /*

      * Developers can load the WASM binary from buffer with the

      * `WasmEdge_VMLoadWasmFromBytes()` API, or from `WasmEdge_ASTModuleContext`

      * object with the `WasmEdge_VMLoadWasmFromASTModule()` API.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 2: Validate the WASM module. */

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 3: Instantiate the WASM module. */

     Res = WasmEdge_VMInstantiate(VMCxt);

     /*

      * Developers can load, validate, and instantiate another WASM module to

      * replace the instantiated one. In this case, the old module will be

      * cleared, but the registered modules are still kept.

      */

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiation phase failed: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return 1;

     }

     /* Step 4: Asynchronously execute the WASM function and get the

      * `WasmEdge_Async` object. */

     WasmEdge_Async *Async =

         WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);

     /*

      * Developers can execute functions repeatedly after instantiation.

      * For invoking the registered functions, you can use the

      * `WasmEdge_VMAsyncExecuteRegistered()` API.

      */



     /* Wait and check the return values length. */

     uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);

     /* The `Arity` should be 1. Developers can skip this step if they have

      * known the return arity. */



     /* Get the result. */

     Res = WasmEdge_AsyncGet(Async, Returns, Arity);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_AsyncDelete(Async);

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

   }

   ```



   Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` context supplies the APIs to retrieve the instances.



1. Store



   If the `VM` context is created without assigning a `Store` context, the `VM` context will allocate and own a `Store` context.



   ```c

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */

   WasmEdge_VMDelete(VMCxt);

   ```



   Developers can also create the `VM` context with a `Store` context. In this case, developers should guarantee the life cycle of the `Store` context. Please refer to the [Store Contexts](#store) for the details about the `Store` context APIs.



   ```c

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

   WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);

   /* The `StoreCxt` and the `StoreCxtMock` are the same. */

   WasmEdge_VMDelete(VMCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `WasmEdge_VMExecute()` API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   Assume that the WASM file [`fibonacci.wasm`](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



   <!-- prettier-ignore -->

   :::note

   `fibonacci.wat` file is provided in text format. Users should convert it into corresponding WASM binary format by using [WABT tool](https://github.com/WebAssembly/wabt).

   :::



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>

   int main() {

     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);



     WasmEdge_VMLoadWasmFromFile(VMCxt, ""fibonacci.wasm"");

     WasmEdge_VMValidate(VMCxt);

     WasmEdge_VMInstantiate(VMCxt);



     /* List the exported functions. */

     /* Get the number of exported functions. */

     uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);

     /* Create the name buffers and the function type buffers. */

     const uint32_t BUF_LEN = 256;

     WasmEdge_String FuncNames[BUF_LEN];

     WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];

     /*

      * Get the export function list.

      * If the function list length is larger than the buffer length, the

      * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can

      * be NULL if developers don't need them.

      */

     uint32_t RealFuncNum =

         WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);



     for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

       char Buf[BUF_LEN];

       uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

       printf(""Get exported function string length: %u, name: %s\n"", Size,

              Buf);

       /*

        * The function names should be __NOT__ destroyed.

        * The returned function type contexts should __NOT__ be destroyed.

        */

     }

     WasmEdge_StoreDelete(StoreCxt);

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get exported function string length: 3, name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` context from the `VM` context and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` context provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   const WasmEdge_FunctionTypeContext *FuncType =

       WasmEdge_VMGetFunctionType(VMCxt, FuncName);

   /*

    * Developers can get the function types of functions in the registered

    * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the

    * module name. If the function is not found, these APIs will return `NULL`.

    * The returned function type contexts should __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` context. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `WasmEdge_VMGetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```c

   /*

    * ...

    * Assume that a WASM module is instantiated in `VMCxt`.

    */

   const WasmEdge_ModuleInstanceContext *ModCxt =

       WasmEdge_VMGetActiveModule(VMCxt);

   /*

    * If there's no WASM module instantiated, this API will return `NULL`.

    * The returned module instance context should __NOT__ be destroyed.

    */

   ```



5. List and get the registered modules



   To list and retrieve the registered modules in the `VM` context, besides accessing the `store` context of the `VM`, developers can use the following APIs.



   ```c

   /*

    * ...

    * Assume that the `VMCxt` is created.

    */

   WasmEdge_String Names[32];

   uint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);

   for (uint32_t I = 0; I < ModuleLen; I++) {

     /* Will print the registered module names in the VM context. */

     printf(""%s\n"", Names[I].Buf);

   }



   WasmEdge_String WasiName =

       WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");

   /* The `WasiModule` will not be `NULL` because the configuration was set. */

   const WasmEdge_ModuleInstanceContext *WasiModule =

       WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);

   WasmEdge_StringDelete(WasiName);

   ```



6. Get the components



   The `VM` context is composed by the `Loader`, `Validator`, and `Executor` contexts. For the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the `VM` context. The get contexts are owned by the `VM` context, and developers should not call their delete functions.



   ```c

   WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */

   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);

   /* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` context](#wasmedge-vm), developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` contexts.



Assume that the WASM file [`fibonacci.wasm`](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



<!-- prettier-ignore -->

:::note

`fibonacci.wat` file is provided in text format. Users should convert it into corresponding WASM binary format by using [WABT tool](https://github.com/WebAssembly/wabt).

:::



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /*

   * Create the configure context. This step is not necessary because we didn't

   * adjust any setting.

   */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /*

   * Create the statistics context. This step is not necessary if the statistics

   * in runtime is not needed.

   */

  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

  /*

   * Create the store context. The store context is the object to link the

   * modules for imports and exports.

   */

  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

  /* Result. */

  WasmEdge_Result Res;



  /* Create the loader context. The configure context can be NULL. */

  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

  /* Create the validator context. The configure context can be NULL. */

  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

  /*

   * Create the executor context. The configure context and the statistics

   * context can be NULL.

   */

  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);



  /*

   * Load the WASM file or the compiled-WASM file and convert into the AST

   * module context.

   */

  WasmEdge_ASTModuleContext *ASTCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Validate the WASM module. */

  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }

  /* Instantiate the WASM module into store context. */

  WasmEdge_ModuleInstanceContext *ModCxt = NULL;

  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  /* Try to list the exported functions of the instantiated WASM module. */

  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

  /* Create the name buffers. */

  const uint32_t BUF_LEN = 256;

  WasmEdge_String FuncNames[BUF_LEN];

  /*

   * If the list length is larger than the buffer length, the overflowed data

   * will be discarded.

   */

  uint32_t RealFuncNum =

      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

    char Buf[BUF_LEN];

    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));

    printf(""Get exported function string length: %u, name: %s\n"", Size, Buf);

    /* The function names should __NOT__ be destroyed. */

  }



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

  /* Find the exported function by function name. */

  WasmEdge_FunctionInstanceContext *FuncCxt =

      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

  if (FuncCxt == NULL) {

    printf(""Function `fib` not found.\n"");

    return 1;

  }

  /* Invoke the WASM function. */

  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_StringDelete(FuncName);

  WasmEdge_ASTModuleDelete(ASTCxt);

  WasmEdge_ModuleInstanceDelete(ModCxt);

  WasmEdge_LoaderDelete(LoadCxt);

  WasmEdge_ValidatorDelete(ValidCxt);

  WasmEdge_ExecutorDelete(ExecCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  WasmEdge_StoreDelete(StoreCxt);

  WasmEdge_StatisticsDelete(StatCxt);

  return 0;

}

```



Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)



```bash

$ gcc test.c -lwasmedge

$ ./a.out

Get exported function string length: 3, name: fib

Get the result: 4181

```



### Loader



The `Loader` context loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```c

uint8_t Buf[4096];

/* ... Read the WASM code to the buffer. */

uint32_t FileSize = ...;

/* The `FileSize` is the length of the WASM code. */



/* Developers can adjust settings in the configure context. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);



WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;



/* Load WASM or compiled-WASM from the file. */

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



/* Load WASM or compiled-WASM from the buffer. */

WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(Buf, FileSize);

Res = WasmEdge_LoaderParseFromBytes(LoadCxt, &ASTCxt, Bytes);

/*

 * Note: `WasmEdge_LoaderParseFromBuffer()` will be deprecated in the future.

 * We recommand developers to use `WasmEdge_LoaderParseFromBytes()` instead.

 */

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



### Validator



The `Validator` context can validate the WASM module. Every WASM module should be validated before instantiation.



```c

/*

 * ...

 * Assume that the `ASTCxt` is the output AST module context from the loader

 * context.

 * Assume that the `ConfCxt` is the configure context.

 */

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);

WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

WasmEdge_ValidatorDelete(ValidCxt);

```



### Executor



The `Executor` context is the executor for both WASM and compiled-WASM. This object should work base on the `Store` context. For the details of the `Store` context, please refer to the [next chapter](#store).



1. Instantiate and register an `AST module` as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` contexts, developers can instantiate an `AST module` contexts into a named `Module` instance, and register it into the `Store` context. After the registration, the result `Module` instance is exported to the `Store` with the given module name and can be linked when instantiating another module.



   For the details about the `Module` instances APIs, please refer to the [Instances](#instances). The `Store` context is only the linker for searching and linking the exported modules when instantiation. Developers should delete the output `Module` instance when it will no longer be used. When the `Module` instance being deleted, it will automatically unlink to all linked `Store` contexts.



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /*

    * Register the WASM module into the store with the export module name

    * ""mod"".

    */

   Res =

       WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   WasmEdge_StringDelete(ModName);



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST module` contexts, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   /* Create a module instance for host functions. */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""host-module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ModName);

   WasmEdge_StringDelete(ModName);

   /*

    * ...

    * Create and add the host functions, tables, memories, and globals into the

    * module instance.

    */



   /* Register the module instance into store with the exported module name. */

   /* The export module name is in the module instance already. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



3. Instantiate an `AST module` to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` context for linking.



   ```c

   /*

    * ...

    * Assume that the `ASTCxt` is the output AST module context from the loader

    * context and has passed the validation. Assume that the `ConfCxt` is the

    * configure context.

    */

   /* Create the statistics context. This step is not necessary. */

   WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();

   /*

    * Create the executor context. The configure and the statistics contexts

    * can be NULL.

    */

   WasmEdge_ExecutorContext *ExecCxt =

       WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

   /*

    * Create the store context. The store context is the object to link the

    * modules for imports and exports.

    */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /* Instantiate the WASM module. */

   WasmEdge_Result Res =

       WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM instantiation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   /* ... */



   /* After the execution, the resources should be released. */

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StatisticsDelete(StatCxt);

   WasmEdge_StoreDelete(StoreCxt);

   WasmEdge_ModuleInstanceDelete(ModCxt);

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `WasmEdge_ExecutorInvoke()` API.



5. Asynchronously invoke functions



   Such as [executing WASM functions in VM asynchronously](#asynchronous-execution), developers can also invoke a function asynchronously by `Executor` contexts API.



   After getting the `Function` instance, developers will get the `Async` context by calling the `WasmEdge_ExecutorAsyncInvoke()` API. Please refer to the [Async](#async) chapter to work with this context for getting the results.



### AST Module



The `AST Module` context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST Module` context.



```c

WasmEdge_ASTModuleContext *ASTCxt = ...;

/* Assume that a WASM is loaded into an AST module context. */



/* Create the import type context buffers. */

const uint32_t BUF_LEN = 256;

const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];

uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealImportNum =

    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {

  /* Working with the import type `ImpTypes[I]` ... */

}



/* Create the export type context buffers. */

const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];

uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealExportNum =

    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);

for (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {

  /* Working with the export type `ExpTypes[I]` ... */

}



WasmEdge_ASTModuleDelete(ASTCxt);

/*

 * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be

 * accessed.

 */

```



### Serializer



As the reversion of loading WASM file or buffer into a `AST Module`, the `Loader` context also provide the serializer to serialze the `AST Module` back into a WASM buffer.



```c

WasmEdge_ASTModuleContext *ASTCxt = ...;

/* Assume that a WASM is loaded into an AST module context. */



WasmEdge_LoaderContext *LoadCxt = ...;

/* Assume that a loader context is created with configuration. */



WasmEdbe_Bytes Bytes;

/* Serialize the AST module back into WASM binary format. */

Res = WasmEdge_LoaderSerializeASTModule(LoadCxt, ASTCxt, &Bytes);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Serialization failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}



/* The output WasmEdge_Bytes should be destroyed. */

WasmEdge_BytesDelete(Bytes);

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` context in WasmEdge is an object which present the linker to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context, and should delete the `Module` instances registered into the `Store` context if they will not be used anymore.



When the `Store` context being deleted, the linked `Module` instances will automatically unlink to this `Store` context. When a `Module` instance being deleted, it will automatically unlink to all the linked `Store` contexts.



```c

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



/*

 * ...

 * Register a WASM module via the executor context.

 */



/* Try to list the registered WASM modules. */

uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);

/* Create the name buffers. */

const uint32_t BUF_LEN = 256;

WasmEdge_String ModNames[BUF_LEN];

/*

 * If the list length is larger than the buffer length, the overflowed data will

 * be discarded.

 */

uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);

for (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {

  /* Working with the module name `ModNames[I]` ... */

  /* The module names should __NOT__ be destroyed. */

}



/* Find named module by name. */

WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");

const WasmEdge_ModuleInstanceContext *ModCxt =

    WasmEdge_StoreFindModule(StoreCxt, ModName);

/* If the module with name not found, the `ModCxt` will be NULL. */

WasmEdge_StringDelete(ModName);

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST module` context, developers will get a `Module` instance as the result, and have the responsibility to destroy it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```c

   /*

    * ...

    * Instantiate a WASM module via the executor context and get the `ModCxt`

    * as the output module instance.

    */



   /* Try to list the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String FuncNames[BUF_LEN];

   /*

    * If the list length is larger than the buffer length, the overflowed data

    * will be discarded.

    */

   uint32_t RealFuncNum =

       WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);

   for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {

     /* Working with the function name `FuncNames[I]` ... */

     /* The function names should __NOT__ be destroyed. */

   }



   /* Try to find the exported instance of the instantiated WASM module. */

   /* Take the function instances for example here. */

   /* Function name. */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_FunctionInstanceContext *FuncCxt =

       WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

   /* `FuncCxt` will be `NULL` if the function not found. */

   /*

    * The returned instance is owned by the module instance context and should

    * __NOT__ be destroyed.

    */

   WasmEdge_StringDelete(FuncName);

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` contexts for host functions and add them into an `Module` instance context for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` contexts through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```c

   /* Retrieve the function instance from the module instance context. */

   WasmEdge_FunctionInstanceContext *FuncCxt = ...;

   WasmEdge_FunctionTypeContext *FuncTypeCxt =

       WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);

   /*

    * The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be

    * destroyed.

    */



   /*

    * For the function instance creation, please refer to the `Host Function`

    * guide.

    */

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Table` contexts supply APIs to control the data in table instances.



   ```c

   WasmEdge_Limit TabLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   /* Create the table type with limit and the `FuncRef` element type. */

   WasmEdge_TableTypeContext *TabTypeCxt =

       WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);

   /* Create the table instance with table type. */

   /* 

    * Developers can also use the `WasmEdge_TableInstanceCreateWithInit()` API to

    * create the table instance with default reference values.

    */

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(TabTypeCxt);

   /* Delete the table type. */

   WasmEdge_TableTypeDelete(TabTypeCxt);

   WasmEdge_Result Res;

   WasmEdge_Value Data;



   const WasmEdge_TableTypeContext *GotTabTypeCxt =

       WasmEdge_TableInstanceGetTableType(HostTable);

   /*

    * The `GotTabTypeCxt` got from table instance is owned by the `HostTable` and

    * should __NOT__ be destroyed.

    */

   WasmEdge_ValType RefType = WasmEdge_TableTypeGetRefType(GotGlobTypeCxt);

   bool IsTypeFuncRef = WasmEdge_ValTypeIsFuncRef(RefType);

   /* `IsTypeFuncRef` will be `TRUE`. */

   Data = WasmEdge_ValueGenFuncRef(5);

   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);

   /* Set the function index 5 to the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);

    */

   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);

   /* Get the FuncRef value of the table[3]. */

   /*

    * This will get an ""out of bounds table access"" error

    * because the position (13) is out of the table size (10):

    *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);

    */



   uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);

   /* `Size` will be 10. */

   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

   /* Grow the table size of 6, the table size will be 16. */

   /*

    * This will get an ""out of bounds table access"" error because

    * the size (16 + 6) will reach the table limit(20):

    *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);

    */



   WasmEdge_TableInstanceDelete(HostTable);

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Memory` contexts supply APIs to control the data in memory instances.



   ```c

   WasmEdge_Limit MemLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 5};

   /* Create the memory type with limit. The memory page size is 64KiB. */

   WasmEdge_MemoryTypeContext *MemTypeCxt =

       WasmEdge_MemoryTypeCreate(MemLimit);

   /* Create the memory instance with memory type. */

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(MemTypeCxt);

   /* Delete the memory type. */

   WasmEdge_MemoryTypeDelete(MemTypeCxt);

   WasmEdge_Result Res;

   uint8_t Buf[256];



   Buf[0] = 0xAA;

   Buf[1] = 0xBB;

   Buf[2] = 0xCC;

   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);

   /* Set the data[0:2] to the memory[4096:4098]. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */

   Buf[0] = 0;

   Buf[1] = 0;

   Buf[2] = 0;

   Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);

   /* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */

   /*

    * This will get an ""out of bounds memory access"" error

    * because [65535:65537] is out of 1 page size (65536):

    *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);

    */



   uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);

   /* `PageSize` will be 1. */

   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);

   /* Grow the page size of 2, the page size of the memory instance will be 3. */

   /*

    * This will get an ""out of bounds memory access"" error because

    * the page size (3 + 3) will reach the memory limit(5):

    *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);

    */



   WasmEdge_MemoryInstanceDelete(HostMemory);

   ```



5. Tag instance



   Unlike the other instances, the `Tag` contexts are only available and can be retrieved from a `Module` instance context when turning on the `Exception Handling` proposal. Developers can retrieve the `Tag Type` from the instance.



   ```c

   /*

    * ...

    * Instantiate a WASM module with exception handling instructions via the

    * executor context and get the `ModCxt` as the output module instance.

    */



   /* Try to list the exported tag instance of the instantiated WASM module. */

   uint32_t TagNum = WasmEdge_ModuleInstanceListTagLength(ModCxt);

   /* Create the name buffers. */

   const uint32_t BUF_LEN = 256;

   WasmEdge_String TagNames[BUF_LEN];

   /*

    * If the list length is larger than the buffer length, the overflowed data

    * will be discarded.

    */

   uint32_t RealTagNum = WasmEdge_ModuleInstanceListTag(ModCxt, TagNames, BUF_LEN);

   for (uint32_t I = 0; I < RealTagNum && I < BUF_LEN; I++) {

     /* Working with the tag name `TagNames[I]` ... */

     /* The function names should __NOT__ be destroyed. */

   }



   /* Try to find the exported tag instance of the instantiated WASM module. */

   WasmEdge_String TagName = WasmEdge_StringCreateByCString(""tag-1"");

   WasmEdge_TagInstanceContext *TagCxt =

       WasmEdge_ModuleInstanceFindTag(ModCxt, TagName);

   /* `TagCxt` will be `NULL` if the tag not found. */

   /*

    * The returned instance is owned by the module instance context and should

    * __NOT__ be destroyed.

    */



   /* Try to retrieve the tag type from the tag instance. */

   const WasmEdge_TagTypeContext *TagTypeCxt =

       WasmEdge_TagInstanceGetTagType(TagCxt);

   /*

    * The returned tag type context is owned by the tag instance context and should

    * __NOT__ be destroyed.

    */



   WasmEdge_StringDelete(TagName);

   ```



6. Global instance



   In WasmEdge, developers can create the `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`. The `Global` contexts supply APIs to control the value in global instances.



   ```c

   WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);

   /* Create the global type with value type and mutation. */

   WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValTypeGenI64(), WasmEdge_Mutability_Var);

   /* Create the global instance with value and global type. */

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);

   /* Delete the global type. */

   WasmEdge_GlobalTypeDelete(GlobTypeCxt);

   WasmEdge_Result Res;



   const WasmEdge_GlobalTypeContext *GotGlobTypeCxt =

       WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);

   /*

    * The `GotGlobTypeCxt` got from global instance is owned by the `HostGlobal`

    * and should __NOT__ be destroyed.

    */

   WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GotGlobTypeCxt);

   bool IsTypeF64 = WasmEdge_ValTypeIsI64(ValType);

   /* `ValType` will be `TRUE`. */

   enum WasmEdge_Mutability ValMut =

       WasmEdge_GlobalTypeGetMutability(GotGlobTypeCxt);

   /* `ValMut` will be `WasmEdge_Mutability_Var`. */



   Res = WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));

   /*

    * Set the value u64(888) to the global.

    * This function will return error if the value type mismatched or

    * the global mutability is `WasmEdge_Mutability_Const`.

    */

   WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);

   /* Get the value (888 now) of the global context. */



   WasmEdge_GlobalInstanceDelete(HostGlobal);

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` contexts and add them into an `Module` instance context for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define C functions with the following function signature as the host function body:



   ```c

   typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

       void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

       const WasmEdge_Value *Params, WasmEdge_Value *Returns);

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```c

   WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /*

      * Params: {i32, i32}

      * Returns: {i32}

      * Developers should take care about the function type.

      */

     /* Retrieve the value 1. */

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     /* Retrieve the value 2. */

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     /* Output value 1 is Val1 + Val2. */

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Return the status of success. */

     return WasmEdge_Result_Success;

   }

   ```



   Then developers can create `Function` context with the host function body and the function type:



   ```c

   WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),

                                    WasmEdge_ValTypeGenI32()};

   WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};

   /* Create a function type: {i32, i32} -> {i32}. */

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   /*

    * Create a function context with the function type and host function body.

    * The `Cost` parameter can be 0 if developers do not need the cost

    * measuring.

    */

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostType);



   /*

    * If the function instance is __NOT__ added into a module instance context,

    * it should be deleted.

    */

   WasmEdge_FunctionInstanceDelete(HostFunc);

   ```



2. Calling frame context



   The `WasmEdge_CallingFrameContext` is the context to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



   ```c

   WasmEdge_Result LoadOffset(void *Data,

                              const WasmEdge_CallingFrameContext *CallFrameCxt,

                              const WasmEdge_Value *In, WasmEdge_Value *Out) {

     /* Function type: {i32} -> {} */

     uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

     uint32_t Num = 0;



     /*

      * Get the 0-th memory instance of the module instance of the top frame on

      * stack.

      */

     WasmEdge_MemoryInstanceContext *MemCxt =

         WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);



     WasmEdge_Result Res =

         WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

     if (WasmEdge_ResultOK(Res)) {

       printf(""u32 at memory[%lu]: %lu\n"", Offset, Num);

     } else {

       return Res;

     }

     return WasmEdge_Result_Success;

   }

   ```



   Besides using the `WasmEdge_CallingFrameGetMemoryInstance()` API to get the memory instance by index in the module instance, developers can use the `WasmEdge_CallingFrameGetModuleInstance()` to get the module instance directly. Therefore, developers can retrieve the exported contexts by the `WasmEdge_ModuleInstanceContext` APIs. And also, developers can use the `WasmEdge_CallingFrameGetExecutor()` API to get the currently used executor context.



3. User-defined error code of the host functions



   In host functions, WasmEdge provides `WasmEdge_Result_Success` to return success, `WasmEdge_Result_Terminate` to terminate the WASM execution, and `WasmEdge_Result_Fail` to return fail. WasmEdge also provides the usage of returning the user-specified codes. Developers can use the `WasmEdge_ResultGen()` API to generate the `WasmEdge_Result` with error code, and use the `WasmEdge_ResultGetCode()` API to get the error code.



   > Notice: The error code only supports 24-bit integer (0 ~ 16777216 in `uint32_t`). The values larger than 24-bit will be truncated.



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32)))

     (import ""extern"" ""trap"" (func $f-trap (type $t0)))

     (func (export ""trap"") (param i32)

       local.get 0

       call $f-trap)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Trap(void *Data,

                        const WasmEdge_CallingFrameContext *CallFrameCxt,

                        const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val = WasmEdge_ValueGetI32(In[0]);

     /* Return the error code from the param[0]. */

     return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x05, 0x01,

                       /* function type {i32} -> {} */

                       0x60, 0x01, 0x7F, 0x00,

                       /* Import section */

                       0x02, 0x0F, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x08, 0x01,

                       /* export name: ""trap"" */

                       0x04, 0x74, 0x72, 0x61, 0x70,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x08, 0x01,

                       /* code body */

                       0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     WasmEdge_ValType ParamList[1] = {WasmEdge_ValTypeGenI32()};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 1, NULL, 0);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Trap, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""trap"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5566)};

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""trap"");

     /* Run the WASM function from memory. */

     WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));

     /*

      * Note: `WasmEdge_VMRunWasmFromBuffer()` will be deprecated in the future.

      * We recommand developers to use `WasmEdge_VMRunWasmFromBytes()` instead.

      */

     WasmEdge_Result Res =

         WasmEdge_VMRunWasmFromBytes(VMCxt, Bytes, FuncName, Params, 1, NULL, 0);



     /* Get the result code and print. */

     printf(""Get the error code: %u\n"", WasmEdge_ResultGetCode(Res));



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (giving the expected error code `5566`)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   [2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be

   [2022-08-26 15:06:40.384] [error]     When executing function name: ""trap""

   Get the error code: 5566

   ```



4. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```c

   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   /* Create a module instance. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreate(ExportName);

   /*

    * Developers can also use the WasmEdge_ModuleInstanceCreateWithData() to

    * create the module instance with the data and its finalizer. It will be

    * introduced later.

    */

   WasmEdge_StringDelete(ExportName);



   /* Create and add a function instance into the module instance. */

   WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),

                                    WasmEdge_ValTypeGenI32()};

   WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};

   WasmEdge_FunctionTypeContext *HostFType =

       WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

   WasmEdge_FunctionInstanceContext *HostFunc =

       WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

   /*

    * The third parameter is the pointer to the additional data object.

    * Developers should guarantee the life cycle of the data, and it can be

    * `NULL` if the external data is not needed.

    */

   WasmEdge_FunctionTypeDelete(HostFType);

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

   WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);

   WasmEdge_StringDelete(FuncName);



   /* Create and add a table instance into the import object. */

   WasmEdge_Limit TableLimit = {

       .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

   WasmEdge_TableTypeContext *HostTType =

       WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TableLimit);

   WasmEdge_TableInstanceContext *HostTable =

       WasmEdge_TableInstanceCreate(HostTType);

   WasmEdge_TableTypeDelete(HostTType);

   WasmEdge_String TableName = WasmEdge_StringCreateByCString(""table"");

   WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);

   WasmEdge_StringDelete(TableName);



   /* Create and add a memory instance into the import object. */

   WasmEdge_Limit MemoryLimit = {

       .HasMax = true, .Shared = false, .Min = 1, .Max = 2};

   WasmEdge_MemoryTypeContext *HostMType =

       WasmEdge_MemoryTypeCreate(MemoryLimit);

   WasmEdge_MemoryInstanceContext *HostMemory =

       WasmEdge_MemoryInstanceCreate(HostMType);

   WasmEdge_MemoryTypeDelete(HostMType);

   WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(""memory"");

   WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);

   WasmEdge_StringDelete(MemoryName);



   /* Create and add a global instance into the module instance. */

   WasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(

       WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Var);

   WasmEdge_GlobalInstanceContext *HostGlobal =

       WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));

   WasmEdge_GlobalTypeDelete(HostGType);

   WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(""global"");

   WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);

   WasmEdge_StringDelete(GlobalName);



   /*

    * The module instance should be deleted.

    * Developers should __NOT__ destroy the instances added into the module

    * instance contexts.

    */

   WasmEdge_ModuleInstanceDelete(HostModCxt);

   ```



5. Specified module instance



   `WasmEdge_ModuleInstanceCreateWASI()` API can create and initialize the `WASI` module instance.



   Developers can create these module instance contexts and register them into the `Store` or `VM` contexts rather than adjust the settings in the `Configure` contexts.



   ```c

   WasmEdge_ModuleInstanceContext *WasiModCxt =

       WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);

   WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

   /* Register the WASI and WasmEdge_Process into the VM context. */

   WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);

   /* Get the WASI exit code. */

   uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);

   /*

    * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.

    * Otherwise, it will return with the related exit code.

    */

   WasmEdge_VMDelete(VMCxt);

   /* The module instances should be deleted. */

   WasmEdge_ModuleInstanceDelete(WasiModCxt);

   ```



6. Example



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),

                                      WasmEdge_ValTypeGenI32()};

     WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from memory. */

     WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));

     /*

      * Note: `WasmEdge_VMRunWasmFromBuffer()` will be deprecated in the future.

      * We recommand developers to use `WasmEdge_VMRunWasmFromBytes()` instead.

      */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBytes(VMCxt, Bytes, FuncName,

                                                       Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   ```



7. Host Data Example



   Developers can set a external data object to the `Function` context, and access to the object in the function body. Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   And the `test.c` is as following:



   ```c

   #include <wasmedge/wasmedge.h>

   #include <stdio.h>



   /* Host function body definition. */

   WasmEdge_Result Add(void *Data,

                       const WasmEdge_CallingFrameContext *CallFrameCxt,

                       const WasmEdge_Value *In, WasmEdge_Value *Out) {

     int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

     int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

     printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

     Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

     /* Also set the result to the data. */

     int32_t *DataPtr = (int32_t *)Data;

     *DataPtr = Val1 + Val2;

     return WasmEdge_Result_Success;

   }



   int main() {

     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* The WASM module buffer. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Import section */

                       0x02, 0x13, 0x01,

                       /* module name: ""extern"" */

                       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                       /* extern name: ""func-add"" */

                       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                       /* import desc: func 0 */

                       0x00, 0x00,

                       /* Function section */

                       0x03, 0x02, 0x01, 0x00,

                       /* Export section */

                       0x07, 0x0A, 0x01,

                       /* export name: ""addTwo"" */

                       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                       /* export desc: func 0 */

                       0x00, 0x01,

                       /* Code section */

                       0x0A, 0x0A, 0x01,

                       /* code body */

                       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



     /* The external data object: an integer. */

     int32_t Data;



     /* Create the module instance. */

     WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

     WasmEdge_ModuleInstanceContext *HostModCxt =

         WasmEdge_ModuleInstanceCreate(ExportName);

     WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(),

                                      WasmEdge_ValTypeGenI32()};

     WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};

     WasmEdge_FunctionTypeContext *HostFType =

         WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

     WasmEdge_FunctionInstanceContext *HostFunc =

         WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);

     WasmEdge_FunctionTypeDelete(HostFType);

     WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

     WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

     WasmEdge_StringDelete(HostFuncName);



     WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



     /* The parameters and returns arrays. */

     WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                                 WasmEdge_ValueGenI32(5678)};

     WasmEdge_Value Returns[1];

     /* Function name. */

     WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

     /* Run the WASM function from memory. */

     WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));

     /*

      * Note: `WasmEdge_VMRunWasmFromBuffer()` will be deprecated in the future.

      * We recommand developers to use `WasmEdge_VMRunWasmFromBytes()` instead.

      */

     WasmEdge_Result Res = WasmEdge_VMRunWasmFromBytes(VMCxt, Bytes, FuncName,

                                                       Params, 2, Returns, 1);



     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

     }

     printf(""Data value: %d\n"", Data);



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     WasmEdge_StringDelete(FuncName);

     WasmEdge_ModuleInstanceDelete(HostModCxt);

     return 0;

   }

   ```



   Then you can compile and run: (the result of 1234 + 5678 is 6912)



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Host function ""Add"": 1234 + 5678

   Get the result: 6912

   Data value: 6912

   ```



8. Host Data in Module Instance with Finalizer



   Besides setting host data into a host function, developers can set and move ownership of host data into a `Module` instance context with its finalizer. This may be useful when implementing the plug-ins.



   ```c

   /* Struct definition. */

   typedef struct Point {

     int X;

     int Y;

   } Point;



   /* Host function body definition. */

   WasmEdge_Result Print(void *Data,

                         const WasmEdge_CallingFrameContext *CallFrameCxt,

                         const WasmEdge_Value *In, WasmEdge_Value *Out) {

     Point *P = (Point *)In;

     printf(""Point: (%d, %d)\n"", P->X, P->Y);

     return WasmEdge_Result_Success;

   }



   /* Finalizer definition. */

   void PointFinalizer(void *Data) {

     if (Data) {

       free((Point *)Data);

     }

   }



   /* Create a module instance with host data and its finalizer. */

   WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

   Point *Data = (Point *)malloc(sizeof(Point));

   Data->X = 5;

   Data->Y = -5;

   WasmEdge_ModuleInstanceContext *HostModCxt =

       WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);

   /*

   * When the `HostModCxt` being destroyed, the finalizer will be invoked and the

   * `Data` will be its argument.

   */

   WasmEdge_StringDelete(ExportName);

   ```



### Plug-ins



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



#### Load plug-ins from paths



To use the plug-ins, developers should load the plug-ins from paths first.



```c

WasmEdge_PluginLoadWithDefaultPaths();

```



After calling this API, the plug-ins in the default paths will be loaded. The default paths are:



1. The path given in the environment variable `WASMEDGE_PLUGIN_PATH`.

2. The `../plugin/` directory related to the WasmEdge installation path.

3. The `./wasmedge/` directory under the library path if the WasmEdge is installed under the system directory (such as `/usr` and `/usr/local`).



To load the plug-ins from a specific path or under a specific directory, developers can use this API:



```c

WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plugin.so"");

```



#### Get the plug-in by name



After loading the plug-ins, developers can list the loaded plug-in names.



```c

WasmEdge_PluginLoadWithDefaultPaths();

printf(""Number of loaded plug-ins: %d\n"", WasmEdge_PluginListPluginsLength());



WasmEdge_String Names[20];

uint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);

for (int I = 0; I < NumPlugins; I++) {

  printf(""plug-in %d name: %s\n"", I, Names[I].Buf);

}

```



And developers can retrieve the plug-in context by its name.



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();



const char PluginName[] = ""wasi_crypto"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(PluginName, strlen(PluginName));

const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);

```



#### Create the module instance from a plug-in



With the plug-in context, developers can create the module instances by the module name.



```c

/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */



/* List the available host modules in the plug-in. */

WasmEdge_String Names[20];

uint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);

for (uint32_t I = 0; I < ModuleLen; I++) {

  /* Will print the available host module names in the plug-in. */

  printf(""%s\n"", Names[I].Buf);

}

/*

 * Will print here for the WASI-Crypto plug-in here:

 * wasi_ephemeral_crypto_asymmetric_common

 * wasi_ephemeral_crypto_common

 * wasi_ephemeral_crypto_kx

 * wasi_ephemeral_crypto_signatures

 * wasi_ephemeral_crypto_symmetric

 */



/* Create a module instance from the plug-in by the module name. */

const char ModuleName[] = ""wasi_ephemeral_crypto_common"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));

WasmEdge_ModuleInstance *ModCxt =

    WasmEdge_PluginCreateModule(PluginCxt, NameString);



WasmEdge_ModuleInstanceDelete(ModCxt);

```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options.



WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



Assume that the WASM file [`fibonacci.wasm`](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test.c` is as following:



<!-- prettier-ignore -->

:::note

`fibonacci.wat` file is provided in text format. Users should convert it into corresponding WASM binary format by using [WABT tool](https://github.com/WebAssembly/wabt).

:::



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main() {

  /* Create the configure context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* ... Adjust settings in the configure context. */

  /* Result. */

  WasmEdge_Result Res;



  /* Create the compiler context. The configure context can be NULL. */

  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);

  /* Compile the WASM file with input and output paths. */

  Res = WasmEdge_CompilerCompile(CompilerCxt, ""fibonacci.wasm"",

                                 ""fibonacci-aot.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  WasmEdge_CompilerDelete(CompilerCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  return 0;

}

```



Then you can compile and run (the output file is ""fibonacci-aot.wasm""):



```bash

$ gcc test.c -lwasmedge

$ ./a.out

[2021-07-02 11:08:08.651] [info] compile start

[2021-07-02 11:08:08.653] [info] verify start

[2021-07-02 11:08:08.653] [info] optimize start

[2021-07-02 11:08:08.670] [info] codegen start

[2021-07-02 11:08:08.706] [info] compile done

```



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```c

/// AOT compiler optimization level enumeration.

enum WasmEdge_CompilerOptimizationLevel {

  /// Disable as many optimizations as possible.

  WasmEdge_CompilerOptimizationLevel_O0 = 0,

  /// Optimize quickly without destroying debuggability.

  WasmEdge_CompilerOptimizationLevel_O1,

  /// Optimize for fast execution as much as possible without triggering

  /// significant incremental compile time or code size growth.

  WasmEdge_CompilerOptimizationLevel_O2,

  /// Optimize for fast execution as much as possible.

  WasmEdge_CompilerOptimizationLevel_O3,

  /// Optimize for small code size as much as possible without triggering

  /// significant incremental compile time or execution time slowdowns.

  WasmEdge_CompilerOptimizationLevel_Os,

  /// Optimize for small code size as much as possible.

  WasmEdge_CompilerOptimizationLevel_Oz

};



/// AOT compiler output binary format enumeration.

enum WasmEdge_CompilerOutputFormat {

  /// Native dynamic library format.

  WasmEdge_CompilerOutputFormat_Native = 0,

  /// WebAssembly with AOT compiled codes in custom sections.

  WasmEdge_CompilerOutputFormat_Wasm

};

```



Please refer to the [AOT compiler options configuration](#configurations) for details.



## WasmEdge CLI Tools



In this partition, we will introduce the C API for triggering the WasmEdge CLI tools.



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API. The API arguments are the same as the command line arguments of the CLI tools.



### Runtime CLI



The `WasmEdge_Driver_Tool()` API presents the same function as running the [`wasmedge run` command](../../../start/build-and-run/run.md).



Noticed that this API presents the old `wasmedge` CLI tool, which is the same as the `wasmedge run` command. For the current unified `wasmedge` CLI, please refer to the [API below](#unified-cli).



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge runtime tool. */

  return WasmEdge_Driver_Tool(argc, argv);

}

```



### Compiler CLI



The `WasmEdge_Driver_Compiler()` API presents the same function as running the [`wasmedge compile` tool](../../../start/build-and-run/aot.md).



Noticed that this API presents the old `wasmedgec` CLI tool, which is the same as the `wasmedge compile` command. For the current unified `wasmedge` CLI, please refer to the [API below](#unified-cli).



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge AOT compiler. */

  return WasmEdge_Driver_Compiler(argc, argv);

}

```



### Unified CLI



The `WasmEdge_Driver_UniTool()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge unified tool. */

  /* (Within both runtime and AOT compiler) */

  return WasmEdge_Driver_UniTool(argc, argv);

}

```



### CLI Helpers for Windows



On Windows platforms, developers can use the `WasmEdge_Driver_ArgvCreate()` and `WasmEdge_Driver_ArgvDelete()` APIs to convert and handle the `UTF-8` command line arguments, or use the `WasmEdge_Driver_SetConsoleOutputCPtoUTF8()` API to set the console output code page to `UTF-8`.








------"
"The following is a markdown document located at /embed/c/reference/upgrade_to_0.10.0.md
------


---

sidebar_position: 10

---



# Upgrade to WasmEdge 0.10.0



Due to the WasmEdge C API breaking changes, this document shows the guideline of programming with WasmEdge C API to upgrade from the `0.9.1` to the `0.10.0` version.



## Concepts



1. Merged the `WasmEdge_ImportObjectContext` into the `WasmEdge_ModuleInstanceContext`.



   The `WasmEdge_ImportObjectContext` which is for the host functions is merged into `WasmEdge_ModuleInstanceContext`. Developers can use the related APIs to construct host modules.



   - `WasmEdge_ImportObjectCreate()` is changed to `WasmEdge_ModuleInstanceCreate()`.

   - `WasmEdge_ImportObjectDelete()` is changed to `WasmEdge_ModuleInstanceDelete()`.

   - `WasmEdge_ImportObjectAddFunction()` is changed to `WasmEdge_ModuleInstanceAddFunction()`.

   - `WasmEdge_ImportObjectAddTable()` is changed to `WasmEdge_ModuleInstanceAddTable()`.

   - `WasmEdge_ImportObjectAddMemory()` is changed to `WasmEdge_ModuleInstanceAddMemory()`.

   - `WasmEdge_ImportObjectAddGlobal()` is changed to `WasmEdge_ModuleInstanceAddGlobal()`.

   - `WasmEdge_ImportObjectCreateWASI()` is changed to `WasmEdge_ModuleInstanceCreateWASI()`.

   - `WasmEdge_ImportObjectCreateWasmEdgeProcess()` is changed to `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()`.

   - `WasmEdge_ImportObjectInitWASI()` is changed to `WasmEdge_ModuleInstanceInitWASI()`.

   - `WasmEdge_ImportObjectInitWasmEdgeProcess()` is changed to `WasmEdge_ModuleInstanceInitWasmEdgeProcess()`.



   For the new host function examples, please refer to [the example below](#host-functions).



2. Used the pointer to `WasmEdge_FunctionInstanceContext` instead of the index in the `FuncRef` value type.



   For the better performance and security, the `FuncRef` related APIs used the `const WasmEdge_FunctionInstanceContext *` for the parameters and returns.



   - `WasmEdge_ValueGenFuncRef()` is changed to use the `const WasmEdge_FunctionInstanceContext *` as it's argument.

   - `WasmEdge_ValueGetFuncRef()` is changed to return the `const WasmEdge_FunctionInstanceContext *`.



3. Supported multiple anonymous WASM module instantiation.



   In the version before `0.9.1`, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced. After the `0.10.0` version, developers can instantiate multiple anonymous WASM module by `Executor` and get the `Module` instance. But for the source code using the `VM` APIs, the behavior is not changed. For the new examples of instantiating multiple anonymous WASM modules, please refer to [the example below](#wasmedge-executor-changes).



4. Behavior changed of `WasmEdge_StoreContext`.



   The `Function`, `Table`, `Memory`, and `Global` instances retrievement from the `Store` is moved to the `Module` instance. The `Store` only manage the module linking when instantiation and the named module searching after the `0.10.0` version.



   - `WasmEdge_StoreListFunctionLength()` and `WasmEdge_StoreListFunctionRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListFunctionLength()`.

   - `WasmEdge_StoreListTableLength()` and `WasmEdge_StoreListTableRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListTableLength()`.

   - `WasmEdge_StoreListMemoryLength()` and `WasmEdge_StoreListMemoryRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListMemoryLength()`.

   - `WasmEdge_StoreListGlobalLength()` and `WasmEdge_StoreListGlobalRegisteredLength()` is replaced by `WasmEdge_ModuleInstanceListGlobalLength()`.

   - `WasmEdge_StoreListFunction()` and `WasmEdge_StoreListFunctionRegistered()` is replaced by `WasmEdge_ModuleInstanceListFunction()`.

   - `WasmEdge_StoreListTable()` and `WasmEdge_StoreListTableRegistered()` is replaced by `WasmEdge_ModuleInstanceListTable()`.

   - `WasmEdge_StoreListMemory()` and `WasmEdge_StoreListMemoryRegistered()` is replaced by `WasmEdge_ModuleInstanceListMemory()`.

   - `WasmEdge_StoreListGlobal()` and `WasmEdge_StoreListGlobalRegistered()` is replaced by `WasmEdge_ModuleInstanceListGlobal()`.

   - `WasmEdge_StoreFindFunction()` and `WasmEdge_StoreFindFunctionRegistered()` is replaced by `WasmEdge_ModuleInstanceFindFunction()`.

   - `WasmEdge_StoreFindTable()` and `WasmEdge_StoreFindTableRegistered()` is replaced by `WasmEdge_ModuleInstanceFindTable()`.

   - `WasmEdge_StoreFindMemory()` and `WasmEdge_StoreFindMemoryRegistered()` is replaced by `WasmEdge_ModuleInstanceFindMemory()`.

   - `WasmEdge_StoreFindGlobal()` and `WasmEdge_StoreFindGlobalRegistered()` is replaced by `WasmEdge_ModuleInstanceFindGlobal()`.



   For the new examples of retrieving instances, please refer to [the example below](#instances-retrievement).



5. The `WasmEdge_ModuleInstanceContext`-based resource management.



   Except the creation of `Module` instance for the host functions, the `Executor` will output a `Module` instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by `WasmEdge_ModuleInstanceDelete()` API. The `Store` will link to the named `Module` instance after registering. After the destroyment of a `Module` instance, the `Store` will unlink to that automatically; after the destroyment of the `Store`, the all `Module` instances the `Store` linked to will unlink to that `Store` automatically.



## WasmEdge VM changes



The `VM` APIs are basically not changed, except the `ImportObject` related APIs.



The following is the example of WASI initialization in WasmEdge `0.9.1` C API:



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

/* The following API can retrieve the pre-registration import objects from the VM context. */

/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */

WasmEdge_ImportObjectContext *WasiObject =

    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);

/* Initialize the WASI. */

WasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );



/* ... */



WasmEdge_VMDelete(VMCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



Developers can change to use the WasmEdge `0.10.0` C API as follows, with only replacing the `WasmEdge_ImportObjectContext` into `WasmEdge_ModuleInstanceContext`:



```c

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

/* The following API can retrieve the pre-registration module instances from the VM context. */

/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */

WasmEdge_ModuleInstanceContext *WasiModule =

    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);

/* Initialize the WASI. */

WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );



/* ... */



WasmEdge_VMDelete(VMCxt);

WasmEdge_ConfigureDelete(ConfCxt);

```



The `VM` provides a new API for getting the current instantiated anonymous `Module` instance. For example, if developer want to get the exported `Global` instance:



```c

/* Assume that a WASM module is instantiated in `VMCxt`, and exports the ""global_i32"". */

WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

WasmEdge_String GlobName = WasmEdge_StringCreateByCString(""global_i32"");

WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_StoreFindGlobal(StoreCxt, GlobName);

WasmEdge_StringDelete(GlobName);

```



After the WasmEdge `0.10.0` C API, developers can use the `WasmEdge_VMGetActiveModule()` to get the module instance:



```c

/* Assume that a WASM module is instantiated in `VMCxt`, and exports the ""global_i32"". */

const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);

/* The example of retrieving the global instance. */

WasmEdge_String GlobName = WasmEdge_StringCreateByCString(""global_i32"");

WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_ModuleInstanceFindGlobal(ModCxt, GlobName);

WasmEdge_StringDelete(GlobName);

```



## WasmEdge Executor changes



`Executor` helps to instantiate a WASM module, register a WASM module into `Store` with module name, register the host modules with host functions, or invoke functions.



1. WASM module instantiation



   In WasmEdge `0.9.1` version, developers can instantiate a WASM module by the `Executor` API:



   ```c

   WasmEdge_ASTModuleContext *ASTCxt;

   /*

    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.

    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.

    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.

    */

   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   ```



   Then the WASM module is instantiated into an anonymous module instance and handled by the `Store`. If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned. After the WasmEdge `0.10.0` version, the instantiated anonymous module will be outputted and handled by caller, and not only 1 anonymous module instance can be instantiated. Developers have the responsibility to destroy the outputted module instances.



   ```c

   WasmEdge_ASTModuleContext *ASTCxt1, *ASTCxt2;

   /*

    * Assume that `ASTCxt1` and `ASTCxt2` are loaded WASMs from different files or buffers,

    * and have both passed the validation.

    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.

    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.

    */

   WasmEdge_ModuleInstanceContext *ModCxt1 = NULL;

   WasmEdge_ModuleInstanceContext *ModCxt2 = NULL;

   WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt1);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt2, StoreCxt, ASTCxt2);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   ```



2. WASM module registration with module name



   When instantiating and registering a WASM module with module name, developers can use the `WasmEdge_ExecutorRegisterModule()` API before WasmEdge `0.9.1`.



   ```c

   WasmEdge_ASTModuleContext *ASTCxt;

   /*

    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.

    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.

    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.

    */



   /* Register the WASM module into store with the export module name ""mod"". */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);

   WasmEdge_StringDelete(ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   ```



   The same feature is implemented in WasmEdge `0.10.0`, but in different API `WasmEdge_ExecutorRegister()`:



   ```c

   WasmEdge_ASTModuleContext *ASTCxt;

   /*

    * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.

    * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.

    * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.

    */



   /* Register the WASM module into store with the export module name ""mod"". */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""mod"");

   /* The output module instance. */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   Res = WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);

   WasmEdge_StringDelete(ModName);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""WASM registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   ```



   Developers have the responsibility to destroy the outputted module instances.



3. Host module registration



   In WasmEdge `0.9.1`, developers can create a `WasmEdge_ImportObjectContext` and register into `Store`.



   ```c

   /* Create the import object with the export module name. */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ModName);

   WasmEdge_StringDelete(ModName);

   /*

    * ...

    * Add the host functions, tables, memories, and globals into the import object.

    */

   /* The import module context has already contained the export module name. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpObj);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Import object registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   ```



   After WasmEdge `0.10.0`, developers should use the `WasmEdge_ModuleInstanceContext` instead:



   ```c

   /* Create the module instance with the export module name. */

   WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module"");

   WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_ModuleInstanceCreate(ModName);

   WasmEdge_StringDelete(ModName);

   /*

    * ...

    * Add the host functions, tables, memories, and globals into the module instance.

    */

   /* The module instance context has already contained the export module name. */

   Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ModCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Module instance registration failed: %s\n"", WasmEdge_ResultGetMessage(Res));

   }

   ```



   Developers have the responsibility to destroy the created module instances.



4. WASM function invocation



   This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat). In WasmEdge `0.9.1` version, developers can invoke a WASM function with the export function name:



   ```c

   /* Create the store context. The store context holds the instances. */

   WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

   /* Result. */

   WasmEdge_Result Res;



   /* Create the loader context. The configure context can be NULL. */

   WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

   /* Create the validator context. The configure context can be NULL. */

   WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);

   /* Create the executor context. The configure context and the statistics context can be NULL. */

   WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);



   /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */

   WasmEdge_ASTModuleContext *ASTCxt = NULL;

   Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   /* Validate the WASM module. */

   Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   /* Instantiate the WASM module into the store context. */

   Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   /* Invoke the function which is exported with the function name ""fib"". */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };

   WasmEdge_Value Returns[1];

   Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);

   if (WasmEdge_ResultOK(Res)) {

     printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

   } else {

     printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   WasmEdge_ASTModuleDelete(ASTCxt);

   WasmEdge_LoaderDelete(LoadCxt);

   WasmEdge_ValidatorDelete(ValidCxt);

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



   After the WasmEdge `0.10.0`, developers should retrieve the `Function` instance by function name first.



   ```c

   /*

    * ...

    * Ignore the unchanged steps before validation. Please refer to the sample code above.

    */

   WasmEdge_ModuleInstanceContext *ModCxt = NULL;

   /* Instantiate the WASM module. */

   Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt1, StoreCxt, ASTCxt);

   if (!WasmEdge_ResultOK(Res)) {

     printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }

   /* Retrieve the function instance by name. */

   WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

   WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

   WasmEdge_StringDelete(FuncName);

   /* Invoke the function. */

   WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };

   WasmEdge_Value Returns[1];

   Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);

   if (WasmEdge_ResultOK(Res)) {

     printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

   } else {

     printf(""Execution phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

     return -1;

   }



   WasmEdge_ModuleInstanceDelete(ModCxt);

   WasmEdge_ASTModuleDelete(ASTCxt);

   WasmEdge_LoaderDelete(LoadCxt);

   WasmEdge_ValidatorDelete(ValidCxt);

   WasmEdge_ExecutorDelete(ExecCxt);

   WasmEdge_StoreDelete(StoreCxt);

   ```



## Instances retrievement



This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



Before the WasmEdge `0.9.1` versions, developers can retrieve all exported instances of named or anonymous modules from `Store`:



```c

/* Create the store context. The store context holds the instances. */

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/* Result. */

WasmEdge_Result Res;



/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);

/* Create the executor context. The configure context and the statistics context can be NULL. */

WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);



/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */

WasmEdge_ASTModuleContext *ASTCxt = NULL;

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

/* Validate the WASM module. */

Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

/* Example: register and instantiate the WASM module with the module name ""module_fib"". */

WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module_fib"");

Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

/* Example: Instantiate the WASM module into the store context. */

Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

WasmEdge_StringDelete(ModName);



/* Now, developers can retrieve the exported instances from the store. */

/* Take the exported functions as example. This WASM exports the function ""fib"". */

WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

WasmEdge_FunctionInstanceContext *FoundFuncCxt;

/* Find the function ""fib"" from the instantiated anonymous module. */

FoundFuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);

/* Find the function ""fib"" from the registered module ""module_fib"". */

ModName = WasmEdge_StringCreateByCString(""module_fib"");

FoundFuncCxt = WasmEdge_StoreFindFunctionRegistered(StoreCxt, ModName, FuncName);

WasmEdge_StringDelete(ModName);

WasmEdge_StringDelete(FuncName);



WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ValidatorDelete(ValidCxt);

WasmEdge_ExecutorDelete(ExecCxt);

WasmEdge_StoreDelete(StoreCxt);

```



After the WasmEdge `0.10.0`, developers can instantiate several anonymous `Module` instances, and should retrieve the exported instances from named or anonymous `Module` instances:



```c

/* Create the store context. The store context is the object to link the modules for imports and exports. */

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/* Result. */

WasmEdge_Result Res;



/* Create the loader context. The configure context can be NULL. */

WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

/* Create the validator context. The configure context can be NULL. */

WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);

/* Create the executor context. The configure context and the statistics context can be NULL. */

WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);



/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */

WasmEdge_ASTModuleContext *ASTCxt = NULL;

Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, ""fibonacci.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

/* Validate the WASM module. */

Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Validation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

/* Example: register and instantiate the WASM module with the module name ""module_fib"". */

WasmEdge_ModuleInstanceContext *NamedModCxt = NULL;

WasmEdge_String ModName = WasmEdge_StringCreateByCString(""module_fib"");

Res = WasmEdge_ExecutorRegister(ExecCxt, &NamedModCxt, StoreCxt, ASTCxt, ModName);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

/* Example: Instantiate the WASM module and get the output module instance. */

WasmEdge_ModuleInstanceContext *ModCxt = NULL;

Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Instantiation phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

  return -1;

}

WasmEdge_StringDelete(ModName);



/* Now, developers can retrieve the exported instances from the module instances. */

/* Take the exported functions as example. This WASM exports the function ""fib"". */

WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

WasmEdge_FunctionInstanceContext *FoundFuncCxt;

/* Find the function ""fib"" from the instantiated anonymous module. */

FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);

/* Find the function ""fib"" from the registered module ""module_fib"". */

FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(NamedModCxt, FuncName);

/* Or developers can get the named module instance from the store: */

ModName = WasmEdge_StringCreateByCString(""module_fib"");

const WasmEdge_ModuleInstanceContext *ModCxtGot = WasmEdge_StoreFindModule(StoreCxt, ModName);

WasmEdge_StringDelete(ModName);

FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxtGot, FuncName);

WasmEdge_StringDelete(FuncName);



WasmEdge_ModuleInstanceDelete(NamedModCxt);

WasmEdge_ModuleInstanceDelete(ModCxt);

WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);

WasmEdge_ValidatorDelete(ValidCxt);

WasmEdge_ExecutorDelete(ExecCxt);

WasmEdge_StoreDelete(StoreCxt);

```



## Host functions



The difference of host functions are the replacement of `WasmEdge_ImportObjectContext`.



```c

/* Host function body definition. */

WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                    const WasmEdge_Value *In, WasmEdge_Value *Out) {

  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

  return WasmEdge_Result_Success;

}



/* Create the import object. */

WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);

WasmEdge_StringDelete(ExportName);



/* Create and add a function instance into the import object. */

enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

WasmEdge_FunctionTypeContext *HostFType =

    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

WasmEdge_FunctionInstanceContext *HostFunc =

    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

/*

 * The third parameter is the pointer to the additional data object.

 * Developers should guarantee the life cycle of the data, and it can be

 * `NULL` if the external data is not needed.

 */

WasmEdge_FunctionTypeDelete(HostFType);

WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

WasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);

WasmEdge_StringDelete(FuncName);



/*

 * The import objects should be deleted.

 * Developers should __NOT__ destroy the instances added into the import object contexts.

 */

WasmEdge_ImportObjectDelete(ImpObj);

```



Developers can use the `WasmEdge_ModuleInstanceContext` to upgrade to WasmEdge `0.10.0` easily.



```c

/* Host function body definition. */

WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                    const WasmEdge_Value *In, WasmEdge_Value *Out) {

  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

  return WasmEdge_Result_Success;

}



/* Create a module instance. */

WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);

WasmEdge_StringDelete(ExportName);



/* Create and add a function instance into the module instance. */

enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };

enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };

WasmEdge_FunctionTypeContext *HostFType =

    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

WasmEdge_FunctionInstanceContext *HostFunc =

    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

/*

 * The third parameter is the pointer to the additional data object.

 * Developers should guarantee the life cycle of the data, and it can be

 * `NULL` if the external data is not needed.

 */

WasmEdge_FunctionTypeDelete(HostFType);

WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add"");

WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);

WasmEdge_StringDelete(FuncName);



/*

 * The module instance should be deleted.

 * Developers should __NOT__ destroy the instances added into the module instance contexts.

 */

WasmEdge_ModuleInstanceDelete(HostModCxt);

```








------"
"The following is a markdown document located at /embed/c/reference/upgrade_to_0.11.0.md
------


---

sidebar_position: 8

---



# Upgrade to WasmEdge 0.11.0



Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.10.1` to the `0.11.0` version.



## Concepts



1. Supported the user-defined error code in host functions.



   Developers can use the new API `WasmEdge_ResultGen()` to generate a `WasmEdge_Result` struct with `WasmEdge_ErrCategory_UserLevelError` and the error code. With this support, developers can specify the host function error code when failed by themselves. For the examples to specify the user-defined error code, please refer to [the example below](#user-defined-error-code-in-host-functions).



2. Calling frame for the host function extension



   In the previous versions, host functions only pass the memory instance into the function body. For supporting the WASM multiple memories proposal and providing the recursive invocation in host functions, the new context `WasmEdge_CallingFrameContext` replaced the memory instance in the second argument of the host function definition. For the examples of the new host function definition, please refer to [the example below](#calling-frame-in-host-functions).



3. Apply the SONAME and SOVERSION.



   When linking the WasmEdge shared library, please notice that `libwasmedge_c.so` is renamed to `libwasmedge.so` after the 0.11.0 release. Please use `-lwasmedge` instead of `-lwasmedge_c` for the linker option.



## User Defined Error Code In Host Functions



Assume that we want to specify that the host function failed in the versions before `0.10.1`:



```c

/* Host function body definition. */

WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* This will create a trap in WASM. */

  return WasmEdge_Result_Fail;

}

```



When the execution is finished, developers will get the `WasmEdge_Result`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.



For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.



```c

/* Host function body definition. */

WasmEdge_Result FaildFunc(void *Data,

                          const WasmEdge_CallingFrameContext *CallFrameCxt,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* This will create a trap in WASM with the error code. */

  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);

}

```



Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. Noticed that if developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.



## Calling Frame In Host Functions



When implementing the host functions, developers usually use the input memory instance to load or store data. In the WasmEdge versions before `0.10.1`, the argument before the input and return value list of the host function definition is the memory instance context, so that developers can access the data in the memory instance.



```c

/* Host function body definition. */

WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                           const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* Function type: {i32} -> {} */

  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

  uint32_t Num = 0;

  WasmEdge_Result Res =

      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

  if (WasmEdge_ResultOK(Res)) {

    printf(""u32 at memory[%u]: %u\n"", Offset, Num);

  } else {

    return Res;

  }

  return WasmEdge_Result_Success;

}

```



The input memory instance is the one that belongs to the module instance on the top calling frame of the stack. However, after applying the WASM multiple memories proposal, there may be more than 1 memory instance in a WASM module. Furthermore, there may be requests for accessing the module instance on the top frame of the stack to get the exported WASM functions, such as recursive invocation in host functions. To support these, the `WasmEdge_CallingFrameContext` is designed to replace the memory instance input of the host function.



In the WasmEdge versions after `0.11.0`, the host function definitions are changed:



```c

typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

    const WasmEdge_Value *Params, WasmEdge_Value *Returns);



typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(

    void *This, void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

    const WasmEdge_Value *Params, const uint32_t ParamLen,

    WasmEdge_Value *Returns, const uint32_t ReturnLen);

```



Developers need to change to use the `WasmEdge_CallingFrameContext` related APIs to access the memory instance:



```c

/* Host function body definition. */

WasmEdge_Result LoadOffset(void *Data,

                           const WasmEdge_CallingFrameContext *CallFrameCxt,

                           const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* Function type: {i32} -> {} */

  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

  uint32_t Num = 0;



  /* Get the 0th memory instance of the module of the top frame on the stack. */

  WasmEdge_MemoryInstanceContext *MemCxt =

      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);

  WasmEdge_Result Res =

      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

  if (WasmEdge_ResultOK(Res)) {

    printf(""u32 at memory[%u]: %u\n"", Offset, Num);

  } else {

    return Res;

  }

  return WasmEdge_Result_Success;

}

```



The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents.



The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.








------"
"The following is a markdown document located at /embed/c/reference/upgrade_to_0.12.0.md
------


---

sidebar_position: 6

---



# Upgrade to WasmEdge 0.12.0



Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.11.2` to the `0.12.0` version.



## Concepts



1. Removed the members of the `WasmEdge_HostRegistration` enumeration.



   The following members of the `WasmEdge_HostRegistration` enumeration are removed:



   - `WasmEdge_HostRegistration_WasmEdge_Process`

   - `WasmEdge_HostRegistration_WasiNN`

   - `WasmEdge_HostRegistration_WasiCrypto_Common`

   - `WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon`

   - `WasmEdge_HostRegistration_WasiCrypto_Kx`

   - `WasmEdge_HostRegistration_WasiCrypto_Signatures`

   - `WasmEdge_HostRegistration_WasiCrypto_Symmetric`



   The `WasmEdge_VMContext` will create and register the host modules automatically now. If the plug-ins are not loaded, the `WasmEdge_VMContext` will create and register the mock modules to prevent from import failed.



2. Removed the module instance creation functions of the plug-ins.



   The following APIs are removed:



   - `WasmEdge_ModuleInstanceCreateWasiNN()`

   - `WasmEdge_ModuleInstanceCreateWasiCryptoCommon()`

   - `WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()`

   - `WasmEdge_ModuleInstanceCreateWasiCryptoKx()`

   - `WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()`

   - `WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()`

   - `WasmEdge_ModuleInstanceCreateWasmEdgeProcess()`



   For the new examples for creating the module instances from plug-ins, please refer to [the example below](#creating-the-module-instance-from-a-plug-in).



3. New module instance retrieving API of `VM` context.



   - Added `WasmEdge_VMGetRegisteredModule()` for retrieving registered named module in VM context quickly.

   - Added `WasmEdge_VMListRegisteredModuleLength()` and `WasmEdge_VMListRegisteredModule()` for listing registered named modules in VM context quickly.



## The `WasmEdge_HostRegistration` for plug-ins is not necessary in VM contexts



Before the version `0.11.2`, developers should add the configurations when they want to load the plug-ins in VM:



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();

WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);

WasmEdge_ConfigureAddHostRegistration(Conf,

                                      WasmEdge_HostRegistration_WasiCrypto_Kx);

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);

WasmEdge_ConfigureDelete(Conf);



WasmEdge_String Names[32];

WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

uint32_t ModuleLen = WasmEdge_StoreListModule(StoreCxt, Names, 32);

for (uint32_t I = 0; I < ModuleLen; I++) {

  printf(""%s\n"", Names[I].Buf);

}

/*

 * Will print:

 * wasi_ephemeral_crypto_asymmetric_common

 * wasi_ephemeral_crypto_common

 * wasi_ephemeral_crypto_kx

 * wasi_ephemeral_crypto_signatures

 * wasi_ephemeral_crypto_symmetric

 */

WasmEdge_VMDelete(VMCxt);

```



After `0.12.0`, the plug-ins will automatically loaded after the `WasmEdge_PluginLoadWithDefaultPaths()` called or the specific path given into the `WasmEdge_PluginLoadFromPath()` API.



For the plug-ins not installed, the mocked modules will be registered into VM context and will print the error message when invoking the host functions to notice the users to install the plug-in.



```c

WasmEdge_PluginLoadWithDefaultPaths();

WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();

/* The `WasmEdge_HostRegistration_Wasi` is still needed. */

WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);

WasmEdge_ConfigureDelete(Conf);



WasmEdge_String Names[32];

uint32_t ModuleLen = WasmEdge_VMListRegisteredModule(VMCxt, Names, 32);

for (uint32_t I = 0; I < ModuleLen; I++) {

  printf(""%s\n"", Names[I].Buf);

}

/*

 * Will print:

 * wasi_ephemeral_crypto_asymmetric_common

 * wasi_ephemeral_crypto_common

 * wasi_ephemeral_crypto_kx

 * wasi_ephemeral_crypto_signatures

 * wasi_ephemeral_crypto_symmetric

 * wasi_ephemeral_nn

 * wasi_snapshot_preview1

 * wasmedge_httpsreq

 * wasmedge_process

 */

WasmEdge_VMDelete(VMCxt);

```



<!-- prettier-ignore -->

:::note

The `WasmEdge_HostRegistration_Wasi` configuration is still needed if developers want to use the WASI.

:::



## Creating the module instance from a plug-in



When developers didn't use the VM context to load the plug-ins, they can use the creation functions before the `0.11.2` versions:



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();



WasmEdge_ModuleInstance *WasiCryptoCommonCxt =

    WasmEdge_ModuleInstanceCreateWasiCryptoCommon();



WasmEdge_ModuleInstanceDelete(WasiCryptoCommonCxt);

```



But it not make sense and not extensionable if developers should use different APIs for the different plug-ins.



After the `0.12.0` version, the `WasmEdge_PluginContext` is added, and developers can use the general API to create the module instances:



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();



const char CryptoPName[] = ""wasi_crypto"";

const char CryptoMName[] = ""wasi_crypto_common"";

WasmEdge_String PluginName =

    WasmEdge_StringWrap(CryptoPName, strlen(CryptoPName));

WasmEdge_String ModuleName =

    WasmEdge_StringWrap(CryptoMName, strlen(CryptoMName));

const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(PluginName);



WasmEdge_ModuleInstance *ModCxt =

    WasmEdge_PluginCreateModule(PluginCxt, ModuleName);



WasmEdge_ModuleInstanceDelete(ModCxt);

```



## Retrieving the module instances from the VM context



Before the version `0.11.2`, developers can retrieve the `WASI` or the modules from plug-ins with the `WasmEdge_HostRegistration` values, or retrieve the registered modules from the store context.



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();

WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();

/* Add the WASI-Crypto related configurations. */

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_Common);

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);

WasmEdge_ConfigureAddHostRegistration(Conf,

                                      WasmEdge_HostRegistration_WasiCrypto_Kx);

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_Signatures);

WasmEdge_ConfigureAddHostRegistration(

    Conf, WasmEdge_HostRegistration_WasiCrypto_Symmetric);

/* Add the WASI configurations. */

WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);

WasmEdge_ConfigureDelete(Conf);



/* Get the WASI module instance. */

WasmEdge_ModuleInstance *WASIModInst =

    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);

/* Get the WASI-crypto-common module instance. */

WasmEdge_ModuleInstance *WASICryptoCommonModInst =

    WasmEdge_VMGetImportModuleContext(

        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);



/* Get the registered module instance by name. */

WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);

WasmEdge_String ModName =

    WasmEdge_StringCreateByCString(""wasi_ephemeral_crypto_kx"");

const WasmEdge_ModuleInstance *WASICryptoKxModInst =

    WasmEdge_StoreFindModule(StoreCxt, ModName);

WasmEdge_StringDelete(ModName);



WasmEdge_VMDelete(VMCxt);

```



After the `0.12.0` version, due to removing the plug-in related configurations and automatically registering the plug-ins into VM contexts, developers cannot use the `WasmEdge_VMGetImportModuleContext()` API to retrieve the module instances except the built-in host modules (`WASI` currently).



However, developers can use the new APIs to retrieve the registered module instances more quickly.



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();

WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();

/* Add the WASI configurations. */

WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(Conf, NULL);

WasmEdge_ConfigureDelete(Conf);



/* Get the WASI module instance. */

WasmEdge_ModuleInstance *WASIModInst =

    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);

/* Get the registered WASI-crypto-common module instance by name. */

WasmEdge_String ModName =

    WasmEdge_StringCreateByCString(""wasi_ephemeral_crypto_common"");

const WasmEdge_ModuleInstance *WASICryptoKxModInst =

    WasmEdge_VMGetImportModuleContext(VMCxt, ModName);

WasmEdge_StringDelete(ModName);



WasmEdge_VMDelete(VMCxt);

```








------"
"The following is a markdown document located at /embed/c/reference/upgrade_to_0.13.0.md
------


---

sidebar_position: 4

---



# Upgrade to WasmEdge 0.13.0



Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.12.1` to the `0.13.0` version.



In this version, there are only new features. Developers can build their original source with this WasmEdge version directly.



## Concepts



1. Introduced new API for setting data and its finalizer into module instances when creation.



   Developers can use the `WasmEdge_ModuleInstanceCreateWithData()` API to set the host data and its finalizer into the module instance.



2. Asynchronously invoking WASM function by executor.



   Developers can use the `WasmEdge_ExecutorAsyncInvoke()` API to execute a WASM function asynchronously.



3. Unified WasmEdge CLI.



   Developers can use the `WasmEdge_Driver_UniTool()` API to trigger the unified WasmEdge CLI.



## Set data and its finalizer into a module instance when creation



Besides setting host data into a host function, developers can set and move ownership of host data into a `Module` instance context with its finalizer. This may be useful when implementing the plug-ins.



```c

/* Struct definition. */

typedef struct Point {

  int X;

  int Y;

} Point;



/* Host function body definition. */

WasmEdge_Result Print(void *Data,

                      const WasmEdge_CallingFrameContext *CallFrameCxt,

                      const WasmEdge_Value *In, WasmEdge_Value *Out) {

  Point *P = (Point *)In;

  printf(""Point: (%d, %d)\n"", P->X, P->Y);

  return WasmEdge_Result_Success;

}



/* Finalizer definition. */

void PointFinalizer(void *Data) {

  if (Data) {

    free((Point *)Data);

  }

}



/* Create a module instance with host data and its finalizer. */

WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""module"");

Point *Data = (Point *)malloc(sizeof(Point));

Data->X = 5;

Data->Y = -5;

WasmEdge_ModuleInstanceContext *HostModCxt =

    WasmEdge_ModuleInstanceCreateWithData(ExportName, Data, PointFinalizer);

/*

 * When the `HostModCxt` being destroyed, the finalizer will be invoked and the

 * `Data` will be its argument.

 */

WasmEdge_StringDelete(ExportName);

```



## Unified WasmEdge CLI



The `WasmEdge_Driver_UniTool()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int argc, const char *argv[]) {

  /* Run the WasmEdge unified tool. */

  /* (Within both runtime and AOT compiler) */

  return WasmEdge_Driver_UniTool(argc, argv);

}

```








------"
"The following is a markdown document located at /embed/c/reference/upgrade_to_0.14.0.md
------


---

sidebar_position: 2

---



# Upgrade to WasmEdge 0.14.0



Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `0.13.5` to the `0.14.0` version.



## Concepts



1. Introduced new APIs for `WasmEdge_ValType` struct and integrated with WASM values.



   The `WasmEdge_ValType` becomes a struct for supporting the [typed function reference proposal](https://github.com/WebAssembly/function-references) and [GC proposal](https://github.com/WebAssembly/gc).



   The enumerations `enum WasmEdge_ValType` and `enum WasmEdge_RefType` are renamed as `enum WasmEdge_ValTypeCode` and `enum WasmEdge_RefTypeCode`. Developers should use the following APIs to generate the `WasmEdge_ValType` structures:



   - `WasmEdge_ValTypeGenI32()`

   - `WasmEdge_ValTypeGenI64()`

   - `WasmEdge_ValTypeGenF32()`

   - `WasmEdge_ValTypeGenF64()`

   - `WasmEdge_ValTypeGenV128()`

   - `WasmEdge_ValTypeGenFuncRef()`

   - `WasmEdge_ValTypeGenExternRef()`



   And there's new APIs for checking the value types from the `WasmEdge_ValType` struct:



   - `WasmEdge_ValTypeIsEqual()`

   - `WasmEdge_ValTypeIsI32()`

   - `WasmEdge_ValTypeIsI64()`

   - `WasmEdge_ValTypeIsF32()`

   - `WasmEdge_ValTypeIsF64()`

   - `WasmEdge_ValTypeIsV128()`

   - `WasmEdge_ValTypeIsFuncRef()` for checking whether a type is a nullable or non-nullable function reference.

   - `WasmEdge_ValTypeIsExternRef()` for checking whether a type is a nullable or non-nullable external reference.

   - `WasmEdge_ValTypeIsRef()` for checking whether a type is a nullable or non-nullable reference.

   - `WasmEdge_ValTypeIsRefNull()` for checking whether a type is a nullable reference.



   The following APIs using value types as parameters and return values are affected:



   - `WasmEdge_FunctionTypeCreate()`

   - `WasmEdge_FunctionTypeGetParameters()`

   - `WasmEdge_FunctionTypeGetReturns()`

   - `WasmEdge_TableTypeCreate()`

   - `WasmEdge_TableTypeGetRefType()`: returns a `WasmEdge_ValType`, which is guaranteed as a reference type.

   - `WasmEdge_GlobalTypeCreate()`

   - `WasmEdge_GlobalTypeGetValType()`



   The following API is deleted:



   - `WasmEdge_ValueGenNullRef()`: please use `WasmEdge_ValueGenFuncRef()` or `WasmEdge_ValueGenExternRef()` instead.



2. Introduced `WasmEdge_Bytes` for loading and serialization.



   Rathar than the raw buffer, we recommand developers to use `WasmEdge_Bytes` and related APIs to manage the input and output buffer for loading and serializing a WASM binary.



   - `WasmEdge_BytesCreate()`: create a `WasmEdge_Bytes` and copy from buffer with size.

   - `WasmEdge_BytesWrap()`: wrap a `WasmEdge_Bytes` onto a buffer with size.

   - `WasmEdge_BytesDelete()`: delete a allocated `WasmEdge_Bytes`.



   For the old APIs, we also introduced the `WasmEdge_Bytes` version. The old APIs will be deprecated in the future.



   - `WasmEdge_CompilerCompileFromBytes()`: this API has the same behavior as `WasmEdge_CompilerCompileFromBuffer()`.

   - `WasmEdge_LoaderParseFromBytes()`: this API has the same behavior as `WasmEdge_LoaderParseFromBuffer()`.

   - `WasmEdge_LoaderSerializeASTModule()`: this API outputs a `WasmEdge_Bytes`, and the result should be deleted by the caller.

   - `WasmEdge_VMRegisterModuleFromBytes()`: this API has the same behavior as `WasmEdge_VMRegisterModuleFromBuffer()`.

   - `WasmEdge_VMRunWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMRunWasmFromBuffer()`.

   - `WasmEdge_VMAsyncRunWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMAsyncRunWasmFromBuffer()`.

   - `WasmEdge_VMLoadWasmFromBytes()`: this API has the same behavior as `WasmEdge_VMLoadWasmFromBuffer()`.



3. APIs of instances changed for the new proposal.



   For supporting the [typed function reference proposal](https://github.com/WebAssembly/function-references) and [GC proposal](https://github.com/WebAssembly/gc) proposal, the new API of table instance is needed for the defaultable reference values.



   - `WasmEdge_TableInstanceCreateWithInit()`: developers can use this API to create a table instance with default value.



   Furthermore, for type matching and mutation checking, the result error is needed.



   - `WasmEdge_GlobalInstanceSetValue()`: returns `WasmEdge_Result` for result, and error occurs when type not matched or mutation failed.



## Value type creation and checking



Before the version `0.13.5`, the `WasmEdge_ValType` is an `enum`:



```c

enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,

                                      WasmEdge_ValType_I32};

enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};

/* Create a function type: {i32, i32} -> {i32}. */

WasmEdge_FunctionTypeContext *HostFType =

    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



WasmEdge_FunctionTypeDelete(HostType);

```



After `0.14.0`, developers should use the APIs to generate the `WasmEdge_ValType`. This affects the APIs list above.



```c

WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};

WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};

/* Create a function type: {i32, i32} -> {i32}. */

WasmEdge_FunctionTypeContext *HostFType =

    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);



WasmEdge_FunctionTypeDelete(HostType);

```



## Use packaged buffer for loading



Before the version `0.13.5`, developers can use the raw buffer to load WASM binary:



```c

uint8_t WASM[] = {/* WASM header */

                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                  /* Type section */

                  0x01, 0x07, 0x01,

                  /* function type {i32, i32} -> {i32} */

                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                  /* Import section */

                  0x02, 0x13, 0x01,

                  /* module name: ""extern"" */

                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                  /* extern name: ""func-add"" */

                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                  /* import desc: func 0 */

                  0x00, 0x00,

                  /* Function section */

                  0x03, 0x02, 0x01, 0x00,

                  /* Export section */

                  0x07, 0x0A, 0x01,

                  /* export name: ""addTwo"" */

                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                  /* export desc: func 0 */

                  0x00, 0x01,

                  /* Code section */

                  0x0A, 0x0A, 0x01,

                  /* code body */

                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;



/* Load WASM or compiled-WASM from the buffer. */

Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, WASM, sizeof(WASM));

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

```



After `0.14.0`, we recommanded developers use the `WasmEdge_Bytes` related APIs instead. The old APIs still work, but will be deprecated in the future.



```c

uint8_t WASM[] = {/* WASM header */

                  0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                  /* Type section */

                  0x01, 0x07, 0x01,

                  /* function type {i32, i32} -> {i32} */

                  0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                  /* Import section */

                  0x02, 0x13, 0x01,

                  /* module name: ""extern"" */

                  0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                  /* extern name: ""func-add"" */

                  0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                  /* import desc: func 0 */

                  0x00, 0x00,

                  /* Function section */

                  0x03, 0x02, 0x01, 0x00,

                  /* Export section */

                  0x07, 0x0A, 0x01,

                  /* export name: ""addTwo"" */

                  0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                  /* export desc: func 0 */

                  0x00, 0x01,

                  /* Code section */

                  0x0A, 0x0A, 0x01,

                  /* code body */

                  0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

WasmEdge_ASTModuleContext *ASTCxt = NULL;

WasmEdge_Result Res;

/* Wrap onto the `WASM`. */

WasmEdge_Bytes Bytes = WasmEdge_BytesWrap(WASM, sizeof(WASM));

/*

 * If developers want to copy from buffer, use the `WasmEdge_BytesCreate()`

 * instead. The created `WasmEdge_Bytes` should be destroyed.

 */



/* Load WASM or compiled-WASM from the buffer. */

Res = WasmEdge_LoaderParseFromBytes(LoadCxt, &ASTCxt, Bytes);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Loading phase failed: %s\n"", WasmEdge_ResultGetMessage(Res));

}

/* The output AST module context should be destroyed. */

WasmEdge_ASTModuleDelete(ASTCxt);



WasmEdge_LoaderDelete(LoadCxt);

```








------"
"```json:/embed/c/_category_.json


{

  ""label"": ""C SDK for Embedding WasmEdge"",

  ""position"": 4,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to embed WasmEdge with the C API.""

  }

}








```"
"The following is a markdown document located at /embed/c/externref.md
------


---

sidebar_position: 4

---



# Customized External References



[External References](https://webassembly.github.io/spec/core/syntax/types.html#syntax-reftype) denotes an opaque and unforgettable reference to a host object. A new `externref` type can be passed into a WASM module or returned. The WASM module cannot reveal an `externref` value's bit pattern nor create a fake host reference by an integer value.



<!-- prettier-ignore -->

:::note

For all WASM example codes used in this chapter, users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.

:::



## Tutorial



The following tutorial summarizes the `externref` example in WasmEdge.



### Prepare Your WASM File



The WASM file should contain importing host functions that take the `externref`. Take [this WAT](https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat) as an example:



```wasm

(module

  (type $t0 (func (param externref i32) (result i32)))

  (type $t1 (func (param externref i32 i32) (result i32)))

  (type $t2 (func (param externref externref i32 i32) (result i32)))

  (import ""extern_module"" ""functor_square"" (func $functor_square (type $t0)))

  (import ""extern_module"" ""class_add"" (func $class_add (type $t1)))

  (import ""extern_module"" ""func_mul"" (func $func_mul (type $t1)))

  (func $call_add (export ""call_add"") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)

    (call $class_add

      (local.get $p0)

      (local.get $p1)

      (local.get $p2)))

  (func $call_mul (export ""call_mul"") (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)

    (call $func_mul

      (local.get $p0)

      (local.get $p1)

      (local.get $p2)))

  (func $call_square (export ""call_square"") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)

    (call $functor_square

      (local.get $p0)

      (local.get $p1)))

  (func $call_add_square (export ""call_add_square"") (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)

    (call $functor_square

      (local.get $p1)

      (call $class_add

        (local.get $p0)

        (local.get $p2)

        (local.get $p3))))

  (memory $memory (export ""memory"") 1))

```



### Implement Host Module and Register into WasmEdge



The host module should be implemented and registered into WasmEdge before executing Wasm. Assume that the following code is saved as `main.c`:



```c

#include <wasmedge/wasmedge.h>



#include <stdio.h>



uint32_t SquareFunc(uint32_t A) { return A * A; }

uint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }

uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }



// Host function to call `SquareFunc` by external reference

WasmEdge_Result ExternSquare(void *Data,

                             const WasmEdge_CallingFrameContext *CallFrameCxt,

                             const WasmEdge_Value *In, WasmEdge_Value *Out) {

  // Function type: {externref, i32} -> {i32}

  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);

  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));

  Out[0] = WasmEdge_ValueGenI32(C);

  return WasmEdge_Result_Success;

}



// Host function to call `AddFunc` by external reference

WasmEdge_Result ExternAdd(void *Data,

                          const WasmEdge_CallingFrameContext *CallFrameCxt,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  // Function type: {externref, i32, i32} -> {i32}

  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);

  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));

  Out[0] = WasmEdge_ValueGenI32(C);

  return WasmEdge_Result_Success;

}



// Host function to call `ExternMul` by external reference

WasmEdge_Result ExternMul(void *Data,

                          const WasmEdge_CallingFrameContext *CallFrameCxt,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  // Function type: {externref, i32, i32} -> {i32}

  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);

  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));

  Out[0] = WasmEdge_ValueGenI32(C);

  return WasmEdge_Result_Success;

}



// Helper function to create the ""extern_module"" module instance.

WasmEdge_ModuleInstanceContext *CreateExternModule() {

  WasmEdge_String HostName;

  WasmEdge_FunctionTypeContext *HostFType = NULL;

  WasmEdge_FunctionInstanceContext *HostFunc = NULL;

  WasmEdge_ValType P[3], R[1];



  HostName = WasmEdge_StringCreateByCString(""extern_module"");

  WasmEdge_ModuleInstanceContext *HostMod =

      WasmEdge_ModuleInstanceCreate(HostName);

  WasmEdge_StringDelete(HostName);



  // Add host function ""functor_square"": {externref, i32} -> {i32}

  P[0] = WasmEdge_ValTypeGenExternRef();

  P[1] = WasmEdge_ValTypeGenI32();

  R[0] = WasmEdge_ValTypeGenI32();

  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);

  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);

  WasmEdge_FunctionTypeDelete(HostFType);

  HostName = WasmEdge_StringCreateByCString(""functor_square"");

  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);

  WasmEdge_StringDelete(HostName);



  // Add host function ""class_add"": {externref, i32, i32} -> {i32}

  P[2] = WasmEdge_ValTypeGenI32();

  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);

  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);

  WasmEdge_FunctionTypeDelete(HostFType);

  HostName = WasmEdge_StringCreateByCString(""class_add"");

  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);

  WasmEdge_StringDelete(HostName);



  // Add host function ""func_mul"": {externref, i32, i32} -> {i32}

  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);

  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);

  WasmEdge_FunctionTypeDelete(HostFType);

  HostName = WasmEdge_StringCreateByCString(""func_mul"");

  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);

  WasmEdge_StringDelete(HostName);



  return HostMod;

}



int main() {

  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  WasmEdge_ModuleInstanceContext *HostMod = CreateExternModule();

  WasmEdge_Value P[3], R[1];

  WasmEdge_String FuncName;

  WasmEdge_Result Res;



  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Host module instance registration failed\n"");

    return EXIT_FAILURE;

  }

  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""funcs.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""WASM file loading failed\n"");

    return EXIT_FAILURE;

  }

  Res = WasmEdge_VMValidate(VMCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""WASM validation failed\n"");

    return EXIT_FAILURE;

  }

  Res = WasmEdge_VMInstantiate(VMCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""WASM instantiation failed\n"");

    return EXIT_FAILURE;

  }



  // Test 1: call add -- 1234 + 5678

  P[0] = WasmEdge_ValueGenExternRef(AddFunc);

  P[1] = WasmEdge_ValueGenI32(1234);

  P[2] = WasmEdge_ValueGenI32(5678);

  FuncName = WasmEdge_StringCreateByCString(""call_add"");

  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);

  WasmEdge_StringDelete(FuncName);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Test 1 -- `call_add` -- 1234 + 5678 = %d\n"",

           WasmEdge_ValueGetI32(R[0]));

  } else {

    printf(""Test 1 -- `call_add` -- 1234 + 5678 -- failed\n"");

    return EXIT_FAILURE;

  }



  // Test 2: call mul -- 789 * 4321

  P[0] = WasmEdge_ValueGenExternRef(MulFunc);

  P[1] = WasmEdge_ValueGenI32(789);

  P[2] = WasmEdge_ValueGenI32(4321);

  FuncName = WasmEdge_StringCreateByCString(""call_mul"");

  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);

  WasmEdge_StringDelete(FuncName);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Test 2 -- `call_mul` -- 789 * 4321 = %d\n"",

           WasmEdge_ValueGetI32(R[0]));

  } else {

    printf(""Test 2 -- `call_mul` -- 789 * 4321 -- failed\n"");

    return EXIT_FAILURE;

  }



  // Test 3: call square -- 8256^2

  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);

  P[1] = WasmEdge_ValueGenI32(8256);

  FuncName = WasmEdge_StringCreateByCString(""call_square"");

  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Test 3 -- `call_mul` -- 8256 ^ 2 = %d\n"",

           WasmEdge_ValueGetI32(R[0]));

  } else {

    printf(""Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\n"");

    return EXIT_FAILURE;

  }



  return EXIT_SUCCESS;

}

```



### Setup the Environment And Compile



1. Install the WasmEdge shared library.



   For details, please refer to the [Installation](../../start/install.md#install).



2. Prepare the WASM and the `main.c` source files as above.



3. Compile



   ```bash

   gcc main.c -lwasmedge

   # Or you can use g++ for the C++ case, or use the clang.

   ```



4. Run the Test



   ```bash

   $ ./a.out

   Test 1 -- `call_add` -- 1234 + 5678 = 6912

   Test 2 -- `call_mul` -- 789 * 4321 = 3409269

   Test 3 -- `call_mul` -- 8256 ^ 2 = 68161536

   ```



## WASM module with External References



Take the following `wat` for example:



```wasm

(module

  (type $t0 (func (param externref i32) (result i32)))

  ;; Import a host function which type is {externref i32} -> {i32}

  (import ""extern_module"" ""functor_square"" (func $functor_square (type $t0)))

  ;; WASM function which type is {externref i32} -> {i32} and exported as ""call_square""

  (func $call_square (export ""call_square"") (type $t0) (param $p0 externref) (param $p1 i32) (result i32)

    (call $functor_square (local.get $p0) (local.get $p1))

  )

  (memory $memory (export ""memory"") 1))

```



The WASM function ""`call_square`"" takes an `externref` parameter and calls the imported host function `functor_square` with that `externref`. Therefore, the `functor_square` host function can get the object reference when users call ""`call_square`"" WASM function and pass the object's reference.



## WasmEdge ExternRef Example



The following examples are how to use `externref` in WASM with WasmEdge C API.



### WASM Code



The WASM code must pass the `externref` to host functions that want to access it. Take the following `wat` for example, which is a part of [the test WASM file](https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat):



```wasm

(module

  (type $t0 (func (param externref i32 i32) (result i32)))

  (import ""extern_module"" ""func_mul"" (func $func_mul (type $t0)))

  (func $call_mul (export ""call_mul"") (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)

    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))

  )

  (memory $memory (export ""memory"") 1))

```



The host function ""`extern_module::func_mul`"" takes `externref` as a function pointer to multiply parameters 1 and 2 and then returns the result. The exported WASM function ""`call_mul`"" calls ""`func_mul`"" and passes the `externref` and 2 numbers as arguments.



### Host Functions



To instantiate the above example Wasm, the host functions must be registered into WasmEdge. See [Host Functions](reference/latest.md#host-functions) for more details. The host functions which take `externref`s must know the original objects' types. We take the function pointer case, for example.



```c

/* Function to pass as function pointer. */

uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }



/* Host function to call the function by external reference as a function pointer */

WasmEdge_Result ExternMul(void *, const WasmEdge_CallingFrameContext *,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* Function type: {externref, i32, i32} -> {i32} */

  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);

  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;

  /*

   * For C++, the `reinterpret_cast` is needed:

   * uint32_t (*Obj)(uint32_t, uint32_t) =

   *   *reinterpret_cast<uint32_t (*)(uint32_t, uint32_t)>(Ptr);

   */

  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));

  Out[0] = WasmEdge_ValueGenI32(C);

  return WasmEdge_Result_Success;

}

```



""`MulFunc`"" is a function that will be passed into WASM as `externref`. In the ""`func_mul`"" host function, users can use ""`WasmEdge_ValueGetExternRef`"" API to get the pointer from the `WasmEdge_Value` which contains a `externref`.



Developers can add the host functions with names into a module instance.



```c

/* Create a module instance. */

WasmEdge_String HostName = WasmEdge_StringCreateByCString(""extern_module"");

WasmEdge_ModuleInstanceContext *HostMod =

    WasmEdge_ModuleInstanceCreate(HostName);

WasmEdge_StringDelete(HostName);



/* Create a function instance and add to the module instance. */

WasmEdge_ValType P[3], R[1];

P[0] = WasmEdge_ValTypeGenExternRef();

P[1] = WasmEdge_ValTypeGenI32();

P[2] = WasmEdge_ValTypeGenI32();

R[0] = WasmEdge_ValTypeGenI32();

WasmEdge_FunctionTypeContext *HostFType =

    WasmEdge_FunctionTypeCreate(P, 3, R, 1);

WasmEdge_FunctionInstanceContext *HostFunc =

    WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);

WasmEdge_FunctionTypeDelete(HostFType);

HostName = WasmEdge_StringCreateByCString(""func_mul"");

WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);

WasmEdge_StringDelete(HostName);



...

```



### Execution



Take [the test WASM file in text format](https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/funcs.wat) for example. Assume the `funcs.wasm` is copied into the current directory. The following is an example of executing WASM with `externref` through the WasmEdge C API.



```c

/* Create the VM context. */

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

/* Create the module instance context that contains the host functions. */

WasmEdge_ModuleInstanceContext *HostMod = /* Ignored ... */;

/* Assume the host functions are added to the module instance above. */

WasmEdge_Value P[3], R[1];

WasmEdge_String FuncName;

WasmEdge_Result Res;



/* Register the module instance into VM. */

Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Import object registration failed\n"");

  return EXIT_FAILURE;

}

/* Load WASM from the file. */

Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""funcs.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""WASM file loading failed\n"");

  return EXIT_FAILURE;

}

/* Validate WASM. */

Res = WasmEdge_VMValidate(VMCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""WASM validation failed\n"");

  return EXIT_FAILURE;

}

/* Instantiate the WASM module. */

Res = WasmEdge_VMInstantiate(VMCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""WASM instantiation failed\n"");

  return EXIT_FAILURE;

}



/* Run a WASM function. */

P[0] = WasmEdge_ValueGenExternRef(AddFunc);

P[1] = WasmEdge_ValueGenI32(1234);

P[2] = WasmEdge_ValueGenI32(5678);

/* Run the `call_add` function. */

FuncName = WasmEdge_StringCreateByCString(""call_add"");

Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);

WasmEdge_StringDelete(FuncName);

if (WasmEdge_ResultOK(Res)) {

  printf(""Run -- `call_add` -- 1234 + 5678 = %d\n"",

          WasmEdge_ValueGetI32(R[0]));

} else {

  printf(""Run -- `call_add` -- 1234 + 5678 -- failed\n"");

  return EXIT_FAILURE;

}

```



## Passing Objects



The above example is passing a function reference as `externref`. The following examples are about how to pass an object reference into WASM as `externref` in C++.



### Passing a Class



The object instance is needed to pass a class as `externref`.



```cpp

class AddClass {

public:

  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }

};



AddClass AC;

```



Then users can pass the object into WasmEdge by using `WasmEdge_ValueGenExternRef()` API.



```cpp

WasmEdge_Value P[3], R[1];

P[0] = WasmEdge_ValueGenExternRef(&AC);

P[1] = WasmEdge_ValueGenI32(1234);

P[2] = WasmEdge_ValueGenI32(5678);

WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_add"");

WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);

WasmEdge_StringDelete(FuncName);

if (WasmEdge_ResultOK(Res)) {

  std::cout << ""Result : "" << WasmEdge_ValueGetI32(R[0]) std::endl;

  // Will print `6912`.

} else {

  return EXIT_FAILURE;

}

```



In the host function which would access the object by reference, users can use the `WasmEdge_ValueGetExternRef()` API to retrieve the reference to the object.



```cpp

// Modify the `ExternAdd` in the above tutorial.

WasmEdge_Result ExternAdd(void *, const WasmEdge_CallingFrameContext *,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  // Function type: {externref, i32, i32} -> {i32}

  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);

  AddClass &Obj = *reinterpret_cast<AddClass *>(Ptr);

  uint32_t C =

      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));

  Out[0] = WasmEdge_ValueGenI32(C);

  return WasmEdge_Result_Success;

}

```



### Passing an Object As Functor



Like passing a class instance, the functor object instance is needed.



```cpp

struct SquareStruct {

  uint32_t operator()(uint32_t Val) const { return Val * Val; }

};



SquareStruct SS;

```



Then users can pass the object into WasmEdge using the `WasmEdge_ValueGenExternRef()` API.



```cpp

WasmEdge_Value P[2], R[1];

P[0] = WasmEdge_ValueGenExternRef(&SS);

P[1] = WasmEdge_ValueGenI32(1024);

WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_square"");

WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);

WasmEdge_StringDelete(FuncName);

if (WasmEdge_ResultOK(Res)) {

  std::cout << ""Result : "" << WasmEdge_ValueGetI32(R[0]) std::endl;

  // Will print `1048576`.

} else {

  return EXIT_FAILURE;

}

```



In the host function, which would access the object by reference, users can use the `WasmEdge_ValueGetExternRef` API to retrieve the reference to the object, which is a functor.



```cpp

// Modify the `ExternSquare` in the above tutorial.

WasmEdge_Result ExternSquare(void *, const WasmEdge_CallingFrameContext *,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  // Function type: {externref, i32, i32} -> {i32}

  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);

  SquareStruct &Obj = *reinterpret_cast<SquareStruct *>(Ptr);

  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));

  Out[0] = WasmEdge_ValueGenI32(C);

  return WasmEdge_Result_Success;

}

```



### Passing STL Objects



The [example WASM in text format](https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/stl.wat) provides functions to interact with host functions which can access C++ STL objects. Assume that the WASM file `stl.wasm` is copied into the current directory.



Take the `std::ostream` and `std::string` objects for example. Assume that there's a host function that accesses to a `std::ostream` and a `std::string` through `externref`s:



```cpp

// Host function to output std::string through std::ostream

WasmEdge_Result ExternSTLOStreamStr(void *,

                                    const WasmEdge_CallingFrameContext *,

                                    const WasmEdge_Value *In,

                                    WasmEdge_Value *) {

  // Function type: {externref, externref} -> {}

  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);

  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);

  std::ostream &RefOS = *reinterpret_cast<std::ostream *>(Ptr0);

  std::string &RefStr = *reinterpret_cast<std::string *>(Ptr1);

  RefOS << RefStr;

  return WasmEdge_Result_Success;

}

```



Assume that the above host function is added to the module instance `HostMod`, and the `HostMod` is registered into a VM context `VMCxt`. Then users can instantiate the WASM module:



```cpp

WasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""stl.wasm"");

if (!WasmEdge_ResultOK(Res)) {

  printf(""WASM file loading failed\n"");

  return EXIT_FAILURE;

}

Res = WasmEdge_VMValidate(VMCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""WASM validation failed\n"");

  return EXIT_FAILURE;

}

Res = WasmEdge_VMInstantiate(VMCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""WASM instantiation failed\n"");

  return EXIT_FAILURE;

}

```



Last, pass the `std::cout` and a `std::string` object by external references.



```cpp

std::string PrintStr(""Hello world!"");

WasmEdge_Value P[2], R[1];

P[0] = WasmEdge_ValueGenExternRef(&std::cout);

P[1] = WasmEdge_ValueGenExternRef(&PrintStr);

WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""call_ostream_str"");

WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);

// Will print ""Hello world!"" to stdout.

WasmEdge_StringDelete(FuncName);

if (!WasmEdge_ResultOK(Res)) {

  return EXIT_FAILURE;

}

```



For other C++ STL objects cases, such as `std::vector<T>`, `std::map<T, U>`, or `std::set<T>`, the object can be accessed correctly in host functions if the type in `reinterpret_cast` is correct.








------"
"The following is a markdown document located at /embed/c/host_function.md
------


---

sidebar_position: 3

---



# Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are the functions outside WebAssembly and are passed to WASM modules as imports. The following steps give an example of implementing host functions and registering a `host module` into the WasmEdge runtime.



## Host Instances



WasmEdge supports registering `host function`, `memory`, `table`, and `global` instances as imports.



### Functions



The host function body definition in WasmEdge is defined as follows:



```c

typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

    const WasmEdge_Value *Params, WasmEdge_Value *Returns);

```



A simple host function can be defined as follows:



```c

#include <wasmedge/wasmedge.h>



/* This function can add 2 i32 values and return the result. */

WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,

                    const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /*

  * Params: {i32, i32}

  * Returns: {i32}

  */



  /* Retrieve the value 1. */

  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

  /* Retrieve the value 2. */

  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

  /* Output value 1 is Val1 + Val2. */

  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

  /* Return the status of success. */

  return WasmEdge_Result_Success;

}

```



For adding the host function into a host module instance, developers should first create the function instance with the function type context.



```c

WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};

WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};

/* Create a function type: {i32, i32} -> {i32}. */

WasmEdge_FunctionTypeContext *HostFType =

    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

/*

  * Create a function context with the function type and host function body.

  * The `Cost` parameter can be 0 if developers do not need the cost

  * measuring.

  */

WasmEdge_FunctionInstanceContext *HostFunc =

    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

/*

  * The third parameter is the pointer to the additional data.

  * Developers should guarantee the life cycle of the data, and it can be NULL if the external data is not needed.

  */

WasmEdge_FunctionTypeDelete(HostType);

```



### Tables, Memories, and Globals



To create a `host table`, `memory`, and `global` instance, developers can use similar APIs.



```c

/* Create a host table exported as ""table"". */

WasmEdge_Limit TabLimit = {

    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};

WasmEdge_TableTypeContext *HostTType =

    WasmEdge_TableTypeCreate(WasmEdge_ValTypeGenFuncRef(), TabLimit);

WasmEdge_TableInstanceContext *HostTable =

    WasmEdge_TableInstanceCreate(HostTType);

WasmEdge_TableTypeDelete(HostTType);



/* Create a host memory exported as ""memory"". */

WasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};

WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemLimit);

WasmEdge_MemoryInstanceContext *HostMemory =

    WasmEdge_MemoryInstanceCreate(HostMType);

WasmEdge_MemoryTypeDelete(HostMType);



/* Create a host global exported as ""global_i32"" and initialized as `666`. */

WasmEdge_GlobalTypeContext *HostGType =

    WasmEdge_GlobalTypeCreate(WasmEdge_ValTypeGenI32(), WasmEdge_Mutability_Const);

WasmEdge_GlobalInstanceContext *HostGlobal =

    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));

WasmEdge_GlobalTypeDelete(HostGType);

```



## Host Modules



The host module is a module instance that contains `host functions`, `tables`, `memories`, and `globals`, the same as the WASM modules. Developers can use APIs to add the instances into a host module. After registering the host modules into a `VM` or `Store` context, the exported instances in that modules can be imported by WASM modules when instantiating.



### Module Instance Creation



Module instance supplies exported module name.



```c

WasmEdge_String HostName = WasmEdge_StringCreateByCString(""test"");

WasmEdge_ModuleInstanceContext *HostMod =

    WasmEdge_ModuleInstanceCreate(HostName);

WasmEdge_StringDelete(HostName);

```



### Add Instances



Developers can add the `host functions`, `tables`, `memories`, and `globals` into the module instance with the export name. After adding to the module, the ownership of the instances is moved into the module. Developers should **NOT** access or destroy them.



```c

/* Add the host function created above with the export name ""add"". */

HostName = WasmEdge_StringCreateByCString(""add"");

WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);

WasmEdge_StringDelete(HostName);



/* Add the table created above with the export name ""table"". */

HostName = WasmEdge_StringCreateByCString(""table"");

WasmEdge_ModuleInstanceAddTable(HostMod, HostName, HostTable);

WasmEdge_StringDelete(HostName);



/* Add the memory created above with the export name ""memory"". */

HostName = WasmEdge_StringCreateByCString(""memory"");

WasmEdge_ModuleInstanceAddMemory(HostMod, HostName, HostMemory);

WasmEdge_StringDelete(HostName);



/* Add the global created above with the export name ""global_i32"". */

HostName = WasmEdge_StringCreateByCString(""global_i32"");

WasmEdge_ModuleInstanceAddGlobal(HostMod, HostName, HostGlobal);

WasmEdge_StringDelete(HostName);

```



### Register Host Modules to WasmEdge



For importing the host functions in WASM, developers can register the host modules into a `VM` or `Store` context.



```c

WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);



/* Register the module instance into the store. */

WasmEdge_Result Res =

    WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);

if (!WasmEdge_ResultOK(Res)) {

  printf(""Host module registration failed: %s\n"",

         WasmEdge_ResultGetMessage(Res));

  return -1;

}

/*

 * Developers can register the host module into a VM context by the

 * `WasmEdge_VMRegisterModuleFromImport()` API.

 */

/*

 * The owner of the host module will not be changed. Developers can register

 * the host module into several VMs or stores.

 */



/* Although being registered, the host module should be destroyed. */

WasmEdge_StoreDelete(StoreCxt);

WasmEdge_ExecutorDelete(ExecCxt);

WasmEdge_ModuleInstanceDelete(HostModCxt);

```



## Host Function Body Implementation Tips



There are some tips about implementing the host functions.



### Calling Frame Context



The `WasmEdge_CallingFrameContext` is the context to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance to which the caller function belonging is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



```c

/* Host function body definition. */

WasmEdge_Result LoadOffset(void *Data,

                           const WasmEdge_CallingFrameContext *CallFrameCxt,

                           const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* Function type: {i32} -> {} */

  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

  uint32_t Num = 0;



  /* Get the 0th memory instance of the module of the top frame on the stack. */

  /*

   * Noticed that the `MemCxt` will be `NULL` if there's no memory instance in

   * the module instance on the top frame.

   */

  WasmEdge_MemoryInstanceContext *MemCxt =

      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);

  WasmEdge_Result Res =

      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

  if (WasmEdge_ResultOK(Res)) {

    printf(""u32 at memory[%u]: %u\n"", Offset, Num);

  } else {

    return Res;

  }

  return WasmEdge_Result_Success;

}

```



The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents. The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.



### Return Error Codes



Usually, the host function in WasmEdge can return the `WasmEdge_Result_Success` to present the successful execution. For presenting the host function execution failed, one way is to return a trap with the error code. Then the WasmEdge runtime will cause the trap in WASM and return that error.



<!-- prettier-ignore -->

:::note

We don't recommend using system calls such as `exit()`. That will shut down the whole WasmEdge runtime._

:::



For simply generating the trap, developers can return the `WasmEdge_Result_Fail`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.



For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.



```c

/* Host function body definition. */

WasmEdge_Result FaildFunc(void *Data,

                          const WasmEdge_CallingFrameContext *CallFrameCxt,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* This will create a trap in WASM with the error code. */

  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);

}

```



Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. If developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.



### Host Data



The third parameter of the `WasmEdge_FunctionInstanceCreate()` API is for the host data as the type `void *`. Developers can pass the data into the host functions when creating. Then in the host function body, developers can access the data from the first argument. Developers should guarantee that the availability of the host data should be longer than the host functions.



```c

/* Host function body definition. */

WasmEdge_Result PrintData(void *Data,

                          const WasmEdge_CallingFrameContext *,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* Function type: {} -> {} */

  printf(""Data: %lf\n"", *(double *)Data);

  return WasmEdge_Result_Success;

}



/* The host data. */

double Number = 0.0f;



/* Create a function type: {} -> {}. */

WasmEdge_FunctionTypeContext *HostFType =

    WasmEdge_FunctionTypeCreate(NULL, 0, NULL, 0);

/* Create a function context with the function type and host function body. */

WasmEdge_FunctionInstanceContext *HostFunc =

    WasmEdge_FunctionInstanceCreate(HostFType, &PrintData, (void *)(&Number), 0);

WasmEdge_FunctionTypeDelete(HostType);

```



### Forcing Termination



Sometimes developers may want to terminate the WASM execution with the success status. WasmEdge provides a method for terminating WASM execution in host functions. Developers can return `WasmEdge_Result_Terminate` to trigger the forcing termination of the current execution. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `true`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `1`.








------"
"The following is a markdown document located at /embed/c/intro.md
------


---

sidebar_position: 1

---



# WasmEdge C SDK Introduction



The WasmEdge C API denotes an interface to embed the WasmEdge runtime into a C program. The following is the quick start guide for working with the C APIs of WasmEdge. For the details of the WasmEdge C API, please refer to the [complete documentation](reference/latest.md). Before programming with the WasmEdge C API, please [install WasmEdge](../../start/install.md#install) first.



The WasmEdge C API is also the fundamental API for other languages' SDK.



<!-- prettier-ignore -->

:::note

For all WASM example codes used in this chapter, users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool.

:::



## Quick Start Guide for the WasmEdge Runner



The following is an example of running a WASM file. Assume that the WASM file [fibonacci.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test_wasmedge.c` is as follows:

Please Note: In the example directory, `fibonacci.wat` file is provided and users should convert it into corresponding wasm file using [WABT tool](https://github.com/WebAssembly/wabt)



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int Argc, const char* Argv[]) {

  /* Create the configure context and add the WASI support. */

  /* This step is not necessary unless you need WASI support. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);

  /* The configure and store context to the VM creation can be NULL. */

  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""fib"");

  /* Run the WASM function from file. */

  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);



  if (WasmEdge_ResultOK(Res)) {

    printf(""Get result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_VMDelete(VMCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  WasmEdge_StringDelete(FuncName);

  return 0;

}

```



Then you can compile and run: (the 32th fibonacci number is 3524578 in 0-based index)



```bash

$ gcc test_wasmedge.c -lwasmedge -o test_wasmedge

$ ./test_wasmedge fibonacci.wasm

Get result: 3524578

```



## Quick Start Guide for the WasmEdge AOT compiler



Assume that the WASM file [fibonacci.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) is copied into the current directory, and the C file `test_wasmedge_compiler.c` is as follows:

Please Note: In the example directory, `fibonacci.wat` file is provided and users should convert it into corresponding wasm file using [WABT tool](https://github.com/WebAssembly/wabt)



```c

#include <wasmedge/wasmedge.h>

#include <stdio.h>

int main(int Argc, const char* Argv[]) {

  /* Create the configure context. */

  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

  /* ... Adjust settings in the configure context. */

  /* Result. */

  WasmEdge_Result Res;



  /* Create the compiler context. The configure context can be NULL. */

  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);

  /* Compile the WASM file with input and output paths. */

  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Compilation failed: %s\n"", WasmEdge_ResultGetMessage(Res));

    return 1;

  }



  WasmEdge_CompilerDelete(CompilerCxt);

  WasmEdge_ConfigureDelete(ConfCxt);

  return 0;

}

```



Then you can compile and run (the output file is `fibonacci_aot.wasm`):



```bash

$ gcc test_wasmedge_compiler.c -lwasmedge -o test_wasmedge_compiler

$ ./test_wasmedge_compiler fibonacci.wasm fibonacci_aot.wasm

[2021-07-02 11:08:08.651] [info] compile start

[2021-07-02 11:08:08.653] [info] verify start

[2021-07-02 11:08:08.653] [info] optimize start

[2021-07-02 11:08:08.670] [info] codegen start

[2021-07-02 11:08:08.706] [info] compile done

```



The compiled WASM file can be used as a WASM input for the WasmEdge runner. The following is the comparison of the interpreter mode and the AOT mode:



```bash

$ time ./test_wasmedge fibonacci.wasm

Get result: 5702887



real 0m2.715s

user 0m2.700s

sys 0m0.008s



$ time ./test_wasmedge fibonacci_aot.wasm

Get result: 5702887



real 0m0.036s

user 0m0.022s

sys 0m0.011s

```



## API References



- [0.13.4](reference/latest.md)

- [0.12.1](reference/0.12.x.md)

- [0.11.2](reference/0.11.x.md)

- [0.10.1](reference/0.10.x.md)

- [0.9.1](reference/0.9.x.md)



## Examples



- Link with the [WasmEdge library](library.md)

- Use the [external reference](externref.md) of WebAssembly input and output in C/C++

- Implement the [host functions](host_function.md) in C/C++

- [Multiple WASM Module Example](multiple_modules.md)








------"
"The following is a markdown document located at /embed/c/library.md
------


---

sidebar_position: 2

---



# Use WasmEdge Library



When programming with WasmEdge C API, developers should include the required headers and link with the WasmEdge Library. Besides [install WasmEdge](../../start/install.md#install) with the WasmEdge shared library, developers can also [build WasmEdge](../../contribute/source/build_from_src.md) to generate the WasmEdge static library.



Assume the example `test.c`:



```c

#include <stdio.h>

#include <wasmedge/wasmedge.h>



/* Host function body definition. */

WasmEdge_Result Add(void *Data,

                    const WasmEdge_CallingFrameContext *CallFrameCxt,

                    const WasmEdge_Value *In, WasmEdge_Value *Out) {

  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);

  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);

  printf(""Host function \""Add\"": %d + %d\n"", Val1, Val2);

  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);

  return WasmEdge_Result_Success;

}



int main() {

  /* Create the VM context. */

  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



  /* The WASM module buffer. */

  uint8_t WASM[] = {/* WASM header */

                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                    /* Type section */

                    0x01, 0x07, 0x01,

                    /* function type {i32, i32} -> {i32} */

                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                    /* Import section */

                    0x02, 0x13, 0x01,

                    /* module name: ""extern"" */

                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

                    /* extern name: ""func-add"" */

                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

                    /* import desc: func 0 */

                    0x00, 0x00,

                    /* Function section */

                    0x03, 0x02, 0x01, 0x00,

                    /* Export section */

                    0x07, 0x0A, 0x01,

                    /* export name: ""addTwo"" */

                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

                    /* export desc: func 0 */

                    0x00, 0x01,

                    /* Code section */

                    0x0A, 0x0A, 0x01,

                    /* code body */

                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};



  /* Create the module instance. */

  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");

  WasmEdge_ModuleInstanceContext *HostModCxt =

      WasmEdge_ModuleInstanceCreate(ExportName);

  WasmEdge_ValType ParamList[2] = {WasmEdge_ValTypeGenI32(), WasmEdge_ValTypeGenI32()};

  WasmEdge_ValType ReturnList[1] = {WasmEdge_ValTypeGenI32()};

  WasmEdge_FunctionTypeContext *HostFType =

      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

  WasmEdge_FunctionInstanceContext *HostFunc =

      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);

  WasmEdge_FunctionTypeDelete(HostFType);

  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""func-add"");

  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);

  WasmEdge_StringDelete(HostFuncName);



  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);



  /* The parameters and returns arrays. */

  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),

                              WasmEdge_ValueGenI32(5678)};

  WasmEdge_Value Returns[1];

  /* Function name. */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""addTwo"");

  /* Run the WASM function from buffer. */

  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(

      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);



  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the result: %d\n"", WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Error message: %s\n"", WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_VMDelete(VMCxt);

  WasmEdge_StringDelete(FuncName);

  WasmEdge_ModuleInstanceDelete(HostModCxt);

  return 0;

}

```



This example will execute a WASM, which calls into a host function to add 2 numbers.



## Link with WasmEdge Shared Library



To link the executable with the WasmEdge shared library is easy. Just compile the example file after installation of WasmEdge.



```bash

$ gcc test.c -lwasmedge -o test

$ ./test

Host function ""Add"": 1234 + 5678

Get the result: 6912

```



## Link with WasmEdge Static Library



For preparing the WasmEdge static library, developers should [build WasmEdge from source](../../contribute/source/build_from_src#cmake-building-options) with the options:



```bash

# Recommend to use the `wasmedge/wasmedge:latest` docker image. This will provide the required packages.

# In the WasmEdge source directory

cmake -Bbuild -GNinja -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_LINK_LLVM_STATIC=ON -DWASMEDGE_BUILD_SHARED_LIB=Off -DWASMEDGE_BUILD_STATIC_LIB=On -DWASMEDGE_LINK_TOOLS_STATIC=On -DWASMEDGE_BUILD_PLUGINS=Off

cmake --build build

cmake --install build

```



The cmake option `-DWASMEDGE_LINK_LLVM_STATIC=ON` will turn on the static library building, and the `-DWASMEDGE_BUILD_SHARED_LIB=Off` will turn off the shared library building.



After installation, developers can compile the example file:



```bash

# Note: only the Linux platforms need the `-lrt`. The MacOS platforms do not need this linker flag.

$ gcc test.c -lwasmedge -lrt -ldl -pthread -lm -lstdc++ -o test

$ ./test

Host function ""Add"": 1234 + 5678

Get the result: 6912

```








------"
"The following is a markdown document located at /embed/c/multiple_modules.md
------


---

sidebar_position: 5

---



# Multiple WASM Module Example



For those WASM modules that export their functions, the other WASM modules can import them as a library.



This will cause a situation that links multiple modules for the dependencies in execution.



This chapter will introduce examples of linking and executing multiple WASM modules in WasmEdge.



## Example WASM file



### The Library WASM



Assume that there's a WASM that exports it's function:



```wasm

(module

  (func (export ""add"") (param i32 i32) (result i32)

    ;; Function to add 2 numbers and exported as ""add"".

    (i32.add (local.get 0) (local.get 1))

  )

  (func (export ""mul"") (param i32 i32) (result i32)

    ;; Function to mul 2 number and exported as ""mul"".

    (i32.mul (local.get 0) (local.get 1))

  )

)

```



Users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool. Assume that this `wat` is converted into the WASM binary format and saved as `lib.wasm`.



### The Entering WASM



Assume that there's a WASM which imports some functions from the `lib.wasm`, and this WASM exports the functions which can be invoked:



```wasm

(module

  (type $type0 (func (param i32 i32)(result i32)))

  ;; Import the ""add"" function which calculate ""a + b"".

  (import ""math"" ""add"" (func $math-add (type $type0)))

  ;; Import the ""mul"" function which calculate ""a * b"".

  (import ""math"" ""mul"" (func $math-mul (type $type0)))

  (func (export ""add_and_square"") (param i32 i32) (result i32)

    ;; Function to add 2 numbers and square it ((a + b)^2).

    ;; Exported as ""add_and_square"".

    (call $math-mul

      (call $math-add (local.get 0) (local.get 1))

      (call $math-add (local.get 0) (local.get 1))

    )

  )

  (func (export ""sum_of_squares"") (param i32 i32) (result i32)

    ;; Function to calculate the sum of squares (a^2 + b^2).

    ;; Exported as ""sum_of_squares"".

    (call $math-add

      (call $math-mul (local.get 0) (local.get 0))

      (call $math-mul (local.get 1) (local.get 1))

    )

  )

)

```



Users can convert `wat` to `wasm` through [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) live tool. Assume that this `wat` is converted into the WASM binary format and saved as `test.wasm`.



### Prerequisites



For executing these examples, developers should [install WasmEdge](../../start/install.md#install).



To improve the performance of executing WASM, developers can also use the [AOT compiler](../../start/build-and-run/aot.md) to compile the above WASM files.



## Linking WASM Modules With the VM Context



With the `WasmEdge_VMContext`, developers can instantiate and execute WASM quickly. There are at least four ways to link these multiple WASM modules with the VM context. For the example codes below, assume that the C code is saved as `example.c`.



1. Register and instantiate the `lib.wasm` from the file directly.



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>



   int main() {

     /* The result. */

     WasmEdge_Result Res;



     /* The params and returns. */

     WasmEdge_Value Params[2], Returns[1];



     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* Register the `lib.wasm` from file with the module name ""math"". */

     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");

     Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModuleName, ""lib.wasm"");

     WasmEdge_StringDelete(ModuleName);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Instantiate the `test.wasm`. */

     /*

      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to

      * instantiate and execute quickly.

      */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Validate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMInstantiate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Instantiate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Invoke the functions. */

     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */

     WasmEdge_String FuncName =

         WasmEdge_StringCreateByCString(""add_and_square"");

     Params[0] = WasmEdge_ValueGenI32(123);

     Params[1] = WasmEdge_ValueGenI32(456);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'add_and_square' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }

     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */

     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");

     Params[0] = WasmEdge_ValueGenI32(77);

     Params[1] = WasmEdge_ValueGenI32(88);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'sum_of_squares' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then compile and execute:



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the '(123 + 456)^2' result: 335241

   Get the '77^2 + 88^2' result: 13673

   ```



2. Register and instantiate the `lib.wasm` from the buffer.



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>



   int main() {

     /* The result. */

     WasmEdge_Result Res;



     /* The params and returns. */

     WasmEdge_Value Params[2], Returns[1];



     /* The `lib.wasm` buffer example. */

     /* Developers can also load the buffer from file. */

     uint8_t WASM[] = {/* WASM header */

                       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

                       /* Type section */

                       0x01, 0x07, 0x01,

                       /* function type {i32, i32} -> {i32} */

                       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

                       /* Function section */

                       0x03, 0x03, 0x02, 0x00, 0x00,

                       /* Export section */

                       0x07, 0x0D, 0x02,

                       /* export function: ""add"" */

                       0x03, 0x61, 0x64, 0x64, 0x00, 0x00,

                       /* export function: ""mul"" */

                       0x03, 0x6D, 0x75, 0x6C, 0x00, 0x01,

                       /* Code section */

                       0x0A, 0x11, 0x02,

                       /* ""add"" code body */

                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6A, 0x0B,

                       /* ""mul"" code body */

                       0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6C, 0x0B};



     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* Register the `lib.wasm` from the buffer with the module name ""math"". */

     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");

     Res = WasmEdge_VMRegisterModuleFromBuffer(VMCxt, ModuleName, WASM,

                                               sizeof(WASM));

     WasmEdge_StringDelete(ModuleName);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Instantiate the `test.wasm`. */

     /*

      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to

      * instantiate and execute quickly.

      */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Validate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMInstantiate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Instantiate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Invoke the functions. */

     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */

     WasmEdge_String FuncName =

         WasmEdge_StringCreateByCString(""add_and_square"");

     Params[0] = WasmEdge_ValueGenI32(123);

     Params[1] = WasmEdge_ValueGenI32(456);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'add_and_square' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }

     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */

     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");

     Params[0] = WasmEdge_ValueGenI32(77);

     Params[1] = WasmEdge_ValueGenI32(88);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'sum_of_squares' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then compile and execute:



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the '(123 + 456)^2' result: 335241

   Get the '77^2 + 88^2' result: 13673

   ```



3. Load the `lib.wasm` to an AST Context first



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>



   int main() {

     /* The result. */

     WasmEdge_Result Res;



     /* The params and returns. */

     WasmEdge_Value Params[2], Returns[1];



     /* Assume that the `lib.wasm` has loaded first. */

     WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

     WasmEdge_ASTModuleContext *LibASTCxt = NULL;

     Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");

     WasmEdge_LoaderDelete(LoadCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* Register the loaded AST context with the module name ""math"". */

     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");

     Res =

         WasmEdge_VMRegisterModuleFromASTModule(VMCxt, ModuleName, LibASTCxt);

     WasmEdge_StringDelete(ModuleName);

     WasmEdge_ASTModuleDelete(LibASTCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Instantiate the `test.wasm`. */

     /*

      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to

      * instantiate and execute quickly.

      */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Validate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMInstantiate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       printf(""Instantiate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Invoke the functions. */

     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */

     WasmEdge_String FuncName =

         WasmEdge_StringCreateByCString(""add_and_square"");

     Params[0] = WasmEdge_ValueGenI32(123);

     Params[1] = WasmEdge_ValueGenI32(456);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'add_and_square' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }

     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */

     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");

     Params[0] = WasmEdge_ValueGenI32(77);

     Params[1] = WasmEdge_ValueGenI32(88);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'sum_of_squares' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     return 0;

   }

   ```



   Then compile and execute:



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the '(123 + 456)^2' result: 335241

   Get the '77^2 + 88^2' result: 13673

   ```



4. Instantiate the `lib.wasm` first



   ```c

   #include <stdio.h>

   #include <wasmedge/wasmedge.h>



   int main() {

     /* The result. */

     WasmEdge_Result Res;



     /* The params and returns. */

     WasmEdge_Value Params[2], Returns[1];



     /* Create the VM context. */

     WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);



     /* Assume that the `lib.wasm` has instantiated first. */

     WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

     WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);

     WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

     WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

     WasmEdge_ASTModuleContext *LibASTCxt = NULL;

     WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;

     Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");

     WasmEdge_LoaderDelete(LoadCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);

     WasmEdge_ValidatorDelete(ValidCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_ASTModuleDelete(LibASTCxt);

       printf(""Validate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     /*

      * The module name is determined when instantiation.

      * If use the `WasmEdge_ExecutorInstantiate` API, the module name will be

      * """".

      */

     WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");

     Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,

                                     ModuleName);

     WasmEdge_ExecutorDelete(ExecCxt);

     WasmEdge_ASTModuleDelete(LibASTCxt);

     WasmEdge_StringDelete(ModuleName);

     WasmEdge_StoreDelete(StoreCxt);

     if (!WasmEdge_ResultOK(Res)) {

       printf(""Instantiate lib.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Register the module instance with the module name ""math"". */

     /* The module name has been determined when instantiating the `lib.wasm`. */

     Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, LibInstCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       WasmEdge_ModuleInstanceDelete(LibInstCxt);

       printf(""Register lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Instantiate the `test.wasm`. */

     /*

      * Developers can use the APIs such as `WasmEdge_VMRunWasmFromFile` to

      * instantiate and execute quickly.

      */

     Res = WasmEdge_VMLoadWasmFromFile(VMCxt, ""test.wasm"");

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       WasmEdge_ModuleInstanceDelete(LibInstCxt);

       printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMValidate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       WasmEdge_ModuleInstanceDelete(LibInstCxt);

       printf(""Validate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }

     Res = WasmEdge_VMInstantiate(VMCxt);

     if (!WasmEdge_ResultOK(Res)) {

       WasmEdge_VMDelete(VMCxt);

       WasmEdge_ModuleInstanceDelete(LibInstCxt);

       printf(""Instantiate test.wasm error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

       return -1;

     }



     /* Invoke the functions. */

     /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */

     WasmEdge_String FuncName =

         WasmEdge_StringCreateByCString(""add_and_square"");

     Params[0] = WasmEdge_ValueGenI32(123);

     Params[1] = WasmEdge_ValueGenI32(456);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'add_and_square' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }

     /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */

     FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");

     Params[0] = WasmEdge_ValueGenI32(77);

     Params[1] = WasmEdge_ValueGenI32(88);

     Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 2, Returns, 1);

     WasmEdge_StringDelete(FuncName);

     if (WasmEdge_ResultOK(Res)) {

       printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,

              WasmEdge_ValueGetI32(Returns[0]));

     } else {

       printf(""Execute 'sum_of_squares' error: %s\n"",

              WasmEdge_ResultGetMessage(Res));

     }



     /* Resources deallocations. */

     WasmEdge_VMDelete(VMCxt);

     /* The imported module instance should be destroyed. */

     WasmEdge_ModuleInstanceDelete(LibInstCxt);

     return 0;

   }

   ```



   Then compile and execute:



   ```bash

   $ gcc test.c -lwasmedge

   $ ./a.out

   Get the '(123 + 456)^2' result: 335241

   Get the '77^2 + 88^2' result: 13673

   ```



## Linking WASM Modules By the Executor Context



For linking multiple WASM modules, developers should instantiate them first by considering their dependencies.



```c

#include <stdio.h>

#include <wasmedge/wasmedge.h>



int main() {

  /* The result. */

  WasmEdge_Result Res;



  /* The params and returns. */

  WasmEdge_Value Params[2], Returns[1];



  /* Create the contexts. */

  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);

  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);

  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();



  /* Load and register the `lib.wasm` with the module name ""math"". */

  WasmEdge_ASTModuleContext *LibASTCxt = NULL;

  WasmEdge_ModuleInstanceContext *LibInstCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &LibASTCxt, ""lib.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Load lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

    return -1;

  }

  Res = WasmEdge_ValidatorValidate(ValidCxt, LibASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

    return -1;

  }

  WasmEdge_String ModuleName = WasmEdge_StringCreateByCString(""math"");

  Res = WasmEdge_ExecutorRegister(ExecCxt, &LibInstCxt, StoreCxt, LibASTCxt,

                                  ModuleName);

  WasmEdge_StringDelete(ModuleName);

  WasmEdge_ASTModuleDelete(LibASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiate lib.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

    return -1;

  }



  /* Load and instantiate the `test.wasm`. */

  WasmEdge_ASTModuleContext *TestASTCxt = NULL;

  WasmEdge_ModuleInstanceContext *TestInstCxt = NULL;

  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &TestASTCxt, ""test.wasm"");

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Load test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

    return -1;

  }

  Res = WasmEdge_ValidatorValidate(ValidCxt, TestASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Validate test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

    return -1;

  }

  Res =

      WasmEdge_ExecutorInstantiate(ExecCxt, &TestInstCxt, StoreCxt, TestASTCxt);

  WasmEdge_ASTModuleDelete(TestASTCxt);

  if (!WasmEdge_ResultOK(Res)) {

    printf(""Instantiate test.wasm error: %s\n"", WasmEdge_ResultGetMessage(Res));

    return -1;

  }



  /* Invoke the functions. */

  /* Invoke the ""add_and_square"" to calculate (123 + 456)^2 */

  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""add_and_square"");

  WasmEdge_FunctionInstanceContext *FuncCxt =

      WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);

  WasmEdge_StringDelete(FuncName);

  if (FuncCxt == NULL) {

    printf(""Function 'add_and_square' not found.\n"");

    return -1;

  }

  Params[0] = WasmEdge_ValueGenI32(123);

  Params[1] = WasmEdge_ValueGenI32(456);

  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the '(%d + %d)^2' result: %d\n"", 123, 456,

           WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execute 'add_and_square' error: %s\n"",

           WasmEdge_ResultGetMessage(Res));

  }

  /* Invoke the ""sum_of_squares"" to calculate (77^2 + 88^2) */

  FuncName = WasmEdge_StringCreateByCString(""sum_of_squares"");

  FuncCxt = WasmEdge_ModuleInstanceFindFunction(TestInstCxt, FuncName);

  WasmEdge_StringDelete(FuncName);

  if (FuncCxt == NULL) {

    printf(""Function 'sum_of_squares' not found.\n"");

    return -1;

  }

  Params[0] = WasmEdge_ValueGenI32(77);

  Params[1] = WasmEdge_ValueGenI32(88);

  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {

    printf(""Get the '%d^2 + %d^2' result: %d\n"", 77, 88,

           WasmEdge_ValueGetI32(Returns[0]));

  } else {

    printf(""Execute 'sum_of_squares' error: %s\n"",

           WasmEdge_ResultGetMessage(Res));

  }



  /* Resources deallocations. */

  WasmEdge_LoaderDelete(LoadCxt);

  WasmEdge_ValidatorDelete(ValidCxt);

  WasmEdge_ExecutorDelete(ExecCxt);

  WasmEdge_StoreDelete(StoreCxt);

  WasmEdge_ModuleInstanceDelete(LibInstCxt);

  WasmEdge_ModuleInstanceDelete(TestInstCxt);

  return 0;

}

```



Then compile and execute:



```bash

$ gcc test.c -lwasmedge

$ ./a.out

Get the '(123 + 456)^2' result: 335241

Get the '77^2 + 88^2' result: 13673

```








------"
"```json:/embed/c++/_category_.json


{

  ""label"": ""C++ SDK for Embedding WasmEdge"",

  ""position"": 9,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to Embed WasmEdge in your C++ host applications.""

  }

}








```"
"The following is a markdown document located at /embed/c++/intro.md
------


---

sidebar_position: 1

---



# WasmEdge C++ SDK Introduction



The WasmEdge C++ SDK is a collection of headers and libraries that allow you to build and deploy WebAssembly (Wasm) modules for execution on WasmEdge devices. It includes a CMake project and a set of command-line tools that you can use to build and deploy your Wasm modules.



## Quick Start Guide



To get started with WasmEdge, follow these steps:



Install the WasmEdge C/C++ SDK: Download C++ SDK from the WasmEdge [website](https://wasmedge.org/docs/embed/quick-start/install) and follow the instructions to install it on your development machine



```cpp

#include <wasmedge/wasmedge.h>

#include <iostream>



int main(int argc, char** argv) {

  /* Create the configure context and add the WASI support. */

  /* This step is not necessary unless you need WASI support. */

  WasmEdge_ConfigureContext* conf_cxt = WasmEdge_ConfigureCreate();

  WasmEdge_ConfigureAddHostRegistration(conf_cxt, WasmEdge_HostRegistration_Wasi);

  /* The configure and store context to the VM creation can be NULL. */

  WasmEdge_VMContext* vm_cxt = WasmEdge_VMCreate(conf_cxt, nullptr);



  /* The parameters and returns arrays. */

  WasmEdge_Value params[1] = { WasmEdge_ValueGenI32(40) };

  WasmEdge_Value returns[1];

  /* Function name. */

  WasmEdge_String func_name = WasmEdge_StringCreateByCString(""fib"");

  /* Run the WASM function from file. */

  WasmEdge_Result res = WasmEdge_VMRunWasmFromFile(vm_cxt, argv[1], func_name, params, 1, returns, 1);



  if (WasmEdge_ResultOK(res)) {

    std::cout << ""Get result: "" << WasmEdge_ValueGetI32(returns[0]) << std::endl;

  } else {

    std::cout << ""Error message: "" << WasmEdge_ResultGetMessage(res) << std::endl;

  }



  /* Resources deallocations. */

  WasmEdge_VMDelete(vm_cxt);

  WasmEdge_ConfigureDelete(conf_cxt);

  WasmEdge_StringDelete(func_name);

  return 0;

}

```



You can use the -I flag to specify the include directories and the -L and -l flags to specify the library directories and library names, respectively. Then you can compile the code and run: ( the 40th fibonacci number is 102334155)



```bash

gcc example.cpp -x c++ -I/path/to/wasmedge/include -L/path/to/wasmedge/lib -lwasmedge -o example

```



To run the `example` executable that was created in the previous step, you can use the following command



```bash

./example

```



## Quick Start Guide in AOT compiler



```cpp

#include <wasmedge/wasmedge.h>

#include <stdio.h>



int main(int argc, const char* argv[]) {

  // Create the configure context and add the WASI support.

  // This step is not necessary unless you need WASI support.

  wasmedge_configure_context* conf_cxt = wasmedge_configure_create();

  wasmedge_configure_add_host_registration(conf_cxt, WASMEDGE_HOST_REGISTRATION_WASI);



  // Create the VM context in AOT mode.

  wasmedge_vm_context* vm_cxt = wasmedge_vm_create_aot(conf_cxt, NULL);



  // The parameters and returns arrays.

  wasmedge_value params[1] = { wasmedge_value_gen_i32(32) };

  wasmedge_value returns[1];

  // Function name.

  wasmedge_string func_name = wasmedge_string_create_by_cstring(""fib"");

  // Run the WASM function from file.

  wasmedge_result res = wasmedge_vm_run_wasm_from_file(vm_cxt, argv[1], func_name, params, 1, returns, 1);



  if (wasmedge_result_ok(res)) {

    printf(""Get result: %d\n"", wasmedge_value_get_i32(returns[0]));

  } else {

    printf(""Error message: %s\n"", wasmedge_result_get_message(res));

  }



  // Resources deallocations.

  wasmedge_vm_delete(vm_cxt);

  wasmedge_configure_delete(conf_cxt);

  wasmedge_string_delete(func_name);

  return 0;

}

```



In this example, the wasmedge_vm_create_aot function is used to create a wasmedge_vm_context object in AOT mode, which is then passed as the second argument to the wasmedge_vm_run_wasm_from_file function to execute the Wasm module in AOT mode.








------"
"```json:/embed/data/_category_.json


{

  ""label"": ""Passing Complex Data"",

  ""position"": 2,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Passing Complex Data from the host app to the wasm app""

  }

}








```"
"The following is a markdown document located at /embed/data/go.md
------


---

sidebar_position: 3

---



# Go Host application with wasmedge-bindgen



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /embed/data/intro.md
------


---

sidebar_position: 1

---



# WasmEdge-Bindgen Introduction



Passing complex data like a string is difficult for WebAssembly since WASM does not have a string data type. That's why we have the [WasmEdge-Bindgen](https://github.com/second-state/wasmedge-bindgen) project. The Wasmedge-Bindgen project provides Rust macros for functions to accept and return complex data types and then for functions in the host to call such Rust functions running in WasmEdge.



Now WasmEdge-bindgen supports WasmEdge Go SDK and Rust SDK. I will walk you through how to pass complex data from GO and Rust host to an embedded WASM function.



- [Passing complex data from WasmEdge Go SDK](go.md)

- [Passing complex data from WasmEdge Rust SDK](rust.md)








------"
"The following is a markdown document located at /embed/data/rust.md
------


---

sidebar_position: 2

---



# Rust Host application with wasmedge-bindgen



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"```json:/embed/go/reference/_category_.json


{

  ""label"": ""API Reference"",

  ""position"": 7,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will discuss the WasmEdge Go API Reference.""

  }

}








```"
"The following is a markdown document located at /embed/go/reference/0.10.x.md
------


---

sidebar_position: 7

---



# Go API v0.10.1 Documentation



The following are the guides to develop with the WasmEdge-Go SDK.



**Developers can refer to [here to upgrade to 0.11.0](upgrade_to_0.11.0.md).**



## Table of Contents



- [Getting Started](#getting-started)

  - [WasmEdge Installation](#wasmedge-installation)

  - [Get WasmEdge-go](#get-wasmedge-go)

  - [WasmEdge-go Extensions](#wasmedge-go-extensions)

  - [Example repository](#example-repository)

- [WasmEdge-go Basics](#wasmedge-go-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Results](#results)

  - [Contexts And Their Life Cycles](#contexts-and-their-life-cycles)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

  - [Tools driver](#tools-driver-v0101-or-upper-only)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Object](#wasm-execution-example-with-vm-object)

  - [VM Creations](#vm-creations)

  - [Preregistrations](#preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## Getting Started



The WasmEdge-go requires golang version >= 1.16. Please check your golang version before installation. Developers can [download golang here](https://golang.org/dl/).



```bash

$ go version

go version go1.16.5 linux/amd64

```



### WasmEdge Installation



Developers must [install the WasmEdge shared library](../../../start/install.md#install) with the same `WasmEdge-go` release or pre-release version.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.10.1

```



For the developers need the `TensorFlow` or `Image` extension for `WasmEdge-go`, please install the `WasmEdge` with extensions:



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.10.1

```



Noticed that the `TensorFlow` and `Image` extensions are only for the `Linux` platforms. After installation, developers can use the `source` command to update the include and linking searching path.



### Get WasmEdge-go



After the WasmEdge installation, developers can get the `WasmEdge-go` package and build it in your Go project directory.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

go build

```



<!-- prettier-ignore -->

:::note

The WasmEdge-Go version number should match the installed WasmEdge version.

:::



### WasmEdge-go Extensions



By default, the `WasmEdge-go` only turns on the basic runtime.



`WasmEdge-go` has the following extensions (on the Linux platforms only):



- Tensorflow



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow).

  - The `TensorFlow` and `TensorFlow-Lite` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e tensorflow` command.

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflow

    ```



- Tensorflow-Lite (`v0.10.1` or upper only)



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow) with only `TensorFlow-Lite`.

  - The `TensorFlow-Lite` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e tensorflow` command.

  - **THIS TAG CANNOT BE USED WITH THE `tensorflow` TAG.**

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflowlite

    ```



- Image



  - This extension supports the host functions in [WasmEdge-image](https://github.com/second-state/WasmEdge-image).

  - The `Image` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e image` command.

  - For using this extension, the tag `image` when building is required:



    ```bash

    go build -tags image

    ```



Users can also turn on the multiple extensions when building:



```bash

go build -tags image,tensorflow

```



### Example Repository



Developers can refer to [the example repository](https://github.com/second-state/WasmEdge-go-examples/) for the WasmEdge-Go examples.



## WasmEdge-go Basics



In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.



### Version



The `Version` related APIs provide developers to check for the installed WasmEdge shared library version.



```go

import ""github.com/second-state/WasmEdge-go/wasmedge""



verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.

vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.

verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.

verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.

```



### Logging Settings



The `wasmedge.SetLogErrorLevel()` and `wasmedge.SetLogDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



### Value Types



In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.



1. Number types: `i32`, `i64`, `f32`, and `f64`



   - Convert the `uint32` and `int32` to `i32` automatically when passing a value into WASM.

   - Convert the `uint64` and `int64` to `i64` automatically when passing a value into WASM.

   - Convert the `uint` and `int` to `i32` automatically when passing a value into WASM in 32-bit system.

   - Convert the `uint` and `int` to `i64` automatically when passing a value into WASM in 64-bit system.

   - Convert the `float32` to `f32` automatically when passing a value into WASM.

   - Convert the `float64` to `f64` automatically when passing a value into WASM.

   - Convert the `i32` from WASM to `int32` when getting a result.

   - Convert the `i64` from WASM to `int64` when getting a result.

   - Convert the `f32` from WASM to `float32` when getting a result.

   - Convert the `f64` from WASM to `float64` when getting a result.



2. Number type: `v128` for the `SIMD` proposal



   Developers should use the `wasmedge.NewV128()` to generate a `v128` value, and use the `wasmedge.GetV128()` to get the value.



   ```go

   val := wasmedge.NewV128(uint64(1234), uint64(5678))

   high, low := val.GetVal()

   // `high` will be uint64(1234), `low` will be uint64(5678)

   ```



3. Reference types: `FuncRef` and `ExternRef` for the `Reference-Types` proposal



   ```go

   var funccxt *wasmedge.Function = ... // Create or get function object.

   funcref := wasmedge.NewFuncRef(funccxt)

   // Create a `FuncRef` with the function object.



   num := 1234

   // `num` is a `int`.

   externref := wasmedge.NewExternRef(&num)

   // Create an `ExternRef` which reference to the `num`.

   num = 5678

   // Modify the `num` to 5678.

   numref := externref.GetRef().(*int)

   // Get the original reference from the `ExternRef`.

   fmt.Println(*numref)

   // Will print `5678`.

   numref.Release()

   // Should call the `Release` method.

   ```



### Results



The `Result` object specifies the execution status. Developers can use the `Error()` function to get the error message.



```go

// Assume that `vm` is a `wasmedge.VM` object.

res, err = vm.Execute(...) // Ignore the detail of parameters.

// Assume that `res, err` are the return values for executing a function with `vm`.

if err != nil {

  fmt.Println(""Error message:"", err.Error())

}

```



### Contexts And Their Life Cycles



The objects, such as `VM`, `Store`, and `Function`, etc., are composed of `Context`s in the WasmEdge shared library. All of the contexts can be created by calling the corresponding `New` APIs, developers should also call the corresponding `Release` functions of the contexts to release the resources. Noticed that it's not necessary to call the `Release` functions for the contexts which are retrieved from other contexts but not created from the `New` APIs.



```go

// Create a Configure.

conf := wasmedge.NewConfigure()

// Release the `conf` immediately.

conf.Release()

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `Limit` struct presents the minimum and maximum value data structure.



   ```go

   lim1 := wasmedge.NewLimit(12)

   fmt.Println(lim1.HasMax())

   // Will print `false`.

   fmt.Println(lim1.GetMin())

   // Will print `12`.



   lim2 := wasmedge.NewLimitWithMax(15, 50)

   fmt.Println(lim2.HasMax())

   // Will print `true`.

   fmt.Println(lim2.GetMin())

   // Will print `15`.

   fmt.Println(lim2.GetMax())

   // Will print `50`.

   ```



   For the thread proposal, the `Limit` struct also supports the shared memory description. (`v0.10.1` or upper only)



   ```go

   lim3 := wasmedge.NewLimitShared(20)

   fmt.Println(lim3.HasMax())

   // Will print `false`.

   fmt.Println(lim3.IsShared())

   // Will print `true`.

   fmt.Println(lim3.GetMin())

   // Will print `20`.



   lim4 := wasmedge.NewLimitSharedWithMax(30, 40)

   fmt.Println(lim4.HasMax())

   // Will print `true`.

   fmt.Println(lim4.IsShared())

   // Will print `true`.

   fmt.Println(lim4.GetMin())

   // Will print `30`.

   fmt.Println(lim4.GetMax())

   // Will print `40`.

   ```



2. Function type context



   The `FunctionType` is an object holds the function type context and used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `FunctionType` APIs to get the parameter or return value types information.



   ```go

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{

       wasmedge.ValType_ExternRef,

       wasmedge.ValType_I32,

       wasmedge.ValType_I64,

     }, []wasmedge.ValType{

       wasmedge.ValType_F32,

       wasmedge.ValType_F64,

     })



   plen := functype.GetParametersLength()

   // `plen` will be 3.

   rlen := functype.GetReturnsLength()

   // `rlen` will be 2.

   plist := functype.GetParameters()

   // `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.

   rlist := functype.GetReturns()

   // `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.



   functype.Release()

   ```



3. Table type context



   The `TableType` is an object holds the table type context and used for `Table` instance creation or getting information from `Table` instances.



   ```go

   lim := wasmedge.NewLimit(12)

   tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)



   rtype := tabtype.GetRefType()

   // `rtype` will be `wasmedge.RefType_ExternRef`.

   getlim := tabtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   tabtype.Release()

   ```



4. Memory type context



   The `MemoryType` is an object holds the memory type context and used for `Memory` instance creation or getting information from `Memory` instances.



   ```go

   lim := wasmedge.NewLimit(1)

   memtype := wasmedge.NewMemoryType(lim)



   getlim := memtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   memtype.Release()

   ```



5. Global type context



   The `GlobalType` is an object holds the global type context and used for `Global` instance creation or getting information from `Global` instances.



   ```go

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)



   vtype := globtype.GetValType()

   // `vtype` will be `wasmedge.ValType_F64`.

   vmut := globtype.GetMutability()

   // `vmut` will be `wasmedge.ValMut_Var`.



   globtype.Release()

   ```



6. Import type context



   The `ImportType` is an object holds the import type context and used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `ImportType` object. The details about querying `ImportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   imptypelist := ast.ListImports()

   // Assume that `imptypelist` is an array listed from the `ast` for the imports.



   for i, imptype := range imptypelist {

     exttype := imptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     modname := imptype.GetModuleName()

     extname := imptype.GetExternalName()

     // Get the module name and external name of the imports.



     extval := imptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



7. Export type context



   The `ExportType` is an object holds the export type context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `ExportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   exptypelist := ast.ListExports()

   // Assume that `exptypelist` is an array listed from the `ast` for the exports.



   for i, exptype := range exptypelist {

     exttype := exptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     extname := exptype.GetExternalName()

     // Get the external name of the exports.



     extval := exptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `wasmedge.Async` object. Developers own the object and should call the `(*Async).Release()` API to release it.



1. Get the execution result of the asynchronous execution



   Developers can use the `(*Async).GetResult()` API to block and wait for getting the return values. This function will block and wait for the execution. If the execution has finished, this function will return immediately. If the execution failed, this function will return an error.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution and get the return values.

   res, err := async.GetResult()

   async.Release()

   ```



2. Wait for the asynchronous execution with timeout settings



   Besides waiting until the end of execution, developers can set the timeout to wait for.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution with the timeout(ms).

   isend := async.WaitFor(1000)

   if isend {

     res, err := async.GetResult()

     // ...

   } else {

     async.Cancel()

     _, err := async.GetResult()

     // The error message in `err` will be ""execution interrupted"".

   }

   async.Release()

   ```



### Configurations



The configuration object, `wasmedge.Configure`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` object to create other runtime objects.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` object.



   ```go

   const (

     IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)

     NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)

     SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)

     MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)

     BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)

     REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)

     SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)

     TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)

     ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)

     MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)

     THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)

     EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)

     FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)

   )

   ```



   Developers can add or remove the proposals into the `Configure` object.



   ```go

   // By default, the following proposals have turned on initially:

   // * IMPORT_EXPORT_MUT_GLOBALS

   // * NON_TRAP_FLOAT_TO_INT_CONVERSIONS

   // * SIGN_EXTENSION_OPERATORS

   // * MULTI_VALUE

   // * BULK_MEMORY_OPERATIONS

   // * REFERENCE_TYPES

   // * SIMD

   // For the current WasmEdge version, the following proposals are supported:

   // * TAIL_CALL

   // * MULTI_MEMORIES

   // * THREADS

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)

   conf.AddConfig(wasmedge.SIMD)

   conf.RemoveConfig(wasmedge.REFERENCE_TYPES)

   is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)

   // The `is_bulkmem` will be `true`.

   conf.Release()

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` or `wasmedge_process` supports and only effective in `VM` objects.



   ```go

   const (

     WASI                        = HostRegistration(C.WasmEdge_HostRegistration_Wasi)

     WasmEdge_PROCESS            = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)

     // The follows are `v0.10.1` or upper only.

     WasiNN                      = HostRegistration(C.WasmEdge_HostRegistration_WasiNN)

     WasiCrypto_Common           = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Common)

     WasiCrypto_AsymmetricCommon = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon)

     WasiCrypto_Kx               = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Kx)

     WasiCrypto_Signatures       = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Signatures)

     WasiCrypto_Symmetric        = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Symmetric)

   )

   ```



   The details will be introduced in the [preregistrations of VM context](#preregistrations).



   ```go

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.WASI)

   conf.AddConfig(wasmedge.WASI)

   conf.Release()

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` objects.



   ```go

   conf := wasmedge.NewConfigure()



   pagesize := conf.GetMaxMemoryPage()

   // By default, the maximum memory page size in each memory instances is 65536.

   conf.SetMaxMemoryPage(1234)

   pagesize := conf.GetMaxMemoryPage()

   // `pagesize` will be 1234.



   conf.Release()

   ```



4. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```go

   const (

     // Disable as many optimizations as possible.

     CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

     // Optimize quickly without destroying debuggability.

     CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

     // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

     CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

     // Optimize for fast execution as much as possible.

     CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

     // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

     CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

     // Optimize for small code size as much as possible.

     CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

   )



   const (

     // Native dynamic library format.

     CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

     // WebAssembly with AOT compiled codes in custom section.

     CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

   )

   ```



   These configurations are only effective in `Compiler` contexts.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the optimization level is O3.

   conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)

   // By default, the output format is universal WASM.

   conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)

   // By default, the dump IR is `false`.

   conf.SetCompilerDumpIR(true)

   // By default, the generic binary is `false`.

   conf.SetCompilerGenericBinary(true)



   conf.Release()

   ```



5. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` objects.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsInstructionCounting(true)

   // By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsTimeMeasuring(true)

   // By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsCostMeasuring(true)



   conf.Release()

   ```



### Statistics



The statistics object, `wasmedge.Statistics`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` object from the `VM` object, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```go

   stat := wasmedge.NewStatistics()

   // ... After running the WASM functions with the `Statistics` object



   count := stat.GetInstrCount()

   ips := stat.GetInstrPerSecond()

   stat.Release()

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` object. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   stat := wasmedge.NewStatistics()



   costtable := []uint64{

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0,

   }

   // Developers can set the costs of each instruction. The value not covered will be 0.



   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   stat.SetCostTable()

   stat.SetCostLimit(5000000)



   // ... After running the WASM functions with the `Statistics` object

   cost := stat.GetTotalCost()

   stat.Release()

   ```



### Tools Driver (`v0.10.1` or upper only)



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools in WasmEdge-Go. The API arguments are the same as the command line arguments of the CLI tools.



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeCLI(os.Args)

}

```



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)

}

```



## WasmEdge VM



In this partition, we will introduce the functions of `wasmedge.VM` object and show examples of executing WASM functions.



### WASM Execution Example With VM Object



The following shows the example of running the WASM for getting the Fibonacci. This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current `wasmedge_test` directory, and create and edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create the configure context and add the WASI support.

     // This step is not necessary unless you need WASI support.

     conf := wasmedge.NewConfigure(wasmedge.WASI)

     // Create VM with the configure.

     vm := wasmedge.NewVMWithConfig(conf)



     res, err := vm.RunWasmFile(""fibonacci.wasm"", ""fib"", uint32(21))

     if err == nil {

       fmt.Println(""Get fibonacci[21]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

     conf.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

   $ go build

   $ ./wasmedge_test

   Get fibonacci[21]: 17711

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` object APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create VM.

     vm := wasmedge.NewVM()

     var err error

     var res []interface{}



     // Step 1: Load WASM file.

     err = vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     // Developers can load, validate, and instantiate another WASM module

     // to replace the instantiated one. In this case, the old module will

     // be cleared, but the registered modules are still kept.

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Execute WASM functions. Parameters: (funcname, args...)

     res, err = vm.Execute(""fib"", uint32(25))

     // Developers can execute functions repeatedly after instantiation.

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



   The following graph explains the status of the `VM` object.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered,

                   ExecuteBindgen, ExecuteBindgenRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or import objects in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation APIs accepts the `Configure` object and the `Store` object. Noticed that if the `VM` created with the outside `Store` object, the `VM` will execute WASM on that `Store` object. If the `Store` object is set into multiple `VM` objects, it may causes data conflict when in execution. The details of the `Store` object will be introduced in [Store](#store).



```go

conf := wasmedge.NewConfigure()

store := wasmedge.NewStore()



// Create a VM with default configure and store.

vm := wasmedge.NewVM()

vm.Release()



// Create a VM with the specified configure and default store.

vm = wasmedge.NewVMWithConfig(conf)

vm.Release()



// Create a VM with the default configure and specified store.

vm = wasmedge.NewVMWithStore(store)

vm.Release()



// Create a VM with the specified configure and store.

vm = wasmedge.NewVMWithConfigAndStore(conf, store)

vm.Release()



conf.Release()

store.Release()

```



### Preregistrations



WasmEdge provides the following built-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` object.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WASI)

   // Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.

   vm := wasmedge.NewVMWithConfig(conf)

   vm.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   wasiconf := conf.GetImportModule(wasmedge.WASI)

   // Initialize the WASI.

   wasiconf.InitWasi(/* ... ignored */)



   conf.Release()

   ```



   And also can create the WASI import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. [WasmEdge_Process](https://crates.io/crates/wasmedge_process_interface)



   This pre-registration is for the process interface for WasmEdge on `Rust` sources. After turning on this pre-registration, the VM will support the `wasmedge_process` plugin.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)

   vm := wasmedge.NewVMWithConfig(conf)

   vm.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   procconf := conf.GetImportModule(wasmedge.WasmEdge_PROCESS)

   // Initialize the WasmEdge_Process.

   procconf.InitWasmEdgeProcess(/* ... ignored */)



   conf.Release()

   ```



   And also can create the WasmEdge_Process import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



3. [WASI-NN proposal](https://github.com/WebAssembly/wasi-nn) (`v0.10.1` or upper only)



   Developers can turn on the WASI-NN proposal support for VM in the `Configure` object.



   > Note: Please check that the [dependencies and prerequests](../../../start/install.md#wasi-nn-plug-in-with-openvino-backend) are satisfied.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WasiNN)

   vm := wasmedge.NewVMWithConfig(conf)

   vm.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   nnmodule := conf.GetImportModule(wasmedge.WasiNN)

   conf.Release()

   ```



   And also can create the WASI-NN module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



4. [WASI-Crypto proposal](https://github.com/WebAssembly/wasi-crypto) (`v0.10.1` or upper only)



   Developers can turn on the WASI-Crypto proposal support for VM in the `Configure` object.



   > Note: Please check that the [dependencies and prerequests](../../../start/install.md#wasi-crypto-plug-in) are satisfied.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WasiCrypto_Common, wasmedge.WasiCrypto_AsymmetricCommon, wasmedge.WasiCrypto_Kx, wasmedge.WasiCrypto_Signatures, wasmedge.WasiCrypto_Symmetric)

   vm := wasmedge.NewVMWithConfig(conf)

   vm.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   nnmodule := conf.GetImportModule(wasmedge.WasiCrypto_Common)

   conf.Release()

   ```



   And also can create the WASI-Crypto module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge-go, the host functions are composed into host modules as `Module` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` object.



```go

vm := wasmedge.NewVM()

// You can also create and register the WASI host modules by this API.

wasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)



res := vm.RegisterModule(wasiobj)

// The result status should be checked.



vm.Release()

// The created import objects should be released.

wasiobj.Release()

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory. Then create and edit the Go file `main.go` as following:



   ```go

   package main



   import ""github.com/second-state/WasmEdge-go/wasmedge""



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var err error

     err = vm.RegisterWasmFile(""module_name"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     // The result status should be checked. The error will occur if the

     // WASM module instantiation failed or the module name conflicts.



     vm.Release()

   }

   ```



2. Execute the functions in registered WASM modules



   Edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var res []interface{}

     var err error

     // Register the WASM module from file into VM with the module name ""mod"".

     err = vm.RegisterWasmFile(""mod"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     if err != nil {

       fmt.Println(""WASM registration failed:"", err.Error())

       return

     }

     // The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

     // name ""mod"". As the same as host functions, other modules can import the

     // function `""mod"" ""fib""`.



     // Execute WASM functions in registered modules.

     // Unlike the execution of functions, the registered functions can be

     // invoked without `(*VM).Instantiate` because the WASM module was

     // instantiated when registering.

     // Developers can also invoke the host functions directly with this API.

     res, err = vm.ExecuteRegistered(""mod"", ""fib"", int32(25))

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.

     async := vm.AsyncRunWasmFile(""fibonacci.wasm"", ""fib"", uint32(20))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

   $ go build

   $ ./wasmedge_test

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     var err error

     var res []interface{}



     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,

     // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.

     async := vm.AsyncExecute(""fib"", uint32(25))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

   $ go build

   $ ./wasmedge_test

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` object supplies the APIs to retrieve the instances.



1. Store



   If the `VM` object is created without assigning a `Store` object, the `VM` context will allocate and own a `Store`.



   ```go

   vm := wasmedge.NewVM()

   store := vm.GetStore()

   // The object should __NOT__ be deleted by calling `(*Store).Release`.

   vm.Release()

   ```



   Developers can also create the `VM` object with a `Store` object. In this case, developers should guarantee that the `Store` object cannot be released before the `VM` object. Please refer to the [Store Objects](#store) for the details about the `Store` APIs.



   ```go

   store := wasmedge.NewStore()

   vm := wasmedge.NewVMWithStore(store)



   storemock := vm.GetStore()

   // The internal store context of the `store` and the `storemock` are the same.



   vm.Release()

   store.Release()

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `(*VM).Execute` function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // List the exported functions for the names and function types.

     funcnames, functypes := vm.GetFunctionList()

     for _, fname := range funcnames {

       fmt.Println(""Exported function name:"", fname)

     }

     for _, ftype := range functypes {

       // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.

       // Developers should __NOT__ call the `ftype.Release()`.

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

   $ go build

   $ ./wasmedge_test

   Exported function name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` object from the `VM` object and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` object provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   functype := vm.GetFunctionType(""fib"")

   // Developers can get the function types of functions in the registered modules via the

   // `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.

   // If the function is not found, these APIs will return `nil`.

   // Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` object. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `(*VM).GetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   mod := vm.GetActiveModule()

   // If there's no WASM module instantiated, this API will return `nil`.

   // Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.

   ```



5. Get the components (`v0.10.1` or upper only)



   The `VM` object is composed by the `Loader`, `Validator`, and `Executor` objects. For the developers who want to use these objects without creating another instances, these APIs can help developers to get them from the `VM` object. The get objects are owned by the `VM` object, and developers should not call their release functions.



   ```go

   loader := vm.GetLoader()

   // Developers should __NOT__ call the `(*Loader).Release` function of the returned object.

   validator := vm.GetValidator()

   // Developers should __NOT__ call the `(*Validator).Release` function of the returned object.

   executor := vm.GetExecutor()

   // Developers should __NOT__ call the `(*Executor).Release` function of the returned object.

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` object](#wasmedge-vm) rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` objects.



Assume that a new Go project is created as following:



```bash

mkdir wasmedge_test && cd wasmedge_test

go mod init wasmedge_test

```



Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



```go

package main



import (

  ""fmt""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  // Set the logging level to debug to print the statistics info.

  wasmedge.SetLogDebugLevel()

  // Create the configure object. This is not necessary if developers use the default configuration.

  conf := wasmedge.NewConfigure()

  // Turn on the runtime instruction counting and time measuring.

  conf.SetStatisticsInstructionCounting(true)

  conf.SetStatisticsTimeMeasuring(true)

  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.

  stat := wasmedge.NewStatistics()

  // Create the store object. The store object is the WASM runtime structure core.

  store := wasmedge.NewStore()



  var err error

  var res []interface{}

  var ast *wasmedge.AST

  var mod *wasmedge.Module



  // Create the loader object.

  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

  loader := wasmedge.NewLoaderWithConfig(conf)

  // Create the validator object.

  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

  validator := wasmedge.NewValidatorWithConfig(conf)

  // Create the executor object.

  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.

  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)



  // Load the WASM file or the compiled-WASM file and convert into the AST module object.

  ast, err = loader.LoadFile(""fibonacci.wasm"")

  if err != nil {

    fmt.Println(""Load WASM from file FAILED:"", err.Error())

    return

  }

  // Validate the WASM module.

  err = validator.Validate(ast)

  if err != nil {

    fmt.Println(""Validation FAILED:"", err.Error())

    return

  }

  // Instantiate the WASM module and get the output module instance.

  mod, err = executor.Instantiate(store, ast)

  if err != nil {

    fmt.Println(""Instantiation FAILED:"", err.Error())

    return

  }



  // Try to list the exported functions of the instantiated WASM module.

  funcnames := mod.ListFunction()

  for _, fname := range funcnames {

    fmt.Println(""Exported function name:"", fname)

  }



  // Invoke the WASM function.

  funcinst := mod.FindFunction(""fib"")

  if funcinst == nil {

    fmt.Println(""Run FAILED: Function name `fib` not found"")

    return

  }

  res, err = executor.Invoke(store, funcinst, int32(30))

  if err == nil {

    fmt.Println(""Get fibonacci[30]:"", res[0].(int32))

  } else {

    fmt.Println(""Run FAILED:"", err.Error())

  }



  // Resources deallocations.

  conf.Release()

  stat.Release()

  ast.Release()

  loader.Release()

  validator.Release()

  executor.Release()

  store.Release()

  mod.Release()

}

```



Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)



```bash

$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

$ go build

$ ./wasmedge_test

Exported function name: fib

[2021-11-24 18:53:01.451] [debug]  Execution succeeded.

[2021-11-24 18:53:01.452] [debug]

 ====================  Statistics  ====================

 Total execution time: 556372295 ns

 Wasm instructions execution time: 556372295 ns

 Host functions execution time: 0 ns

 Executed wasm instructions count: 28271634

 Gas costs: 0

 Instructions per second: 50814237

Get fibonacci[30]: 1346269

```



### Loader



The `Loader` object loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```go

var buf []byte

// ... Read the WASM code to the `buf`.



// Developers can adjust settings in the configure object.

conf := wasmedge.NewConfigure()

// Create the loader object.

// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

loader := wasmedge.NewLoaderWithConfig(conf)

conf.Release()



// Load WASM or compiled-WASM from the file.

ast, err := loader.LoadFile(""fibonacci.wasm"")

if err != nil {

  fmt.Println(""Load WASM from file FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



// Load WASM or compiled-WASM from the buffer

ast, err = loader.LoadBuffer(buf)

if err != nil {

  fmt.Println(""Load WASM from buffer FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



loader.Release()

```



### Validator



The `Validator` object can validate the WASM module. Every WASM module should be validated before instantiation.



```go

// ...

// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.

// Assume that the `conf` is the `*wasmedge.Configure` object.



// Create the validator context.

// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

validator := wasmedge.NewValidatorWithConfig(conf)



err := validator.Validate(ast)

if err != nil {

  fmt.Println(""Validation FAILED:"", err.Error())

}



validator.Release()

```



### Executor



The `Executor` object is the executor for both WASM and compiled-WASM. This object should work base on the `Store` object. For the details of the `Store` object, please refer to the [next chapter](#store).



1. Instantiate and register an `AST` object as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` objects, developers can instantiate and register an `AST` objects into the `Store` context as a named `Module` instance by the `Executor` APIs. After the registration, the result `Module` instance is exported with the given module name and can be linked when instantiating another module. For the details about the `Module` instances APIs, please refer to the [Instances](#instances).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Register the loaded WASM `ast` into store with the export module name ""mod"".

   mod, res := executor.Register(store, ast, ""mod"")

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST` object, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Create a module instance for host functions.

   mod := wasmedge.NewModule(""mod"")

   // ...

   // Create and add the host functions, tables, memories, and globals into the module instance.

   // ...



   // Register the module instance into store with the exported module name.

   // The export module name is in the module instance already.

   res := executor.RegisterImport(store, mod)

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



3. Instantiate an `AST` object to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` object for linking.



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Instantiate the WASM module.

   mod, err := executor.Instantiate(stpre, ast)

   if err != nil {

     fmt.Println(""WASM instantiation FAILED:"", err.Error())

     return

   }



   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `(*Executor).Invoke` API.



### AST Module



The `AST` object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST` object.



```go

ast := ...

// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.



// List the imports.

imports := ast.ListImports()

for _, import := range imports {

  fmt.Println(""Import:"", import.GetModuleName(), import.GetExternalName())

}



// List the exports.

exports := ast.ListExports()

for _, export := range exports {

  fmt.Println(""Export:"", export.GetExternalName())

}



ast.Release()

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` object in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context.



```go

store := wasmedge.NewStore()



// ...

// Register a WASM module via the executor object.

// ...



// Try to list the registered WASM modules.

modnames := store.ListModule()

// ...



// Find named module by name.

mod := store.FindModule(""module"")

// If the module with name not found, the `mod` will be `nil`.



store.Release()

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST` object, developers will get a `Module` instance as the result, and have the responsibility to release it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```go

   // ...

   // Instantiate a WASM module via the executor object and get the `mod` as the output module instance.

   // ...



   // List the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcnames := mod.ListFunction()



   // Try to find the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcinst := mod.FindFunction(""fib"")

   // `funcinst` will be `nil` if the function not found.

   // The returned instance is owned by the module instance and should __NOT__ be released.

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` objects for host functions and add them into an `Module` instance for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` objects through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```go

   funcobj := ...

   // `funcobj` is the `*wasmedge.Function` retrieved from the module instance.

   functype := funcobj.GetFunctionType()

   // The `funcobj` retrieved from the module instance should __NOT__ be released.

   // The `functype` retrieved from the `funcobj` should __NOT__ be released.



   // For the function object creation, please refer to the `Host Function` guide.

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Table` objects supply APIs to control the data in table instances.



   ```go

   lim := wasmedge.NewLimitWithMax(10, 20)

   // Create the table type with limit and the `FuncRef` element type.

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)

   // Create the table instance with table type.

   tabinst := wasmedge.NewTable(tabtype)

   // Delete the table type.

   tabtype.Release()



   gottabtype := tabinst.GetTableType()

   // The `gottabtype` got from table instance is owned by the `tabinst`

   // and should __NOT__ be released.

   reftype := gottabtype.GetRefType()

   // The `reftype` will be `wasmedge.RefType_FuncRef`.



   var gotdata interface{}

   data := wasmedge.NewFuncRef(5)

   err := tabinst.SetData(data, 3)

   // Set the function index 5 to the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   err = tabinst.SetData(data, 13)



   gotdata, err = tabinst.GetData(3)

   // Get the FuncRef value of the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   gotdata, err = tabinst.GetData(13)



   tabsize := tabinst.GetSize()

   // `tabsize` will be 10.

   err = tabinst.Grow(6)

   // Grow the table size of 6, the table size will be 16.



   // The following line will get an ""out of bounds table access"" error

   // because the size (16 + 6) will reach the table limit (20):

   //   err = tabinst.Grow(6)



   tabinst.Release()

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Memory` objects supply APIs to control the data in memory instances.



   ```go

   lim := wasmedge.NewLimitWithMax(1, 5)

   // Create the memory type with limit. The memory page size is 64KiB.

   memtype := wasmedge.NewMemoryType(lim)

   // Create the memory instance with memory type.

   meminst := wasmedge.NewMemory(memtype)

   // Delete the memory type.

   memtype.Release()



   data := []byte(""A quick brown fox jumps over the lazy dog"")

   err := meminst.SetData(data, 0x1000, 10)

   // Set the data[0:9] to the memory[4096:4105].



   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   err = meminst.SetData(data, 0xFFFF, 10)



   var gotdata []byte

   gotdata, err = meminst.GetData(0x1000, 10)

   // Get the memory[4096:4105]. The `gotdata` will be `[]byte(""A quick br"").

   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   gotdata, err = meminst.Getdata(0xFFFF, 10)



   pagesize := meminst.GetPageSize()

   // `pagesize` will be 1.

   err = meminst.GrowPage(2)

   // Grow the page size of 2, the page size of the memory instance will be 3.



   // The following line will get an ""out of bounds memory access"" error

   // because the size (3 + 3) will reach the memory limit (5):

   //   err = meminst.GetPageSize(3)



   meminst.Release()

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Global` objects supply APIs to control the value in global instances.



   ```go

   // Create the global type with value type and mutation.

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)

   // Create the global instance with value and global type.

   globinst := wasmedge.NewGlobal(globtype, uint64(1000))

   // Delete the global type.

   globtype.Release()



   gotglobtype := globinst.GetGlobalType()

   // The `gotglobtype` got from global instance is owned by the `globinst`

   // and should __NOT__ be released.

   valtype := gotglobtype.GetValType()

   // The `valtype` will be `wasmedge.ValType_I64`.

   valmut := gotglobtype.GetMutability()

   // The `valmut` will be `wasmedge.ValMut_Var`.



   globinst.SetValue(uint64(888))

   // Set the value u64(888) to the global.

   // This function will do nothing if the value type mismatched or the

   // global mutability is `wasmedge.ValMut_Const`.

   gotval := globinst.GetValue()

   // The `gotbal` will be `interface{}` which the type is `uint64` and

   // the value is 888.



   globinst.Release()

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define Go functions with the following function signature as the host function body:



   ```go

   type hostFunctionSignature func(

       data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```go

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }

   ```



   Then developers can create `Function` object with the host function body and function type:



   ```go

   // Create a function type: {i32, i32} -> {i32}.

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )



   // Create a function context with the function type and host function body.

   // The third parameter is the pointer to the additional data.

   // Developers should guarantee the life cycle of the data, and it can be

   // `nil` if the external data is not needed.

   // The last parameter can be 0 if developers do not need the cost measuring.

   func_add := wasmedge.NewFunction(functype, host_add, nil, 0)



   // If the function object is not added into an module instance object, it should be released.

   func_add.Release()

   functype.Release()

   ```



2. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```go

   // Host function body definition.

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   // Create a module instance with the module name ""module"".

   mod := wasmedge.NewModule(""module"")



   // Create and add a function instance into the module instance with export name ""add"".

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )

   hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

   functype.Release()

   mod.AddFunction(""add"", hostfunc)



   // Create and add a table instance into the module instance with export name ""table"".

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))

   hosttab := wasmedge.NewTable(tabtype)

   tabtype.Release()

   mod.AddTable(""table"", hosttab)



   // Create and add a memory instance into the module instance with export name ""memory"".

   memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))

   hostmem := wasmedge.NewMemory(memtype)

   memtype.Release()

   mod.AddMemory(""memory"", hostmem)



   // Create and add a global instance into the module instance with export name ""global"".

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)

   hostglob := wasmedge.NewGlobal(globtype, uint32(666))

   globtype.Release()

   mod.AddGlobal(""global"", hostglob)



   // The module instances should be released.

   // Developers should __NOT__ release the instances added into the module instance objects.

   mod.Release()

   ```



3. Specified module instance



   `wasmedge.NewWasiModule()` API can create and initialize the `WASI` module instance.



   `wasmedge.NewWasiNNModule()` API can create and initialize the `wasi_ephemeral_nn` module instance for `WASI-NN` plugin (`v0.10.1` or upper only).



   `wasmedge.NewWasiCryptoCommonModule()` API can create and initialize the `wasi_ephemeral_crypto_common` module instance for `WASI-Crypto` plugin (`v0.10.1` or upper only).



   `wasmedge.NewWasiCryptoAsymmetricCommonModule()` API can create and initialize the `wasi_ephemeral_crypto_asymmetric_common` module instance for `WASI-Crypto` plugin (`v0.10.1` or upper only).



   `wasmedge.NewWasiCryptoKxModule()` API can create and initialize the `wasi_ephemeral_crypto_kx` module instance for `WASI-Crypto` plugin (`v0.10.1` or upper only).



   `wasmedge.NewWasiCryptoSignaturesModule()` API can create and initialize the `wasi_ephemeral_crypto_signatures` module instance for `WASI-Crypto` plugin (`v0.10.1` or upper only).



   `wasmedge.NewWasiCryptoSymmetricModule()` API can create and initialize the `wasi_ephemeral_crypto_symmetric` module instance for `WASI-Crypto` plugin (`v0.10.1` or upper only).



   `wasmedge.NewWasmEdgeProcessModule()` API can create and initialize the `wasmedge_process` module instance for `wasmedge_process` plugin.



   Developers can create these module instance objects and register them into the `Store` or `VM` objects rather than adjust the settings in the `Configure` objects.



   > Note: For the `WASI-NN` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-nn-plug-in-with-openvino-backend) are satisfied. Note: For the `WASI-Crypto` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-crypto-plug-in) are satisfied. And the 5 modules are recommended to all be created and registered together.



   ```go

   wasiobj := wasmedge.NewWasiModule(

     os.Args[1:],     // The args

     os.Environ(),    // The envs

     []string{"".:.""}, // The mapping preopens

   )

   procobj := wasmedge.NewWasmEdgeProcessModule(

     []string{""ls"", ""echo""}, // The allowed commands

     false,                  // Not to allow all commands

   )



   // Register the WASI and WasmEdge_Process into the VM object.

   vm := wasmedge.NewVM()

   vm.RegisterImport(wasiobj)

   vm.RegisterImport(procobj)



   // ... Execute some WASM functions.



   // Get the WASI exit code.

   exitcode := wasiobj.WasiGetExitCode()

   // The `exitcode` will be 0 if the WASI function ""_start"" execution has no error.

   // Otherwise, it will return with the related exit code.



   vm.Release()

   // The import objects should be deleted.

   wasiobj.Release()

   procobj.Release()

   ```



4. Example



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that there is a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   Create and edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // Create the module instance with the module name ""extern"".

     impmod := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

     functype.Release()

     impmod.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(impmod)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }



     impmod.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   ```



5. Host Data Example



   Developers can set a external data object to the `Function` object, and access to the object in the function body. Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Also set the result to the data.

     *data.(*int32) = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // The additional data to set into the host function.

     var data int32 = 0



     // Create the module instance with the module name ""extern"".

     modinst := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)

     functype.Release()

     modinst.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(modinst)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     fmt.Println(""Data value:"", data)



     modinst.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.1

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   Data value: 6912

   ```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options in Go. WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) provide a tool for compiling a WASM file.



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```go

const (

  // Disable as many optimizations as possible.

  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

  // Optimize quickly without destroying debuggability.

  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

  // Optimize for fast execution as much as possible.

  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

  // Optimize for small code size as much as possible.

  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

)



const (

  // Native dynamic library format.

  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

  // WebAssembly with AOT compiled codes in custom section.

  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

)

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/go/reference/0.11.x.md
------


---

sidebar_position: 5

---



# Go API v0.11.2 Documentation



The following are the guides to develop with the WasmEdge-Go SDK.



**Developers can refer to [here to upgrade to v0.12.0](upgrade_to_0.12.0).**



## Table of Contents



- [Getting Started](#getting-started)

  - [WasmEdge Installation](#wasmedge-installation)

  - [Get WasmEdge-go](#get-wasmedge-go)

  - [WasmEdge-go Extensions](#wasmedge-go-extensions)

  - [Example repository](#example-repository)

- [WasmEdge-go Basics](#wasmedge-go-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Results](#results)

  - [Contexts And Their Life Cycles](#contexts-and-their-life-cycles)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

  - [Tools driver](#tools-driver)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Object](#wasm-execution-example-with-vm-object)

  - [VM Creations](#vm-creations)

  - [Preregistrations](#preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## Getting Started



The WasmEdge-go requires golang version >= 1.16. Please check your golang version before installation. Developers can [download golang here](https://golang.org/dl/).



```bash

$ go version

go version go1.16.5 linux/amd64

```



### WasmEdge Installation



Developers must [install the WasmEdge shared library](../../../start/install.md#install) with the same `WasmEdge-go` release or pre-release version.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.2

```



For the developers need the `TensorFlow` or `Image` extension for `WasmEdge-go`, please install the `WasmEdge` with extensions:



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.11.2

```



Noticed that the `TensorFlow` and `Image` extensions are only for the `Linux` and `Darwin x86_64` platforms. After installation, developers can use the `source` command to update the include and linking searching path.



### Get WasmEdge-go



After the WasmEdge installation, developers can get the `WasmEdge-go` package and build it in your Go project directory.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

go build

```



<!-- prettier-ignore -->

:::note

The WasmEdge-Go version number should match the installed WasmEdge version.

:::



### WasmEdge-go Extensions



By default, the `WasmEdge-go` only turns on the basic runtime.



`WasmEdge-go` has the following extensions (on the Linux platforms only):



- Tensorflow



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow).

  - The `TensorFlow` and `TensorFlow-Lite` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e tensorflow` command.

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflow

    ```



- Tensorflow-Lite



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow) with only `TensorFlow-Lite`.

  - The `TensorFlow-Lite` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e tensorflow` command.

  - **THIS TAG CANNOT BE USED WITH THE `tensorflow` TAG.**

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflowlite

    ```



- Image



  - This extension supports the host functions in [WasmEdge-image](https://github.com/second-state/WasmEdge-image).

  - The `Image` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e image` command.

  - For using this extension, the tag `image` when building is required:



    ```bash

    go build -tags image

    ```



Users can also turn on the multiple extensions when building:



```bash

go build -tags image,tensorflow

```



### Example Repository



Developers can refer to [the example repository](https://github.com/second-state/WasmEdge-go-examples/) for the WasmEdge-Go examples.



## WasmEdge-go Basics



In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.



### Version



The `Version` related APIs provide developers to check for the installed WasmEdge shared library version.



```go

import ""github.com/second-state/WasmEdge-go/wasmedge""



verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.

vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.

verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.

verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.

```



### Logging Settings



The `wasmedge.SetLogErrorLevel()` and `wasmedge.SetLogDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



Developers can also use the `wasmedge.SetLogOff()` API to disable all logging. (`v0.11.2` or upper only)



### Value Types



In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.



1. Number types: `i32`, `i64`, `f32`, and `f64`



   - Convert the `uint32` and `int32` to `i32` automatically when passing a value into WASM.

   - Convert the `uint64` and `int64` to `i64` automatically when passing a value into WASM.

   - Convert the `uint` and `int` to `i32` automatically when passing a value into WASM in 32-bit system.

   - Convert the `uint` and `int` to `i64` automatically when passing a value into WASM in 64-bit system.

   - Convert the `float32` to `f32` automatically when passing a value into WASM.

   - Convert the `float64` to `f64` automatically when passing a value into WASM.

   - Convert the `i32` from WASM to `int32` when getting a result.

   - Convert the `i64` from WASM to `int64` when getting a result.

   - Convert the `f32` from WASM to `float32` when getting a result.

   - Convert the `f64` from WASM to `float64` when getting a result.



2. Number type: `v128` for the `SIMD` proposal



   Developers should use the `wasmedge.NewV128()` to generate a `v128` value, and use the `wasmedge.GetV128()` to get the value.



   ```go

   val := wasmedge.NewV128(uint64(1234), uint64(5678))

   high, low := val.GetVal()

   // `high` will be uint64(1234), `low` will be uint64(5678)

   ```



3. Reference types: `FuncRef` and `ExternRef` for the `Reference-Types` proposal



   ```go

   var funccxt *wasmedge.Function = ... // Create or get function object.

   funcref := wasmedge.NewFuncRef(funccxt)

   // Create a `FuncRef` with the function object.



   num := 1234

   // `num` is a `int`.

   externref := wasmedge.NewExternRef(&num)

   // Create an `ExternRef` which reference to the `num`.

   num = 5678

   // Modify the `num` to 5678.

   numref := externref.GetRef().(*int)

   // Get the original reference from the `ExternRef`.

   fmt.Println(*numref)

   // Will print `5678`.

   numref.Release()

   // Should call the `Release` method.

   ```



### Results



The `Result` object specifies the execution status. Developers can use the `Error()` function to get the error message.



```go

// Assume that `vm` is a `wasmedge.VM` object.

res, err = vm.Execute(...) // Ignore the detail of parameters.

// Assume that `res, err` are the return values for executing a function with `vm`.

if err != nil {

  fmt.Println(""Error message:"", err.Error())

  category := err.GetErrorCategory()

  // The `category` will be `wasmedge.ErrCategory_WASM`.

}



userdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)

// Generate the user-defined error with code.

code := userdef_err.GetCode()

// The `Code` will be 123456.

```



### Contexts And Their Life Cycles



The objects, such as `VM`, `Store`, and `Function`, etc., are composed of `Context`s in the WasmEdge shared library. All of the contexts can be created by calling the corresponding `New` APIs, developers should also call the corresponding `Release` functions of the contexts to release the resources. Noticed that it's not necessary to call the `Release` functions for the contexts which are retrieved from other contexts but not created from the `New` APIs.



```go

// Create a Configure.

conf := wasmedge.NewConfigure()

// Release the `conf` immediately.

conf.Release()

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `Limit` struct presents the minimum and maximum value data structure.



   ```go

   lim1 := wasmedge.NewLimit(12)

   fmt.Println(lim1.HasMax())

   // Will print `false`.

   fmt.Println(lim1.GetMin())

   // Will print `12`.



   lim2 := wasmedge.NewLimitWithMax(15, 50)

   fmt.Println(lim2.HasMax())

   // Will print `true`.

   fmt.Println(lim2.GetMin())

   // Will print `15`.

   fmt.Println(lim2.GetMax())

   // Will print `50`.

   ```



   For the thread proposal, the `Limit` struct also supports the shared memory description.



   ```go

   lim3 := wasmedge.NewLimitShared(20)

   fmt.Println(lim3.HasMax())

   // Will print `false`.

   fmt.Println(lim3.IsShared())

   // Will print `true`.

   fmt.Println(lim3.GetMin())

   // Will print `20`.



   lim4 := wasmedge.NewLimitSharedWithMax(30, 40)

   fmt.Println(lim4.HasMax())

   // Will print `true`.

   fmt.Println(lim4.IsShared())

   // Will print `true`.

   fmt.Println(lim4.GetMin())

   // Will print `30`.

   fmt.Println(lim4.GetMax())

   // Will print `40`.

   ```



2. Function type context



   The `FunctionType` is an object holds the function type context and used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `FunctionType` APIs to get the parameter or return value types information.



   ```go

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{

       wasmedge.ValType_ExternRef,

       wasmedge.ValType_I32,

       wasmedge.ValType_I64,

     }, []wasmedge.ValType{

       wasmedge.ValType_F32,

       wasmedge.ValType_F64,

     })



   plen := functype.GetParametersLength()

   // `plen` will be 3.

   rlen := functype.GetReturnsLength()

   // `rlen` will be 2.

   plist := functype.GetParameters()

   // `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.

   rlist := functype.GetReturns()

   // `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.



   functype.Release()

   ```



3. Table type context



   The `TableType` is an object holds the table type context and used for `Table` instance creation or getting information from `Table` instances.



   ```go

   lim := wasmedge.NewLimit(12)

   tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)



   rtype := tabtype.GetRefType()

   // `rtype` will be `wasmedge.RefType_ExternRef`.

   getlim := tabtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   tabtype.Release()

   ```



4. Memory type context



   The `MemoryType` is an object holds the memory type context and used for `Memory` instance creation or getting information from `Memory` instances.



   ```go

   lim := wasmedge.NewLimit(1)

   memtype := wasmedge.NewMemoryType(lim)



   getlim := memtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   memtype.Release()

   ```



5. Global type context



   The `GlobalType` is an object holds the global type context and used for `Global` instance creation or getting information from `Global` instances.



   ```go

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)



   vtype := globtype.GetValType()

   // `vtype` will be `wasmedge.ValType_F64`.

   vmut := globtype.GetMutability()

   // `vmut` will be `wasmedge.ValMut_Var`.



   globtype.Release()

   ```



6. Import type context



   The `ImportType` is an object holds the import type context and used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `ImportType` object. The details about querying `ImportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   imptypelist := ast.ListImports()

   // Assume that `imptypelist` is an array listed from the `ast` for the imports.



   for i, imptype := range imptypelist {

     exttype := imptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     modname := imptype.GetModuleName()

     extname := imptype.GetExternalName()

     // Get the module name and external name of the imports.



     extval := imptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



7. Export type context



   The `ExportType` is an object holds the export type context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `ExportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   exptypelist := ast.ListExports()

   // Assume that `exptypelist` is an array listed from the `ast` for the exports.



   for i, exptype := range exptypelist {

     exttype := exptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     extname := exptype.GetExternalName()

     // Get the external name of the exports.



     extval := exptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `wasmedge.Async` object. Developers own the object and should call the `(*Async).Release()` API to release it.



1. Get the execution result of the asynchronous execution



   Developers can use the `(*Async).GetResult()` API to block and wait for getting the return values. This function will block and wait for the execution. If the execution has finished, this function will return immediately. If the execution failed, this function will return an error.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution and get the return values.

   res, err := async.GetResult()

   async.Release()

   ```



2. Wait for the asynchronous execution with timeout settings



   Besides waiting until the end of execution, developers can set the timeout to wait for.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution with the timeout(ms).

   isend := async.WaitFor(1000)

   if isend {

     res, err := async.GetResult()

     // ...

   } else {

     async.Cancel()

     _, err := async.GetResult()

     // The error message in `err` will be ""execution interrupted"".

   }

   async.Release()

   ```



### Configurations



The configuration object, `wasmedge.Configure`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` object to create other runtime objects.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` object.



   ```go

   const (

     IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)

     NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)

     SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)

     MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)

     BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)

     REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)

     SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)

     TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)

     ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)

     MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)

     EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)

     EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)

     THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)

     FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)

   )

   ```



   Developers can add or remove the proposals into the `Configure` object.



   ```go

   // By default, the following proposals have turned on initially:

   // * IMPORT_EXPORT_MUT_GLOBALS

   // * NON_TRAP_FLOAT_TO_INT_CONVERSIONS

   // * SIGN_EXTENSION_OPERATORS

   // * MULTI_VALUE

   // * BULK_MEMORY_OPERATIONS

   // * REFERENCE_TYPES

   // * SIMD

   // For the current WasmEdge version, the following proposals are supported:

   // * TAIL_CALL

   // * MULTI_MEMORIES

   // * THREADS

   // * EXTENDED_CONST

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)

   conf.AddConfig(wasmedge.SIMD)

   conf.RemoveConfig(wasmedge.REFERENCE_TYPES)

   is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)

   // The `is_bulkmem` will be `true`.

   conf.Release()

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` or `wasmedge_process` supports and only effective in `VM` objects.



   ```go

   const (

     WASI                        = HostRegistration(C.WasmEdge_HostRegistration_Wasi)

     WasmEdge_PROCESS            = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)

     WasiNN                      = HostRegistration(C.WasmEdge_HostRegistration_WasiNN)

     WasiCrypto_Common           = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Common)

     WasiCrypto_AsymmetricCommon = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon)

     WasiCrypto_Kx               = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Kx)

     WasiCrypto_Signatures       = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Signatures)

     WasiCrypto_Symmetric        = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Symmetric)

   )

   ```



   The details will be introduced in the [preregistrations of VM context](#preregistrations).



   ```go

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.WASI)

   conf.AddConfig(wasmedge.WASI)

   conf.Release()

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` objects.



   ```go

   conf := wasmedge.NewConfigure()



   pagesize := conf.GetMaxMemoryPage()

   // By default, the maximum memory page size in each memory instances is 65536.

   conf.SetMaxMemoryPage(1234)

   pagesize = conf.GetMaxMemoryPage()

   // `pagesize` will be 1234.



   conf.Release()

   ```



4. Forcibly interpreter mode (`v0.11.2` or upper only)



   If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration.



   ```go

   conf := wasmedge.NewConfigure()



   is_forceinterp := conf.IsForceInterpreter()

   // By default, the `is_forceinterp` will be `false`.

   conf.SetForceInterpreter(true)

   is_forceinterp = conf.IsForceInterpreter()

   /* The `is_forceinterp` will be `true`. */



   conf.Release()

   ```



5. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```go

   const (

     // Disable as many optimizations as possible.

     CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

     // Optimize quickly without destroying debuggability.

     CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

     // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

     CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

     // Optimize for fast execution as much as possible.

     CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

     // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

     CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

     // Optimize for small code size as much as possible.

     CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

   )



   const (

     // Native dynamic library format.

     CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

     // WebAssembly with AOT compiled codes in custom section.

     CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

   )

   ```



   These configurations are only effective in `Compiler` contexts.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the optimization level is O3.

   conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)

   // By default, the output format is universal WASM.

   conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)

   // By default, the dump IR is `false`.

   conf.SetCompilerDumpIR(true)

   // By default, the generic binary is `false`.

   conf.SetCompilerGenericBinary(true)



   conf.Release()

   ```



6. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` objects.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsInstructionCounting(true)

   // By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsTimeMeasuring(true)

   // By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsCostMeasuring(true)



   conf.Release()

   ```



### Statistics



The statistics object, `wasmedge.Statistics`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` object from the `VM` object, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```go

   stat := wasmedge.NewStatistics()

   // ... After running the WASM functions with the `Statistics` object



   count := stat.GetInstrCount()

   ips := stat.GetInstrPerSecond()

   stat.Release()

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` object. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   stat := wasmedge.NewStatistics()



   costtable := []uint64{

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0,

   }

   // Developers can set the costs of each instruction. The value not covered will be 0.



   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   stat.SetCostTable()

   stat.SetCostLimit(5000000)



   // ... After running the WASM functions with the `Statistics` object

   cost := stat.GetTotalCost()

   stat.Release()

   ```



### Tools Driver



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools in WasmEdge-Go. The API arguments are the same as the command line arguments of the CLI tools.



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeCLI(os.Args)

}

```



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)

}

```



## WasmEdge VM



In this partition, we will introduce the functions of `wasmedge.VM` object and show examples of executing WASM functions.



### WASM Execution Example With VM Object



The following shows the example of running the WASM for getting the Fibonacci. This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current `wasmedge_test` directory, and create and edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create the configure context and add the WASI support.

     // This step is not necessary unless you need WASI support.

     conf := wasmedge.NewConfigure(wasmedge.WASI)

     // Create VM with the configure.

     vm := wasmedge.NewVMWithConfig(conf)



     res, err := vm.RunWasmFile(""fibonacci.wasm"", ""fib"", uint32(21))

     if err == nil {

       fmt.Println(""Get fibonacci[21]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

     conf.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   Get fibonacci[21]: 17711

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` object APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create VM.

     vm := wasmedge.NewVM()

     var err error

     var res []interface{}



     // Step 1: Load WASM file.

     err = vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     // Developers can load, validate, and instantiate another WASM module

     // to replace the instantiated one. In this case, the old module will

     // be cleared, but the registered modules are still kept.

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Execute WASM functions. Parameters: (funcname, args...)

     res, err = vm.Execute(""fib"", uint32(25))

     // Developers can execute functions repeatedly after instantiation.

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



   The following graph explains the status of the `VM` object.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered,

                   ExecuteBindgen, ExecuteBindgenRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or import objects in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation APIs accepts the `Configure` object and the `Store` object. Noticed that if the `VM` created with the outside `Store` object, the `VM` will execute WASM on that `Store` object. If the `Store` object is set into multiple `VM` objects, it may causes data conflict when in execution. The details of the `Store` object will be introduced in [Store](#store).



```go

conf := wasmedge.NewConfigure()

store := wasmedge.NewStore()



// Create a VM with default configure and store.

vm := wasmedge.NewVM()

vm.Release()



// Create a VM with the specified configure and default store.

vm = wasmedge.NewVMWithConfig(conf)

vm.Release()



// Create a VM with the default configure and specified store.

vm = wasmedge.NewVMWithStore(store)

vm.Release()



// Create a VM with the specified configure and store.

vm = wasmedge.NewVMWithConfigAndStore(conf, store)

vm.Release()



conf.Release()

store.Release()

```



### Preregistrations



WasmEdge provides the following built-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` object.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WASI)

   // Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   wasimodule := vm.GetImportModule(wasmedge.WASI)

   // Initialize the WASI.

   wasimodule.InitWasi(/* ... ignored */)



   vm.Release()

   ```



   And also can create the WASI import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. [WasmEdge_Process](https://crates.io/crates/wasmedge_process_interface)



   This pre-registration is for the process interface for WasmEdge on `Rust` sources. After turning on this pre-registration, the VM will support the `wasmedge_process` plugin.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   procmodule := vm.GetImportModule(wasmedge.WasmEdge_PROCESS)

   // Initialize the WasmEdge_Process.

   procmodule.InitWasmEdgeProcess(/* ... ignored */)



   vm.Release()

   ```



   And also can create the WasmEdge_Process import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



3. [WASI-NN proposal](https://github.com/WebAssembly/wasi-nn)



   Developers can turn on the WASI-NN proposal support for VM in the `Configure` object.



   > Note: Please check that the [dependencies and prerequests](../../../start/install.md#wasi-nn-plug-in) are satisfied.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WasiNN)

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   nnmodule := vm.GetImportModule(wasmedge.WasiNN)

   vm.Release()

   ```



   And also can create the WASI-NN module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



4. [WASI-Crypto proposal](https://github.com/WebAssembly/wasi-crypto)



   Developers can turn on the WASI-Crypto proposal support for VM in the `Configure` object.



   > Note: Please check that the [dependencies and prerequests](../../../start/install.md#wasi-crypto-plug-in) are satisfied.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WasiCrypto_Common, wasmedge.WasiCrypto_AsymmetricCommon, wasmedge.WasiCrypto_Kx, wasmedge.WasiCrypto_Signatures, wasmedge.WasiCrypto_Symmetric)

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   nnmodule := vm.GetImportModule(wasmedge.WasiCrypto_Common)

   vm.Release()

   ```



   And also can create the WASI-Crypto module instance from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge-go, the host functions are composed into host modules as `Module` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` object.



```go

vm := wasmedge.NewVM()

// You can also create and register the WASI host modules by this API.

wasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)



res := vm.RegisterModule(wasiobj)

// The result status should be checked.



vm.Release()

// The created import objects should be released.

wasiobj.Release()

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory. Then create and edit the Go file `main.go` as following:



   ```go

   package main



   import ""github.com/second-state/WasmEdge-go/wasmedge""



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var err error

     err = vm.RegisterWasmFile(""module_name"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     // The result status should be checked. The error will occur if the

     // WASM module instantiation failed or the module name conflicts.



     vm.Release()

   }

   ```



2. Execute the functions in registered WASM modules



   Edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var res []interface{}

     var err error

     // Register the WASM module from file into VM with the module name ""mod"".

     err = vm.RegisterWasmFile(""mod"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     if err != nil {

       fmt.Println(""WASM registration failed:"", err.Error())

       return

     }

     // The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

     // name ""mod"". As the same as host functions, other modules can import the

     // function `""mod"" ""fib""`.



     // Execute WASM functions in registered modules.

     // Unlike the execution of functions, the registered functions can be

     // invoked without `(*VM).Instantiate` because the WASM module was

     // instantiated when registering.

     // Developers can also invoke the host functions directly with this API.

     res, err = vm.ExecuteRegistered(""mod"", ""fib"", int32(25))

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.

     async := vm.AsyncRunWasmFile(""fibonacci.wasm"", ""fib"", uint32(20))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     var err error

     var res []interface{}



     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,

     // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.

     async := vm.AsyncExecute(""fib"", uint32(25))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` object supplies the APIs to retrieve the instances.



1. Store



   If the `VM` object is created without assigning a `Store` object, the `VM` context will allocate and own a `Store`.



   ```go

   vm := wasmedge.NewVM()

   store := vm.GetStore()

   // The object should __NOT__ be deleted by calling `(*Store).Release`.

   vm.Release()

   ```



   Developers can also create the `VM` object with a `Store` object. In this case, developers should guarantee that the `Store` object cannot be released before the `VM` object. Please refer to the [Store Objects](#store) for the details about the `Store` APIs.



   ```go

   store := wasmedge.NewStore()

   vm := wasmedge.NewVMWithStore(store)



   storemock := vm.GetStore()

   // The internal store context of the `store` and the `storemock` are the same.



   vm.Release()

   store.Release()

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `(*VM).Execute` function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // List the exported functions for the names and function types.

     funcnames, functypes := vm.GetFunctionList()

     for _, fname := range funcnames {

       fmt.Println(""Exported function name:"", fname)

     }

     for _, ftype := range functypes {

       // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.

       // Developers should __NOT__ call the `ftype.Release()`.

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   Exported function name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` object from the `VM` object and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` object provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   functype := vm.GetFunctionType(""fib"")

   // Developers can get the function types of functions in the registered modules via the

   // `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.

   // If the function is not found, these APIs will return `nil`.

   // Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` object. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `(*VM).GetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   mod := vm.GetActiveModule()

   // If there's no WASM module instantiated, this API will return `nil`.

   // Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.

   ```



5. Get the components



   The `VM` object is composed by the `Loader`, `Validator`, and `Executor` objects. For the developers who want to use these objects without creating another instances, these APIs can help developers to get them from the `VM` object. The get objects are owned by the `VM` object, and developers should not call their release functions.



   ```go

   loader := vm.GetLoader()

   // Developers should __NOT__ call the `(*Loader).Release` function of the returned object.

   validator := vm.GetValidator()

   // Developers should __NOT__ call the `(*Validator).Release` function of the returned object.

   executor := vm.GetExecutor()

   // Developers should __NOT__ call the `(*Executor).Release` function of the returned object.

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` object](#wasmedge-vm) rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` objects.



Assume that a new Go project is created as following:



```bash

mkdir wasmedge_test && cd wasmedge_test

go mod init wasmedge_test

```



Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



```go

package main



import (

  ""fmt""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  // Set the logging level to debug to print the statistics info.

  wasmedge.SetLogDebugLevel()

  // Create the configure object. This is not necessary if developers use the default configuration.

  conf := wasmedge.NewConfigure()

  // Turn on the runtime instruction counting and time measuring.

  conf.SetStatisticsInstructionCounting(true)

  conf.SetStatisticsTimeMeasuring(true)

  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.

  stat := wasmedge.NewStatistics()

  // Create the store object. The store object is the WASM runtime structure core.

  store := wasmedge.NewStore()



  var err error

  var res []interface{}

  var ast *wasmedge.AST

  var mod *wasmedge.Module



  // Create the loader object.

  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

  loader := wasmedge.NewLoaderWithConfig(conf)

  // Create the validator object.

  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

  validator := wasmedge.NewValidatorWithConfig(conf)

  // Create the executor object.

  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.

  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)



  // Load the WASM file or the compiled-WASM file and convert into the AST module object.

  ast, err = loader.LoadFile(""fibonacci.wasm"")

  if err != nil {

    fmt.Println(""Load WASM from file FAILED:"", err.Error())

    return

  }

  // Validate the WASM module.

  err = validator.Validate(ast)

  if err != nil {

    fmt.Println(""Validation FAILED:"", err.Error())

    return

  }

  // Instantiate the WASM module and get the output module instance.

  mod, err = executor.Instantiate(store, ast)

  if err != nil {

    fmt.Println(""Instantiation FAILED:"", err.Error())

    return

  }



  // Try to list the exported functions of the instantiated WASM module.

  funcnames := mod.ListFunction()

  for _, fname := range funcnames {

    fmt.Println(""Exported function name:"", fname)

  }



  // Invoke the WASM function.

  funcinst := mod.FindFunction(""fib"")

  if funcinst == nil {

    fmt.Println(""Run FAILED: Function name `fib` not found"")

    return

  }

  res, err = executor.Invoke(store, funcinst, int32(30))

  if err == nil {

    fmt.Println(""Get fibonacci[30]:"", res[0].(int32))

  } else {

    fmt.Println(""Run FAILED:"", err.Error())

  }



  // Resources deallocations.

  conf.Release()

  stat.Release()

  ast.Release()

  loader.Release()

  validator.Release()

  executor.Release()

  store.Release()

  mod.Release()

}

```



Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)



```bash

$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

$ go build

$ ./wasmedge_test

Exported function name: fib

[2021-11-24 18:53:01.451] [debug]  Execution succeeded.

[2021-11-24 18:53:01.452] [debug]

 ====================  Statistics  ====================

 Total execution time: 556372295 ns

 Wasm instructions execution time: 556372295 ns

 Host functions execution time: 0 ns

 Executed wasm instructions count: 28271634

 Gas costs: 0

 Instructions per second: 50814237

Get fibonacci[30]: 1346269

```



### Loader



The `Loader` object loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```go

var buf []byte

// ... Read the WASM code to the `buf`.



// Developers can adjust settings in the configure object.

conf := wasmedge.NewConfigure()

// Create the loader object.

// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

loader := wasmedge.NewLoaderWithConfig(conf)

conf.Release()



// Load WASM or compiled-WASM from the file.

ast, err := loader.LoadFile(""fibonacci.wasm"")

if err != nil {

  fmt.Println(""Load WASM from file FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



// Load WASM or compiled-WASM from the buffer

ast, err = loader.LoadBuffer(buf)

if err != nil {

  fmt.Println(""Load WASM from buffer FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



loader.Release()

```



### Validator



The `Validator` object can validate the WASM module. Every WASM module should be validated before instantiation.



```go

// ...

// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.

// Assume that the `conf` is the `*wasmedge.Configure` object.



// Create the validator context.

// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

validator := wasmedge.NewValidatorWithConfig(conf)



err := validator.Validate(ast)

if err != nil {

  fmt.Println(""Validation FAILED:"", err.Error())

}



validator.Release()

```



### Executor



The `Executor` object is the executor for both WASM and compiled-WASM. This object should work base on the `Store` object. For the details of the `Store` object, please refer to the [next chapter](#store).



1. Instantiate and register an `AST` object as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` objects, developers can instantiate and register an `AST` objects into the `Store` context as a named `Module` instance by the `Executor` APIs. After the registration, the result `Module` instance is exported with the given module name and can be linked when instantiating another module. For the details about the `Module` instances APIs, please refer to the [Instances](#instances).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Register the loaded WASM `ast` into store with the export module name ""mod"".

   mod, res := executor.Register(store, ast, ""mod"")

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST` object, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Create a module instance for host functions.

   mod := wasmedge.NewModule(""mod"")

   // ...

   // Create and add the host functions, tables, memories, and globals into the module instance.

   // ...



   // Register the module instance into store with the exported module name.

   // The export module name is in the module instance already.

   res := executor.RegisterImport(store, mod)

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



3. Instantiate an `AST` object to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` object for linking.



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Instantiate the WASM module.

   mod, err := executor.Instantiate(stpre, ast)

   if err != nil {

     fmt.Println(""WASM instantiation FAILED:"", err.Error())

     return

   }



   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `(*Executor).Invoke` API.



### AST Module



The `AST` object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST` object.



```go

ast := ...

// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.



// List the imports.

imports := ast.ListImports()

for _, import := range imports {

  fmt.Println(""Import:"", import.GetModuleName(), import.GetExternalName())

}



// List the exports.

exports := ast.ListExports()

for _, export := range exports {

  fmt.Println(""Export:"", export.GetExternalName())

}



ast.Release()

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` object in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context.



```go

store := wasmedge.NewStore()



// ...

// Register a WASM module via the executor object.

// ...



// Try to list the registered WASM modules.

modnames := store.ListModule()

// ...



// Find named module by name.

mod := store.FindModule(""module"")

// If the module with name not found, the `mod` will be `nil`.



store.Release()

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST` object, developers will get a `Module` instance as the result, and have the responsibility to release it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```go

   // ...

   // Instantiate a WASM module via the executor object and get the `mod` as the output module instance.

   // ...



   // List the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcnames := mod.ListFunction()



   // Try to find the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcinst := mod.FindFunction(""fib"")

   // `funcinst` will be `nil` if the function not found.

   // The returned instance is owned by the module instance and should __NOT__ be released.

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` objects for host functions and add them into an `Module` instance for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` objects through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```go

   funcobj := ...

   // `funcobj` is the `*wasmedge.Function` retrieved from the module instance.

   functype := funcobj.GetFunctionType()

   // The `funcobj` retrieved from the module instance should __NOT__ be released.

   // The `functype` retrieved from the `funcobj` should __NOT__ be released.



   // For the function object creation, please refer to the `Host Function` guide.

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Table` objects supply APIs to control the data in table instances.



   ```go

   lim := wasmedge.NewLimitWithMax(10, 20)

   // Create the table type with limit and the `FuncRef` element type.

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)

   // Create the table instance with table type.

   tabinst := wasmedge.NewTable(tabtype)

   // Delete the table type.

   tabtype.Release()



   gottabtype := tabinst.GetTableType()

   // The `gottabtype` got from table instance is owned by the `tabinst`

   // and should __NOT__ be released.

   reftype := gottabtype.GetRefType()

   // The `reftype` will be `wasmedge.RefType_FuncRef`.



   var gotdata interface{}

   data := wasmedge.NewFuncRef(5)

   err := tabinst.SetData(data, 3)

   // Set the function index 5 to the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   err = tabinst.SetData(data, 13)



   gotdata, err = tabinst.GetData(3)

   // Get the FuncRef value of the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   gotdata, err = tabinst.GetData(13)



   tabsize := tabinst.GetSize()

   // `tabsize` will be 10.

   err = tabinst.Grow(6)

   // Grow the table size of 6, the table size will be 16.



   // The following line will get an ""out of bounds table access"" error

   // because the size (16 + 6) will reach the table limit (20):

   //   err = tabinst.Grow(6)



   tabinst.Release()

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Memory` objects supply APIs to control the data in memory instances.



   ```go

   lim := wasmedge.NewLimitWithMax(1, 5)

   // Create the memory type with limit. The memory page size is 64KiB.

   memtype := wasmedge.NewMemoryType(lim)

   // Create the memory instance with memory type.

   meminst := wasmedge.NewMemory(memtype)

   // Delete the memory type.

   memtype.Release()



   data := []byte(""A quick brown fox jumps over the lazy dog"")

   err := meminst.SetData(data, 0x1000, 10)

   // Set the data[0:9] to the memory[4096:4105].



   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   err = meminst.SetData(data, 0xFFFF, 10)



   var gotdata []byte

   gotdata, err = meminst.GetData(0x1000, 10)

   // Get the memory[4096:4105]. The `gotdata` will be `[]byte(""A quick br"").

   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   gotdata, err = meminst.Getdata(0xFFFF, 10)



   pagesize := meminst.GetPageSize()

   // `pagesize` will be 1.

   err = meminst.GrowPage(2)

   // Grow the page size of 2, the page size of the memory instance will be 3.



   // The following line will get an ""out of bounds memory access"" error

   // because the size (3 + 3) will reach the memory limit (5):

   //   err = meminst.GetPageSize(3)



   meminst.Release()

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Global` objects supply APIs to control the value in global instances.



   ```go

   // Create the global type with value type and mutation.

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)

   // Create the global instance with value and global type.

   globinst := wasmedge.NewGlobal(globtype, uint64(1000))

   // Delete the global type.

   globtype.Release()



   gotglobtype := globinst.GetGlobalType()

   // The `gotglobtype` got from global instance is owned by the `globinst`

   // and should __NOT__ be released.

   valtype := gotglobtype.GetValType()

   // The `valtype` will be `wasmedge.ValType_I64`.

   valmut := gotglobtype.GetMutability()

   // The `valmut` will be `wasmedge.ValMut_Var`.



   globinst.SetValue(uint64(888))

   // Set the value u64(888) to the global.

   // This function will do nothing if the value type mismatched or the

   // global mutability is `wasmedge.ValMut_Const`.

   gotval := globinst.GetValue()

   // The `gotbal` will be `interface{}` which the type is `uint64` and

   // the value is 888.



   globinst.Release()

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define Go functions with the following function signature as the host function body:



   ```go

   type hostFunctionSignature func(

       data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```go

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }

   ```



   Then developers can create `Function` object with the host function body and function type:



   ```go

   // Create a function type: {i32, i32} -> {i32}.

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )



   // Create a function context with the function type and host function body.

   // The third parameter is the pointer to the additional data.

   // Developers should guarantee the life cycle of the data, and it can be

   // `nil` if the external data is not needed.

   // The last parameter can be 0 if developers do not need the cost measuring.

   func_add := wasmedge.NewFunction(functype, host_add, nil, 0)



   // If the function object is not added into an module instance object, it should be released.

   func_add.Release()

   functype.Release()

   ```



2. Calling frame object



   The `wasmedge.CallingFrame` is the object to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



   ```go

   import (

     ""encoding/binary""

     ""fmt""

   )



   // Host function body definition.

   func LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // Function type: {i32} -> {}

     offset := params[0].(int32)



     // Get the 0th memory instance of the module of the top frame on the stack.

     mem := callframe.GetMemoryByIndex(0)



     data, err := mem.GetData(uint(offset), 4)

     if err != nil {

       return nil, err

     }

     fmt.Println(""u32 at memory[{}]: {}"", offset, binary.LittleEndian.Uint32(data))

     return nil, wasmedge.Result_Success

   }

   ```



   Besides using the `(*CallingFrame).GetMemoryByIndex()` API to get the memory instance by index in the module instance, developers can use the `(*CallingFrame).GetModule()` to get the module instance directly. Therefore, developers can retrieve the exported contexts by the `wasmedge.Module` APIs. And also, developers can use the `(*CallingFrame).GetExecutor()` API to get the currently used executor context.



3. User-defined error code of the host functions



   In host functions, WasmEdge-Go provides `wasmedge.Result_Success` to return success, `wasmedge.Result_Terminate` to terminate the WASM execution, and `wasmedge.Result_Fail` to return fail. WasmEdge-Go also provides the usage of returning the user-specified codes. Developers can use the `wasmedge.NewResult()` API to generate the `wasmedge.Result` struct with error code, and use the `(*result).GetCode()` API to get the error code.



   > Notice: The error code only supports 24-bit integer (0 ~ 16777216 in `uint32`). The values larger than 24-bit will be truncated.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32)))

     (import ""extern"" ""trap"" (func $f-trap (type $t0)))

     (func (export ""trap"") (param i32)

       local.get 0

       call $f-trap)

   )

   ```



   And the `main.go` is as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x05, 0x01,

       /* function type {i32} -> {} */

       0x60, 0x01, 0x7F, 0x00,

       /* Import section */

       0x02, 0x0F, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""trap"" */

       0x04, 0x74, 0x72, 0x61, 0x70,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x08, 0x01,

       /* export name: ""trap"" */

       0x04, 0x74, 0x72, 0x61, 0x70,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x08, 0x01,

       /* code body */

       0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,

     }



     // Create the module instance with the module name ""extern"".

     impmod := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})

     hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)

     functype.Release()

     impmod.AddFunction(""trap"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(impmod)



     _, err := vm.RunWasmBuffer(wasmbuf, ""trap"", uint32(5566))

     if err != nil {

       fmt.Println(""Get the error code:"", err.GetCode())

     }



     impmod.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   [2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be

   [2022-08-26 15:06:40.384] [error]     When executing function name: ""trap""

   Get the error code: 5566

   ```



4. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```go

   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   // Create a module instance with the module name ""module"".

   mod := wasmedge.NewModule(""module"")



   // Create and add a function instance into the module instance with export name ""add"".

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )

   hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

   functype.Release()

   mod.AddFunction(""add"", hostfunc)



   // Create and add a table instance into the module instance with export name ""table"".

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))

   hosttab := wasmedge.NewTable(tabtype)

   tabtype.Release()

   mod.AddTable(""table"", hosttab)



   // Create and add a memory instance into the module instance with export name ""memory"".

   memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))

   hostmem := wasmedge.NewMemory(memtype)

   memtype.Release()

   mod.AddMemory(""memory"", hostmem)



   // Create and add a global instance into the module instance with export name ""global"".

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)

   hostglob := wasmedge.NewGlobal(globtype, uint32(666))

   globtype.Release()

   mod.AddGlobal(""global"", hostglob)



   // The module instances should be released.

   // Developers should __NOT__ release the instances added into the module instance objects.

   mod.Release()

   ```



5. Specified module instance



   `wasmedge.NewWasiModule()` API can create and initialize the `WASI` module instance.



   `wasmedge.NewWasiNNModule()` API can create and initialize the `wasi_ephemeral_nn` module instance for `WASI-NN` plugin.



   `wasmedge.NewWasiCryptoCommonModule()` API can create and initialize the `wasi_ephemeral_crypto_common` module instance for `WASI-Crypto` plugin.



   `wasmedge.NewWasiCryptoAsymmetricCommonModule()` API can create and initialize the `wasi_ephemeral_crypto_asymmetric_common` module instance for `WASI-Crypto` plugin.



   `wasmedge.NewWasiCryptoKxModule()` API can create and initialize the `wasi_ephemeral_crypto_kx` module instance for `WASI-Crypto` plugin.



   `wasmedge.NewWasiCryptoSignaturesModule()` API can create and initialize the `wasi_ephemeral_crypto_signatures` module instance for `WASI-Crypto` plugin.



   `wasmedge.NewWasiCryptoSymmetricModule()` API can create and initialize the `wasi_ephemeral_crypto_symmetric` module instance for `WASI-Crypto` plugin.



   `wasmedge.NewWasmEdgeProcessModule()` API can create and initialize the `wasmedge_process` module instance for `wasmedge_process` plugin.



   Developers can create these module instance objects and register them into the `Store` or `VM` objects rather than adjust the settings in the `Configure` objects.



   > Note: For the `WASI-NN` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-nn-plug-in) are satisfied. Note: For the `WASI-Crypto` plugin, please check that the [dependencies and prerequests](../../../start/install.md#wasi-crypto-plug-in) are satisfied. And the 5 modules are recommended to all be created and registered together.



   ```go

   wasiobj := wasmedge.NewWasiModule(

     os.Args[1:],     // The args

     os.Environ(),    // The envs

     []string{"".:.""}, // The mapping preopens

   )

   procobj := wasmedge.NewWasmEdgeProcessModule(

     []string{""ls"", ""echo""}, // The allowed commands

     false,                  // Not to allow all commands

   )



   // Register the WASI and WasmEdge_Process into the VM object.

   vm := wasmedge.NewVM()

   vm.RegisterImport(wasiobj)

   vm.RegisterImport(procobj)



   // ... Execute some WASM functions.



   // Get the WASI exit code.

   exitcode := wasiobj.WasiGetExitCode()

   // The `exitcode` will be 0 if the WASI function ""_start"" execution has no error.

   // Otherwise, it will return with the related exit code.



   vm.Release()

   // The import objects should be deleted.

   wasiobj.Release()

   procobj.Release()

   ```



6. Example



   Assume that there is a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // Create the module instance with the module name ""extern"".

     impmod := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

     functype.Release()

     impmod.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(impmod)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }



     impmod.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   ```



7. Host Data Example



   Developers can set a external data object to the `Function` object, and access to the object in the function body. Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Also set the result to the data.

     *data.(*int32) = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // The additional data to set into the host function.

     var data int32 = 0



     // Create the module instance with the module name ""extern"".

     modinst := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)

     functype.Release()

     modinst.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(modinst)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     fmt.Println(""Data value:"", data)



     modinst.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.2

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   Data value: 6912

   ```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options in Go. WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) provide a tool for compiling a WASM file.



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```go

const (

  // Disable as many optimizations as possible.

  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

  // Optimize quickly without destroying debuggability.

  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

  // Optimize for fast execution as much as possible.

  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

  // Optimize for small code size as much as possible.

  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

)



const (

  // Native dynamic library format.

  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

  // WebAssembly with AOT compiled codes in custom section.

  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

)

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/go/reference/0.12.x.md
------


---

sidebar_position: 3

---



# Go API v0.12.1 Documentation



The following are the guides to working with the WasmEdge-Go SDK.



**Developers can refer to [here to upgrade to v0.13.0](upgrade_to_0.13.0).**



## Table of Contents



- [Getting Started](#getting-started)

  - [WasmEdge Installation](#wasmedge-installation)

  - [Get WasmEdge-go](#get-wasmedge-go)

  - [WasmEdge-go Extensions](#wasmedge-go-extensions)

  - [Example repository](#example-repository)

- [WasmEdge-go Basics](#wasmedge-go-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Results](#results)

  - [Contexts And Their Life Cycles](#contexts-and-their-life-cycles)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

  - [Tools driver](#tools-driver)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Object](#wasm-execution-example-with-vm-object)

  - [VM Creations](#vm-creations)

  - [Built-in Host Modules and Plug-in Preregistrations](#built-in-host-modules-and-plug-in-preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

  - [Plug-ins](#plug-ins)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## Getting Started



The WasmEdge-go requires golang version >= 1.16. Please check your golang version before installation. Developers can [download golang here](https://golang.org/dl/).



```bash

$ go version

go version go1.16.5 linux/amd64

```



### WasmEdge Installation



Developers must [install the WasmEdge shared library](../../../start/install.md#install) with the same `WasmEdge-go` release or pre-release version.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.12.1

```



For the developers need the `TensorFlow` or `Image` extension for `WasmEdge-go`, please install the `WasmEdge` with extensions:



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.12.1

```



Noticed that the `TensorFlow` and `Image` extensions are only for the `Linux` platforms. After installation, developers can use the `source` command to update the include and linking searching path.



### Get WasmEdge-go



After the WasmEdge installation, developers can get the `WasmEdge-go` package and build it in your Go project directory.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

go build

```



<!-- prettier-ignore -->

:::note

The WasmEdge-Go version number should match the installed WasmEdge version.

:::



### WasmEdge-go Extensions



By default, the `WasmEdge-go` only turns on the basic runtime.



`WasmEdge-go` has the following extensions (on the Linux platforms only):



- Tensorflow



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow).

  - The `TensorFlow` and `TensorFlow-Lite` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e tensorflow` command.

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflow

    ```



- Tensorflow-Lite



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow) with only `TensorFlow-Lite`.

  - The `TensorFlow-Lite` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e tensorflow` command.

  - **THIS TAG CANNOT BE USED WITH THE `tensorflow` TAG.**

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflowlite

    ```



- Image



  - This extension supports the host functions in [WasmEdge-image](https://github.com/second-state/WasmEdge-image).

  - The `Image` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e image` command.

  - For using this extension, the tag `image` when building is required:



    ```bash

    go build -tags image

    ```



Users can also turn on the multiple extensions when building:



```bash

go build -tags image,tensorflow

```



### Example Repository



Developers can refer to [the example repository](https://github.com/second-state/WasmEdge-go-examples/) for the WasmEdge-Go examples.



## WasmEdge-go Basics



In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.



### Version



The `Version` related APIs provide developers to check for the installed WasmEdge shared library version.



```go

import ""github.com/second-state/WasmEdge-go/wasmedge""



verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.

vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.

verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.

verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.

```



### Logging Settings



The `wasmedge.SetLogErrorLevel()` and `wasmedge.SetLogDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



Developers can also use the `wasmedge.SetLogOff()` API to disable all logging.



### Value Types



In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.



1. Number types: `i32`, `i64`, `f32`, and `f64`



   - Convert the `uint32` and `int32` to `i32` automatically when passing a value into WASM.

   - Convert the `uint64` and `int64` to `i64` automatically when passing a value into WASM.

   - Convert the `uint` and `int` to `i32` automatically when passing a value into WASM in 32-bit system.

   - Convert the `uint` and `int` to `i64` automatically when passing a value into WASM in 64-bit system.

   - Convert the `float32` to `f32` automatically when passing a value into WASM.

   - Convert the `float64` to `f64` automatically when passing a value into WASM.

   - Convert the `i32` from WASM to `int32` when getting a result.

   - Convert the `i64` from WASM to `int64` when getting a result.

   - Convert the `f32` from WASM to `float32` when getting a result.

   - Convert the `f64` from WASM to `float64` when getting a result.



2. Number type: `v128` for the `SIMD` proposal



   Developers should use the `wasmedge.NewV128()` to generate a `v128` value, and use the `wasmedge.GetV128()` to get the value.



   ```go

   val := wasmedge.NewV128(uint64(1234), uint64(5678))

   high, low := val.GetVal()

   // `high` will be uint64(1234), `low` will be uint64(5678)

   ```



3. Reference types: `FuncRef` and `ExternRef` for the `Reference-Types` proposal



   ```go

   var funccxt *wasmedge.Function = ... // Create or get function object.

   funcref := wasmedge.NewFuncRef(funccxt)

   // Create a `FuncRef` with the function object.



   num := 1234

   // `num` is a `int`.

   externref := wasmedge.NewExternRef(&num)

   // Create an `ExternRef` which reference to the `num`.

   num = 5678

   // Modify the `num` to 5678.

   numref := externref.GetRef().(*int)

   // Get the original reference from the `ExternRef`.

   fmt.Println(*numref)

   // Will print `5678`.

   numref.Release()

   // Should call the `Release` method.

   ```



### Results



The `Result` object specifies the execution status. Developers can use the `Error()` function to get the error message.



```go

// Assume that `vm` is a `wasmedge.VM` object.

res, err = vm.Execute(...) // Ignore the detail of parameters.

// Assume that `res, err` are the return values for executing a function with `vm`.

if err != nil {

  fmt.Println(""Error message:"", err.Error())

  category := err.GetErrorCategory()

  // The `category` will be `wasmedge.ErrCategory_WASM`.

}



userdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)

// Generate the user-defined error with code.

code := userdef_err.GetCode()

// The `Code` will be 123456.

```



### Contexts And Their Life Cycles



The objects, such as `VM`, `Store`, and `Function`, etc., are composed of `Context`s in the WasmEdge shared library. All of the contexts can be created by calling the corresponding `New` APIs, developers should also call the corresponding `Release` functions of the contexts to release the resources. Noticed that it's not necessary to call the `Release` functions for the contexts which are retrieved from other contexts but not created from the `New` APIs.



```go

// Create a Configure.

conf := wasmedge.NewConfigure()

// Release the `conf` immediately.

conf.Release()

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `Limit` struct presents the minimum and maximum value data structure.



   ```go

   lim1 := wasmedge.NewLimit(12)

   fmt.Println(lim1.HasMax())

   // Will print `false`.

   fmt.Println(lim1.GetMin())

   // Will print `12`.



   lim2 := wasmedge.NewLimitWithMax(15, 50)

   fmt.Println(lim2.HasMax())

   // Will print `true`.

   fmt.Println(lim2.GetMin())

   // Will print `15`.

   fmt.Println(lim2.GetMax())

   // Will print `50`.

   ```



   For the thread proposal, the `Limit` struct also supports the shared memory description.



   ```go

   lim3 := wasmedge.NewLimitShared(20)

   fmt.Println(lim3.HasMax())

   // Will print `false`.

   fmt.Println(lim3.IsShared())

   // Will print `true`.

   fmt.Println(lim3.GetMin())

   // Will print `20`.



   lim4 := wasmedge.NewLimitSharedWithMax(30, 40)

   fmt.Println(lim4.HasMax())

   // Will print `true`.

   fmt.Println(lim4.IsShared())

   // Will print `true`.

   fmt.Println(lim4.GetMin())

   // Will print `30`.

   fmt.Println(lim4.GetMax())

   // Will print `40`.

   ```



2. Function type context



   The `FunctionType` is an object holds the function type context and used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `FunctionType` APIs to get the parameter or return value types information.



   ```go

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{

       wasmedge.ValType_ExternRef,

       wasmedge.ValType_I32,

       wasmedge.ValType_I64,

     }, []wasmedge.ValType{

       wasmedge.ValType_F32,

       wasmedge.ValType_F64,

     })



   plen := functype.GetParametersLength()

   // `plen` will be 3.

   rlen := functype.GetReturnsLength()

   // `rlen` will be 2.

   plist := functype.GetParameters()

   // `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.

   rlist := functype.GetReturns()

   // `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.



   functype.Release()

   ```



3. Table type context



   The `TableType` is an object holds the table type context and used for `Table` instance creation or getting information from `Table` instances.



   ```go

   lim := wasmedge.NewLimit(12)

   tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)



   rtype := tabtype.GetRefType()

   // `rtype` will be `wasmedge.RefType_ExternRef`.

   getlim := tabtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   tabtype.Release()

   ```



4. Memory type context



   The `MemoryType` is an object holds the memory type context and used for `Memory` instance creation or getting information from `Memory` instances.



   ```go

   lim := wasmedge.NewLimit(1)

   memtype := wasmedge.NewMemoryType(lim)



   getlim := memtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   memtype.Release()

   ```



5. Global type context



   The `GlobalType` is an object holds the global type context and used for `Global` instance creation or getting information from `Global` instances.



   ```go

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)



   vtype := globtype.GetValType()

   // `vtype` will be `wasmedge.ValType_F64`.

   vmut := globtype.GetMutability()

   // `vmut` will be `wasmedge.ValMut_Var`.



   globtype.Release()

   ```



6. Import type context



   The `ImportType` is an object holds the import type context and used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `ImportType` object. The details about querying `ImportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   imptypelist := ast.ListImports()

   // Assume that `imptypelist` is an array listed from the `ast` for the imports.



   for i, imptype := range imptypelist {

     exttype := imptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     modname := imptype.GetModuleName()

     extname := imptype.GetExternalName()

     // Get the module name and external name of the imports.



     extval := imptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



7. Export type context



   The `ExportType` is an object holds the export type context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `ExportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   exptypelist := ast.ListExports()

   // Assume that `exptypelist` is an array listed from the `ast` for the exports.



   for i, exptype := range exptypelist {

     exttype := exptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     extname := exptype.GetExternalName()

     // Get the external name of the exports.



     extval := exptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `wasmedge.Async` object. Developers own the object and should call the `(*Async).Release()` API to release it.



1. Get the execution result of the asynchronous execution



   Developers can use the `(*Async).GetResult()` API to block and wait for getting the return values. This function will block and wait for the execution. If the execution has finished, this function will return immediately. If the execution failed, this function will return an error.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution and get the return values.

   res, err := async.GetResult()

   async.Release()

   ```



2. Wait for the asynchronous execution with timeout settings



   Besides waiting until the end of execution, developers can set the timeout to wait for.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution with the timeout(ms).

   isend := async.WaitFor(1000)

   if isend {

     res, err := async.GetResult()

     // ...

   } else {

     async.Cancel()

     _, err := async.GetResult()

     // The error message in `err` will be ""execution interrupted"".

   }

   async.Release()

   ```



### Configurations



The configuration object, `wasmedge.Configure`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` object to create other runtime objects.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` object.



   ```go

   const (

     IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)

     NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)

     SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)

     MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)

     BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)

     REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)

     SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)

     TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)

     ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)

     MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)

     EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)

     EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)

     THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)

     FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)

   )

   ```



   Developers can add or remove the proposals into the `Configure` object.



   ```go

   // By default, the following proposals have turned on initially:

   // * IMPORT_EXPORT_MUT_GLOBALS

   // * NON_TRAP_FLOAT_TO_INT_CONVERSIONS

   // * SIGN_EXTENSION_OPERATORS

   // * MULTI_VALUE

   // * BULK_MEMORY_OPERATIONS

   // * REFERENCE_TYPES

   // * SIMD

   // For the current WasmEdge version, the following proposals are supported:

   // * TAIL_CALL

   // * MULTI_MEMORIES

   // * THREADS

   // * EXTENDED_CONST

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)

   conf.AddConfig(wasmedge.SIMD)

   conf.RemoveConfig(wasmedge.REFERENCE_TYPES)

   is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)

   // The `is_bulkmem` will be `true`.

   conf.Release()

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` supports and only effective in `VM` contexts.



   The element of this enum is reserved for the other built-in host functions (such as `wasi-socket`) in the future.



   ```go

   const (

     WASI = HostRegistration(C.WasmEdge_HostRegistration_Wasi)

   )

   ```



   The details will be introduced in the [preregistrations of VM context](#built-in-host-modules-and-plug-in-preregistrations).



   ```go

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.WASI)

   conf.AddConfig(wasmedge.WASI)

   conf.Release()

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` objects.



   ```go

   conf := wasmedge.NewConfigure()



   pagesize := conf.GetMaxMemoryPage()

   // By default, the maximum memory page size in each memory instances is 65536.

   conf.SetMaxMemoryPage(1234)

   pagesize = conf.GetMaxMemoryPage()

   // `pagesize` will be 1234.



   conf.Release()

   ```



4. Forcibly interpreter mode



   If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration.



   ```go

   conf := wasmedge.NewConfigure()



   is_forceinterp := conf.IsForceInterpreter()

   // By default, the `is_forceinterp` will be `false`.

   conf.SetForceInterpreter(true)

   is_forceinterp = conf.IsForceInterpreter()

   /* The `is_forceinterp` will be `true`. */



   conf.Release()

   ```



5. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```go

   const (

     // Disable as many optimizations as possible.

     CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

     // Optimize quickly without destroying debuggability.

     CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

     // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

     CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

     // Optimize for fast execution as much as possible.

     CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

     // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

     CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

     // Optimize for small code size as much as possible.

     CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

   )



   const (

     // Native dynamic library format.

     CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

     // WebAssembly with AOT compiled codes in custom section.

     CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

   )

   ```



   These configurations are only effective in `Compiler` contexts.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the optimization level is O3.

   conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)

   // By default, the output format is universal WASM.

   conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)

   // By default, the dump IR is `false`.

   conf.SetCompilerDumpIR(true)

   // By default, the generic binary is `false`.

   conf.SetCompilerGenericBinary(true)



   conf.Release()

   ```



6. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` objects.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsInstructionCounting(true)

   // By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsTimeMeasuring(true)

   // By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsCostMeasuring(true)



   conf.Release()

   ```



### Statistics



The statistics object, `wasmedge.Statistics`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` object from the `VM` object, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```go

   stat := wasmedge.NewStatistics()

   // ... After running the WASM functions with the `Statistics` object



   count := stat.GetInstrCount()

   ips := stat.GetInstrPerSecond()

   stat.Release()

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` object. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   stat := wasmedge.NewStatistics()



   costtable := []uint64{

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0,

   }

   // Developers can set the costs of each instruction. The value not covered will be 0.



   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   stat.SetCostTable()

   stat.SetCostLimit(5000000)



   // ... After running the WASM functions with the `Statistics` object

   cost := stat.GetTotalCost()

   stat.Release()

   ```



### Tools Driver



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools in WasmEdge-Go. The API arguments are the same as the command line arguments of the CLI tools.



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeCLI(os.Args)

}

```



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)

}

```



## WasmEdge VM



In this partition, we will introduce the functions of `wasmedge.VM` object and show examples of executing WASM functions.



### WASM Execution Example With VM Object



The following shows the example of running the WASM for getting the Fibonacci. This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current `wasmedge_test` directory, and create and edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create the configure context and add the WASI support.

     // This step is not necessary unless you need WASI support.

     conf := wasmedge.NewConfigure(wasmedge.WASI)

     // Create VM with the configure.

     vm := wasmedge.NewVMWithConfig(conf)



     res, err := vm.RunWasmFile(""fibonacci.wasm"", ""fib"", uint32(21))

     if err == nil {

       fmt.Println(""Get fibonacci[21]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

     conf.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   Get fibonacci[21]: 17711

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` object APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create VM.

     vm := wasmedge.NewVM()

     var err error

     var res []interface{}



     // Step 1: Load WASM file.

     err = vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     // Developers can load, validate, and instantiate another WASM module

     // to replace the instantiated one. In this case, the old module will

     // be cleared, but the registered modules are still kept.

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Execute WASM functions. Parameters: (funcname, args...)

     res, err = vm.Execute(""fib"", uint32(25))

     // Developers can execute functions repeatedly after instantiation.

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



   The following graph explains the status of the `VM` object.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered,

                   ExecuteBindgen, ExecuteBindgenRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or import objects in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation APIs accepts the `Configure` object and the `Store` object. Noticed that if the `VM` created with the outside `Store` object, the `VM` will execute WASM on that `Store` object. If the `Store` object is set into multiple `VM` objects, it may causes data conflict when in execution. The details of the `Store` object will be introduced in [Store](#store).



```go

conf := wasmedge.NewConfigure()

store := wasmedge.NewStore()



// Create a VM with default configure and store.

vm := wasmedge.NewVM()

vm.Release()



// Create a VM with the specified configure and default store.

vm = wasmedge.NewVMWithConfig(conf)

vm.Release()



// Create a VM with the default configure and specified store.

vm = wasmedge.NewVMWithStore(store)

vm.Release()



// Create a VM with the specified configure and store.

vm = wasmedge.NewVMWithConfigAndStore(conf, store)

vm.Release()



conf.Release()

store.Release()

```



### Built-in Host Modules and Plug-in Preregistrations



WasmEdge provides the following built-in host modules and plug-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` object.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WASI)

   // Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the built-in registered module instances from the VM object.

   // This API will return `nil` if the corresponding configuration is not set when creating the VM object.

   wasiconf := vm.GetImportModule(wasmedge.WASI)

   // Initialize the WASI.

   wasiconf.InitWasi(/* ... ignored */)



   vm.Release()

   ```



   And also can create the WASI import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. Plug-ins



   There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](../../../start/install.md#install-wasmedge-plug-ins-and-dependencies).



   Before using the plug-ins, developers should [load the plug-ins from paths](#load-plug-ins-from-paths).



   The `VM` object will automatically create and register the module of the loaded plug-ins when creation. Furthermore, the following host modules will be mocked if the plug-in not loaded:



   - `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)

   - `wasi_ephemeral_nn`

   - `wasi_snapshot_preview1`

   - `wasmedge_httpsreq`

   - `wasmedge_process`



   When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.



   ```go

   // Load the plug-ins in the default paths first.

   wasmedge.LoadPluginDefaultPaths()



   // Create the VM object with the WASI configuration.

   conf := wasmedge.NewConfigure(wasmedge.WASI)

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.

   // This API will return `NULL` if the module instance not found.



   // The `wasimodule` will not be `nil` because the configuration was set.

   wasimodule := vm.GetRegisteredModule(""wasi_snapshot_preview1"")



   // The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.

   wasinnmodule := vm.GetRegisteredModule(""wasi_ephemeral_nn"")



   vm.Release()

   ```



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge-go, the host functions are composed into host modules as `Module` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` object.



```go

vm := wasmedge.NewVM()

// You can also create and register the WASI host modules by this API.

wasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)



res := vm.RegisterModule(wasiobj)

// The result status should be checked.



vm.Release()

// The created import objects should be released.

wasiobj.Release()

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory. Then create and edit the Go file `main.go` as following:



   ```go

   package main



   import ""github.com/second-state/WasmEdge-go/wasmedge""



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var err error

     err = vm.RegisterWasmFile(""module_name"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     // The result status should be checked. The error will occur if the

     // WASM module instantiation failed or the module name conflicts.



     vm.Release()

   }

   ```



2. Execute the functions in registered WASM modules



   Edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var res []interface{}

     var err error

     // Register the WASM module from file into VM with the module name ""mod"".

     err = vm.RegisterWasmFile(""mod"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     if err != nil {

       fmt.Println(""WASM registration failed:"", err.Error())

       return

     }

     // The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

     // name ""mod"". As the same as host functions, other modules can import the

     // function `""mod"" ""fib""`.



     // Execute WASM functions in registered modules.

     // Unlike the execution of functions, the registered functions can be

     // invoked without `(*VM).Instantiate` because the WASM module was

     // instantiated when registering.

     // Developers can also invoke the host functions directly with this API.

     res, err = vm.ExecuteRegistered(""mod"", ""fib"", int32(25))

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.

     async := vm.AsyncRunWasmFile(""fibonacci.wasm"", ""fib"", uint32(20))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     var err error

     var res []interface{}



     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,

     // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.

     async := vm.AsyncExecute(""fib"", uint32(25))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` object supplies the APIs to retrieve the instances.



1. Store



   If the `VM` object is created without assigning a `Store` object, the `VM` context will allocate and own a `Store`.



   ```go

   vm := wasmedge.NewVM()

   store := vm.GetStore()

   // The object should __NOT__ be deleted by calling `(*Store).Release`.

   vm.Release()

   ```



   Developers can also create the `VM` object with a `Store` object. In this case, developers should guarantee that the `Store` object cannot be released before the `VM` object. Please refer to the [Store Objects](#store) for the details about the `Store` APIs.



   ```go

   store := wasmedge.NewStore()

   vm := wasmedge.NewVMWithStore(store)



   storemock := vm.GetStore()

   // The internal store context of the `store` and the `storemock` are the same.



   vm.Release()

   store.Release()

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `(*VM).Execute` function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // List the exported functions for the names and function types.

     funcnames, functypes := vm.GetFunctionList()

     for _, fname := range funcnames {

       fmt.Println(""Exported function name:"", fname)

     }

     for _, ftype := range functypes {

       // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.

       // Developers should __NOT__ call the `ftype.Release()`.

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   Exported function name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` object from the `VM` object and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` object provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   functype := vm.GetFunctionType(""fib"")

   // Developers can get the function types of functions in the registered modules via the

   // `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.

   // If the function is not found, these APIs will return `nil`.

   // Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` object. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `(*VM).GetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   mod := vm.GetActiveModule()

   // If there's no WASM module instantiated, this API will return `nil`.

   // Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.

   ```



5. List and get the registered modules



   To list and retrieve the registered modules in the `VM` object, besides accessing the `store` object of the `VM`, developers can use the following APIs.



   ```go

   // Assume that the `vm` is the created `wasmedge.VM` object.

   modnames := vm.ListRegisteredModule()

   for _, name := range modnames {

     fmt.Println(""Registered module name: "", name)

   }

   ```



6. Get the components



   The `VM` object is composed by the `Loader`, `Validator`, and `Executor` objects. For the developers who want to use these objects without creating another instances, these APIs can help developers to get them from the `VM` object. The get objects are owned by the `VM` object, and developers should not call their release functions.



   ```go

   loader := vm.GetLoader()

   // Developers should __NOT__ call the `(*Loader).Release` function of the returned object.

   validator := vm.GetValidator()

   // Developers should __NOT__ call the `(*Validator).Release` function of the returned object.

   executor := vm.GetExecutor()

   // Developers should __NOT__ call the `(*Executor).Release` function of the returned object.

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` object](#wasmedge-vm) rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` objects.



Assume that a new Go project is created as following:



```bash

mkdir wasmedge_test && cd wasmedge_test

go mod init wasmedge_test

```



Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



```go

package main



import (

  ""fmt""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  // Set the logging level to debug to print the statistics info.

  wasmedge.SetLogDebugLevel()

  // Create the configure object. This is not necessary if developers use the default configuration.

  conf := wasmedge.NewConfigure()

  // Turn on the runtime instruction counting and time measuring.

  conf.SetStatisticsInstructionCounting(true)

  conf.SetStatisticsTimeMeasuring(true)

  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.

  stat := wasmedge.NewStatistics()

  // Create the store object. The store object is the WASM runtime structure core.

  store := wasmedge.NewStore()



  var err error

  var res []interface{}

  var ast *wasmedge.AST

  var mod *wasmedge.Module



  // Create the loader object.

  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

  loader := wasmedge.NewLoaderWithConfig(conf)

  // Create the validator object.

  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

  validator := wasmedge.NewValidatorWithConfig(conf)

  // Create the executor object.

  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.

  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)



  // Load the WASM file or the compiled-WASM file and convert into the AST module object.

  ast, err = loader.LoadFile(""fibonacci.wasm"")

  if err != nil {

    fmt.Println(""Load WASM from file FAILED:"", err.Error())

    return

  }

  // Validate the WASM module.

  err = validator.Validate(ast)

  if err != nil {

    fmt.Println(""Validation FAILED:"", err.Error())

    return

  }

  // Instantiate the WASM module and get the output module instance.

  mod, err = executor.Instantiate(store, ast)

  if err != nil {

    fmt.Println(""Instantiation FAILED:"", err.Error())

    return

  }



  // Try to list the exported functions of the instantiated WASM module.

  funcnames := mod.ListFunction()

  for _, fname := range funcnames {

    fmt.Println(""Exported function name:"", fname)

  }



  // Invoke the WASM function.

  funcinst := mod.FindFunction(""fib"")

  if funcinst == nil {

    fmt.Println(""Run FAILED: Function name `fib` not found"")

    return

  }

  res, err = executor.Invoke(store, funcinst, int32(30))

  if err == nil {

    fmt.Println(""Get fibonacci[30]:"", res[0].(int32))

  } else {

    fmt.Println(""Run FAILED:"", err.Error())

  }



  // Resources deallocations.

  conf.Release()

  stat.Release()

  ast.Release()

  loader.Release()

  validator.Release()

  executor.Release()

  store.Release()

  mod.Release()

}

```



Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)



```bash

$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

$ go build

$ ./wasmedge_test

Exported function name: fib

[2021-11-24 18:53:01.451] [debug]  Execution succeeded.

[2021-11-24 18:53:01.452] [debug]

 ====================  Statistics  ====================

 Total execution time: 556372295 ns

 Wasm instructions execution time: 556372295 ns

 Host functions execution time: 0 ns

 Executed wasm instructions count: 28271634

 Gas costs: 0

 Instructions per second: 50814237

Get fibonacci[30]: 1346269

```



### Loader



The `Loader` object loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```go

var buf []byte

// ... Read the WASM code to the `buf`.



// Developers can adjust settings in the configure object.

conf := wasmedge.NewConfigure()

// Create the loader object.

// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

loader := wasmedge.NewLoaderWithConfig(conf)

conf.Release()



// Load WASM or compiled-WASM from the file.

ast, err := loader.LoadFile(""fibonacci.wasm"")

if err != nil {

  fmt.Println(""Load WASM from file FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



// Load WASM or compiled-WASM from the buffer

ast, err = loader.LoadBuffer(buf)

if err != nil {

  fmt.Println(""Load WASM from buffer FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



loader.Release()

```



### Validator



The `Validator` object can validate the WASM module. Every WASM module should be validated before instantiation.



```go

// ...

// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.

// Assume that the `conf` is the `*wasmedge.Configure` object.



// Create the validator context.

// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

validator := wasmedge.NewValidatorWithConfig(conf)



err := validator.Validate(ast)

if err != nil {

  fmt.Println(""Validation FAILED:"", err.Error())

}



validator.Release()

```



### Executor



The `Executor` object is the executor for both WASM and compiled-WASM. This object should work base on the `Store` object. For the details of the `Store` object, please refer to the [next chapter](#store).



1. Instantiate and register an `AST` object as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` objects, developers can instantiate and register an `AST` objects into the `Store` context as a named `Module` instance by the `Executor` APIs. After the registration, the result `Module` instance is exported with the given module name and can be linked when instantiating another module. For the details about the `Module` instances APIs, please refer to the [Instances](#instances).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Register the loaded WASM `ast` into store with the export module name ""mod"".

   mod, res := executor.Register(store, ast, ""mod"")

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST` object, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Create a module instance for host functions.

   mod := wasmedge.NewModule(""mod"")

   // ...

   // Create and add the host functions, tables, memories, and globals into the module instance.

   // ...



   // Register the module instance into store with the exported module name.

   // The export module name is in the module instance already.

   res := executor.RegisterImport(store, mod)

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



3. Instantiate an `AST` object to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` object for linking.



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Instantiate the WASM module.

   mod, err := executor.Instantiate(stpre, ast)

   if err != nil {

     fmt.Println(""WASM instantiation FAILED:"", err.Error())

     return

   }



   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `(*Executor).Invoke` API.



### AST Module



The `AST` object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST` object.



```go

ast := ...

// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.



// List the imports.

imports := ast.ListImports()

for _, import := range imports {

  fmt.Println(""Import:"", import.GetModuleName(), import.GetExternalName())

}



// List the exports.

exports := ast.ListExports()

for _, export := range exports {

  fmt.Println(""Export:"", export.GetExternalName())

}



ast.Release()

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` object in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` context.



```go

store := wasmedge.NewStore()



// ...

// Register a WASM module via the executor object.

// ...



// Try to list the registered WASM modules.

modnames := store.ListModule()

// ...



// Find named module by name.

mod := store.FindModule(""module"")

// If the module with name not found, the `mod` will be `nil`.



store.Release()

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST` object, developers will get a `Module` instance as the result, and have the responsibility to release it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```go

   // ...

   // Instantiate a WASM module via the executor object and get the `mod` as the output module instance.

   // ...



   // List the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcnames := mod.ListFunction()



   // Try to find the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcinst := mod.FindFunction(""fib"")

   // `funcinst` will be `nil` if the function not found.

   // The returned instance is owned by the module instance and should __NOT__ be released.

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` objects for host functions and add them into an `Module` instance for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` objects through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```go

   funcobj := ...

   // `funcobj` is the `*wasmedge.Function` retrieved from the module instance.

   functype := funcobj.GetFunctionType()

   // The `funcobj` retrieved from the module instance should __NOT__ be released.

   // The `functype` retrieved from the `funcobj` should __NOT__ be released.



   // For the function object creation, please refer to the `Host Function` guide.

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Table` objects supply APIs to control the data in table instances.



   ```go

   lim := wasmedge.NewLimitWithMax(10, 20)

   // Create the table type with limit and the `FuncRef` element type.

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)

   // Create the table instance with table type.

   tabinst := wasmedge.NewTable(tabtype)

   // Delete the table type.

   tabtype.Release()



   gottabtype := tabinst.GetTableType()

   // The `gottabtype` got from table instance is owned by the `tabinst`

   // and should __NOT__ be released.

   reftype := gottabtype.GetRefType()

   // The `reftype` will be `wasmedge.RefType_FuncRef`.



   var gotdata interface{}

   data := wasmedge.NewFuncRef(5)

   err := tabinst.SetData(data, 3)

   // Set the function index 5 to the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   err = tabinst.SetData(data, 13)



   gotdata, err = tabinst.GetData(3)

   // Get the FuncRef value of the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   gotdata, err = tabinst.GetData(13)



   tabsize := tabinst.GetSize()

   // `tabsize` will be 10.

   err = tabinst.Grow(6)

   // Grow the table size of 6, the table size will be 16.



   // The following line will get an ""out of bounds table access"" error

   // because the size (16 + 6) will reach the table limit (20):

   //   err = tabinst.Grow(6)



   tabinst.Release()

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Memory` objects supply APIs to control the data in memory instances.



   ```go

   lim := wasmedge.NewLimitWithMax(1, 5)

   // Create the memory type with limit. The memory page size is 64KiB.

   memtype := wasmedge.NewMemoryType(lim)

   // Create the memory instance with memory type.

   meminst := wasmedge.NewMemory(memtype)

   // Delete the memory type.

   memtype.Release()



   data := []byte(""A quick brown fox jumps over the lazy dog"")

   err := meminst.SetData(data, 0x1000, 10)

   // Set the data[0:9] to the memory[4096:4105].



   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   err = meminst.SetData(data, 0xFFFF, 10)



   var gotdata []byte

   gotdata, err = meminst.GetData(0x1000, 10)

   // Get the memory[4096:4105]. The `gotdata` will be `[]byte(""A quick br"").

   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   gotdata, err = meminst.Getdata(0xFFFF, 10)



   pagesize := meminst.GetPageSize()

   // `pagesize` will be 1.

   err = meminst.GrowPage(2)

   // Grow the page size of 2, the page size of the memory instance will be 3.



   // The following line will get an ""out of bounds memory access"" error

   // because the size (3 + 3) will reach the memory limit (5):

   //   err = meminst.GetPageSize(3)



   meminst.Release()

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Global` objects supply APIs to control the value in global instances.



   ```go

   // Create the global type with value type and mutation.

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)

   // Create the global instance with value and global type.

   globinst := wasmedge.NewGlobal(globtype, uint64(1000))

   // Delete the global type.

   globtype.Release()



   gotglobtype := globinst.GetGlobalType()

   // The `gotglobtype` got from global instance is owned by the `globinst`

   // and should __NOT__ be released.

   valtype := gotglobtype.GetValType()

   // The `valtype` will be `wasmedge.ValType_I64`.

   valmut := gotglobtype.GetMutability()

   // The `valmut` will be `wasmedge.ValMut_Var`.



   globinst.SetValue(uint64(888))

   // Set the value u64(888) to the global.

   // This function will do nothing if the value type mismatched or the

   // global mutability is `wasmedge.ValMut_Const`.

   gotval := globinst.GetValue()

   // The `gotbal` will be `interface{}` which the type is `uint64` and

   // the value is 888.



   globinst.Release()

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function`, `Memory`, `Table`, and `Global` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define Go functions with the following function signature as the host function body:



   ```go

   type hostFunctionSignature func(

       data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```go

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }

   ```



   Then developers can create `Function` object with the host function body and function type:



   ```go

   // Create a function type: {i32, i32} -> {i32}.

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )



   // Create a function context with the function type and host function body.

   // The third parameter is the pointer to the additional data.

   // Developers should guarantee the life cycle of the data, and it can be

   // `nil` if the external data is not needed.

   // The last parameter can be 0 if developers do not need the cost measuring.

   func_add := wasmedge.NewFunction(functype, host_add, nil, 0)



   // If the function object is not added into an module instance object, it should be released.

   func_add.Release()

   functype.Release()

   ```



2. Calling frame object



   The `wasmedge.CallingFrame` is the object to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



   ```go

   import (

     ""encoding/binary""

     ""fmt""

   )



   // Host function body definition.

   func LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // Function type: {i32} -> {}

     offset := params[0].(int32)



     // Get the 0th memory instance of the module of the top frame on the stack.

     mem := callframe.GetMemoryByIndex(0)



     data, err := mem.GetData(uint(offset), 4)

     if err != nil {

       return nil, err

     }

     fmt.Println(""u32 at memory[{}]: {}"", offset, binary.LittleEndian.Uint32(data))

     return nil, wasmedge.Result_Success

   }

   ```



   Besides using the `(*CallingFrame).GetMemoryByIndex()` API to get the memory instance by index in the module instance, developers can use the `(*CallingFrame).GetModule()` to get the module instance directly. Therefore, developers can retrieve the exported contexts by the `wasmedge.Module` APIs. And also, developers can use the `(*CallingFrame).GetExecutor()` API to get the currently used executor context.



3. User-defined error code of the host functions



   In host functions, WasmEdge-Go provides `wasmedge.Result_Success` to return success, `wasmedge.Result_Terminate` to terminate the WASM execution, and `wasmedge.Result_Fail` to return fail. WasmEdge-Go also provides the usage of returning the user-specified codes. Developers can use the `wasmedge.NewResult()` API to generate the `wasmedge.Result` struct with error code, and use the `(*result).GetCode()` API to get the error code.



   > Notice: The error code only supports 24-bit integer (0 ~ 16777216 in `uint32`). The values larger than 24-bit will be truncated.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32)))

     (import ""extern"" ""trap"" (func $f-trap (type $t0)))

     (func (export ""trap"") (param i32)

       local.get 0

       call $f-trap)

   )

   ```



   And the `main.go` is as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x05, 0x01,

       /* function type {i32} -> {} */

       0x60, 0x01, 0x7F, 0x00,

       /* Import section */

       0x02, 0x0F, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""trap"" */

       0x04, 0x74, 0x72, 0x61, 0x70,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x08, 0x01,

       /* export name: ""trap"" */

       0x04, 0x74, 0x72, 0x61, 0x70,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x08, 0x01,

       /* code body */

       0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,

     }



     // Create the module instance with the module name ""extern"".

     impmod := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})

     hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)

     functype.Release()

     impmod.AddFunction(""trap"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(impmod)



     _, err := vm.RunWasmBuffer(wasmbuf, ""trap"", uint32(5566))

     if err != nil {

       fmt.Println(""Get the error code:"", err.GetCode())

     }



     impmod.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   [2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be

   [2022-08-26 15:06:40.384] [error]     When executing function name: ""trap""

   Get the error code: 5566

   ```



4. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```go

   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   // Create a module instance with the module name ""module"".

   mod := wasmedge.NewModule(""module"")



   // Create and add a function instance into the module instance with export name ""add"".

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )

   hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

   functype.Release()

   mod.AddFunction(""add"", hostfunc)



   // Create and add a table instance into the module instance with export name ""table"".

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))

   hosttab := wasmedge.NewTable(tabtype)

   tabtype.Release()

   mod.AddTable(""table"", hosttab)



   // Create and add a memory instance into the module instance with export name ""memory"".

   memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))

   hostmem := wasmedge.NewMemory(memtype)

   memtype.Release()

   mod.AddMemory(""memory"", hostmem)



   // Create and add a global instance into the module instance with export name ""global"".

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)

   hostglob := wasmedge.NewGlobal(globtype, uint32(666))

   globtype.Release()

   mod.AddGlobal(""global"", hostglob)



   // The module instances should be released.

   // Developers should __NOT__ release the instances added into the module instance objects.

   mod.Release()

   ```



5. Specified module instance



   `wasmedge.NewWasiModule()` API can create and initialize the `WASI` module instance.



   ```go

   wasiobj := wasmedge.NewWasiModule(

     os.Args[1:],     // The args

     os.Environ(),    // The envs

     []string{"".:.""}, // The mapping preopens

   )



   // Register the WASI into the VM object.

   vm := wasmedge.NewVM()

   vm.RegisterImport(wasiobj)



   // ... Execute some WASM functions.



   // Get the WASI exit code.

   exitcode := wasiobj.WasiGetExitCode()

   // The `exitcode` will be 0 if the WASI function ""_start"" execution has no error.

   // Otherwise, it will return with the related exit code.



   vm.Release()

   // The import objects should be deleted.

   wasiobj.Release()

   ```



6. Example



   Assume that there is a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // Create the module instance with the module name ""extern"".

     impmod := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

     functype.Release()

     impmod.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(impmod)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }



     impmod.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   ```



7. Host Data Example



   Developers can set a external data object to the `Function` object, and access to the object in the function body. Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Also set the result to the data.

     *data.(*int32) = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // The additional data to set into the host function.

     var data int32 = 0



     // Create the module instance with the module name ""extern"".

     modinst := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)

     functype.Release()

     modinst.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(modinst)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     fmt.Println(""Data value:"", data)



     modinst.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.12.1

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   Data value: 6912

   ```



### Plug-ins



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



#### Load plug-ins from paths



To use the plug-ins, developers should load the plug-ins from paths first.



```go

wasmedge.LoadPluginDefaultPaths()

```



After calling this API, the plug-ins in the default paths will be loaded. The default paths are:



1. The path given in the environment variable `WASMEDGE_PLUGIN_PATH`.

2. The `../plugin/` directory related to the WasmEdge installation path.

3. The `./wasmedge/` directory under the library path if the WasmEdge is installed under the system directory (such as `/usr` and `/usr/local`).



To load the plug-ins from a specific path or under a specific directory, developers can use this API:



```go

wasmedge.LoadPluginFromPath(""PATH_TO_PLUGIN/plugin.so"")

```



#### Get the plug-in by name



After loading the plug-ins, developers can list the loaded plug-in names.



```go

wasmedge.LoadPluginDefaultPaths()

pluginnames := wasmedge.ListPlugins()

for _, name := range pluginnames {

  fmt.Println(""Loaded plug-in name: "", name)

}

```



And developers can retrieve the plug-in object by its name.



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()

plugincrypto := wasmedge.FindPlugin(""wasi_crypto"")

```



#### Create the module instance from a plug-in



With the plug-in object, developers can create the module instances by the module name.



```go

// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.



// List the available host modules in the plug-in.

modules := plugincrypto.ListModule()

for _, name := range modules {

  fmt.Println(""Available module: "", name)

}

// Will print here for the WASI-Crypto plug-in here:

//   wasi_ephemeral_crypto_asymmetric_common

//   wasi_ephemeral_crypto_common

//   wasi_ephemeral_crypto_kx

//   wasi_ephemeral_crypto_signatures

//   wasi_ephemeral_crypto_symmetric



// Create a module instance from the plug-in by the module name.

modinst := plugincrypto.CreateModule(""wasi_ephemeral_crypto_common"")



modinst.Release()

```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options in Go. WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) provide a tool for compiling a WASM file.



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```go

const (

  // Disable as many optimizations as possible.

  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

  // Optimize quickly without destroying debuggability.

  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

  // Optimize for fast execution as much as possible.

  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

  // Optimize for small code size as much as possible.

  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

)



const (

  // Native dynamic library format.

  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

  // WebAssembly with AOT compiled codes in custom section.

  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

)

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/go/reference/0.9.x.md
------


---

sidebar_position: 9

---



# Go API v0.9.1 Documentation



The following are the guides to develop with the WasmEdge-Go SDK at WasmEdge version `0.9.1` and WasmEdge-Go version `v0.9.2`.



**Please install WasmEdge 0.9.1 to use this Go package.**



**WasmEdge-Go v0.9.1 is retracted. Please use WasmEdge-Go v0.9.2 instead.**



**Developers can refer [here to upgrade to v0.10.0](upgrade_to_0.10.0.md).**



## Table of Contents



- [Getting Started](#getting-started)

  - [WasmEdge Installation](#wasmedge-installation)

  - [Get WasmEdge-go](#get-wasmedge-go)

  - [WasmEdge-go Extensions](#wasmedge-go-extensions)

  - [Example of Embedding A Function with wasmedge-bindgen](#example-of-embedding-a-function-with-wasmedge-bindgen)

  - [Example of Embedding A Full WASI Program](#example-of-embedding-a-full-wasi-program)

- [WasmEdge-go Basics](#wasmedge-go-basics)

  - [Version](#version)

  - [Logging Settings](#logging-settings)

  - [Value Types](#value-types)

  - [Results](#results)

  - [Contexts And Their Life Cycles](#contexts-and-their-life-cycles)

  - [WASM data structures](#wasm-data-structures)

  - [Async](#async)

  - [Configurations](#configurations)

  - [Statistics](#statistics)

- [WasmEdge VM](#wasmedge-vm)

  - [WASM Execution Example With VM Object](#wasm-execution-example-with-vm-object)

  - [VM Creations](#vm-creations)

  - [Preregistrations](#preregistrations)

  - [Host Module Registrations](#host-module-registrations)

  - [WASM Registrations And Executions](#wasm-registrations-and-executions)

  - [Asynchronous execution](#asynchronous-execution)

  - [Instance Tracing](#instance-tracing)

- [WasmEdge Runtime](#wasmedge-runtime)

  - [WASM Execution Example Step-By-Step](#wasm-execution-example-step-by-step)

  - [Loader](#loader)

  - [Validator](#validator)

  - [Executor](#executor)

  - [AST Module](#ast-module)

  - [Store](#store)

  - [Instances](#instances)

  - [Host Functions](#host-functions)

- [WasmEdge AOT Compiler](#wasmedge-aot-compiler)

  - [Compilation Example](#compilation-example)

  - [Compiler Options](#compiler-options)



## Getting Started



The WasmEdge-go requires golang version >= 1.15. Please check your golang version before installation. Developers can [download golang here](https://golang.org/dl/).



```bash

$ go version

go version go1.16.5 linux/amd64

```



### WasmEdge Installation



Developers must [install the WasmEdge shared library](../../../start/install.md#install) with the same `WasmEdge-go` release or pre-release version.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1

```



For the developers need the `TensorFlow` or `Image` extension for `WasmEdge-go`, please install the `WasmEdge` with extensions:



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.1

```



Noticed that the `TensorFlow` and `Image` extensions are only for the `Linux` platforms. After installation, developers can use the `source` command to update the include and linking searching path.



### Get WasmEdge-go



After the WasmEdge installation, developers can get the `WasmEdge-go` package and build it in your Go project directory.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

go build

```



### WasmEdge-go Extensions



By default, the `WasmEdge-go` only turns on the basic runtime.



`WasmEdge-go` has the following extensions (on the Linux platforms only):



- Tensorflow



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow).

  - The `TensorFlow` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e tensorflow` command.

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflow

    ```



- Image



  - This extension supports the host functions in [WasmEdge-image](https://github.com/second-state/WasmEdge-image).

  - The `Image` extension when installing `WasmEdge` is required. Please install `WasmEdge` with the `-e image` command.

  - For using this extension, the tag `image` when building is required:



    ```bash

    go build -tags image

    ```



Users can also turn on the multiple extensions when building:



```bash

go build -tags image,tensorflow

```



### Example of Embedding A Function with wasmedge-bindgen



In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs), we will demonstrate how to call a few simple WebAssembly functions with wasmedge-bindgen from a Golang app. The [functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) are written in Rust, and require complex call parameters and return values.



While the WebAssembly only supports a few simple data types out of the box. It [does not support](https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333) types such as string and array. In order to pass rich types in Golang to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The `#[wasmedge_bindgen]` macro does this conversion automatically, combining it with Golang's `wasmedge-bindgen` package to auto-generate the correct code to pass call parameters from Golang to WebAssembly.



```rust

use wasmedge_bindgen::*;

use wasmedge_bindgen_macro::*;

use num_integer::lcm;

use sha3::{Digest, Sha3_256, Keccak256};

use serde::{Serialize, Deserialize};



#[derive(Serialize, Deserialize, Debug)]

struct Point {

  x: f32,

  y: f32

}



#[derive(Serialize, Deserialize, Debug)]

struct Line {

  points: Vec<Point>,

  valid: bool,

  length: f32,

  desc: String

}



#[wasmedge_bindgen]

pub fn create_line(p1: String, p2: String, desc: String) -> String {

  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();

  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();

  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();



  let valid = if length == 0.0 { false } else { true };



  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };



  return serde_json::to_string(&line).unwrap();

}



#[wasmedge_bindgen]

pub fn say(s: String) -> String {

  let r = String::from(""hello "");

  return r + s.as_str();

}



#[wasmedge_bindgen]

pub fn obfusticate(s: String) -> String {

  (&s).chars().map(|c| {

    match c {

      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,

      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,

      _ => c

    }

  }).collect()

}



#[wasmedge_bindgen]

pub fn lowest_common_multiple(a: i32, b: i32) -> i32 {

  return lcm(a, b);

}



#[wasmedge_bindgen]

pub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {

  return Sha3_256::digest(&v).as_slice().to_vec();

}



#[wasmedge_bindgen]

pub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {

  return Keccak256::digest(&s).as_slice().to_vec();

}

```



First, compile the Rust source code into WebAssembly bytecode functions.



```bash

rustup target add wasm32-wasi

cd rust_bindgen_funcs

cargo build --target wasm32-wasi --release

# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm

```



The [Golang source code](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go) to run the WebAssembly function in WasmEdge is as follows. The `bg.Execute()` function calls the WebAssembly function and passes the parameters with the `wasmedge-bindgen` supporting.



```go

package main



import (

  ""fmt""

  ""os""



  ""github.com/second-state/WasmEdge-go/wasmedge""

  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""

)



func main() {

  // Expected Args[0]: program name (./bindgen_funcs)

  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))



  // Set not to print debug info

  wasmedge.SetLogErrorLevel()



  // Create configure

  var conf = wasmedge.NewConfigure(wasmedge.WASI)



  // Create VM with configure

  var vm = wasmedge.NewVMWithConfig(conf)



  // Init WASI

  var wasi = vm.GetImportObject(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping preopens

  )



  // Load and validate the wasm

  vm.LoadWasmFile(os.Args[1])

  vm.Validate()



  // Instantiate the bindgen and vm

  bg := bindgen.Instantiate(vm)



  // create_line: string, string, string -> string (inputs are JSON stringified)

  res, err := bg.Execute(""create_line"", ""{\""x\"":2.5,\""y\"":7.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")

  if err == nil {

    fmt.Println(""Run bindgen -- create_line:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- create_line FAILED"", err)

  }



  // say: string -> string

  res, err = bg.Execute(""say"", ""bindgen funcs test"")

  if err == nil {

    fmt.Println(""Run bindgen -- say:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- say FAILED"")

  }



  // obfusticate: string -> string

  res, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")

  if err == nil {

    fmt.Println(""Run bindgen -- obfusticate:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- obfusticate FAILED"")

  }



  // lowest_common_multiple: i32, i32 -> i32

  res, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))

  if err == nil {

    fmt.Println(""Run bindgen -- lowest_common_multiple:"", res[0].(int32))

  } else {

    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")

  }



  // sha3_digest: array -> array

  res, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- sha3_digest:"", res[0].([]byte))

  } else {

    fmt.Println(""Run bindgen -- sha3_digest FAILED"")

  }



  // keccak_digest: array -> array

  res, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- keccak_digest:"", res[0].([]byte))

  } else {

    fmt.Println(""Run bindgen -- keccak_digest FAILED"")

  }



  bg.Release()

  vm.Release()

  conf.Release()

}

```



Next, build the Golang application with the WasmEdge Golang SDK.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

go get github.com/second-state/wasmedge-bindgen@v0.1.12

go build

```



Run the Golang application and it will run the WebAssembly functions embedded in the WasmEdge runtime.



```bash

$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm

Run bindgen -- create_line: {""points"":[{""x"":2.5,""y"":7.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.0,""desc"":""A thin red line""}

Run bindgen -- say: hello bindgen funcs test

Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt

Run bindgen -- lowest_common_multiple: 246

Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]

Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]

```



### Example of Embedding A Full WASI Program



Note: You can use the latest Rust compiler to create a standalone WasmEdge application with a `main.rs` functions and then embed it into a Golang application.



Besides functions, the WasmEdge Golang SDK can also [embed standalone WebAssembly applications](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile) — i.e. a Rust application with a `main()` function compiled into WebAssembly.



Our [demo Rust application](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile) reads from a file.



```rust

use std::env;

use std::fs::File;

use std::io::{self, BufRead};



fn main() {

  // Get the argv.

  let args: Vec<String> = env::args().collect();

  if args.len() <= 1 {

    println!(""Rust: ERROR - No input file name."");

    return;

  }



  // Open the file.

  println!(""Rust: Opening input file \""{}\""..."", args[1]);

  let file = match File::open(&args[1]) {

    Err(why) => {

      println!(""Rust: ERROR - Open file \""{}\"" failed: {}"", args[1], why);

      return;

    },

    Ok(file) => file,

  };



  // Read lines.

  let reader = io::BufReader::new(file);

  let mut texts:Vec<String> = Vec::new();

  for line in reader.lines() {

    if let Ok(text) = line {

      texts.push(text);

    }

  }

  println!(""Rust: Read input file \""{}\"" succeeded."", args[1]);



  // Get stdin to print lines.

  println!(""Rust: Please input the line number to print the line of file."");

  let stdin = io::stdin();

  for line in stdin.lock().lines() {

    let input = line.unwrap();

    match input.parse::<usize>() {

      Ok(n) => if n > 0 && n <= texts.len() {

        println!(""{}"", texts[n - 1]);

      } else {

        println!(""Rust: ERROR - Line \""{}\"" is out of range."", n);

      },

      Err(e) => println!(""Rust: ERROR - Input \""{}\"" is not an integer: {}"", input, e),

    }

  }

  println!(""Rust: Process end."");

}

```



Use the `rustwasmc` tool to compile the application into WebAssembly.



```bash

cd rust_readfile

rustwasmc build

# The output file will be at `pkg/rust_readfile.wasm`.

```



Or you can compile the application into WebAssembly directly by `cargo`:



```bash

cd rust_readfile

# Need to add the `wasm32-wasi` target.

rustup target add wasm32-wasi

cargo build --release --target=wasm32-wasi

# The output wasm will be at `target/wasm32-wasi/release/rust_readfile.wasm`.

```



The Golang source code to run the WebAssembly function in WasmEdge is as follows.



```go

package main



import (

  ""os""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.SetLogErrorLevel()



  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)

  conf.AddConfig(wasmedge.WASI)

  var vm = wasmedge.NewVMWithConfig(conf)

  var wasi = vm.GetImportObject(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping directories

  )



  // Instantiate and run WASM ""_start"" function, which refers to the main() function

  vm.RunWasmFile(os.Args[1], ""_start"")



  vm.Release()

  conf.Release()

}

```



Next, build the Golang application with the WasmEdge Golang SDK.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

go build

```



Run the Golang application.



```bash

$ ./read_file rust_readfile/pkg/rust_readfile.wasm file.txt

Rust: Opening input file ""file.txt""...

Rust: Read input file ""file.txt"" succeeded.

Rust: Please input the line number to print the line of file.

# Input ""5"" and press Enter.

5

# The output will be the 5th line of `file.txt`:

abcDEF___!@#$%^

# To terminate the program, send the EOF (Ctrl + D).

^D

# The output will print the terminate message:

Rust: Process end.

```



For more examples, please refer to the [example repository](https://github.com/second-state/WasmEdge-go-examples/).



## WasmEdge-go Basics



In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.



### Version



The `Version` related APIs provide developers to check for the installed WasmEdge shared library version.



```go

import ""github.com/second-state/WasmEdge-go/wasmedge""



verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.

vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.

verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.

verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.

```



### Logging Settings



The `wasmedge.SetLogErrorLevel()` and `wasmedge.SetLogDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



### Value Types



In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.



1. Number types: `i32`, `i64`, `f32`, and `f64`



   - Convert the `uint32` and `int32` to `i32` automatically when passing a value into WASM.

   - Convert the `uint64` and `int64` to `i64` automatically when passing a value into WASM.

   - Convert the `uint` and `int` to `i32` automatically when passing a value into WASM in 32-bit system.

   - Convert the `uint` and `int` to `i64` automatically when passing a value into WASM in 64-bit system.

   - Convert the `float32` to `f32` automatically when passing a value into WASM.

   - Convert the `float64` to `f64` automatically when passing a value into WASM.

   - Convert the `i32` from WASM to `int32` when getting a result.

   - Convert the `i64` from WASM to `int64` when getting a result.

   - Convert the `f32` from WASM to `float32` when getting a result.

   - Convert the `f64` from WASM to `float64` when getting a result.



2. Number type: `v128` for the `SIMD` proposal



   Developers should use the `wasmedge.NewV128()` to generate a `v128` value, and use the `wasmedge.GetV128()` to get the value.



   ```go

   val := wasmedge.NewV128(uint64(1234), uint64(5678))

   high, low := val.GetVal()

   // `high` will be uint64(1234), `low` will be uint64(5678)

   ```



3. Reference types: `FuncRef` and `ExternRef` for the `Reference-Types` proposal



   ```go

   funcref := wasmedge.NewFuncRef(10)

   // Create a `FuncRef` with function index 10.



   num := 1234

   // `num` is a `int`.

   externref := wasmedge.NewExternRef(&num)

   // Create an `ExternRef` which reference to the `num`.

   num = 5678

   // Modify the `num` to 5678.

   numref := externref.GetRef().(*int)

   // Get the original reference from the `ExternRef`.

   fmt.Println(*numref)

   // Will print `5678`.

   numref.Release()

   // Should call the `Release` method.

   ```



### Results



The `Result` object specifies the execution status. Developers can use the `Error()` function to get the error message.



```go

// Assume that `vm` is a `wasmedge.VM` object.

res, err = vm.Execute(...) // Ignore the detail of parameters.

// Assume that `res, err` are the return values for executing a function with `vm`.

if err != nil {

  fmt.Println(""Error message:"", err.Error())

}

```



### Contexts And Their Life Cycles



The objects, such as `VM`, `Store`, and `Function`, etc., are composed of `Context`s in the WasmEdge shared library. All of the contexts can be created by calling the corresponding `New` APIs, developers should also call the corresponding `Release` functions of the contexts to release the resources. Noticed that it's not necessary to call the `Release` functions for the contexts which are retrieved from other contexts but not created from the `New` APIs.



```go

// Create a Configure.

conf := wasmedge.NewConfigure()

// Release the `conf` immediately.

conf.Release()

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `Limit` struct presents the minimum and maximum value data structure.



   ```go

   lim1 := wasmedge.NewLimit(12)

   fmt.Println(lim1.HasMax())

   // Will print `false`.

   fmt.Println(lim1.GetMin())

   // Will print `12`.



   lim2 := wasmedge.NewLimitWithMax(15, 50)

   fmt.Println(lim2.HasMax())

   // Will print `true`.

   fmt.Println(lim2.GetMin())

   // Will print `15`.

   fmt.Println(lim2.GetMax())

   // Will print `50`.

   ```



2. Function type context



   The `FunctionType` is an object holds the function type context and used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `FunctionType` APIs to get the parameter or return value types information.



   ```go

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{

       wasmedge.ValType_ExternRef,

       wasmedge.ValType_I32,

       wasmedge.ValType_I64,

     }, []wasmedge.ValType{

       wasmedge.ValType_F32,

       wasmedge.ValType_F64,

     })



   plen := functype.GetParametersLength()

   // `plen` will be 3.

   rlen := functype.GetReturnsLength()

   // `rlen` will be 2.

   plist := functype.GetParameters()

   // `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.

   rlist := functype.GetReturns()

   // `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.



   functype.Release()

   ```



3. Table type context



   The `TableType` is an object holds the table type context and used for `Table` instance creation or getting information from `Table` instances.



   ```go

   lim := wasmedge.NewLimit(12)

   tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)



   rtype := tabtype.GetRefType()

   // `rtype` will be `wasmedge.RefType_ExternRef`.

   getlim := tabtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   tabtype.Release()

   ```



4. Memory type context



   The `MemoryType` is an object holds the memory type context and used for `Memory` instance creation or getting information from `Memory` instances.



   ```go

   lim := wasmedge.NewLimit(1)

   memtype := wasmedge.NewMemoryType(lim)



   getlim := memtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   memtype.Release()

   ```



5. Global type context



   The `GlobalType` is an object holds the global type context and used for `Global` instance creation or getting information from `Global` instances.



   ```go

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)



   vtype := globtype.GetValType()

   // `vtype` will be `wasmedge.ValType_F64`.

   vmut := globtype.GetMutability()

   // `vmut` will be `wasmedge.ValMut_Var`.



   globtype.Release()

   ```



6. Import type context



   The `ImportType` is an object holds the import type context and used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `ImportType` object. The details about querying `ImportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   imptypelist := ast.ListImports()

   // Assume that `imptypelist` is an array listed from the `ast` for the imports.



   for i, imptype := range imptypelist {

     exttype := imptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     modname := imptype.GetModuleName()

     extname := imptype.GetExternalName()

     // Get the module name and external name of the imports.



     extval := imptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



7. Export type context



   The `ExportType` is an object holds the export type context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `ExportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   exptypelist := ast.ListExports()

   // Assume that `exptypelist` is an array listed from the `ast` for the exports.



   for i, exptype := range exptypelist {

     exttype := exptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     extname := exptype.GetExternalName()

     // Get the external name of the exports.



     extval := exptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `wasmedge.Async` object. Developers own the object and should call the `(*Async).Release()` API to release it.



1. Get the execution result of the asynchronous execution



   Developers can use the `(*Async).GetResult()` API to block and wait for getting the return values. This function will block and wait for the execution. If the execution has finished, this function will return immediately. If the execution failed, this function will return an error.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution and get the return values.

   res, err := async.GetResult()

   async.Release()

   ```



2. Wait for the asynchronous execution with timeout settings



   Besides waiting until the end of execution, developers can set the timeout to wait for.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution with the timeout(ms).

   isend := async.WaitFor(1000)

   if isend {

     res, err := async.GetResult()

     // ...

   } else {

     async.Cancel()

     _, err := async.GetResult()

     // The error message in `err` will be ""execution interrupted"".

   }

   async.Release()

   ```



### Configurations



The configuration object, `wasmedge.Configure`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` object to create other runtime objects.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` object.



   ```go

   const (

     IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)

     NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)

     SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)

     MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)

     BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)

     REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)

     SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)

     TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)

     ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)

     MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)

     THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)

     EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)

     FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)

   )

   ```



   Developers can add or remove the proposals into the `Configure` object.



   ```go

   // By default, the following proposals have turned on initially:

   // * IMPORT_EXPORT_MUT_GLOBALS

   // * NON_TRAP_FLOAT_TO_INT_CONVERSIONS

   // * SIGN_EXTENSION_OPERATORS

   // * MULTI_VALUE

   // * BULK_MEMORY_OPERATIONS

   // * REFERENCE_TYPES

   // * SIMD

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)

   conf.AddConfig(wasmedge.SIMD)

   conf.RemoveConfig(wasmedge.REFERENCE_TYPES)

   is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)

   // The `is_bulkmem` will be `true`.

   conf.Release()

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` or `wasmedge_process` supports and only effective in `VM` objects.



   ```go

   const (

     WASI             = HostRegistration(C.WasmEdge_HostRegistration_Wasi)

     WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)

   )

   ```



   The details will be introduced in the [preregistrations of VM context](#preregistrations).



   ```go

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.WASI)

   conf.AddConfig(wasmedge.WASI)

   conf.Release()

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` objects.



   ```go

   conf := wasmedge.NewConfigure()



   pagesize := conf.GetMaxMemoryPage()

   // By default, the maximum memory page size in each memory instances is 65536.

   conf.SetMaxMemoryPage(1234)

   pagesize := conf.GetMaxMemoryPage()

   // `pagesize` will be 1234.



   conf.Release()

   ```



4. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```go

   const (

     // Disable as many optimizations as possible.

     CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

     // Optimize quickly without destroying debuggability.

     CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

     // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

     CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

     // Optimize for fast execution as much as possible.

     CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

     // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

     CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

     // Optimize for small code size as much as possible.

     CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

   )



   const (

     // Native dynamic library format.

     CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

     // WebAssembly with AOT compiled codes in custom section.

     CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

   )

   ```



   These configurations are only effective in `Compiler` contexts.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the optimization level is O3.

   conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)

   // By default, the output format is universal WASM.

   conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)

   // By default, the dump IR is `false`.

   conf.SetCompilerDumpIR(true)

   // By default, the generic binary is `false`.

   conf.SetCompilerGenericBinary(true)



   conf.Release()

   ```



5. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` objects.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsInstructionCounting(true)

   // By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsTimeMeasuring(true)

   // By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsCostMeasuring(true)



   conf.Release()

   ```



### Statistics



The statistics object, `wasmedge.Statistics`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` object from the `VM` object, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```go

   stat := wasmedge.NewStatistics()

   // ... After running the WASM functions with the `Statistics` object



   count := stat.GetInstrCount()

   ips := stat.GetInstrPerSecond()

   stat.Release()

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` object. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   stat := wasmedge.NewStatistics()



   costtable := []uint64{

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0,

   }

   // Developers can set the costs of each instruction. The value not covered will be 0.



   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   stat.SetCostTable()

   stat.SetCostLimit(5000000)



   // ... After running the WASM functions with the `Statistics` object

   cost := stat.GetTotalCost()

   stat.Release()

   ```



## WasmEdge VM



In this partition, we will introduce the functions of `wasmedge.VM` object and show examples of executing WASM functions.



### WASM Execution Example With VM Object



The following shows the example of running the WASM for getting the Fibonacci. This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



```wasm

(module

 (export ""fib"" (func $fib))

 (func $fib (param $n i32) (result i32)

  (if

   (i32.lt_s (get_local $n)(i32.const 2))

   (return (i32.const 1))

  )

  (return

   (i32.add

    (call $fib (i32.sub (get_local $n)(i32.const 2)))

    (call $fib (i32.sub (get_local $n)(i32.const 1)))

   )

  )

 )

)

```



1. Run WASM functions rapidly



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current `wasmedge_test` directory, and create and edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create the configure context and add the WASI support.

     // This step is not necessary unless you need WASI support.

     conf := wasmedge.NewConfigure(wasmedge.WASI)

     // Create VM with the configure.

     vm := wasmedge.NewVMWithConfig(conf)



     res, err := vm.RunWasmFile(""fibonacci.wasm"", ""fib"", uint32(21))

     if err == nil {

       fmt.Println(""Get fibonacci[21]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

     conf.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

   $ go build

   $ ./wasmedge_test

   Get fibonacci[21]: 17711

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` object APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create VM.

     vm := wasmedge.NewVM()

     var err error

     var res []interface{}



     // Step 1: Load WASM file.

     err = vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     // Developers can load, validate, and instantiate another WASM module

     // to replace the instantiated one. In this case, the old module will

     // be cleared, but the registered modules are still kept.

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Execute WASM functions. Parameters: (funcname, args...)

     res, err = vm.Execute(""fib"", uint32(25))

     // Developers can execute functions repeatedly after instantiation.

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



   The following graph explains the status of the `VM` object.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered,

                   ExecuteBindgen, ExecuteBindgenRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or import objects in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation APIs accepts the `Configure` object and the `Store` object. Noticed that if the `VM` created with the outside `Store` object, the `VM` will execute WASM on that `Store` object. If the `Store` object is set into multiple `VM` objects, it may causes data conflict when in execution. The details of the `Store` object will be introduced in [Store](#store).



```go

conf := wasmedge.NewConfigure()

store := wasmedge.NewStore()



// Create a VM with default configure and store.

vm := wasmedge.NewVM()

vm.Release()



// Create a VM with the specified configure and default store.

vm = wasmedge.NewVMWithConfig(conf)

vm.Release()



// Create a VM with the default configure and specified store.

vm = wasmedge.NewVMWithStore(store)

vm.Release()



// Create a VM with the specified configure and store.

vm = wasmedge.NewVMWithConfigAndStore(conf, store)

vm.Release()



conf.Release()

store.Release()

```



### Preregistrations



WasmEdge provides the following built-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` object.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WASI)

   // Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.

   vm := wasmedge.NewVMWithConfig(conf)

   vm.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   wasiconf := conf.GetImportObject(wasmedge.WASI)

   // Initialize the WASI.

   wasiconf.InitWasi(/* ... ignored */)



   conf.Release()

   ```



   And also can create the WASI import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. [WasmEdge_Process](https://crates.io/crates/wasmedge_process_interface)



   This pre-registration is for the process interface for WasmEdge on `Rust` sources. After turning on this pre-registration, the VM will support the `wasmedge_process` host functions.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)

   vm := wasmedge.NewVMWithConfig(conf)

   vm.Release()



   // The following API can retrieve the pre-registration import objects from the VM object.

   // This API will return `nil` if the corresponding pre-registration is not set into the configuration.

   procconf := conf.GetImportObject(wasmedge.WasmEdge_PROCESS)

   // Initialize the WasmEdge_Process.

   procconf.InitWasmEdgeProcess(/* ... ignored */)



   conf.Release()

   ```



   And also can create the WasmEdge_Process import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge-go, the host functions are composed into host modules as `ImportObject` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` object.



```go

vm := wasmedge.NewVM()

// You can also create and register the WASI host modules by this API.

wasiobj := wasmedge.NewWasiImportObject(/* ... ignored ... */)



res := vm.RegisterImport(wasiobj)

// The result status should be checked.



vm.Release()

// The created import objects should be released.

wasiobj.Release()

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory. Then create and edit the Go file `main.go` as following:



   ```go

   package main



   import ""github.com/second-state/WasmEdge-go/wasmedge""



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var err error

     err = vm.RegisterWasmFile(""module_name"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     // The result status should be checked. The error will occur if the

     // WASM module instantiation failed or the module name conflicts.



     vm.Release()

   }

   ```



2. Execute the functions in registered WASM modules



   Edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var res []interface{}

     var err error

     // Register the WASM module from file into VM with the module name ""mod"".

     err = vm.RegisterWasmFile(""mod"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     if err != nil {

       fmt.Println(""WASM registration failed:"", err.Error())

       return

     }

     // The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

     // name ""mod"". As the same as host functions, other modules can import the

     // function `""mod"" ""fib""`.



     // Execute WASM functions in registered modules.

     // Unlike the execution of functions, the registered functions can be

     // invoked without `(*VM).Instantiate` because the WASM module was

     // instantiated when registering.

     // Developers can also invoke the host functions directly with this API.

     res, err = vm.ExecuteRegistered(""mod"", ""fib"", int32(25))

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.

     async := vm.AsyncRunWasmFile(""fibonacci.wasm"", ""fib"", uint32(20))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

   $ go build

   $ ./wasmedge_test

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     var err error

     var res []interface{}



     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,

     // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.

     async := vm.AsyncExecute(""fib"", uint32(25))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

   $ go build

   $ ./wasmedge_test

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` object supplies the APIs to retrieve the instances.



1. Store



   If the `VM` object is created without assigning a `Store` object, the `VM` context will allocate and own a `Store`.



   ```go

   vm := wasmedge.NewVM()

   store := vm.GetStore()

   // The object should __NOT__ be deleted by calling `(*Store).Release`.

   vm.Release()

   ```



   Developers can also create the `VM` object with a `Store` object. In this case, developers should guarantee that the `Store` object cannot be released before the `VM` object. Please refer to the [Store Objects](#store) for the details about the `Store` APIs.



   ```go

   store := wasmedge.NewStore()

   vm := wasmedge.NewVMWithStore(store)



   storemock := vm.GetStore()

   // The internal store context of the `store` and the `storemock` are the same.



   vm.Release()

   store.Release()

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `(*VM).Execute` function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // List the exported functions for the names and function types.

     funcnames, functypes := vm.GetFunctionList()

     for _, fname := range funcnames {

       fmt.Println(""Exported function name:"", fname)

     }

     for _, ftype := range functypes {

       // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.

       // Developers should __NOT__ call the `ftype.Release()`.

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

   $ go build

   $ ./wasmedge_test

   Exported function name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` object from the `VM` object and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` object provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   functype := vm.GetFunctionType(""fib"")

   // Developers can get the function types of functions in the registered modules via the

   // `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.

   // If the function is not found, these APIs will return `nil`.

   // Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` object](#wasmedge-vm) rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` objects.



Assume that a new Go project is created as following:



```bash

mkdir wasmedge_test && cd wasmedge_test

go mod init wasmedge_test

```



Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



```go

package main



import (

  ""fmt""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  // Set the logging level to debug to print the statistics info.

  wasmedge.SetLogDebugLevel()

  // Create the configure object. This is not necessary if developers use the default configuration.

  conf := wasmedge.NewConfigure()

  // Turn on the runtime instruction counting and time measuring.

  conf.SetStatisticsInstructionCounting(true)

  conf.SetStatisticsTimeMeasuring(true)

  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.

  stat := wasmedge.NewStatistics()

  // Create the store object. The store object is the WASM runtime structure core.

  store := wasmedge.NewStore()



  var err error

  var res []interface{}

  var ast *wasmedge.AST



  // Create the loader object.

  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

  loader := wasmedge.NewLoaderWithConfig(conf)

  // Create the validator object.

  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

  validator := wasmedge.NewValidatorWithConfig(conf)

  // Create the executor object.

  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.

  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)



  // Load the WASM file or the compiled-WASM file and convert into the AST module object.

  ast, err = loader.LoadFile(""fibonacci.wasm"")

  if err != nil {

    fmt.Println(""Load WASM from file FAILED:"", err.Error())

    return

  }

  // Validate the WASM module.

  err = validator.Validate(ast)

  if err != nil {

    fmt.Println(""Validation FAILED:"", err.Error())

    return

  }

  // Instantiate the WASM module into the Store object.

  err = executor.Instantiate(store, ast)

  if err != nil {

    fmt.Println(""Instantiation FAILED:"", err.Error())

    return

  }



  // Try to list the exported functions of the instantiated WASM module.

  funcnames := store.ListFunction()

  for _, fname := range funcnames {

    fmt.Println(""Exported function name:"", fname)

  }



  // Invoke the WASM function.

  res, err = executor.Invoke(store, ""fib"", int32(30))

  if err == nil {

    fmt.Println(""Get fibonacci[30]:"", res[0].(int32))

  } else {

    fmt.Println(""Run failed:"", err.Error())

  }



  // Resources deallocations.

  conf.Release()

  stat.Release()

  ast.Release()

  loader.Release()

  validator.Release()

  executor.Release()

  store.Release()

}

```



Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)



```bash

$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

$ go build

$ ./wasmedge_test

Exported function name: fib

[2021-11-24 18:53:01.451] [debug]  Execution succeeded.

[2021-11-24 18:53:01.452] [debug]

 ====================  Statistics  ====================

 Total execution time: 556372295 ns

 Wasm instructions execution time: 556372295 ns

 Host functions execution time: 0 ns

 Executed wasm instructions count: 28271634

 Gas costs: 0

 Instructions per second: 50814237

Get fibonacci[30]: 1346269

```



### Loader



The `Loader` object loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```go

var buf []byte

// ... Read the WASM code to the `buf`.



// Developers can adjust settings in the configure object.

conf := wasmedge.NewConfigure()

// Create the loader object.

// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

loader := wasmedge.NewLoaderWithConfig(conf)

conf.Release()



// Load WASM or compiled-WASM from the file.

ast, err := loader.LoadFile(""fibonacci.wasm"")

if err != nil {

  fmt.Println(""Load WASM from file FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



// Load WASM or compiled-WASM from the buffer

ast, err = loader.LoadBuffer(buf)

if err != nil {

  fmt.Println(""Load WASM from buffer FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



loader.Release()

```



### Validator



The `Validator` object can validate the WASM module. Every WASM module should be validated before instantiation.



```go

// ...

// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.

// Assume that the `conf` is the `*wasmedge.Configure` object.



// Create the validator context.

// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

validator := wasmedge.NewValidatorWithConfig(conf)



err := validator.Validate(ast)

if err != nil {

  fmt.Println(""Validation FAILED:"", err.Error())

}



validator.Release()

```



### Executor



The `Executor` object is the executor for both WASM and compiled-WASM. This object should work base on the `Store` object. For the details of the `Store` object, please refer to the [next chapter](#store).



1. Register modules



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` objects, developers can register `ImportObject` or `AST` objects into the `Store` object by the `Executor` APIs. For the details of import objects, please refer to the [Host Functions](#host-functions)).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Register the loaded WASM `ast` into store with the export module name ""mod"".

   res := executor.RegisterModule(store, ast, ""mod"")

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // Assume that the `impobj` is the `*wasmedge.ImportObject` for host functions.

   impobj := ...

   err = executor.RegisterImport(store, impobj)

   if err != nil {

     fmt.Println(""Import object registration FAILED:"", err.Error())

     return

   }



   executor.Release()

   stat.Release()

   store.Release()

   impobj.Release()

   ```



2. Instantiate modules



   WASM or compiled-WASM modules should be instantiated before the function invocation. Note that developers can only instantiate one module into the `Store` object, and in that case, the old instantiated module will be cleaned. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` object.



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Instantiate the WASM module.

   err := executor.Instantiate(stpre, ast)

   if err != nil {

     fmt.Println(""WASM instantiation FAILED:"", err.Error())

     return

   }



   executor.Release()

   stat.Release()

   store.Release()

   ```



3. Invoke functions



   As the same as function invocation via the `VM` object, developers can invoke the functions of the instantiated or registered modules. The APIs, `(*Executor).Invoke` and `(*Executor).InvokeRegistered`, are similar as the APIs of the `VM` object. Please refer to the [VM context workflows](#wasm-execution-example-with-vm-object) for details.



### AST Module



The `AST` object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST` object.



```go

ast := ...

// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.



// List the imports.

imports := ast.ListImports()

for _, import := range imports {

  fmt.Println(""Import:"", import.GetModuleName(), import.GetExternalName())

}



// List the exports.

exports := ast.ListExports()

for _, export := range exports {

  fmt.Println(""Export:"", export.GetExternalName())

}



ast.Release()

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all instances of `Function`s, `Table`s, `Memory`s, and `Global`s that have been allocated during the lifetime of the abstract machine. The `Store` object in WasmEdge-go provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into `Store` objects, please instantiate or register WASM modules or `ImportObject` objects via the `Executor` APIs.



1. List instances



   ```go

   store := wasmedge.NewStore()

   // ...

   // Instantiate a WASM module via the `*wasmedge.Executor` object.

   // ...



   // Try to list the exported functions of the instantiated WASM module.

   // Take the function instances for example here.

   funcnames := store.ListFunction()

   for _, name := range funcnames {

     fmt.Println(""Exported function name:"", name)

   }



   store.Release()

   ```



   Developers can list the function instance exported names of the registered modules via the `(*Store).ListFunctionRegistered()` API with the module name.



2. Find instances



   ```go

   store := wasmedge.NewStore()

   // ...

   // Instantiate a WASM module via the `*wasmedge.Executor` object.

   // ...



   // Try to find the exported functions of the instantiated WASM module.

   // Take the function instances for example here.

   funcobj := store.FindFunction(""fib"")

   // `funcobj` will be `nil` if the function not found.



   store.Release()

   ```



   Developers can retrieve the exported function instances of the registered modules via the `(*Store).FindFunctionRegistered` API with the module name.



3. List registered modules



   With the module names, developers can list the exported instances of the registered modules with their names.



   ```go

   store := wasmedge.NewStore()

   // ...

   // Instantiate a WASM module via the `*wasmedge.Executor` object.

   // ...



   // Try to list the registered WASM modules.

   modnames := store.ListModule()

   for _, name := range modnames {

     fmt.Println(""Registered module names:"", name)

   }



   store.Release()

   ```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the instances from the `Store` objects. The `Store` objects will allocate instances when a WASM module or an `ImportObject` is registered or instantiated through the `Executor`. A single instance can be allocated by its creation function. Developers can construct instances into an `ImportObject` for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed, EXCEPT they are added into an `ImportObject` object.



1. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` objects for host functions and add them into an `ImportObject` object for registering into a `VM` or a `Store`. For both host functions and the functions get from `Store`, developers can retrieve the `FunctionType` from the `Function` objects. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```go

   funcinst := ...

   // `funcobj` is the `*wasmedge.Function` retrieved from the store object.

   functype := funcobj.GetFunctionType()

   // The `funcobj` retrieved from the store object should __NOT__ be released.

   // The `functype` retrieved from the `funcobj` should __NOT__ be released.

   ```



2. Table instance



   In WasmEdge, developers can create the `Table` objects and add them into an `ImportObject` object for registering into a `VM` or a `Store`. The `Table` objects supply APIs to control the data in table instances.



   ```go

   lim := wasmedge.NewLimitWithMax(10, 20)

   // Create the table type with limit and the `FuncRef` element type.

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)

   // Create the table instance with table type.

   tabinst := wasmedge.NewTable(tabtype)

   // Delete the table type.

   tabtype.Release()



   gottabtype := tabinst.GetTableType()

   // The `gottabtype` got from table instance is owned by the `tabinst`

   // and should __NOT__ be released.

   reftype := gottabtype.GetRefType()

   // The `reftype` will be `wasmedge.RefType_FuncRef`.



   var gotdata interface{}

   data := wasmedge.NewFuncRef(5)

   err := tabinst.SetData(data, 3)

   // Set the function index 5 to the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   err = tabinst.SetData(data, 13)



   gotdata, err = tabinst.GetData(3)

   // Get the FuncRef value of the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   gotdata, err = tabinst.GetData(13)



   tabsize := tabinst.GetSize()

   // `tabsize` will be 10.

   err = tabinst.Grow(6)

   // Grow the table size of 6, the table size will be 16.



   // The following line will get an ""out of bounds table access"" error

   // because the size (16 + 6) will reach the table limit (20):

   //   err = tabinst.Grow(6)



   tabinst.Release()

   ```



3. Memory instance



   In WasmEdge, developers can create the `Memory` objects and add them into an `ImportObject` object for registering into a `VM` or a `Store`. The `Memory` objects supply APIs to control the data in memory instances.



   ```go

   lim := wasmedge.NewLimitWithMax(1, 5)

   // Create the memory type with limit. The memory page size is 64KiB.

   memtype := wasmedge.NewMemoryType(lim)

   // Create the memory instance with memory type.

   meminst := wasmedge.NewMemory(memtype)

   // Delete the memory type.

   memtype.Release()



   data := []byte(""A quick brown fox jumps over the lazy dog"")

   err := meminst.SetData(data, 0x1000, 10)

   // Set the data[0:9] to the memory[4096:4105].



   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   err = meminst.SetData(data, 0xFFFF, 10)



   var gotdata []byte

   gotdata, err = meminst.GetData(0x1000, 10)

   // Get the memory[4096:4105]. The `gotdata` will be `[]byte(""A quick br"").

   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   gotdata, err = meminst.Getdata(0xFFFF, 10)



   pagesize := meminst.GetPageSize()

   // `pagesize` will be 1.

   err = meminst.GrowPage(2)

   // Grow the page size of 2, the page size of the memory instance will be 3.



   // The following line will get an ""out of bounds memory access"" error

   // because the size (3 + 3) will reach the memory limit (5):

   //   err = meminst.GetPageSize(3)



   meminst.Release()

   ```



4. Global instance



   In WasmEdge, developers can create the `Global` objects and add them into an `ImportObject` object for registering into a `VM` or a `Store`. The `Global` objects supply APIs to control the value in global instances.



   ```go

   // Create the global type with value type and mutation.

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)

   // Create the global instance with value and global type.

   globinst := wasmedge.NewGlobal(globtype, uint64(1000))

   // Delete the global type.

   globtype.Release()



   gotglobtype := globinst.GetGlobalType()

   // The `gotglobtype` got from global instance is owned by the `globinst`

   // and should __NOT__ be released.

   valtype := gotglobtype.GetValType()

   // The `valtype` will be `wasmedge.ValType_I64`.

   valmut := gotglobtype.GetMutability()

   // The `valmut` will be `wasmedge.ValMut_Var`.



   globinst.SetValue(uint64(888))

   // Set the value u64(888) to the global.

   // This function will do nothing if the value type mismatched or the

   // global mutability is `wasmedge.ValMut_Const`.

   gotval := globinst.GetValue()

   // The `gotbal` will be `interface{}` which the type is `uint64` and

   // the value is 888.



   globinst.Release()

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge-go, developers can create the `Function`, `Memory`, `Table`, and `Global` objects and add them into an `ImportObject` object for registering into a `VM` or a `Store`.



1. Host function allocation



   Developers can define Go functions with the following function signature as the host function body:



   ```go

   type hostFunctionSignature func(

       data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```go

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }

   ```



   Then developers can create `Function` object with the host function body and function type:



   ```go

   // Create a function type: {i32, i32} -> {i32}.

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )



   // Create a function context with the function type and host function body.

   // The third parameter is the pointer to the additional data.

   // Developers should guarantee the life cycle of the data, and it can be

   // `nil` if the external data is not needed.

   // The last parameter can be 0 if developers do not need the cost measuring.

   func_add := wasmedge.NewFunction(functype, host_add, nil, 0)



   // If the function object is not added into an import object object, it should be released.

   func_add.Release()

   functype.Release()

   ```



2. Import object object



   The `ImportObject` object holds an exporting module name and the instances. Developers can add the `Function`, `Memory`, `Table`, and `Global` instances with their exporting names.



   ```go

   // Host function body definition.

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   // Create the import object with the module name ""module"".

   impobj := wasmedge.NewImportObject(""module"")



   // Create and add a function instance into the import object with export name ""add"".

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )

   hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

   functype.Release()

   impobj.AddFunction(""add"", hostfunc)



   // Create and add a table instance into the import object with export name ""table"".

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))

   hosttab := wasmedge.NewTable(tabtype)

   tabtype.Release()

   impobj.AddTable(""table"", hosttab)



   // Create and add a memory instance into the import object with export name ""memory"".

   memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))

   hostmem := wasmedge.NewMemory(memtype)

   memtype.Release()

   impobj.AddMemory(""memory"", hostmem)



   // Create and add a global instance into the import object with export name ""global"".

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)

   hostglob := wasmedge.NewGlobal(globtype, uint32(666))

   globtype.Release()

   impobj.AddGlobal(""global"", hostglob)



   // The import objects should be released.

   // Developers should __NOT__ release the instances added into the import object objects.

   impobj.Release()

   ```



3. Specified import object



   `wasmedge.NewWasiImportObject()` API can create and initialize the `WASI` import object. `wasmedge.NewWasmEdgeProcessImportObject()` API can create and initialize the `wasmedge_process` import object. Developers can create these import object objects and register them into the `Store` or `VM` objects rather than adjust the settings in the `Configure` objects.



   ```go

   wasiobj := wasmedge.NewWasiImportObject(

     os.Args[1:],     // The args

     os.Environ(),    // The envs

     []string{"".:.""}, // The mapping preopens

   )

   procobj := wasmedge.NewWasmEdgeProcessImportObject(

     []string{""ls"", ""echo""}, // The allowed commands

     false,                  // Not to allow all commands

   )



   // Register the WASI and WasmEdge_Process into the VM object.

   vm := wasmedge.NewVM()

   vm.RegisterImport(wasiobj)

   vm.RegisterImport(procobj)



   // ... Execute some WASM functions.



   // Get the WASI exit code.

   exitcode := wasiobj.WasiGetExitCode()

   // The `exitcode` will be 0 if the WASI function ""_start"" execution has no error.

   // Otherwise, it will return with the related exit code.



   vm.Release()

   // The import objects should be deleted.

   wasiobj.Release()

   procobj.Release()

   ```



4. Example



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that there is a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   Create and edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // Create the import object with the module name ""extern"".

     impobj := wasmedge.NewImportObject(""extern"")



     // Create and add a function instance into the import object with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

     functype.Release()

     impobj.AddFunction(""func-add"", hostfunc)



     // Register the import object into VM.

     vm.RegisterImport(impobj)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }



     impobj.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   ```



5. Host Data Example



   Developers can set a external data object to the function object, and access to the object in the function body. Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Also set the result to the data.

     *data.(*int32) = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // The additional data to set into the host function.

     var data int32 = 0



     // Create the import object with the module name ""extern"".

     impobj := wasmedge.NewImportObject(""extern"")



     // Create and add a function instance into the import object with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)

     functype.Release()

     impobj.AddFunction(""func-add"", hostfunc)



     // Register the import object into VM.

     vm.RegisterImport(impobj)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     fmt.Println(""Data value:"", data)



     impobj.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   Data value: 6912

   ```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options in Go. WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) provide a tool for compiling a WASM file.



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```go

const (

  // Disable as many optimizations as possible.

  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

  // Optimize quickly without destroying debuggability.

  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

  // Optimize for fast execution as much as possible.

  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

  // Optimize for small code size as much as possible.

  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

)



const (

  // Native dynamic library format.

  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

  // WebAssembly with AOT compiled codes in custom section.

  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

)

```



Please refer to the [AOT compiler options configuration](#configurations) for details.








------"
"The following is a markdown document located at /embed/go/reference/latest.md
------


---

sidebar_position: 1

---



# Go API v0.13.4 Documentation



The following are the guides to working with the WasmEdge-Go SDK.



## Getting Started



The WasmEdge-go requires golang version >= 1.16. Please check your golang version before installation. Developers can [download golang here](https://golang.org/dl/).



```bash

$ go version

go version go1.16.5 linux/amd64

```



### WasmEdge Installation



Developers must [install the WasmEdge shared library](../../../start/install.md#install) with the same `WasmEdge-go` release or pre-release version.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}

```



For the developers need the `TensorFlow` or `Image` extension for `WasmEdge-go`, please install the `WasmEdge` with extensions:



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v {{ wasmedge_go_version }}

```



Noticed that the `TensorFlow` and `Image` extensions are only for the `Linux` platforms. After installation, developers can use the `source` command to update the include and linking searching path.



### Get WasmEdge-go



After the WasmEdge installation, developers can get the `WasmEdge-go` package and build it in your Go project directory.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

go build

```



<!-- prettier-ignore -->

:::note

The WasmEdge-Go version number should match the installed WasmEdge version.

:::



### Example Repository



Developers can refer to [the example repository](https://github.com/second-state/WasmEdge-go-examples/) for the WasmEdge-Go examples.



## WasmEdge-go Basics



In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.



### Version



The `Version` related APIs provide developers to check for the installed WasmEdge shared library version.



```go

import ""github.com/second-state/WasmEdge-go/wasmedge""



verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.

vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.

verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.

verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.

```



### Logging Settings



The `wasmedge.SetLogErrorLevel()` and `wasmedge.SetLogDebugLevel()` APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.



Developers can also use the `wasmedge.SetLogOff()` API to disable all logging.



### Value Types



In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.



1. Number types: `i32`, `i64`, `f32`, and `f64`



   - Convert the `uint32` and `int32` to `i32` automatically when passing a value into WASM.

   - Convert the `uint64` and `int64` to `i64` automatically when passing a value into WASM.

   - Convert the `uint` and `int` to `i32` automatically when passing a value into WASM in 32-bit system.

   - Convert the `uint` and `int` to `i64` automatically when passing a value into WASM in 64-bit system.

   - Convert the `float32` to `f32` automatically when passing a value into WASM.

   - Convert the `float64` to `f64` automatically when passing a value into WASM.

   - Convert the `i32` from WASM to `int32` when getting a result.

   - Convert the `i64` from WASM to `int64` when getting a result.

   - Convert the `f32` from WASM to `float32` when getting a result.

   - Convert the `f64` from WASM to `float64` when getting a result.



2. Number type: `v128` for the `SIMD` proposal



   Developers should use the `wasmedge.NewV128()` to generate a `v128` value, and use the `wasmedge.GetV128()` to get the value.



   ```go

   val := wasmedge.NewV128(uint64(1234), uint64(5678))

   high, low := val.GetVal()

   // `high` will be uint64(1234), `low` will be uint64(5678)

   ```



3. Reference types: `FuncRef` and `ExternRef` for the `Reference-Types` proposal



   ```go

   var funccxt *wasmedge.Function = ... // Create or get function object.

   funcref := wasmedge.NewFuncRef(funccxt)

   // Create a `FuncRef` with the function object.



   num := 1234

   // `num` is a `int`.

   externref := wasmedge.NewExternRef(&num)

   // Create an `ExternRef` which reference to the `num`.

   num = 5678

   // Modify the `num` to 5678.

   numref := externref.GetRef().(*int)

   // Get the original reference from the `ExternRef`.

   fmt.Println(*numref)

   // Will print `5678`.

   numref.Release()

   // Should call the `Release` method.

   ```



### Results



The `Result` object specifies the execution status. Developers can use the `Error()` function to get the error message.



```go

// Assume that `vm` is a `wasmedge.VM` object.

res, err = vm.Execute(...) // Ignore the detail of parameters.

// Assume that `res, err` are the return values for executing a function with `vm`.

if err != nil {

  fmt.Println(""Error message:"", err.Error())

  category := err.GetErrorCategory()

  // The `category` will be `wasmedge.ErrCategory_WASM`.

}



userdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)

// Generate the user-defined error with code.

code := userdef_err.GetCode()

// The `Code` will be 123456.

```



### Contexts And Their Life Cycles



The objects, such as `VM`, `Store`, and `Function`, etc., are composed of `Context`s in the WasmEdge shared library. All of the contexts can be created by calling the corresponding `New` APIs, developers should also call the corresponding `Release` functions of the contexts to release the resources. Noticed that it's not necessary to call the `Release` functions for the contexts which are retrieved from other contexts but not created from the `New` APIs.



```go

// Create a Configure.

conf := wasmedge.NewConfigure()

// Release the `conf` immediately.

conf.Release()

```



The details of other contexts will be introduced later.



### WASM Data Structures



The WASM data structures are used for creating instances or can be queried from instance contexts. The details of instances creation will be introduced in the [Instances](#instances).



1. Limit



   The `Limit` struct presents the minimum and maximum value data structure.



   ```go

   lim1 := wasmedge.NewLimit(12)

   fmt.Println(lim1.HasMax())

   // Will print `false`.

   fmt.Println(lim1.GetMin())

   // Will print `12`.



   lim2 := wasmedge.NewLimitWithMax(15, 50)

   fmt.Println(lim2.HasMax())

   // Will print `true`.

   fmt.Println(lim2.GetMin())

   // Will print `15`.

   fmt.Println(lim2.GetMax())

   // Will print `50`.

   ```



   For the thread proposal, the `Limit` struct also supports the shared memory description.



   ```go

   lim3 := wasmedge.NewLimitShared(20)

   fmt.Println(lim3.HasMax())

   // Will print `false`.

   fmt.Println(lim3.IsShared())

   // Will print `true`.

   fmt.Println(lim3.GetMin())

   // Will print `20`.



   lim4 := wasmedge.NewLimitSharedWithMax(30, 40)

   fmt.Println(lim4.HasMax())

   // Will print `true`.

   fmt.Println(lim4.IsShared())

   // Will print `true`.

   fmt.Println(lim4.GetMin())

   // Will print `30`.

   fmt.Println(lim4.GetMax())

   // Will print `40`.

   ```



2. Function type context



   The `FunctionType` is an object holds the function type context and used for the `Function` creation, checking the value types of a `Function` instance, or getting the function type with function name from VM. Developers can use the `FunctionType` APIs to get the parameter or return value types information.



   ```go

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{

       wasmedge.ValType_ExternRef,

       wasmedge.ValType_I32,

       wasmedge.ValType_I64,

     }, []wasmedge.ValType{

       wasmedge.ValType_F32,

       wasmedge.ValType_F64,

     })



   plen := functype.GetParametersLength()

   // `plen` will be 3.

   rlen := functype.GetReturnsLength()

   // `rlen` will be 2.

   plist := functype.GetParameters()

   // `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.

   rlist := functype.GetReturns()

   // `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.



   functype.Release()

   ```



3. Table type context



   The `TableType` is an object holds the table type context and used for `Table` instance creation or getting information from `Table` instances.



   ```go

   lim := wasmedge.NewLimit(12)

   tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)



   rtype := tabtype.GetRefType()

   // `rtype` will be `wasmedge.RefType_ExternRef`.

   getlim := tabtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   tabtype.Release()

   ```



4. Memory type context



   The `MemoryType` is an object holds the memory type context and used for `Memory` instance creation or getting information from `Memory` instances.



   ```go

   lim := wasmedge.NewLimit(1)

   memtype := wasmedge.NewMemoryType(lim)



   getlim := memtype.GetLimit()

   // `getlim` will be the same value as `lim`.



   memtype.Release()

   ```



5. Global type context



   The `GlobalType` is an object holds the global type context and used for `Global` instance creation or getting information from `Global` instances.



   ```go

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)



   vtype := globtype.GetValType()

   // `vtype` will be `wasmedge.ValType_F64`.

   vmut := globtype.GetMutability()

   // `vmut` will be `wasmedge.ValMut_Var`.



   globtype.Release()

   ```



6. Import type context



   The `ImportType` is an object holds the import type context and used for getting the imports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`), import module name, and external name from an `ImportType` object. The details about querying `ImportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   imptypelist := ast.ListImports()

   // Assume that `imptypelist` is an array listed from the `ast` for the imports.



   for i, imptype := range imptypelist {

     exttype := imptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     modname := imptype.GetModuleName()

     extname := imptype.GetExternalName()

     // Get the module name and external name of the imports.



     extval := imptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



7. Export type context



   The `ExportType` is an object holds the export type context is used for getting the exports information from a [AST Module](#ast-module). Developers can get the external type (`function`, `table`, `memory`, or `global`) and external name from an `Export Type` context. The details about querying `ExportType` objects will be introduced in the [AST Module](#ast-module).



   ```go

   var ast *wasmedge.AST = ...

   // Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.

   exptypelist := ast.ListExports()

   // Assume that `exptypelist` is an array listed from the `ast` for the exports.



   for i, exptype := range exptypelist {

     exttype := exptype.GetExternalType()

     // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,

     // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.



     extname := exptype.GetExternalName()

     // Get the external name of the exports.



     extval := exptype.GetExternalValue()

     // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,

     // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.

   }

   ```



### Async



After calling the [asynchronous execution APIs](#asynchronous-execution), developers will get the `wasmedge.Async` object. Developers own the object and should call the `(*Async).Release()` API to release it.



1. Get the execution result of the asynchronous execution



   Developers can use the `(*Async).GetResult()` API to block and wait for getting the return values. This function will block and wait for the execution. If the execution has finished, this function will return immediately. If the execution failed, this function will return an error.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution and get the return values.

   res, err := async.GetResult()

   async.Release()

   ```



2. Wait for the asynchronous execution with timeout settings



   Besides waiting until the end of execution, developers can set the timeout to wait for.



   ```go

   async := ... // Ignored. Asynchronous execute a function.



   // Blocking and waiting for the execution with the timeout(ms).

   isend := async.WaitFor(1000)

   if isend {

     res, err := async.GetResult()

     // ...

   } else {

     async.Cancel()

     _, err := async.GetResult()

     // The error message in `err` will be ""execution interrupted"".

   }

   async.Release()

   ```



### Configurations



The configuration object, `wasmedge.Configure`, manages the configurations for `Loader`, `Validator`, `Executor`, `VM`, and `Compiler`. Developers can adjust the settings about the proposals, VM host pre-registrations (such as `WASI`), and AOT compiler options, and then apply the `Configure` object to create other runtime objects.



1. Proposals



   WasmEdge supports turning on or off the WebAssembly proposals. This configuration is effective in any contexts created with the `Configure` object.



   ```go

   const (

     IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)

     NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)

     SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)

     MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)

     BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)

     REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)

     SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)

     TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)

     ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)

     MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)

     EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)

     EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)

     THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)

     FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)

   )

   ```



   Developers can add or remove the proposals into the `Configure` object.



   ```go

   // By default, the following proposals have turned on initially:

   // * IMPORT_EXPORT_MUT_GLOBALS

   // * NON_TRAP_FLOAT_TO_INT_CONVERSIONS

   // * SIGN_EXTENSION_OPERATORS

   // * MULTI_VALUE

   // * BULK_MEMORY_OPERATIONS

   // * REFERENCE_TYPES

   // * SIMD

   // For the current WasmEdge version, the following proposals are supported:

   // * TAIL_CALL

   // * MULTI_MEMORIES

   // * THREADS

   // * EXTENDED_CONST

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)

   conf.AddConfig(wasmedge.SIMD)

   conf.RemoveConfig(wasmedge.REFERENCE_TYPES)

   is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)

   // The `is_bulkmem` will be `true`.

   conf.Release()

   ```



2. Host registrations



   This configuration is used for the `VM` context to turn on the `WASI` supports and only effective in `VM` contexts.



   The element of this enum is reserved for the other built-in host functions (such as `wasi-socket`) in the future.



   ```go

   const (

     WASI = HostRegistration(C.WasmEdge_HostRegistration_Wasi)

   )

   ```



   The details will be introduced in the [preregistrations of VM context](#built-in-host-modules-and-plug-in-preregistrations).



   ```go

   conf := wasmedge.NewConfigure()

   // Developers can also pass the proposals as parameters:

   // conf := wasmedge.NewConfigure(wasmedge.WASI)

   conf.AddConfig(wasmedge.WASI)

   conf.Release()

   ```



3. Maximum memory pages



   Developers can limit the page size of memory instances by this configuration. When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail. This configuration is only effective in the `Executor` and `VM` objects.



   ```go

   conf := wasmedge.NewConfigure()



   pagesize := conf.GetMaxMemoryPage()

   // By default, the maximum memory page size in each memory instances is 65536.

   conf.SetMaxMemoryPage(1234)

   pagesize = conf.GetMaxMemoryPage()

   // `pagesize` will be 1234.



   conf.Release()

   ```



4. Forcibly interpreter mode



   If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration.



   ```go

   conf := wasmedge.NewConfigure()



   is_forceinterp := conf.IsForceInterpreter()

   // By default, the `is_forceinterp` will be `false`.

   conf.SetForceInterpreter(true)

   is_forceinterp = conf.IsForceInterpreter()

   /* The `is_forceinterp` will be `true`. */



   conf.Release()

   ```



5. AOT compiler options



   The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.



   ```go

   const (

     // Disable as many optimizations as possible.

     CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

     // Optimize quickly without destroying debuggability.

     CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

     // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

     CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

     // Optimize for fast execution as much as possible.

     CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

     // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

     CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

     // Optimize for small code size as much as possible.

     CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

   )



   const (

     // Native dynamic library format.

     CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

     // WebAssembly with AOT compiled codes in custom section.

     CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

   )

   ```



   These configurations are only effective in `Compiler` contexts.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the optimization level is O3.

   conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)

   // By default, the output format is universal WASM.

   conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)

   // By default, the dump IR is `false`.

   conf.SetCompilerDumpIR(true)

   // By default, the generic binary is `false`.

   conf.SetCompilerGenericBinary(true)



   conf.Release()

   ```



6. Statistics options



   The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler. These configurations are effective in `Compiler`, `VM`, and `Executor` objects.



   ```go

   conf := wasmedge.NewConfigure()



   // By default, the instruction counting is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsInstructionCounting(true)

   // By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsTimeMeasuring(true)

   // By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.

   conf.SetStatisticsCostMeasuring(true)



   conf.Release()

   ```



### Statistics



The statistics object, `wasmedge.Statistics`, provides the instruction counter, cost summation, and cost limitation at runtime.



Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.



1. Instruction counter



   The instruction counter can help developers to profile the performance of WASM running. Developers can retrieve the `Statistics` object from the `VM` object, or create a new one for the `Executor` creation. The details will be introduced in the next partitions.



   ```go

   stat := wasmedge.NewStatistics()

   // ... After running the WASM functions with the `Statistics` object



   count := stat.GetInstrCount()

   ips := stat.GetInstrPerSecond()

   stat.Release()

   ```



2. Cost table



   The cost table is to accumulate the cost of instructions with their weights. Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the `Statistics` object. If the cost limit value is set, the execution will return the `cost limit exceeded` error immediately when exceeds the cost limit in runtime.



   ```c

   stat := wasmedge.NewStatistics()



   costtable := []uint64{

     0, 0,

     10, /* 0x02: Block */

     11, /* 0x03: Loop */

     12, /* 0x04: If */

     12, /* 0x05: Else */

     0, 0, 0, 0, 0, 0,

     20, /* 0x0C: Br */

     21, /* 0x0D: Br_if */

     22, /* 0x0E: Br_table */

     0,

   }

   // Developers can set the costs of each instruction. The value not covered will be 0.



   WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);

   stat.SetCostTable()

   stat.SetCostLimit(5000000)



   // ... After running the WASM functions with the `Statistics` object

   cost := stat.GetTotalCost()

   stat.Release()

   ```



## WasmEdge VM



In this partition, we will introduce the functions of `wasmedge.VM` object and show examples of executing WASM functions.



### WASM Execution Example With VM Object



The following shows the example of running the WASM for getting the Fibonacci. This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



```wasm

(module

  (export ""fib"" (func $fib))

  (func $fib (param $n i32) (result i32)

    (if

      (i32.lt_s (get_local $n)(i32.const 2))

      (return (i32.const 1))

    )

    (return

      (i32.add

        (call $fib (i32.sub (get_local $n)(i32.const 2)))

        (call $fib (i32.sub (get_local $n)(i32.const 1)))

      )

    )

  )

)

```



1. Run WASM functions rapidly



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current `wasmedge_test` directory, and create and edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create the configure context and add the WASI support.

     // This step is not necessary unless you need WASI support.

     conf := wasmedge.NewConfigure(wasmedge.WASI)

     // Create VM with the configure.

     vm := wasmedge.NewVMWithConfig(conf)



     res, err := vm.RunWasmFile(""fibonacci.wasm"", ""fib"", uint32(21))

     if err == nil {

       fmt.Println(""Get fibonacci[21]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

     conf.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   Get fibonacci[21]: 17711

   ```



2. Instantiate and run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` object APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Set the logging level.

     wasmedge.SetLogErrorLevel()



     // Create VM.

     vm := wasmedge.NewVM()

     var err error

     var res []interface{}



     // Step 1: Load WASM file.

     err = vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     // Developers can load, validate, and instantiate another WASM module

     // to replace the instantiated one. In this case, the old module will

     // be cleared, but the registered modules are still kept.

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Execute WASM functions. Parameters: (funcname, args...)

     res, err = vm.Execute(""fib"", uint32(25))

     // Developers can execute functions repeatedly after instantiation.

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



   The following graph explains the status of the `VM` object.



   ```text

                          |========================|

                 |------->|      VM: Initiated     |

                 |        |========================|

                 |                    |

                 |                 LoadWasm

                 |                    |

                 |                    v

                 |        |========================|

                 |--------|       VM: Loaded       |<-------|

                 |        |========================|        |

                 |              |            ^              |

                 |         Validate          |              |

             Cleanup            |          LoadWasm         |

                 |              v            |            LoadWasm

                 |        |========================|        |

                 |--------|      VM: Validated     |        |

                 |        |========================|        |

                 |              |            ^              |

                 |      Instantiate          |              |

                 |              |          RegisterModule   |

                 |              v            |              |

                 |        |========================|        |

                 |--------|    VM: Instantiated    |--------|

                          |========================|

                                |            ^

                                |            |

                                --------------

                   Instantiate, Execute, ExecuteRegistered,

                   ExecuteBindgen, ExecuteBindgenRegistered

   ```



   The status of the `VM` context would be `Inited` when created. After loading WASM successfully, the status will be `Loaded`. After validating WASM successfully, the status will be `Validated`. After instantiating WASM successfully, the status will be `Instantiated`, and developers can invoke functions. Developers can register WASM or import objects in any status, but they should instantiate WASM again. Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation. When in the `Instantiated` status, developers can instantiate the WASM module again to reset the old WASM runtime structures.



### VM Creations



The `VM` creation APIs accepts the `Configure` object and the `Store` object. Noticed that if the `VM` created with the outside `Store` object, the `VM` will execute WASM on that `Store` object. If the `Store` object is set into multiple `VM` objects, it may causes data conflict when in execution. The details of the `Store` object will be introduced in [Store](#store).



```go

conf := wasmedge.NewConfigure()

store := wasmedge.NewStore()



// Create a VM with default configure and store.

vm := wasmedge.NewVM()

vm.Release()



// Create a VM with the specified configure and default store.

vm = wasmedge.NewVMWithConfig(conf)

vm.Release()



// Create a VM with the default configure and specified store.

vm = wasmedge.NewVMWithStore(store)

vm.Release()



// Create a VM with the specified configure and store.

vm = wasmedge.NewVMWithConfigAndStore(conf, store)

vm.Release()



conf.Release()

store.Release()

```



### Built-in Host Modules and Plug-in Preregistrations



WasmEdge provides the following built-in host modules and plug-in pre-registrations.



1. [WASI (WebAssembly System Interface)](https://github.com/WebAssembly/WASI)



   Developers can turn on the WASI support for VM in the `Configure` object.



   ```go

   conf := wasmedge.NewConfigure(wasmedge.WASI)

   // Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the built-in registered module instances from the VM object.

   // This API will return `nil` if the corresponding configuration is not set when creating the VM object.

   wasiconf := vm.GetImportModule(wasmedge.WASI)

   // Initialize the WASI.

   wasiconf.InitWasi(/* ... ignored */)



   vm.Release()

   ```



   And also can create the WASI import object from API. The details will be introduced in the [Host Functions](#host-functions) and the [Host Module Registrations](#host-module-registrations).



2. Plug-ins



   There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](../../../start/install.md#install-wasmedge-plug-ins-and-dependencies).



   Before using the plug-ins, developers should [load the plug-ins from paths](#load-plug-ins-from-paths).



   The `VM` object will automatically create and register the module of the loaded plug-ins when creation. Furthermore, the following host modules will be mocked if the plug-in not loaded:



   - `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)

   - `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)

   - `wasi_ephemeral_nn`

   - `wasi_snapshot_preview1`

   - `wasmedge_httpsreq`

   - `wasmedge_process`

   - `wasi:logging/logging` (for the `WASI-Logging`)



   When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.



   ```go

   // Load the plug-ins in the default paths first.

   wasmedge.LoadPluginDefaultPaths()



   // Create the VM object with the WASI configuration.

   conf := wasmedge.NewConfigure(wasmedge.WASI)

   vm := wasmedge.NewVMWithConfig(conf)

   conf.Release()



   // The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.

   // This API will return `NULL` if the module instance not found.



   // The `wasimodule` will not be `nil` because the configuration was set.

   wasimodule := vm.GetRegisteredModule(""wasi_snapshot_preview1"")



   // The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.

   wasinnmodule := vm.GetRegisteredModule(""wasi_ephemeral_nn"")



   vm.Release()

   ```



### Host Module Registrations



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge-go, the host functions are composed into host modules as `Module` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details. In this chapter, we show the example for registering the host modules into a `VM` object.



```go

vm := wasmedge.NewVM()

// You can also create and register the WASI host modules by this API.

wasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)



res := vm.RegisterModule(wasiobj)

// The result status should be checked.



vm.Release()

// The created import objects should be released.

wasiobj.Release()

```



### WASM Registrations And Executions



In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules. WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.



1. Register the WASM modules with exported module names



   Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory. Then create and edit the Go file `main.go` as following:



   ```go

   package main



   import ""github.com/second-state/WasmEdge-go/wasmedge""



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var err error

     err = vm.RegisterWasmFile(""module_name"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     // The result status should be checked. The error will occur if the

     // WASM module instantiation failed or the module name conflicts.



     vm.Release()

   }

   ```



2. Execute the functions in registered WASM modules



   Edit the Go file `main.go` as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     var res []interface{}

     var err error

     // Register the WASM module from file into VM with the module name ""mod"".

     err = vm.RegisterWasmFile(""mod"", ""fibonacci.wasm"")

     // Developers can register the WASM module from `[]byte` with the

     // `(*VM).RegisterWasmBuffer` function, or from `AST` object with

     // the `(*VM).RegisterAST` function.

     if err != nil {

       fmt.Println(""WASM registration failed:"", err.Error())

       return

     }

     // The function ""fib"" in the ""fibonacci.wasm"" was exported with the module

     // name ""mod"". As the same as host functions, other modules can import the

     // function `""mod"" ""fib""`.



     // Execute WASM functions in registered modules.

     // Unlike the execution of functions, the registered functions can be

     // invoked without `(*VM).Instantiate` because the WASM module was

     // instantiated when registering.

     // Developers can also invoke the host functions directly with this API.

     res, err = vm.ExecuteRegistered(""mod"", ""fib"", int32(25))

     if err == nil {

       fmt.Println(""Get fibonacci[25]:"", res[0].(int32))

     } else {

       fmt.Println(""Run failed:"", err.Error())

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   Get fibonacci[25]: 121393

   ```



### Asynchronous Execution



1. Asynchronously run WASM functions rapidly



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.

     async := vm.AsyncRunWasmFile(""fibonacci.wasm"", ""fib"", uint32(20))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 20th Fibonacci number is 10946 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   Get the result: 10946

   ```



2. Instantiate and asynchronously run WASM functions manually



   Besides the above example, developers can run the WASM functions step-by-step with `VM` context APIs:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     var err error

     var res []interface{}



     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,

     // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.

     async := vm.AsyncExecute(""fib"", uint32(25))



     // Block and wait for the execution and get the results.

     res, err := async.GetResult()

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     async.Release()

     vm.Release()

   }

   ```



   Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   Get the result: 121393

   ```



### Instance Tracing



Sometimes the developers may have requirements to get the instances of the WASM runtime. The `VM` object supplies the APIs to retrieve the instances.



1. Store



   If the `VM` object is created without assigning a `Store` object, the `VM` context will allocate and own a `Store`.



   ```go

   vm := wasmedge.NewVM()

   store := vm.GetStore()

   // The object should __NOT__ be deleted by calling `(*Store).Release`.

   vm.Release()

   ```



   Developers can also create the `VM` object with a `Store` object. In this case, developers should guarantee that the `Store` object cannot be released before the `VM` object. Please refer to the [Store Objects](#store) for the details about the `Store` APIs.



   ```go

   store := wasmedge.NewStore()

   vm := wasmedge.NewVMWithStore(store)



   storemock := vm.GetStore()

   // The internal store context of the `store` and the `storemock` are the same.



   vm.Release()

   store.Release()

   ```



2. List exported functions



   After the WASM module instantiation, developers can use the `(*VM).Execute` function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   Assume that a new Go project is created as following:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   func main() {

     // Create VM.

     vm := wasmedge.NewVM()



     // Step 1: Load WASM file.

     err := vm.LoadWasmFile(""fibonacci.wasm"")

     if err != nil {

       fmt.Println(""Load WASM from file FAILED:"", err.Error())

       return

     }



     // Step 2: Validate the WASM module.

     err = vm.Validate()

     if err != nil {

       fmt.Println(""Validation FAILED:"", err.Error())

       return

     }



     // Step 3: Instantiate the WASM module.

     err = vm.Instantiate()

     if err != nil {

       fmt.Println(""Instantiation FAILED:"", err.Error())

       return

     }



     // List the exported functions for the names and function types.

     funcnames, functypes := vm.GetFunctionList()

     for _, fname := range funcnames {

       fmt.Println(""Exported function name:"", fname)

     }

     for _, ftype := range functypes {

       // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.

       // Developers should __NOT__ call the `ftype.Release()`.

     }



     vm.Release()

   }

   ```



   Then you can build and run: (the only exported function in `fibonacci.wasm` is `fib`)



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   Exported function name: fib

   ```



   If developers want to get the exported function names in the registered WASM modules, please retrieve the `Store` object from the `VM` object and refer to the APIs of [Store Contexts](#store) to list the registered functions by the module name.



3. Get function types



   The `VM` object provides APIs to find the function type by function name. Please refer to the [Instances in runtime](#instances) for the details about the function types.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   functype := vm.GetFunctionType(""fib"")

   // Developers can get the function types of functions in the registered modules via the

   // `(*VM).GetFunctionTypeRegistered` API with the function name and the module name.

   // If the function is not found, these APIs will return `nil`.

   // Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.

   ```



4. Get the active module



   After the WASM module instantiation, an anonymous module is instantiated and owned by the `VM` object. Developers may need to retrieve it to get the instances beyond the module. Then developers can use the `(*VM).GetActiveModule()` API to get that anonymous module instance. Please refer to the [Module instance](#instances) for the details about the module instance APIs.



   ```go

   // Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.

   mod := vm.GetActiveModule()

   // If there's no WASM module instantiated, this API will return `nil`.

   // Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.

   ```



5. List and get the registered modules



   To list and retrieve the registered modules in the `VM` object, besides accessing the `store` object of the `VM`, developers can use the following APIs.



   ```go

   // Assume that the `vm` is the created `wasmedge.VM` object.

   modnames := vm.ListRegisteredModule()

   for _, name := range modnames {

     fmt.Println(""Registered module name: "", name)

   }

   ```



6. Get the components



   The `VM` object is composed by the `Loader`, `Validator`, and `Executor` objects. For the developers who want to use these objects without creating another instances, these APIs can help developers to get them from the `VM` object. The get objects are owned by the `VM` object, and developers should not call their release functions.



   ```go

   loader := vm.GetLoader()

   // Developers should __NOT__ call the `(*Loader).Release` function of the returned object.

   validator := vm.GetValidator()

   // Developers should __NOT__ call the `(*Validator).Release` function of the returned object.

   executor := vm.GetExecutor()

   // Developers should __NOT__ call the `(*Executor).Release` function of the returned object.

   ```



## WasmEdge Runtime



In this partition, we will introduce the objects of WasmEdge runtime manually.



### WASM Execution Example Step-By-Step



Besides the WASM execution through the [`VM` object](#wasmedge-vm) rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the `Loader`, `Validator`, `Executor`, and `Store` objects.



Assume that a new Go project is created as following:



```bash

mkdir wasmedge_test && cd wasmedge_test

go mod init wasmedge_test

```



Then assume that the WASM file `fibonacci.wasm` from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat) is copied into the current directory, and create and edit a Go file `main.go`:



```go

package main



import (

  ""fmt""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  // Set the logging level to debug to print the statistics info.

  wasmedge.SetLogDebugLevel()

  // Create the configure object. This is not necessary if developers use the default configuration.

  conf := wasmedge.NewConfigure()

  // Turn on the runtime instruction counting and time measuring.

  conf.SetStatisticsInstructionCounting(true)

  conf.SetStatisticsTimeMeasuring(true)

  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.

  stat := wasmedge.NewStatistics()

  // Create the store object. The store object is the WASM runtime structure core.

  store := wasmedge.NewStore()



  var err error

  var res []interface{}

  var ast *wasmedge.AST

  var mod *wasmedge.Module



  // Create the loader object.

  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

  loader := wasmedge.NewLoaderWithConfig(conf)

  // Create the validator object.

  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

  validator := wasmedge.NewValidatorWithConfig(conf)

  // Create the executor object.

  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.

  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)



  // Load the WASM file or the compiled-WASM file and convert into the AST module object.

  ast, err = loader.LoadFile(""fibonacci.wasm"")

  if err != nil {

    fmt.Println(""Load WASM from file FAILED:"", err.Error())

    return

  }

  // Validate the WASM module.

  err = validator.Validate(ast)

  if err != nil {

    fmt.Println(""Validation FAILED:"", err.Error())

    return

  }

  // Instantiate the WASM module and get the output module instance.

  mod, err = executor.Instantiate(store, ast)

  if err != nil {

    fmt.Println(""Instantiation FAILED:"", err.Error())

    return

  }



  // Try to list the exported functions of the instantiated WASM module.

  funcnames := mod.ListFunction()

  for _, fname := range funcnames {

    fmt.Println(""Exported function name:"", fname)

  }



  // Invoke the WASM function.

  funcinst := mod.FindFunction(""fib"")

  if funcinst == nil {

    fmt.Println(""Run FAILED: Function name `fib` not found"")

    return

  }

  res, err = executor.Invoke(funcinst, int32(30))

  if err == nil {

    fmt.Println(""Get fibonacci[30]:"", res[0].(int32))

  } else {

    fmt.Println(""Run FAILED:"", err.Error())

  }



  // Resources deallocations.

  conf.Release()

  stat.Release()

  ast.Release()

  loader.Release()

  validator.Release()

  executor.Release()

  store.Release()

  mod.Release()

}

```



Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)



```bash

$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

$ go build

$ ./wasmedge_test

Exported function name: fib

[2021-11-24 18:53:01.451] [debug]  Execution succeeded.

[2021-11-24 18:53:01.452] [debug]

 ====================  Statistics  ====================

 Total execution time: 556372295 ns

 Wasm instructions execution time: 556372295 ns

 Host functions execution time: 0 ns

 Executed wasm instructions count: 28271634

 Gas costs: 0

 Instructions per second: 50814237

Get fibonacci[30]: 1346269

```



### Loader



The `Loader` object loads the WASM binary from files or buffers. Both the WASM and the compiled-WASM from the [WasmEdge AOT Compiler](#wasmedge-aot-compiler) are supported.



```go

var buf []byte

// ... Read the WASM code to the `buf`.



// Developers can adjust settings in the configure object.

conf := wasmedge.NewConfigure()

// Create the loader object.

// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.

loader := wasmedge.NewLoaderWithConfig(conf)

conf.Release()



// Load WASM or compiled-WASM from the file.

ast, err := loader.LoadFile(""fibonacci.wasm"")

if err != nil {

  fmt.Println(""Load WASM from file FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



// Load WASM or compiled-WASM from the buffer

ast, err = loader.LoadBuffer(buf)

if err != nil {

  fmt.Println(""Load WASM from buffer FAILED:"", err.Error())

} else {

  // The output AST object should be released.

  ast.Release()

}



loader.Release()

```



### Validator



The `Validator` object can validate the WASM module. Every WASM module should be validated before instantiation.



```go

// ...

// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.

// Assume that the `conf` is the `*wasmedge.Configure` object.



// Create the validator context.

// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.

validator := wasmedge.NewValidatorWithConfig(conf)



err := validator.Validate(ast)

if err != nil {

  fmt.Println(""Validation FAILED:"", err.Error())

}



validator.Release()

```



### Executor



The `Executor` object is the executor for both WASM and compiled-WASM. This object should work base on the `Store` object. For the details of the `Store` object, please refer to the [next chapter](#store).



1. Instantiate and register an `AST` object as a named `Module` instance



   As the same of [registering host modules](#host-module-registrations) or [importing WASM modules](#wasm-registrations-and-executions) in `VM` objects, developers can instantiate an `AST module` object into a named `Module` instance, and register it into the `Store` object. After the registration, the result `Module` instance is exported to the `Store` with the given module name and can be linked when instantiating another module.



   For the details about the `Module` instances APIs, please refer to the [Instances](#instances). The `Store` context is only the linker for searching and linking the exported modules when instantiation. Developers should release the output `Module` instance when it will no longer be used. When the `Module` instance being released, it will automatically unlink to all linked `Store` objects.



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Register the loaded WASM `ast` into store with the export module name ""mod"".

   mod, res := executor.Register(store, ast, ""mod"")

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



2. Register an existing `Module` instance and export the module name



   Besides instantiating and registering an `AST` object, developers can register an existing `Module` instance into the store with exporting the module name (which is in the `Module` instance already). This case occurs when developers create a `Module` instance for the host functions and want to register it for linking. For the details about the construction of host functions in `Module` instances, please refer to the [Host Functions](#host-functions).



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Create a module instance for host functions.

   mod := wasmedge.NewModule(""mod"")

   // ...

   // Create and add the host functions, tables, memories, and globals into the module instance.

   // ...



   // Register the module instance into store with the exported module name.

   // The export module name is in the module instance already.

   res := executor.RegisterImport(store, mod)

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

     return

   }



   // ...



   // Resources deallocations.

   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



3. Instantiate an `AST` object to an anonymous `Module` instance



   WASM or compiled-WASM modules should be instantiated before the function invocation. Before instantiating a WASM module, please check the [import section](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import) for ensuring the imports are registered into the `Store` object for linking.



   ```go

   // ...

   // Assume that the `ast` is the output `*wasmedge.AST` object from the loader

   // and has passed the validation.

   // Assume that the `conf` is the `*wasmedge.Configure` object.



   // Create the statistics object. This step is not necessary if the statistics

   // is not needed.

   stat := wasmedge.NewStatistics()

   // Create the executor object.

   // For executor creation with default configuration and without statistics,

   // you can use `wasmedge.NewExecutor()` instead.

   executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

   // Create the store object. The store is the WASM runtime structure core.

   store := wasmedge.NewStore()



   // Instantiate the WASM module.

   mod, err := executor.Instantiate(stpre, ast)

   if err != nil {

     fmt.Println(""WASM instantiation FAILED:"", err.Error())

     return

   }



   executor.Release()

   stat.Release()

   store.Release()

   mod.Release()

   ```



4. Invoke functions



   After registering or instantiating and get the result `Module` instance, developers can retrieve the exported `Function` instances from the `Module` instance for invocation. For the details about the `Module` instances APIs, please refer to the [Instances](#instances). Please refer to the [example above](#wasm-execution-example-step-by-step) for the `Function` instance invocation with the `(*Executor).Invoke` API.



5. Asynchronously invoke functions



   Such as [executing WASM functions in VM asynchronously](#asynchronous-execution), developers can also invoke a function asynchronously by `Executor` objects API.



   After getting the `Function` instance, developers will get the `wasmedge.Async` object by calling the `(*wasmedge.executor).AsyncInvoke()` API. Please refer to the [Async](#async) chapter to work with this object for getting the results.



### AST Module



The `AST` object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from [Loader](#loader). Before instantiation, developers can also query the imports and exports of an `AST` object.



```go

ast := ...

// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.



// List the imports.

imports := ast.ListImports()

for _, import := range imports {

  fmt.Println(""Import:"", import.GetModuleName(), import.GetExternalName())

}



// List the exports.

exports := ast.ListExports()

for _, export := range exports {

  fmt.Println(""Export:"", export.GetExternalName())

}



ast.Release()

```



### Store



[Store](https://webassembly.github.io/spec/core/exec/runtime.html#store) is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs. The `Store` object in WasmEdge-Go is an object which present the linker to provide the instance exporting and importing when instantiating WASM modules. Developers can retrieve the named modules from the `Store` object, and should release the `Module` instances registered into the `Store` object if they will not be used anymore.



When the `Store` object being released, the linked `Module` instances will automatically unlink to this `Store` object. When a `Module` instance being released, it will automatically unlink to all the linked `Store` objects.



```go

store := wasmedge.NewStore()



// ...

// Register a WASM module via the executor object.

// ...



// Try to list the registered WASM modules.

modnames := store.ListModule()

// ...



// Find named module by name.

mod := store.FindModule(""module"")

// If the module with name not found, the `mod` will be `nil`.



store.Release()

```



### Instances



The instances are the runtime structures of WASM. Developers can retrieve the `Module` instances from the `Store` contexts, and retrieve the other instances from the `Module` instances. A single instance can be allocated by its creation function. Developers can construct instances into an `Module` instance for registration. Please refer to the [Host Functions](#host-functions) for details. The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an `Module` instance.



1. Module instance



   After instantiating or registering an `AST` object, developers will get a `Module` instance as the result, and have the responsibility to release it when not in use. A `Module` instance can also be created for the host module. Please refer to the [host function](#host-functions) for the details. `Module` instance provides APIs to list and find the exported instances in the module.



   ```go

   // ...

   // Instantiate a WASM module via the executor object and get the `mod` as the output module instance.

   // ...



   // List the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcnames := mod.ListFunction()



   // Try to find the exported instance of the instantiated WASM module.

   // Take the function instances for example here.

   funcinst := mod.FindFunction(""fib"")

   // `funcinst` will be `nil` if the function not found.

   // The returned instance is owned by the module instance and should __NOT__ be released.

   ```



2. Function instance



   [Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, developers can create the `Function` objects for host functions and add them into an `Module` instance for registering into a `VM` or a `Store`. Developers can retrieve the `Function Type` from the `Function` objects through the API. For the details of the `Host Function` guide, please refer to the [next chapter](#host-functions).



   ```go

   funcobj := ...

   // `funcobj` is the `*wasmedge.Function` retrieved from the module instance.

   functype := funcobj.GetFunctionType()

   // The `funcobj` retrieved from the module instance should __NOT__ be released.

   // The `functype` retrieved from the `funcobj` should __NOT__ be released.



   // For the function object creation, please refer to the `Host Function` guide.

   ```



3. Table instance



   In WasmEdge, developers can create the `Table` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Table` objects supply APIs to control the data in table instances.



   ```go

   lim := wasmedge.NewLimitWithMax(10, 20)

   // Create the table type with limit and the `FuncRef` element type.

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)

   // Create the table instance with table type.

   tabinst := wasmedge.NewTable(tabtype)

   // Delete the table type.

   tabtype.Release()



   gottabtype := tabinst.GetTableType()

   // The `gottabtype` got from table instance is owned by the `tabinst`

   // and should __NOT__ be released.

   reftype := gottabtype.GetRefType()

   // The `reftype` will be `wasmedge.RefType_FuncRef`.



   var gotdata interface{}

   data := wasmedge.NewFuncRef(5)

   err := tabinst.SetData(data, 3)

   // Set the function index 5 to the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   err = tabinst.SetData(data, 13)



   gotdata, err = tabinst.GetData(3)

   // Get the FuncRef value of the table[3].



   // The following line will get an ""out of bounds table access"" error

   // because the position (13) is out of the table size (10):

   //   gotdata, err = tabinst.GetData(13)



   tabsize := tabinst.GetSize()

   // `tabsize` will be 10.

   err = tabinst.Grow(6)

   // Grow the table size of 6, the table size will be 16.



   // The following line will get an ""out of bounds table access"" error

   // because the size (16 + 6) will reach the table limit (20):

   //   err = tabinst.Grow(6)



   tabinst.Release()

   ```



4. Memory instance



   In WasmEdge, developers can create the `Memory` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Memory` objects supply APIs to control the data in memory instances.



   ```go

   lim := wasmedge.NewLimitWithMax(1, 5)

   // Create the memory type with limit. The memory page size is 64KiB.

   memtype := wasmedge.NewMemoryType(lim)

   // Create the memory instance with memory type.

   meminst := wasmedge.NewMemory(memtype)

   // Delete the memory type.

   memtype.Release()



   data := []byte(""A quick brown fox jumps over the lazy dog"")

   err := meminst.SetData(data, 0x1000, 10)

   // Set the data[0:9] to the memory[4096:4105].



   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   err = meminst.SetData(data, 0xFFFF, 10)



   var gotdata []byte

   gotdata, err = meminst.GetData(0x1000, 10)

   // Get the memory[4096:4105]. The `gotdata` will be `[]byte(""A quick br"").

   // The following line will get an ""out of bounds memory access"" error

   // because [65535:65544] is out of 1 page size (65536):

   //   gotdata, err = meminst.Getdata(0xFFFF, 10)



   pagesize := meminst.GetPageSize()

   // `pagesize` will be 1.

   err = meminst.GrowPage(2)

   // Grow the page size of 2, the page size of the memory instance will be 3.



   // The following line will get an ""out of bounds memory access"" error

   // because the size (3 + 3) will reach the memory limit (5):

   //   err = meminst.GetPageSize(3)



   meminst.Release()

   ```



5. Global instance



   In WasmEdge, developers can create the `Global` objects and add them into an `wasmedge.Module` object for registering into a `VM` or a `Store`. The `Global` objects supply APIs to control the value in global instances.



   ```go

   // Create the global type with value type and mutation.

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)

   // Create the global instance with value and global type.

   globinst := wasmedge.NewGlobal(globtype, uint64(1000))

   // Delete the global type.

   globtype.Release()



   gotglobtype := globinst.GetGlobalType()

   // The `gotglobtype` got from global instance is owned by the `globinst`

   // and should __NOT__ be released.

   valtype := gotglobtype.GetValType()

   // The `valtype` will be `wasmedge.ValType_I64`.

   valmut := gotglobtype.GetMutability()

   // The `valmut` will be `wasmedge.ValMut_Var`.



   globinst.SetValue(uint64(888))

   // Set the value u64(888) to the global.

   // This function will do nothing if the value type mismatched or the

   // global mutability is `wasmedge.ValMut_Const`.

   gotval := globinst.GetValue()

   // The `gotbal` will be `interface{}` which the type is `uint64` and

   // the value is 888.



   globinst.Release()

   ```



### Host Functions



[Host functions](https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc) are functions outside WebAssembly and passed to WASM modules as imports. In WasmEdge, the host functions are composed into host modules as `wasmedge.Module` objects with module names. Please refer to the [Host Functions in WasmEdge Runtime](#host-functions) for the details.



In this chapter, we show the example for registering the host modules into a `VM` object. Noticed that the developers should guarantee the availability of the registered module instances, and should release the module instances when they will not be used.



1. Host function allocation



   Developers can define Go functions with the following function signature as the host function body:



   ```go

   type hostFunctionSignature func(

       data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)

   ```



   The example of an `add` host function to add 2 `i32` values:



   ```go

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }

   ```



   Then developers can create `Function` object with the host function body and function type:



   ```go

   // Create a function type: {i32, i32} -> {i32}.

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )



   // Create a function context with the function type and host function body.

   // The third parameter is the pointer to the additional data.

   // Developers should guarantee the life cycle of the data, and it can be

   // `nil` if the external data is not needed.

   // The last parameter can be 0 if developers do not need the cost measuring.

   func_add := wasmedge.NewFunction(functype, host_add, nil, 0)



   // If the function object is not added into an module instance object, it should be released.

   func_add.Release()

   functype.Release()

   ```



2. Calling frame object



   The `wasmedge.CallingFrame` is the object to provide developers to access the module instance of the [frame on the top of the calling stack](https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames). According to the [WASM spec](https://webassembly.github.io/spec/core/exec/instructions.html#function-calls), a frame with the module instance is pushed into the stack when invoking a function. Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.



   ```go

   import (

     ""encoding/binary""

     ""fmt""

   )



   // Host function body definition.

   func LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // Function type: {i32} -> {}

     offset := params[0].(int32)



     // Get the 0th memory instance of the module of the top frame on the stack.

     mem := callframe.GetMemoryByIndex(0)



     data, err := mem.GetData(uint(offset), 4)

     if err != nil {

       return nil, err

     }

     fmt.Println(""u32 at memory[{}]: {}"", offset, binary.LittleEndian.Uint32(data))

     return nil, wasmedge.Result_Success

   }

   ```



   Besides using the `(*CallingFrame).GetMemoryByIndex()` API to get the memory instance by index in the module instance, developers can use the `(*CallingFrame).GetModule()` to get the module instance directly. Therefore, developers can retrieve the exported contexts by the `wasmedge.Module` APIs. And also, developers can use the `(*CallingFrame).GetExecutor()` API to get the currently used executor context.



3. User-defined error code of the host functions



   In host functions, WasmEdge-Go provides `wasmedge.Result_Success` to return success, `wasmedge.Result_Terminate` to terminate the WASM execution, and `wasmedge.Result_Fail` to return fail. WasmEdge-Go also provides the usage of returning the user-specified codes. Developers can use the `wasmedge.NewResult()` API to generate the `wasmedge.Result` struct with error code, and use the `(*result).GetCode()` API to get the error code.



   > Notice: The error code only supports 24-bit integer (0 ~ 16777216 in `uint32`). The values larger than 24-bit will be truncated.



   Create a new Go project first:



   ```bash

   mkdir wasmedge_test && cd wasmedge_test

   go mod init wasmedge_test

   ```



   Assume that a simple WASM from the WAT is as following:



   ```wasm

   (module

     (type $t0 (func (param i32)))

     (import ""extern"" ""trap"" (func $f-trap (type $t0)))

     (func (export ""trap"") (param i32)

       local.get 0

       call $f-trap)

   )

   ```



   And the `main.go` is as following:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x05, 0x01,

       /* function type {i32} -> {} */

       0x60, 0x01, 0x7F, 0x00,

       /* Import section */

       0x02, 0x0F, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""trap"" */

       0x04, 0x74, 0x72, 0x61, 0x70,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x08, 0x01,

       /* export name: ""trap"" */

       0x04, 0x74, 0x72, 0x61, 0x70,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x08, 0x01,

       /* code body */

       0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,

     }



     // Create the module instance with the module name ""extern"".

     impmod := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})

     hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)

     functype.Release()

     impmod.AddFunction(""trap"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(impmod)



     _, err := vm.RunWasmBuffer(wasmbuf, ""trap"", uint32(5566))

     if err != nil {

       fmt.Println(""Get the error code:"", err.GetCode())

     }



     impmod.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   [2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be

   [2022-08-26 15:06:40.384] [error]     When executing function name: ""trap""

   Get the error code: 5566

   ```



4. Construct a module instance with host instances



   Besides creating a `Module` instance by registering or instantiating a WASM module, developers can create a `Module` instance with a module name and add the `Function`, `Memory`, `Table`, and `Global` instances into it with their exporting names.



   ```go

   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   // Create a module instance with the module name ""module"".

   mod := wasmedge.NewModule(""module"")



   // Create and add a function instance into the module instance with export name ""add"".

   functype := wasmedge.NewFunctionType(

     []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

     []wasmedge.ValType{wasmedge.ValType_I32},

   )

   hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

   functype.Release()

   mod.AddFunction(""add"", hostfunc)



   // Create and add a table instance into the module instance with export name ""table"".

   tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))

   hosttab := wasmedge.NewTable(tabtype)

   tabtype.Release()

   mod.AddTable(""table"", hosttab)



   // Create and add a memory instance into the module instance with export name ""memory"".

   memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))

   hostmem := wasmedge.NewMemory(memtype)

   memtype.Release()

   mod.AddMemory(""memory"", hostmem)



   // Create and add a global instance into the module instance with export name ""global"".

   globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)

   hostglob := wasmedge.NewGlobal(globtype, uint32(666))

   globtype.Release()

   mod.AddGlobal(""global"", hostglob)



   // The module instances should be released.

   // Developers should __NOT__ release the instances added into the module instance objects.

   mod.Release()

   ```



5. Specified module instance



   `wasmedge.NewWasiModule()` API can create and initialize the `WASI` module instance.



   ```go

   wasiobj := wasmedge.NewWasiModule(

     os.Args[1:],     // The args

     os.Environ(),    // The envs

     []string{"".:.""}, // The mapping preopens

   )



   // Register the WASI into the VM object.

   vm := wasmedge.NewVM()

   vm.RegisterImport(wasiobj)



   // ... Execute some WASM functions.



   // Get the WASI exit code.

   exitcode := wasiobj.WasiGetExitCode()

   // The `exitcode` will be 0 if the WASI function ""_start"" execution has no error.

   // Otherwise, it will return with the related exit code.



   vm.Release()

   // The import objects should be deleted.

   wasiobj.Release()

   ```



6. Example



   Assume that there is a simple WASM from the WAT as following:



   ```wasm

   (module

     (type $t0 (func (param i32 i32) (result i32)))

     (import ""extern"" ""func-add"" (func $f-add (type $t0)))

     (func (export ""addTwo"") (param i32 i32) (result i32)

       local.get 0

       local.get 1

       call $f-add)

   )

   ```



   Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // Create the module instance with the module name ""extern"".

     impmod := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

     functype.Release()

     impmod.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(impmod)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }



     impmod.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   ```



7. Host Data Example



   Developers can set a external data object to the `Function` object, and access to the object in the function body. Assume that edit the Go file `main.go` above:



   ```go

   package main



   import (

     ""fmt""



     ""github.com/second-state/WasmEdge-go/wasmedge""

   )



   // Host function body definition.

   func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {

     // add: i32, i32 -> i32

     res := params[0].(int32) + params[1].(int32)



     // Set the returns

     returns := make([]interface{}, 1)

     returns[0] = res



     // Also set the result to the data.

     *data.(*int32) = res



     // Return

     return returns, wasmedge.Result_Success

   }



   func main() {

     // Create the VM object.

     vm := wasmedge.NewVM()



     // The WASM module buffer.

     wasmbuf := []byte{

       /* WASM header */

       0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,

       /* Type section */

       0x01, 0x07, 0x01,

       /* function type {i32, i32} -> {i32} */

       0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,

       /* Import section */

       0x02, 0x13, 0x01,

       /* module name: ""extern"" */

       0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,

       /* extern name: ""func-add"" */

       0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,

       /* import desc: func 0 */

       0x00, 0x00,

       /* Function section */

       0x03, 0x02, 0x01, 0x00,

       /* Export section */

       0x07, 0x0A, 0x01,

       /* export name: ""addTwo"" */

       0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,

       /* export desc: func 0 */

       0x00, 0x01,

       /* Code section */

       0x0A, 0x0A, 0x01,

       /* code body */

       0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,

     }



     // The additional data to set into the host function.

     var data int32 = 0



     // Create the module instance with the module name ""extern"".

     modinst := wasmedge.NewModule(""extern"")



     // Create and add a function instance into the module instance with export name ""func-add"".

     functype := wasmedge.NewFunctionType(

       []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

       []wasmedge.ValType{wasmedge.ValType_I32},

     )

     hostfunc := wasmedge.NewFunction(functype, host_add, &data, 0)

     functype.Release()

     modinst.AddFunction(""func-add"", hostfunc)



     // Register the module instance into VM.

     vm.RegisterImport(modinst)



     res, err := vm.RunWasmBuffer(wasmbuf, ""addTwo"", uint32(1234), uint32(5678))

     if err == nil {

       fmt.Println(""Get the result:"", res[0].(int32))

     } else {

       fmt.Println(""Error message:"", err.Error())

     }

     fmt.Println(""Data value:"", data)



     modinst.Release()

     vm.Release()

   }

   ```



   Then you can build and run the Golang application with the WasmEdge Golang SDK:



   ```bash

   $ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

   $ go build

   $ ./wasmedge_test

   Get the result: 6912

   Data value: 6912

   ```



### Plug-ins



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



#### Load plug-ins from paths



To use the plug-ins, developers should load the plug-ins from paths first.



```go

wasmedge.LoadPluginDefaultPaths()

```



After calling this API, the plug-ins in the default paths will be loaded. The default paths are:



1. The path given in the environment variable `WASMEDGE_PLUGIN_PATH`.

2. The `../plugin/` directory related to the WasmEdge installation path.

3. The `./wasmedge/` directory under the library path if the WasmEdge is installed under the system directory (such as `/usr` and `/usr/local`).



To load the plug-ins from a specific path or under a specific directory, developers can use this API:



```go

wasmedge.LoadPluginFromPath(""PATH_TO_PLUGIN/plugin.so"")

```



#### Get the plug-in by name



After loading the plug-ins, developers can list the loaded plug-in names.



```go

wasmedge.LoadPluginDefaultPaths()

pluginnames := wasmedge.ListPlugins()

for _, name := range pluginnames {

  fmt.Println(""Loaded plug-in name: "", name)

}

```



And developers can retrieve the plug-in object by its name.



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()

plugincrypto := wasmedge.FindPlugin(""wasi_crypto"")

```



#### Create the module instance from a plug-in



With the plug-in object, developers can create the module instances by the module name.



```go

// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.



// List the available host modules in the plug-in.

modules := plugincrypto.ListModule()

for _, name := range modules {

  fmt.Println(""Available module: "", name)

}

// Will print here for the WASI-Crypto plug-in here:

//   wasi_ephemeral_crypto_asymmetric_common

//   wasi_ephemeral_crypto_common

//   wasi_ephemeral_crypto_kx

//   wasi_ephemeral_crypto_signatures

//   wasi_ephemeral_crypto_symmetric



// Create a module instance from the plug-in by the module name.

modinst := plugincrypto.CreateModule(""wasi_ephemeral_crypto_common"")



modinst.Release()

```



## WasmEdge AOT Compiler



In this partition, we will introduce the WasmEdge AOT compiler and the options in Go. WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code. The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.



### Compilation Example



The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) provide a tool for compiling a WASM file.



### Compiler Options



Developers can set options for AOT compilers such as optimization level and output format:



```go

const (

  // Disable as many optimizations as possible.

  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)

  // Optimize quickly without destroying debuggability.

  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)

  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.

  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)

  // Optimize for fast execution as much as possible.

  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)

  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.

  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)

  // Optimize for small code size as much as possible.

  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)

)



const (

  // Native dynamic library format.

  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)

  // WebAssembly with AOT compiled codes in custom section.

  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)

)

```



Please refer to the [AOT compiler options configuration](#configurations) for details.



## WasmEdge CLI Tools



Besides executing the `wasmedge` and `wasmedgec` CLI tools, developers can trigger the WasmEdge CLI tools in WasmEdge-Go. The API arguments are the same as the command line arguments of the CLI tools.



### Runtime CLI



The `wasmedge.RunWasmEdgeCLI()` API presents the same function as running the [`wasmedge run` command](../../../start/build-and-run/run.md).



Noticed that this API presents the old `wasmedge` CLI tool, which is the same as the `wasmedge run` command. For the current unified `wasmedge` CLI, please refer to the [API below](#unified-cli).



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeCLI(os.Args)

}

```



### Compiler CLI



The `wasmedge.RunWasmEdgeAOTCompilerCLI()` API presents the same function as running the [`wasmedge compile` tool](../../../start/build-and-run/aot.md).



Noticed that this API presents the old `wasmedgec` CLI tool, which is the same as the `wasmedge compile` command. For the current unified `wasmedge` CLI, please refer to the [API below](#unified-cli).



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)

}

```



### Unified CLI



The `wasmedge.RunWasmEdgeUnifiedCLI()` API presents the same function as running the [`wasmedge` tool](../../../start/build-and-run/cli.md).



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.RunWasmEdgeUnifiedCLI(os.Args)

}

```








------"
"The following is a markdown document located at /embed/go/reference/upgrade_to_0.10.0.md
------


---

sidebar_position: 8

---



# Upgrade to WasmEdge-Go v0.10.0



Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.9.2` to the `v0.10.0` version.



**Due to the `v0.9.1` is retracted, we use the version `v0.9.2` here.**



## Concepts



1. Merged the `ImportObject` into the `Module`.



   The `ImportObject` struct which is for the host functions is merged into `Module`. Developers can use the related APIs to construct host modules.



   - `wasmedge.NewImportObject()` is changed to `wasmedge.NewModule()`.

   - `(*wasmedge.ImportObject).Release()` is changed to `(*wasmedge.Module).Release()`.

   - `(*wasmedge.ImportObject).AddFunction()` is changed to `(*wasmedge.Module).AddFunction()`.

   - `(*wasmedge.ImportObject).AddTable()` is changed to `(*wasmedge.Module).AddTable()`.

   - `(*wasmedge.ImportObject).AddMemory()` is changed to `(*wasmedge.Module).AddMemory()`.

   - `(*wasmedge.ImportObject).AddGlobal()` is changed to `(*wasmedge.Module).AddGlobal()`.

   - `(*wasmedge.ImportObject).NewWasiImportObject()` is changed to `(*wasmedge.Module).NewWasiModule()`.

   - `(*wasmedge.ImportObject).NewWasmEdgeProcessImportObject()` is changed to `(*wasmedge.Module).NewWasmEdgeProcessModule()`.

   - `(*wasmedge.ImportObject).InitWASI()` is changed to `(*wasmedge.Module).InitWASI()`.

   - `(*wasmedge.ImportObject).InitWasmEdgeProcess()` is changed to `(*wasmedge.Module).InitWasmEdgeProcess()`.

   - `(*wasmedge.ImportObject).WasiGetExitCode()` is changed to `(*wasmedge.Module).WasiGetExitCode`.

   - `(*wasmedge.VM).RegisterImport()` is changed to `(*wasmedge.VM).RegisterModule()`.

   - `(*wasmedge.VM).GetImportObject()` is changed to `(*wasmedge.VM).GetImportModule()`.



   For the new host function examples, please refer to [the example below](#host-functions).



2. Used the pointer to `Function` instead of the index in the `FuncRef` value type.



   For the better performance and security, the `FuncRef` related APIs used the `*wasmedge.Function` for the parameters and returns.



   - `wasmedge.NewFuncRef()` is changed to use the `*Function` as it's argument.

   - Added `(wasmedge.FuncRef).GetRef()` to retrieve the `*Function`.



3. Supported multiple anonymous WASM module instantiation.



   In the version before `v0.9.2`, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced. After the `v0.10.0` version, developers can instantiate multiple anonymous WASM module by `Executor` and get the `Module` instance. But for the source code using the `VM` APIs, the behavior is not changed. For the new examples of instantiating multiple anonymous WASM modules, please refer to [the example below](#wasmedge-executor-changes).



4. Behavior changed of `Store`.



   The `Function`, `Table`, `Memory`, and `Global` instances retrievement from the `Store` is moved to the `Module` instance. The `Store` only manage the module linking when instantiation and the named module searching after the `v0.10.0` version.



   - `(*wasmedge.Store).ListFunction()` and `(*wasmedge.Store).ListFunctionRegistered()` is replaced by `(*wasmedge.Module).ListFunction()`.

   - `(*wasmedge.Store).ListTable()` and `(*wasmedge.Store).ListTableRegistered()` is replaced by `(*wasmedge.Module).ListTable()`.

   - `(*wasmedge.Store).ListMemory()` and `(*wasmedge.Store).ListMemoryRegistered()` is replaced by `(*wasmedge.Module).ListMemory()`.

   - `(*wasmedge.Store).ListGlobal()` and `(*wasmedge.Store).ListGlobalRegistered()` is replaced by `(*wasmedge.Module).ListGlobal()`.

   - `(*wasmedge.Store).FindFunction()` and `(*wasmedge.Store).FindFunctionRegistered()` is replaced by `(*wasmedge.Module).FindFunction()`.

   - `(*wasmedge.Store).FindTable()` and `(*wasmedge.Store).FindTableRegistered()` is replaced by `(*wasmedge.Module).FindTable()`.

   - `(*wasmedge.Store).FindMemory()` and `(*wasmedge.Store).FindMemoryRegistered()` is replaced by `(*wasmedge.Module).FindMemory()`.

   - `(*wasmedge.Store).FindGlobal()` and `(*wasmedge.Store).FindGlobalRegistered()` is replaced by `(*wasmedge.Module).FindGlobal()`.



   For the new examples of retrieving instances, please refer to [the example below](#instances-retrievement).



5. The `Module`-based resource management.



   Except the creation of `Module` instance for the host functions, the `Executor` will output a `Module` instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by `(*wasmedge.Module).Release()` API. The `Store` will link to the named `Module` instance after registering. After the destroyment of a `Module` instance, the `Store` will unlink to that automatically; after the destroyment of the `Store`, the all `Module` instances the `Store` linked to will unlink to that `Store` automatically.



## WasmEdge-Go VM changes



The `VM` APIs are basically not changed, except the `ImportObject` related APIs.



The following is the example of WASI initialization in WasmEdge-Go `v0.9.2`:



```go

conf := wasmedge.NewConfigure(wasmedge.WASI)

vm := wasmedge.NewVMWithConfig(conf)



// The following API can retrieve the pre-registration import objects from the VM object.

// This API will return `nil` if the corresponding pre-registration is not set into the configuration.

wasiobj := vm.GetImportObject(wasmedge.WASI)

// Initialize the WASI.

wasiobj.InitWasi(

  os.Args[1:],     // The args

  os.Environ(),    // The envs

  []string{"".:.""}, // The mapping preopens

)



// ...



vm.Release()

conf.Release()

```



Developers can change to use the WasmEdge-Go `v0.10.0` as follows, with only replacing the `ImportObject` into `Module`:



```go

conf := wasmedge.NewConfigure(wasmedge.WASI)

vm := wasmedge.NewVMWithConfig(conf)



// The following API can retrieve the pre-registration module instances from the VM object.

// This API will return `nil` if the corresponding pre-registration is not set into the configuration.

wasiobj := vm.GetImportModule(wasmedge.WASI)

// Initialize the WASI.

wasiobj.InitWasi(

  os.Args[1:],     // The args

  os.Environ(),    // The envs

  []string{"".:.""}, // The mapping preopens

)



// ...



vm.Release()

conf.Release()

```



The `VM` provides a new API for getting the current instantiated anonymous `Module` instance. For example, if developer want to get the exported `Global` instance:



```go

// Assume that a WASM module is instantiated in `vm`, and exports the ""global_i32"".

store := vm.GetStore()



globinst := store.FindGlobal(""global_i32"")

```



After the WasmEdge-Go `v0.10.0`, developers can use the `(*wasmedge.VM).GetActiveModule()` to get the module instance:



```go

// Assume that a WASM module is instantiated in `vm`, and exports the ""global_i32"".

mod := vm.GetActiveModule()



// The example of retrieving the global instance.

globinst := mod.FindGlobal(""global_i32"")

```



## WasmEdge Executor changes



`Executor` helps to instantiate a WASM module, register a WASM module into `Store` with module name, register the host modules with host functions, or invoke functions.



1. WASM module instantiation



   In WasmEdge-Go `v0.9.2` version, developers can instantiate a WASM module by the `Executor` API:



   ```go

   var ast *wasmedge.AST

   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.

   // Assume that `executor` is a `*wasmedge.Executor`.

   // Assume that `store` is a `*wasmedge.Store`.

   err := executor.Instantiate(store, ast)

   if err != nil {

     fmt.Println(""Instantiation FAILED:"", err.Error())

   }

   ```



   Then the WASM module is instantiated into an anonymous module instance and handled by the `Store`. If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned. After the WasmEdge-Go `v0.10.0` version, the instantiated anonymous module will be outputted and handled by caller, and not only 1 anonymous module instance can be instantiated. Developers have the responsibility to release the outputted module instances.



   ```go

   var ast1 *wasmedge.AST

   var ast2 *wasmedge.AST

   // Assume that `ast1` and `ast2` are loaded WASMs from different files or buffers,

   // and have both passed the validation.

   // Assume that `executor` is a `*wasmedge.Executor`.

   // Assume that `store` is a `*wasmedge.Store`.

   mod1, err1 := executor.Instantiate(store, ast1)

   if err1 != nil {

     fmt.Println(""Instantiation FAILED:"", err1.Error())

   }

   mod2, err2 := executor.Instantiate(store, ast2)

   if err2 != nil {

     fmt.Println(""Instantiation FAILED:"", err2.Error())

   }

   mod1.Release()

   mod2.Release()

   ```



2. WASM module registration with module name



   When instantiating and registering a WASM module with module name, developers can use the `(*wasmedge.Executor).RegisterModule()` API before WasmEdge-Go `v0.9.2`.



   ```go

   var ast *wasmedge.AST

   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.

   // Assume that `executor` is a `*wasmedge.Executor`.

   // Assume that `store` is a `*wasmedge.Store`.



   // Register the WASM module into store with the export module name ""mod"".

   err := executor.RegisterModule(store, ast, ""mod"")

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

   }

   ```



   The same feature is implemented in WasmEdge-Go `v0.10.0`, but in different API `(*wasmedge.Executor).Register()`:



   ```go

   var ast *wasmedge.AST

   // Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.

   // Assume that `executor` is a `*wasmedge.Executor`.

   // Assume that `store` is a `*wasmedge.Store`.



   // Register the WASM module into store with the export module name ""mod"".

   mod, err := executor.Register(store, ast, ""mod"")

   if err != nil {

     fmt.Println(""WASM registration FAILED:"", err.Error())

   }

   mod.Release()

   ```



   Developers have the responsibility to release the outputted module instances.



3. Host module registration



   In WasmEdge-Go `v0.9.2`, developers can create an `ImportObject` and register into `Store`.



   ```go

   // Create the import object with the export module name.

   impobj := wasmedge.NewImportObject(""module"")



   // ...

   // Add the host functions, tables, memories, and globals into the import object.



   // The import object has already contained the export module name.

   err := executor.RegisterImport(store, impobj)

   if err != nil {

     fmt.Println(""Import object registration FAILED:"", err.Error())

   }

   ```



   After WasmEdge-Go `v0.10.0`, developers should use the `Module` instance instead:



   ```go

   // Create the module instance with the export module name.

   impmod := wasmedge.NewModule(""module"")



   // ...

   // Add the host functions, tables, memories, and globals into the module instance.



   // The module instance has already contained the export module name.

   err := executor.RegisterImport(store, impmod)

   if err != nil {

     fmt.Println(""Module instance registration FAILED:"", err.Error())

   }

   ```



   Developers have the responsibility to release the created module instances.



4. WASM function invocation



   This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat). In WasmEdge-Go `v0.9.2` version, developers can invoke a WASM function with the export function name:



   ```go

   // Create the store object. The store object holds the instances.

   store := wasmedge.NewStore()

   // Error.

   var err error

   // AST object.

   var ast *wasmedge.AST

   // Return values.

   var res []interface{}



   // Create the loader object.

   loader := wasmedge.NewLoader()

   // Create the validator object.

   validator := wasmedge.NewValidator()

   // Create the executor object.

   executor := wasmedge.NewExecutor()



   // Load the WASM file or the compiled-WASM file and convert into the AST object.

   ast, err = loader.LoadFile(""fibonacci.wasm"")

   if err != nil {

     fmt.Println(""Load WASM from file FAILED:"", err.Error())

     return

   }

   // Validate the WASM module.

   err = validator.Validate(ast)

   if err != nil {

     fmt.Println(""Validation FAILED:"", err.Error())

     return

   }

   // Instantiate the WASM module into the Store object.

   err = executor.Instantiate(store, ast)

   if err != nil {

     fmt.Println(""Instantiation FAILED:"", err.Error())

     return

   }

   // Invoke the function which is exported with the function name ""fib"".

   res, err = executor.Invoke(store, ""fib"", int32(30))

   if err == nil {

     fmt.Println(""Get fibonacci[30]:"", res[0].(int32))

   } else {

     fmt.Println(""Run failed:"", err.Error())

   }



   ast.Release()

   loader.Release()

   validator.Release()

   executor.Release()

   store.Release()

   ```



   After the WasmEdge-Go `v0.10.0`, developers should retrieve the `Function` instance by function name first.



   ```go

   // ...

   // Ignore the unchanged steps before validation. Please refer to the sample code above.



   var mod *wasmedge.Module

   // Instantiate the WASM module and get the output module instance.

   mod, err = executor.Instantiate(store, ast)

   if err != nil {

     fmt.Println(""Instantiation FAILED:"", err.Error())

     return

   }

   // Retrieve the function instance by name.

   funcinst := mod.FindFunction(""fib"")

   if funcinst == nil {

     fmt.Println(""Run FAILED: Function name `fib` not found"")

     return

   }

   res, err = executor.Invoke(store, funcinst, int32(30))

   if err == nil {

     fmt.Println(""Get fibonacci[30]:"", res[0].(int32))

   } else {

     fmt.Println(""Run FAILED:"", err.Error())

   }



   ast.Release()

   mod.Release()

   loader.Release()

   validator.Release()

   executor.Release()

   store.Release()

   ```



## Instances retrievement



This example uses the WASM file `fibonacci.wasm` converted from the text format [fibonacci.wat](https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat).



Before the WasmEdge-Go `v0.9.2` versions, developers can retrieve all exported instances of named or anonymous modules from `Store`:



```go

// Create the store object. The store object holds the instances.

store := wasmedge.NewStore()

// Error.

var err error

// AST object.

var ast *wasmedge.AST



// Create the loader object.

loader := wasmedge.NewLoader()

// Create the validator object.

validator := wasmedge.NewValidator()

// Create the executor object.

executor := wasmedge.NewExecutor()



// Load the WASM file or the compiled-WASM file and convert into the AST object.

ast, err = loader.LoadFile(""fibonacci.wasm"")

if err != nil {

  fmt.Println(""Load WASM from file FAILED:"", err.Error())

  return

}

// Validate the WASM module.

err = validator.Validate(ast)

if err != nil {

  fmt.Println(""Validation FAILED:"", err.Error())

  return

}

// Example: register and instantiate the WASM module with the module name ""module_fib"".

err = executor.RegisterModule(store, ast, ""module_fib"")

if err != nil {

  fmt.Println(""Instantiation FAILED:"", err.Error())

  return

}

// Example: Instantiate the WASM module into the Store object.

err = executor.Instantiate(store, ast)

if err != nil {

  fmt.Println(""Instantiation FAILED:"", err.Error())

  return

}



// Now, developers can retrieve the exported instances from the store.

// Take the exported functions as example. This WASM exports the function ""fib"".

// Find the function ""fib"" from the instantiated anonymous module.

func1 := store.FindFunction(""fib"")

// Find the function ""fib"" from the registered module ""module_fib"".

func2 := store.FindFunctionRegistered(""module_fib"", ""fib"")



ast.Release()

store.Release()

loader.Release()

validator.Release()

executor.Release()

```



After the WasmEdge-Go `v0.10.0`, developers can instantiate several anonymous `Module` instances, and should retrieve the exported instances from named or anonymous `Module` instances:



```go

// Create the store object. The store is the object to link the modules for imports and exports.

store := wasmedge.NewStore()

// Error.

var err error

// AST object.

var ast *wasmedge.AST

// Module instances.

var namedmod *wasmedge.Module

var anonymousmod *wasmedge.Module



// Create the loader object.

loader := wasmedge.NewLoader()

// Create the validator object.

validator := wasmedge.NewValidator()

// Create the executor object.

executor := wasmedge.NewExecutor()



// Load the WASM file or the compiled-WASM file and convert into the AST object.

ast, err = loader.LoadFile(""fibonacci.wasm"")

if err != nil {

  fmt.Println(""Load WASM from file FAILED:"", err.Error())

  return

}

// Validate the WASM module.

err = validator.Validate(ast)

if err != nil {

  fmt.Println(""Validation FAILED:"", err.Error())

  return

}

// Example: register and instantiate the WASM module with the module name ""module_fib"".

namedmod, err = executor.Register(store, ast, ""module_fib"")

if err != nil {

  fmt.Println(""Instantiation FAILED:"", err.Error())

  return

}

// Example: Instantiate the WASM module and get the output module instance.

anonymousmod, err = executor.Instantiate(store, ast)

if err != nil {

  fmt.Println(""Instantiation FAILED:"", err.Error())

  return

}



// Now, developers can retrieve the exported instances from the module instances.

// Take the exported functions as example. This WASM exports the function ""fib"".

// Find the function ""fib"" from the instantiated anonymous module.

func1 := anonymousmod.FindFunction(""fib"")

// Find the function ""fib"" from the registered module ""module_fib"".

func2 := namedmod.FindFunction(""fib"")

// Or developers can get the named module instance from the store:

gotmod := store.FindModule(""module_fib"")

func3 := gotmod.FindFunction(""fib"")



namedmod.Release()

anonymousmod.Release()

ast.Release()

store.Release()

loader.Release()

validator.Release()

executor.Release()

```



## Host functions



The difference of host functions are the replacement of `ImportObject` struct.



```go

// Host function body definition.

func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

  // add: i32, i32 -> i32

  res := params[0].(int32) + params[1].(int32)



  // Set the returns

  returns := make([]interface{}, 1)

  returns[0] = res



  // Return

  return returns, wasmedge.Result_Success

}



// ...



// Create an import object with the module name ""module"".

impobj := wasmedge.NewImportObject(""module"")



// Create and add a function instance into the import object with export name ""add"".

functype := wasmedge.NewFunctionType(

  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

  []wasmedge.ValType{wasmedge.ValType_I32},

)

hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

// The third parameter is the pointer to the additional data object.

// Developers should guarantee the life cycle of the data, and it can be `nil`

// if the external data is not needed.

functype.Release()

impobj.AddFunction(""add"", hostfunc)



// The import object should be released.

// Developers should __NOT__ release the instances added into the import objects.

impobj.Release()

```



Developers can use the `Module` struct to upgrade to WasmEdge `v0.10.0` easily.



```go

// Host function body definition.

func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {

  // add: i32, i32 -> i32

  res := params[0].(int32) + params[1].(int32)



  // Set the returns

  returns := make([]interface{}, 1)

  returns[0] = res



  // Return

  return returns, wasmedge.Result_Success

}



// ...



// Create a module instance with the module name ""module"".

mod := wasmedge.NewModule(""module"")



// Create and add a function instance into the module instance with export name ""add"".

functype := wasmedge.NewFunctionType(

  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},

  []wasmedge.ValType{wasmedge.ValType_I32},

)

hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)

// The third parameter is the pointer to the additional data object.

// Developers should guarantee the life cycle of the data, and it can be `nil`

// if the external data is not needed.

functype.Release()

mod.AddFunction(""add"", hostfunc)



// The module instances should be released.

// Developers should __NOT__ release the instances added into the module instance objects.

mod.Release()

```








------"
"The following is a markdown document located at /embed/go/reference/upgrade_to_0.11.0.md
------


---

sidebar_position: 6

---



# Upgrade to WasmEdge-Go v0.11.0



Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the `v0.10.1` to the `v0.11.0` version.



## Concepts



1. Supported the user-defined error code in host functions.



   Developers can use the new API `WasmEdge_ResultGen()` to generate a `WasmEdge_Result` struct with `WasmEdge_ErrCategory_UserLevelError` and the error code. With this support, developers can specify the host function error code when failed by themselves. For the examples to specify the user-defined error code, please refer to [the example below](#user-defined-error-code-in-host-functions).



2. Calling frame for the host function extension



   In the previous versions, host functions only pass the memory instance into the function body. For supporting the WASM multiple memories proposal and providing the recursive invocation in host functions, the new context `WasmEdge_CallingFrameContext` replaced the memory instance in the second argument of the host function definition. For the examples of the new host function definition, please refer to [the example below](#calling-frame-in-host-functions).



3. Apply the SONAME and SOVERSION.



   When linking the WasmEdge shared library, please notice that `libwasmedge_c.so` is renamed to `libwasmedge.so` after the 0.11.0 release. Please use `-lwasmedge` instead of `-lwasmedge_c` for the linker option.



## User Defined Error Code In Host Functions



Assume that we want to specify that the host function failed in the versions before `0.10.1`:



```c

/* Host function body definition. */

WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* This will create a trap in WASM. */

  return WasmEdge_Result_Fail;

}

```



When the execution is finished, developers will get the `WasmEdge_Result`. If developers call the `WasmEdge_ResultOK()` with the returned result, they will get `false`. If developers call the `WasmEdge_ResultGetCode()` with the returned result, they will always get `2`.



For the versions after `0.11.0`, developers can specify the error code within 24-bit (smaller than `16777216`) size.



```c

/* Host function body definition. */

WasmEdge_Result FaildFunc(void *Data,

                          const WasmEdge_CallingFrameContext *CallFrameCxt,

                          const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* This will create a trap in WASM with the error code. */

  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);

}

```



Therefore when developers call the `WasmEdge_ResultGetCode()` with the returned result, they will get the error code `12345678`. Noticed that if developers call the `WasmEdge_ResultGetMessage()`, they will always get the C string `""user defined error code""`.



## Calling Frame In Host Functions



When implementing the host functions, developers usually use the input memory instance to load or store data. In the WasmEdge versions before `0.10.1`, the argument before the input and return value list of the host function definition is the memory instance context, so that developers can access the data in the memory instance.



```c

/* Host function body definition. */

WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,

                           const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* Function type: {i32} -> {} */

  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

  uint32_t Num = 0;

  WasmEdge_Result Res =

      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

  if (WasmEdge_ResultOK(Res)) {

    printf(""u32 at memory[%u]: %u\n"", Offset, Num);

  } else {

    return Res;

  }

  return WasmEdge_Result_Success;

}

```



The input memory instance is the one that belongs to the module instance on the top calling frame of the stack. However, after applying the WASM multiple memories proposal, there may be more than 1 memory instance in a WASM module. Furthermore, there may be requests for accessing the module instance on the top frame of the stack to get the exported WASM functions, such as recursive invocation in host functions. To support these, the `WasmEdge_CallingFrameContext` is designed to replace the memory instance input of the host function.



In the WasmEdge versions after `0.11.0`, the host function definitions are changed:



```c

typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(

    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

    const WasmEdge_Value *Params, WasmEdge_Value *Returns);



typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(

    void *This, void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,

    const WasmEdge_Value *Params, const uint32_t ParamLen,

    WasmEdge_Value *Returns, const uint32_t ReturnLen);

```



Developers need to change to use the `WasmEdge_CallingFrameContext` related APIs to access the memory instance:



```c

/* Host function body definition. */

WasmEdge_Result LoadOffset(void *Data,

                           const WasmEdge_CallingFrameContext *CallFrameCxt,

                           const WasmEdge_Value *In, WasmEdge_Value *Out) {

  /* Function type: {i32} -> {} */

  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);

  uint32_t Num = 0;



  /* Get the 0th memory instance of the module of the top frame on the stack. */

  WasmEdge_MemoryInstanceContext *MemCxt =

      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);

  WasmEdge_Result Res =

      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);

  if (WasmEdge_ResultOK(Res)) {

    printf(""u32 at memory[%u]: %u\n"", Offset, Num);

  } else {

    return Res;

  }

  return WasmEdge_Result_Success;

}

```



The `WasmEdge_CallingFrameGetModuleInstance()` API can help developers to get the module instance of the top frame on the stack. With the module instance context, developers can use the module instance-related APIs to get its contents.



The `WasmEdge_CallingFrameGetExecutor()` API can help developers to get the currently used executor context. Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.








------"
"The following is a markdown document located at /embed/go/reference/upgrade_to_0.12.0.md
------


---

sidebar_position: 4

---



# Upgrade to WasmEdge-Go v0.12.0



Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.11.2` to the `v0.12.0` version.



## Concepts



1. Removed the members of the `wasmedge.HostRegistration` related const values.



   The following const values are removed:



   - `wasmedge.WasmEdge_Process`

   - `wasmedge.WasiNN`

   - `wasmedge.WasiCrypto_Common`

   - `wasmedge.WasiCrypto_AsymmetricCommon`

   - `wasmedge.WasiCrypto_Kx`

   - `wasmedge.WasiCrypto_Signatures`

   - `wasmedge.WasiCrypto_Symmetric`



   The `wasmedge.VM` objects will create and register the host modules automatically now. If the plug-ins are not loaded, the `VM` objects will create and register the mock modules to prevent from import failed.



2. Removed the module instance creation functions of the plug-ins.



   The following APIs are removed:



   - `wasmedge.NewWasiNNModule()`

   - `wasmedge.NewWasiCryptoCommonModule()`

   - `wasmedge.NewWasiCryptoAsymmetricCommonModule()`

   - `wasmedge.NewWasiCryptoKxModule()`

   - `wasmedge.NewWasiCryptoSignaturesModule()`

   - `wasmedge.NewWasiCryptoSymmetricModule()`

   - `wasmedge.NewWasmEdgeProcessModule()`



   For the new examples for creating the module instances from plug-ins, please refer to [the example below](#creating-the-module-instance-from-a-plug-in).



3. New module instance retrieving API of `VM` objects.



   - Added `(*wasmedge.VM).GetRegisteredModule()` for retrieving registered named module in `VM` objects quickly.

   - Added `(*wasmedge.VM).ListRegisteredModule()` for listing registered named modules in `VM` objects quickly.



## The `wasmedge.HostRegistration` const values for plug-ins are not necessary in VM objects



Before the version `v0.11.2`, developers should add the configurations when they want to load the plug-ins in VM:



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()



conf := wasmedge.NewConfigure(wasmedge.WASI)

comf.AddConfig(wasmedge.WasiCrypto_Common)

comf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)

comf.AddConfig(wasmedge.WasiCrypto_Kx)

comf.AddConfig(wasmedge.WasiCrypto_Signatures)

comf.AddConfig(wasmedge.WasiCrypto_Symmetric)

vm := wasmedge.NewVMWithConfig(conf)

conf.Release()



store := vm.GetStore()

modulelist := store.ListModule()

for _, name := range modulelist {

  fmt.Println(name)

}

// Will print:

//   wasi_ephemeral_crypto_asymmetric_common

//   wasi_ephemeral_crypto_common

//   wasi_ephemeral_crypto_kx

//   wasi_ephemeral_crypto_signatures

//   wasi_ephemeral_crypto_symmetric

vm.Release()

```



After `v0.12.0`, the plug-ins will automatically loaded after the `wasmedge.LoadPluginDefaultPaths()` called or the specific path given into the `wasmedge.LoadPluginFromPath()` API.



For the plug-ins not installed, the mocked modules will be registered into `VM` objects and will print the error message when invoking the host functions to notice the users to install the plug-in.



```go

wasmedge.LoadPluginDefaultPaths()

// The `wasmedge.WASI` is still needed.

conf := wasmedge.NewConfigure(wasmedge.WASI)

vm := wasmedge.NewVMWithConfig(conf)

conf.Release()



modulelist := vm.ListRegisteredModule()

for _, name := range modulelist {

  fmt.Println(name)

}

// Will print:

//   wasi_ephemeral_crypto_asymmetric_common

//   wasi_ephemeral_crypto_common

//   wasi_ephemeral_crypto_kx

//   wasi_ephemeral_crypto_signatures

//   wasi_ephemeral_crypto_symmetric

//   wasi_ephemeral_nn

//   wasi_snapshot_preview1

//   wasmedge_httpsreq

//   wasmedge_process

vm.Release()

```



<!-- prettier-ignore -->

:::note

The `wasmedge.WASI` configuration is still needed if developers want to use the WASI.

:::



## Creating the module instance from a plug-in



When developers didn't use the VM objects to load the plug-ins, they can use the creation functions before the `v0.11.2` versions:



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()



cryptocommonmod := wasmedge.NewWasiCryptoCommonModule()



cryptocommonmod.Release()

```



But it not make sense and not extensionable if developers should use different APIs for the different plug-ins.



After the `v0.12.0` version, the `wasmedge.Plugin` struct is added, and developers can use the general API to create the module instances:



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()



cryptoplugin := wasmedge.FindPlugin(""wasi_crypto"")

if ctyptoplugin == nil {

  fmt.Println(""FAIL: Cannot find the wasi_crypto plugin."")

  return

}



cryptocommonmod := cryptoplugin.CreateModule(""wasi_crypto_common"")



cryptocommonmod.Release()

```



## Retrieving the module instances from the VM context



Before the version `v0.11.2`, developers can retrieve the `WASI` or the modules from plug-ins with the `wasmedge.HostRegistration` const values, or retrieve the registered modules from the `store` object.



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()

conf := wasmedge.NewConfigure(wasmedge.WASI)

comf.AddConfig(wasmedge.WasiCrypto_Common)

comf.AddConfig(wasmedge.WasiCrypto_AsymmetricCommon)

comf.AddConfig(wasmedge.WasiCrypto_Kx)

comf.AddConfig(wasmedge.WasiCrypto_Signatures)

comf.AddConfig(wasmedge.WasiCrypto_Symmetric)

vm := wasmedge.NewVMWithConfig(conf)

conf.Release()



// Get the WASI module instance.

wasimod := vm.GetImportModule(wasmedge.WASI)

// Get the WASI-crypto-common module instance.

cryptocommonmod := vm.GetImportModule(wasmedge.WasiCrypto_Common)



// Get the registered module instance by name.

store := vm.GetStore()

cryptokxmod := store.FindModule(""wasi_ephemeral_crypto_kx"")



vm.Release()

```



After the `v0.12.0` version, due to removing the plug-in related configurations and automatically registering the plug-ins into VM objects, developers cannot use the `(*wasmedge.VM).GetImportModule()` API to retrieve the module instances except the built-in host modules (`WASI` currently).



However, developers can use the new APIs to retrieve the registered module instances more quickly.



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()

// Add the WASI configurations.

conf := wasmedge.NewConfigure(wasmedge.WASI)

vm := wasmedge.NewVMWithConfig(conf)

conf.Release()



// Get the WASI module instance.

wasimod := vm.GetImportModule(wasmedge.WASI)

// Get the registered WASI-crypto-common module instance by name.

cryptocommonmod := vm.GetRegisteredModule(""wasi_ephemeral_crypto_common"")



vm.Release()

```








------"
"The following is a markdown document located at /embed/go/reference/upgrade_to_0.13.0.md
------


---

sidebar_position: 2

---



# Upgrade to WasmEdge-Go v0.13.0



Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the `v0.12.1` to the `v0.13.0` version.



## Concepts



1. Removed the `TensorFlow`, `TensorFlow-Lite`, and `Image` extension APIs.



   After `v0.13.0`, the WasmEdge extensions are replaced by the corresponding plug-ins. Please refer to our newest [example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_mtcnn).



2. Asynchronously invoking WASM function by executor.



   Developers can use the `(wasmedge.Executor).AsyncInvoke()` API to execute a WASM function asynchronously.



3. Fixed the `(wasmedge.Executor).Invoke()` API to remove the first `wasmedge.Store` parameter.



   It's easy to update. Just drop the first parameter.



4. Unified WasmEdge CLI.



   Developers can use the `wasmedge.RunWasmEdgeUnifiedCLI()` API to trigger the unified WasmEdge CLI.








------"
"```json:/embed/go/_category_.json


{

  ""label"": ""Go SDK for Embedding WasmEdge"",

  ""position"": 6,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to Embed WasmEdge in your Go host applications.""

  }

}








```"
"The following is a markdown document located at /embed/go/ai.md
------


---

sidebar_position: 5

---



# AI Inference with TensorFlow



<!-- prettier-ignore -->

:::note

The WasmEdge extensions have been deprecated after the v0.12.1 version. We'll update to use the WasmEdge plug-in in the future.

:::



In this section, we will show you how to create a TensorFlow or TensorFlow-Lite inference function in Rust for image classification and then embed it into a Go application. The project source code is [available here](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/).



## The WASM app in Rust



The Rust function for image classification is [available here](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/rust_tflite_food/src/lib.rs). It utilizes the WasmEdge Tensorflow Lite plug-in as well as the [wasmedge_bindgen](function.md) for passing call parameters.



```rust

#[wasmedge_bindgen]

fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {

  let img = image::load_from_memory(&image_data).unwrap().to_rgb8();

  let flat_img = image::imageops::thumbnail(&img, 192, 192);



  let model_data: &[u8] = include_bytes!(""lite-model_aiy_vision_classifier_food_V1_1.tflite"");

  let labels = include_str!(""aiy_food_V1_labelmap.txt"");



  let mut session = wasmedge_tensorflow_interface::TFLiteSession::new(model_data);

  session.add_input(""input"", &flat_img).run();

  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Softmax"");

  ... ...

}

```



## Compile the Rust code to Wasm



You can build the standard `Cargo` command into a WebAssembly function.



```bash

git clone https://github.com/second-state/WasmEdge-go-examples.git

cd go_TfliteFood/rust_tflite_food

cargo build --target wasm32-wasi --release

cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../

cd ../

```



You can use our AOT compiler `wasmedge compile` to instrument the WebAssembly file to make it run much faster. [Learn more](../../start/build-and-run/aot.md).



```bash

wasmedge compile rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm

```



## Go host app



The [Go host app](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_TfliteFood/tflite_food.go) source code shows how to instantiate a WasmEdge runtime with the Tensorflow extension, and how to pass the image data to the Rust function in WasmEdge to run the inference.



```go

import (

  ""fmt""

  ""io/ioutil""

  ""os""



  ""github.com/second-state/WasmEdge-go/wasmedge""

  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""

)



func main() {

  fmt.Println(""Go: Args:"", os.Args)

  // Expected Args[0]: program name (./mobilenet)

  // Expected Args[1]: wasm file (rust_mobilenet_lib.wasm)

  // Expected Args[2]: input image name (grace_hopper.jpg)



  // Set not to print debug info

  wasmedge.SetLogErrorLevel()



  // Set Tensorflow not to print debug info

  os.Setenv(""TF_CPP_MIN_LOG_LEVEL"", ""3"")

  os.Setenv(""TF_CPP_MIN_VLOG_LEVEL"", ""3"")



  // Load WasmEdge-image and WasmEdge-tensorflow from default path

  wasmedge.LoadPluginDefaultPaths()



  // Create configure

  var conf = wasmedge.NewConfigure(wasmedge.WASI)



  // Create VM with configure

  var vm = wasmedge.NewVMWithConfig(conf)



  // Init WASI

  var wasi = vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping preopens

  )



  // Load and validate the wasm

  vm.LoadWasmFile(os.Args[1])

  vm.Validate()



  // Instantiate the bindgen and vm

  bg := bindgen.New(vm)

  bg.Instantiate()



  img, _ := ioutil.ReadFile(os.Args[2])

  if res, _, err := bg.Execute(""infer"", img); err != nil {

    fmt.Println(err)

  } else {

    fmt.Println(res[0].(string))

  }



  bg.Release()

  vm.Release()

  conf.Release()

}

```



## Build and run the wasm app from your go host



<!-- prettier-ignore -->

:::note

Ensure you have installed [Go, WasmEdge, and WasmEdge Go SDK with the TensorFlow extension](intro.md).

:::



Builds the Go host application with the WasmEdge Go SDK.



```bash

go build

```



Now you can run the Go application. It calls the WebAssembly function in WasmEdge to run inference on the input image.



```bash

./tflite_food rust_tflite_food_lib.wasm food.jpg

```



The results are as follows.



```bash

Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]

It is very likely a Hot dog in the picture

```








------"
"The following is a markdown document located at /embed/go/app.md
------


---

sidebar_position: 2

---



# Embed a standalone WASM app



The WasmEdge Go SDK can [embed standalone WebAssembly applications](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile) — ie a Rust application with a `main()` function compiled into WebAssembly.



## The WASM app in Rust



Our [demo Rust application](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile) reads from a file. Note that the WebAssembly program's input and output data are now passed by the STDIN and STDOUT.



```rust

use std::env;

use std::fs::File;

use std::io::{self, BufRead};



fn main() {

  // Get the argv.

  let args: Vec<String> = env::args().collect();

  if args.len() <= 1 {

    println!(""Rust: ERROR - No input file name."");

    return;

  }



  // Open the file.

  println!(""Rust: Opening input file \""{}\""..."", args[1]);

  let file = match File::open(&args[1]) {

    Err(why) => {

      println!(""Rust: ERROR - Open file \""{}\"" failed: {}"", args[1], why);

      return;

    },

    Ok(file) => file,

  };



  // Read lines.

  let reader = io::BufReader::new(file);

  let mut texts:Vec<String> = Vec::new();

  for line in reader.lines() {

    if let Ok(text) = line {

      texts.push(text);

    }

  }

  println!(""Rust: Read input file \""{}\"" succeeded."", args[1]);



  // Get stdin to print lines.

  println!(""Rust: Please input the line number to print the line of file."");

  let stdin = io::stdin();

  for line in stdin.lock().lines() {

    let input = line.unwrap();

    match input.parse::<usize>() {

      Ok(n) => if n > 0 && n <= texts.len() {

        println!(""{}"", texts[n - 1]);

      } else {

        println!(""Rust: ERROR - Line \""{}\"" is out of range."", n);

      },

      Err(e) => println!(""Rust: ERROR - Input \""{}\"" is not an integer: {}"", input, e),

    }

  }

  println!(""Rust: Process end."");

}

```



## Compile the Rust code into Wasm



Next, let's compile the application into WebAssembly.



```bash

git clone https://github.com/second-state/WasmEdge-go-examples.git

cd rust_readfile

cargo build --target wasm32-wasi

# The output file will be target/wasm32-wasi/debug/rust_readfile.wasm

```



## The Go Host app



The Go source code to run the WebAssembly function in WasmEdge is as follows.



```go

package main



import (

  ""os""

  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.SetLogErrorLevel()



  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)

  conf.AddConfig(wasmedge.WASI)

  var vm = wasmedge.NewVMWithConfig(conf)

  var wasi = vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping directories

  )



  // Instantiate wasm. _start refers to the main() function

  vm.RunWasmFile(os.Args[1], ""_start"")



  vm.Release()

  conf.Release()

}

```



## Run the compiled WASM file from Go host



::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::



Next, let's build the Go application with the WasmEdge Go SDK.



```bash

go build

```



Run the Golang application.



```bash

$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt

Rust: Opening input file ""file.txt""...

Rust: Read input file ""file.txt"" succeeded.

Rust: Please input the line number to print the line of file.

# Input ""5"" and press Enter.

5

# The output will be the 5th line of `file.txt`:

abcDEF___!@#$%^

# To terminate the program, send the EOF (Ctrl + D).

^D

# The output will print the terminate message:

Rust: Process end.

```



More examples can be found at [the WasmEdge-go-examples GitHub repo.](https://github.com/second-state/WasmEdge-go-examples)








------"
"The following is a markdown document located at /embed/go/bindgen.md
------


---

sidebar_position: 6

---



# Embed a bindgen function



In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs), we will demonstrate how to call a few simple WebAssembly functions from a Go app. The [functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) are written in Rust, and require complex call parameters and return values. The `#[wasmedge_bindgen]` macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.



## The WASM app in Rust



The WebAssembly spec only supports a few simple data types out of the box. It [does not support](https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333) types such as string and array. To pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The `wasmedge_bindgen` tool does this conversion automatically.



```rust

use num_integer::lcm;

use serde::{Deserialize, Serialize};

use sha3::{Digest, Keccak256, Sha3_256};

#[allow(unused_imports)]

use wasmedge_bindgen::*;

use wasmedge_bindgen_macro::*;



#[derive(Serialize, Deserialize, Debug)]

struct Point {

    x: f32,

    y: f32,

}



#[derive(Serialize, Deserialize, Debug)]

struct Line {

    points: Vec<Point>,

    valid: bool,

    length: f32,

    desc: String,

}



#[wasmedge_bindgen]

pub fn create_line(p1: String, p2: String, desc: String) -> String {

    let point1: Point = serde_json::from_str(&p1).unwrap();

    let point2: Point = serde_json::from_str(&p2).unwrap();

    let length = ((point1.x - point2.x) * (point1.x - point2.x)

        + (point1.y - point2.y) * (point1.y - point2.y))

        .sqrt();



    let valid = if length == 0.0 { false } else { true };



    let line = Line {

        points: vec![point1, point2],

        valid: valid,

        length: length,

        desc: desc,

    };



    return serde_json::to_string(&line).unwrap();

}



#[wasmedge_bindgen]

pub fn say(s: String) -> String {

    let r = String::from(""hello "");

    return r + &s;

}



#[wasmedge_bindgen]

pub fn obfusticate(s: String) -> String {

    (&s).chars()

        .map(|c| match c {

            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,

            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,

            _ => c,

        })

        .collect()

}



#[wasmedge_bindgen]

pub fn lowest_common_multiple(a: i32, b: i32) -> i32 {

    let r = lcm(a, b);

    return r;

}



#[wasmedge_bindgen]

pub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {

    return Sha3_256::digest(&v).as_slice().to_vec();

}



#[wasmedge_bindgen]

pub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {

    return Keccak256::digest(&s).as_slice().to_vec();

}

```



## Compile the Rust code to Wasm



First, we will compile the Rust source code into WebAssembly bytecode functions.



```bash

git clone https://github.com/second-state/WasmEdge-go-examples.git

cd rust_bindgen_funcs

$cargo build --release --target wasm32-wasi

# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm

```



## The Go host app



The [Go source code](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go) to run the WebAssembly function in WasmEdge is as follows. The `Execute()` function calls the WebAssembly function and passes the call parameters using the `#[wasmedge_bindgen]` convention.



```go

package main



import (

  ""fmt""

  ""os""



  ""github.com/second-state/WasmEdge-go/wasmedge""

  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""

)



func main() {

  // Expected Args[0]: program name (./bindgen_funcs)

  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))



  // Set not to print debug info

  wasmedge.SetLogErrorLevel()



  // Create configure

  var conf = wasmedge.NewConfigure(wasmedge.WASI)



  // Create VM with configure

  var vm = wasmedge.NewVMWithConfig(conf)



  // Init WASI

  var wasi = vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping preopens

  )



  vm.LoadWasmFile(os.Args[1])

  vm.Validate()

  // Instantiate the bindgen and vm

  bg := bindgen.New(vm)

  bg.Instantiate()



  // Run bindgen functions

  var res []interface{}

  var err error

  // create_line: array, array, array -> array (inputs are JSON stringified)

  res, _, err = bg.Execute(""create_line"", ""{\""x\"":1.5,\""y\"":3.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")

  if err == nil {

    fmt.Println(""Run bindgen -- create_line:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- create_line FAILED"")

  }

  // say: array -> array

  res, _, err = bg.Execute(""say"", ""bindgen funcs test"")

  if err == nil {

    fmt.Println(""Run bindgen -- say:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- say FAILED"")

  }

  // obfusticate: array -> array

  res, _, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")

  if err == nil {

    fmt.Println(""Run bindgen -- obfusticate:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- obfusticate FAILED"")

  }

  // lowest_common_multiple: i32, i32 -> i32

  res, _, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))

  if err == nil {

    fmt.Println(""Run bindgen -- lowest_common_multiple:"", res[0].(int32))

  } else {

    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")

  }

  // sha3_digest: array -> array

  res, _, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- sha3_digest:"", res[0].([]byte))

  } else {

    fmt.Println(""Run bindgen -- sha3_digest FAILED"")

  }

  // keccak_digest: array -> array

  res, _, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- keccak_digest:"", res[0].([]byte))

  } else {

    fmt.Println(""Run bindgen -- keccak_digest FAILED"")

  }



  bg.Release()

  conf.Release()

}

```



## Build and run the WASM app from your go host



::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::



Next, let's build the Go application with the WasmEdge Go SDK.



```bash

go build

```



Run the Go application and it will run the WebAssembly functions embedded in the WasmEdge runtime.



```bash

$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm

Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}

Run bindgen -- say: hello bindgen funcs test

Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt

Run bindgen -- lowest_common_multiple: 246

Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]

Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]

```








------"
"The following is a markdown document located at /embed/go/function.md
------


---

sidebar_position: 3

---



# Embed WASM Functions



In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs), we will demonstrate how to call a few simple WebAssembly functions from a Go app. The [functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) are written in Rust, and require complex call parameters and return values. The `#[wasmedge_bindgen]` macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.



## The WASM app in Rust



As we [described](../data/intro.md) here, the WebAssembly spec only supports a few simple data types out of the box. It [does not support](https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333) types such as string and array. To pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The `wasmedge_bindgen` tool does this conversion automatically.



```rust

use num_integer::lcm;

use serde::{Deserialize, Serialize};

use sha3::{Digest, Keccak256, Sha3_256};

#[allow(unused_imports)]

use wasmedge_bindgen::*;

use wasmedge_bindgen_macro::*;



#[derive(Serialize, Deserialize, Debug)]

struct Point {

    x: f32,

    y: f32,

}



#[derive(Serialize, Deserialize, Debug)]

struct Line {

    points: Vec<Point>,

    valid: bool,

    length: f32,

    desc: String,

}



#[wasmedge_bindgen]

pub fn create_line(p1: String, p2: String, desc: String) -> String {

    let point1: Point = serde_json::from_str(&p1).unwrap();

    let point2: Point = serde_json::from_str(&p2).unwrap();

    let length = ((point1.x - point2.x) * (point1.x - point2.x)

        + (point1.y - point2.y) * (point1.y - point2.y))

        .sqrt();



    let valid = if length == 0.0 { false } else { true };



    let line = Line {

        points: vec![point1, point2],

        valid: valid,

        length: length,

        desc: desc,

    };



    return serde_json::to_string(&line).unwrap();

}



#[wasmedge_bindgen]

pub fn say(s: String) -> String {

    let r = String::from(""hello "");

    return r + &s;

}



#[wasmedge_bindgen]

pub fn obfusticate(s: String) -> String {

    (&s).chars()

        .map(|c| match c {

            'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,

            'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,

            _ => c,

        })

        .collect()

}



#[wasmedge_bindgen]

pub fn lowest_common_multiple(a: i32, b: i32) -> i32 {

    let r = lcm(a, b);

    return r;

}



#[wasmedge_bindgen]

pub fn sha3_digest(v: Vec<u8>) -> Vec<u8> {

    return Sha3_256::digest(&v).as_slice().to_vec();

}



#[wasmedge_bindgen]

pub fn keccak_digest(s: Vec<u8>) -> Vec<u8> {

    return Keccak256::digest(&s).as_slice().to_vec();

}

```



## Compile the Rust code to Wasm



First, we will compile the Rust source code into WebAssembly bytecode functions.



```bash

git clone https://github.com/second-state/WasmEdge-go-examples.git

cd rust_bindgen_funcs

cargo build --release --target wasm32-wasi

# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm

```



## The Go host app



The [Go source code](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go) to run the WebAssembly function in WasmEdge is as follows. The `Execute()` function calls the WebAssembly function and passes the call parameters using the `#[wasmedge_bindgen]` convention.



```go

package main



import (

  ""fmt""

  ""os""



  ""github.com/second-state/WasmEdge-go/wasmedge""

  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""

)



func main() {

  // Expected Args[0]: program name (./bindgen_funcs)

  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))



  // Set not to print debug info

  wasmedge.SetLogErrorLevel()



  // Create configure

  var conf = wasmedge.NewConfigure(wasmedge.WASI)



  // Create VM with configure

  var vm = wasmedge.NewVMWithConfig(conf)



  // Init WASI

  var wasi = vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping preopens

  )



  vm.LoadWasmFile(os.Args[1])

  vm.Validate()

  // Instantiate the bindgen and vm

  bg := bindgen.New(vm)

  bg.Instantiate()



  // Run bindgen functions

  var res []interface{}

  var err error

  // create_line: array, array, array -> array (inputs are JSON stringified)

  res, _, err = bg.Execute(""create_line"", ""{\""x\"":1.5,\""y\"":3.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")

  if err == nil {

    fmt.Println(""Run bindgen -- create_line:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- create_line FAILED"")

  }

  // say: array -> array

  res, _, err = bg.Execute(""say"", ""bindgen funcs test"")

  if err == nil {

    fmt.Println(""Run bindgen -- say:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- say FAILED"")

  }

  // obfusticate: array -> array

  res, _, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")

  if err == nil {

    fmt.Println(""Run bindgen -- obfusticate:"", res[0].(string))

  } else {

    fmt.Println(""Run bindgen -- obfusticate FAILED"")

  }

  // lowest_common_multiple: i32, i32 -> i32

  res, _, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))

  if err == nil {

    fmt.Println(""Run bindgen -- lowest_common_multiple:"", res[0].(int32))

  } else {

    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")

  }

  // sha3_digest: array -> array

  res, _, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- sha3_digest:"", res[0].([]byte))

  } else {

    fmt.Println(""Run bindgen -- sha3_digest FAILED"")

  }

  // keccak_digest: array -> array

  res, _, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- keccak_digest:"", res[0].([]byte))

  } else {

    fmt.Println(""Run bindgen -- keccak_digest FAILED"")

  }



  bg.Release()

  conf.Release()

}

```



## Build and run the WASM app from your Go host app



::note Make sure you have installed [Go, WasmEdge, and WasmEdge Go SDK](intro.md). ::



Next, let's build the Go application with the WasmEdge Go SDK.



```bash

go build

```



Run the Go application, and it will run the WebAssembly functions embedded in the WasmEdge runtime.



```bash

$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm

Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}

Run bindgen -- say: hello bindgen funcs test

Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt

Run bindgen -- lowest_common_multiple: 246

Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]

Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]

```








------"
"The following is a markdown document located at /embed/go/intro.md
------


---

sidebar_position: 1

---



# WasmEdge Go SDK Introduction



The following is the guide to working with the WasmEdge Go API. You can embed the WasmEdge into your go application through the WasmEdge Go API.



## Set up Environment for embedding WASM functions into your go application



### Install and build WasmEdge and WasmEdge Go SDK



The WasmEdge-go requires Golang version >= 1.16. Please check your Golang version before installation. You can [download Golang here](https://golang.org/dl/).



```bash

$ go version

go version go1.16.5 linux/amd64

```



Meanwhile, please ensure you have installed [WasmEdge](../../start/install.md#install) with the same `WasmEdge-go` release version.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}

```



Install the `WasmEdge-go` package and build in your Go project directory:



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

go build

```



### Build WasmEdge-go Extensions



<!-- prettier-ignore -->

:::note

The WasmEdge extensions have been deprecated after the 0.12.1 version. Please use the corresponding plug-ins after the 0.13.0 version.

:::



By default, the `WasmEdge-go` only turns on the basic runtime.



`WasmEdge-go` has the following extensions:



- TensorFlow



  - This extension supports the host functions in [WasmEdge-tensorflow](https://github.com/second-state/WasmEdge-tensorflow).

  - To install the `tensorflow` extension, please use the `-e tensorflow` flag in the WasmEdge installer command.

  - For using this extension, the tag `tensorflow` when building is required:



    ```bash

    go build -tags tensorflow

    ```



- Image



  - This extension supports the host functions in [WasmEdge-image](https://github.com/second-state/WasmEdge-image).

  - To install the `image` extension, please use the `-e image` flag in the WasmEdge installer command.

  - For using this extension, the tag `image` when building is required:



    ```bash

    go build -tags image

    ```



You can also turn on the multiple extensions when building:



```bash

go build -tags image,tensorflow

```



For examples, please refer to the [example repository](https://github.com/second-state/WasmEdge-go-examples/).



### WasmEdge AOT Compiler in Go



The [go_WasmAOT example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT) demonstrates how to compile a WASM file into a native binary (AOT compile) from within a Go application.



### Toolchain for Compile the Source Code to WASM Bytecode



To embed WasmEdge into your go application and run the WASM function, we still need language toolchain to compile the source code to WASM bytecode.



- For Rust, please refer to [the Rust setup guide](../../develop/rust/setup.md)



- For Tinygo, please refer to [the Tinygo setup guide](../../develop/go/hello_world.md)



- For C, please refer to [the C setup guide](../../develop/c/hello_world.md)



- For Javascript, you need the [WasmEdge-QuickJS](https://github.com/second-state/wasmedge-quickjs) into your Go application. See a community example [here](https://github.com/Edgenesis/wasm-shifu-demo).



## Examples



- [Embed a standalone WASM app](app.md)

- [Embed a WASM function](function.md)

- [Pass complex parameters to WASM functions](passing_data.md)

- [Embed a Tensorflow inference function](ai.md)

- [Embed a bindgen function](bindgen.md)



## API References



- [v0.13.4](reference/latest.md)

- [v0.12.1](reference/0.12.x.md)

- [v0.11.2](reference/0.11.x.md)

- [v0.10.1](reference/0.10.x.md)

- [v0.9.1](reference/0.9.x.md)








------"
"The following is a markdown document located at /embed/go/passing_data.md
------


---

sidebar_position: 4

---



# Pass complex parameters to WASM functions



An issue with the WebAssembly spec is that it only supports a very limited number of data types. If you want to embed a WebAssembly function with complex call parameters or return values, you must manage memory pointers on Go SDK and WebAssembly function sides.



Complex call parameters and return values include dynamic memory structures such as strings and byte arrays.



In this section, we will discuss several examples.



- [Pass complex parameters to WASM functions](#pass-complex-parameters-to-wasm-functions)

  - [Pass strings to Rust functions](#pass-strings-to-rust-functions)

  - [Pass strings to TinyGo functions](#pass-strings-to-tinygo-functions)

  - [Pass bytes to Rust functions](#pass-bytes-to-rust-functions)

  - [Pass bytes to TinyGo functions](#pass-bytes-to-tinygo-functions)



## Pass strings to Rust functions



In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreet), we will demonstrate how to call [a Rust-based WebAssembly function](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/rust_memory_greet/src/lib.rs) from a Go app. Specially, we will discuss how to pass string data.



<!-- prettier-ignore -->

:::note

An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the `wasmedge_bindgen` compiler tool. You can [learn more here](bindgen.md).

:::



The Rust function takes a memory pointer for the string and constructs the Rust string itself.



```rust

use std::ffi::{CStr, CString};

use std::mem;

use std::os::raw::{c_char, c_void};



#[no_mangle]

pub extern fn allocate(size: usize) -> *mut c_void {

  let mut buffer = Vec::with_capacity(size);

  let pointer = buffer.as_mut_ptr();

  mem::forget(buffer);



  pointer as *mut c_void

}



#[no_mangle]

pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {

  unsafe {

    let _ = Vec::from_raw_parts(pointer, 0, capacity);

  }

}



#[no_mangle]

pub extern fn greet(subject: *mut c_char) -> *mut c_char {

  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };

  let mut output = b""Hello, "".to_vec();

  output.extend(&subject);

  output.extend(&[b'!']);



  unsafe { CString::from_vec_unchecked(output) }.into_raw()

}

```



Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.



```bash

cd rust_memory_greet

cargo build --target wasm32-wasi

# The output WASM will be `target/wasm32-wasi/debug/rust_memory_greet_lib.wasm`.

```



The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/greet_memory.go) must call `allocate` from the WasmEdge VM to get a pointer to the string parameter. It will then call the `greet` function in Rust with the pointer. After the function returns, the Go application will call `deallocate` to free the memory space.



```go

package main



import (

  ""fmt""

  ""os""

  ""strings""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.SetLogErrorLevel()

  conf := wasmedge.NewConfigure(wasmedge.WASI)

  vm := wasmedge.NewVMWithConfig(conf)



  wasi := vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],

    os.Environ(),

    []string{"".:.""},

  )



  err := vm.LoadWasmFile(os.Args[1])

  if err != nil {

    fmt.Println(""failed to load wasm"")

  }

  vm.Validate()

  vm.Instantiate()



  subject := ""WasmEdge""

  lengthOfSubject := len(subject)



  // Allocate memory for the subject, and get a pointer to it.

  // Include a byte for the NULL terminator we add below.

  allocateResult, _ := vm.Execute(""allocate"", int32(lengthOfSubject + 1))

  inputPointer := allocateResult[0].(int32)



  // Write the subject into the memory.

  mod := vm.GetActiveModule()

  mem := mod.FindMemory(""memory"")

  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))

  copy(memData, subject)



  // C-string terminates by NULL.

  memData[lengthOfSubject] = 0



  // Run the `greet` function. Given the pointer to the subject.

  greetResult, _ := vm.Execute(""greet"", inputPointer)

  outputPointer := greetResult[0].(int32)



  pageSize := mem.GetPageSize()

  // Read the result of the `greet` function.

  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))

  nth := 0

  var output strings.Builder



  for {

    if memData[int(outputPointer) + nth] == 0 {

      break

    }



    output.WriteByte(memData[int(outputPointer) + nth])

    nth++

  }



  lengthOfOutput := nth



  fmt.Println(output.String())



  // Deallocate the subject, and the output.

  vm.Execute(""deallocate"", inputPointer, int32(lengthOfSubject+1))

  vm.Execute(""deallocate"", outputPointer, int32(lengthOfOutput+1))



  vm.Release()

  conf.Release()

}

```



To build the Go SDK example, run the following commands.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

go build greet_memory.go

```



Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.



```bash

$ ./greet_memory rust_memory_greet_lib.wasm

Hello, WasmEdge!

```



## Pass strings to TinyGo functions



In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreetTinyGo), we will demonstrate how to call [a TinyGo-based WebAssembly function](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet.go) from a Go app.



The TinyGo function takes a memory pointer for the string, and constructs the TinyGo string itself.



<!-- prettier-ignore -->

:::note

The empty `main()` is needed for the compiled WebAssembly program to set up WASI properly.

:::



```go

package main



import (

  ""strings""

  ""unsafe""

)



func main() {}



//export greet

func greet(subject *int32) *int32 {

  nth := 0

  var subjectStr strings.Builder

  pointer := uintptr(unsafe.Pointer(subject))

  for {

    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))

    if s == 0 {

      break

    }



    subjectStr.WriteByte(byte(s))

    nth++

  }



  output := []byte(""Hello, "" + subjectStr.String() + ""!"")



  r := make([]int32, 2)

  r[0] = int32(uintptr(unsafe.Pointer(&(output[0]))))

  r[1] = int32(len(output))



  return &r[0]

}

```



Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.



```bash

tinygo build -o greet.wasm -target wasi greet.go

```



The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet_memory.go) must call `malloc` from the WasmEdge VM to get a pointer to the string parameter. It will then call the `greet` function in TinyGo with the pointer. After the function returns, the Go application will call `free` to free the memory space.



```go

package main



import (

  ""fmt""

  ""os""

  ""encoding/binary""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.SetLogErrorLevel()

  conf := wasmedge.NewConfigure(wasmedge.WASI)

  vm := wasmedge.NewVMWithConfig(conf)



  wasi := vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],

    os.Environ(),

    []string{"".:.""},

  )



  err := vm.LoadWasmFile(os.Args[1])

  if err != nil {

    fmt.Println(""failed to load wasm"")

  }

  vm.Validate()

  vm.Instantiate()



  subject := ""WasmEdge""

  lengthOfSubject := len(subject)



  // Allocate memory for the subject, and get a pointer to it.

  // Include a byte for the NULL terminator we add below.

  allocateResult, _ := vm.Execute(""malloc"", int32(lengthOfSubject+1))

  inputPointer := allocateResult[0].(int32)



  // Write the subject into the memory.

  mod := vm.GetActiveModule()

  mem := mod.FindMemory(""memory"")

  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))

  copy(memData, subject)



  // C-string terminates by NULL.

  memData[lengthOfSubject] = 0



  // Run the `greet` function. Given the pointer to the subject.

  greetResult, _ := vm.Execute(""greet"", inputPointer)

  outputPointer := greetResult[0].(int32)



  memData, _ = mem.GetData(uint(outputPointer), 8)

  resultPointer := binary.LittleEndian.Uint32(memData[:4])

  resultLength := binary.LittleEndian.Uint32(memData[4:])



  // Read the result of the `greet` function.

  memData, _ = mem.GetData(uint(resultPointer), uint(resultLength))

  fmt.Println(string(memData))



  // Deallocate the subject, and the output.

  vm.Execute(""free"", inputPointer)



  vm.Release()

  conf.Release()

}

```



To build the Go SDK example, run the following commands.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

go build greet_memory.go

```



Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.



```bash

$ ./greet_memory greet.wasm

Hello, WasmEdge!

```



## Pass bytes to Rust functions



In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemory), we will demonstrate how to call [Rust-based WebAssembly functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/rust_access_memory/src/lib.rs) and pass arrays to and from a Go app.



<!-- prettier-ignore -->

:::note

An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the `wasmedge_bindgen` compiler tool. You can [learn more here](bindgen.md).

:::



The `fib_array()` function takes an array as a call parameter and fills it with a Fibonacci sequence of numbers. Alternatively, the `fib_array_return_memory()` function returns an array of Fibonacci sequences of numbers.



For the array in the call parameter, the Rust function `fib_array()` takes a memory pointer and constructs the Rust `Vec` using `from_raw_parts`. For the array return value, the Rust function `fib_array_return_memory()` simply returns the pointer.



```rust

use std::mem;

use std::os::raw::{c_void, c_int};



#[no_mangle]

pub extern fn allocate(size: usize) -> *mut c_void {

  let mut buffer = Vec::with_capacity(size);

  let pointer = buffer.as_mut_ptr();

  mem::forget(buffer);



  pointer as *mut c_void

}



#[no_mangle]

pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {

  unsafe {

    let _ = Vec::from_raw_parts(pointer, 0, capacity);

  }

}



#[no_mangle]

pub extern fn fib_array(n: i32, p: *mut c_int) -> i32 {

  unsafe {

    let mut arr = Vec::<i32>::from_raw_parts(p, 0, (4*n) as usize);

    for i in 0..n {

      if i < 2 {

        arr.push(i);

      } else {

        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);

      }

    }

    let r = arr[(n - 1) as usize];

    mem::forget(arr);

    r

  }

}



#[no_mangle]

pub extern fn fib_array_return_memory(n: i32) -> *mut c_int {

  let mut arr = Vec::with_capacity((4 * n) as usize);

  let pointer = arr.as_mut_ptr();

  for i in 0..n {

    if i < 2 {

      arr.push(i);

    } else {

      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);

    }

  }

  mem::forget(arr);

  pointer

}

```



Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.



```bash

cd rust_access_memory

cargo build --target wasm32-wasi

# The output WASM will be target/wasm32-wasi/debug/rust_access_memory_lib.wasm.

```



The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/run.go) must call `allocate` from the WasmEdge VM to get a pointer to the array. It will then call the `fib_array()` function in Rust and pass in the pointer. After the functions return, the Go application will use the WasmEdge `store` API to construct an array from the pointer in the call parameter (`fib_array()`) or in the return value (`fib_array_return_memory()`). The Go app will eventually call `deallocate` to free the memory space.



```go

package main



import (

  ""fmt""

  ""os""

  ""unsafe""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.SetLogErrorLevel()

  conf := wasmedge.NewConfigure(wasmedge.WASI)

  vm := wasmedge.NewVMWithConfig(conf)



  wasi := vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],

    os.Environ(),

    []string{"".:.""},

  )



  err := vm.LoadWasmFile(os.Args[1])

  if err != nil {

    fmt.Println(""failed to load wasm"")

  }

  vm.Validate()

  vm.Instantiate()



  n := int32(10)



  p, err := vm.Execute(""allocate"", 4 * n)

  if err != nil {

    fmt.Println(""allocate failed:"", err)

  }



  fib, err := vm.Execute(""fib_array"", n, p[0])

  if err != nil {

    fmt.Println(""fib_rray failed:"", err)

  } else {

    fmt.Println(""fib_array() returned:"", fib[0])

    fmt.Printf(""fib_array memory at: %p\n"", unsafe.Pointer((uintptr)(p[0].(int32))))

    mod := vm.GetActiveModule()

    mem := mod.FindMemory(""memory"")

    if mem != nil {

      // int32 occupies 4 bytes

      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))

      if err == nil && fibArray != nil {

        fmt.Println(""fibArray:"", fibArray)

      }

    }

  }



  fibP, err := vm.Execute(""fib_array_return_memory"", n)

  if err != nil {

    fmt.Println(""fib_array_return_memory failed:"", err)

  } else {

    fmt.Printf(""fib_array_return_memory memory at: %p\n"", unsafe.Pointer((uintptr)(fibP[0].(int32))))

    mod := vm.GetActiveModule()

    mem := mod.FindMemory(""memory"")

    if mem != nil {

      // int32 occupies 4 bytes

      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))

      if err == nil && fibArrayReturnMemory != nil {

        fmt.Println(""fibArrayReturnMemory:"", fibArrayReturnMemory)

      }

    }

  }



  _, err = vm.Execute(""deallocate"", p[0].(int32), 4 * n)

  if err != nil {

    fmt.Println(""free failed:"", err)

  }





  exitcode := wasi.WasiGetExitCode()

  if exitcode != 0 {

    fmt.Println(""Go: Running wasm failed, exit code:"", exitcode)

  }



  vm.Release()

  conf.Release()

}

```



To build the Go SDK example, run the following commands.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

go build run.go

```



Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.



```bash

$ ./run rust_access_memory_lib.wasm

fib_array() returned: 34

fib_array memory at: 0x102d80

fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]

fib_array_return_memory memory at: 0x105430

fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]

```



## Pass bytes to TinyGo functions



In [this example](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemoryTinyGo), we will demonstrate how to call [TinyGo-based WebAssembly functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/fib.go) and pass arrays to and from a Go app.



The `fibArray` function takes an array as a call parameter and fills it with a Fibonacci sequence of numbers. Alternatively, the `fibArrayReturnMemory` function returns an array of Fibonacci sequences of numbers.



```go

package main



import (

  ""fmt""

  ""unsafe""

)



func main() {

  println(""in main"")

  n := int32(10)

  arr := make([]int32, n)

  arrP := &arr[0]

  fmt.Printf(""call fibArray(%d, %p) = %d\n"", n, arrP, fibArray(n, arrP))

  fmt.Printf(""call fibArrayReturnMemory(%d) return %p\n"", n, fibArrayReturnMemory(n))

}



// export fibArray

func fibArray(n int32, p *int32) int32 {

  arr := unsafe.Slice(p, n)

  for i := int32(0); i < n; i++ {

    switch {

    case i < 2:

      arr[i] = i

    default:

      arr[i] = arr[i-1] + arr[i-2]

    }

  }

  return arr[n-1]

}



// export fibArrayReturnMemory

func fibArrayReturnMemory(n int32) *int32 {

  arr := make([]int32, n)

  for i := int32(0); i < n; i++ {

    switch {

    case i < 2:

      arr[i] = i

    default:

      arr[i] = arr[i-1] + arr[i-2]

    }

  }

  return &arr[0]

}

```



Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.



```bash

tinygo build -o fib.wasm -target wasi fib.go

```



The [Go SDK application](https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/run.go) must call `malloc` from the WasmEdge VM to get a pointer to the array. It will then call the `fibArray()` function in TinyGo with the pointer. After the functions return, the Go app uses the WasmEdge SDK's `store` API to construct an array from the pointer in the call parameter (`fibArray()`) or in the return value (`fibArrayReturnMemory()`). The Go application will eventually call `free` to free the memory space.



```go

package main



import (

  ""fmt""

  ""os""

  ""unsafe""



  ""github.com/second-state/WasmEdge-go/wasmedge""

)



func main() {

  wasmedge.SetLogErrorLevel()

  conf := wasmedge.NewConfigure(wasmedge.WASI)

  vm := wasmedge.NewVMWithConfig(conf)



  wasi := vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],

    os.Environ(),

    []string{"".:.""},

  )



  err := vm.LoadWasmFile(os.Args[1])

  if err != nil {

    fmt.Println(""failed to load wasm"")

  }

  vm.Validate()

  vm.Instantiate()



  n := int32(10)



  p, err := vm.Execute(""malloc"", n)

  if err != nil {

    fmt.Println(""malloc failed:"", err)

  }



  fib, err := vm.Execute(""fibArray"", n, p[0])

  if err != nil {

    fmt.Println(""fibArray failed:"", err)

  } else {

    fmt.Println(""fibArray() returned:"", fib[0])

    fmt.Printf(""fibArray memory at: %p\n"", unsafe.Pointer((uintptr)(p[0].(int32))))

    mod := vm.GetActiveModule()

    mem := mod.FindMemory(""memory"")

    if mem != nil {

      // int32 occupies 4 bytes

      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))

      if err == nil && fibArray != nil {

        fmt.Println(""fibArray:"", fibArray)

      }

    }

  }



  fibP, err := vm.Execute(""fibArrayReturnMemory"", n)

  if err != nil {

    fmt.Println(""fibArrayReturnMemory failed:"", err)

  } else {

    fmt.Printf(""fibArrayReturnMemory memory at: %p\n"", unsafe.Pointer((uintptr)(fibP[0].(int32))))

    mod := vm.GetActiveModule()

    mem := mod.FindMemory(""memory"")

    if mem != nil {

      // int32 occupies 4 bytes

      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))

      if err == nil && fibArrayReturnMemory != nil {

        fmt.Println(""fibArrayReturnMemory:"", fibArrayReturnMemory)

      }

    }

  }



  _, err = vm.Execute(""free"", p...)

  if err != nil {

    fmt.Println(""free failed:"", err)

  }



  exitcode := wasi.WasiGetExitCode()

  if exitcode != 0 {

    fmt.Println(""Go: Running wasm failed, exit code:"", exitcode)

  }



  vm.Release()

  conf.Release()

}

```



To build the Go SDK example, run the following commands.



```bash

go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

go build run.go

```



Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.



```bash

$ ./run fib.wasm

fibArray() returned: 34

fibArray memory at: 0x14d3c

fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]

fibArrayReturnMemory memory at: 0x14d4c

fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]

```








------"
"```json:/embed/java/_category_.json


{

  ""label"": ""Java SDK for Embedding WasmEdge"",

  ""position"": 7,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to Embed WasmEdge in your Java host applications.""

  }

}








```"
"The following is a markdown document located at /embed/java/intro.md
------


---

sidebar_position: 1

---



# WasmEdge Java SDK Introduction



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"```json:/embed/python/_category_.json


{

  ""label"": ""Python SDK for Embedding WasmEdge"",

  ""position"": 10,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will learn how to Embed WasmEdge in your Python host applications.""

  }

}








```"
"The following is a markdown document located at /embed/python/intro.md
------


---

sidebar_position: 1

---



# WasmEdge Python SDK Introduction



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"```json:/embed/quick-start/_category_.json


{

  ""label"": ""Quick Start"",

  ""position"": 1,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will introduce how to install and run the WASM app quickly with WasmEdge runtime.""

  }

}








```"
"The following is a markdown document located at /embed/quick-start/embed-wasm-apps-go.md
------


---

sidebar_position: 3

---



# Embed the WASM app into your Go Host app



In the previous chapter, we learned how to create a WASM app using Rust and `wasmedge-bindgen` tool. In this chapter, I will walk you through how to embed the compiled WASM app into your Go Host app.



## The Go Host Application



In the [Go host application](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go), you can create and set up the WasmEdge VM using the WasmEdge Go SDK.



However, instead of calling `vm.Instantiate()`, you should now call `bindgen.Instantiate(vm)` to instantiate the VM and return a `bindgen` object.



```go

func main() {

  // Expected Args[0]: program name (./bindgen_funcs)

  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))



  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  var vm = wasmedge.NewVMWithConfig(conf)

  var wasi = vm.GetImportModule(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping preopens

  )

  vm.LoadWasmFile(os.Args[1])

  vm.Validate()



  // Instantiate the bindgen and vm

  bg := bindgen.Instantiate(vm)

```



Next, you can call any `[wasmedge_bindgen]` annotated functions in the VM via the `bindgen` object.



```go

  // create_line: string, string, string -> string (inputs are JSON stringified)

  res, err := bg.Execute(""create_line"", ""{\""x\"":2.5,\""y\"":7.8}"", ""{\""x\"":2.5,\""y\"":5.8}"", ""A thin red line"")

  if err == nil {

    fmt.Println(""Run bindgen -- create_line:"", string(res))

  } else {

    fmt.Println(""Run bindgen -- create_line FAILED"", err)

  }



  // say: string -> string

  res, err = bg.Execute(""say"", ""bindgen funcs test"")

  if err == nil {

    fmt.Println(""Run bindgen -- say:"", string(res))

  } else {

    fmt.Println(""Run bindgen -- say FAILED"")

  }



  // obfusticate: string -> string

  res, err = bg.Execute(""obfusticate"", ""A quick brown fox jumps over the lazy dog"")

  if err == nil {

    fmt.Println(""Run bindgen -- obfusticate:"", string(res))

  } else {

    fmt.Println(""Run bindgen -- obfusticate FAILED"")

  }



  // lowest_common_multiple: i32, i32 -> i32

  res, err = bg.Execute(""lowest_common_multiple"", int32(123), int32(2))

  if err == nil {

    num, _ := strconv.ParseInt(string(res), 10, 32)

    fmt.Println(""Run bindgen -- lowest_common_multiple:"", num)

  } else {

    fmt.Println(""Run bindgen -- lowest_common_multiple FAILED"")

  }



  // sha3_digest: array -> array

  res, err = bg.Execute(""sha3_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- sha3_digest:"", res)

  } else {

    fmt.Println(""Run bindgen -- sha3_digest FAILED"")

  }



  // keccak_digest: array -> array

  res, err = bg.Execute(""keccak_digest"", []byte(""This is an important message""))

  if err == nil {

    fmt.Println(""Run bindgen -- keccak_digest:"", res)

  } else {

    fmt.Println(""Run bindgen -- keccak_digest FAILED"")

  }



  bg.Release()

  vm.Release()

  conf.Release()

}

```



## Run the WASM app from your Go Host



Before that, make sure you have [installed Go, WasmEdge, and WasmEdge Go SDK](install.md).



```bash

$ cd rust_bindgen_funcs

go build

./bindgen_funcs rust_bindgen_funcs_lib.wasm

```



The standard output of this example will be the following.



```bash

Run bindgen -- create_line: {""points"":[{""x"":1.5,""y"":3.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.2360682,""desc"":""A thin red line""}

Run bindgen -- say: hello bindgen funcs test

Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt

Run bindgen -- lowest_common_multiple: 246

Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]

Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]

```



That's it. Next, let's dive into how to pass complex data from host applications to the WASM app.








------"
"The following is a markdown document located at /embed/quick-start/install.md
------


---

sidebar_position: 1

---



# Install Notes



To use a kind of WasmEdge language SDK, you must install WasmEdge itself first. Please be noted, he version of WasmEdge's language SDKs should be the same as the version of WasmEdge. For example, If you want to use WasmEdge Go SDK v{{ wasmedge_go_version }}, then your WasmEdge version must be {{ wasmedge_go_version }} as well.



<!-- prettier-ignore -->

:::note

The releases of WasmEdge language SDKs follow the official version of WasmEdge. We don't release the alpha, beta, and RC versions for WasmEdge language SDKs. For the WasmEdge release process, please check [here](../../contribute/release.md).

:::



## Install WasmEdge GO SDK as an example



Let's take WasmEdge Go SDK as an example to show how to embed a WASM App in Rust to a Go Host application.



First, ensure you have installed [Go](https://go.dev/dl/) first. The Golang version should be above 1.16.



Next, let's install WasmEdge and WasmEdge Go SDK. Again, The WasmEdge and WasmEdge Go SDK should be the same version.



```bash

$ go version

go version go1.16.5 linux/amd64



# Install WasmEdge

$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}



# Install WasmEdge-Go

$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}

```



Now we have set up WasmEdge and WasmEdge Go SDK. Next, let's see how to create a WASM app using Rust and wasmedge-bindgen.



To embed WasmEdge into your host app, you must install WasmEdge itself and its corresponding WasmEdge's language bindings.



In this Quick Start guide, we use WasmEdge Go SDK as an example to show how it works. Primarily, we will use [a bindgen function](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs) in rust to demonstrate how to call a few simple WebAssembly functions from a Go app.



Before we start, ensure you have installed [Go first](https://go.dev/dl/). The Golang version should be above 1.16.



First, let's install WasmEdge and WasmEdge Go SDK. **They should be in the same version**.



```bash

$ go version

go version go1.16.5 linux/amd64



# Install WasmEdge

$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v {{ wasmedge_go_version }}



# Install WasmEdge-Go

$ go get github.com/second-state/WasmEdge-go/wasmedge@v{{ wasmedge_go_version }}



# Install the WasmEdge-bindgen tool, which helps us handle complex data passing

$ go get github.com/second-state/wasmedge-bindgen@v0.4.1

```



<!-- prettier-ignore -->

:::note

For more advanced features like AI inference, please refer to [Go SDK For Embedding WASM Function Chapter](/category/go-sdk-for-embedding-wasmedge).

:::



Since the demo app includes [a compiled WASM file](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs_lib.wasm) from [the Rust function](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs), so we don't need to install the Rust toolchain to compile the Rust code to wasm.



## Run the demo



Now we have set up the basic environment, let's run the example.



```bash

# Get the source code of this example

$ git clone https://github.com/second-state/WasmEdge-go-examples.git

$ cd WasmEdge-go-examples//wasmedge-bindgen/go_BindgenFuncs/



# build the project

go build



# run the example

./bindgen_funcs rust_bindgen_funcs_lib.wasm

```



The standard output of this example will be the following:



```bash

Run bindgen -- create_line: {""points"":[{""x"":2.5,""y"":7.8},{""x"":2.5,""y"":5.8}],""valid"":true,""length"":2.0,""desc"":""A thin red line""}

Run bindgen -- say: hello bindgen funcs test

Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt

Run bindgen -- lowest_common_multiple: 246

Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]

Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]

```



## Achieve higher performance



Use the following command line if you want to get better performance.



```bash

# Use the AoT mode

wasmedgec rust_bindgen_funcs_lib.wasm rust_bindgen_funcs_lib.wasm



# Run the demo

./bindgen_funcs rust_bindgen_funcs_lib.wasm

```



That's it. Let's dive into [more examples with WasmEdge Go SDK](/category/go-sdk-for-embedding-wasmedge).








------"
"The following is a markdown document located at /embed/quick-start/wasm-app-in-rust.md
------


---

sidebar_position: 2

---



# Create a WASM app using Rust and wasmedge-bindgen



In the previous chapter, we learned how to install WasmEdge and WasmEdge Go SDK. This chapter will teach us how to create a WASM app using Rust and `wasmedge-bindgen` tool.



<!-- prettier-ignore -->

:::note

The [wasmedge-bindgen](https://github.com/second-state/wasmedge-bindgen) project provides Rust macros for functions to accept and return complex data types and then for Go functions to call such Rust functions running in WasmEdge.

:::



## Prerequisites



We need to install [Rust and add `wasm32-wasi` target for Rust](../../develop/rust/setup.md)



We also need to install `wasmedge-bindgen`.



```bash

# Install the WasmEdge-bindgen tool, which help us handle complex data passing

$ go get github.com/second-state/wasmedge-bindgen@v0.4.1

```



## Rust function



The complete source code for the demo in this chapter is [available here](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs).



In the [Rust project](https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs), all you need is to annotate [your functions](https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) with a `[wasmedge_bindgen]` macro.



Those annotated functions will be automatically instrumented by the Rust compiler and turned into WebAssembly functions that can be called from the bindgen related functions of WasmEdge GO SDK.



The example below shows several Rust functions that take complex call parameters and return complex values.



```rust

use wasmedge_bindgen::*;

use wasmedge_bindgen_macro::*;

use num_integer::lcm;

use sha3::{Digest, Sha3_256, Keccak256};

use serde::{Serialize, Deserialize};



#[derive(Serialize, Deserialize, Debug)]

struct Point {

  x: f32,

  y: f32

}



#[derive(Serialize, Deserialize, Debug)]

struct Line {

  points: Vec<Point>,

  valid: bool,

  length: f32,

  desc: String

}



#[wasmedge_bindgen]

pub fn create_line(p1: String, p2: String, desc: String) -> Result<Vec<u8>, String> {

  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();

  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();

  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();



  let valid = if length == 0.0 { false } else { true };



  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };



  return Ok(serde_json::to_vec(&line).unwrap());

}



#[wasmedge_bindgen]

pub fn say(s: String) -> Result<Vec<u8>, String> {

  let r = String::from(""hello "");

  return Ok((r + s.as_str()).as_bytes().to_vec());

}



#[wasmedge_bindgen]

pub fn obfusticate(s: String) -> Result<Vec<u8>, String> {

  let r: String = (&s).chars().map(|c| {

    match c {

      'A' ..= 'M' | 'a' ..= 'm' => ((c as u8) + 13) as char,

      'N' ..= 'Z' | 'n' ..= 'z' => ((c as u8) - 13) as char,

      _ => c

    }

  }).collect();

  Ok(r.as_bytes().to_vec())

}



#[wasmedge_bindgen]

pub fn lowest_common_multiple(a: i32, b: i32) -> Result<Vec<u8>, String> {

  let r = lcm(a, b);

  return Ok(r.to_string().as_bytes().to_vec());

}



#[wasmedge_bindgen]

pub fn sha3_digest(v: Vec<u8>) -> Result<Vec<u8>, String> {

  return Ok(Sha3_256::digest(&v).as_slice().to_vec());

}



#[wasmedge_bindgen]

pub fn keccak_digest(s: Vec<u8>) -> Result<Vec<u8>, String> {

  return Ok(Keccak256::digest(&s).as_slice().to_vec());

}

```



## Compile the Rust code into Wasm



Now the rust function is ready. Let's compile the Rust code to WASM.



First， fork or git clone the demo project to get the source code.



```bash

git clone https://github.com/second-state/WasmEdge-go-examples.git

```



Next, build the WebAssembly bytecode file using standard `Cargo` commands.



```bash

cd rust_bindgen_funcs

cargo build --target wasm32-wasi --release

# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.

cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../

cd ../

```



Now we have a WASM function. Next, how to embed the WASM function into a Go Host application.








------"
"```json:/embed/rust/_category_.json


{

  ""label"": ""Rust SDK for Embedding WasmEdge"",

  ""position"": 5,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""we will learn how to Embed WasmEdge in your Rust host applications""

  }

}








```"
"The following is a markdown document located at /embed/rust/ai.md
------


---

sidebar_position: 5

---



# AI Inference with Pytorch








------"
"The following is a markdown document located at /embed/rust/app.md
------


---

sidebar_position: 2

---



# Embed WASM Apps



<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-1-run-a-wasm-app-from-host>








------"
"The following is a markdown document located at /embed/rust/asyncfy.md
------


---

sidebar_position: 6

---



# Asyncfy



<!-- prettier-ignore -->

:::info

Work in Progress

:::








------"
"The following is a markdown document located at /embed/rust/complex_data.md
------


---

sidebar_position: 4

---



# Pass Complex Data



<!-- prettier-ignore -->

:::info

Work in Progress

:::

 See an example here: <https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-1-define-a-host-function-with-string-arguments>








------"
"The following is a markdown document located at /embed/rust/function.md
------


---

sidebar_position: 3

---



# Embed WASM Functions and Async Functions



<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-4-define-and-register-a-host-function>



<https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#example-5-define-and-register-async-host-functions>








------"
"The following is a markdown document located at /embed/rust/intro.md
------


---

sidebar_position: 1

---



# WasmEdge Rust SDK



## Overview



WasmEdge Rust SDK consists of five crates:



- `wasmedge-sdk` crate defines a group of safe, ergonomic high-level APIs developers use to build up their own business applications.



- `wasmedge-sys` crate is a wrapper of WasmEdge C-API and provides safe counterparts. It is not recommended to use it directly by application developers. `wasmedge-sys`, `wasmedge-types`, and `wasmedge-macro` constitute the low-level layer of WasmEdge Rust SDK.



- `wasmedge-types` crate defines the data structures commonly used in `wasmedge-sdk` and `wasmedge-sys`.



- `wasmedge-macro` crate defines the macros that are commonly used in `wasmedge-sdk` and `wasmedge-sys` to declare [host functions](https://webassembly.github.io/spec/core/exec/runtime.html#:~:text=A%20host%20function%20is%20a,a%20module%20as%20an%20import.).



- `async-wasi` crate provides the asynchronous WASI APIs.



## Usage



- Deploy WasmEdge library in your local environment.



  Since this crate depends on the WasmEdge C API, it needs to be installed in your system first. Please refer to [WasmEdge Installation and Uninstallation](../../start/install.md) to install the WasmEdge library. The versioning table below shows the version of the WasmEdge library required by each version of the `wasmedge-sdk` crate.



  | wasmedge-sdk | WasmEdge lib | wasmedge-sys | wasmedge-types | wasmedge-macro | async-wasi |

  | :-: | :-: | :-: | :-: | :-: | :-: |

  | 0.11.0 | 0.13.3 | 0.16.0 | 0.4.3 | 0.6.0 | 0.0.3 |

  | 0.10.1 | 0.13.3 | 0.15.1 | 0.4.2 | 0.5.0 | 0.0.2 |

  | 0.10.0 | 0.13.2 | 0.15.0 | 0.4.2 | 0.5.0 | 0.0.2 |

  | 0.9.0 | 0.13.1 | 0.14.0 | 0.4.2 | 0.4.0 | 0.0.1 |

  | 0.9.0 | 0.13.0 | 0.14.0 | 0.4.2 | 0.4.0 | 0.0.1 |

  | 0.8.1 | 0.12.1 | 0.13.1 | 0.4.1 | 0.3.0 | - |

  | 0.8.0 | 0.12.0 | 0.13.0 | 0.4.1 | 0.3.0 | - |

  | 0.7.1 | 0.11.2 | 0.12.2 | 0.3.1 | 0.3.0 | - |

  | 0.7.0 | 0.11.2 | 0.12 | 0.3.1 | 0.3.0 | - |

  | 0.6.0 | 0.11.2 | 0.11 | 0.3.0 | 0.2.0 | - |

  | 0.5.0 | 0.11.1 | 0.10 | 0.3.0 | 0.1.0 | - |

  | 0.4.0 | 0.11.0 | 0.9 | 0.2.1 | - | - |

  | 0.3.0 | 0.10.1 | 0.8 | 0.2 | - | - |

  | 0.1.0 | 0.10.0 | 0.7 | 0.1 | - | - |



  WasmEdge Rust SDK can automatically search the following paths for the WasmEdge library:



  - `/usr/local` (Linux/macOS)

  - `$HOME/.wasmedge` (Linux/macOS)



    Note that if you have installed the WasmEdge library in a different path, you can set the `WASMEDGE_INCLUDE_DIR` and `WASMEDGE_LIB_DIR` environment variables to the path of the WasmEdge library.



- Add `wasmedge-sdk` crate to your `Cargo.toml` file. Note that, according to the versioning table, the version of `wasmedge-sdk` matching `WasmEdge v0.13.3` is `0.11.0`.



  ```toml

  wasmedge-sdk = ""0.11.0""

  ```



**Notice:** The minimum supported Rust version is 1.68.



## Examples



[wasmedge-rustsdk-examples](https://github.com/second-state/wasmedge-rustsdk-examples/tree/main) provides a set of examples to demonstrate how to use `wasmedge-sdk` to, for example, create host functions, create WebAssembly libraries, create plug-ins, etc.








------"
"The following is a markdown document located at /embed/rust/reference.md
------


---

sidebar_position: 7

---



# API Reference



Check out [the `wasmedge-sdk` crate](https://crates.io/crates/wasmedge-sdk) for more information.








------"
"```json:/embed/use-case/plugin/_category_.json


{

  ""label"": ""Plugin-User Guide"",

  ""position"": 7,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""We will learn how to use WasmEdge Plugin System.""

  }

}








```"
"The following is a markdown document located at /embed/use-case/plugin/c_sdk.md
------


---

sidebar_position: 1

---



# Using Plug-ins to Extend the Runtime in C



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



## Loading Plug-ins from Paths



Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:



```c

WasmEdge_PluginLoadWithDefaultPaths();

```



Once this API is called, plug-ins from the default paths will be loaded. The default paths include:



- The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.

- The `../plugin/` directory relative to the WasmEdge installation path.

- The `./wasmedge/` directory under the library path if WasmEdge is installed in a system directory (e.g., `/usr` and `/usr/local`).



Developers can also load plug-ins from specific paths using this API:



```c

WasmEdge_PluginLoadFromPath(""PATH_TO_PLUGIN/plugin.so"");

```



## Listing Loaded Plug-ins



Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:



```c

WasmEdge_PluginLoadWithDefaultPaths();

printf(""Number of loaded plug-ins: %d\n"", WasmEdge_PluginListPluginsLength());



WasmEdge_String Names[20];

uint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);

for (int I = 0; I < NumPlugins; I++) {

  printf(""Plug-in %d name: %s\n"", I, Names[I].Buf);

}

```



## Getting Plug-in Context by Name



Developers can obtain the plug-in context by its name using the following method:



```c

/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */

WasmEdge_PluginLoadWithDefaultPaths();



const char PluginName[] = ""wasi_crypto"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(PluginName, strlen(PluginName));

const WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);

```



## Creating Module Instances from Plug-ins



With the plug-in context, developers can create module instances by providing the module name:



```c

/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */



/* List the available host modules in the plug-in. */

WasmEdge_String Names[20];

uint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);

for (uint32_t I = 0; I < ModuleLen; I++) {

  /* Will print the available host module names in the plug-in. */

  printf(""%s\n"", Names[I].Buf);

}

/* Will print here for the WASI-Crypto plug-in here:

 * wasi_ephemeral_crypto_asymmetric_common

 * wasi_ephemeral_crypto_common

 * wasi_ephemeral_crypto_kx

 * wasi_ephemeral_crypto_signatures

 * wasi_ephemeral_crypto_symmetric

 */



/* Create a module instance from the plug-in by the module name. */

const char ModuleName[] = ""wasi_ephemeral_crypto_common"";

WasmEdge_String NameString =

    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));

WasmEdge_ModuleInstance *ModCxt =

    WasmEdge_PluginCreateModule(PluginCxt, NameString);



WasmEdge_ModuleInstanceDelete(ModCxt);

```



There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).



Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).



## Automatic Module Creation and Mocking



Upon creating a `VM` context, the WasmEdge runtime will automatically create and register the modules of loaded plug-ins. In cases where specific plug-ins are not loaded, WasmEdge will provide mock implementations for certain host modules. These mocked modules include:



- `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)

- `wasi_ephemeral_nn`

- `wasi_snapshot_preview1`

- `wasmedge_httpsreq`

- `wasmedge_process`



## Handling Missing Plug-ins and Error Messages



When the WASM want to invoke these host functions but the corresponding plug-in is not installed, WasmEdge will print the error message and return an error.



```c

/* Load the plug-ins in the default paths first. */

WasmEdge_PluginLoadWithDefaultPaths();

/* Create the configure context and add the WASI configuration. */

WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();

WasmEdge_ConfigureAddHostRegistration(ConfCxt,

                                        WasmEdge_HostRegistration_Wasi);

WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

WasmEdge_ConfigureDelete(ConfCxt);

/* The following API can retrieve the registered modules in the VM context,

* includes the built-in WASI and the plug-ins.

*/

/*

* This API will return `NULL` if the module instance is not found.

*/

WasmEdge_String WasiName =

    WasmEdge_StringCreateByCString(""wasi_snapshot_preview1"");

/* The `WasiModule` will not be `NULL` because the configuration was set. */

const WasmEdge_ModuleInstanceContext *WasiModule =

    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);

WasmEdge_StringDelete(WasiName);

WasmEdge_String WasiNNName =

    WasmEdge_StringCreateByCString(""wasi_ephemeral_nn"");

/* The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not

* installed, because the VM context will mock and register the host

* modules.

*/

const WasmEdge_ModuleInstanceContext *WasiNNModule =

    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);

WasmEdge_StringDelete(WasiNNName);



WasmEdge_VMDelete(VMCxt);

```








------"
"The following is a markdown document located at /embed/use-case/plugin/go_sdk.md
------


---

sidebar_position: 3

---



# Using Plug-ins to Extend the Runtime in Go



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



## Loading Plug-ins from Paths



Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:



```go

wasmedge.LoadPluginDefaultPaths()

```



Once this API is called, plug-ins from the default paths will be loaded. The default paths include:



- The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.

- The `../plugin/` directory relative to the WasmEdge installation path.

- The `./wasmedge/` directory under the library path if WasmEdge is installed in a system directory (e.g., `/usr` and `/usr/local`).



Developers can also load plug-ins from specific paths using this API:



```go

wasmedge.LoadPluginFromPath(""PATH_TO_PLUGIN/plugin.so"")

```



## Listing Loaded Plug-ins



Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:



```go

wasmedge.LoadPluginDefaultPaths()

pluginnames := wasmedge.ListPlugins()

for _, name := range pluginnames {

  fmt.Println(""Loaded plug-in name: "", name)

}

```



## Getting Plug-in Context by Name



Developers can obtain the plug-in context by its name using the following method:



```go

// Assume that wasi_crypto plug-in is installed in the default plug-in path.

wasmedge.LoadPluginDefaultPaths()

plugincrypto := wasmedge.FindPlugin(""wasi_crypto"")

```



## Creating Module Instances from Plug-ins



With the plug-in context, developers can create module instances by providing the module name:



```go

// Assume that the `plugincrypto` is the object to the wasi_crypto plug-in.



// List the available host modules in the plug-in.

modules := plugincrypto.ListModule()

for _, name := range modules {

  fmt.Println(""Available module: "", name)

}

// Will print here for the WASI-Crypto plug-in here:

//   wasi_ephemeral_crypto_asymmetric_common

//   wasi_ephemeral_crypto_common

//   wasi_ephemeral_crypto_kx

//   wasi_ephemeral_crypto_signatures

//   wasi_ephemeral_crypto_symmetric



// Create a module instance from the plug-in by the module name.

modinst := plugincrypto.CreateModule(""wasi_ephemeral_crypto_common"")



modinst.Release()

```



There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).



Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).



## Automatic Module Creation and Mocking



Upon creating a `VM` context, the WasmEdge runtime will automatically create and register the modules of loaded plug-ins. In cases where specific plug-ins are not loaded, WasmEdge will provide mock implementations for certain host modules. These mocked modules include:



- `wasi_ephemeral_crypto_asymmetric_common` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_common` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_kx` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_signatures` (for the `WASI-Crypto`)

- `wasi_ephemeral_crypto_symmetric` (for the `WASI-Crypto`)

- `wasi_ephemeral_nn`

- `wasi_snapshot_preview1`

- `wasmedge_httpsreq`

- `wasmedge_process`

- `wasi:logging/logging` (for the `WASI-Logging`)



## Handling Missing Plug-ins and Error Messages



When the WASM want to invoke these host functions but the corresponding plug-in not installed, WasmEdge will print the error message and return an error.



```go

// Load the plug-ins in the default paths first.

wasmedge.LoadPluginDefaultPaths()



// Create the VM object with the WASI configuration.

conf := wasmedge.NewConfigure(wasmedge.WASI)

vm := wasmedge.NewVMWithConfig(conf)

conf.Release()



// The following API can retrieve the registered modules in the VM objects, includes the built-in WASI and the plug-ins.

// This API will return `NULL` if the module instance not found.



// The `wasimodule` will not be `nil` because the configuration was set.

wasimodule := vm.GetRegisteredModule(""wasi_snapshot_preview1"")



// The `wasinnmodule` will not be `nil` even if the wasi_nn plug-in is not installed, because the VM context will mock and register the host modules.

wasinnmodule := vm.GetRegisteredModule(""wasi_ephemeral_nn"")



vm.Release()

```








------"
"The following is a markdown document located at /embed/use-case/plugin/rust_sdk.md
------


---

sidebar_position: 2

---



# Using Plug-ins to Extend the Runtime in Rust



The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily.



## Loading Plug-ins from Paths



Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:



```rust

impl PluginManager

pub fn load(path: Option<&Path>) -> WasmEdgeResult<()>

```



- The default plug-in paths will be used if the path is not given.



  - The path specified in the `WASMEDGE_PLUGIN_PATH` environment variable.

  - The `../plugin/` directory relative to the WasmEdge installation path.

  - The `./wasmedge/` directory under the library path if WasmEdge is installed in the `/usr` directory.



- If the path is given, then



  - If the path is pointing at a file, then it indicates that a single plug-in will be loaded from the file.

  - If the path is pointing at a directory, then the method will load plug-ins from the files.



To get the names of all loaded plug-ins as returns -



```rust

pub fn names() -> Vec<String>

```



<!-- prettier-ignore -->

:::note

`path` - A path to a plug-in file or a directory holding plug-in files. If `None`, then the default plug-in path will be used.

:::



## Listing Loaded Plug-ins



Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:



```rust

pub fn names() -> Vec<String>

```



## Getting Plug-in Context by Name



Developers can get the plug-in context by its name using the following method:



```rust

pub fn find(name: impl AsRef<str>) -> Option<Plugin>

```



Here `name` is the name of the target plug-in.



## Getting Module Instances from Plug-ins



With the plug-in context, developers can get module instances by providing the module name:



```rust

pub fn mod_names(&self) -> Vec<String>

```



There may be several plug-ins in the default plug-in paths if users [installed WasmEdge plug-ins by the installer](/contribute/installer.md#plugins).



Before using the plug-ins, developers should [Loading Plug-ins from Paths](#loading-plug-ins-from-paths).



## Plug-in Module Instance



To initialize the `wasmedge_process` plug-in module instance with the parameters -



```rust

pub fn init_wasmedge_process(allowed_cmds: Option<Vec<&str>>, allowed: bool)

```



Here, `allowed_cmds` is A white list of commands and `allowed` determines if wasmedge_process is allowed to execute all commands on the white list.








------"
"```json:/embed/use-case/_category_.json


{

  ""label"": ""Use Cases"",

  ""position"": 11,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will discuss how popular software applications embed WasmEdge to support extended functionalities.""

  }

}








```"
"The following is a markdown document located at /embed/use-case/libsql.md
------


---

sidebar_position: 1

---



# UDF in the libSQL database



[libSQL](https://github.com/libsql/libsql) is a fork of the popular [SQLite](https://www.sqlite.org/) database. One of the key enhancements libSQL brings is UDF (User Defined Functions) support. Through Wasm-based UDFs, users can add their own processing logic to the database, and then process the data in and out of the database on the fly. libSQL uses WasmEdge to run these UDFs. In this article, I will show you how.



## Prerequisites



First, you will need to [install WasmEdge runtime](../../start/install.md#install).



Next, install the latest libSQL or build it from source.



```bash

git clone https://github.com/libsql/libsql

cd libsql

./configure --enable-wasm-runtime-wasmedge

make

```



## The encrypt and decrypt example



Build the encrypt and decrypt example into wasm. Since WasmEdge supports WASI functions here, we will use the `wasm32-wasi` target.



```bash

git clone https://github.com/libsql/libsql_bindgen

cd libsql_bindgen/examples/encrypt_decrypt

cargo build --target wasm32-wasi --release

```



Then, we can build a SQL file for creating the `encrypt` function in a libSQL database.



```bash

export FUNC_NAME='encrypt'

echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql

echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql

xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql

echo ""';"" >> create_${FUNC_NAME}_udf.sql

```



Create another SQL file for the `decrypt` function.



```bash

export FUNC_NAME='decrypt'

echo ""DROP FUNCTION IF EXISTS ${FUNC_NAME};"" >> create_${FUNC_NAME}_udf.sql

echo -n ""CREATE FUNCTION ${FUNC_NAME} LANGUAGE wasm AS X'"" >> create_${FUNC_NAME}_udf.sql

xxd -p  ../../target/wasm32-wasi/release/libsql_encrypt_decrypt.wasm | tr -d ""\n"" >> create_${FUNC_NAME}_udf.sql

echo ""';"" >> create_${FUNC_NAME}_udf.sql

```



Now, you can add those UDFs to a libSQL instance.



```bash

./libsql

libsql> .init_wasm_func_table

libsql> .read create_encrypt_udf.sql

libsql> .read create_decrypt_udf.sql

```



Finally, you can create a table and test it.



```bash

libsql>



CREATE TABLE secrets(secret);

INSERT INTO secrets (secret) VALUES (encrypt('my secret value: 1', 's3cretp4ss'));

INSERT INTO secrets (secret) VALUES (encrypt('my even more secret value: 2', 's3cretp4ss'));

INSERT INTO secrets (secret) VALUES (encrypt('classified value: 3', 's3cretp4ss'));



SELECT secret, decrypt(secret, 'wrong-pass') from secrets;

secret                                        decrypt(secret, 'wrong-pass')

--------------------------------------------  -----------------------------

IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  [ACCESS DENIED]

bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  [ACCESS DENIED]

o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  [ACCESS DENIED]



SELECT secret, decrypt(secret, 's3cretp4ss') from secrets;

secret                                        decrypt(secret, 's3cretp4ss')

--------------------------------------------  -----------------------------

IyTvoTEnh9a/f6+pac3rLPToP9DkWqS7CEW8tan3mbQ=  my secret value: 1

bUQ4fEe6hPnsMx8ABOZO97CMr/wouGTByfUCEmFVZTs=  my even more secret value: 2

o+m1w7UdoxBZxLumNW0VoMKSMFaC4o8N5uknAQZ/yFY=  classified value: 3

```








------"
"The following is a markdown document located at /embed/use-case/serverless-saas.md
------


---

sidebar_position: 5

---



# Serverless Software-As-A-Service Functions



WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.



- WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.

- Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his servers (e.g., callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.



The examples below showcase how WasmEdge-based serverless functions connect SaaS APIs from different services and process data flows across those SaaS APIs according to each user's business logic.



## Slack



- [Build a serverless chatbot for Slack](http://reactor.secondstate.info/en/docs/user_guideline.html)



## Lark



It is also known as `飞书`, aka the Chinese Slack. Byte Dance, the parent company of Tiktok, creates it.



- [Build a serverless chatbot for Lark](http://reactor.secondstate.info/en/docs/user_guideline.html)








------"
"The following is a markdown document located at /embed/use-case/ssr-modern-ui.md
------


---

sidebar_position: 6

---



# Server Side Rendering Modern Web UI



Traditional web applications follow the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is a thin client that displays the rendered web pages in real-time. However, as the browser becomes more capable and sophisticated, the client can take on more workload to improve application UX, performance, and security.



That gave rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static website (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew, or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (browsers and apps) makes it difficult to achieve great performance across all use cases.



The solution is server-side rendering (SSR). That is to have edge servers run the ""client side"" UI code (i.e., the React-generated JavaScript OR Percy-generated WebAssembly) and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the same code (i.e., [JavaScript](../../develop/javascript/hello_world.md) and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high-performance, OCI complaint, and polyglot container to run all SSR functions on edge servers.



- [React JS SSR function](../../develop/javascript/ssr.md)

- Vue JS SSR function (coming soon)

- Yew Rust compiled to WebAssembly SSR function (coming soon)

- [Percy Rust compiled to WebAssembly SSR function](../../develop/rust/ssr.md)



We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers and then stream the rendered results to the client application. Potential examples include



- Render Unity3D animations on the edge server (based on [WebAssembly rendering of Unity3D](https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html))

- Render interactive video (generated from AI) on the edge server



Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.








------"
"The following is a markdown document located at /embed/use-case/wasm-nginx.md
------


---

sidebar_position: 3

---



# wasm-nginx-module



The wasm-nginx-module is an Nginx module built upon OpenResty. By implementing the [Proxy-WASM ABI](https://github.com/proxy-wasm/spec), any WASM program written with Proxy WASM SDK can be run inside it. Hence, you can write Go or Rust code, compile them into Wasm, then load & execute it in Nginx.



> The wasm-nginx-module is already used in APISIX and allows it to [run WASM plugin like Lua plugin](https://github.com/apache/apisix/blob/master/docs/en/latest/wasm.md).



To follow along the tutorials in this chapter, you will need to first [build your Nginx with wasm-nginx-module included and WasmEdge shared library installed in the right path](https://github.com/api7/wasm-nginx-module#install-dependencies).



Once you have Nginx installed, let me show you a real-world example - using WASM to inject custom responses in Nginx.



## Inject Custom Response via Go in Nginx, Step by Step



### Go Step 1: Write code based on proxy-wasm-go-sdk



The implementation code (including `go.mod` and others) can be found [here](https://github.com/apache/apisix/tree/master/t/wasm).



It should be explained that although the proxy-wasm-go-sdk project carries the Go name, it actually uses tinygo instead of native Go, which has some problems supporting WASI (which you can think of as a non-browser WASM runtime interface). See [here](https://github.com/tetratelabs/proxy-wasm-go-sdk/blob/main/doc/OVERVIEW.md#tinygo-vs-the-official-go-compiler) for more details.



We also provide a Rust version (including Cargo.toml and others) [there](https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection).



### Go Step 2: Build the corresponding WASM file



```shell

tinygo build -o ./fault-injection/main.go.wasm -scheduler=none -target=wasi ./fault-injection/main.go

```



### Go Step 3: Load and execute the WASM file



Then, start Nginx with the configuration below:



```conf

worker_processes  1;



error_log  /tmp/error.log warn;



events {

    worker_connections  10240;

}



http {

    wasm_vm wasmedge;

    init_by_lua_block {

        local wasm = require(""resty.proxy-wasm"")

        package.loaded.plugin = assert(wasm.load(""fault_injection"",

            ""/path/to/fault-injection/main.go.wasm""))

    }

    server {

        listen 1980;

        location / {

            content_by_lua_block {

                local wasm = require(""resty.proxy-wasm"")

                local ctx = assert(wasm.on_configure(package.loaded.plugin,

                    '{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}'))

                assert(wasm.on_http_request_headers(ctx))

            }

        }

    }

}

```



This configuration loads the WASM file we just built, and executes it with the configuration `{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}`.



### Go Step 4: Verify the Result



After Nginx starts, we can use `curl http://127.0.0.1:1980/ -i` to verify the execution result of the Wasm.



It is expected to see the output:



```bash

HTTP/1.1 403 Forbidden

...



powered by wasm-nginx-module

```



## Inject Custom Response via Rust in Nginx, Step by Step



### Rust Step 1: Write code based on proxy-wasm-rust-sdk



We also provide a Rust version (including Cargo.toml and others) [here](https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection).



### Rust Step 2: Build the corresponding WASM file



```shell

cargo build --target=wasm32-wasi

```



### Rust Step 3: Load and execute the WASM file



Then, start Nginx with the configuration below:



```conf

worker_processes  1;



error_log  /tmp/error.log warn;



events {

    worker_connections  10240;

}



http {

    wasm_vm wasmedge;

    init_by_lua_block {

        local wasm = require(""resty.proxy-wasm"")

        package.loaded.plugin = assert(wasm.load(""fault_injection"",

            ""/path/to/fault-injection/target/wasm32-wasi/debug/fault_injection.wasm""))

    }

    server {

        listen 1980;

        location / {

            content_by_lua_block {

                local wasm = require(""resty.proxy-wasm"")

                local ctx = assert(wasm.on_configure(package.loaded.plugin,

                    '{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}'))

                assert(wasm.on_http_request_headers(ctx))

            }

        }

    }

}

```



This configuration loads the WASM file we just built, executes it with the configuration `{""http_status"": 403, ""body"": ""powered by wasm-nginx-module""}`.



### Rust Step 4: verify the result



After Nginx starts, we can use `curl http://127.0.0.1:1980/ -i` to verify the execution result of the Wasm.



It is expected to see the output:



```bash

HTTP/1.1 403 Forbidden

...



powered by wasm-nginx-module

```








------"
"The following is a markdown document located at /embed/use-case/yomo.md
------


---

sidebar_position: 2

---



# YoMo Framework



[YoMo](https://yomo.run/) is a programming framework enabling developers to build a distributed cloud system (Geo-Distributed Cloud System). YoMo's communication layer is made on top of the QUIC protocol, which brings high-speed data transmission. In addition, it has a built-in Streaming Serverless ""streaming function"", which significantly improves the development experience of distributed cloud systems. The distributed cloud system built by YoMo provides an ultra-high-speed communication mechanism between near-field computing power and terminals. It has many use cases in Metaverse, VR/AR, IoT, etc.



YoMo is written in the Go language. For streaming Serverless, Golang plug-ins and shared libraries are used to load users' code dynamically, which also has certain limitations for developers. With Serverless architecture's rigid demand for isolation, WebAssembly is an excellent choice for running user-defined functions.



For example, in real-time AI inference in AR/VR devices or smart factories, the camera sends real-time unstructured data to the computing node in the near-field MEC (multi-access edge computing) device through YoMo. YoMo sends the AI computing result to the end device in real time when the AI inference is completed. Thus, the hosted AI inference function will be automatically executed.



However, a challenge for YoMo is incorporating and managing handler functions written by multiple outside developers in an edge computing node. It requires runtime isolation for those functions without sacrificing performance. Traditional software container solutions like Docker need to be updated to the task. They need to be lighter and faster to handle real-time tasks.



WebAssembly provides a lightweight and high-performance software container. It is ideally suited as a runtime for YoMo’s data processing handler functions.



This article will show you how to create a Rust function for Tensorflow-based image classification, compile it into WebAssembly, and then use YoMo to run it as a stream data handler. We use [WasmEdge](https://wasmedge.org/) as our WebAssembly runtime because it offers the highest performance and flexibility compared with other WebAssembly runtimes. It is the only WebAssembly VM that reliably supports Tensorflow. YoMo manages WasmEdge VM instances and the contained WebAssembly bytecode apps through [WasmEdge’s Golang API](../go/intro.md).



<!-- prettier-ignore -->

:::note

Source code: <https://github.com/yomorun/yomo-wasmedge-tensorflow>

:::



Checkout [the WasmEdge image classification function in action in YoMo](https://www.youtube.com/watch?v=E0ltsn6cLIU)



## Prerequisite



You will need to have [Golang installed](https://golang.org/doc/install), but I assume you already did.



<!-- prettier-ignore -->

:::note

Golang version should be newer than 1.15 for our example to work.

:::



You also need to install the YoMo CLI application. It orchestrates and coordinates data streaming and handler function invocations.



```bash

$ go install github.com/yomorun/cli/yomo@latest

$ yomo version

YoMo CLI version: v0.1.3

```



Next, please install the WasmEdge and its Tensorflow shared libraries. [WasmEdge](https://wasmedge.org/) is a leading WebAssembly runtime hosted by the CNCF. We will use it to embed and run WebAssembly programs from YoMo.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

```



Finally, since our demo WebAssembly functions are written in Rust, you need a [Rust compiler](https://www.rust-lang.org/tools/install).



For the rest of the demo, fork, and clone the [source code repository](https://github.com/yomorun/yomo-wasmedge-tensorflow).



```bash

git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git

```



## The image classification function



The [image classification function](https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food) to process the YoMo image stream is written in Rust. It utilizes the WasmEdge Tensorflow API to process an input image.



```rust

#[wasmedge_bindgen]

pub fn infer(image_data: Vec<u8>) -> Result<Vec<u8>, String> {

  let start = Instant::now();



  // Load the TFLite model and its metadata (the text label for each recognized object number)

  let model_data: &[u8] = include_bytes!(""lite-model_aiy_vision_classifier_food_V1_1.tflite"");

  let labels = include_str!(""aiy_food_V1_labelmap.txt"");



  // Pre-process the image to a format that this model can use

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&image_data[..], 192, 192);

  println!(""RUST: Loaded image in ... {:?}"", start.elapsed());



  // Run the TFLite model using the WasmEdge Tensorflow API

  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);

  session.add_input(""input"", &flat_img, &[1, 192, 192, 3])

         .run();

  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Softmax"");



  // Find the object index in res_vec that has the greatest probability

  // Translate the probability into a confidence level

  // Translate the object index into a label from the model metadata food_name

  let mut i = 0;

  let mut max_index: i32 = -1;

  let mut max_value: u8 = 0;

  while i < res_vec.len() {

    let cur = res_vec[i];

    if cur > max_value {

      max_value = cur;

      max_index = i as i32;

    }

    i += 1;

  }

  println!(""RUST: index {}, prob {}"", max_index, max_value);



  let confidence: String;

  if max_value > 200 {

    confidence = ""is very likely"".to_string();

  } else if max_value > 125 {

    confidence = ""is likely"".to_string();

  } else {

    confidence = ""could be"".to_string();

  }



  let ret_str: String;

  if max_value > 50 {

    let mut label_lines = labels.lines();

    for _i in 0..max_index {

      label_lines.next();

    }

    let food_name = label_lines.next().unwrap().to_string();

    ret_str = format!(

      ""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"",

      confidence, food_name, food_name

    );

  } else {

    ret_str = ""It does not appears to be a food item in the picture."".to_string();

  }



  println!(

    ""RUST: Finished post-processing in ... {:?}"",

    start.elapsed()

  );

  return Ok(ret_str.as_bytes().to_vec());

}

```



You should add `wasm32-wasi` target to rust to compile this function into WebAssembly bytecode.



```bash

rustup target add wasm32-wasi



cd flow/rust_mobilenet_food

cargo build --target wasm32-wasi --release

# The output WASM will be target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm



# Copy the wasm bytecode file to the flow/ directory

cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../

```



To release the best performance of WasmEdge, you should enable the AOT mode by compiling the `.wasm` file to the `.so`.



```bash

wasmedge compile rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so

```



## Integration with YoMo



On the YoMo side, we use the WasmEdge Golang API to start and run WasmEdge VM for the image classification function. The [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) file in the source code project is as follows.



```go

package main



import (

  ""crypto/sha1""

  ""fmt""

  ""log""

  ""os""

  ""sync/atomic""



  ""github.com/second-state/WasmEdge-go/wasmedge""

  bindgen ""github.com/second-state/wasmedge-bindgen/host/go""

  ""github.com/yomorun/yomo""

)



var (

  counter uint64

)



const ImageDataKey = 0x10



func main() {

  // Connect to Zipper service

  sfn := yomo.NewStreamFunction(""image-recognition"", yomo.WithZipperAddr(""localhost:9900""))

  defer sfn.Close()



  // set only monitoring data

  sfn.SetObserveDataID(ImageDataKey)



  // set handler

  sfn.SetHandler(Handler)



  // start

  err := sfn.Connect()

  if err != nil {

    log.Print(""❌ Connect to zipper failure: "", err)

    os.Exit(1)

  }



  select {}

}



// Handler processes the data in the stream

func Handler(img []byte) (byte, []byte) {

  // Initialize WasmEdge's VM

  vmConf, vm := initVM()

  bg := bindgen.Instantiate(vm)

  defer bg.Release()

  defer vm.Release()

  defer vmConf.Release()



  // recognize the image

  res, err := bg.Execute(""infer"", img)

  if err == nil {

    fmt.Println(""GO: Run bindgen -- infer:"", string(res))

  } else {

    fmt.Println(""GO: Run bindgen -- infer FAILED"")

  }



  // print logs

  hash := genSha1(img)

  log.Printf(""✅ received image-%d hash %v, img_size=%d \n"", atomic.AddUint64(&counter, 1), hash, len(img))



  return 0x11, nil

}



// genSha1 generate the hash value of the image

func genSha1(buf []byte) string {

  h := sha1.New()

  h.Write(buf)

  return fmt.Sprintf(""%x"", h.Sum(nil))

}



// initVM initialize WasmEdge's VM

func initVM() (*wasmedge.Configure, *wasmedge.VM) {

  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info

  os.Setenv(""TF_CPP_MIN_LOG_LEVEL"", ""3"")

  os.Setenv(""TF_CPP_MIN_VLOG_LEVEL"", ""3"")



  // Create configure

  vmConf := wasmedge.NewConfigure(wasmedge.WASI)



  // Create VM with configure

  vm := wasmedge.NewVMWithConfig(vmConf)



  // Init WASI

  var wasi = vm.GetImportObject(wasmedge.WASI)

  wasi.InitWasi(

    os.Args[1:],     // The args

    os.Environ(),    // The envs

    []string{"".:.""}, // The mapping directories

  )



  // Register WasmEdge-tensorflow and WasmEdge-image

  var tfobj = wasmedge.NewTensorflowImportObject()

  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()

  vm.RegisterImport(tfobj)

  vm.RegisterImport(tfliteobj)

  var imgobj = wasmedge.NewImageImportObject()

  vm.RegisterImport(imgobj)



  // Instantiate wasm

  vm.LoadWasmFile(""rust_mobilenet_food_lib.so"")

  vm.Validate()



  return vmConf, vm

}

```



## In action



Finally, we can start YoMo and see the entire data processing pipeline. Start the YoMo CLI application from the project folder. The [yaml file](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml) defines port YoMo should listen on and the workflow handler to trigger for incoming data. Note that the flow name `image-recognition` matches the name in the aforementioned data handler [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go).



```bash

yomo serve -c ./zipper/workflow.yaml

```



Start the handler function by running the aforementioned [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) program.



```bash

cd flow

go run --tags ""tensorflow image"" app.go

```



[Start a simulated data source](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go) by sending a video to YoMo. The video is a series of image frames. The WasmEdge function in [app.go](https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go) will be invoked against every image frame in the video.



```bash

# Download a video file

wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'



# Stream the video to YoMo

go run ./source/main.go ./source/hot-dog.mp4

```



You can see the output from the WasmEdge handler function in the console. It prints the names of the objects detected in each image frame in the video.



## What's next



This article shows how to use the WasmEdge Tensorflow API and Golang SDK in YoMo framework to process an image stream in near real-time.



In collaboration with YoMo, we will soon deploy WasmEdge in production in smart factories for various assembly line tasks. WasmEdge is the software runtime for edge computing!








------"
"The following is a markdown document located at /embed/overview.md
------


---

sidebar_position: 1

displayed_sidebar: embedSidebar

---



# Embed WasmEdge in Your Apps



As we mentioned before, the most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product. It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.



We could use WasmEdge as a standalone container and deploy WasmEdge using the existing containers tools. The other way is to use WasmEdge as an embedded runtime and manage WasmEdge using the host applications.



WasmEdge provides SDKs for various programming languages. The WasmEdge library allows developers to embed the WasmEdge into their host applications, so that the WebAssembly applications can be executed in the WasmEdge sandbox safely. Furthermore, developers can implement the host functions for the extensions with the WasmEdge library.



![Embeded architecture](embed_arch.png)



In this section, we will walk you through how to embed WasmEdge in different languages. We will cover the following content:



- [Quick Start](/category/quick-start)

- [Passing complex data](/category/passing-complex-data)

- [Developing components using witc](witc.md)

- [Embed WasmEdge in C/C++](/category/c-sdk-for-embedding-wasmedge)

- [Embed WasmEdge in Rust](/category/rust-sdk-for-embedding-wasmedge)

- [Embed WasmEdge in Go](/category/go-sdk-for-embedding-wasmedge)

- [Embed WasmEdge in Java](/category/java-sdk-for-embedding-wasmedge)

- [Embed WasmEdge in Python](/category/python-sdk-for-embedding-wasmedge)

- [Use cases](/category/use-cases)



Besides this, we also have two more guides for [developing WASM apps](../develop/overview.md) and [contributing to WasmEdge](../contribute/overview.md).








------"
"The following is a markdown document located at /embed/witc.md
------


---

sidebar_position: 3

---



# Developing components using witc



Work in progress. Please refer to <https://github.com/second-state/witc>.








------"
"```json:/start/build-and-run/_category_.json


{

  ""label"": ""Running with WasmEdge"",

  ""position"": 5,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will discuss WasmEdge CLIs and how to leverage Docker + WASM to run build, share, and run your WASM apps.""

  }

}








```"
"The following is a markdown document located at /start/build-and-run/aot.md
------


---

sidebar_position: 3

---



# The AoT Compiler



After [installation](../install.md#install), users can execute the `wasmedge compile` command.



The usage of the `wasmedge compile` command will be:



```bash

$ wasmedge compile -h

USAGE

   wasmedge compile [OPTIONS] [--] WASM WASM_SO



...

```



The `wasmedge compile` command can compile WebAssembly into native machine code (i.e., the AOT compiler). For the pure WebAssembly, the `wasmedge` tool will execute the WASM in interpreter mode. After compiling with the `wasmedge compile` AOT compiler, the `wasmedge` tool can execute the WASM in AOT mode, which is much faster.



## Options



The options of the `wasmedge compile` command are as follows.



1. `-h|--help`: Show the help messages. Will ignore the other arguments below.

2. _(Optional)_ `--dump`: Dump the LLVM IR to `wasm.ll` and `wasm-opt.ll`.

3. _(Optional)_ `--interruptible`: Generate the binary which supports interruptible execution.

   - By default, the AOT-compiled WASM not supports [interruptions in asynchronous executions](../../embed/c/reference/0.12.x#async).

4. _(Optional)_ Statistics information:

   - By default, the AOT-compiled WASM does not support all statistics even if the options are turned on when running the `wasmedge` tool.

   - Use `--enable-time-measuring` to generate code for enabling time-measuring statistics in execution.

   - Use `--enable-gas-measuring` to generate code for enabling the statistics of gas measuring in execution.

   - Use `--enable-instruction-count` to generate code for enabling the statistics of counting WebAssembly instructions.

   - Or use `--enable-all-statistics` to generate code for enabling all of the statistics.

5. _(Optional)_ `--generic-binary`: Generate the generic binary of the current host CPU architecture.

6. _(Optional)_ WebAssembly proposals:

   - Use `--disable-import-export-mut-globals` to disable the [Import/Export of Mutable Globals](https://github.com/WebAssembly/mutable-global) proposal (Default `ON`).

   - Use `--disable-non-trap-float-to-int` to disable the [Non-Trapping Float-to-Int Conversions](https://github.com/WebAssembly/nontrapping-float-to-int-conversions) proposal (Default `ON`).

   - Use `--disable-sign-extension-operators` to disable the [Sign-Extension Operators](https://github.com/WebAssembly/sign-extension-ops) proposal (Default `ON`).

   - Use `--disable-multi-value` to disable the [Multi-value](https://github.com/WebAssembly/multi-value) proposal (Default `ON`).

   - Use `--disable-bulk-memory` to disable the [Bulk Memory Operations](https://github.com/WebAssembly/bulk-memory-operations) proposal (Default `ON`).

   - Use `--disable-reference-types` to disable the [Reference Types](https://github.com/WebAssembly/reference-types) proposal (Default `ON`).

   - Use `--disable-simd` to disable the [Fixed-width SIMD](https://github.com/webassembly/simd) proposal (Default `ON`).

   - Use `--enable-multi-memory` to enable the [Multiple Memories](https://github.com/WebAssembly/multi-memory) proposal (Default `OFF`).

   - Use `--enable-tail-call` to enable the [Tail call](https://github.com/WebAssembly/tail-call) proposal (Default `OFF`).

   - Use `--enable-extended-const` to enable the [Extended Constant Expressions](https://github.com/WebAssembly/extended-const) proposal (Default `OFF`).

   - Use `--enable-threads` to enable the [Threads](https://github.com/webassembly/threads) proposal (Default `OFF`).

   - Use `--enable-function-reference` to enable the [Typed-Function References](https://github.com/WebAssembly/function-references) proposal (Default `OFF`).

   - Use `--enable-all` to enable ALL proposals above.

7. _(Optional)_ `--optimize`: Select the LLVM optimization level.

   - Use `--optimize LEVEL` to set the optimization level. The `LEVEL` should be one of `0`, `1`, `2`, `3`, `s`, or `z`.

   - The default value will be `2`, which means `O2`.

8. Input WASM file (`/path/to/wasm/file`).

9. Output path (`/path/to/output/file`).

   - By default, the `wasmedge compile` command will output the [universal WASM format](#output-format-universal-wasm).

   - If the specific file extension (`.so` on Linux, `.dylib` on MacOS, and `.dll` on Windows) is assigned in the output path, the `wasmedge compile` command will output the [shared library format](#output-format-shared-library).



## Example



We created the hand-written [fibonacci.wat](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) and used the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) tool to convert it into the `fibonacci.wasm` WebAssembly program. Take it, for example. It exported a `fib()` function, which takes a single `i32` integer as the input parameter.



You can run:



```bash

wasmedge compile fibonacci.wasm fibonacci_aot.wasm

```



or:



```bash

wasmedge compile fibonacci.wasm fibonacci_aot.so # On Linux.

```



The output will be:



```bash

[2022-09-09 14:22:10.540] [info] compile start

[2022-09-09 14:22:10.541] [info] verify start

[2022-09-09 14:22:10.542] [info] optimize start

[2022-09-09 14:22:10.547] [info] codegen start

[2022-09-09 14:22:10.552] [info] output start

[2022-09-09 14:22:10.600] [info] compile done

```



Then you can execute the output file with `wasmedge` and measure the execution time:



```bash

time wasmedge --reactor fibonacci_aot.wasm fib 30

```



The output will be:



```bash

1346269



real    0m0.029s

user    0m0.012s

sys     0m0.014s

```



Then you can compare it with the interpreter mode:



```bash

time wasmedge --reactor fibonacci.wasm fib 30

```



The output shows that the AOT-compiled WASM is much faster than the interpreter mode:



```bash

1346269



real    0m0.442s

user    0m0.427s

sys     0m0.012s

```



## Output Format: Universal WASM



By default, the `wasmedge compile` AOT compiler tool could wrap the AOT-compiled native binary into a custom section in the origin WASM file. We call this the universal WASM binary format.



This AOT-compiled WASM file is compatible with any WebAssembly runtime. However, when this WASM file is executed by the WasmEdge runtime, WasmEdge will extract the native binary from the custom section and execute it in AOT mode.



<!-- prettier-ignore -->

:::note

On MacOS platforms, the universal WASM format will `bus error` in execution. By default, the `wasmedge compile` tool optimizes the WASM in the `O2` level. We are trying to fix this issue. For working around, please use the shared library output format instead.

:::



```bash

wasmedge compile app.wasm app_aot.wasm

wasmedge app_aot.wasm

```



## Output Format: Shared Library



Users can assign the shared library extension for the output files (`.so` on Linux, `.dylib` on MacOS, and `.dll` on Windows) to generate the shared library output format output.



This AOT-compiled WASM file is only for WasmEdge use and cannot be used by other WebAssembly runtimes.



```bash

wasmedge compile app.wasm app_aot.so

wasmedge app_aot.so

```








------"
"The following is a markdown document located at /start/build-and-run/cli.md
------


---

sidebar_position: 1

---



# The `wasmedge` CLI



After installing WasmEdge, you can use the `wasmedge` CLI to execute WASM files. We will cover how to run WASM files with WasmEdge on your machine and Docker images.



The `wasmedge` binary is a command line interface (CLI) program that runs WebAssembly programs.



- If the WebAssembly program contains a `main()` function, `wasmedge` would execute it as a standalone program in the command mode.

- If the WebAssembly program contains one or more exported public functions, `wasmedge` could invoke individual functions in the reactor mode.



By default, the `wasmedge` will execute WebAssembly programs in interpreter mode and execute the AOT-compiled `.so`, `.dylib`, `.dll`, or `.wasm` (universal output format) in AOT mode. If you want to accelerate the WASM execution, we recommend to [compile the WebAssembly with the AOT compiler](aot.md) first.



<!-- prettier-ignore -->

:::note

The original `wasmedgec` tool is changed to `wasmedge compile`. The [`wasmedge compile` CLI tool](aot.md) is the ahead-of-time compiler to compile the WebAssembly file into native code.

:::



```bash

$ wasmedge -v

wasmedge version {{ wasmedge_version }}

```



Users can run the `wasmedge -h` to realize the command line options quickly or [refer to the detailed `wasmedge` CLI options here](#options). The usage of the `wasmedge` tool will be:



```bash

$ wasmedge -h

USAGE

   wasmedge [OPTIONS] [--] WASM_OR_SO [ARG ...]



...

```



The `wasmedge` CLI tool will execute the wasm file in ahead-of-time(AOT) mode or interpreter mode. If the file has been compiled with `wasmedge compile`, then WasmEdge will execute it in AOT mode, otherwise, WasmEdge will execute it in interpreter mode.



## Options



The options of the `wasmedge` CLI tool are as follows:



1. `-v|--version`: Show the version information. Will ignore other arguments below.

2. `-h|--help`: Show the help messages. Will ignore other arguments below.

3. _(Optional)_ `--reactor`: Enable the reactor mode.

   - In the reactor mode, `wasmedge` runs a specified function exported by the WebAssembly program.

   - WasmEdge will execute the function whose name should be given in `ARG[0]`.

   - If an exported function names `_initialize`, the function will be executed with the empty parameter at first.

4. _(Optional)_ `--dir`: Bind directories into WASI virtual filesystem.

   - Use `--dir guest_path:host_path` to bind the host path into the guest path in WASI virtual system.

5. _(Optional)_ `--env`: Assign the environment variables in WASI.

   - Use `--env ENV_NAME=VALUE` to assign the environment variable.

6. _(Optional)_ Statistics information:

   - Use `--enable-time-measuring` to show the execution time.

   - Use `--enable-gas-measuring` to show the amount of used gas.

   - Use `--enable-instruction-count` to display the number of executed instructions.

   - Or use `--enable-all-statistics` to enable all of the statistics options.

7. _(Optional)_ Resource limitations:

   - Use `--time-limit MILLISECOND_TIME` to limit the execution time. Default value is `0` which specifies no limitation.

   - Use `--gas-limit GAS_LIMIT` to limit the execution cost.

   - Use `--memory-page-limit PAGE_COUNT` to set the limitation of pages(as size of 64 KiB) in every memory instance.

8. _(Optional)_ Execution mode:

   - Use `--force-interpreter` to forcibly run WASM in interpreter mode.

   - Use `--enable-jit` to enable Just-In-Time compiler for running WASM.

9. _(Optional)_ WebAssembly proposals:

   - Use `--disable-import-export-mut-globals` to disable the [Import/Export of Mutable Globals](https://github.com/WebAssembly/mutable-global) proposal (Default `ON`).

   - Use `--disable-non-trap-float-to-int` to disable the [Non-Trapping Float-to-Int Conversions](https://github.com/WebAssembly/nontrapping-float-to-int-conversions) proposal (Default `ON`).

   - Use `--disable-sign-extension-operators` to disable the [Sign-Extension Operators](https://github.com/WebAssembly/sign-extension-ops) proposal (Default `ON`).

   - Use `--disable-multi-value` to disable the [Multi-value](https://github.com/WebAssembly/multi-value) proposal (Default `ON`).

   - Use `--disable-bulk-memory` to disable the [Bulk Memory Operations](https://github.com/WebAssembly/bulk-memory-operations) proposal (Default `ON`).

   - Use `--disable-reference-types` to disable the [Reference Types](https://github.com/WebAssembly/reference-types) proposal (Default `ON`).

   - Use `--disable-simd` to disable the [Fixed-width SIMD](https://github.com/webassembly/simd) proposal (Default `ON`).

   - Use `--enable-multi-memory` to enable the [Multiple Memories](https://github.com/WebAssembly/multi-memory) proposal (Default `OFF`).

   - Use `--enable-tail-call` to enable the [Tail call](https://github.com/WebAssembly/tail-call) proposal (Default `OFF`).

   - Use `--enable-extended-const` to enable the [Extended Constant Expressions](https://github.com/WebAssembly/extended-const) proposal (Default `OFF`).

   - Use `--enable-threads` to enable the [Threads](https://github.com/webassembly/threads) proposal (Default `OFF`).

   - Use `--enable-function-reference` to enable the [Typed-Function References](https://github.com/WebAssembly/function-references) proposal (Default `OFF`).

   - Use `--enable-gc` to enable the [GC](https://github.com/WebAssembly/gc) proposal (Default `OFF`, interpreter mode only).

   - Use `--enable-exception-handling` to enable the [Exception Handling](https://github.com/WebAssembly/exception-handling) proposal (Default `OFF`, interpreter mode only).

   - Use `--enable-component` to enable the [Component Model](https://github.com/WebAssembly/component-model) proposal (Default `OFF`, loader phase only).

   - Use `--enable-all` to enable ALL proposals above.

10. WASM file (`/path/to/wasm/file`).

11. _(Optional)_ `ARG` command line arguments array.

    - In reactor mode, the first argument will be the function name, and the arguments after `ARG[0]` will be parameters of wasm function `ARG[0]`.

    - In command mode, the arguments will be the command line arguments of the WASI `_start` function. They are also known as command line arguments(`argv`) for a standalone C/C++ program.



## TensorFlow Tools



<!-- prettier-ignore -->

:::note

The `WasmEdge-tensorflow-tools` has been deprecated after the 0.12.1 version and replaced by the plug-ins after the 0.13.0 version.

:::



If users install WasmEdge from the install script with the option `-e tf,image`, the WasmEdge CLI tools with TensorFlow and TensorFlow-Lite extensions will also be installed.



- `wasmedge-tensorflow` CLI tool

  - The `wasmedge` tool with TensorFlow, TensorFlow-Lite, and `wasmedge-image` extensions.

  - Only on `x86_64` and `aarch64` Linux platforms and `x86_64` MacOS.

- `wasmedge-tensorflow-lite` CLI tool

  - The `wasmedge` tool with TensorFlow-Lite, and `wasmedge-image` extensions.

  - Only on `x86_64` and `aarch64` Linux platforms, Android, and `x86_64` MacOS.



## Examples



### Build and run a standalone WebAssembly app



The Hello World example is a standalone Rust application that can be executed by the [WasmEdge CLI](../build-and-run/cli). Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).



You will need to have the [Rust compiler installed](https://github.com/second-state/rust-examples/blob/main/README.md#prerequisites), and then use the following command to build the WASM bytecode file from the Rust source code.



```bash

cargo build --target wasm32-wasi --release

```



You can then use the `wasmedge` command to run the program.



```bash

$ wasmedge target/wasm32-wasi/release/hello.wasm

Hello WasmEdge!

```



#### Execute with `statistics` enabled



The CLI supports `--enable-all-statistics` flags for the statistics and gas metering.



You can run:



```bash

wasmedge --enable-all-statistics hello.wasm

```



The output will be:



```bash

Hello WasmEdge!

[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================

[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns

[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns

[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns

[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425

[2021-12-09 16:03:33.261] [info]  Gas costs: 20425

[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218

[2021-12-09 16:03:33.261] [info] =======================   End   ======================

```



#### Execute with `gas-limit` enabled



The CLI supports `--gas-limit` flags for controlling the execution costs.



For giving sufficient gas as the example, you can run:



```bash

wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm

```



The output will be:



```bash

Hello WasmEdge!

[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================

[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns

[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns

[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns

[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425

[2021-12-09 16:03:33.261] [info]  Gas costs: 20425

[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218

[2021-12-09 16:03:33.261] [info] =======================   End   ======================

```



For giving insufficient gas as the example, you can run:



```bash

wasmedge --enable-all-statistics --gas-limit 20 hello.wasm

```



The output will be:



```bash

Hello WasmEdge!

[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.

[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000

[2021-12-23 15:19:06.690] [error]     At AST node: expression

[2021-12-23 15:19:06.690] [error]     At AST node: element segment

[2021-12-23 15:19:06.690] [error]     At AST node: element section

[2021-12-23 15:19:06.690] [error]     At AST node: module

[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================

[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns

[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns

[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns

[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21

[2021-12-23 15:19:06.690] [info]  Gas costs: 20

```



### Call a WebAssembly function compiled from Rust



The [add](https://github.com/second-state/wasm-learning/tree/master/cli/add) program is written in Rust and contains an exported `add()` function. You can compile it into WebAssembly and use `wasmedge` to call the `add()` function. In this example, you will see how it is done from the CLI. It is often used when you embed WasmEdge into another host application, and need to call a WASM function from the host.



You will need to have the [Rust compiler](https://github.com/second-state/rust-examples/blob/main/README.md#prerequisites) installed, and then use the following command to build the WASM bytecode file from the Rust source code.



```bash

cargo build --target wasm32-wasi --release

```



You can execute `wasmedge` in reactor mode to invoke the `add()` function with two `i32` integer input parameters.



```bash

wasmedge --reactor add.wasm add 2 2

```



The output will be:



```bash

4

```



### Call a WebAssembly function written in WAT



We created the hand-written [fibonacci.wat](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat) and used the [wat2wasm](https://webassembly.github.io/wabt/demo/wat2wasm/) tool to convert it into the `fibonacci.wasm` WebAssembly program. It exported a `fib()` function which takes a single `i32` integer as the input parameter. We can execute `wasmedge` in reactor mode to invoke the exported function.



You can run:



```bash

wasmedge --reactor fibonacci.wasm fib 10

```



The output will be:



```bash

89

```



### JavaScript examples



Using WasmEdge as a high-performance, secure, extensible, easy-to-deploy, and [Kubernetes-compliant](https://github.com/second-state/wasmedge-containers-examples) JavaScript runtime is possible. There is no need to build a JavaScript app. You need to download the WasmEdge JavaScript runtime for Node.js.



- [Download the wasmedge_quickjs.wasm file here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm)

- [Download the modules.zip file here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip) and then unzip it into the current folder as `./modules/`



```bash

wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm

wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip

unzip modules.zip

```



Take a simple Javascript file for example. Save the following code as `hello.js`:



```javascript

args = args.slice(1);

print('Hello', ...args);

```



You can run:



```bash

wasmedge --dir .:. wasmedge_quickjs.wasm hello.js 1 2 3

```



The output will be:



```bash

Hello 1 2 3

```



The [qjs_tf.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm) is a JavaScript interpreter with [WasmEdge Tensorflow extension](https://www.secondstate.io/articles/wasi-tensorflow/) compiled into WebAssembly. To run [qjs_tf.wasm](https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm), you must use the `wasmedge-tensorflow-lite` CLI tool, which is a build of WasmEdge with Tensorflow-Lite extension built-in. You can download a full [Tensorflow-based JavaScript example](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo) to classify images.



```bash

# Download the Tensorflow example

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js



$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js

label: Hot dog

confidence: 0.8941176470588236

```



## Docker images for the CLI tools



The Docker images in this section are mostly used for development purposes. They allow you to use WasmEdge tools in containerized Linux environments. If you want to containerize WASM apps, check out [this](../getting-started/quick_start_docker.md) section.



The `wasmedge/slim:{version}` Docker images provide a slim WasmEdge images built with [DockerSlim](https://dockersl.im) every releases.



- Image `wasmedge/slim-runtime:{version}` includes only WasmEdge runtime with `wasmedge` command.

- Image `wasmedge/slim:{version}` includes the following command line utilities:

  - `wasmedge`

  - `wasmedge compile`

- Image `wasmedge/slim-tf:{version}` includes the following command line utilities (DEPRECATED after 0.13.0):

  - `wasmedge`

  - `wasmedge compile`

  - `wasmedge-tensorflow-lite`

  - `wasmedge-tensorflow`

  - `show-tflite-tensor`

- The working directory of the release docker image is `/app`.



### Dockerslim Examples



After pulling the docker image successfully, you could use `wasmedge compile` and `wasmedge` to aot compile the wasm file and run the wasm app.



```bash

$ docker pull wasmedge/slim:{{ wasmedge_version }}



$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge compile hello.wasm hello.aot.wasm

[2022-07-07 08:15:49.154] [info] compile start

[2022-07-07 08:15:49.163] [info] verify start

[2022-07-07 08:15:49.169] [info] optimize start

[2022-07-07 08:15:49.808] [info] codegen start

[2022-07-07 08:15:50.419] [info] output start

[2022-07-07 08:15:50.421] [info] compile done

[2022-07-07 08:15:50.422] [info] output start



$ docker run -it --rm -v $PWD:/app wasmedge/slim:{{ wasmedge_version }} wasmedge hello.aot.wasm world

hello

world

```



Use `wasmedge-tensorflow-lite` ([link](https://github.com/WasmEdge/WasmEdge/tree/master/examples/js)):



<!-- prettier-ignore -->

:::note

The `WasmEdge-tensorflow-tools` has been deprecated after the 0.12.1 version. We'll update to use the WasmEdge plug-in in the future.

:::



```bash

$ docker pull wasmedge/slim-tf:0.12.1

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite

$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js



$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:0.12.1 wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js

label:

Hot dog

confidence:

0.8941176470588236

```








------"
"The following is a markdown document located at /start/build-and-run/docker_wasm.md
------


---

sidebar_position: 4

---



# Docker + WASM



The Docker Desktop distributes with the WasmEdge Runtime embedded. That allows developers to build, share and run very lightweight containers (i.e., a `scratch` empty container with only the `.wasm` file without any Linux OS libraries or files) through Docker tools. Those ""WASM containers"" are fully OCI-compliant and hence can be managed by Docker Hub. They are cross-platform and can run on any OS / CPU Docker supports (the OS and CPU platform is `wasi/wasm`). But most importantly, they are 1/10 of the size of a comparable Linux container and start up in 1/10 of the time, as the WASM containers do not need to bundle and start Linux libraries and services.



Together with Docker's capability to containerize developer and deployment environments, you can create and deploy complex applications without installing any dependencies. For example, you could setup a complete Rust and WasmEdge development environment without installing either tool on your local dev machine. You can also deploy a complex WasmEdge app that needs to connect to a MySQL database without having to install MySQL locally.



In this guide, we will cover how to:



- [Create and run a Rust program](#create-and-run-a-rust-program)

- [Create and run a node.js server](#create-and-run-a-nodejs-server)

- [Create and deploy a database driven microservice in Rust](#create-and-deploy-a-database-driven-microservice-in-rust)



## Prerequisite



Install [Docker Desktop](https://www.docker.com/products/docker-desktop/) and turn on the containerd image store feature in your Docker Desktop settings.



![Docker config](docker_config.png)



## Create and run a Rust program



With Docker + WASM, you can use the entire Rust toolchain in a Docker container to build the WASM bytecode application, and then publish and run the WASM application. The [example Rust source code and build instructions are available here](https://github.com/second-state/rust-examples/tree/main/hello).



### Build the rust example



In the project directory, run the following command to build the Rust source code into WASM and then package the WASM file into an empty container image. Notice that you do not need to install the Rust compiler toolchain here.



```bash

docker buildx build --platform wasi/wasm -t secondstate/rust-example-hello .

```



The [Dockerfile](https://github.com/second-state/rust-examples/blob/main/hello/Dockerfile) shows how it is done. The Dockerfile has three parts. The first part sets up a Docker container for the Rust build environment.



```dockerfile

FROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase

WORKDIR /src

RUN <<EOT bash

    set -ex

    apt-get update

    apt-get install -y \

        git \

        clang

    rustup target add wasm32-wasi

EOT

```



The second part uses the Rust build environment to compile the Rust source code and generate the WASM file.



```dockerfile

FROM buildbase AS build

COPY Cargo.toml .

COPY src ./src

# Build the WASM binary

RUN cargo build --target wasm32-wasi --release

```



The third part is the essential. It copies the WASM file into an empty `scratch` container and then set the WASM file as the `ENTRYPOINT` of the container. It is the container image `rust-example-hello` built by the command in this section.



```dockerfile

FROM scratch

ENTRYPOINT [ ""hello.wasm"" ]

COPY --link --from=build /src/target/wasm32-wasi/release/hello.wasm /hello.wasm

```



The WASM container image is only 0.5MB. It is much smaller than a natively compiled Rust program in a minimal Linux container.



### Publish the rust example



To publish the WASM container image to Docker Hub, do the following.



```bash

docker push secondstate/rust-example-hello

```



### Run the rust example



You can use the regular Docker `run` command to run the WASM container application. Notice that you do need to specify the `runtime` and `platform` flags to tell Docker that this is a non-Linux container and requires WasmEdge to run it.



```bash

$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest

Hello WasmEdge!

```



That's it.



### Further reading for the rust example



To see more Dockerized Rust example apps for WasmEdge, check out the following.



- [Use Rust standard libraries](https://github.com/second-state/rust-examples/tree/main/wasi)

- [Create a HTTP server in hyper and tokio](https://github.com/second-state/rust-examples/tree/main/server)



## Create and run a node.js server



WasmEdge provides a node.js compatible JavaScript runtime. You can create lightweight WASM container images that runs node.js apps. Compared with standard node.js Linux container images, the WASM images are 1/100 of the size, completely portable, and starts up in 1/10 of the time.



In this guide, the example app is an HTTP web server written in node.js. Its [source code and build instructions are available here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).



### Build the node.js example



In the project directory, run the following command to package the WasmEdge JavaScript runtime and the JS HTTP server program into an empty container image.



```bash

docker buildx build --platform wasi/wasm -t secondstate/node-example-hello .

```



The [Dockerfile](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/docker_wasm/server/Dockerfile) shows how it is done. The Dockerfile has three parts. The first part sets up a Docker container for the `wget` and `unzip` utilities.



```dockerfile

FROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase

WORKDIR /src

RUN <<EOT bash

    set -ex

    apt-get update

    apt-get install -y \

        wget unzip

EOT

```



The second part uses `wget` and `unzip` to download and extract the WasmEdge JavaScript runtime files and the JS application files into a build container.



```dockerfile

FROM buildbase AS build

COPY server.js .

RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm

RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip

RUN unzip modules.zip

```



The third part is the essential. It copies the WasmEdge JavaScript runtime files and the JS application files into an empty `scratch` container and then set the `ENTRYPOINT`. It is the container image `node-example-hello` built by the command in this section.



```dockerfile

FROM scratch

ENTRYPOINT [ ""wasmedge_quickjs.wasm"", ""server.js"" ]

COPY --link --from=build /src/wasmedge_quickjs.wasm /wasmedge_quickjs.wasm

COPY --link --from=build /src/server.js /server.js

COPY --link --from=build /src/modules /modules

```



The WASM container image for the entire node.js app is only 1MB. It is much smaller than a standard node.js image, which is 300+MB.



### Publish the node.js example



To publish the WASM container image to Docker Hub, do the following.



```bash

docker push secondstate/node-example-hello

```



### Run and test the node.js example



You can use the regular Docker `run` command to run the WASM container application. Notice that you do need to specify the `runtime` and `platform` flags to tell Docker that this is a non-Linux container and requires WasmEdge to run it. Since this is an HTTP server app, you also need to map the container port 8080 to host so that you can access the server from the host.



```bash

$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest

listen 8080 ...

```



From another terminal, test the server application.



```bash

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""

Hello WasmEdge

```



That's it.



### Further reading for the node.js example



- [Use the fetch() API](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)

- [Image classification using Tensorflow Lite](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)



## Create and deploy a database driven microservice in Rust



Docker + wasm allows us to build and run WASM containers. However, in most complex applications, the WASM container is only part of the application. It needs to work together with other Linux containers in the system. The [Docker compose](https://docs.docker.com/compose/) tool is widely used to compose and manage multi-container deployments. It is installed with Docker Desktop.



In our [example microservice application](https://github.com/second-state/microservice-rust-mysql), there is an Nginx web server and a MySQL database. The WASM container is only for the Rust application that accesses the database and processes the HTTP requests (i.e., the application server).



<!-- prettier-ignore -->

:::note

For more Docker compose examples, including Linux containers + WASM containers mixed deployments, check out the [awesome-compose](https://github.com/docker/awesome-compose) repo.

:::



### Build the microservice example



In the project directory, run the following command to build all three containers: `client`, `server` and `db`.



```bash

docker compose up

```



There is a [docker-compose.yml](https://github.com/second-state/microservice-rust-mysql/blob/main/docker-compose.yml) file. It defines the 3 containers needed in this application.



```yaml

services:

  client:

    image: nginx:alpine

    ports:

      - 8090:80

    volumes:

      - ./client:/usr/share/nginx/html

  server:

    image: demo-microservice

    platform: wasi/wasm

    build:

      context: .

    ports:

      - 8080:8080

    environment:

      DATABASE_URL: mysql://root:whalehello@db:3306/mysql

      RUST_BACKTRACE: full

    restart: unless-stopped

    runtime: io.containerd.wasmedge.v1

  db:

    image: mariadb:10.9

    environment:

      MYSQL_ROOT_PASSWORD: whalehello

```



- The `client` container is an Nginx web server

  - Linux container with mapped HTTP port and volume for the static HTML/JS files

- The `server` container is a Rust container for the business logic

  - The WASM container is built from [Rust source code](https://github.com/second-state/microservice-rust-mysql/blob/main/src/main.rs) using this [Dockerfile](https://github.com/second-state/microservice-rust-mysql/blob/main/Dockerfile)

  - WASM container with mapped web service port and an environment variable for the database connection string

- The `db` container is a MySQL database

  - Linux container with a pre-set database password



### Deploy the microservice example



Start and run all three containers in the correct order with one command.



```bash

docker compose up

```



Go back to Docker Desktop Dash board, you will see there're three containers running.



![Docker](docker.jpeg)



### CRUD tests



Open another terminal, and you can use the `curl` command to interact with the web service.



When the microservice receives a `GET` request to the `/init` endpoint, it would initialize the database with the `orders` table.



```bash

curl http://localhost:8080/init

```



When the microservice receives a `POST` request to the `/create_order` endpoint, it would extract the JSON data from the `POST` body and insert an `Order` record into the database table. For multiple records, use the `/create_orders` endpoint and `POST` a JSON array of `Order` objects.



```bash

curl http://localhost:8080/create_orders -X POST -d @orders.json

```



When the microservice receives a `GET` request to the `/orders` endpoint, it would get all rows from the `orders` table and return the result set in a JSON array in the HTTP response.



```bash

curl http://localhost:8080/orders

```



When the microservice receives a `POST` request to the `/update_order` endpoint, it would extract the JSON data from the `POST` body and update the `Order` record in the database table that matches the `order_id` in the input data.



```bash

curl http://localhost:8080/update_order -X POST -d @update_order.json

```



When the microservice receives a `GET` request to the `/delete_order` endpoint, it would delete the row in the `orders` table that matches the `id` `GET` parameter.



```bash

curl http://localhost:8080/delete_order?id=2

```



That's it. Feel free to fork this project and use it as a template for your own lightweight microservices!



### Further reading for the microservice example



To learn how Docker + WASM works under the hood, visit the [containerd](../../develop/deploy/cri-runtime/containerd.md) chapter for more details.








------"
"The following is a markdown document located at /start/build-and-run/run.md
------


---

sidebar_position: 2

---



# `wasmedge run` CLI



After [installation](../install.md#install), users can execute the `wasmedge run` command.



`wasmedge run` is an alias of `wasmedge` without `-v|--version` option. The usage of the `wasmedge run` tool will be:



```bash

$ wasmedge run -h

USAGE

   wasmedge run [OPTIONS] [--] WASM_OR_SO [ARG ...]

```



## Options



`wasmedge run` is an alias of `wasmedge` without `-v|--version` option.



In the other words, if users want to execute the following command.



```bash

wasmedge --reactor fibonacci.wasm fib 10

```



It is also accepted to add subcommand `run` and will have no difference on execution process and result.



```bash

wasmedge run --reactor fibonacci.wasm fib 10

```








------"
"```json:/start/getting-started/_category_.json


{

  ""label"": ""Getting Started with WasmEdge"",

  ""position"": 3,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will show you how to get WasmEdge up and running quickly.""

  }

}








```"
"The following is a markdown document located at /start/getting-started/quick_start_docker.md
------


---

sidebar_position: 2

---



# Quick start with Docker



In this guide, we will walk you through how to quickly run WasmEdge apps in Docker Desktop. There is no additional dependencies as the entire development and runtime environments are managed by Docker Desktop.



<!-- prettier-ignore -->

:::note

If you are not using Docker Desktop, [get started here](quick_start.md).

:::



We will cover the following examples.



- [Run a standalone WASM app](#run-a-standalone-wasm-app)

- [Run an HTTP server](#run-an-http-server)

- [Run a JavaScript server (node.js)](#run-a-javascript-based-server)



In this quick start guide, we cover how to run WASM container apps using Docker commands. If you are interested in how to build, publish, and compose WASM container apps from source code, check out the [Docker + wasm chapter](../build-and-run/docker_wasm.md).



## Prerequisite



You must have Docker Desktop 4.15+ installed. Make sure you have turned on the containerd image store feature in your Docker Desktop.



![Docker config](docker_config.png)



## Run a standalone WASM app



The Hello world example is a standalone Rust application. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).



Use Docker to run the containerized WASM app. The WASM container image is stored in Docker Hub, and its image size is only 500KB. This image can run on any OS and CPU platform Docker supports.



```bash

$ docker run --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-hello:latest

Hello WasmEdge!

```



To learn more about how to create WASM apps in Rust



- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)

- [Rust developer guides](/category/develop-wasm-apps-in-rust)

  - WASI-NN with [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md), or [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) backends

  - [HTTP and HTTPS client](../../develop/rust/http_service/client.md)

  - [MySQL database client](../../develop/rust/database/my_sql_driver.md)

  - Redis client

  - Kafka client



## Run an HTTP server



This example is a standalone HTTP server written in Rust. It demonstrates that Rust + WasmEdge as a lightweight stack for microservices. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/server).



Use Docker to pull the container image (around 800KB) from Docker Hub and then run it in a WasmEdge container. The container starts as a server. Note how we map the container's port 8080 to the local host's port 8080 so that the server becomes accessible from outside of the WASM container.



```bash

$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/rust-example-server:latest

Listening on http://0.0.0.0:8080

```



From another terminal window, do the following.



```bash

$ curl http://localhost:8080/

Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`



$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""

Hello WasmEdge

```



To learn more about how to create WASM services in Rust



- [Rust developer guides](/category/develop-wasm-apps-in-rust)

- [HTTP application examples](https://github.com/WasmEdge/wasmedge_hyper_demo)

- [Database application examples](https://github.com/WasmEdge/wasmedge-db-examples)

- Lightweight microservices in Rust and WasmEdge

  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)

  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)

  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)



## Run a JavaScript-based server



This example is a standalone HTTP server written in JavaScript using the node.js API. It demonstrates WasmEdge as a lightweight runtime for zero-dependency and portable node.js applications. Its source code is available [here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).



```bash

$ docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest

... ...

```



From another terminal window, do the following.



```bash

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""

Hello WasmEdge

```



To learn more about how to run JavaScript apps in WasmEdge.



- [The WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)

- [AI inference application examples](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)

- [Web service client examples with fetch()](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)



## Next steps



- [Learn more about building and managing WASM containers in Docker](../build-and-run/docker_wasm.md)

- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)

- Use Docker Compose to build and Rust-based microservices

  - [WasmEdge / MySQL / Nginx](https://github.com/docker/awesome-compose/tree/master/wasmedge-mysql-nginx) - Sample Wasm-based web application with a static HTML frontend, using a MySQL (MariaDB) database. The frontend connects to a WASM microservice written in Rust, that runs using the WasmEdge runtime.

  - [WasmEdge / Kafka / MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql) - Sample Wasm-based microservice that subscribes to a Kafka (Redpanda) queue topic, and transforms and saves any incoming message into a MySQL (MariaDB) database.

- Write WASM apps in your favorite languages, like [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.








------"
"The following is a markdown document located at /start/getting-started/quick_start_redhat.md
------


---

sidebar_position: 3

---



# Quick start with Red Hat



In this guide, we will walk you through how to quickly run WasmEdge apps in Fedora / CentOS / Red Hat Linux / OpenShift systems. There is no additional dependencies as the entire development and runtime environments are managed by OpenSift / Podman.



<!-- prettier-ignore -->

:::note

If you are not using OpenShift / Podman, [get started here](quick_start.md).

:::



We will cover the following examples.



- [Run a standalone WASM app](#run-a-standalone-wasm-app)

- [Run an HTTP server](#run-an-http-server)

- [Run a JavaScript server (node.js)](#run-a-javascript-based-server)



## Install



You can use an one-liner `dnf` command to install WasmEdge, [crun](https://github.com/containers/crun) and [Podman](https://www.redhat.com/en/topics/containers/what-is-podman) on your Fedora / CentOS / Red Hat Linux system. The WasmEdge Runtime is available as an [officially maintained upstream package](https://packages.fedoraproject.org/pkgs/wasmedge/wasmedge/index.html) for Fedora 37 and Red Hat REPL 8 and 9.



```bash

dnf install wasmedge crun-wasm podman

```



## Run a standalone WASM app



The Hello world example is a standalone Rust application. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).



Use Podman to run the containerized WASM app. The WASM container image is stored in Docker Hub, and its image size is only 500KB. This image can run on any OS and CPU platform Red Hat supports.



```bash

$ podman --runtime /usr/bin/crun-wasm run --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-hello:latest

Hello WasmEdge!

```



To learn more about how to create WASM apps in Rust



- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)

- [Rust developer guides](/category/develop-wasm-apps-in-rust)

  - WASI-NN with [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md), or [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) backends

  - [HTTP and HTTPS client](../../develop/rust/http_service/client.md)

  - [MySQL database client](../../develop/rust/database/my_sql_driver.md)

  - Redis client

  - Kafka client



## Run an HTTP server



This example is a standalone HTTP server written in Rust. It demonstrates Rust + WasmEdge as a lightweight stack for microservices. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/server).



Use Podman to pull the container image (around 800KB) from Docker Hub and then run it in a WasmEdge container. The container starts as a server. Note how we map the container's port 8080 to the local host's port 8080 so that the server becomes accessible from outside of the WASM container.



```bash

$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/rust-example-server:latest

Listening on http://0.0.0.0:8080

```



From another terminal window, do the following.



```bash

$ curl http://localhost:8080/

Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`



$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""

Hello WasmEdge

```



To learn more about how to create WASM services in Rust



- [Rust developer guides](/category/develop-wasm-apps-in-rust)

- [HTTP application examples](https://github.com/WasmEdge/wasmedge_hyper_demo)

- [Database application examples](https://github.com/WasmEdge/wasmedge-db-examples)

- Lightweight microservices in Rust and WasmEdge

  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)

  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)

  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)



## Run a JavaScript-based server



This example is a standalone HTTP server written in JavaScript using the node.js API. It demonstrates WasmEdge as a lightweight runtime for zero-dependency and portable node.js applications. Its source code is available [here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).



```bash

$ podman --runtime /usr/bin/crun-wasm run -dp 8080:8080 --platform=wasi/wasm -t --rm docker.io/secondstate/node-example-server:latest

... ...

```



From another terminal window, do the following.



```bash

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""

Hello WasmEdge

```



To learn more about how to run JavaScript apps in WasmEdge.



- [The WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)

- [AI inference application examples](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)

- [Web service client examples with fetch()](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)



## Next steps



- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)

- Write WASM apps in your favorite languages, like [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.








------"
"The following is a markdown document located at /start/getting-started/quick_start.md
------


---

sidebar_position: 1

---



# Quick start on Linux



In this guide, we will walk you through how to quickly install and run the WasmEdge Runtime on a generic Linux distribution (such as Ubuntu, Debian, Raspberry OS or WSL on Windows). Comprehensive and OS-specific installation instructions can be found [here](../install.md#install).



<!-- prettier-ignore -->

:::note

If you have Docker Desktop 4.15 and above, you can skip this and [get started here](quick_start_docker.md). For Fedora Linux / Red Hat Linux / OpenShift / Podman users, [get started here](quick_start_redhat.md).

:::



We will cover the following examples:



- [How to run a standalone WASM app](#how-to-run-a-standalone-wasm-app)

- [How to run an HTTP server](#how-to-run-an-http-server)

- [How to run a JavaScript server (node.js)](#how-to-run-a-javascript-based-server)



## One-liner Installation of WasmEdge



The easiest way to install WasmEdge is to run the following command. You should have root or at least `sudo` privilege. Your system should have `git` and `curl` installed as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | sudo bash -s -- -p /usr/local

```



If you do not have root or `sudo` rights, use the following line to install WasmEdge in your `$HOME/.wasmedge` directory:



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

```



## How to run a standalone WASM app



The Hello world example is a standalone Rust application that can be executed by the [WasmEdge CLI](../build-and-run/cli.md). Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/hello).



Download the hello.wasm file [here](https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm), or run the following command:



```bash

wget https://github.com/second-state/rust-examples/releases/latest/download/hello.wasm

```



Use the `wasmedge` command to run the program.



```bash

$ wasmedge hello.wasm

Hello WasmEdge!

```



Use the AoT compiler `wasmedgec` to get much better performance.



```bash

$ wasmedgec hello.wasm hello_aot.wasm

$ wasmedge hello_aot.wasm

Hello WasmEdge!

```



To learn more about how to create WASM apps in Rust



- [Basic Rust examples for WasmEdge](https://github.com/second-state/rust-examples)

- [Rust developer guides](/category/develop-wasm-apps-in-rust)

  - WASI-NN with [PyTorch](../../develop/rust/wasinn/pytorch.md), [OpenVINO](../../develop/rust/wasinn/openvino.md), or [Tensorflow Lite](../../develop/rust/wasinn/tensorflow_lite.md) backends

  - [HTTP and HTTPS client](../../develop/rust/http_service/client.md)

  - [MySQL database client](../../develop/rust/database/my_sql_driver.md)

  - Redis client

  - Kafka client



## How to run an HTTP server



This example is a standalone HTTP server written in Rust. It demonstrates that Rust + WasmEdge as a lightweight stack for microservices. Its source code and build instructions are available [here](https://github.com/second-state/rust-examples/tree/main/server).



Download the server.wasm file [here](https://github.com/second-state/rust-examples/releases/latest/download/server.wasm), or run the following command:



```bash

wget https://github.com/second-state/rust-examples/releases/latest/download/server.wasm

```



Use the `wasmedge` command to run the program.



```bash

$ wasmedge server.wasm

Listening on http://0.0.0.0:8080

```



From another terminal window, do the following.



```bash

$ curl http://localhost:8080/

Try POSTing data to /echo such as: `curl localhost:8080/echo -XPOST -d 'hello world'`



$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""

Hello WasmEdge

```



To learn more about how to create WASM services in Rust



- [Rust developer guides](/category/develop-wasm-apps-in-rust)

- [HTTP application examples](https://github.com/WasmEdge/wasmedge_hyper_demo)

- [Database application examples](https://github.com/WasmEdge/wasmedge-db-examples)

- Lightweight microservices in Rust and WasmEdge

  - [WasmEdge + Nginx + MySQL](https://github.com/second-state/microservice-rust-mysql)

  - [WasmEdge + Kafka + MySQL](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)

  - [Dapr + WasmEdge](https://github.com/second-state/dapr-wasm)



## How to run a JavaScript-based server



This example is a standalone HTTP server written in JavaScript using the node.js API. It demonstrates WasmEdge as a lightweight runtime for node.js applications. Its source code is available [here](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/docker_wasm/server).



- Download the wasmedge_quickjs.wasm file [here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm), or run the following command:



```bash

wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm

```



- Download the modules.zip file [here](https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip), or run the following command:



```bash

wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip

```



Unzip the modules.zip file into the current folder as `./modules/`.



```bash

unzip modules.zip

```



- Download the server.js file [here](https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js).



```bash

wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/docker_wasm/server/server.js

```



Use the `wasmedge` command to run the program.



```bash

$ wasmedge --dir .:. wasmedge_quickjs.wasm server.js

listen 8080 ...

```



From another terminal window, do the following.



```bash

$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""

Hello WasmEdge

```



To learn more about how to run JavaScript apps in WasmEdge.



- [The WasmEdge QuickJS runtime](https://github.com/second-state/wasmedge-quickjs)

- [AI inference application examples](https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo)

- [Web service client examples with fetch()](https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js)



## Next steps



- Check out all available [WasmEdge CLI options](../build-and-run/cli.md) to explore WasmEdge's features.

- Write WASM apps in your favorite languages, like [Rust](/category/develop-wasm-apps-in-rust), [C/C++](/category/develop-wasm-apps-in-cc), [JavaScript](/category/develop-wasm-apps-in-javascript), [Go](/category/develop-wasm-apps-in-go), and many other languages.








------"
"```json:/start/usage/serverless/_category_.json


{

  ""label"": ""Serverless Platforms"",

  ""position"": 9,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""Run WebAssembly as an alternative lightweight runtime side-by-side with Docker and microVMs in cloud native infrastructure""

  }

}








```"
"The following is a markdown document located at /start/usage/serverless/aws.md
------


---

sidebar_position: 1

---



# WebAssembly Serverless Functions in AWS Lambda



In this article, we will show you two serverless functions in Rust and WasmEdge deployed on AWS Lambda. One is the image processing function, the other one is the TensorFlow inference function.



> For the insight on why WasmEdge on AWS Lambda, please refer to the article [WebAssembly Serverless Functions in AWS Lambda](https://www.secondstate.io/articles/webassembly-serverless-functions-in-aws-lambda/)



## Prerequisites



Since our demo WebAssembly functions are written in Rust, you will need a [Rust compiler](https://www.rust-lang.org/tools/install). Make sure that you install the `wasm32-wasi` compiler target as follows, in order to generate WebAssembly bytecode.



```bash

rustup target add wasm32-wasi

```



The demo application front end is written in [Next.js](https://nextjs.org/), and deployed on AWS Lambda. We will assume that you already have the basic knowledge of how to work with Next.js and Lambda.



## Example 1: Image processing



Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A [live demo](https://second-state.github.io/aws-lambda-wasm-runtime/) deployed through GitHub Pages is available.



Fork the [demo application’s GitHub repo](https://github.com/second-state/aws-lambda-wasm-runtime) to get started. To deploy the application on AWS Lambda, follow the guide in the repository [README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md).



### Create the function



This repo is a standard Next.js application. The backend serverless function is in the `api/functions/image_grayscale` folder. The `src/main.rs` file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the black-white image to the `STDOUT`.



```rust

use hex;

use std::io::{self, Read};

use image::{ImageOutputFormat, ImageFormat};



fn main() {

  let mut buf = Vec::new();

  io::stdin().read_to_end(&mut buf).unwrap();



  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();

  let img = image::load_from_memory(&buf).unwrap();

  let filtered = img.grayscale();

  let mut buf = vec![];

  match image_format_detected {

    ImageFormat::Gif => {

      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();

    },

    _ => {

      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();

    },

  };

  io::stdout().write_all(&buf).unwrap();

  io::stdout().flush().unwrap();

}

```



You can use Rust’s `cargo` tool to build the Rust program into WebAssembly bytecode or native code.



```bash

cd api/functions/image-grayscale/

cargo build --release --target wasm32-wasi

```



Copy the build artifacts to the `api` folder.



```bash

cp target/wasm32-wasi/release/grayscale.wasm ../../

```



> When we build the docker image, `api/pre.sh` is executed. `pre.sh` installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native `so` library for faster execution.



### Create the service script to load the function



The [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice that [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js) runs the compiled `grayscale.so` file generated by [`api/pre.sh`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/pre.sh) for better performance.



```javascript

const { spawn } = require('child_process');

const path = require('path');



function _runWasm(reqBody) {

  return new Promise((resolve) => {

    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [

      path.join(__dirname, 'grayscale.so'),

    ]);



    let d = [];

    wasmedge.stdout.on('data', (data) => {

      d.push(data);

    });



    wasmedge.on('close', (code) => {

      let buf = Buffer.concat(d);

      resolve(buf);

    });



    wasmedge.stdin.write(reqBody);

    wasmedge.stdin.end('');

  });

}

```



The `exports.handler` part of `hello.js` exports an async function handler, used to handle different events every time the serverless function is called. In this example, we simply process the image by calling the function above and return the result, but more complicated event-handling behavior may be defined based on your need. We also need to return some `Access-Control-Allow` headers to avoid [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) errors when calling the serverless function from a browser. You can read more about CORS errors [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors) if you encounter them when replicating our example.



```javascript

exports.handler = async function (event, context) {

  var typedArray = new Uint8Array(

    event.body.match(/[\da-f]{2}/gi).map(function (h) {

      return parseInt(h, 16);

    }),

  );

  let buf = await _runWasm(typedArray);

  return {

    statusCode: 200,

    headers: {

      'Access-Control-Allow-Headers':

        'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',

      'Access-Control-Allow-Origin': '*',

      'Access-Control-Allow-Methods':

        'DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT',

    },

    body: buf.toString('hex'),

  };

};

```



### Build the Docker image for Lambda deployment



Now we have the WebAssembly bytecode function and the script to load and connect to the web request. In order to deploy them as a function service on AWS Lambda, you still need to package the whole thing into a Docker image.



We are not going to cover in detail about how to build the Docker image and deploy on AWS Lambda, as there are detailed steps in the [Deploy section of the repository README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy). However, we will highlight some lines in the [`Dockerfile`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/Dockerfile) for you to avoid some pitfalls.



```dockerfile

FROM public.ecr.aws/lambda/nodejs:14



# Change directory to /var/task

WORKDIR /var/task



RUN yum update -y && yum install -y curl tar gzip



# Bundle and pre-compile the wasm files

COPY *.wasm ./

COPY pre.sh ./

RUN chmod +x pre.sh

RUN ./pre.sh



# Bundle the JS files

COPY *.js ./



CMD [ ""hello.handler"" ]

```



First, we are building the image from [AWS Lambda's Node.js base image](https://hub.docker.com/r/amazon/aws-lambda-nodejs). The advantage of using AWS Lambda's base image is that it includes the [Lambda Runtime Interface Client (RIC)](https://github.com/aws/aws-lambda-nodejs-runtime-interface-client), which we need to implement in our Docker image as it is required by AWS Lambda. The Amazon Linux uses `yum` as the package manager.



> These base images contain the Amazon Linux Base operating system, the runtime for a given language, dependencies and the Lambda Runtime Interface Client (RIC), which implements the Lambda [Runtime API](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html). The Lambda Runtime Interface Client allows your runtime to receive requests from and send requests to the Lambda service.



Second, we need to put our function and all its dependencies in the `/var/task` directory. Files in other folders will not be executed by AWS Lambda.



Third, we need to define the default command when we start our container. `CMD [ ""hello.handler"" ]` means that we will call the `handler` function in `hello.js` whenever our serverless function is called. Recall that we have defined and exported the handler function in the previous steps through `exports.handler = ...` in `hello.js`.



### Optional: test the Docker image locally



Docker images built from AWS Lambda's base images can be tested locally following [this guide](https://docs.aws.amazon.com/lambda/latest/dg/images-test.html). Local testing requires [AWS Lambda Runtime Interface Emulator (RIE)](https://github.com/aws/aws-lambda-runtime-interface-emulator), which is already installed in all of AWS Lambda's base images. To test your image, first, start the Docker container by running:



```bash

docker run -p 9000:8080  myfunction:latest

```



This command sets a function endpoint on your local machine at `http://localhost:9000/2015-03-31/functions/function/invocations`.



Then, from a separate terminal window, run:



```bash

curl -XPOST ""http://localhost:9000/2015-03-31/functions/function/invocations"" -d '{}'

```



And you should get your expected output in the terminal.



If you don't want to use a base image from AWS Lambda, you can also use your own base image and install RIC and/or RIE while building your Docker image. Just follow **Create an image from an alternative base image** section from [this guide](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html).



That's it! After building your Docker image, you can deploy it to AWS Lambda following steps outlined in the repository [README](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy). Now your serverless function is ready to rock!



## Example 2: AI inference



The [second demo](https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow) application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.



It is in [the same GitHub repo](https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow) as the previous example but in the `tensorflow` branch. The backend serverless function for image classification is in the `api/functions/image-classification` folder in the `tensorflow` branch. The `src/main.rs` file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the text output to the `STDOUT`. It utilizes the WasmEdge Tensorflow API to run the AI inference.



```rust

pub fn main() {

  // Step 1: Load the TFLite model

  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");

  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");



  // Step 2: Read image from STDIN

  let mut buf = Vec::new();

  io::stdin().read_to_end(&mut buf).unwrap();



  // Step 3: Resize the input image for the tensorflow model

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);



  // Step 4: AI inference

  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);

  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])

         .run();

  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");



  // Step 5: Find the food label that responds to the highest probability in res_vec

  // ... ...

  let mut label_lines = labels.lines();

  for _i in 0..max_index {

    label_lines.next();

  }



  // Step 6: Generate the output text

  let class_name = label_lines.next().unwrap().to_string();

  if max_value > 50 {

    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);

  } else {

    println!(""It does not appears to be any food item in the picture."");

  }

}

```



You can use the `cargo` tool to build the Rust program into WebAssembly bytecode or native code.



```bash

cd api/functions/image-classification/

cargo build --release --target wasm32-wasi

```



Copy the build artifacts to the `api` folder.



```bash

cp target/wasm32-wasi/release/classify.wasm ../../

```



Again, the `api/pre.sh` script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the `classify.wasm` bytecode program to the `classify.so` native shared library at the time of deployment.



The [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js) runs the compiled `classify.so` file generated by [`api/pre.sh`](https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/pre.sh) for better performance. The handler function is similar to our previous example, and is omitted here.



```javascript

const { spawn } = require('child_process');

const path = require('path');



function _runWasm(reqBody) {

  return new Promise(resolve => {

    const wasmedge = spawn(

      path.join(__dirname, 'wasmedge-tensorflow-lite'),

      [path.join(__dirname, 'classify.so')],

      {env: {'LD_LIBRARY_PATH': __dirname}}

    );



    let d = [];

    wasmedge.stdout.on('data', (data) => {

      d.push(data);

    });



    wasmedge.on('close', (code) => {

      resolve(d.join(''));

    });



    wasmedge.stdin.write(reqBody);

    wasmedge.stdin.end('');

  });

}



exports.handler = ... // _runWasm(reqBody) is called in the handler

```



You can build your Docker image and deploy the function in the same way as outlined in the previous example. Now you have created a web app for subject classification!



Next, it's your turn to use the [aws-lambda-wasm-runtime repo](https://github.com/second-state/aws-lambda-wasm-runtime/tree/main) as a template to develop Rust serverless function on AWS Lambda. Looking forward to your great work.








------"
"The following is a markdown document located at /start/usage/serverless/netlify.md
------


---

sidebar_position: 2

---



# WebAssembly Serverless Functions in Netlify



In this article we will show you two serverless functions in Rust and WasmEdge deployed on Netlify. One is the image processing function, the other one is the TensorFlow inference function.



> For more insights on why WasmEdge on Netlify, please refer to the article [WebAssembly Serverless Functions in Netlify](https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/).



## Prerequisite



Since our demo WebAssembly functions are written in Rust, you will need a [Rust compiler](https://www.rust-lang.org/tools/install). Make sure that you install the `wasm32-wasi` compiler target as follows, in order to generate WebAssembly bytecode.



```bash

rustup target add wasm32-wasi

```



The demo application front end is written in [Next.js](https://nextjs.org/), and deployed on Netlify. We will assume that you already have the basic knowledge of how to work with Next.js and Netlify.



## Example 1: Image processing



Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A [live demo](https://60fe22f9ff623f0007656040--reverent-hodgkin-dc1f51.netlify.app/) deployed on Netlify is available.



Fork the [demo application’s GitHub repo](https://github.com/second-state/netlify-wasm-runtime) to get started. To deploy the application on Netlify, just [add your github repo to Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/).



This repo is a standard Next.js application for the Netlify platform. The backend serverless function is in the [`api/functions/image_grayscale`](https://github.com/second-state/netlify-wasm-runtime/tree/main/api/functions/image-grayscale) folder. The [`src/main.rs`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the black-white image to the `STDOUT`.



```rust

use hex;

use std::io::{self, Read};

use image::{ImageOutputFormat, ImageFormat};



fn main() {

  let mut buf = Vec::new();

  io::stdin().read_to_end(&mut buf).unwrap();



  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();

  let img = image::load_from_memory(&buf).unwrap();

  let filtered = img.grayscale();

  let mut buf = vec![];

  match image_format_detected {

    ImageFormat::Gif => {

      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();

    },

    _ => {

      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();

    },

  };

  io::stdout().write_all(&buf).unwrap();

  io::stdout().flush().unwrap();

}

```



You can use Rust’s `cargo` tool to build the Rust program into WebAssembly bytecode or native code.



```bash

cd api/functions/image-grayscale/

cargo build --release --target wasm32-wasi

```



Copy the build artifacts to the `api` folder.



```bash

cp target/wasm32-wasi/release/grayscale.wasm ../../

```



> The Netlify function runs [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh) upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native `so` library for faster execution.



The [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js) runs the compiled `grayscale.so` file generated by [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh) for better performance.



```javascript

const fs = require('fs');

const { spawn } = require('child_process');

const path = require('path');



module.exports = (req, res) => {

  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [

    path.join(__dirname, 'grayscale.so'),

  ]);



  let d = [];

  wasmedge.stdout.on('data', (data) => {

    d.push(data);

  });



  wasmedge.on('close', (code) => {

    let buf = Buffer.concat(d);



    res.setHeader('Content-Type', req.headers['image-type']);

    res.send(buf);

  });



  wasmedge.stdin.write(req.body);

  wasmedge.stdin.end('');

};

```



That's it. [Deploy the repo to Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/) and you now have a Netlify Jamstack app with a high-performance Rust and WebAssembly based serverless backend.



## Example 2: AI inference



The [second demo](https://60ff7e2d10fe590008db70a9--reverent-hodgkin-dc1f51.netlify.app/) application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.



It is in [the same GitHub repo](https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow) as the previous example but in the `tensorflow` branch. The backend serverless function for image classification is in the [`api/functions/image-classification`](https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow/api/functions/image-classification) folder in the `tensorflow` branch. The [`src/main.rs`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the text output to the `STDOUT`. It utilizes the WasmEdge Tensorflow API to run the AI inference.



```rust

pub fn main() {

  // Step 1: Load the TFLite model

  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");

  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");



  // Step 2: Read image from STDIN

  let mut buf = Vec::new();

  io::stdin().read_to_end(&mut buf).unwrap();



  // Step 3: Resize the input image for the tensorflow model

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);



  // Step 4: AI inference

  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);

  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])

         .run();

  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");



  // Step 5: Find the food label that responds to the highest probability in res_vec

  // ... ...

  let mut label_lines = labels.lines();

  for _i in 0..max_index {

    label_lines.next();

  }



  // Step 6: Generate the output text

  let class_name = label_lines.next().unwrap().to_string();

  if max_value > 50 {

    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);

  } else {

    println!(""It does not appears to be any food item in the picture."");

  }

}

```



You can use the `cargo` tool to build the Rust program into WebAssembly bytecode or native code.



```bash

cd api/functions/image-classification/

cargo build --release --target wasm32-wasi

```



Copy the build artifacts to the `api` folder.



```bash

cp target/wasm32-wasi/release/classify.wasm ../../

```



Again, the [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh) script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the `classify.wasm` bytecode program to the `classify.so` native shared library at the time of deployment.



The [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js) script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js) runs the compiled `classify.so` file generated by [`api/pre.sh`](https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh) for better performance.



```javascript

const fs = require('fs');

const { spawn } = require('child_process');

const path = require('path');



module.exports = (req, res) => {

  const wasmedge = spawn(

    path.join(__dirname, 'wasmedge-tensorflow-lite'),

    [path.join(__dirname, 'classify.so')],

    { env: { LD_LIBRARY_PATH: __dirname } },

  );



  let d = [];

  wasmedge.stdout.on('data', (data) => {

    d.push(data);

  });



  wasmedge.on('close', (code) => {

    res.setHeader('Content-Type', `text/plain`);

    res.send(d.join(''));

  });



  wasmedge.stdin.write(req.body);

  wasmedge.stdin.end('');

};

```



You can now [deploy your forked repo to Netlify](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/) and have a web app for subject classification.



Next, it's your turn to develop Rust serverless functions in Netlify using the [netlify-wasm-runtime repo](https://github.com/second-state/netlify-wasm-runtime) as a template. Looking forward to your great work.








------"
"The following is a markdown document located at /start/usage/serverless/tencent.md
------


---

sidebar_position: 4

---



# WebAssembly serverless functions on Tencent Cloud



As the main users of Tencent Cloud are from China, so the tutorial is [written in Chinese](https://my.oschina.net/u/4532842/blog/5172639).



We also provide a code template for deploying serverless WebAssembly functions on Tencent Cloud, please check out [the tencent-scf-wasm-runtime repo](https://github.com/second-state/tencent-scf-wasm-runtime).



Fork the repo and start writing your own rust functions.








------"
"The following is a markdown document located at /start/usage/serverless/vercel.md
------


---

sidebar_position: 5

---



# Rust and WebAssembly Serverless functions in Vercel



In this article, we will show you two serverless functions in Rust and WasmEdge deployed on Vercel. One is the image processing function, the other one is the TensorFlow inference function.



> For more insights on why WasmEdge on Vercel, please refer to the article [Rust and WebAssembly Serverless Functions in Vercel](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/).



## Prerequisite



Since our demo WebAssembly functions are written in Rust, you will need a [Rust compiler](https://www.rust-lang.org/tools/install). Make sure that you install the `wasm32-wasi` compiler target as follows, in order to generate WebAssembly bytecode.



```bash

rustup target add wasm32-wasi

```



The demo application front end is written in [Next.js](https://nextjs.org/), and deployed on Vercel. We will assume that you already have the basic knowledge of how to work with Vercel.



## Example 1: Image processing



Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A [live demo](https://vercel-wasm-runtime.vercel.app/) deployed on Vercel is available.



Fork the [demo application’s GitHub repo](https://github.com/second-state/vercel-wasm-runtime) to get started. To deploy the application on Vercel, just [import the Github repo](https://vercel.com/docs/git#deploying-a-git-repository) from [Vercel for Github](https://vercel.com/docs/git/vercel-for-github) web page.



This repo is a standard Next.js application for the Vercel platform. The backend serverless function is in the [`api/functions/image_grayscale`](https://github.com/second-state/vercel-wasm-runtime/tree/main/api/functions/image-grayscale) folder. The [`src/main.rs`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the black-white image to the `STDOUT`.



```rust

use hex;

use std::io::{self, Read};

use image::{ImageOutputFormat, ImageFormat};



fn main() {

  let mut buf = Vec::new();

  io::stdin().read_to_end(&mut buf).unwrap();



  let image_format_detected: ImageFormat = image::guess_format(&buf).unwrap();

  let img = image::load_from_memory(&buf).unwrap();

  let filtered = img.grayscale();

  let mut buf = vec![];

  match image_format_detected {

    ImageFormat::Gif => {

      filtered.write_to(&mut buf, ImageOutputFormat::Gif).unwrap();

    },

    _ => {

      filtered.write_to(&mut buf, ImageOutputFormat::Png).unwrap();

    },

  };

  io::stdout().write_all(&buf).unwrap();

  io::stdout().flush().unwrap();

}

```



You can use Rust’s `cargo` tool to build the Rust program into WebAssembly bytecode or native code.



```bash

cd api/functions/image-grayscale/

cargo build --release --target wasm32-wasi

```



Copy the build artifacts to the `api` folder.



```bash

cp target/wasm32-wasi/release/grayscale.wasm ../../

```



> Vercel runs [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh) upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native `so` library for faster execution.



The [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js) file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js) runs the compiled `grayscale.so` file generated by [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh) for better performance.



```javascript

const fs = require('fs');

const { spawn } = require('child_process');

const path = require('path');



module.exports = (req, res) => {

  const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [

    path.join(__dirname, 'grayscale.so'),

  ]);



  let d = [];

  wasmedge.stdout.on('data', (data) => {

    d.push(data);

  });



  wasmedge.on('close', (code) => {

    let buf = Buffer.concat(d);



    res.setHeader('Content-Type', req.headers['image-type']);

    res.send(buf);

  });



  wasmedge.stdin.write(req.body);

  wasmedge.stdin.end('');

};

```



That's it. [Deploy the repo to Vercel](https://vercel.com/docs/git#deploying-a-git-repository) and you now have a Vercel Jamstack app with a high-performance Rust and WebAssembly based serverless backend.



## Example 2: AI inference



The [second demo](https://vercel-wasm-runtime.vercel.app/) application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.



It is in [the same GitHub repo](https://github.com/second-state/vercel-wasm-runtime) as the previous example but in the `tensorflow` branch. Note: when you [import this GitHub repo](https://vercel.com/docs/git#deploying-a-git-repository) on the Vercel website, it will create a [preview URL](https://vercel.com/docs/platform/deployments#preview) for each branch. The `tensorflow` branch would have its own deployment URL.



The backend serverless function for image classification is in the [`api/functions/image-classification`](https://github.com/second-state/vercel-wasm-runtime/tree/tensorflow/api/functions/image-classification) folder in the `tensorflow` branch. The [`src/main.rs`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs) file contains the Rust program’s source code. The Rust program reads image data from the `STDIN`, and then outputs the text output to the `STDOUT`. It utilizes the WasmEdge Tensorflow API to run the AI inference.



```rust

pub fn main() {

  // Step 1: Load the TFLite model

  let model_data: &[u8] = include_bytes!(""models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite"");

  let labels = include_str!(""models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt"");



  // Step 2: Read image from STDIN

  let mut buf = Vec::new();

  io::stdin().read_to_end(&mut buf).unwrap();



  // Step 3: Resize the input image for the tensorflow model

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&buf, 224, 224);



  // Step 4: AI inference

  let mut session = wasmedge_tensorflow_interface::Session::new(&model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);

  session.add_input(""input"", &flat_img, &[1, 224, 224, 3])

         .run();

  let res_vec: Vec<u8> = session.get_output(""MobilenetV1/Predictions/Reshape_1"");



  // Step 5: Find the food label that responds to the highest probability in res_vec

  // ... ...

  let mut label_lines = labels.lines();

  for _i in 0..max_index {

    label_lines.next();

  }



  // Step 6: Generate the output text

  let class_name = label_lines.next().unwrap().to_string();

  if max_value > 50 {

    println!(""It {} a <a href='https://www.google.com/search?q={}'>{}</a> in the picture"", confidence.to_string(), class_name, class_name);

  } else {

    println!(""It does not appears to be any food item in the picture."");

  }

}

```



You can use the `cargo` tool to build the Rust program into WebAssembly bytecode or native code.



```bash

cd api/functions/image-classification/

cargo build --release --target wasm32-wasi

```



Copy the build artifacts to the `api` folder.



```bash

cp target/wasm32-wasi/release/classify.wasm ../../

```



Again, the [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh) script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the `classify.wasm` bytecode program to the `classify.so` native shared library at the time of deployment.



The [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js) file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via `STDIN`. Notice [`api/hello.js`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js) runs the compiled `classify.so` file generated by [`api/pre.sh`](https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh) for better performance.



```javascript

const fs = require('fs');

const { spawn } = require('child_process');

const path = require('path');



module.exports = (req, res) => {

  const wasmedge = spawn(

    path.join(__dirname, 'wasmedge-tensorflow-lite'),

    [path.join(__dirname, 'classify.so')],

    { env: { LD_LIBRARY_PATH: __dirname } },

  );



  let d = [];

  wasmedge.stdout.on('data', (data) => {

    d.push(data);

  });



  wasmedge.on('close', (code) => {

    res.setHeader('Content-Type', `text/plain`);

    res.send(d.join(''));

  });



  wasmedge.stdin.write(req.body);

  wasmedge.stdin.end('');

};

```



You can now [deploy your forked repo to Vercel](https://vercel.com/docs/git#deploying-a-git-repository) and have a web app for subject classification.



Next, it's your turn to use [the vercel-wasm-runtime repo](https://github.com/second-state/vercel-wasm-runtime) as a template to develop your own Rust serverless functions in Vercel. Looking forward to your great work.








------"
"```json:/start/usage/_category_.json


{

  ""label"": ""WasmEdge Use-cases"",

  ""position"": 5,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""In this chapter, we will discuss use-cases of WasmEdge""

  }

}








```"
"The following is a markdown document located at /start/usage/use-cases.md
------


---

sidebar_position: 1

---



# Use Cases



Featuring AOT compiler optimization, WasmEdge is one of the fastest WebAssembly runtimes on the market today. Therefore WasmEdge is widely used in edge computing, automotive, Jamstack, serverless, SaaS, service mesh, and even blockchain applications.



- Modern web apps feature rich UIs that are rendered in the browser and/or on the edge cloud. WasmEdge works with popular web UI frameworks, such as React, Vue, Yew, and Percy, to support isomorphic [server-side rendering (SSR)](../../embed/use-case/ssr-modern-ui.md) functions on edge servers. It could also support server-side rendering of Unity3D animations and AI-generated interactive videos for web applications on the edge cloud.



- WasmEdge provides a lightweight, secure and high-performance runtime for microservices. It is fully compatible with application service frameworks such as Dapr, and service orchestrators like Kubernetes. WasmEdge microservices can run on edge servers, and have access to distributed cache, to support both stateless and stateful business logic functions for modern web apps. Also related: Serverless function-as-a-service in public clouds.



- [Serverless SaaS (Software-as-a-Service)](/category/serverless-platforms) functions enables users to extend and customize their SaaS experience without operating their own API callback servers. The serverless functions can be embedded into the SaaS or reside on edge servers next to the SaaS servers. Developers simply upload functions to respond to SaaS events or to connect SaaS APIs.



- [Smart device apps](./wasm-smart-devices.md) could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, and developer productivity. WasmEdge runs on Android, OpenHarmony, and seL4 RTOS devices.



- WasmEdge could support high performance DSLs (Domain Specific Languages) or act as a cloud-native JavaScript runtime by embedding a JS execution engine or interpreter.



- Developers can leverage container tools such as [Kubernetes](../../develop/deploy/kubernetes/kubernetes-containerd-crun.md), Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications.



- WasmEdge applications can be plugged into existing application frameworks or platforms.



If you have any great ideas on WasmEdge, don't hesitate to open a GitHub issue to discuss together.








------"
"The following is a markdown document located at /start/usage/wasm-smart-devices.md
------


---

sidebar_position: 4

---



# WasmEdge On Smart Devices



Smart device apps could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e., the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, OTA upgradability, and developer productivity. WasmEdge runs on the following device OSes.



- [Android](/category/build-and-run-wasmedge-on-android)

- [OpenHarmony](../../contribute/source/os/openharmony.md)

- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)

- [The seL4 RTOS](../../contribute/source/os/sel4.md)



With WasmEdge on both the device and the edge server, we can support [isomorphic Server-Side Rendering (SSR)](../../develop/rust/ssr.md) and [microservices](../../start/build-and-run/docker_wasm.md#deploy-the-microservice-example) for rich-client mobile applications that are both portable and upgradeable.








------"
"```json:/start/wasmedge/extensions/_category_.json


{

  ""label"": ""WasmEdge Extensions"",

  ""position"": 3,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""WasmEdge supports all standard WebAssembly and WASI specifications. In addition, it supports features and APIs that are crucial for the cloud-native use cases. WasmEdge is a superset of standard Wasm. Through its extension SDK, developers can easily add features they need to the WasmEdge Runtime as plugins.""

  }

}








```"
"The following is a markdown document located at /start/wasmedge/extensions/plugins.md
------


---

sidebar_position: 2

---



# WasmEdge Plug-ins



For those workloads which are too heavy to compile into WebAssembly, it would be more appropriate to build them into native host functions. To satisfy the portability of WebAssembly runtime, WasmEdge introduced the plug-in mechanism to make the host functions loadable and portable.



The plug-in mechanism for WasmEdge is an easy way to extend the host modules from loadable shared libraries. With the plug-ins, users can load and instantiate the host functions from the shared libraries released by WasmEdge official or even by other developers.



## Official Released Plug-ins



The following lists are the WasmEdge official released plug-ins. Users can install them easily by the installer.



| Plug-in | Description | Platform Support | Guest Language Support | Build From Source |

|---------|-------------|------------------|------------------------|-------------------|

| [WASI-Logging](https://github.com/WebAssembly/wasi-logging) | Logging API for WebAssembly program to log messages. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | Rust | [Steps](../../../contribute/source/plugin/wasi_logging.md) |

| [WASI-Crypto](https://github.com/WebAssembly/wasi-crypto) | APIs that a runtime can expose to WebAssembly modules in order to perform cryptographic operations and key management. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.10.1`) | [Rust](https://crates.io/crates/wasi-crypto) | [Steps](../../../contribute/source/plugin/wasi_crypto.md) |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(OpenVINO backend)](../../../develop/rust/wasinn/openvino.md) | AI inference using OpenVINO models. | `ubuntu 20.04 (x86_64)`<br/>(since `0.10.1`) | [Rust](https://crates.io/crates/wasi-nn), JavaScript | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-openvino-backend) |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(Pytorch backend)](../../../develop/rust/wasinn/pytorch.md) | AI inference using Pytorch models. | `manylinux2014 (x86_64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.11.1`) | [Rust](https://crates.io/crates/wasi-nn), JavaScript | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-pytorch-backend) |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(TensorFlow-Lite backend)](../../../develop/rust/wasinn/tensorflow_lite.md) | AI inference using TensorFlow-Lite models. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.11.2`) | [Rust](https://crates.io/crates/wasi-nn), JavaScript | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-tensorflow-lite-backend) |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(Ggml backend)](../../../develop/rust/wasinn/llm_inference.md) | AI inference using LLM interfaces. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.4`) | [Rust](https://github.com/second-state/wasmedge-wasi-nn) | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-llamacpp-backend) |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(Piper backend)](../../../develop/rust/wasinn/piper.md) | AI inference using Piper models. | `manylinux_2_28 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.14.1`) | [Rust](https://github.com/second-state/wasmedge-wasi-nn) | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-piper-backend) |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) [(Whisper backend)](../../../develop/rust/wasinn/whisper.md) | AI inference using Whisper models. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.14.1`) | [Rust](https://github.com/second-state/wasmedge-wasi-nn) | [Steps](../../../contribute/source/plugin/wasi_nn.md#build-wasmedge-with-wasi-nn-whisper-backend) |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) Burn.rs backend (Squeezenet) | AI inference using Squeezenet models in Burn.rs. | `ubuntu 20.04 (x86_64)`<br/>(since `0.14.1`) | [Rust](https://github.com/second-state/wasmedge-wasi-nn) | |

| [WASI-NN](https://github.com/WebAssembly/wasi-nn) Burn.rs backend (Whisper) | AI inference using Whisper models in Burn.rs. | `ubuntu 20.04 (x86_64)`<br/>(since `0.14.1`) | [Rust](https://github.com/second-state/wasmedge-wasi-nn) | |

| WasmEdge-ffmpeg | | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.14.0`) | | |

| [WasmEdge-Image](../../../contribute/source/plugin/image.md) | A native library to manipulate images for AI inference tasks. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.3.0) | [Steps](../../../contribute/source/plugin/image.md) |

| WasmEdge-LLMC | | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.14.1`) | | |

| WasmEdge-OpenCV | Very popular utility functions to process images and videos for AI input/output. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.3`) | | |

| [WasmEdge-Process](../../../contribute/source/plugin/process.md) | Allows WebAssembly programs to execute native commands in the host operating system. It supports passing arguments, environment variables, `STDIN`/`STDOUT` pipes, and security policies for host access. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.10.0`) | [Rust](https://crates.io/crates/wasmedge_process_interface) | [Steps](../../../contribute/source/plugin/process.md) |

| WasmEdge-StableDiffusion | | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.14.1`) | | |

| [WasmEdge-Tensorflow](../../../contribute/source/plugin/tensorflow.md) | A native library for inferring TensorFlow models.| `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.3.0) | [Steps](../../../contribute/source/plugin/tensorflow.md) |

| [WasmEdge-TensorflowLite](../../../contribute/source/plugin/tensorflowlite.md)| A native library for inferring TensorFlow-Lite models. | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`) | [Rust](https://crates.io/crates/wasmedge_tensorflow_interface) (0.3.0) | [Steps](../../../contribute/source/plugin/tensorflowlite.md) |

| WasmEdge-zlib | ??? | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.5`) | | |

| [WasmEdge-eBPF](../../../contribute/source/plugin/ebpf.md) | A native library for inferring eBPF applications | `manylinux2014 (x86_64,  aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>(since `0.13.2`) | Rust | [Steps](../../../contribute/source/plugin/ebpf.md) |

| [WasmEdge-rustls](../../../contribute/source/plugin/rusttls.md) (DEPRECATED) | A native library for inferring Rust and TLS Library | `manylinux2014 (x86_64, aarch64)`<br/>`ubuntu 20.04 (x86_64)`<br/>`darwin (x86_64, arm64)`<br/>(since `0.13.0`, until `0.13.5`) | [Rust](https://crates.io/crates/wasmedge_rustls_api) | [Steps](../../../contribute/source/plugin/rusttls.md) |








------"
"The following is a markdown document located at /start/wasmedge/extensions/proposals.md
------


---

sidebar_position: 1

---



# WebAssembly Proposals



## Standard WebAssembly Features



WasmEdge supports the following [WebAssembly proposals](https://github.com/WebAssembly/proposals). These proposals are likely to become official WebAssembly specifications in the future.



| Proposal | WasmEdge CLI flag | WasmEdge C API enumeration | Default turning on | Interpreter mode | AOT mode |

| --- | --- | --- | --- | --- | --- |

| [Import/Export of Mutable Globals][] | `--disable-import-export-mut-globals` | `WasmEdge_Proposal_ImportExportMutGlobals` | ✓ (since `0.8.2`) | ✓ | ✓ |

| [Non-trapping float-to-int conversions][] | `--disable-non-trap-float-to-int` | `WasmEdge_Proposal_NonTrapFloatToIntConversions` | ✓ (since `0.8.2`) | ✓ | ✓ |

| [Sign-extension operators][] | `--disable-sign-extension-operators` | `WasmEdge_Proposal_SignExtensionOperators` | ✓ (since `0.8.2`) | ✓ | ✓ |

| [Multi-value][] | `--disable-multi-value` | `WasmEdge_Proposal_MultiValue` | ✓ (since `0.8.2`) | ✓ | ✓ |

| [Reference Types][] | `--disable-reference-types` | `WasmEdge_Proposal_ReferenceTypes` | ✓ (since `0.8.2`) | ✓ | ✓ |

| [Bulk memory operations][] | `--disable-bulk-memory` | `WasmEdge_Proposal_BulkMemoryOperations` | ✓ (since `0.8.2`) | ✓ | ✓ |

| [Fixed-width SIMD][] | `--disable-simd` | `WasmEdge_Proposal_SIMD` | ✓ (since `0.9.0`) | ✓ (since `0.8.2`) | ✓ (since `0.8.2`) |

| [Tail call][] | `--enable-tail-call` | `WasmEdge_Proposal_TailCall` |  | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) |

| [Extended Constant Expressions][] | `--enable-extended-const` | `WasmEdge_Proposal_ExtendedConst` |  | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) |

| [Typed Function References][] | `--enable-function-reference` | `WasmEdge_Proposal_FunctionReferences` |  | ✓ (since `0.14.0`) | ✓ (since `0.14.0`) |

| [Garbage collection][] | `--enable-gc` | `WasmEdge_Proposal_GC` |  | ✓ (since `0.14.0`) |  |

| [Multiple memories][] | `--enable-multi-memory` | `WasmEdge_Proposal_MultiMemories` |  | ✓ (since `0.9.1`) | ✓ (since `0.9.1`) |

| [Threads][] | `--enable-threads` | `WasmEdge_Proposal_Threads` |  | ✓ (since `0.10.1`) | ✓ (since `0.10.1`) |

| [Exception handling][] | `--enable-exception-handling` | `WasmEdge_Proposal_ExceptionHandling` |  | ✓ (since `0.14.0`) |  |

| [Component Model][] | `--enable-component` | `WasmEdge_Proposal_Component` |  | Loader only (since `0.14.0`) |  |



The following proposals are under development and may be supported in the future:



- [Exception handling][]

- [Relaxed SIMD][]

- [Memory64][]

- [WebAssembly C and C++ API][]



[Import/Export of Mutable Globals]: https://github.com/WebAssembly/mutable-global

[Non-trapping float-to-int conversions]: https://github.com/WebAssembly/nontrapping-float-to-int-conversions

[Sign-extension operators]: https://github.com/WebAssembly/sign-extension-ops

[Multi-value]: https://github.com/WebAssembly/multi-value

[Reference Types]: https://github.com/WebAssembly/reference-types

[Bulk memory operations]: https://github.com/WebAssembly/bulk-memory-operations

[Fixed-width SIMD]: https://github.com/webassembly/simd

[Tail call]: https://github.com/WebAssembly/tail-call

[Multiple memories]: https://github.com/WebAssembly/multi-memory

[Extended Constant Expressions]: https://github.com/WebAssembly/extended-const

[Threads]: https://github.com/webassembly/threads

[Component Model]: https://github.com/WebAssembly/component-model

[Exception handling]: https://github.com/WebAssembly/exception-handling

[Typed Function References]: https://github.com/WebAssembly/function-references

[Garbage collection]: https://github.com/WebAssembly/gc

[Relaxed SIMD]: https://github.com/WebAssembly/relaxed-simd

[Memory64]: https://github.com/WebAssembly/memory64

[WebAssembly C and C++ API]: https://github.com/WebAssembly/wasm-c-api



## WASI proposals



WasmEdge implements the following [WASI proposals](https://github.com/WebAssembly/WASI/blob/main/Proposals.md):



| Proposal | Platform: `Linux x86_64` | Platform: `Linux aarch64` | Platform: `x86_64 MacOS` | Platform: `MacOS arm64` |

| --- | --- | --- | --- | --- |

| [Sockets][] | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) | ✓ (since `0.10.0`) |

| [Crypto][] | ✓ (since `0.10.1`) | ✓ (since `0.10.1`) | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) |

| [Logging][] | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) | ✓ (since `0.13.0`) |

| [Machine Learning (wasi-nn)][] | ✓ OpenVINO (since `0.10.1`)<br/>✓ PyTorch (since `0.11.1`)<br/>✓ TensorFlow-Lite (since `0.11.2`)<br/>✓ Ggml (since `0.13.4`) | ✓ Ggml (since `0.13.4`) | ✓ Ggml (since `0.13.4`) | ✓ Ggml (since `0.13.4`) |

| [proxy-wasm][] | ✓ (since `0.8.2`, interpreter) | | ✓ (since `0.11.2`, interpreter) | |



The following proposals is under development and may be supported in the future:



- TensorFlow backend of WASI-NN



[Sockets]: https://github.com/WebAssembly/wasi-sockets

[Crypto]: https://github.com/WebAssembly/wasi-crypto

[Logging]: https://github.com/WebAssembly/wasi-logging

[Machine Learning (wasi-nn)]: https://github.com/WebAssembly/wasi-nn

[proxy-wasm]: https://github.com/proxy-wasm/spec








------"
"The following is a markdown document located at /start/wasmedge/extensions/unique_extensions.md
------


---

sidebar_position: 3

---



# Other Extensions



A challenge for running WASM apps on the server side is the lack of support for Linux APIs and common application libraries. WasmEdge fixes this by adding support for many platform APIs for WASM apps. Developers can often simply compile their Linux apps to WASM and expect it run in WasmEdge. WasmEdge provides an easy extension mechanism for the community to add these APIs. For example,



Through its support for networking socket and related APIs, WasmEdge can run Rust applications that



- [provide HTTP services](https://github.com/WasmEdge/wasmedge_hyper_demo)

- [access external web services](https://github.com/WasmEdge/wasmedge_reqwest_demo)

- [connect to databases](https://github.com/WasmEdge/wasmedge-db-examples)

- [connect to messging queues](https://github.com/docker/awesome-compose/tree/master/wasmedge-kafka-mysql)

- [support database driven microservices](https://github.com/second-state/microservice-rust-mysql)

- [support microservices with Dapr sidecars](https://github.com/second-state/dapr-wasm)



Furthermore, the networking socket APIs also allow us to support the node.js API, including both the `server` and `fetch()`, in WasmEdge's JavaScript runtime.



Through its support for WASI-NN APIs, WasmEdge can support Rust and JavaScript applications for AI inference. Models from popular AI frameworks such as Tensorflow, PyTorch and OpenVINO [are all supported](https://github.com/second-state/WasmEdge-WASINN-examples).



## Available extensions



The extensions can be easily installed by the WasmEdge installer. They can also be included in WASM container images for Docker, Podman, and Kubernetes applications.



| Name | Description | Platform Support | Language support | Note |

| --- | --- | --- | --- | --- |

| Networking sockets | Supports async (non-blocking) POSIX networking sockets | Linux | Rust, JavaScript, C | Supports popular libraries such as tokio (Rust) and node (JavaScript) |

| DNS | Supports DNS domain names in networking sockets | Linux | Rust, JavaScript, C | Supports popular libraries such as tokio (Rust) and node (JavaScript) |

| Domain sockets | Supports high-performance data exchange between processes | Linux | Rust, JavaScript, C |  |

| TLS | Supports TLS and HTTPS connections from the networking sockets | Linux | Rust, JavaScript, C |  |

| KV Storage | Allows WebAssembly programs to read and write a key value store | Linux | Rust |  |

| [Ethereum](https://github.com/second-state/wasmedge-evmc) | supports Ethereum smart contracts compiled to WebAssembly. | Linux | none | It is a leading implementation for Ethereum flavored WebAssembly (Ewasm). |

| [Substrate](https://github.com/second-state/substrate-ssvm-node) | The [Pallet](https://github.com/second-state/pallet-ssvm) allows WasmEdge to act as an Ethereum smart contract execution engine on any Substrate based blockchains. | Linux | none |  |








------"
"```json:/start/wasmedge/_category_.json


{

  ""label"": ""What is WasmEdge"",

  ""position"": 4,

  ""link"": {

    ""type"": ""generated-index"",

    ""description"": ""WasmEdge is a WebAssembly runtime optimized for cloud-native and edge-native applications. It is a safe, fast, lightweight, and portable alternative to Linux containers in the cloud. It is also an ideal runtime for serverless functions, user-defined functions, embedded functions in application platforms and data pipelines.""

  }

}








```"
"The following is a markdown document located at /start/wasmedge/comparison.md
------


---

sidebar_position: 5

---



# Comparison



## What's the relationship between WebAssembly and Docker?



Check out our infographic [WebAssembly vs. Docker](https://wasmedge.org/wasm_linux_container/). WebAssembly runs side by side with Docker in cloud native and edge native applications.



## What's the difference for Native clients (NaCl), Application runtimes, and WebAssembly?



We created a handy table for the comparison.



|  | NaCl | Application runtimes (eg Node &amp; Python) | Docker-like container | WebAssembly |

| --- | --- | --- | --- | --- |

| Performance | Great | Poor | OK | Great |

| Resource footprint | Great | Poor | Poor | Great |

| Isolation | Poor | OK | OK | Great |

| Safety | Poor | OK | OK | Great |

| Portability | Poor | Great | OK | Great |

| Security | Poor | OK | OK | Great |

| Language and framework choice | N/A | N/A | Great | OK |

| Ease of use | OK | Great | Great | OK |

| Manageability | Poor | Poor | Great | Great |



## What's the difference between WebAssembly and eBPF?



`eBPF` is the bytecode format for a Linux kernel space VM that is suitable for network or security related tasks. WebAssembly is the bytecode format for a user space VM that is suited for business applications. [See details here](https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89).








------"
"The following is a markdown document located at /start/wasmedge/component_model.md
------


---

sidebar_position: 4

---



# Component Model



The component model for WASM would dramatically improve WASM module’s reusability and composability. It will allow better access from one WASM module to other modules and systems, including the operating system APIs (e.g., networking).



WasmEdge is already committed to supporting and implementing [the component model proposal](https://github.com/WebAssembly/component-model). See the related issue [here](https://github.com/WasmEdge/WasmEdge/issues/1892).



After the support for the component model is done, WasmEdge could be integrated by Spin and Spiderlightning.








------"
"The following is a markdown document located at /start/wasmedge/features.md
------


---

sidebar_position: 1

---



# WasmEdge Features



WasmEdge ([a sandbox project under CNCF](https://www.cncf.io/projects/wasmedge/)) is a safe, fast, lightweight, portable, and extensible WebAssembly runtime.



## High Performance



Taking advantage of [the LLVM-based AoT compiler](../build-and-run/aot), WasmEdge is the fastest WebAssembly runtime on the market.



- [A Lightweight Design for High-performance Serverless Computing](https://arxiv.org/abs/2010.07115), published on IEEE Software, Jan 2021. [https://arxiv.org/abs/2010.07115](https://arxiv.org/abs/2010.07115)

- [Performance Analysis for Arm vs. x86 CPUs in the Cloud](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/), published on infoQ.com, Jan 2021. [https://www.infoq.com/articles/arm-vs-x86-cloud-performance/](https://www.infoq.com/articles/arm-vs-x86-cloud-performance/)

- [WasmEdge is the fastest WebAssembly Runtime in Suborbital Reactr test suite](https://blog.suborbital.dev/suborbital-wasmedge), Dec 2021



## Cloud-native Extensions



Besides WASI and the standard WebAssembly proposal, WasmEdge has some cloud-native extensions.



- Non-blocking network sockets and web services with Rust, C, and JavaScript SDK

- MySQL-based database driver

- Key value store

- Gas meter for resource limitation

- WasmEdge-bindgen for complex para passing

- AI inference with TensorFlow, TensorFlow Lite, Pytorch, and OpenVINO



## JavaScript Support



Through the [WasmEdge-Quickjs](https://github.com/second-state/wasmedge-quickjs) project, WasmEdge could run a JavaScript program, lowering the bar for developing a WASM app.



- ES6 module and std API support

- NPM module support

- Native JS API in Rust

- Node.js API Support

- Async networking

- Fetch API

- React SSR



## Cloud Native orchestration



WasmEdge could be seamlessly integrated with the existing cloud-native infra.



To integrate WasmEdge with your existing cloud-native infrastructure, there are several options available for managing WASM applications as ""containers"" under Kubernetes. These options enable you to run Linux containers and WASM containers side by side within a Kubernetes cluster.



**Option #1:** is to [use an OCI runtime crun](../../develop/deploy/oci-runtime/crun.md) (the C version of runc — mainly supported by Red Hat). crun decides whether an OCI image is WASM or Linux based on image annotations. If the image is annotated as wasm32, crun will bypass the Linux container setup and just use WasmEdge to run the image. By using crun, you can get the entire Kubernetes stack - including CRI-O, containerd, Podman, kind, micro k8s, and k8s - to work with WASM images.



Option #2 is to [use a containerd-shim to start WASM ""containers"" via runwasi](../../develop/deploy/cri-runtime/containerd.md). Basically, containerd could look at the image's target platform. It uses runwasi if the image is wasm32 and runc if it is x86 / arm. This is the approach used by Docker + Wasm.



## Cross Platform



WASM is Portable. The compiled WASM file could run on different hardware and platforms without any changes.



WasmEdge supports a wide range of operating systems and hardware platforms. It allows WebAssembly applications to be truly portable across platforms. It runs on Linux-like systems and microkernels such as the `seL4` real-time system.



WasmEdge now supports:



- [Linux (x86_64 and aarch64)](../../contribute/source/os/linux.md)

- [MacOS (x86_64 and M1)](../../contribute/source/os/macos.md)

- [Windows 10](../../contribute/source/os/windows.md)

- [Android](/category/build-and-run-wasmedge-on-android)

- [seL4 RTOS](../../contribute/source/os/sel4.md)

- [OpenWrt](../../contribute/source/os/openwrt.md)

- [OpenHarmony](../../contribute/source/os/openharmony.md)

- [Raspberry Pi](../../contribute/source/os/raspberrypi.md)

- [RISC-V (WIP)](../../contribute/source/os/riscv64.md)



## Easy extensible



It is easy to build customized WasmEdge runtime with native host functions in C, Go, and Rust.



Or you could build your own plug-ins for WasmEdge in



- [Rust](../../contribute/plugin/develop_plugin_rustsdk)

- [C](../../contribute/plugin/develop_plugin_c)

- [C++](../../contribute/plugin/develop_plugin_cpp)



## Easy to Embed into a Host Application



[Embedded runtime](https://wasmedge.org/docs/embed/overview) is the classical use case for WasmEdge. You could embed WasmEdge functions in C, Go, Rust, Node.js, Java (WIP), and Python (WIP) host applications.








------"
"The following is a markdown document located at /start/wasmedge/integrations.md
------


---

sidebar_position: 2

---



# WasmEdge Integrations



WasmEdge is a ""serverless"" runtime for cloud-native and edge computing applications. It allows developers safely embed third-party or ""native"" functions into a host application or a distributed computing framework.



## Embed WasmEdge Into A Host Application



A major use case of WasmEdge is to start a VM instance from a host application. Depending on your host application's programming language, you can use WasmEdge SDKs to start and invoke WasmEdge functions.



- Embed WasmEdge functions into a `C`-based application using the [WasmEdge C API](/category/c-sdk-for-embedding-wasmedge). Checkout the [quick start guide](../../embed/c/intro.md).

- Embed WasmEdge functions into a `Go` application using the [WasmEdge Go API](/category/go-sdk-for-embedding-wasmedge). Here is a [tutorial](https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/) and are some [examples](https://github.com/second-state/WasmEdge-go-examples)!

- Embed WasmEdge functions into a `Rust` application using the [WasmEdge Rust crate](https://crates.io/crates/wasmedge-sdk).

- Embed WasmEdge functions into a `Node.js` application using the `NAPI`. Here is a [tutorial](https://www.secondstate.io/articles/getting-started-with-rust-function/).

- Embed WasmEdge functions into any application by spawning a new process. See examples for [Vercel Serverless Functions](https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/) and [AWS Lambda](https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/).



However, the WebAssembly spec only supports very limited data types as input parameters and return values for the WebAssembly bytecode functions. To pass complex data types, such as a string of an array, as call arguments into WebAssembly compiled from Rust, you should use the `bindgen` solution provided by the [`wasmedge-bindgen`](https://crates.io/crates/wasmedge-bindgen). We currently support the `wasmedge-bindgen` in the [Rust](../../develop/rust/bindgen.md) and in [Go](../../embed/go/bindgen.md).



## Use WasmEdge As A Docker-Like Container



WasmEdge provides an OCI-compliant interface. You can use container tools like CRI-O, Docker Hub, and Kubernetes to orchestrate and manage WasmEdge runtimes.



- [Manage WasmEdge with CRI-O and Docker Hub](https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/).



## Call Native Host Functions From WasmEdge



A key feature of WasmEdge is its extensibility. WasmEdge APIs allow developers to register ""host functions"" from the host programming languages into a WasmEdge instance and invoke these functions from the WebAssembly program.



- The WasmEdge C API supports the [C host functions](../../embed/c/host_function.md).

- The WasmEdge Go API supports the [Go host functions](https://github.com/second-state/WasmEdge-go-examples/tree/master/go_HostFunc#wasmedge-go-host-function-example).

- The WasmEdge Rust API supports the [Rust host functions](https://github.com/second-state/wasmedge-rustsdk-examples/blob/main/README.md#host-functions).



[Here is an example](https://www.secondstate.io/articles/call-native-functions-from-javascript/) of a JavaScript program in WasmEdge calling a C-based host function in the underlying OS.



The host functions break the WASM sandbox to access the underly OS or hardware. But the sandbox breaking is done with explicit permission from the system’s operator.








------"
"The following is a markdown document located at /start/faq.md
------


---

sidebar_position: 4

---



# Frequently Asked Questions



This FAQ page is designed to address the most common technical questions about WasmEdge. If your question is not directly answered here, please refer to the WasmEdge [documentation](https://wasmedge.org/docs/) or engage with the WasmEdge community via discord.



## 1. How does WasmEdge handle memory sharing between modules?



WasmEdge follows the WebAssembly specification, which currently does not support shared memory between different modules. Each module has its own linear memory space. This is because WebAssembly modules are isolated and cannot directly access each other's memory 1. However, it is possible to manually copy data from one module to another using host functions



## 2. Can WasmEdge support model training?



As of now, WasmEdge supports [model inference](https://www.secondstate.io/articles/fast-llm-inference/). It uses the WASI-NN API to make predictions using pre-trained models. However, model training is not yet supported. It only allows for the execution of pre-trained models.



## 3. What is the internal flow of WasmEdge?



The WasmEdge runtime follows a general flow: parsing the Wasm file, validating the parsed Wasm file, compiling the validated Wasm file into native code, and then executing the compiled code. For more detailed information, please refer to the WasmEdge runtime [documentation](https://wasmedge.org/docs/).



## 4. Why is my plugin crashing?



If your plugin crashes, it might be due to several reasons. It could be related to incorrect use of the WasmEdge API, or the plugin may be incompatible with the WasmEdge version you're using. It's recommended to debug the plugin using a debugger tool to get more detailed error information. Also it you should check the [plug-in documentation](https://wasmedge.org/docs/contribute/plugin/test_plugin)



## 5. How to create a VM to call `infer()` in a Wasm library?



You can use the WASI-NN API to call the `infer()` function in a Wasm library. First, you need to prepare the model, inputs, and outputs. Then, you can call the `infer()` function with these parameters.



## 6. Can WasmEdge support Tensorflow as its inference backend using WASI-NN?



Yes, WasmEdge can use Tensorflow as its [inference](https://wasmedge.org/docs/embed/go/ai/) backend through the WASI-NN API.



## 7. How to read a host file in WasmEdge runtime?



WasmEdge provides the WASI (WebAssembly System Interface) API for interacting with the host system, including file operations. You can use the [WASI API](https://wasmedge.org/docs/embed/go/reference/0.11.x?_highlight=wasi&_highlight=api#preregistrations) to open and read files from the host system.



## 8. What's the relationship between WasmEdge and Second State



The relationship between WasmEdge and Second State is rooted in the latter contributing their WasmEdge Runtime project to the Cloud Native Computing Foundation (CNCF). Subsequently, Second State became one of the maintainers for WasmEdge. As WasmEdge seeks to broaden its community, it continues to search for additional maintainers.



Please remember, this FAQ page is not exhaustive, and the WasmEdge community is always ready to help with any questions or issues you may have. Don't hesitate to reach out if you need assistance in our [Discord server](https://discord.gg/h4KDyB8XTt).








------"
"The following is a markdown document located at /start/install.md
------


---

sidebar_position: 2

---



# Install and uninstall WasmEdge



This chapter will discuss ways to install and uninstall the WasmEdge Runtime on various OSes and platforms. We will cover how to install plug-ins to WasmEdge.



<!-- prettier-ignore -->

:::note

Docker Desktop 4.15+ already has WasmEdge bundled in its distribution binary. If you use Docker Desktop, you will not need to install WasmEdge separately. Check out [how to run WasmEdge apps in Docker Desktop.](build-and-run/docker_wasm.md)

:::



## Install



You can install the WasmEdge Runtime on any generic Linux and MacOS platforms. If you use Windows 10 or Fedora / Red Hat Linux systems, you can install with their default package managers.



### Generic Linux and MacOS



The easiest way to install WasmEdge is to run the following command. Your system should have `git` and `curl` as prerequisites.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

```



Run the following command to make the installed binary available in the current session.



```bash

source $HOME/.wasmedge/env

```



#### Install for all users



WasmEdge is installed in the `$HOME/.wasmedge` directory by default. You can install it into a system directory, such as `/usr/local` to make it available to all users. To specify an install directory, run the `install.sh` script with the `-p` flag. You will need to run the following commands as the `root` user or `sudo` since they are written write into system directories.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local

```



#### Install a specific version of WasmEdge



The WasmEdge installer script will install the latest official release by default. You could install a specific version of WasmEdge, including pre-releases or old releases by passing the `-v` argument to the installer script. Here is an example.



```bash

VERSION={{ wasmedge_version }}

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v $VERSION

```



Suppose you are interested in the latest builds from the `HEAD` of the `master` branch, which is basically WasmEdge's nightly builds. In that case, you can download the release package directly from our Github Action's CI artifact. [Here is an example](https://github.com/WasmEdge/WasmEdge/actions/runs/2969775464#artifacts).



#### Install via Nix



For nix/nixos users, we also provide a `flake.nix` in repository, so you can install WasmEdge via:



```bash

nix profile install github:WasmEdge/WasmEdge

```



#### Install WasmEdge with plug-ins



WasmEdge plug-ins are pre-built native modules that provide additional functionalities to the WasmEdge Runtime. To install plug-ins with the runtime, you can pass the `--plugins` parameter in the installer. For example, the command below installs the `wasi_nn-ggml` plug-in to enable LLM (Large Language Model) inference.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_nn-ggml

```



To install multiple plug-ins, you can pass a list of plug-ins with the `--plugins` option. For example, the following command installs the `wasi_logging` and the `wasi_nn-ggml` plug-ins. The `wasi_logging` plug-in allows the Rust [log::Log](https://crates.io/crates/log) API to compile into Wasm and run in WasmEdge.



```bash

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- --plugins wasi_logging wasi_nn-ggml

```



The installer downloads the plug-in files from the WasmEdge release on GitHub, unzips them, and then copies them over to the `~/.wasmedge/plugin/` folder (for user install) and to the `/usr/local/lib/wasmedge/` folder (for system install).



<!-- prettier-ignore -->

:::note

The `WASI-NN` related plug-ins are all EXCLUSIVE. Users can only install one of the WASI-NN backends.



After WasmEdge `0.14.1`, the WASI-Logging plug-in is bundled into the WasmEdge shared library and is not necessary to be installed.



Some of plug-ins need dependencies. Please follow the guide in the comment column to install the dependencies.

:::



The following lists are the WasmEdge official released plug-ins. Users can install them easily by the parameters of `--plugins` option of installer.



| Plug-in | Parameter | Supported Platforms | Versions | Comment |

|---------|-----------|---------------------|----------|---------|

| WASI-Logging | `wasi_logging` | All | Since `0.13.0` | Bundled into WasmEdge library since `0.14.1`. |

| WASI-Crypto | `wasi_crypto` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.10.1` | |

| WASI-NN OpenVINO backend | `wasi_nn-openvino` | Linux (`x86_64`, Ubuntu only) | Since `0.10.1` | Users should install the [OpenVINO dependency](#openvino-dependencies). |

| WASI-NN PyTorch backend | `wasi_nn-pytorch` | Linux (`x86_64`) | Since `0.11.1` | Users should install the [PyTorch dependency](#pytorch-dependencies). |

| WASI-NN TensorFlow-Lite backend | `wasi_nn-tensorflowlite` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.11.2` | [Dependency](#tensorflow-lite-dependencies) installed automatically by installer. |

| WASI-NN GGML backend | `wasi_nn-ggml` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.13.4` | [Notes for the dependency](#ggml-dependencies) |

| WASI-NN Piper backend | `wasi_nn-piper` | Linux (`x86_64`, `aarch64`) | Since `0.14.1` | Users should install the [Piper dependency](#piper-dependencies). |

| WASI-NN Whisper backend | `wasi_nn-whisper` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.14.1` | |

| WASI-NN Burn.rs backend (Squeezenet) | `wasi_nn_burnrs-squeezenet` | Linux (`x86_64`, Ubuntu only) | Since `0.14.1` | |

| WASI-NN Burn.rs backend (Whisper) | `wasi_nn_burnrs-whisper` | Linux (`x86_64`, Ubuntu only) | Since `0.14.1` | |

| Ffmpeg | `wasmedge_ffmpeg` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.14.0` | |

| Image | `wasmedge_image` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.13.0` | |

| LLM | `wasmedge_llmc` | Linux (`x86_64`, `aarch64`) | Since `0.14.1` | |

| OpenCV mini | `wasmedge_opencvmini` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.13.3` | |

| Process | `wasmedge_process` | Linux (`x86_64`, `aarch64`) | Since `0.10.0` | |

| Stable Diffusion | `wasmedge_stablediffusion` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.14.1` | |

| TensorFlow | `wasmedge_tensorflow` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.13.0` | [Dependency](#tensorflow-dependencies) installed automatically by installer. |

| TensorFlow-Lite | `wasmedge_tensorflowlite` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.13.0` | [Dependency](#tensorflow-lite-dependencies) installed automatically by installer. |

| Zlib | `wasmedge_zlib` | Linux (`x86_64`, `aarch64`), MacOS (`x86_64`, `arm64`) | Since `0.13.5` | |

| WASM-eBPF | `wasm_bpf` | Linux (`x86_64`) | Since `0.13.2` | |

| Rust TLS | `wasmedge_rustls` | Linux (`x86_64`) | Since `0.13.0` | Until `0.13.5`. DEPRECATED. |



For further details of each plug-ins, please follow the [plug-in page](wasmedge/extensions/plugins.md).



### Windows



For `Windows 10`, you could use Windows Package Manager Client (aka `winget.exe`) to install WasmEdge with one single command in your terminal.



```bash

winget install wasmedge

```



To install plug-ins, you can download plug-in binary modules from the WasmEdge release page, unzip them, and then copy them to `C:\Program Files\WasmEdge\lib`.



### Fedora and Red Hat Linux



WasmEdge is now an official package on Fedora 36, Fedora 37, Fedora 38, Fedora EPEL 8, and Fedora EPEL 9. Check out the stable version [here](https://src.fedoraproject.org/rpms/wasmedge). To install WasmEdge on Fedora, run the following command:



```bash

dnf install wasmedge

```



For more usages, please check out Fedora docs.



To install plug-ins, you can download plug-in binary modules from the WasmEdge release page, unzip them, and then copy them over to `/usr/local/lib/wasmedge/`.



## What's installed



If you install into the `$HOME/.wasmedge` directory, you will have the following directories and files after installation:



- The `$HOME/.wasmedge/bin` directory contains the WasmEdge Runtime CLI executable files. You can copy and move them around on your file system.



  - The `wasmedge` tool is the standard WasmEdge runtime. You can use it from the CLI.

    - Execute a WASM file: `wasmedge --dir .:. app.wasm`

  - The `wasmedgec` tool is the ahead-of-time (AOT) compiler to compile a `.wasm` file into a native `.so` file (or `.dylib` on MacOS, `.dll` on Windows, or `.wasm` as the universal WASM format on all platforms). The `wasmedge` can then execute the output file.



    - Compile a WASM file into a AOT-compiled WASM: `wasmedgec app.wasm app.so`

    - Execute the WASM in AOT mode: `wasmedge --dir .:. app.so`



    <!-- prettier-ignore -->

    :::note

    The usage of `wasmedgec` is equal to `wasmedge compile`. We decide to deprecate `wasmedgec` in the future.

    :::



- The `$HOME/.wasmedge/lib` directory contains WasmEdge shared libraries and dependency libraries. They are useful for WasmEdge SDKs to launch WasmEdge programs and functions from host applications.

- The `$HOME/.wasmedge/include` directory contains the WasmEdge header files. They are useful for WasmEdge SDKs.

- The `$HOME/.wasmedge/plugin` directory contains the WasmEdge plug-ins. They are loadable extensions for WasmEdge SDKs and will automatically be loaded when running the WasmEdge CLI.



<!-- prettier-ignore -->

:::note

You could also change it to `/usr/local` if you did a system-wide install.

If you used `winget` to install WasmEdge, the files are located at `C:\Program Files\WasmEdge`.

:::



## Uninstall



To uninstall WasmEdge, you can run the following command:



```bash

bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)

```



If the `wasmedge` binary is not in `PATH` and it wasn't installed in the default `$HOME/.wasmedge` folder, then you must provide the installation path.



```bash

bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder

```



If you wish to uninstall uninteractively, you can pass in the `--quick` or `-q` flag.



```bash

bash <(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q

```



<!-- prettier-ignore -->

:::note

If a parent folder of the `wasmedge` binary contains `.wasmedge`, the folder will be considered for removal. For example, the script altogether removes the default `$HOME/.wasmedge` folder.

:::



If you used `dnf` to install WasmEdge on Fedora and Red Hat Linux, run the following command to uninstall it:



```bash

dnf remove wasmedge

```



If you used `winget` to install WasmEdge on Windows, run the following command to uninstall it:



```bash

winget uninstall wasmedge

```



## Appendix: Installing the Dependencies



### GGML Dependencies



The installer from WasmEdge 0.13.5 will detect CUDA automatically. If CUDA is detected, the installer will always attempt to install a CUDA-enabled version of the WASI-NN GGML plug-in.



If CPU is the only available hardware on your machine, the installer will install OpenBLAS version of plugin instead.



```bash

apt update && apt install -y libopenblas-dev # You may need sudo if the user is not root.

```



### TensorFlow-Lite Dependencies



If you install the WASI-NN TensorflowLite or `WasmEdge-TensorFlowLite` plug-in WITHOUT installer, you can download the shared libraries with the following commands:



```bash

VERSION=TF-2.12.0-CC

# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.

PLATFORM=manylinux2014_x86_64

# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.

# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.

# For the MacOS arm64 platforms, please use the `darwin_arm64`.

curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/$VERSION/WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz

tar -zxf WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz

rm -f WasmEdge-tensorflow-deps-TFLite-$VERSION-$PLATFORM.tar.gz

```



The shared library will be extracted in the current directory `./libtensorflowlite_c.so` (or `.dylib` for MacOS) and `./libtensorflowlite_flex.so` (after the `WasmEdge 0.13.0` version). You can move the library to the installation path:



```bash

# If you installed wasmedge locally as above

mv libtensorflowlite_c.so ~/.wasmedge/lib

mv libtensorflowlite_flex.so ~/.wasmedge/lib



# Or, if you installed wasmedge for all users in /usr/local/

mv libtensorflowlite_c.so /usr/local/lib

mv libtensorflowlite_flex.so /usr/local/lib



# Or on MacOS platforms

mv libtensorflowlite_c.dylib ~/.wasmedge/lib

mv libtensorflowlite_flex.dylib ~/.wasmedge/lib

```



### TensorFlow Dependencies



If you install the `WasmEdge-Tensorflow` plug-in WITHOUT installer, you can download the shared libraries with the following commands:



```bash

VERSION=TF-2.12.0-CC

# For the WasmEdge versions before 0.13.0, please use the `TF-2.6.0-CC` version.

PLATFORM=manylinux2014_x86_64

# For the Linux aarch64 platforms, please use the `manylinux2014_aarch64`.

# For the MacOS x86_64 platforms, please use the `darwin_x86_64`.

# For the MacOS arm64 platforms, please use the `darwin_arm64`.

curl -s -L -O --remote-name-all https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/TF-2.12.0-CC/WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz

tar -zxf WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz

rm -f WasmEdge-tensorflow-deps-TF-TF-$VERSION-$PLATFORM.tar.gz

```



The shared library will be extracted in the current directory `./libtensorflow_cc.so.2.12.0` and `./libtensorflow_framework.so.2.12.0` on `Linux` platforms, or `./libtensorflow_cc.2.12.0.dylib` and `./libtensorflow_framework.2.12.0.dylib` on `MacOS` platforms. You can move the library to the installation path:



```bash

# If you installed wasmedge locally as above

mv libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib

mv libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib

ln -s libtensorflow_cc.so.2.12.0 ~/.wasmedge/lib/libtensorflow_cc.so.2

ln -s libtensorflow_cc.so.2 ~/.wasmedge/lib/libtensorflow_cc.so

ln -s libtensorflow_framework.so.2.12.0 ~/.wasmedge/lib/libtensorflow_framework.so.2

ln -s libtensorflow_framework.so.2 ~/.wasmedge/lib/libtensorflow_framework.so



# Or, if you installed wasmedge for all users in /usr/local/

mv libtensorflow_cc.so.2.12.0 /usr/local/lib

mv libtensorflow_framework.so.2.12.0 /usr/local/lib

ln -s libtensorflow_cc.so.2.12.0 /usr/local/lib/libtensorflow_cc.so.2

ln -s libtensorflow_cc.so.2 /usr/local/lib/libtensorflow_cc.so

ln -s libtensorflow_framework.so.2.12.0 /usr/local/lib/libtensorflow_framework.so.2

ln -s libtensorflow_framework.so.2 /usr/local/lib/libtensorflow_framework.so



# Or on MacOS platforms

mv libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib

mv libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib

ln -s libtensorflow_cc.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_cc.2.dylib

ln -s libtensorflow_cc.2.dylib ~/.wasmedge/lib/libtensorflow_cc.dylib

ln -s libtensorflow_framework.2.12.0.dylib ~/.wasmedge/lib/libtensorflow_framework.2.dylib

ln -s libtensorflow_framework.2.dylib ~/.wasmedge/lib/libtensorflow_framework.dylib

```



### OpenVINO Dependencies



The WASI-NN plug-in with OpenVINO backend depends on the OpenVINO C library to perform AI/ML computations. The following commands are for Ubuntu 20.04 and above to install [OpenVINO](https://docs.openvino.ai/2023.0/openvino_docs_install_guides_installing_openvino_apt.html)(2023) dependencies.



```bash

wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB

sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB

echo ""deb https://apt.repos.intel.com/openvino/2023 ubuntu20 main"" | sudo tee /etc/apt/sources.list.d/intel-openvino-2023.list

sudo apt update

sudo apt-get -y install openvino

ldconfig

```



### PyTorch Dependencies



The WASI-NN plug-in with PyTorch backend depends on the `libtorch` C++ library to perform AI/ML computations. You need to install the [PyTorch 1.8.2 LTS](https://pytorch.org/get-started/locally/) dependencies for it to work properly.



```bash

export PYTORCH_VERSION=""1.8.2""

# For the Ubuntu 20.04 or above, use the libtorch with cxx11 abi.

export PYTORCH_ABI=""libtorch-cxx11-abi""

# For the manylinux2014, please use the without cxx11 abi version:

#   export PYTORCH_ABI=""libtorch""

curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip

unzip -q ""${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""

rm -f ""${PYTORCH_ABI}-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip""

export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$(pwd)/libtorch/lib

```



<!-- prettier-ignore -->

:::note

For the `Ubuntu 20.04` or above versions, the WasmEdge installer will install the `Ubuntu` version of WasmEdge and its plug-ins.

For other systems, the WasmEdge installer will install the `manylinux2014` version, and you should get the `libtorch` without `cxx11-abi`.

:::



### Piper Dependencies



The WASI-NN plug-in with Piper backend depends on the ONNX Runtime C++ API. For installation instructions, please refer to the installation table on the [official website](https://onnxruntime.ai/getting-started).



Example of installing ONNX Runtime 1.14.1 on Ubuntu:



```bash

curl -LO https://github.com/microsoft/onnxruntime/releases/download/v1.14.1/onnxruntime-linux-x64-1.14.1.tgz

tar zxf onnxruntime-linux-x64-1.14.1.tgz

mv onnxruntime-linux-x64-1.14.1/include/* /usr/local/include/

mv onnxruntime-linux-x64-1.14.1/lib/* /usr/local/lib/

rm -rf onnxruntime-linux-x64-1.14.1.tgz onnxruntime-linux-x64-1.14.1

ldconfig

```



## Troubleshooting



Some users, especially in China, reported encountering the Connection refused error when trying to download the `install.sh` from the `githubusercontent.com`.



Please make sure your network connection can access `github.com` and `githubusercontent.com` via VPN.



```bash

# The error message

curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused

```








------"
"The following is a markdown document located at /start/overview.md
------


---

sidebar_position: 1

displayed_sidebar: startSidebar

---



# Getting Started with WasmEdge



WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime for cloud-native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, udf, smart contracts, and IoT devices. WasmEdge is currently a CNCF (Cloud Native Computing Foundation) Sandbox project.



The WasmEdge Runtime provides a well-defined execution sandbox for its contained WebAssembly bytecode program. The runtime offers isolation and protection for operating system resources (e.g., file system, sockets, environment variables, processes) and memory space. The most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product (e.g., SaaS, database, edge nodes, or even blockchain nodes). It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.



This chapter will introduce how to install and get started with WasmEdge.



We will cover the following content:



- [Install and Uninstall WasmEdge](install.md)

- [Getting Started](/category/getting-started-with-wasmEdge)

- Introduce the [WasmEdge Runtime](/category/what-is-wasmedge)

- Usages of [Running WasmEdge](/category/running-with-wasmedge)

- [Frequently Asked Question](faq.md)

- [Style Guide](style_guide.md) for new contributors

- [Troubleshooting Guide](troubleshooting_guide.md)



For advanced programming with WasmEdge, please refer to the guides for [developing WASM apps](../develop/overview.md), [Embedding WasmEdge in your apps](../embed/overview.md), or [contributing](../contribute/overview.md) to WasmEdge.



If you find any issues or have any feedback, please reach out to us via the following ways.



- [Discord Chat](https://discord.gg/U4B5sFTkFc)

- [Create a GitHub issue for technical support](https://github.com/WasmEdge/WasmEdge/issues)

- [Submit a GitHub discussion](https://github.com/WasmEdge/WasmEdge/discussions)

- [Follow @realwasmedge on Twitter](https://twitter.com/realwasmedge)








------"
"The following is a markdown document located at /start/style_guide.md
------


# WasmEdge Style Guide



- [Documentation Style Guide](#documentation-style-guide)

  - [Language](#language)

  - [Structure and Format](#structure-and-format)

  - [Content](#content)

  - [Other Considerations](#other-considerations)

- [Coding Style Guide](#coding-style-guide)

  - [Code Formatting](#code-formatting)

  - [Code Quality](#code-quality)

  - [Testing](#testing)

  - [Security](#security)



## Documentation Style Guide



### Language



- Use clear, simple, and concise language. Avoid jargon and technical terms as much as possible. If they are unavoidable, provide clear definitions or explanations.

- Write in the active voice and use the second person (""you"") to make the documentation more user-oriented.



### Structure and Format



- Structure content with descriptive headings and subheadings.

- Make content more readable and easier to follow with bullet points and numbered lists.

- Include code examples and technical references where necessary. They should be well-formatted and easy to understand. Use code blocks and syntax highlighting for code examples.



### Content



- Start with an introduction that provides an overview of the topic.

- Provide step-by-step instructions and include code examples where necessary.

- Include a section on troubleshooting to help users solve common problems they might encounter.



### Other Considerations



- Encourage contributions from the community. Include a section explaining how users can contribute to the project.

- Regularly review the content and make updates as necessary.

- Ensure that the documentation is accessible to everyone. It should be easy to read, understand, and navigate.



## Coding Style Guide



### Code Formatting



- Use consistent indentation. For example, you can choose to use spaces over tabs and stick with it throughout the project.

- Use meaningful variable, function, and class names. They should clearly indicate what the variable contains, what the function does, etc.

- Comment your code. Explain what each section or line of code does, especially if it involves complex logic.



### Code Quality



- Keep your code DRY (Don't Repeat Yourself). If you find yourself writing the same code in multiple places, consider creating a function or class.

- Write small, single-purpose functions. Each function should do one thing and do it well.

- Handle errors properly. Don't leave empty catch blocks in your code.



### Testing



- Write tests for your code. This helps to catch bugs early and makes sure that the code is working as expected.

- Follow a testing methodology, like unit testing or integration testing.



### Security



- Avoid code that might lead to security vulnerabilities, such as SQL injection.

- Use secure functions and libraries.

- Follow the security best practices provided by the CNCF.








------"
"The following is a markdown document located at /start/troubleshooting_guide.md
------


---

sidebar_position: 4

---



# Troubleshooting Guide



This guide aims to provide solutions to common problems you may encounter when using WasmEdge, helping you to troubleshoot effectively and get back to your development work as quickly as possible.



## Installation Issues



If you encounter errors during the installation process, make sure to check the following:



1. **Supported Platform**: Make sure you are running a [supported operating system and architecture](https://wasmedge.org/docs/start/install/).



2. **Dependencies**: Ensure that all necessary dependencies are installed and up-to-date. This includes the correct versions of your compiler, build system (like CMake), and any libraries that WasmEdge depends on.



3. **Environment**: Check your environment variables and paths. Some issues can be caused by incorrect paths or missing environment variables.



## Runtime Errors



Runtime errors can occur for a variety of reasons. Here are some common causes and solutions:



1. **Incorrect Usage**: If you're getting errors when executing a Wasm file, make sure that you're using the wasmedge command correctly. Check the [CLI documentation](https://wasmedge.org/docs/start/build-and-run/cli/) to make sure you're using the correct syntax and options.



2. **Incompatible Wasm Files**: Not all Wasm files are compatible with WasmEdge. If the Wasm file uses features or instructions that are not supported by WasmEdge, it may fail to execute. Make sure the Wasm file is compatible with WasmEdge.



3. **Plugin Issues**: If you're using plugins and they're causing issues, make sure the plugins are correctly installed and configured. Check the [plugin documentation](https://wasmedge.org/docs/category/wasmedge-plugin-system) for any specific requirements or known issues.



## Performance Issues



If WasmEdge is running slowly or consuming too much memory, consider the following:



1. **Optimization**: Make sure you're using the [AOT compiler](https://wasmedge.org/docs/start/build-and-run/aot/) if performance is a concern. The AOT compiler can significantly speed up the execution of Wasm files.



2. **Memory Usage**: If memory usage is too high, consider whether the Wasm file or the data it's processing is too large. You may need to optimize the Wasm file or adjust the way it processes data.



## Contributing to WasmEdge



If you're having trouble contributing to WasmEdge, make sure to:



1. **Follow the Contribution Guidelines**: Ensure that your contributions follow the [guidelines](https://wasmedge.org/docs/contribute/).



2. **Understand the Code**: Make sure you have a good understanding of the [WasmEdge codebase](https://github.com/WasmEdge/WasmEdge) before making changes.



3. **Test Your Changes**: Always test your changes before submitting a pull request. This can help catch issues early and make the review process smoother.



If any of the above steps do not help you, you should ask about your problem in Wasmedge's [discord server](https://discord.gg/h4KDyB8XTt) for furthur help.




------"
