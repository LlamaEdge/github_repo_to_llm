"```javascript:modules\url.js
import * as p$1 from 'punycode';
import * as o$1 from 'querystring';
import process from 'process';
import * as exports$1 from 'path';
import { URL } from 'whatwg_url'

var h = {}
var e = p$1
var a = {
  isString: function (t) { return ""string"" == typeof t },
  isObject: function (t) { return ""object"" == typeof t && null !== t },
  isNull: function (t) { return null === t },
  isNullOrUndefined: function (t) { return null == t }
};
function r() {
  this.protocol = null
  this.slashes = null
  this.auth = null
  this.host = null
  this.port = null
  this.hostname = null
  this.hash = null
  this.search = null
  this.query = null
  this.pathname = null
  this.path = null
  this.href = null
}
h.parse = O
h.resolve = function (t, s) {
  return O(t, !1, !0).resolve(s)
}
h.resolveObject = function (t, s) {
  return t ? O(t, !1, !0).resolveObject(s) : s
}
h.format = function (t) {
  a.isString(t) && (t = O(t))
  return t instanceof r ? t.format() : r.prototype.format.call(t)
}
h.Url = r
var o = /^([a-z0-9.+-]+:)/i, n = /:[0-9]*$/, i = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, l = [""{"", ""}"", ""|"", ""\\"", ""^"", ""`""].concat([""<"", "">"", '""', ""`"", "" "", ""\r"", ""\n"", ""\t""]), p = [""'""].concat(l), c = [""%"", ""/"", ""?"", "";"", ""#""].concat(p), u = [""/"", ""?"", ""#""], f = /^[+a-z0-9A-Z_-]{0,63}$/, m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, v = { javascript: !0, ""javascript:"": !0 }, g = { javascript: !0, ""javascript:"": !0 }, y = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, ""http:"": !0, ""https:"": !0, ""ftp:"": !0, ""gopher:"": !0, ""file:"": !0 }, b = o$1;
function O(t, s, h) {
  if (t && a.isObject(t) && t instanceof r) {
    return t;
  }
  var e = new r;
  return e.parse(t, s, h), e
}
r.prototype.parse = function (t, s, h) {
  if (!a.isString(t)) {
    throw new TypeError(""Parameter 'url' must be a string, not "" + typeof t);
  }
  var r = t.indexOf(""?"")
  var n = -1 !== r && r < t.indexOf(""#"") ? ""?"" : ""#""
  var l = t.split(n);
  l[0] = l[0].replace(/\\/g, ""/"");
  var O = t = l.join(n);
  if (O = O.trim(), !h && 1 === t.split(""#"").length) {
    var d = i.exec(O);
    if (d) {
      return this.path = O, this.href = O, this.pathname = d[1], d[2] ? (this.search = d[2], this.query = s ? b.parse(this.search.substr(1)) : this.search.substr(1)) : s && (this.search = """", this.query = {}), this
    }
  }
  var j = o.exec(O);
  if (j) {
    var q = (j = j[0]).toLowerCase();
    this.protocol = q
    O = O.substr(j.length);
  }
  if (h || j || O.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var x = ""//"" === O.substr(0, 2);
    !x || j && g[j] || (O = O.substr(2), this.slashes = !0);
  }
  if (!g[j] && (x || j && !y[j])) {
    for (var A, C, I = -1, w = 0; w < u.length; w++) {
      -1 !== (N = O.indexOf(u[w])) && (-1 === I || N < I) && (I = N);
    }
    -1 !== (C = -1 === I ? O.lastIndexOf(""@"") : O.lastIndexOf(""@"", I)) && (A = O.slice(0, C), O = O.slice(C + 1), this.auth = decodeURIComponent(A))
    I = -1;
    for (w = 0; w < c.length; w++) {
      var N; -1 !== (N = O.indexOf(c[w])) && (-1 === I || N < I) && (I = N);
    }
    -1 === I && (I = O.length), this.host = O.slice(0, I), O = O.slice(I)
    this.parseHost()
    this.hostname = this.hostname || """"
    var U = ""["" === this.hostname[0] && ""]"" === this.hostname[this.hostname.length - 1];
    if (!U) {
      for (var k = this.hostname.split(/\./), S = (w = 0, k.length); w < S; w++) {
        var R = k[w];
        if (R && !R.match(f)) {
          for (var $ = """", z = 0, H = R.length; z < H; z++) {
            R.charCodeAt(z) > 127 ? $ += ""x"" : $ += R[z];
          }
          if (!$.match(f)) {
            var L = k.slice(0, w), Z = k.slice(w + 1), _ = R.match(m); _ && (L.push(_[1]), Z.unshift(_[2])), Z.length && (O = ""/"" + Z.join(""."") + O)
            this.hostname = L.join(""."");
            break
          }
        }
      }
    }
    this.hostname.length > 255 ? this.hostname = """" : this.hostname = this.hostname.toLowerCase()
    U || (this.hostname = e.toASCII(this.hostname));
    var E = this.port ? "":"" + this.port : """"
    P = this.hostname || """";
    this.host = P + E, this.href += this.host
    U && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), ""/"" !== O[0] && (O = ""/"" + O));
  }
  if (!v[q]) {
    for (w = 0, S = p.length; w < S; w++) {
      var T = p[w];
      if (-1 !== O.indexOf(T)) {
        var B = encodeURIComponent(T); B === T && (B = escape(T)), O = O.split(T).join(B);
      }
    }
  }
  var D = O.indexOf(""#""); -1 !== D && (this.hash = O.substr(D), O = O.slice(0, D));
  var F = O.indexOf(""?"");
  if (-1 !== F ? (this.search = O.substr(F), this.query = O.substr(F + 1), s && (this.query = b.parse(this.query)), O = O.slice(0, F)) : s && (this.search = """", this.query = {}), O && (this.pathname = O), y[q] && this.hostname && !this.pathname && (this.pathname = ""/""), this.pathname || this.search) {
    E = this.pathname || """"; var G = this.search || """"; this.path = E + G;
  }
  return this.href = this.format(), this
}
r.prototype.format = function () {
  var t = this.auth || """";
  t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, "":""), t += ""@"");
  var s = this.protocol || """", h = this.pathname || """", e = this.hash || """", r = !1, o = """";
  this.host ? r = t + this.host : this.hostname && (r = t + (-1 === this.hostname.indexOf("":"") ? this.hostname : ""["" + this.hostname + ""]""), this.port && (r += "":"" + this.port)), this.query && a.isObject(this.query) && Object.keys(this.query).length && (o = b.stringify(this.query));
  var n = this.search || o && ""?"" + o || """";
  return s && "":"" !== s.substr(-1) && (s += "":""), this.slashes || (!s || y[s]) && !1 !== r ? (r = ""//"" + (r || """"), h && ""/"" !== h.charAt(0) && (h = ""/"" + h)) : r || (r = """"), e && ""#"" !== e.charAt(0) && (e = ""#"" + e), n && ""?"" !== n.charAt(0) && (n = ""?"" + n), s + r + (h = h.replace(/[?#]/g, (function (t) { return encodeURIComponent(t) }))) + (n = n.replace(""#"", ""%23"")) + e
}
r.prototype.resolve = function (t) {
  return this.resolveObject(O(t, !1, !0)).format()
}
r.prototype.resolveObject = function (t) {
  if (a.isString(t)) {
    var s = new r; s.parse(t, !1, !0), t = s;
  }
  for (var h = new r, e = Object.keys(this), o = 0; o < e.length; o++) {
    var n = e[o]; h[n] = this[n];
  }
  if (h.hash = t.hash, """" === t.href) {
    return h.href = h.format(), h;
  }
  if (t.slashes && !t.protocol) {
    for (var i = Object.keys(t), l = 0; l < i.length; l++) {
      var p = i[l];
      ""protocol"" !== p && (h[p] = t[p]);
    }
    return y[h.protocol] && h.hostname && !h.pathname && (h.path = h.pathname = ""/""), h.href = h.format(), h
  }
  if (t.protocol && t.protocol !== h.protocol) {
    if (!y[t.protocol]) {
      for (var c = Object.keys(t), u = 0; u < c.length; u++) {
        var f = c[u]; h[f] = t[f];
      }
      return h.href = h.format(), h
    }
    if (h.protocol = t.protocol, t.host || g[t.protocol]) {
      h.pathname = t.pathname;
    } else {
      for (var m = (t.pathname || """").split(""/""); m.length && !(t.host = m.shift());) { }
      t.host || (t.host = """")
      t.hostname || (t.hostname = """")
      """" !== m[0] && m.unshift("""")
      m.length < 2 && m.unshift("""")
      h.pathname = m.join(""/"");
    }
    if (h.search = t.search, h.query = t.query, h.host = t.host || """", h.auth = t.auth, h.hostname = t.hostname || t.host, h.port = t.port, h.pathname || h.search) {
      var v = h.pathname || """", b = h.search || """"; h.path = v + b;
    }
    return h.slashes = h.slashes || t.slashes, h.href = h.format(), h
  }
  var O = h.pathname && ""/"" === h.pathname.charAt(0), d = t.host || t.pathname && ""/"" === t.pathname.charAt(0), j = d || O || h.host && t.pathname, q = j, x = h.pathname && h.pathname.split(""/"") || [], A = (m = t.pathname && t.pathname.split(""/"") || [], h.protocol && !y[h.protocol]);
  if (A && (h.hostname = """", h.port = null, h.host && ("""" === x[0] ? x[0] = h.host : x.unshift(h.host)), h.host = """", t.protocol && (t.hostname = null, t.port = null, t.host && ("""" === m[0] ? m[0] = t.host : m.unshift(t.host)), t.host = null), j = j && ("""" === m[0] || """" === x[0])), d) {
    h.host = t.host || """" === t.host ? t.host : h.host, h.hostname = t.hostname || """" === t.hostname ? t.hostname : h.hostname, h.search = t.search, h.query = t.query, x = m;
  } else if (m.length) {
    x || (x = []), x.pop(), x = x.concat(m), h.search = t.search, h.query = t.query;
  } else if (!a.isNullOrUndefined(t.search)) {
    if (A) {
      h.hostname = h.host = x.shift(), (U = !!(h.host && h.host.indexOf(""@"") > 0) && h.host.split(""@"")) && (h.auth = U.shift(), h.host = h.hostname = U.shift());
    }
    return h.search = t.search, h.query = t.query, a.isNull(h.pathname) && a.isNull(h.search) || (h.path = (h.pathname ? h.pathname : """") + (h.search ? h.search : """")), h.href = h.format(), h
  }
  if (!x.length) {
    return h.pathname = null, h.search ? h.path = ""/"" + h.search : h.path = null, h.href = h.format(), h;
  }
  for (var C = x.slice(-1)[0], I = (h.host || t.host || x.length > 1) && (""."" === C || "".."" === C) || """" === C, w = 0, N = x.length; N >= 0; N--) {
    ""."" === (C = x[N]) ? x.splice(N, 1) : "".."" === C ? (x.splice(N, 1), w++) : w && (x.splice(N, 1), w--);
  } if (!j && !q) {
    for (; w--; w) { x.unshift(""..""); }
  }
  !j || """" === x[0] || x[0] && ""/"" === x[0].charAt(0) || x.unshift(""""), I && ""/"" !== x.join(""/"").substr(-1) && x.push("""");
  var U, k = """" === x[0] || x[0] && ""/"" === x[0].charAt(0);
  A && (h.hostname = h.host = k ? """" : x.length ? x.shift() : """", (U = !!(h.host && h.host.indexOf(""@"") > 0) && h.host.split(""@"")) && (h.auth = U.shift(), h.host = h.hostname = U.shift()));
  return (j = j || h.host && x.length) && !k && x.unshift(""""), x.length ? h.pathname = x.join(""/"") : (h.pathname = null, h.path = null), a.isNull(h.pathname) && a.isNull(h.search) || (h.path = (h.pathname ? h.pathname : """") + (h.search ? h.search : """")), h.auth = t.auth || h.auth, h.slashes = h.slashes || t.slashes, h.href = h.format(), h
}
r.prototype.parseHost = function () {
  var t = this.host, s = n.exec(t); s && ("":"" !== (s = s[0]) && (this.port = s.substr(1)), t = t.substr(0, t.length - s.length)), t && (this.hostname = t);
};

h.Url; h.format; h.resolve; h.resolveObject;

var exports = {},
  _dewExec = false;
function dew() {
  if (_dewExec) { return exports; }
  _dewExec = true;

  function assertPath(path) {
    if (typeof path !== ""string"") {
      throw new TypeError(""Path must be a string. Received "" + JSON.stringify(path));
    }
  } // Resolves . and .. elements in a path with directory names


  function normalizeStringPosix(path, allowAboveRoot) {
    var res = """";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;

    for (var i = 0; i <= path.length; ++i) {
      if (i < path.length) { code = path.charCodeAt(i); } else if (code === 47
        /*/*/
      ) { break; } else {
        code = 47
          /*/*/
          ;
      }

      if (code === 47
        /*/*/
      ) {
        if (lastSlash === i - 1 || dots === 1); else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46
            /*.*/
            || res.charCodeAt(res.length - 2) !== 46
            /*.*/
          ) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf(""/"");

              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = """";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf(""/"");
                }

                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = """";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }

          if (allowAboveRoot) {
            if (res.length > 0) { res += ""/..""; } else { res = ""..""; }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) { res += ""/"" + path.slice(lastSlash + 1, i); } else { res = path.slice(lastSlash + 1, i); }
          lastSegmentLength = i - lastSlash - 1;
        }

        lastSlash = i;
        dots = 0;
      } else if (code === 46
        /*.*/
        && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }

    return res;
  }

  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || """") + (pathObject.ext || """");

    if (!dir) {
      return base;
    }

    if (dir === pathObject.root) {
      return dir + base;
    }

    return dir + sep + base;
  }

  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
      var arguments$1 = arguments;

      var resolvedPath = """";
      var resolvedAbsolute = false;
      var cwd;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path;
        if (i >= 0) { path = arguments$1[i]; } else {
          if (cwd === undefined) { cwd = process.cwd(); }
          path = cwd;
        }
        assertPath(path); // Skip empty entries

        if (path.length === 0) {
          continue;
        }

        resolvedPath = path + ""/"" + resolvedPath;
        resolvedAbsolute = path.charCodeAt(0) === 47
          /*/*/
          ;
      } // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path


      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) { return ""/"" + resolvedPath; } else { return ""/""; }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ""."";
      }
    },
    normalize: function normalize(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var isAbsolute = path.charCodeAt(0) === 47
        /*/*/
        ;
      var trailingSeparator = path.charCodeAt(path.length - 1) === 47
        /*/*/
        ; // Normalize the path

      path = normalizeStringPosix(path, !isAbsolute);
      if (path.length === 0 && !isAbsolute) { path = "".""; }
      if (path.length > 0 && trailingSeparator) { path += ""/""; }
      if (isAbsolute) { return ""/"" + path; }
      return path;
    },
    isAbsolute: function isAbsolute(path) {
      assertPath(path);
      return path.length > 0 && path.charCodeAt(0) === 47
        /*/*/
        ;
    },
    join: function join() {
      var arguments$1 = arguments;

      if (arguments.length === 0) { return "".""; }
      var joined;

      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments$1[i];
        assertPath(arg);

        if (arg.length > 0) {
          if (joined === undefined) { joined = arg; } else { joined += ""/"" + arg; }
        }
      }

      if (joined === undefined) { return "".""; }
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) { return """"; }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) { return """"; } // Trim any leading backslashes

      var fromStart = 1;

      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47
          /*/*/
        ) { break; }
      }

      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart; // Trim any leading backslashes

      var toStart = 1;

      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47
          /*/*/
        ) { break; }
      }

      var toEnd = to.length;
      var toLen = toEnd - toStart; // Compare paths to find the longest common path from root

      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;

      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47
              /*/*/
            ) {
              // We get here if `from` is the exact base path for `to`.
              // For example: from='/foo/bar'; to='/foo/bar/baz'
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              // We get here if `from` is the root
              // For example: from='/'; to='/foo'
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47
              /*/*/
            ) {
              // We get here if `to` is the exact base path for `from`.
              // For example: from='/foo/bar/baz'; to='/foo/bar'
              lastCommonSep = i;
            } else if (i === 0) {
              // We get here if `to` is the root.
              // For example: from='/foo'; to='/'
              lastCommonSep = 0;
            }
          }

          break;
        }

        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) { break; } else if (fromCode === 47
          /*/*/
        ) { lastCommonSep = i; }
      }

      var out = """"; // Generate the relative path based on the path difference between `to`
      // and `from`

      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47
          /*/*/
        ) {
          if (out.length === 0) { out += ""..""; } else { out += ""/..""; }
        }
      } // Lastly, append the rest of the destination (`to`) path that comes after
      // the common path parts


      if (out.length > 0) { return out + to.slice(toStart + lastCommonSep); } else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47
          /*/*/
        ) { ++toStart; }
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path) {
      return path;
    },
    dirname: function dirname(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var code = path.charCodeAt(0);
      var hasRoot = code === 47
        /*/*/
        ;
      var end = -1;
      var matchedSlash = true;

      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);

        if (code === 47
          /*/*/
        ) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }

      if (end === -1) { return hasRoot ? ""/"" : "".""; }
      if (hasRoot && end === 1) { return ""//""; }
      return path.slice(0, end);
    },
    basename: function basename(path, ext) {
      if (ext !== undefined && typeof ext !== ""string"") { throw new TypeError(""\""ext\"" argument must be a string""); }
      assertPath(path);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;

      if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) { return """"; }
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;

        for (i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);

          if (code === 47
            /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              // We saw the first non-path separator, remember this index in case
              // we need it if the extension ends up not matching
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }

            if (extIdx >= 0) {
              // Try to match the explicit extension
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  // We matched the extension, so mark this as the end of our path
                  // component
                  end = i;
                }
              } else {
                // Extension does not match, so our result is the entire path
                // component
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }

        if (start === end) { end = firstNonSlashEnd; } else if (end === -1) { end = path.length; }
        return path.slice(start, end);
      } else {
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === 47
            /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // path component
            matchedSlash = false;
            end = i + 1;
          }
        }

        if (end === -1) { return """"; }
        return path.slice(start, end);
      }
    },
    extname: function extname(path) {
      assertPath(path);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0;

      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);

        if (code === 47
          /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
          /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; } else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return """";
      }

      return path.slice(startDot, end);
    },
    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== ""object"") {
        throw new TypeError(""The \""pathObject\"" argument must be of type Object. Received type "" + typeof pathObject);
      }

      return _format(""/"", pathObject);
    },
    parse: function parse(path) {
      assertPath(path);
      var ret = {
        root: """",
        dir: """",
        base: """",
        ext: """",
        name: """"
      };
      if (path.length === 0) { return ret; }
      var code = path.charCodeAt(0);
      var isAbsolute = code === 47
        /*/*/
        ;
      var start;

      if (isAbsolute) {
        ret.root = ""/"";
        start = 1;
      } else {
        start = 0;
      }

      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0; // Get non-dir info

      for (; i >= start; --i) {
        code = path.charCodeAt(i);

        if (code === 47
          /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
          /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; } else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute) { ret.base = ret.name = path.slice(1, end); } else { ret.base = ret.name = path.slice(startPart, end); }
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
        }

        ret.ext = path.slice(startDot, end);
      }

      if (startPart > 0) { ret.dir = path.slice(0, startPart - 1); } else if (isAbsolute) { ret.dir = ""/""; }
      return ret;
    },
    sep: ""/"",
    delimiter: "":"",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports = posix;
  return exports;
}

var path = dew();

// Copyright Joyent, Inc. and other Node contributors.

var processPlatform$1 = ""wasi"";

h.URL = typeof URL !== 'undefined' ? URL : null;
h.pathToFileURL = pathToFileURL$1;
h.fileURLToPath = fileURLToPath$1;

h.Url;
h.format;
h.resolve;
h.resolveObject;

h.URL;

var CHAR_FORWARD_SLASH$1 = 47;
var CHAR_LOWERCASE_A$1 = 97;
var CHAR_LOWERCASE_Z$1 = 122;

var isWindows$1 = processPlatform$1 === 'win32';

var forwardSlashRegEx$1 = /\//g;
var percentRegEx$1 = /%/g;
var backslashRegEx$1 = /\\/g;
var newlineRegEx$1 = /\n/g;
var carriageReturnRegEx$1 = /\r/g;
var tabRegEx$1 = /\t/g;

/**
 * Get fully resolved platform-specific file path from the given URL string/ object
 * @param path The file URL string or URL object to convert to a path
 */
function fileURLToPath$1(path) {
  if (typeof path === ""string"") { path = new URL(path); }
  else if (!(path instanceof URL)) {
    throw new TypeError(
      ""invalid argument path , must be a string or URL""
    );
  }
  if (path.protocol !== ""file:"") {
    throw new TypeError(""invalid url scheme"");
  }
  return isWindows$1 ? getPathFromURLWin$1(path) : getPathFromURLPosix$1(path);
}

function getPathFromURLWin$1(url) {
  var hostname = url.hostname;
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (
        (pathname[n + 1] === ""2"" && third === 102) || // 2f 2F /
        (pathname[n + 1] === ""5"" && third === 99)
      ) {
        // 5c 5C \
        throw new TypeError(
          ""must not include encoded \\ or / characters""
        );
      }
    }
  }

  pathname = pathname.replace(forwardSlashRegEx$1, ""\\"");
  pathname = decodeURIComponent(pathname);
  if (hostname !== """") {
    //TODO add support for punycode encodings
    return (""\\\\"" + hostname + pathname);
  } else {
    // Otherwise, it's a local path that requires a drive letter
    var letter = pathname.codePointAt(1) | 0x20;
    var sep = pathname[2];
    if (
      letter < CHAR_LOWERCASE_A$1 ||
      letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
      sep !== "":""
    ) {
      throw new TypeError(""file url path must be absolute"");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== """") {
    throw new TypeError(""invalid file url hostname"");
  }
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (pathname[n + 1] === ""2"" && third === 102) {
        throw new TypeError(
          ""must not include encoded / characters""
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}

/** Get fully resolved platform-specific File URL from the given file path */
function pathToFileURL$1(filepath) {
  var resolved = path.resolve(filepath);
  // path.resolve strips trailing slashes so we must add them back
  var filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (
    (filePathLast === CHAR_FORWARD_SLASH$1 ||
      (isWindows$1)) &&
    resolved[resolved.length - 1] !== path.sep
  ) {
    resolved += ""/"";
  }
  var outURL = new URL(""file://"");
  if (resolved.includes(""%"")) { resolved = resolved.replace(percentRegEx$1, ""%25""); }
  // In posix, ""/"" is a valid character in paths
  if (resolved.includes(""\\"")) {
    resolved = resolved.replace(backslashRegEx$1, ""%5C"");
  }
  if (resolved.includes(""\n"")) { resolved = resolved.replace(newlineRegEx$1, ""%0A""); }
  if (resolved.includes(""\r"")) {
    resolved = resolved.replace(carriageReturnRegEx$1, ""%0D"");
  }
  if (resolved.includes(""\t"")) { resolved = resolved.replace(tabRegEx$1, ""%09""); }
  outURL.pathname = resolved;
  return outURL;
}

// Copyright Joyent, Inc. and other Node contributors.

var processPlatform = ""wasi"";

h.URL = typeof URL !== 'undefined' ? URL : null;
h.pathToFileURL = pathToFileURL;
h.fileURLToPath = fileURLToPath;

var Url = h.Url;
var format = h.format;
var resolve = h.resolve;
var resolveObject = h.resolveObject;
var parse = h.parse;

var _URL = h.URL;
var CHAR_FORWARD_SLASH = 47;
var CHAR_LOWERCASE_A = 97;
var CHAR_LOWERCASE_Z = 122;

var isWindows = processPlatform === 'win32';

var forwardSlashRegEx = /\//g;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;

/**
 * Get fully resolved platform-specific file path from the given URL string/ object
 * @param path The file URL string or URL object to convert to a path
 */
function fileURLToPath(path) {
  if (typeof path === ""string"") { path = new URL(path); }
  else if (!(path instanceof URL)) {
    throw new TypeError(
      ""invalid argument path , must be a string or URL""
    );
  }
  if (path.protocol !== ""file:"") {
    throw new TypeError(""invalid url scheme"");
  }
  return isWindows ? getPathFromURLWin(path) : getPathFromURLPosix(path);
}

function getPathFromURLWin(url) {
  var hostname = url.hostname;
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (
        (pathname[n + 1] === ""2"" && third === 102) || // 2f 2F /
        (pathname[n + 1] === ""5"" && third === 99)
      ) {
        // 5c 5C \
        throw new TypeError(
          ""must not include encoded \\ or / characters""
        );
      }
    }
  }

  pathname = pathname.replace(forwardSlashRegEx, ""\\"");
  pathname = decodeURIComponent(pathname);
  if (hostname !== """") {
    //TODO add support for punycode encodings
    return (""\\\\"" + hostname + pathname);
  } else {
    // Otherwise, it's a local path that requires a drive letter
    var letter = pathname.codePointAt(1) | 0x20;
    var sep = pathname[2];
    if (
      letter < CHAR_LOWERCASE_A ||
      letter > CHAR_LOWERCASE_Z || // a..z A..Z
      sep !== "":""
    ) {
      throw new TypeError(""file url path must be absolute"");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== """") {
    throw new TypeError(""invalid file url hostname"");
  }
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (pathname[n + 1] === ""2"" && third === 102) {
        throw new TypeError(
          ""must not include encoded / characters""
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}

/** Get fully resolved platform-specific File URL from the given file path */
function pathToFileURL(filepath) {
  var resolved = exports$1.resolve(filepath);
  // path.resolve strips trailing slashes so we must add them back
  var filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (
    (filePathLast === CHAR_FORWARD_SLASH ||
      (isWindows)) &&
    resolved[resolved.length - 1] !== exports$1.sep
  ) {
    resolved += ""/"";
  }
  var outURL = new URL(""file://"");
  if (resolved.includes(""%"")) { resolved = resolved.replace(percentRegEx, ""%25""); }
  // In posix, ""/"" is a valid character in paths
  if (resolved.includes(""\\"")) {
    resolved = resolved.replace(backslashRegEx, ""%5C"");
  }
  if (resolved.includes(""\n"")) { resolved = resolved.replace(newlineRegEx, ""%0A""); }
  if (resolved.includes(""\r"")) {
    resolved = resolved.replace(carriageReturnRegEx, ""%0D"");
  }
  if (resolved.includes(""\t"")) { resolved = resolved.replace(tabRegEx, ""%09""); }
  outURL.pathname = resolved;
  return outURL;
}

export { _URL as URL, Url, h as default, fileURLToPath, format, parse, pathToFileURL, resolve, resolveObject };

```"
"```javascript:example_js\repl.js
/*
 * QuickJS Read Eval Print Loop
 *
 * Copyright (c) 2017-2020 Fabrice Bellard
 * Copyright (c) 2017-2020 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
""use strip"";

import * as std from ""std"";
import * as os from ""os"";
//import * as http from ""http"";

(function(g) {
    /* add 'os' and 'std' bindings */
    g.os = os;
    g.std = std;
//    g.http = http;

    /* close global objects */
    var Object = g.Object;
    var String = g.String;
    var Array = g.Array;
    var Date = g.Date;
    var Math = g.Math;
    var isFinite = g.isFinite;
    var parseFloat = g.parseFloat;

    /* XXX: use preprocessor ? */
    var config_numcalc = (typeof os.open === ""undefined"");
    var has_jscalc = (typeof Fraction === ""function"");
    var has_bignum = (typeof BigFloat === ""function"");

    var colors = {
        none:    ""\x1b[0m"",
        black:   ""\x1b[30m"",
        red:     ""\x1b[31m"",
        green:   ""\x1b[32m"",
        yellow:  ""\x1b[33m"",
        blue:    ""\x1b[34m"",
        magenta: ""\x1b[35m"",
        cyan:    ""\x1b[36m"",
        white:   ""\x1b[37m"",
        gray:    ""\x1b[30;1m"",
        grey:    ""\x1b[30;1m"",
        bright_red:     ""\x1b[31;1m"",
        bright_green:   ""\x1b[32;1m"",
        bright_yellow:  ""\x1b[33;1m"",
        bright_blue:    ""\x1b[34;1m"",
        bright_magenta: ""\x1b[35;1m"",
        bright_cyan:    ""\x1b[36;1m"",
        bright_white:   ""\x1b[37;1m"",
    };

    var styles;
    if (config_numcalc) {
        styles = {
            'default':    'black',
            'comment':    'white',
            'string':     'green',
            'regex':      'cyan',
            'number':     'green',
            'keyword':    'blue',
            'function':   'gray',
            'type':       'bright_magenta',
            'identifier': 'yellow',
            'error':      'bright_red',
            'result':     'black',
            'error_msg':  'bright_red',
        };
    } else {
        styles = {
            'default':    'bright_green',
            'comment':    'white',
            'string':     'bright_cyan',
            'regex':      'cyan',
            'number':     'green',
            'keyword':    'bright_white',
            'function':   'bright_yellow',
            'type':       'bright_magenta',
            'identifier': 'bright_green',
            'error':      'red',
            'result':     'bright_white',
            'error_msg':  'bright_red',
        };
    }

    var history = [];
    var clip_board = """";
    var prec;
    var expBits;
    var log2_10;

    var pstate = """";
    var prompt = """";
    var plen = 0;
    var ps1;
    if (config_numcalc)
        ps1 = ""> "";
    else
        ps1 = ""qjs > "";
    var ps2 = ""  ... "";
    var utf8 = true;
    var show_time = false;
    var show_colors = true;
    var eval_time = 0;

    var mexpr = """";
    var level = 0;
    var cmd = """";
    var cursor_pos = 0;
    var last_cmd = """";
    var last_cursor_pos = 0;
    var history_index;
    var this_fun, last_fun;
    var quote_flag = false;

    var utf8_state = 0;
    var utf8_val = 0;

    var term_fd;
    var term_read_buf;
    var term_width;
    /* current X position of the cursor in the terminal */
    var term_cursor_x = 0;

    function termInit() {
        var tab;
        term_fd = std.in.fileno();

        /* get the terminal size */
        term_width = 80;
        if (os.isatty(term_fd)) {
            if (os.ttyGetWinSize) {
                tab = os.ttyGetWinSize(term_fd);
                if (tab)
                    term_width = tab[0];
            }
            if (os.ttySetRaw) {
                /* set the TTY to raw mode */
                os.ttySetRaw(term_fd);
            }
        }

        /* install a Ctrl-C signal handler */
        os.signal(os.SIGINT, sigint_handler);

        /* install a handler to read stdin */
        term_read_buf = new Uint8Array(64);
        os.setReadHandler(term_fd, term_read_handler);
    }

    function sigint_handler() {
        /* send Ctrl-C to readline */
        handle_byte(3);
    }

    function term_read_handler() {
        var l, i;
        l = os.read(term_fd, term_read_buf.buffer, 0, term_read_buf.length);
        for(i = 0; i < l; i++)
            handle_byte(term_read_buf[i]);
    }

    function handle_byte(c) {
        if (!utf8) {
            handle_char(c);
        } else if (utf8_state !== 0 && (c >= 0x80 && c < 0xc0)) {
            utf8_val = (utf8_val << 6) | (c & 0x3F);
            utf8_state--;
            if (utf8_state === 0) {
                handle_char(utf8_val);
            }
        } else if (c >= 0xc0 && c < 0xf8) {
            utf8_state = 1 + (c >= 0xe0) + (c >= 0xf0);
            utf8_val = c & ((1 << (6 - utf8_state)) - 1);
        } else {
            utf8_state = 0;
            handle_char(c);
        }
    }

    function is_alpha(c) {
        return typeof c === ""string"" &&
            ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
    }

    function is_digit(c) {
        return typeof c === ""string"" && (c >= '0' && c <= '9');
    }

    function is_word(c) {
        return typeof c === ""string"" &&
            (is_alpha(c) || is_digit(c) || c == '_' || c == '$');
    }

    function ucs_length(str) {
        var len, c, i, str_len = str.length;
        len = 0;
        /* we never count the trailing surrogate to have the
         following property: ucs_length(str) =
         ucs_length(str.substring(0, a)) + ucs_length(str.substring(a,
         str.length)) for 0 <= a <= str.length */
        for(i = 0; i < str_len; i++) {
            c = str.charCodeAt(i);
            if (c < 0xdc00 || c >= 0xe000)
                len++;
        }
        return len;
    }

    function is_trailing_surrogate(c)  {
        var d;
        if (typeof c !== ""string"")
            return false;
        d = c.codePointAt(0); /* can be NaN if empty string */
        return d >= 0xdc00 && d < 0xe000;
    }

    function is_balanced(a, b) {
        switch (a + b) {
        case ""()"":
        case ""[]"":
        case ""{}"":
            return true;
        }
        return false;
    }

    function print_color_text(str, start, style_names) {
        var i, j;
        for (j = start; j < str.length;) {
            var style = style_names[i = j];
            while (++j < str.length && style_names[j] == style)
                continue;
            std.puts(colors[styles[style] || 'default']);
            std.puts(str.substring(i, j));
            std.puts(colors['none']);
        }
    }

    function print_csi(n, code) {
        std.puts(""\x1b["" + ((n != 1) ? n : """") + code);
    }

    /* XXX: handle double-width characters */
    function move_cursor(delta) {
        var i, l;
        if (delta > 0) {
            while (delta != 0) {
                if (term_cursor_x == (term_width - 1)) {
                    std.puts(""\n""); /* translated to CRLF */
                    term_cursor_x = 0;
                    delta--;
                } else {
                    l = Math.min(term_width - 1 - term_cursor_x, delta);
                    print_csi(l, ""C""); /* right */
                    delta -= l;
                    term_cursor_x += l;
                }
            }
        } else {
            delta = -delta;
            while (delta != 0) {
                if (term_cursor_x == 0) {
                    print_csi(1, ""A""); /* up */
                    print_csi(term_width - 1, ""C""); /* right */
                    delta--;
                    term_cursor_x = term_width - 1;
                } else {
                    l = Math.min(delta, term_cursor_x);
                    print_csi(l, ""D""); /* left */
                    delta -= l;
                    term_cursor_x -= l;
                }
            }
        }
    }

    function update() {
        var i, cmd_len;
        /* cursor_pos is the position in 16 bit characters inside the
           UTF-16 string 'cmd' */
        if (cmd != last_cmd) {
            if (!show_colors && last_cmd.substring(0, last_cursor_pos) == cmd.substring(0, last_cursor_pos)) {
                /* optimize common case */
                std.puts(cmd.substring(last_cursor_pos));
            } else {
                /* goto the start of the line */
                move_cursor(-ucs_length(last_cmd.substring(0, last_cursor_pos)));
                if (show_colors) {
                    var str = mexpr ? mexpr + '\n' + cmd : cmd;
                    var start = str.length - cmd.length;
                    var colorstate = colorize_js(str);
                    print_color_text(str, start, colorstate[2]);
                } else {
                    std.puts(cmd);
                }
            }
            term_cursor_x = (term_cursor_x + ucs_length(cmd)) % term_width;
            if (term_cursor_x == 0) {
                /* show the cursor on the next line */
                std.puts("" \x08"");
            }
            /* remove the trailing characters */
            std.puts(""\x1b[J"");
            last_cmd = cmd;
            last_cursor_pos = cmd.length;
        }
        if (cursor_pos > last_cursor_pos) {
            move_cursor(ucs_length(cmd.substring(last_cursor_pos, cursor_pos)));
        } else if (cursor_pos < last_cursor_pos) {
            move_cursor(-ucs_length(cmd.substring(cursor_pos, last_cursor_pos)));
        }
        last_cursor_pos = cursor_pos;
        std.out.flush();
    }

    /* editing commands */
    function insert(str) {
        if (str) {
            cmd = cmd.substring(0, cursor_pos) + str + cmd.substring(cursor_pos);
            cursor_pos += str.length;
        }
    }

    function quoted_insert() {
        quote_flag = true;
    }

    function abort() {
        cmd = """";
        cursor_pos = 0;
        return -2;
    }

    function alert() {
    }

    function beginning_of_line() {
        cursor_pos = 0;
    }

    function end_of_line() {
        cursor_pos = cmd.length;
    }

    function forward_char() {
        if (cursor_pos < cmd.length) {
            cursor_pos++;
            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))
                cursor_pos++;
        }
    }

    function backward_char() {
        if (cursor_pos > 0) {
            cursor_pos--;
            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))
                cursor_pos--;
        }
    }

    function skip_word_forward(pos) {
        while (pos < cmd.length && !is_word(cmd.charAt(pos)))
            pos++;
        while (pos < cmd.length && is_word(cmd.charAt(pos)))
            pos++;
        return pos;
    }

    function skip_word_backward(pos) {
        while (pos > 0 && !is_word(cmd.charAt(pos - 1)))
            pos--;
        while (pos > 0 && is_word(cmd.charAt(pos - 1)))
            pos--;
        return pos;
    }

    function forward_word() {
        cursor_pos = skip_word_forward(cursor_pos);
    }

    function backward_word() {
        cursor_pos = skip_word_backward(cursor_pos);
    }

    function accept_line() {
        std.puts(""\n"");
        history_add(cmd);
        return -1;
    }

    function history_add(str) {
        if (str) {
            history.push(str);
        }
        history_index = history.length;
    }

    function previous_history() {
        if (history_index > 0) {
            if (history_index == history.length) {
                history.push(cmd);
            }
            history_index--;
            cmd = history[history_index];
            cursor_pos = cmd.length;
        }
    }

    function next_history() {
        if (history_index < history.length - 1) {
            history_index++;
            cmd = history[history_index];
            cursor_pos = cmd.length;
        }
    }

    function history_search(dir) {
        var pos = cursor_pos;
        for (var i = 1; i <= history.length; i++) {
            var index = (history.length + i * dir + history_index) % history.length;
            if (history[index].substring(0, pos) == cmd.substring(0, pos)) {
                history_index = index;
                cmd = history[index];
                return;
            }
        }
    }

    function history_search_backward() {
        return history_search(-1);
    }

    function history_search_forward() {
        return history_search(1);
    }

    function delete_char_dir(dir) {
        var start, end;

        start = cursor_pos;
        if (dir < 0) {
            start--;
            while (is_trailing_surrogate(cmd.charAt(start)))
                start--;
        }
        end = start + 1;
        while (is_trailing_surrogate(cmd.charAt(end)))
            end++;

        if (start >= 0 && start < cmd.length) {
            if (last_fun === kill_region) {
                kill_region(start, end, dir);
            } else {
                cmd = cmd.substring(0, start) + cmd.substring(end);
                cursor_pos = start;
            }
        }
    }

    function delete_char() {
        delete_char_dir(1);
    }

    function control_d() {
        if (cmd.length == 0) {
            std.puts(""\n"");
            return -3; /* exit read eval print loop */
        } else {
            delete_char_dir(1);
        }
    }

    function backward_delete_char() {
        delete_char_dir(-1);
    }

    function transpose_chars() {
        var pos = cursor_pos;
        if (cmd.length > 1 && pos > 0) {
            if (pos == cmd.length)
                pos--;
            cmd = cmd.substring(0, pos - 1) + cmd.substring(pos, pos + 1) +
                cmd.substring(pos - 1, pos) + cmd.substring(pos + 1);
            cursor_pos = pos + 1;
        }
    }

    function transpose_words() {
        var p1 = skip_word_backward(cursor_pos);
        var p2 = skip_word_forward(p1);
        var p4 = skip_word_forward(cursor_pos);
        var p3 = skip_word_backward(p4);

        if (p1 < p2 && p2 <= cursor_pos && cursor_pos <= p3 && p3 < p4) {
            cmd = cmd.substring(0, p1) + cmd.substring(p3, p4) +
            cmd.substring(p2, p3) + cmd.substring(p1, p2);
            cursor_pos = p4;
        }
    }

    function upcase_word() {
        var end = skip_word_forward(cursor_pos);
        cmd = cmd.substring(0, cursor_pos) +
            cmd.substring(cursor_pos, end).toUpperCase() +
            cmd.substring(end);
    }

    function downcase_word() {
        var end = skip_word_forward(cursor_pos);
        cmd = cmd.substring(0, cursor_pos) +
            cmd.substring(cursor_pos, end).toLowerCase() +
            cmd.substring(end);
    }

    function kill_region(start, end, dir) {
        var s = cmd.substring(start, end);
        if (last_fun !== kill_region)
            clip_board = s;
        else if (dir < 0)
            clip_board = s + clip_board;
        else
            clip_board = clip_board + s;

        cmd = cmd.substring(0, start) + cmd.substring(end);
        if (cursor_pos > end)
            cursor_pos -= end - start;
        else if (cursor_pos > start)
            cursor_pos = start;
        this_fun = kill_region;
    }

    function kill_line() {
        kill_region(cursor_pos, cmd.length, 1);
    }

    function backward_kill_line() {
        kill_region(0, cursor_pos, -1);
    }

    function kill_word() {
        kill_region(cursor_pos, skip_word_forward(cursor_pos), 1);
    }

    function backward_kill_word() {
        kill_region(skip_word_backward(cursor_pos), cursor_pos, -1);
    }

    function yank() {
        insert(clip_board);
    }

    function control_c() {
        if (last_fun === control_c) {
            std.puts(""\n"");
            std.exit(0);
        } else {
            std.puts(""\n(Press Ctrl-C again to quit)\n"");
            readline_print_prompt();
        }
    }

    function reset() {
        cmd = """";
        cursor_pos = 0;
    }

    function get_context_word(line, pos) {
        var s = """";
        while (pos > 0 && is_word(line[pos - 1])) {
            pos--;
            s = line[pos] + s;
        }
        return s;
    }
    function get_context_object(line, pos) {
        var obj, base, c;
        if (pos <= 0 || "" ~!%^&*(-+={[|:;,<>?/"".indexOf(line[pos - 1]) >= 0)
            return g;
        if (pos >= 2 && line[pos - 1] === ""."") {
            pos--;
            obj = {};
            switch (c = line[pos - 1]) {
            case '\'':
            case '\""':
                return ""a"";
            case ']':
                return [];
            case '}':
                return {};
            case '/':
                return / /;
            default:
                if (is_word(c)) {
                    base = get_context_word(line, pos);
                    if ([""true"", ""false"", ""null"", ""this""].includes(base) || !isNaN(+base))
                        return eval(base);
                    obj = get_context_object(line, pos - base.length);
                    if (obj === null || obj === void 0)
                        return obj;
                    if (obj === g && obj[base] === void 0)
                        return eval(base);
                    else
                        return obj[base];
                }
                return {};
            }
        }
        return void 0;
    }

    function get_completions(line, pos) {
        var s, obj, ctx_obj, r, i, j, paren;

        s = get_context_word(line, pos);
        ctx_obj = get_context_object(line, pos - s.length);
        r = [];
        /* enumerate properties from object and its prototype chain,
           add non-numeric regular properties with s as e prefix
         */
        for (i = 0, obj = ctx_obj; i < 10 && obj !== null && obj !== void 0; i++) {
            var props = Object.getOwnPropertyNames(obj);
            /* add non-numeric regular properties */
            for (j = 0; j < props.length; j++) {
                var prop = props[j];
                if (typeof prop == ""string"" && """"+(+prop) != prop && prop.startsWith(s))
                    r.push(prop);
            }
            obj = Object.getPrototypeOf(obj);
        }
        if (r.length > 1) {
            /* sort list with internal names last and remove duplicates */
            function symcmp(a, b) {
                if (a[0] != b[0]) {
                    if (a[0] == '_')
                        return 1;
                    if (b[0] == '_')
                        return -1;
                }
                if (a < b)
                    return -1;
                if (a > b)
                    return +1;
                return 0;
            }
            r.sort(symcmp);
            for(i = j = 1; i < r.length; i++) {
                if (r[i] != r[i - 1])
                    r[j++] = r[i];
            }
            r.length = j;
        }
        /* 'tab' = list of completions, 'pos' = cursor position inside
           the completions */
        return { tab: r, pos: s.length, ctx: ctx_obj };
    }

    function completion() {
        var tab, res, s, i, j, len, t, max_width, col, n_cols, row, n_rows;
        res = get_completions(cmd, cursor_pos);
        tab = res.tab;
        if (tab.length === 0)
            return;
        s = tab[0];
        len = s.length;
        /* add the chars which are identical in all the completions */
        for(i = 1; i < tab.length; i++) {
            t = tab[i];
            for(j = 0; j < len; j++) {
                if (t[j] !== s[j]) {
                    len = j;
                    break;
                }
            }
        }
        for(i = res.pos; i < len; i++) {
            insert(s[i]);
        }
        if (last_fun === completion && tab.length == 1) {
            /* append parentheses to function names */
            var m = res.ctx[tab[0]];
            if (typeof m == ""function"") {
                insert('(');
                if (m.length == 0)
                    insert(')');
            } else if (typeof m == ""object"") {
                insert('.');
            }
        }
        /* show the possible completions */
        if (last_fun === completion && tab.length >= 2) {
            max_width = 0;
            for(i = 0; i < tab.length; i++)
                max_width = Math.max(max_width, tab[i].length);
            max_width += 2;
            n_cols = Math.max(1, Math.floor((term_width + 1) / max_width));
            n_rows = Math.ceil(tab.length / n_cols);
            std.puts(""\n"");
            /* display the sorted list column-wise */
            for (row = 0; row < n_rows; row++) {
                for (col = 0; col < n_cols; col++) {
                    i = col * n_rows + row;
                    if (i >= tab.length)
                        break;
                    s = tab[i];
                    if (col != n_cols - 1)
                        s = s.padEnd(max_width);
                    std.puts(s);
                }
                std.puts(""\n"");
            }
            /* show a new prompt */
            readline_print_prompt();
        }
    }

    var commands = {        /* command table */
        ""\x01"":     beginning_of_line,      /* ^A - bol */
        ""\x02"":     backward_char,          /* ^B - backward-char */
        ""\x03"":     control_c,              /* ^C - abort */
        ""\x04"":     control_d,              /* ^D - delete-char or exit */
        ""\x05"":     end_of_line,            /* ^E - eol */
        ""\x06"":     forward_char,           /* ^F - forward-char */
        ""\x07"":     abort,                  /* ^G - bell */
        ""\x08"":     backward_delete_char,   /* ^H - backspace */
        ""\x09"":     completion,             /* ^I - history-search-backward */
        ""\x0a"":     accept_line,            /* ^J - newline */
        ""\x0b"":     kill_line,              /* ^K - delete to end of line */
        ""\x0d"":     accept_line,            /* ^M - enter */
        ""\x0e"":     next_history,           /* ^N - down */
        ""\x10"":     previous_history,       /* ^P - up */
        ""\x11"":     quoted_insert,          /* ^Q - quoted-insert */
        ""\x12"":     alert,                  /* ^R - reverse-search */
        ""\x13"":     alert,                  /* ^S - search */
        ""\x14"":     transpose_chars,        /* ^T - transpose */
        ""\x18"":     reset,                  /* ^X - cancel */
        ""\x19"":     yank,                   /* ^Y - yank */
        ""\x1bOA"":   previous_history,       /* ^[OA - up */
        ""\x1bOB"":   next_history,           /* ^[OB - down */
        ""\x1bOC"":   forward_char,           /* ^[OC - right */
        ""\x1bOD"":   backward_char,          /* ^[OD - left */
        ""\x1bOF"":   forward_word,           /* ^[OF - ctrl-right */
        ""\x1bOH"":   backward_word,          /* ^[OH - ctrl-left */
        ""\x1b[1;5C"": forward_word,          /* ^[[1;5C - ctrl-right */
        ""\x1b[1;5D"": backward_word,         /* ^[[1;5D - ctrl-left */
        ""\x1b[1~"":  beginning_of_line,      /* ^[[1~ - bol */
        ""\x1b[3~"":  delete_char,            /* ^[[3~ - delete */
        ""\x1b[4~"":  end_of_line,            /* ^[[4~ - eol */
        ""\x1b[5~"":  history_search_backward,/* ^[[5~ - page up */
        ""\x1b[6~"":  history_search_forward, /* ^[[5~ - page down */
        ""\x1b[A"":   previous_history,       /* ^[[A - up */
        ""\x1b[B"":   next_history,           /* ^[[B - down */
        ""\x1b[C"":   forward_char,           /* ^[[C - right */
        ""\x1b[D"":   backward_char,          /* ^[[D - left */
        ""\x1b[F"":   end_of_line,            /* ^[[F - end */
        ""\x1b[H"":   beginning_of_line,      /* ^[[H - home */
        ""\x1b\x7f"": backward_kill_word,     /* M-C-? - backward_kill_word */
        ""\x1bb"":    backward_word,          /* M-b - backward_word */
        ""\x1bd"":    kill_word,              /* M-d - kill_word */
        ""\x1bf"":    forward_word,           /* M-f - backward_word */
        ""\x1bk"":    backward_kill_line,     /* M-k - backward_kill_line */
        ""\x1bl"":    downcase_word,          /* M-l - downcase_word */
        ""\x1bt"":    transpose_words,        /* M-t - transpose_words */
        ""\x1bu"":    upcase_word,            /* M-u - upcase_word */
        ""\x7f"":     backward_delete_char,   /* ^? - delete */
    };

    function dupstr(str, count) {
        var res = """";
        while (count-- > 0)
            res += str;
        return res;
    }

    var readline_keys;
    var readline_state;
    var readline_cb;

    function readline_print_prompt()
    {
        std.puts(prompt);
        term_cursor_x = ucs_length(prompt) % term_width;
        last_cmd = """";
        last_cursor_pos = 0;
    }

    function readline_start(defstr, cb) {
        cmd = defstr || """";
        cursor_pos = cmd.length;
        history_index = history.length;
        readline_cb = cb;

        prompt = pstate;

        if (mexpr) {
            prompt += dupstr("" "", plen - prompt.length);
            prompt += ps2;
        } else {
            if (show_time) {
                var t = Math.round(eval_time) + "" "";
                eval_time = 0;
                t = dupstr(""0"", 5 - t.length) + t;
                prompt += t.substring(0, t.length - 4) + ""."" + t.substring(t.length - 4);
            }
            plen = prompt.length;
            prompt += ps1;
        }
        readline_print_prompt();
        update();
        readline_state = 0;
    }

    function handle_char(c1) {
        var c;
        c = String.fromCodePoint(c1);
        switch(readline_state) {
        case 0:
            if (c == '\x1b') {  /* '^[' - ESC */
                readline_keys = c;
                readline_state = 1;
            } else {
                handle_key(c);
            }
            break;
        case 1: /* '^[ */
            readline_keys += c;
            if (c == '[') {
                readline_state = 2;
            } else if (c == 'O') {
                readline_state = 3;
            } else {
                handle_key(readline_keys);
                readline_state = 0;
            }
            break;
        case 2: /* '^[[' - CSI */
            readline_keys += c;
            if (!(c == ';' || (c >= '0' && c <= '9'))) {
                handle_key(readline_keys);
                readline_state = 0;
            }
            break;
        case 3: /* '^[O' - ESC2 */
            readline_keys += c;
            handle_key(readline_keys);
            readline_state = 0;
            break;
        }
    }

    function handle_key(keys) {
        var fun;

        if (quote_flag) {
            if (ucs_length(keys) === 1)
                insert(keys);
            quote_flag = false;
        } else if (fun = commands[keys]) {
            this_fun = fun;
            switch (fun(keys)) {
            case -1:
                readline_cb(cmd);
                return;
            case -2:
                readline_cb(null);
                return;
            case -3:
                /* uninstall a Ctrl-C signal handler */
                os.signal(os.SIGINT, null);
                /* uninstall the stdin read handler */
                os.setReadHandler(term_fd, null);
                return;
            }
            last_fun = this_fun;
        } else if (ucs_length(keys) === 1 && keys >= ' ') {
            insert(keys);
            last_fun = insert;
        } else {
            alert(); /* beep! */
        }

        cursor_pos = (cursor_pos < 0) ? 0 :
            (cursor_pos > cmd.length) ? cmd.length : cursor_pos;
        update();
    }

    var hex_mode = false;
    var eval_mode = ""std"";

    function number_to_string(a, radix) {
        var s;
        if (!isFinite(a)) {
            /* NaN, Infinite */
            return a.toString();
        } else {
            if (a == 0) {
                if (1 / a < 0)
                    s = ""-0"";
                else
                    s = ""0"";
            } else {
                if (radix == 16 && a === Math.floor(a)) {
                    var s;
                    if (a < 0) {
                        a = -a;
                        s = ""-"";
                    } else {
                        s = """";
                    }
                    s += ""0x"" + a.toString(16);
                } else {
                    s = a.toString();
                }
            }
            return s;
        }
    }

    function bigfloat_to_string(a, radix) {
        var s;
        if (!BigFloat.isFinite(a)) {
            /* NaN, Infinite */
            if (eval_mode !== ""math"") {
                return ""BigFloat("" + a.toString() + "")"";
            } else {
                return a.toString();
            }
        } else {
            if (a == 0) {
                if (1 / a < 0)
                    s = ""-0"";
                else
                    s = ""0"";
            } else {
                if (radix == 16) {
                    var s;
                    if (a < 0) {
                        a = -a;
                        s = ""-"";
                    } else {
                        s = """";
                    }
                    s += ""0x"" + a.toString(16);
                } else {
                    s = a.toString();
                }
            }
            if (typeof a === ""bigfloat"" && eval_mode !== ""math"") {
                s += ""l"";
            } else if (eval_mode !== ""std"" && s.indexOf(""."") < 0 &&
                ((radix == 16 && s.indexOf(""p"") < 0) ||
                 (radix == 10 && s.indexOf(""e"") < 0))) {
                /* add a decimal point so that the floating point type
                   is visible */
                s += "".0"";
            }
            return s;
        }
    }

    function bigint_to_string(a, radix) {
        var s;
        if (radix == 16) {
            var s;
            if (a < 0) {
                a = -a;
                s = ""-"";
            } else {
                s = """";
            }
            s += ""0x"" + a.toString(16);
        } else {
            s = a.toString();
        }
        if (eval_mode === ""std"")
            s += ""n"";
        return s;
    }

    function print(a) {
        var stack = [];

        function print_rec(a) {
            var n, i, keys, key, type, s;

            type = typeof(a);
            if (type === ""object"") {
                if (a === null) {
                    std.puts(a);
                } else if (stack.indexOf(a) >= 0) {
                    std.puts(""[circular]"");
                } else if (has_jscalc && (a instanceof Fraction ||
                                        a instanceof Complex ||
                                        a instanceof Mod ||
                                        a instanceof Polynomial ||
                                        a instanceof PolyMod ||
                                        a instanceof RationalFunction ||
                                        a instanceof Series)) {
                    std.puts(a.toString());
                } else {
                    stack.push(a);
                    if (Array.isArray(a)) {
                        n = a.length;
                        std.puts(""[ "");
                        for(i = 0; i < n; i++) {
                            if (i !== 0)
                                std.puts("", "");
                            if (i in a) {
                                print_rec(a[i]);
                            } else {
                                std.puts(""<empty>"");
                            }
                            if (i > 20) {
                                std.puts(""..."");
                                break;
                            }
                        }
                        std.puts("" ]"");
                    } else if (Object.__getClass(a) === ""RegExp"") {
                        std.puts(a.toString());
                    } else {
                        keys = Object.keys(a);
                        n = keys.length;
                        std.puts(""{ "");
                        for(i = 0; i < n; i++) {
                            if (i !== 0)
                                std.puts("", "");
                            key = keys[i];
                            std.puts(key, "": "");
                            print_rec(a[key]);
                        }
                        std.puts("" }"");
                    }
                    stack.pop(a);
                }
            } else if (type === ""string"") {
                s = a.__quote();
                if (s.length > 79)
                    s = s.substring(0, 75) + ""...\"""";
                std.puts(s);
            } else if (type === ""number"") {
                std.puts(number_to_string(a, hex_mode ? 16 : 10));
            } else if (type === ""bigint"") {
                std.puts(bigint_to_string(a, hex_mode ? 16 : 10));
            } else if (type === ""bigfloat"") {
                std.puts(bigfloat_to_string(a, hex_mode ? 16 : 10));
            } else if (type === ""bigdecimal"") {
                std.puts(a.toString() + ""m"");
            } else if (type === ""symbol"") {
                std.puts(String(a));
            } else if (type === ""function"") {
                std.puts(""function "" + a.name + ""()"");
            } else {
                std.puts(a);
            }
        }
        print_rec(a);
    }

    function extract_directive(a) {
        var pos;
        if (a[0] !== '\\')
            return """";
        for (pos = 1; pos < a.length; pos++) {
            if (!is_alpha(a[pos]))
                break;
        }
        return a.substring(1, pos);
    }

    /* return true if the string after cmd can be evaluted as JS */
    function handle_directive(cmd, expr) {
        var param, prec1, expBits1;

        if (cmd === ""h"" || cmd === ""?"" || cmd == ""help"") {
            help();
        } else if (cmd === ""load"") {
            var filename = expr.substring(cmd.length + 1).trim();
            if (filename.lastIndexOf(""."") <= filename.lastIndexOf(""/""))
                filename += "".js"";
            std.loadScript(filename);
            return false;
        } else if (cmd === ""x"") {
            hex_mode = true;
        } else if (cmd === ""d"") {
            hex_mode = false;
        } else if (cmd === ""t"") {
            show_time = !show_time;
        } else if (has_bignum && cmd === ""p"") {
            param = expr.substring(cmd.length + 1).trim().split("" "");
            if (param.length === 1 && param[0] === """") {
                std.puts(""BigFloat precision="" + prec + "" bits (~"" +
                          Math.floor(prec / log2_10) +
                          "" digits), exponent size="" + expBits + "" bits\n"");
            } else if (param[0] === ""f16"") {
                prec = 11;
                expBits = 5;
            } else if (param[0] === ""f32"") {
                prec = 24;
                expBits = 8;
            } else if (param[0] === ""f64"") {
                prec = 53;
                expBits = 11;
            } else if (param[0] === ""f128"") {
                prec = 113;
                expBits = 15;
            } else {
                prec1 = parseInt(param[0]);
                if (param.length >= 2)
                    expBits1 = parseInt(param[1]);
                else
                    expBits1 = BigFloatEnv.expBitsMax;
                if (Number.isNaN(prec1) ||
                    prec1 < BigFloatEnv.precMin ||
                    prec1 > BigFloatEnv.precMax) {
                    std.puts(""Invalid precision\n"");
                    return false;
                }
                if (Number.isNaN(expBits1) ||
                    expBits1 < BigFloatEnv.expBitsMin ||
                    expBits1 > BigFloatEnv.expBitsMax) {
                    std.puts(""Invalid exponent bits\n"");
                    return false;
                }
                prec = prec1;
                expBits = expBits1;
            }
            return false;
        } else if (has_bignum && cmd === ""digits"") {
            param = expr.substring(cmd.length + 1).trim();
            prec1 = Math.ceil(parseFloat(param) * log2_10);
            if (prec1 < BigFloatEnv.precMin ||
                prec1 > BigFloatEnv.precMax) {
                std.puts(""Invalid precision\n"");
                return false;
            }
            prec = prec1;
            expBits = BigFloatEnv.expBitsMax;
            return false;
        } else if (has_bignum && cmd === ""mode"") {
            param = expr.substring(cmd.length + 1).trim();
            if (param === """") {
                std.puts(""Running mode="" + eval_mode + ""\n"");
            } else if (param === ""std"" || param === ""math"") {
                eval_mode = param;
            } else {
                std.puts(""Invalid mode\n"");
            }
            return false;
        } else if (cmd === ""clear"") {
            std.puts(""\x1b[H\x1b[J"");
        } else if (cmd === ""q"") {
            std.exit(0);
        } else if (has_jscalc && cmd === ""a"") {
            algebraicMode = true;
        } else if (has_jscalc && cmd === ""n"") {
            algebraicMode = false;
        } else {
            std.puts(""Unknown directive: "" + cmd + ""\n"");
            return false;
        }
        return true;
    }

    if (config_numcalc) {
        /* called by the GUI */
        g.execCmd = function (cmd) {
            switch(cmd) {
            case ""dec"":
                hex_mode = false;
                break;
            case ""hex"":
                hex_mode = true;
                break;
            case ""num"":
                algebraicMode = false;
                break;
            case ""alg"":
                algebraicMode = true;
                break;
            }
        }
    }

    function help() {
        function sel(n) {
            return n ? ""*"": "" "";
        }
        std.puts(""\\h          this help\n"" +
                 ""\\x         "" + sel(hex_mode) + ""hexadecimal number display\n"" +
                 ""\\d         "" + sel(!hex_mode) + ""decimal number display\n"" +
                 ""\\t         "" + sel(show_time) + ""toggle timing display\n"" +
                  ""\\clear      clear the terminal\n"");
        if (has_jscalc) {
            std.puts(""\\a         "" + sel(algebraicMode) + ""algebraic mode\n"" +
                     ""\\n         "" + sel(!algebraicMode) + ""numeric mode\n"");
        }
        if (has_bignum) {
            std.puts(""\\p [m [e]]  set the BigFloat precision to 'm' bits\n"" +
                     ""\\digits n   set the BigFloat precision to 'ceil(n*log2(10))' bits\n"");
            if (!has_jscalc) {
                std.puts(""\\mode [std|math] change the running mode (current = "" + eval_mode + "")\n"");
            }
        }
        if (!config_numcalc) {
            std.puts(""\\q          exit\n"");
        }
    }

    function eval_and_print(expr) {
        var result;

        try {
            if (eval_mode === ""math"")
                expr = '""use math""; void 0;' + expr;
            var now = (new Date).getTime();
            /* eval as a script */
            result = std.evalScript(expr, { backtrace_barrier: true });
            eval_time = (new Date).getTime() - now;
            std.puts(colors[styles.result]);
            print(result);
            std.puts(""\n"");
            std.puts(colors.none);
            /* set the last result */
            g._ = result;
        } catch (error) {
            std.puts(colors[styles.error_msg]);
            if (error instanceof Error) {
                console.log(error);
                if (error.stack) {
                    std.puts(error.stack);
                }
            } else {
                std.puts(""Throw: "");
                console.log(error);
            }
            std.puts(colors.none);
        }
    }

    function cmd_start() {
        if (!config_numcalc) {
            if (has_jscalc)
                std.puts('QJSCalc - Type ""\\h"" for help\n');
            else
                std.puts('QuickJS - Type ""\\h"" for help\n');
        }
        if (has_bignum) {
            log2_10 = Math.log(10) / Math.log(2);
            prec = 113;
            expBits = 15;
            if (has_jscalc) {
                eval_mode = ""math"";
                /* XXX: numeric mode should always be the default ? */
                g.algebraicMode = config_numcalc;
            }
        }

        cmd_readline_start();
    }

    function cmd_readline_start() {
        readline_start(dupstr(""    "", level), readline_handle_cmd);
    }

    function readline_handle_cmd(expr) {
        handle_cmd(expr);
        cmd_readline_start();
    }

    function handle_cmd(expr) {
        var colorstate, cmd;

        if (expr === null) {
            expr = """";
            return;
        }
        if (expr === ""?"") {
            help();
            return;
        }
        cmd = extract_directive(expr);
        if (cmd.length > 0) {
            if (!handle_directive(cmd, expr))
                return;
            expr = expr.substring(cmd.length + 1);
        }
        if (expr === """")
            return;

        if (mexpr)
            expr = mexpr + '\n' + expr;
        colorstate = colorize_js(expr);
        pstate = colorstate[0];
        level = colorstate[1];
        if (pstate) {
            mexpr = expr;
            return;
        }
        mexpr = """";

        if (has_bignum) {
            BigFloatEnv.setPrec(eval_and_print.bind(null, expr),
                                prec, expBits);
        } else {
            eval_and_print(expr);
        }
        level = 0;

        /* run the garbage collector after each command */
        std.gc();
    }

    function colorize_js(str) {
        var i, c, start, n = str.length;
        var style, state = """", level = 0;
        var primary, can_regex = 1;
        var r = [];

        function push_state(c) { state += c; }
        function last_state(c) { return state.substring(state.length - 1); }
        function pop_state(c) {
            var c = last_state();
            state = state.substring(0, state.length - 1);
            return c;
        }

        function parse_block_comment() {
            style = 'comment';
            push_state('/');
            for (i++; i < n - 1; i++) {
                if (str[i] == '*' && str[i + 1] == '/') {
                    i += 2;
                    pop_state('/');
                    break;
                }
            }
        }

        function parse_line_comment() {
            style = 'comment';
            for (i++; i < n; i++) {
                if (str[i] == '\n') {
                    break;
                }
            }
        }

        function parse_string(delim) {
            style = 'string';
            push_state(delim);
            while (i < n) {
                c = str[i++];
                if (c == '\n') {
                    style = 'error';
                    continue;
                }
                if (c == '\\') {
                    if (i >= n)
                        break;
                    i++;
                } else
                if (c == delim) {
                    pop_state();
                    break;
                }
            }
        }

        function parse_regex() {
            style = 'regex';
            push_state('/');
            while (i < n) {
                c = str[i++];
                if (c == '\n') {
                    style = 'error';
                    continue;
                }
                if (c == '\\') {
                    if (i < n) {
                        i++;
                    }
                    continue;
                }
                if (last_state() == '[') {
                    if (c == ']') {
                        pop_state()
                    }
                    // ECMA 5: ignore '/' inside char classes
                    continue;
                }
                if (c == '[') {
                    push_state('[');
                    if (str[i] == '[' || str[i] == ']')
                        i++;
                    continue;
                }
                if (c == '/') {
                    pop_state();
                    while (i < n && is_word(str[i]))
                        i++;
                    break;
                }
            }
        }

        function parse_number() {
            style = 'number';
            while (i < n && (is_word(str[i]) || (str[i] == '.' && (i == n - 1 || str[i + 1] != '.')))) {
                i++;
            }
        }

        var js_keywords = ""|"" +
            ""break|case|catch|continue|debugger|default|delete|do|"" +
            ""else|finally|for|function|if|in|instanceof|new|"" +
            ""return|switch|this|throw|try|typeof|while|with|"" +
            ""class|const|enum|import|export|extends|super|"" +
            ""implements|interface|let|package|private|protected|"" +
            ""public|static|yield|"" +
            ""undefined|null|true|false|Infinity|NaN|"" +
            ""eval|arguments|"" +
            ""await|"";

        var js_no_regex = ""|this|super|undefined|null|true|false|Infinity|NaN|arguments|"";
        var js_types = ""|void|var|"";

        function parse_identifier() {
            can_regex = 1;

            while (i < n && is_word(str[i]))
                i++;

            var w = '|' + str.substring(start, i) + '|';

            if (js_keywords.indexOf(w) >= 0) {
                style = 'keyword';
                if (js_no_regex.indexOf(w) >= 0)
                    can_regex = 0;
                return;
            }

            var i1 = i;
            while (i1 < n && str[i1] == ' ')
                i1++;

            if (i1 < n && str[i1] == '(') {
                style = 'function';
                return;
            }

            if (js_types.indexOf(w) >= 0) {
                style = 'type';
                return;
            }

            style = 'identifier';
            can_regex = 0;
        }

        function set_style(from, to) {
            while (r.length < from)
                r.push('default');
            while (r.length < to)
                r.push(style);
        }

        for (i = 0; i < n;) {
            style = null;
            start = i;
            switch (c = str[i++]) {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                continue;
            case '+':
            case '-':
                if (i < n && str[i] == c) {
                    i++;
                    continue;
                }
                can_regex = 1;
                continue;
            case '/':
                if (i < n && str[i] == '*') { // block comment
                    parse_block_comment();
                    break;
                }
                if (i < n && str[i] == '/') { // line comment
                    parse_line_comment();
                    break;
                }
                if (can_regex) {
                    parse_regex();
                    can_regex = 0;
                    break;
                }
                can_regex = 1;
                continue;
            case '\'':
            case '\""':
            case '`':
                parse_string(c);
                can_regex = 0;
                break;
            case '(':
            case '[':
            case '{':
                can_regex = 1;
                level++;
                push_state(c);
                continue;
            case ')':
            case ']':
            case '}':
                can_regex = 0;
                if (level > 0 && is_balanced(last_state(), c)) {
                    level--;
                    pop_state();
                    continue;
                }
                style = 'error';
                break;
            default:
                if (is_digit(c)) {
                    parse_number();
                    can_regex = 0;
                    break;
                }
                if (is_word(c) || c == '$') {
                    parse_identifier();
                    break;
                }
                can_regex = 1;
                continue;
            }
            if (style)
                set_style(start, i);
        }
        set_style(n, n);
        return [ state, level, r ];
    }

    termInit();

    cmd_start();

})(globalThis);
```"
"```javascript:modules\internal\streams\readable.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { addAbortSignalNoValidate } from ""./add-abort-signal.js"";
import { Buffer } from ""buffer"";
import { debuglog } from ""../util/debuglog.js"";
import { getDefaultHighWaterMark, getHighWaterMark } from ""./state.js"";
import { prependListener, Stream } from ""./legacy.js"";
import { StringDecoder } from ""string_decoder"";
import { validateObject } from ""../validators.js"";
import {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_PUSH_AFTER_EOF,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
} from ""../errors.js"";
import _from from ""./from.js"";
import BufferList from ""./buffer_list.js"";
import destroyImpl from ""./destroy.js"";
import EE from ""events"";

let debug = debuglog(""stream"", (fn) => {
    debug = fn;
});

const kPaused = Symbol(""kPaused"");

const nop = () => { };

const { errorOrDestroy } = destroyImpl;

function ReadableState(options, stream, isDuplex) {
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== ""boolean"") {
        isDuplex = stream instanceof Stream.Duplex;
    }

    // Object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away.
    this.objectMode = !!(options && options.objectMode);

    if (isDuplex) {
        this.objectMode = this.objectMode ||
            !!(options && options.readableObjectMode);
    }

    // The point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means ""don't call _read preemptively ever""
    this.highWaterMark = options
        ? getHighWaterMark(this, options, ""readableHighWaterMark"", isDuplex)
        : getDefaultHighWaterMark(false);

    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift().
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;

    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    this.constructed = true;

    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until ""later"" should generally also
    // not happen before the first read call.
    this.sync = true;

    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;

    // True if the error was already emitted and should not be thrown again.
    this.errorEmitted = false;

    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = !options || options.emitClose !== false;

    // Should .destroy() be called after 'end' (and potentially 'finish').
    this.autoDestroy = !options || options.autoDestroy !== false;

    // Has it been destroyed.
    this.destroyed = false;

    // Indicates whether the stream has errored. When true no further
    // _read calls, 'data' or 'readable' events should occur. This is needed
    // since when autoDestroy is disabled we need a way to tell whether the
    // stream has failed.
    this.errored = null;

    // Indicates whether the stream has finished destroying.
    this.closed = false;

    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    this.closeEmitted = false;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = (options && options.defaultEncoding) || ""utf8"";

    // Ref the piped dest which we need a drain event on it
    // type: null | Writable | Set<Writable>.
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;

    // If true, a maybeReadMore has been scheduled.
    this.readingMore = false;

    this.dataEmitted = false;

    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}


function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }

    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5.
    const isDuplex = this instanceof Stream.Duplex;

    this._readableState = new ReadableState(options, this, isDuplex);

    if (options) {
        if (typeof options.read === ""function"") {
            this._read = options.read;
        }

        if (typeof options.destroy === ""function"") {
            this._destroy = options.destroy;
        }

        if (typeof options.construct === ""function"") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }

    Stream.call(this, options);

    destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}

Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
    cb(err);
};

Readable.prototype[EE.captureRejectionSymbol] = function (err) {
    this.destroy(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read().
Readable.prototype.unshift = function (chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};

function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug(""readableAddChunk"", chunk);
    const state = stream._readableState;

    let err;
    if (!state.objectMode) {
        if (typeof chunk === ""string"") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
                if (addToFront && state.encoding) {
                    // When unshifting, if state.encoding is set, we have to save
                    // the string in the BufferList with the state encoding.
                    chunk = Buffer.from(chunk, encoding).toString(state.encoding);
                } else {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = """";
                }
            }
        } else if (chunk instanceof Buffer) {
            encoding = """";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = """";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE(
                ""chunk"",
                [""string"", ""Buffer"", ""Uint8Array""],
                chunk,
            );
        }
    }

    if (err) {
        errorOrDestroy(stream, err);
    } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else if (state.objectMode || (chunk && chunk.length > 0)) {
        if (addToFront) {
            if (state.endEmitted) {
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state, chunk, true);
            }
        } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
            return false;
        } else {
            state.reading = false;
            if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) {
                    addChunk(stream, state, chunk, false);
                } else {
                    maybeReadMore(stream, state);
                }
            } else {
                addChunk(stream, state, chunk, false);
            }
        }
    } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
    }

    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended &&
        (state.length < state.highWaterMark || state.length === 0);
}


function addChunk(stream, state, chunk, addToFront) {
    if (
        state.flowing && state.length === 0 && !state.sync &&
        stream.listenerCount(""data"") > 0
    ) {
        // Use the guard to avoid creating `Set()` repeatedly
        // when we have multiple pipes.
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit(""data"", chunk);
    } else {
        // Update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state.buffer.unshift(chunk);
        } else {
            state.buffer.push(chunk);
        }

        if (state.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state);
}

Readable.prototype.isPaused = function () {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
};

// Backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8.
    this._readableState.encoding = this._readableState.decoder.encoding;

    const buffer = this._readableState.buffer;
    // Iterate over current buffer to convert already stored Buffers:
    let content = """";
    for (const data of buffer) {
        content += decoder.write(data);
    }
    buffer.clear();
    if (content !== """") {
        buffer.push(content);
    }
    this._readableState.length = content.length;
    return this;
};

// Don't raise the hwm > 1GB.
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts.
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || (state.length === 0 && state.ended)) {
        return 0;
    }
    if (state.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        // Only flow one buffer at a time.
        if (state.flowing && state.length) {
            return state.buffer.first().length;
        }
        return state.length;
    }
    if (n <= state.length) {
        return n;
    }
    return state.ended ? state.length : 0;
}

// You can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
    debug(""read"", n);
    // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
    // in this scenario, so we are doing it manually.
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;

    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) {
        state.highWaterMark = computeNewHighWaterMark(n);
    }

    if (n !== 0) {
        state.emittedReadable = false;
    }

    // If we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (
        n === 0 &&
        state.needReadable &&
        ((state.highWaterMark !== 0
            ? state.length >= state.highWaterMark
            : state.length > 0) ||
            state.ended)
    ) {
        debug(""read: emitReadable"", state.length, state.ended);
        if (state.length === 0 && state.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }

    n = howMuchToRead(n, state);

    // If we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) {
            endReadable(this);
        }
        return null;
    }

    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.

    // if we need a readable event, then we need to do some reading.
    let doRead = state.needReadable;
    debug(""need readable"", doRead);

    // If we currently have less than the highWaterMark, then also read some.
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug(""length less than watermark"", doRead);
    }

    // However, if we've ended, then there's no point, if we're already
    // reading, then it's unnecessary, if we're constructing we have to wait,
    // and if we're destroyed or errored, then it's not allowed,
    if (
        state.ended || state.reading || state.destroyed || state.errored ||
        !state.constructed
    ) {
        doRead = false;
        debug(""reading, ended or constructing"", doRead);
    } else if (doRead) {
        debug(""do read"");
        state.reading = true;
        state.sync = true;
        // If the length is currently zero, then we *need* a readable event.
        if (state.length === 0) {
            state.needReadable = true;
        }

        // Call internal read method
        this._read(state.highWaterMark);

        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) {
            n = howMuchToRead(nOrig, state);
        }
    }

    let ret;
    if (n > 0) {
        ret = fromList(n, state);
    } else {
        ret = null;
    }

    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
    }

    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) {
            state.needReadable = true;
        }

        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) {
            endReadable(this);
        }
    }

    if (ret !== null) {
        state.dataEmitted = true;
        this.emit(""data"", ret);
    }

    return ret;
};

function onEofChunk(stream, state) {
    debug(""onEofChunk"");
    if (state.ended) return;
    if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;

    if (state.sync) {
        // If we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call.
        emitReadable(stream);
    } else {
        // Emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        state.emittedReadable = true;
        // We have to emit readable now that we are EOF. Modules
        // in the ecosystem (e.g. dicer) rely on this event being sync.
        emitReadable_(stream);
    }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    const state = stream._readableState;
    debug(""emitReadable"", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug(""emitReadable"", state.flowing);
        state.emittedReadable = true;
        nextTick(emitReadable_, stream);
    }
}

function emitReadable_(stream) {
    const state = stream._readableState;
    debug(""emitReadable_"", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit(""readable"");
        state.emittedReadable = false;
    }

    // The stream needs another readable event if:
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing &&
        !state.ended &&
        state.length <= state.highWaterMark;
    flow(stream);
}

// At this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
    }
}

function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (
        !state.reading && !state.ended &&
        (state.length < state.highWaterMark ||
            (state.flowing && state.length === 0))
    ) {
        const len = state.length;
        debug(""maybeReadMore read 0"");
        stream.read(0);
        if (len === state.length) {
            // Didn't get any data, stop spinning.
            break;
        }
    }
    state.readingMore = false;
}

// Abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, ""length"" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED(""_read()"");
};

Readable.prototype.pipe = function (dest, pipeOpts) {
    const src = this;
    const state = this._readableState;

    if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new Set(
                state.awaitDrainWriters ? [state.awaitDrainWriters] : [],
            );
        }
    }

    state.pipes.push(dest);
    debug(""pipe count=%d opts=%j"", state.pipes.length, pipeOpts);

    const doEnd = (!pipeOpts || pipeOpts.end !== false)
    // &&
    // dest !== stdio.stdout &&
    // dest !== stdio.stderr;

    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) {
        nextTick(endFn);
    } else {
        src.once(""end"", endFn);
    }

    dest.on(""unpipe"", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug(""onunpipe"");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }

    function onend() {
        debug(""onend"");
        dest.end();
    }

    let ondrain;

    let cleanedUp = false;
    function cleanup() {
        debug(""cleanup"");
        // Cleanup event handlers once the pipe is broken.
        dest.removeListener(""close"", onclose);
        dest.removeListener(""finish"", onfinish);
        if (ondrain) {
            dest.removeListener(""drain"", ondrain);
        }
        dest.removeListener(""error"", onerror);
        dest.removeListener(""unpipe"", onunpipe);
        src.removeListener(""end"", onend);
        src.removeListener(""end"", unpipe);
        src.removeListener(""data"", ondata);

        cleanedUp = true;

        // If the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (
            ondrain && state.awaitDrainWriters &&
            (!dest._writableState || dest._writableState.needDrain)
        ) {
            ondrain();
        }
    }

    function pause() {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
                debug(""false write response, pause"", 0);
                state.awaitDrainWriters = dest;
                state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
                debug(""false write response, pause"", state.awaitDrainWriters.size);
                state.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            // When the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            ondrain = pipeOnDrain(src, dest);
            dest.on(""drain"", ondrain);
        }
    }

    src.on(""data"", ondata);
    function ondata(chunk) {
        debug(""ondata"");
        const ret = dest.write(chunk);
        debug(""dest.write"", ret);
        if (ret === false) {
            pause();
        }
    }

    // If the dest has an error, then stop piping into it.
    // However, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug(""onerror"", er);
        unpipe();
        dest.removeListener(""error"", onerror);
        if (EE.listenerCount(dest, ""error"") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                // User incorrectly emitted 'error' directly on the stream.
                errorOrDestroy(dest, er);
            } else {
                dest.emit(""error"", er);
            }
        }
    }

    // Make sure our error handler is attached before userland ones.
    prependListener(dest, ""error"", onerror);

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener(""finish"", onfinish);
        unpipe();
    }
    dest.once(""close"", onclose);
    function onfinish() {
        debug(""onfinish"");
        dest.removeListener(""close"", onclose);
        unpipe();
    }
    dest.once(""finish"", onfinish);

    function unpipe() {
        debug(""unpipe"");
        src.unpipe(dest);
    }

    // Tell the dest that it's being piped to.
    dest.emit(""pipe"", src);

    // Start the flow if it hasn't been started already.

    if (dest.writableNeedDrain === true) {
        if (state.flowing) {
            pause();
        }
    } else if (!state.flowing) {
        debug(""pipe resume"");
        src.resume();
    }

    return dest;
};

function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state = src._readableState;

        // `ondrain` will call directly,
        // `this` maybe not a reference to dest,
        // so we use the real dest here.
        if (state.awaitDrainWriters === dest) {
            debug(""pipeOnDrain"", 1);
            state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
            debug(""pipeOnDrain"", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
        }

        if (
            (!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&
            EE.listenerCount(src, ""data"")
        ) {
            state.flowing = true;
            flow(src);
        }
    };
}


Readable.prototype.unpipe = function (dest) {
    const state = this._readableState;
    const unpipeInfo = { hasUnpiped: false };

    // If we're not piping anywhere, then do nothing.
    if (state.pipes.length === 0) {
        return this;
    }

    if (!dest) {
        // remove all.
        const dests = state.pipes;
        state.pipes = [];
        this.pause();

        for (let i = 0; i < dests.length; i++) {
            dests[i].emit(""unpipe"", this, { hasUnpiped: false });
        }
        return this;
    }

    // Try to find the right one.
    const index = state.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }

    state.pipes.splice(index, 1);
    if (state.pipes.length === 0) {
        this.pause();
    }

    dest.emit(""unpipe"", this, unpipeInfo);

    return this;
};

// Set up data events if they are asked for
// Ensure readable listeners eventually get something.
Readable.prototype.on = function (ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;

    if (ev === ""data"") {
        // Update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount(""readable"") > 0;

        // Try start flowing on next tick if stream isn't explicitly paused.
        if (state.flowing !== false) {
            this.resume();
        }
    } else if (ev === ""readable"") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug(""on readable"", state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                nextTick(nReadingNextTick, this);
            }
        }
    }

    return res;
};
Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);

    if (ev === ""readable"") {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        nextTick(updateReadableListening, this);
    }

    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;

Readable.prototype.removeAllListeners = function (ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);

    if (ev === ""readable"" || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        nextTick(updateReadableListening, this);
    }

    return res;
};

function updateReadableListening(self) {
    const state = self._readableState;
    state.readableListening = self.listenerCount(""readable"") > 0;

    if (state.resumeScheduled && state[kPaused] === false) {
        // Flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true;

        // Crude way to check if we should resume.
    } else if (self.listenerCount(""data"") > 0) {
        self.resume();
    } else if (!state.readableListening) {
        state.flowing = null;
    }
}

function nReadingNextTick(self) {
    debug(""readable nexttick read 0"");
    self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
    const state = this._readableState;
    if (!state.flowing) {
        debug(""resume"");
        // We flow only if there is no one listening
        // for readable, but we still have to call
        // resume().
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state[kPaused] = false;
    return this;
};

function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
    }
}

function resume_(stream, state) {
    debug(""resume"", state.reading);
    if (!state.reading) {
        stream.read(0);
    }

    state.resumeScheduled = false;
    stream.emit(""resume"");
    flow(stream);
    if (state.flowing && !state.reading) {
        stream.read(0);
    }
}

Readable.prototype.pause = function () {
    debug(""call pause flowing=%j"", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug(""pause"");
        this._readableState.flowing = false;
        this.emit(""pause"");
    }
    this._readableState[kPaused] = true;
    return this;
};

function flow(stream) {
    const state = stream._readableState;
    debug(""flow"", state.flowing);
    while (state.flowing && stream.read() !== null);
}

// Wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
    let paused = false;

    // TODO (ronag): Should this.destroy(err) emit
    // 'error' on the wrapped stream? Would require
    // a static factory method, e.g. Readable.wrap(stream).

    stream.on(""data"", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });

    stream.on(""end"", () => {
        this.push(null);
    });

    stream.on(""error"", (err) => {
        errorOrDestroy(this, err);
    });

    stream.on(""close"", () => {
        this.destroy();
    });

    stream.on(""destroy"", () => {
        this.destroy();
    });

    this._read = () => {
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };

    // Proxy all the other methods. Important when wrapping filters and duplexes.
    const streamKeys = Object.keys(stream);
    for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === undefined && typeof stream[i] === ""function"") {
            this[i] = stream[i].bind(stream);
        }
    }

    return this;
};

Readable.prototype[Symbol.asyncIterator] = function () {
    return streamToAsyncIterator(this);
};

Readable.prototype.iterator = function (options) {
    if (options !== undefined) {
        validateObject(options, ""options"");
    }
    return streamToAsyncIterator(this, options);
};

function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== ""function"") {
        stream = Readable.wrap(stream, { objectMode: true });
    }

    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}

async function* createAsyncIterator(stream, options) {
    let callback = nop;

    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options,
    };

    function next(resolve) {
        if (this === stream) {
            callback();
            callback = nop;
        } else {
            callback = resolve;
        }
    }

    const state = stream._readableState;

    let error = state.errored;
    let errorEmitted = state.errorEmitted;
    let endEmitted = state.endEmitted;
    let closeEmitted = state.closeEmitted;

    stream
        .on(""readable"", next)
        .on(""error"", function (err) {
            error = err;
            errorEmitted = true;
            next.call(this);
        })
        .on(""end"", function () {
            endEmitted = true;
            next.call(this);
        })
        .on(""close"", function () {
            closeEmitted = true;
            next.call(this);
        });

    let errorThrown = false;
    try {
        while (true) {
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            destroyImpl.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally {
        if (!errorThrown && opts.destroyOnReturn) {
            if (state.autoDestroy || !endEmitted) {
                // TODO(ronag): ERR_PREMATURE_CLOSE?
                destroyImpl.destroyer(stream, null);
            }
        }
    }
}

// Making it explicit these properties are not enumerable
// because otherwise some prototype manipulation in
// userland will fail.
Object.defineProperties(Readable.prototype, {
    readable: {
        get() {
            const r = this._readableState;
            // r.readable === false means that this is part of a Duplex stream
            // where the readable side was disabled upon construction.
            // Compat. The user might manually disable readable side through
            // deprecated setter.
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&
                !r.endEmitted;
        },
        set(val) {
            // Backwards compat.
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        },
    },

    readableDidRead: {
        enumerable: false,
        get: function () {
            return this._readableState.dataEmitted;
        },
    },

    readableAborted: {
        enumerable: false,
        get: function () {
            return !!(this._readableState.destroyed || this._readableState.errored) &&
                !this._readableState.endEmitted;
        },
    },

    readableHighWaterMark: {
        enumerable: false,
        get: function () {
            return this._readableState.highWaterMark;
        },
    },

    readableBuffer: {
        enumerable: false,
        get: function () {
            return this._readableState && this._readableState.buffer;
        },
    },

    readableFlowing: {
        enumerable: false,
        get: function () {
            return this._readableState.flowing;
        },
        set: function (state) {
            if (this._readableState) {
                this._readableState.flowing = state;
            }
        },
    },

    readableLength: {
        enumerable: false,
        get() {
            return this._readableState.length;
        },
    },

    readableObjectMode: {
        enumerable: false,
        get() {
            return this._readableState ? this._readableState.objectMode : false;
        },
    },

    readableEncoding: {
        enumerable: false,
        get() {
            return this._readableState ? this._readableState.encoding : null;
        },
    },

    destroyed: {
        enumerable: false,
        get() {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set(value) {
            // We ignore the value if the stream
            // has not been initialized yet.
            if (!this._readableState) {
                return;
            }

            // Backward compatibility, the user is explicitly
            // managing destroyed.
            this._readableState.destroyed = value;
        },
    },

    readableEnded: {
        enumerable: false,
        get() {
            return this._readableState ? this._readableState.endEmitted : false;
        },
    },
});

Object.defineProperties(ReadableState.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
        get() {
            return this.pipes.length;
        },
    },

    // Legacy property for `paused`.
    paused: {
        get() {
            return this[kPaused] !== false;
        },
        set(value) {
            this[kPaused] = !!value;
        },
    },
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered.
    if (state.length === 0) {
        return null;
    }

    let ret;
    if (state.objectMode) {
        ret = state.buffer.shift();
    } else if (!n || n >= state.length) {
        // Read it all, truncate the list.
        if (state.decoder) {
            ret = state.buffer.join("""");
        } else if (state.buffer.length === 1) {
            ret = state.buffer.first();
        } else {
            ret = state.buffer.concat(state.length);
        }
        state.buffer.clear();
    } else {
        // read part of list.
        ret = state.buffer.consume(n, state.decoder);
    }

    return ret;
}

function endReadable(stream) {
    const state = stream._readableState;

    debug(""endReadable"", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
    }
}

function endReadableNT(state, stream) {
    debug(""endReadableNT"", state.endEmitted, state.length);

    // Check that we didn't get one last unshift.
    if (
        !state.errorEmitted && !state.closeEmitted &&
        !state.endEmitted && state.length === 0
    ) {
        state.endEmitted = true;
        stream.emit(""end"");

        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well.
            const wState = stream._writableState;
            const autoDestroy = !wState || (
                wState.autoDestroy &&
                // We don't expect the writable to ever 'finish'
                // if writable is explicitly set to false.
                (wState.finished || wState.writable === false)
            );

            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}

function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded &&
        !stream.destroyed;
    if (writable) {
        stream.end();
    }
}

function readableFrom(iterable, opts) {
    return _from(Readable, iterable, opts);
}

function wrap(src, options) {
    return new Readable({
        objectMode: src.readableObjectMode ?? src.objectMode ?? true,
        ...options,
        destroy(err, callback) {
            destroyImpl.destroyer(src, err);
            callback(err);
        },
    }).wrap(src);
}

// Exposed for testing purposes only.
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;

export default Readable;
export { fromList as _fromList, readableFrom as from, ReadableState, wrap };
```"

"```javascript:test\assert\test-assert.js
// Flags: --expose-internals
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

const common = require('../common');
const assert = require('assert');
const { inspect } = require('util');
const vm = require('vm');
const { internalBinding } = require('internal/test/binding');
const a = assert;

// Disable colored output to prevent color codes from breaking assertion
// message comparisons. This should only be an issue when process.stdout
// is a TTY.
if (process.stdout.isTTY)
  process.env.NODE_DISABLE_COLORS = '1';

const strictEqualMessageStart = 'Expected values to be strictly equal:\n';
const start = 'Expected values to be strictly deep-equal:';
const actExp = '+ actual - expected';

assert.ok(a.AssertionError.prototype instanceof Error,
          'a.AssertionError instanceof Error');

assert.throws(() => a(false), a.AssertionError, 'ok(false)');
assert.throws(() => a.ok(false), a.AssertionError, 'ok(false)');

// Throw message if the message is instanceof Error.
{
  let threw = false;
  try {
    assert.ok(false, new Error('ok(false)'));
  } catch (e) {
    threw = true;
    assert.ok(e instanceof Error);
  }
  assert.ok(threw, 'Error: ok(false)');
}


a(true);
a('test', 'ok(\'test\')');
a.ok(true);
a.ok('test');

assert.throws(() => a.equal(true, false),
              a.AssertionError, 'equal(true, false)');

a.equal(null, null);
a.equal(undefined, undefined);
a.equal(null, undefined);
a.equal(true, true);
a.equal(2, '2');
a.notEqual(true, false);

assert.throws(() => a.notEqual(true, true),
              a.AssertionError, 'notEqual(true, true)');

assert.throws(() => a.strictEqual(2, '2'),
              a.AssertionError, 'strictEqual(2, \'2\')');

/* eslint-disable no-restricted-syntax */
assert.throws(() => a.strictEqual(null, undefined),
              a.AssertionError, 'strictEqual(null, undefined)');

assert.throws(
  () => a.notStrictEqual(2, 2),
  {
    message: 'Expected ""actual"" to be strictly unequal to: 2',
    name: 'AssertionError'
  }
);

assert.throws(
  () => a.notStrictEqual('a '.repeat(30), 'a '.repeat(30)),
  {
    message: 'Expected ""actual"" to be strictly unequal to:\n\n' +
             `'${'a '.repeat(30)}'`,
    name: 'AssertionError'
  }
);

assert.throws(
  () => a.notEqual(1, 1),
  {
    message: '1 != 1',
    operator: '!='
  }
);

a.notStrictEqual(2, '2');

// Testing the throwing.
function thrower(errorConstructor) {
  throw new errorConstructor({});
}

// The basic calls work.
assert.throws(() => thrower(a.AssertionError), a.AssertionError, 'message');
assert.throws(() => thrower(a.AssertionError), a.AssertionError);
assert.throws(() => thrower(a.AssertionError));

// If not passing an error, catch all.
assert.throws(() => thrower(TypeError));

// When passing a type, only catch errors of the appropriate type.
assert.throws(
  () => a.throws(() => thrower(TypeError), a.AssertionError),
  {
    generatedMessage: true,
    actual: new TypeError({}),
    expected: a.AssertionError,
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    operator: 'throws',
    message: 'The error is expected to be an instance of ""AssertionError"". ' +
             'Received ""TypeError""\n\nError message:\n\n[object Object]'
  }
);

// doesNotThrow should pass through all errors.
{
  let threw = false;
  try {
    a.doesNotThrow(() => thrower(TypeError), a.AssertionError);
  } catch (e) {
    threw = true;
    assert.ok(e instanceof TypeError);
  }
  assert(threw, 'a.doesNotThrow with an explicit error is eating extra errors');
}

// Key difference is that throwing our correct error makes an assertion error.
{
  let threw = false;
  try {
    a.doesNotThrow(() => thrower(TypeError), TypeError);
  } catch (e) {
    threw = true;
    assert.ok(e instanceof a.AssertionError);
    assert.ok(!e.stack.includes('at Function.doesNotThrow'));
  }
  assert.ok(threw, 'a.doesNotThrow is not catching type matching errors');
}

assert.throws(
  () => a.doesNotThrow(() => thrower(Error), 'user message'),
  {
    name: 'AssertionError',
    code: 'ERR_ASSERTION',
    operator: 'doesNotThrow',
    message: 'Got unwanted exception: user message\n' +
             'Actual message: ""[object Object]""'
  }
);

assert.throws(
  () => a.doesNotThrow(() => thrower(Error)),
  {
    code: 'ERR_ASSERTION',
    message: 'Got unwanted exception.\nActual message: ""[object Object]""'
  }
);

assert.throws(
  () => a.doesNotThrow(() => thrower(Error), /\[[a-z]{6}\s[A-z]{6}\]/g, 'user message'),
  {
    name: 'AssertionError',
    code: 'ERR_ASSERTION',
    operator: 'doesNotThrow',
    message: 'Got unwanted exception: user message\n' +
             'Actual message: ""[object Object]""'
  }
);

// Make sure that validating using constructor really works.
{
  let threw = false;
  try {
    assert.throws(
      () => {
        throw ({}); // eslint-disable-line no-throw-literal
      },
      Array
    );
  } catch {
    threw = true;
  }
  assert.ok(threw, 'wrong constructor validation');
}

// Use a RegExp to validate the error message.
{
  a.throws(() => thrower(TypeError), /\[object Object\]/);

  const symbol = Symbol('foo');
  a.throws(() => {
    throw symbol;
  }, /foo/);

  a.throws(() => {
    a.throws(() => {
      throw symbol;
    }, /abc/);
  }, {
    message: 'The input did not match the regular expression /abc/. ' +
             ""Input:\n\n'Symbol(foo)'\n"",
    code: 'ERR_ASSERTION',
    operator: 'throws',
    actual: symbol,
    expected: /abc/
  });
}

// Use a fn to validate the error object.
a.throws(() => thrower(TypeError), (err) => {
  if ((err instanceof TypeError) && /\[object Object\]/.test(err)) {
    return true;
  }
});

// https://github.com/nodejs/node/issues/3188
{
  let actual;
  assert.throws(
    () => {
      const ES6Error = class extends Error {};
      const AnotherErrorType = class extends Error {};

      assert.throws(() => {
        actual = new AnotherErrorType('foo');
        throw actual;
      }, ES6Error);
    },
    (err) => {
      assert.strictEqual(
        err.message,
        'The error is expected to be an instance of ""ES6Error"". ' +
          'Received ""AnotherErrorType""\n\nError message:\n\nfoo'
      );
      assert.strictEqual(err.actual, actual);
      return true;
    }
  );
}

// Check messages from assert.throws().
{
  const noop = () => {};
  assert.throws(
    () => { a.throws((noop)); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception.',
      operator: 'throws',
      actual: undefined,
      expected: undefined
    });

  assert.throws(
    () => { a.throws(noop, TypeError); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception (TypeError).',
      actual: undefined,
      expected: TypeError
    });

  assert.throws(
    () => { a.throws(noop, 'fhqwhgads'); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception: fhqwhgads',
      actual: undefined,
      expected: undefined
    });

  assert.throws(
    () => { a.throws(noop, TypeError, 'fhqwhgads'); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception (TypeError): fhqwhgads',
      actual: undefined,
      expected: TypeError
    });

  let threw = false;
  try {
    a.throws(noop);
  } catch (e) {
    threw = true;
    assert.ok(e instanceof a.AssertionError);
    assert.ok(!e.stack.includes('at Function.throws'));
  }
  assert.ok(threw);
}

const circular = { y: 1 };
circular.x = circular;

function testAssertionMessage(actual, expected, msg) {
  assert.throws(
    () => assert.strictEqual(actual, ''),
    {
      generatedMessage: true,
      message: msg || strictEqualMessageStart +
               `+ actual - expected\n\n+ ${expected}\n- ''`
    }
  );
}

function testShortAssertionMessage(actual, expected) {
  testAssertionMessage(actual, expected, strictEqualMessageStart +
                                         `\n${inspect(actual)} !== ''\n`);
}

testShortAssertionMessage(null, 'null');
testShortAssertionMessage(true, 'true');
testShortAssertionMessage(false, 'false');
testShortAssertionMessage(100, '100');
testShortAssertionMessage(NaN, 'NaN');
testShortAssertionMessage(Infinity, 'Infinity');
testShortAssertionMessage('a', '""a""');
testShortAssertionMessage('foo', '\'foo\'');
testShortAssertionMessage(0, '0');
testShortAssertionMessage(Symbol(), 'Symbol()');
testShortAssertionMessage(undefined, 'undefined');
testShortAssertionMessage(-Infinity, '-Infinity');
testAssertionMessage([], '[]');
testAssertionMessage(/a/, '/a/');
testAssertionMessage(/abc/gim, '/abc/gim');
testAssertionMessage({}, '{}');
testAssertionMessage([1, 2, 3], '[\n+   1,\n+   2,\n+   3\n+ ]');
testAssertionMessage(function f() {}, '[Function: f]');
testAssertionMessage(function() {}, '[Function (anonymous)]');
testAssertionMessage(circular,
                     '<ref *1> {\n+   x: [Circular *1],\n+   y: 1\n+ }');
testAssertionMessage({ a: undefined, b: null },
                     '{\n+   a: undefined,\n+   b: null\n+ }');
testAssertionMessage({ a: NaN, b: Infinity, c: -Infinity },
                     '{\n+   a: NaN,\n+   b: Infinity,\n+   c: -Infinity\n+ }');

// https://github.com/nodejs/node-v0.x-archive/issues/5292
assert.throws(
  () => assert.strictEqual(1, 2),
  {
    message: `${strictEqualMessageStart}\n1 !== 2\n`,
    generatedMessage: true
  }
);

assert.throws(
  () => assert.strictEqual(1, 2, 'oh no'),
  {
    message: 'oh no',
    generatedMessage: false
  }
);

{
  let threw = false;
  const rangeError = new RangeError('my range');

  // Verify custom errors.
  try {
    assert.strictEqual(1, 2, rangeError);
  } catch (e) {
    assert.strictEqual(e, rangeError);
    threw = true;
    assert.ok(e instanceof RangeError, 'Incorrect error type thrown');
  }
  assert.ok(threw);
  threw = false;

  // Verify AssertionError is the result from doesNotThrow with custom Error.
  try {
    a.doesNotThrow(() => {
      throw new TypeError('wrong type');
    }, TypeError, rangeError);
  } catch (e) {
    threw = true;
    assert.ok(e.message.includes(rangeError.message));
    assert.ok(e instanceof assert.AssertionError);
    assert.ok(!e.stack.includes('doesNotThrow'), e);
  }
  assert.ok(threw);
}

{
  // Verify that throws() and doesNotThrow() throw on non-functions.
  const testBlockTypeError = (method, fn) => {
    assert.throws(
      () => method(fn),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""fn"" argument must be of type function.' +
                 common.invalidArgTypeHelper(fn)
      }
    );
  };

  testBlockTypeError(assert.throws, 'string');
  testBlockTypeError(assert.doesNotThrow, 'string');
  testBlockTypeError(assert.throws, 1);
  testBlockTypeError(assert.doesNotThrow, 1);
  testBlockTypeError(assert.throws, true);
  testBlockTypeError(assert.doesNotThrow, true);
  testBlockTypeError(assert.throws, false);
  testBlockTypeError(assert.doesNotThrow, false);
  testBlockTypeError(assert.throws, []);
  testBlockTypeError(assert.doesNotThrow, []);
  testBlockTypeError(assert.throws, {});
  testBlockTypeError(assert.doesNotThrow, {});
  testBlockTypeError(assert.throws, /foo/);
  testBlockTypeError(assert.doesNotThrow, /foo/);
  testBlockTypeError(assert.throws, null);
  testBlockTypeError(assert.doesNotThrow, null);
  testBlockTypeError(assert.throws, undefined);
  testBlockTypeError(assert.doesNotThrow, undefined);
}

// https://github.com/nodejs/node/issues/3275
// eslint-disable-next-line no-throw-literal
assert.throws(() => { throw 'error'; }, (err) => err === 'error');
assert.throws(() => { throw new Error(); }, (err) => err instanceof Error);

// Long values should be truncated for display.
assert.throws(() => {
  assert.strictEqual('A'.repeat(1000), '');
}, (err) => {
  assert.strictEqual(err.code, 'ERR_ASSERTION');
  assert.strictEqual(err.message,
                     `${strictEqualMessageStart}+ actual - expected\n\n` +
                     `+ '${'A'.repeat(1000)}'\n- ''`);
  assert.strictEqual(err.actual.length, 1000);
  assert.ok(inspect(err).includes(`actual: '${'A'.repeat(488)}...'`));
  return true;
});

// Output that extends beyond 10 lines should also be truncated for display.
{
  const multilineString = 'fhqwhgads\n'.repeat(15);
  assert.throws(() => {
    assert.strictEqual(multilineString, '');
  }, (err) => {
    assert.strictEqual(err.code, 'ERR_ASSERTION');
    assert.strictEqual(err.message.split('\n').length, 19);
    assert.strictEqual(err.actual.split('\n').length, 16);
    assert.ok(inspect(err).includes(
      ""actual: 'fhqwhgads\\n' +\n"" +
      ""    'fhqwhgads\\n' +\n"".repeat(9) +
      ""    '...'""));
    return true;
  });
}

{
  // Bad args to AssertionError constructor should throw TypeError.
  const args = [1, true, false, '', null, Infinity, Symbol('test'), undefined];
  args.forEach((input) => {
    assert.throws(
      () => new assert.AssertionError(input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""options"" argument must be of type object.' +
                 common.invalidArgTypeHelper(input)
      });
  });
}

assert.throws(
  () => assert.strictEqual(new Error('foo'), new Error('foobar')),
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: 'Expected ""actual"" to be reference-equal to ""expected"":\n' +
             '+ actual - expected\n\n' +
             '+ [Error: foo]\n- [Error: foobar]'
  }
);

a.equal(NaN, NaN);
a.throws(
  () => a.notEqual(NaN, NaN),
  a.AssertionError
);

// Test strict assert.
{
  const a = require('assert');
  const assert = require('assert').strict;
  /* eslint-disable no-restricted-properties */
  assert.throws(() => assert.equal(1, true), assert.AssertionError);
  assert.notEqual(0, false);
  assert.throws(() => assert.deepEqual(1, true), assert.AssertionError);
  assert.notDeepEqual(0, false);
  assert.equal(assert.strict, assert.strict.strict);
  assert.equal(assert.equal, assert.strictEqual);
  assert.equal(assert.deepEqual, assert.deepStrictEqual);
  assert.equal(assert.notEqual, assert.notStrictEqual);
  assert.equal(assert.notDeepEqual, assert.notDeepStrictEqual);
  assert.equal(Object.keys(assert).length, Object.keys(a).length);
  assert(7);
  assert.throws(
    () => assert(...[]),
    {
      message: 'No value argument passed to `assert.ok()`',
      name: 'AssertionError',
      generatedMessage: true
    }
  );
  assert.throws(
    () => a(),
    {
      message: 'No value argument passed to `assert.ok()`',
      name: 'AssertionError'
    }
  );

  // Test setting the limit to zero and that assert.strict works properly.
  const tmpLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  assert.throws(
    () => {
      assert.ok(
        typeof 123 === 'string'
      );
    },
    {
      code: 'ERR_ASSERTION',
      constructor: assert.AssertionError,
      message: 'The expression evaluated to a falsy value:\n\n  ' +
               ""assert.ok(\n    typeof 123 === 'string'\n  )\n""
    }
  );
  Error.stackTraceLimit = tmpLimit;

  // Test error diffs.
  let message = [
    start,
    `${actExp} ... Lines skipped`,
    '',
    '  [',
    '    [',
    '      [',
    '        1,',
    '        2,',
    '+       3',
    ""-       '3'"",
    '      ]',
    '...',
    '    4,',
    '    5',
    '  ]'].join('\n');
  assert.throws(
    () => assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]),
    { message });

  message = [
    start,
    `${actExp} ... Lines skipped`,
    '',
    '  [',
    '    1,',
    '...',
    '    1,',
    '    0,',
    '-   1,',
    '    1,',
    '...',
    '    1,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual(
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1]),
    { message });

  message = [
    start,
    `${actExp} ... Lines skipped`,
    '',
    '  [',
    '    1,',
    '...',
    '    1,',
    '    0,',
    '+   1,',
    '    1,',
    '    1,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual(
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]),
    { message });

  message = [
    start,
    actExp,
    '',
    '  [',
    '    1,',
    '+   2,',
    '-   1,',
    '    1,',
    '    1,',
    '    0,',
    '+   1,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual(
      [1, 2, 1, 1, 0, 1, 1],
      [1, 1, 1, 1, 0, 1]),
    { message });

  message = [
    start,
    actExp,
    '',
    '+ [',
    '+   1,',
    '+   2,',
    '+   1',
    '+ ]',
    '- undefined',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual([1, 2, 1], undefined),
    { message });

  message = [
    start,
    actExp,
    '',
    '  [',
    '+   1,',
    '    2,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual([1, 2, 1], [2, 1]),
    { message });

  message = `${start}\n` +
    `${actExp} ... Lines skipped\n` +
    '\n' +
    '  [\n' +
    '+   1,\n'.repeat(25) +
    '...\n' +
    '-   2,\n'.repeat(25) +
    '...';
  assert.throws(
    () => assert.deepEqual(Array(28).fill(1), Array(28).fill(2)),
    { message });

  const obj1 = {};
  const obj2 = { loop: 'forever' };
  obj2[inspect.custom] = () => '{}';
  // No infinite loop and no custom inspect.
  assert.throws(() => assert.deepEqual(obj1, obj2), {
    message: `${start}\n` +
    `${actExp}\n` +
    '\n' +
    '+ {}\n' +
    '- {\n' +
    '-   [Symbol(nodejs.util.inspect.custom)]: [Function (anonymous)],\n' +
    ""-   loop: 'forever'\n"" +
    '- }'
  });

  // notDeepEqual tests
  assert.throws(
    () => assert.notDeepEqual([1], [1]),
    {
      message: 'Expected ""actual"" not to be strictly deep-equal to:\n\n' +
               '[\n  1\n]\n'
    }
  );

  message = 'Expected ""actual"" not to be strictly deep-equal to:' +
            `\n\n[${'\n  1,'.repeat(45)}\n...\n`;
  const data = Array(51).fill(1);
  assert.throws(
    () => assert.notDeepEqual(data, data),
    { message });
  /* eslint-enable no-restricted-properties */
}

assert.throws(
  () => assert.ok(null),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    generatedMessage: true,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert.ok(null)\n'
  }
);
assert.throws(
  () => assert(typeof 123n === 'string'),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    generatedMessage: true,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             ""assert(typeof 123n === 'string')\n""
  }
);

assert.throws(
  () => assert(false, Symbol('foo')),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    generatedMessage: false,
    message: 'Symbol(foo)'
  }
);

{
  // Test caching.
  const fs = internalBinding('fs');
  const tmp = fs.close;
  fs.close = common.mustCall(tmp, 1);
  function throwErr() {
    assert(
      (Buffer.from('test') instanceof Error)
    );
  }
  assert.throws(
    () => throwErr(),
    {
      code: 'ERR_ASSERTION',
      constructor: assert.AssertionError,
      message: 'The expression evaluated to a falsy value:\n\n  ' +
               ""assert(\n    (Buffer.from('test') instanceof Error)\n  )\n""
    }
  );
  assert.throws(
    () => throwErr(),
    {
      code: 'ERR_ASSERTION',
      constructor: assert.AssertionError,
      message: 'The expression evaluated to a falsy value:\n\n  ' +
               ""assert(\n    (Buffer.from('test') instanceof Error)\n  )\n""
    }
  );
  fs.close = tmp;
}

assert.throws(
  () => {
    a(
      (() => 'string')()
      // eslint-disable-next-line operator-linebreak
      ===
      123 instanceof
          Buffer
    );
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n' +
             '  a(\n' +
             '    (() => \'string\')()\n' +
             '    // eslint-disable-next-line operator-linebreak\n' +
             '    ===\n' +
             '    123 instanceof\n' +
             '        Buffer\n' +
             '  )\n'
  }
);

assert.throws(
  () => {
    a(
      (() => 'string')()
      // eslint-disable-next-line operator-linebreak
      ===
  123 instanceof
          Buffer
    );
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n' +
             '  a(\n' +
             '    (() => \'string\')()\n' +
             '    // eslint-disable-next-line operator-linebreak\n' +
             '    ===\n' +
             '  123 instanceof\n' +
             '        Buffer\n' +
             '  )\n'
  }
);

/* eslint-disable indent */
assert.throws(() => {
a((
  () => 'string')() ===
123 instanceof
Buffer
);
}, {
  code: 'ERR_ASSERTION',
  constructor: assert.AssertionError,
  message: 'The expression evaluated to a falsy value:\n\n' +
           '  a((\n' +
           '    () => \'string\')() ===\n' +
           '  123 instanceof\n' +
           '  Buffer\n' +
           '  )\n'
  }
);
/* eslint-enable indent */

assert.throws(
  () => {
    assert(true); assert(null, undefined);
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert(null, undefined)\n'
  }
);

assert.throws(
  () => {
    assert
     .ok(null, undefined);
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'ok(null, undefined)\n'
  }
);

assert.throws(
  // eslint-disable-next-line dot-notation, quotes
  () => assert['ok'][""apply""](null, [0]),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert[\'ok\'][""apply""](null, [0])\n'
  }
);

assert.throws(
  () => {
    const wrapper = (fn, value) => fn(value);
    wrapper(assert, false);
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  fn(value)\n'
  }
);

assert.throws(
  () => assert.ok.call(null, 0),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert.ok.call(null, 0)\n',
    generatedMessage: true
  }
);

assert.throws(
  () => assert.ok.call(null, 0, 'test'),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'test',
    generatedMessage: false
  }
);

// Works in eval.
assert.throws(
  () => new Function('assert', 'assert(1 === 2);')(assert),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  assert(1 === 2)\n'
  }
);
assert.throws(
  () => eval('console.log(""FOO"");\nassert.ok(1 === 2);'),
  {
    code: 'ERR_ASSERTION',
    message: 'false == true'
  }
);

assert.throws(
  () => assert.throws(() => {}, 'Error message', 'message'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""error"" argument must be of type function or ' +
             'an instance of Error, RegExp, or Object. Received type string ' +
             ""('Error message')""
  }
);

[
  1,
  false,
  Symbol(),
].forEach((input) => {
  assert.throws(
    () => assert.throws(() => {}, input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""error"" argument must be of type function or ' +
               'an instance of Error, RegExp, or Object.' +
               common.invalidArgTypeHelper(input)
    }
  );
});

{

  assert.throws(() => {
    assert.ok((() => Boolean('' === false))());
  }, {
    message: 'The expression evaluated to a falsy value:\n\n' +
             ""  assert.ok((() => Boolean('\\u0001' === false))())\n""
  });

  const errFn = () => {
    const err = new TypeError('Wrong value');
    err.code = 404;
    throw err;
  };
  const errObj = {
    name: 'TypeError',
    message: 'Wrong value'
  };
  assert.throws(errFn, errObj);

  errObj.code = 404;
  assert.throws(errFn, errObj);

  // Fail in case a expected property is undefined and not existent on the
  // error.
  errObj.foo = undefined;
  assert.throws(
    () => assert.throws(errFn, errObj),
    {
      code: 'ERR_ASSERTION',
      name: 'AssertionError',
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               '    code: 404,\n' +
               '-   foo: undefined,\n' +
               ""    message: 'Wrong value',\n"" +
               ""    name: 'TypeError'\n"" +
               '  }'
    }
  );

  // Show multiple wrong properties at the same time.
  errObj.code = '404';
  assert.throws(
    () => assert.throws(errFn, errObj),
    {
      code: 'ERR_ASSERTION',
      name: 'AssertionError',
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               '+   code: 404,\n' +
               ""-   code: '404',\n"" +
               '-   foo: undefined,\n' +
               ""    message: 'Wrong value',\n"" +
               ""    name: 'TypeError'\n"" +
               '  }'
    }
  );

  assert.throws(
    () => assert.throws(() => { throw new Error(); }, { foo: 'bar' }, 'foobar'),
    {
      constructor: assert.AssertionError,
      code: 'ERR_ASSERTION',
      message: 'foobar'
    }
  );

  assert.throws(
    () => a.doesNotThrow(() => { throw new Error(); }, { foo: 'bar' }),
    {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""expected"" argument must be of type function or an ' +
               'instance of RegExp. Received an instance of Object'
    }
  );

  assert.throws(() => { throw new Error('e'); }, new Error('e'));
  assert.throws(
    () => assert.throws(() => { throw new TypeError('e'); }, new Error('e')),
    {
      name: 'AssertionError',
      code: 'ERR_ASSERTION',
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               ""    message: 'e',\n"" +
               ""+   name: 'TypeError'\n"" +
               ""-   name: 'Error'\n"" +
               '  }'
    }
  );
  assert.throws(
    () => assert.throws(() => { throw new Error('foo'); }, new Error('')),
    {
      name: 'AssertionError',
      code: 'ERR_ASSERTION',
      generatedMessage: true,
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               ""+   message: 'foo',\n"" +
               ""-   message: '',\n"" +
               ""    name: 'Error'\n"" +
               '  }'
    }
  );

  // eslint-disable-next-line no-throw-literal
  assert.throws(() => { throw undefined; }, /undefined/);
  assert.throws(
    // eslint-disable-next-line no-throw-literal
    () => a.doesNotThrow(() => { throw undefined; }),
    {
      name: 'AssertionError',
      code: 'ERR_ASSERTION',
      message: 'Got unwanted exception.\nActual message: ""undefined""'
    }
  );
}

assert.throws(
  () => assert.throws(() => { throw new Error(); }, {}),
  {
    message: ""The argument 'error' may not be an empty object. Received {}"",
    code: 'ERR_INVALID_ARG_VALUE'
  }
);

assert.throws(
  () => a.throws(
    // eslint-disable-next-line no-throw-literal
    () => { throw 'foo'; },
    'foo'
  ),
  {
    code: 'ERR_AMBIGUOUS_ARGUMENT',
    message: 'The ""error/message"" argument is ambiguous. ' +
             'The error ""foo"" is identical to the message.'
  }
);

assert.throws(
  () => a.throws(
    () => { throw new TypeError('foo'); },
    'foo'
  ),
  {
    code: 'ERR_AMBIGUOUS_ARGUMENT',
    message: 'The ""error/message"" argument is ambiguous. ' +
             'The error message ""foo"" is identical to the message.'
  }
);
/* eslint-enable no-restricted-syntax */

// Should not throw.
// eslint-disable-next-line no-restricted-syntax, no-throw-literal
assert.throws(() => { throw null; }, 'foo');

assert.throws(
  () => assert.strictEqual([], []),
  {
    message: 'Values have same structure but are not reference-equal:\n\n[]\n'
  }
);

{
  const args = (function() { return arguments; })('a');
  assert.throws(
    () => assert.strictEqual(args, { 0: 'a' }),
    {
      message: 'Expected ""actual"" to be reference-equal to ""expected"":\n' +
               '+ actual - expected\n\n' +
               ""+ [Arguments] {\n- {\n    '0': 'a'\n  }""
    }
  );
}

assert.throws(
  () => { throw new TypeError('foobar'); },
  {
    message: /foo/,
    name: /^TypeError$/
  }
);

assert.throws(
  () => assert.throws(
    () => { throw new TypeError('foobar'); },
    {
      message: /fooa/,
      name: /^TypeError$/
    }
  ),
  {
    message: `${start}\n${actExp}\n\n` +
             '  Comparison {\n' +
             ""+   message: 'foobar',\n"" +
             '-   message: /fooa/,\n' +
             ""    name: 'TypeError'\n"" +
             '  }'
  }
);

{
  let actual = null;
  const expected = { message: 'foo' };
  assert.throws(
    () => assert.throws(
      () => { throw actual; },
      expected
    ),
    {
      operator: 'throws',
      actual,
      expected,
      generatedMessage: true,
      message: `${start}\n${actExp}\n\n` +
              '+ null\n' +
              '- {\n' +
              ""-   message: 'foo'\n"" +
              '- }'
    }
  );

  actual = 'foobar';
  const message = 'message';
  assert.throws(
    () => assert.throws(
      () => { throw actual; },
      { message: 'foobar' },
      message
    ),
    {
      actual,
      message,
      operator: 'throws',
      generatedMessage: false
    }
  );
}

// Indicate where the strings diverge.
assert.throws(
  () => assert.strictEqual('test test', 'test foobar'),
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: strictEqualMessageStart +
             '+ actual - expected\n\n' +
             ""+ 'test test'\n"" +
             ""- 'test foobar'\n"" +
             '        ^'
  }
);

// Check for reference-equal objects in `notStrictEqual()`
assert.throws(
  () => {
    const obj = {};
    assert.notStrictEqual(obj, obj);
  },
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: 'Expected ""actual"" not to be reference-equal to ""expected"": {}'
  }
);

assert.throws(
  () => {
    const obj = { a: true };
    assert.notStrictEqual(obj, obj);
  },
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: 'Expected ""actual"" not to be reference-equal to ""expected"":\n\n' +
             '{\n  a: true\n}\n'
  }
);

{
  let threw = false;
  try {
    // eslint-disable-next-line no-restricted-syntax
    assert.deepStrictEqual(Array(100).fill(1), 'foobar');
  } catch (err) {
    threw = true;
    assert.match(inspect(err), /actual: \[Array],\n {2}expected: 'foobar',/);
  }
  assert(threw);
}

assert.throws(
  () => a.equal(1),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.deepEqual(/a/),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notEqual(null),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notDeepEqual('test'),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.strictEqual({}),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.deepStrictEqual(Symbol()),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notStrictEqual(5n), // eslint-disable-line no-restricted-syntax
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notDeepStrictEqual(undefined),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.strictEqual(),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.deepStrictEqual(),
  { code: 'ERR_MISSING_ARGS' }
);

// Verify that `stackStartFunction` works as alternative to `stackStartFn`.
{
  (function hidden() {
    const err = new assert.AssertionError({
      actual: 'foo',
      operator: 'strictEqual',
      stackStartFunction: hidden
    });
    const err2 = new assert.AssertionError({
      actual: 'foo',
      operator: 'strictEqual',
      stackStartFn: hidden
    });
    assert(!err.stack.includes('hidden'));
    assert(!err2.stack.includes('hidden'));
  })();
}

assert.throws(
  () => assert.throws(() => { throw Symbol('foo'); }, RangeError),
  {
    message: 'The error is expected to be an instance of ""RangeError"". ' +
             'Received ""Symbol(foo)""'
  }
);

assert.throws(
  // eslint-disable-next-line no-throw-literal
  () => assert.throws(() => { throw [1, 2]; }, RangeError),
  {
    message: 'The error is expected to be an instance of ""RangeError"". ' +
             'Received ""[Array]""'
  }
);

{
  const err = new TypeError('foo');
  const validate = (() => () => ({ a: true, b: [ 1, 2, 3 ] }))();
  assert.throws(
    () => assert.throws(() => { throw err; }, validate),
    {
      message: 'The validation function is expected to ' +
              `return ""true"". Received ${inspect(validate())}\n\nCaught ` +
              `error:\n\n${err}`,
      code: 'ERR_ASSERTION',
      actual: err,
      expected: validate,
      name: 'AssertionError',
      operator: 'throws',
    }
  );
}

assert.throws(
  () => {
    const script = new vm.Script('new RangeError(""foobar"");');
    const context = vm.createContext();
    const err = script.runInContext(context);
    assert.throws(() => { throw err; }, RangeError);
  },
  {
    message: 'The error is expected to be an instance of ""RangeError"". ' +
             'Received an error with identical name but a different ' +
             'prototype.\n\nError message:\n\nfoobar'
  }
);

// Multiple assert.match() tests.
{
  assert.throws(
    () => assert.match(/abc/, 'string'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""regexp"" argument must be an instance of RegExp. ' +
               ""Received type string ('string')""
    }
  );
  assert.throws(
    () => assert.match('string', /abc/),
    {
      actual: 'string',
      expected: /abc/,
      operator: 'match',
      message: 'The input did not match the regular expression /abc/. ' +
               ""Input:\n\n'string'\n"",
      generatedMessage: true
    }
  );
  assert.throws(
    () => assert.match('string', /abc/, 'foobar'),
    {
      actual: 'string',
      expected: /abc/,
      operator: 'match',
      message: 'foobar',
      generatedMessage: false
    }
  );
  const errorMessage = new RangeError('foobar');
  assert.throws(
    () => assert.match('string', /abc/, errorMessage),
    errorMessage
  );
  assert.throws(
    () => assert.match({ abc: 123 }, /abc/),
    {
      actual: { abc: 123 },
      expected: /abc/,
      operator: 'match',
      message: 'The ""string"" argument must be of type string. ' +
               'Received type object ({ abc: 123 })',
      generatedMessage: true
    }
  );
  assert.match('I will pass', /pass$/);
}

// Multiple assert.doesNotMatch() tests.
{
  assert.throws(
    () => assert.doesNotMatch(/abc/, 'string'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""regexp"" argument must be an instance of RegExp. ' +
               ""Received type string ('string')""
    }
  );
  assert.throws(
    () => assert.doesNotMatch('string', /string/),
    {
      actual: 'string',
      expected: /string/,
      operator: 'doesNotMatch',
      message: 'The input was expected to not match the regular expression ' +
               ""/string/. Input:\n\n'string'\n"",
      generatedMessage: true
    }
  );
  assert.throws(
    () => assert.doesNotMatch('string', /string/, 'foobar'),
    {
      actual: 'string',
      expected: /string/,
      operator: 'doesNotMatch',
      message: 'foobar',
      generatedMessage: false
    }
  );
  const errorMessage = new RangeError('foobar');
  assert.throws(
    () => assert.doesNotMatch('string', /string/, errorMessage),
    errorMessage
  );
  assert.throws(
    () => assert.doesNotMatch({ abc: 123 }, /abc/),
    {
      actual: { abc: 123 },
      expected: /abc/,
      operator: 'doesNotMatch',
      message: 'The ""string"" argument must be of type string. ' +
               'Received type object ({ abc: 123 })',
      generatedMessage: true
    }
  );
  assert.doesNotMatch('I will pass', /different$/);
}

{
  const tempColor = inspect.defaultOptions.colors;
  assert.throws(() => {
    inspect.defaultOptions.colors = true;
    // Guarantee the position indicator is placed correctly.
    assert.strictEqual(111554n, 11111115);
  }, (err) => {
    assert.strictEqual(inspect(err).split('\n')[5], '     ^');
    inspect.defaultOptions.colors = tempColor;
    return true;
  });
}

```"
"```javascript:modules\assert.js
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import { Buffer } from 'buffer';
import {
  ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS,
  isErrorStackTraceLimitWritable,
} from 'internal/errors';

const overrideStackTrace = new WeakMap();

import AssertionError from 'internal/assert/assertion_error';
import { openSync, closeSync, readSync } from 'fs';
import { inspect } from 'internal/util/inspect';
import { isPromise, isRegExp } from 'internal/util/types';
import { EOL } from 'internal/constants';
// import { BuiltinModule } from 'internal/bootstrap/loaders';
import { isError } from 'internal/util';

const errorCache = new Map();
import CallTracker from 'internal/assert/calltracker';
import {
  validateFunction,
} from 'internal/validators';

import { isDeepEqual, isDeepStrictEqual } from 'internal/util/comparisons'

let parseExpressionAt;
let findNodeAround;
let decoder;

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
const escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
const meta = [
  '\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004',
  '\\u0005', '\\u0006', '\\u0007', '\\b', '',
  '', '\\u000b', '\\f', '', '\\u000e',
  '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013',
  '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018',
  '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d',
  '\\u001e', '\\u001f',
];

const escapeFn = (str) => meta[String.prototype.charCodeAt.call(str, 0)];

let warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

const assert = function (obj) {
  if (!obj) {
    throw new AssertionError({ message: 'assert fail' });
  }
};

const NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;

  throw new AssertionError(obj);
}

/**
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @param {string} [operator]
 * @param {Function} [stackStartFn]
 */
function fail(actual, expected, message, operator, stackStartFn) {
  const argsLen = arguments.length;

  let internalMessage = false;
  if (actual == null && argsLen <= 1) {
    internalMessage = true;
    message = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      process.emitWarning(
        'assert.fail() with more than one argument is deprecated. ' +
        'Please use assert.strictEqual() instead or only pass a message.',
        'DeprecationWarning',
        'DEP0094'
      );
    }
    if (argsLen === 2)
      operator = '!=';
  }

  if (message instanceof Error) throw message;

  const errArgs = {
    actual,
    expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail,
    message
  };
  const err = new AssertionError(errArgs);
  if (internalMessage) {
    err.generatedMessage = true;
  }
  throw err;
}

assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;

function findColumn(fd, column, code) {
  if (code.length > column + 100) {
    try {
      return parseCode(code, column);
    } catch {
      // End recursion in case no code could be parsed. The expression should
      // have been found after 2500 characters, so stop trying.
      if (code.length - column > 2500) {
        // eslint-disable-next-line no-throw-literal
        throw null;
      }
    }
  }
  // Read up to 2500 bytes more than necessary in columns. That way we address
  // multi byte characters and read enough data to parse the code.
  const bytesToRead = column - code.length + 2500;
  const buffer = Buffer.allocUnsafe(bytesToRead);
  const bytesRead = readSync(fd, buffer, 0, bytesToRead);
  code += decoder.write(buffer.slice(0, bytesRead));
  // EOF: fast path.
  if (bytesRead < bytesToRead) {
    return parseCode(code, column);
  }
  // Read potentially missing code.
  return findColumn(fd, column, code);
}

function getCode(fd, line, column) {
  let bytesRead = 0;
  if (line === 0) {
    // Special handle line number one. This is more efficient and simplifies the
    // rest of the algorithm. Read more than the regular column number in bytes
    // to prevent multiple reads in case multi byte characters are used.
    return findColumn(fd, column, '');
  }
  let lines = 0;
  // Prevent blocking the event loop by limiting the maximum amount of
  // data that may be read.
  let maxReads = 32; // bytesPerRead * maxReads = 512 KiB
  const bytesPerRead = 16384;
  // Use a single buffer up front that is reused until the call site is found.
  let buffer = Buffer.allocUnsafe(bytesPerRead);
  while (maxReads-- !== 0) {
    // Only allocate a new buffer in case the needed line is found. All data
    // before that can be discarded.
    buffer = lines < line ? buffer : Buffer.allocUnsafe(bytesPerRead);
    bytesRead = readSync(fd, buffer, 0, bytesPerRead);
    // Read the buffer until the required code line is found.
    for (let i = 0; i < bytesRead; i++) {
      if (buffer[i] === 10 && ++lines === line) {
        // If the end of file is reached, directly parse the code and return.
        if (bytesRead < bytesPerRead) {
          return parseCode(buffer.toString('utf8', i + 1, bytesRead), column);
        }
        // Check if the read code is sufficient or read more until the whole
        // expression is read. Make sure multi byte characters are preserved
        // properly by using the decoder.
        const code = decoder.write(buffer.slice(i + 1, bytesRead));
        return findColumn(fd, column, code);
      }
    }
  }
}

function parseCode(code, offset) {
  // Lazy load acorn.
  if (parseExpressionAt === undefined) {
    const Parser = import('internal/deps/acorn/acorn/dist/acorn').Parser;
    ({ findNodeAround } = import('internal/deps/acorn/acorn-walk/dist/walk'));

    parseExpressionAt = Function.prototype.bind.call(Parser.parseExpressionAt, Parser);
  }
  let node;
  let start = 0;
  // Parse the read code until the correct expression is found.
  do {
    try {
      node = parseExpressionAt(code, start, { ecmaVersion: 'latest' });
      start = node.end + 1 || start;
      // Find the CallExpression in the tree.
      node = findNodeAround(node, offset, 'CallExpression');
    } catch (err) {
      // Unexpected token error and the like.
      start += err.raisedAt || 1;
      if (start > offset) {
        // No matching expression found. This could happen if the assert
        // expression is bigger than the provided buffer.
        // eslint-disable-next-line no-throw-literal
        throw null;
      }
    }
  } while (node === undefined || node.node.end < offset);

  return [
    node.node.start,
    String.prototype.replace.call(String.prototype.slice.call(code,
      node.node.start, node.node.end),
      escapeSequencesRegExp, escapeFn),
  ];
}

function getErrMessage(message, fn) {
  return ""assert.getErrMessage unsupported"";
  const tmpLimit = Error.stackTraceLimit;
  const errorStackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  // Make sure the limit is set to 1. Otherwise it could fail (<= 0) or it
  // does to much work.
  if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = 1;
  // We only need the stack trace. To minimize the overhead use an object
  // instead of an error.
  const err = {};
  Error.captureStackTrace(err, fn);
  if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = tmpLimit;

  overrideStackTrace.set(err, (_, stack) => stack);
  const call = err.stack[0];

  const filename = call.getFileName();
  const line = call.getLineNumber() - 1;
  let column = call.getColumnNumber() - 1;
  let identifier;
  let code;

  if (filename) {
    identifier = `${filename}${line}${column}`;

    // Skip Node.js modules!
    if (String.prototype.startsWith.call(filename, 'node:') &&
      BuiltinModule.exists(String.prototype.slice.call(filename, 5))) {
      errorCache.set(identifier, undefined);
      return;
    }
  } else {
    const fn = call.getFunction();
    if (!fn) {
      return message;
    }
    code = String(fn);
    identifier = `${code}${line}${column}`;
  }

  if (errorCache.has(identifier)) {
    return errorCache.get(identifier);
  }

  let fd;
  try {
    // Set the stack trace limit to zero. This makes sure unexpected token
    // errors are handled faster.
    if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = 0;

    if (filename) {
      if (decoder === undefined) {
        const { StringDecoder } = import('string_decoder');
        decoder = new StringDecoder('utf8');
      }
      fd = openSync(filename, 'r', 0o666);
      // Reset column and message.
      ({ 0: column, 1: message } = getCode(fd, line, column));
      // Flush unfinished multi byte characters.
      decoder.end();
    } else {
      for (let i = 0; i < line; i++) {
        code = String.prototype.slice.call(code,
          String.prototype.indexOf.call(code, '\n') + 1);
      }
      ({ 0: column, 1: message } = parseCode(code, column));
    }
    // Always normalize indentation, otherwise the message could look weird.
    if (String.prototype.includes.call(message, '\n')) {
      if (EOL === '\r\n') {
        message = RegExp.prototype[Symbol.replace].call(/\r\n/g, message, '\n');
      }
      const frames = String.prototype.split.call(message, '\n');
      message = Array.prototype.shift.call(frames);
      for (const frame of frames) {
        let pos = 0;
        while (pos < column && (frame[pos] === ' ' || frame[pos] === '\t')) {
          pos++;
        }
        message += `\n  ${String.prototype.slice.call(frame, pos)}`;
      }
    }
    message = `The expression evaluated to a falsy value:\n\n  ${message}\n`;
    // Make sure to always set the cache! No matter if the message is
    // undefined or not
    errorCache.set(identifier, message);

    return message;
  } catch {
    // Invalidate cache to prevent trying to read this part again.
    errorCache.set(identifier, undefined);
  } finally {
    // Reset limit.
    if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = tmpLimit;
    if (fd !== undefined)
      closeSync(fd);
  }
}

function innerOk(fn, argLen, value, message) {
  if (!value) {
    let generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message == null) {
      generatedMessage = true;
      message = getErrMessage(message, fn);
    } else if (message instanceof Error) {
      throw message;
    }

    const err = new AssertionError({
      actual: value,
      expected: true,
      message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

/**
 * Pure assertion tests whether a value is truthy, as determined
 * by !!value.
 * @param {...any} args
 * @returns {void}
 */
function ok(...args) {
  innerOk(ok, args.length, ...args);
}
assert.ok = ok;

/**
 * The equality assertion tests shallow, coercive equality with ==.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected && (!Number.isNaN(actual) || !Number.isNaN(expected))) {
    innerFail({
      actual,
      expected,
      message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

/**
 * The non-equality assertion tests for whether two objects are not
 * equal with !=.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected || (Number.isNaN(actual) && Number.isNaN(expected))) {
    innerFail({
      actual,
      expected,
      message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

/**
 * The deep equivalence assertion tests a deep equality relation.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

/**
 * The deep non-equivalence assertion tests for any deep inequality.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

/**
 * The deep strict equivalence assertion tests a deep strict equality
 * relation.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

/**
 * The deep strict non-equivalence assertion tests for any deep strict
 * inequality.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

/**
 * The strict equivalence assertion tests a strict equality relation.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!Object.is(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

/**
 * The strict non-equivalence assertion tests for any strict inequality.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (Object.is(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

class Comparison {
  constructor(obj, keys, actual) {
    for (const key of keys) {
      if (key in obj) {
        if (actual !== undefined &&
          typeof actual[key] === 'string' &&
          isRegExp(obj[key]) &&
          RegExp.prototype.exec.call(obj[key], actual[key]) !== null) {
          this[key] = actual[key];
        } else {
          this[key] = obj[key];
        }
      }
    }
  }
}

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      const a = new Comparison(actual, keys);
      const b = new Comparison(expected, keys, actual);

      const err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual,
      expected,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, message, fn) {
  let generatedMessage = false;
  let throwError = false;

  if (typeof expected !== 'function') {
    // Handle regular expressions.
    if (isRegExp(expected)) {
      const str = String(actual);
      if (RegExp.prototype.exec.call(expected, str) !== null)
        return;

      if (!message) {
        generatedMessage = true;
        message = 'The input did not match the regular expression ' +
          `${inspect(expected)}. Input:\n\n${inspect(str)}\n`;
      }
      throwError = true;
      // Handle primitives properly.
    } else if (typeof actual !== 'object' || actual === null) {
      const err = new AssertionError({
        actual,
        expected,
        message,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    } else {
      // Handle validation objects.
      const keys = Object.keys(expected);
      // Special handle errors to make sure the name and the message are
      // compared as well.
      if (expected instanceof Error) {
        Array.prototype.push.call(keys, 'name', 'message');
      } else if (keys.length === 0) {
        throw new ERR_INVALID_ARG_VALUE('error',
          expected, 'may not be an empty object');
      }
      for (const key of keys) {
        if (typeof actual[key] === 'string' &&
          isRegExp(expected[key]) &&
          RegExp.prototype.exec.call(expected[key], actual[key]) !== null) {
          continue;
        }
        compareExceptionKey(actual, expected, key, message, keys, fn);
      }
      return;
    }
    // Guard instanceof against arrow functions as they don't have a prototype.
    // Check for matching Error classes.
  } else if (expected.prototype !== undefined && actual instanceof expected) {
    return;
  } else if (Error.prototype.isPrototypeOf(expected)) {
    if (!message) {
      generatedMessage = true;
      message = 'The error is expected to be an instance of ' +
        `""${expected.name}"". Received `;
      if (isError(actual)) {
        const name = (actual.constructor && actual.constructor.name) ||
          actual.name;
        if (expected.name === name) {
          message += 'an error with identical name but a different prototype.';
        } else {
          message += `""${name}""`;
        }
        if (actual.message) {
          message += `\n\nError message:\n\n${actual.message}`;
        }
      } else {
        message += `""${inspect(actual, { depth: -1 })}""`;
      }
    }
    throwError = true;
  } else {
    // Check validation functions return value.
    const res = Reflect.apply(expected, {}, [actual]);
    if (res !== true) {
      if (!message) {
        generatedMessage = true;
        const name = expected.name ? `""${expected.name}"" ` : '';
        message = `The ${name}validation function is expected to return` +
          ` ""true"". Received ${inspect(res)}`;

        if (isError(actual)) {
          message += `\n\nCaught error:\n\n${actual}`;
        }
      }
      throwError = true;
    }
  }

  if (throwError) {
    const err = new AssertionError({
      actual,
      expected,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

function getActual(fn) {
  validateFunction(fn, 'fn');
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  return isPromise(obj) ||
    (obj !== null && typeof obj === 'object' &&
      typeof obj.then === 'function' &&
      typeof obj.catch === 'function');
}

async function waitForActual(promiseFn) {
  let resultPromise;
  if (typeof promiseFn === 'function') {
    // Return a rejected promise if `promiseFn` throws synchronously.
    resultPromise = promiseFn();
    // Fail in case no promise is returned.
    if (!checkIsPromise(resultPromise)) {
      throw new ERR_INVALID_RETURN_VALUE('instance of Promise',
        'promiseFn', resultPromise);
    }
  } else if (checkIsPromise(promiseFn)) {
    resultPromise = promiseFn;
  } else {
    throw new ERR_INVALID_ARG_TYPE(
      'promiseFn', ['Function', 'Promise'], promiseFn);
  }

  try {
    await resultPromise;
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error',
        ['Object', 'Error', 'Function', 'RegExp'],
        error);
    }
    if (typeof actual === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT(
          'error/message',
          `The error message ""${actual.message}"" is identical to the message.`
        );
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT(
        'error/message',
        `The error ""${actual}"" is identical to the message.`
      );
    }
    message = error;
    error = undefined;
  } else if (error != null &&
    typeof error !== 'object' &&
    typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error',
      ['Object', 'Error', 'Function', 'RegExp'],
      error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    let details = '';
    if (error && error.name) {
      details += ` (${error.name})`;
    }
    details += message ? `: ${message}` : '.';
    const fnType = stackStartFn === assert.rejects ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: `Missing expected ${fnType}${details}`,
      stackStartFn
    });
  }

  if (!error)
    return;

  expectedException(actual, error, message, stackStartFn);
}

function hasMatchingError(actual, expected) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) {
      const str = String(actual);
      return RegExp.prototype.exec.call(expected, str) !== null;
    }
    throw new ERR_INVALID_ARG_TYPE(
      'expected', ['Function', 'RegExp'], expected
    );
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Object.prototype.isPrototypeOf.call(Error, expected)) {
    return false;
  }
  return Reflect.apply(expected, {}, [actual]) === true;
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL)
    return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || hasMatchingError(actual, error)) {
    const details = message ? `: ${message}` : '.';
    const fnType = stackStartFn === assert.doesNotReject ?
      'rejection' : 'exception';
    innerFail({
      actual,
      expected: error,
      operator: stackStartFn.name,
      message: `Got unwanted ${fnType}${details}\n` +
        `Actual message: ""${actual && actual.message}""`,
      stackStartFn
    });
  }
  throw actual;
}

/**
 * Expects the function `promiseFn` to throw an error.
 * @param {() => any} promiseFn
 * @param {...any} [args]
 * @returns {void}
 */
assert.throws = function throws(promiseFn, ...args) {
  expectsError(throws, getActual(promiseFn), ...args);
};

/**
 * Expects `promiseFn` function or its value to reject.
 * @param {() => Promise<any>} promiseFn
 * @param {...any} [args]
 * @returns {Promise<void>}
 */
assert.rejects = async function rejects(promiseFn, ...args) {
  expectsError(rejects, await waitForActual(promiseFn), ...args);
};

/**
 * Asserts that the function `fn` does not throw an error.
 * @param {() => any} fn
 * @param {...any} [args]
 * @returns {void}
 */
assert.doesNotThrow = function doesNotThrow(fn, ...args) {
  expectsNoError(doesNotThrow, getActual(fn), ...args);
};

/**
 * Expects `fn` or its value to not reject.
 * @param {() => Promise<any>} fn
 * @param {...any} [args]
 * @returns {Promise<void>}
 */
assert.doesNotReject = async function doesNotReject(fn, ...args) {
  expectsNoError(doesNotReject, await waitForActual(fn), ...args);
};

/**
 * Throws `value` if the value is not `null` or `undefined`.
 * @param {any} err
 * @returns {void}
 */
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    let message = 'ifError got unwanted exception: ';
    if (typeof err === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    const newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    const origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      const origStackStart = String.prototype.indexOf.call(origStack, '\n    at');
      if (origStackStart !== -1) {
        const originalFrames = String.prototype.split.call(
          String.prototype.slice.call(origStack, origStackStart + 1),
          '\n'
        );
        // Filter all frames existing in err.stack.
        let newFrames = String.prototype.split.call(newErr.stack, '\n');
        for (const errFrame of originalFrames) {
          // Find the first occurrence of the frame.
          const pos = Array.prototype.indexOf.call(newFrames, errFrame);
          if (pos !== -1) {
            // Only keep new frames.
            newFrames = Array.prototype.slice.call(newFrames, 0, pos);
            break;
          }
        }
        const stackStart = Array.prototype.join.call(newFrames, '\n');
        const stackEnd = Array.prototype.join.call(originalFrames, '\n');
        newErr.stack = `${stackStart}\n${stackEnd}`;
      }
    }

    throw newErr;
  }
};

function internalMatch(string, regexp, message, fn) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE(
      'regexp', 'RegExp', regexp
    );
  }
  const match = fn === assert.match;
  if (typeof string !== 'string' ||
    RegExp.prototype.exec.call(regexp, string) !== null !== match) {
    if (message instanceof Error) {
      throw message;
    }

    const generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ?
      'The ""string"" argument must be of type string. Received type ' +
      `${typeof string} (${inspect(string)})` :
      (match ?
        'The input did not match the regular expression ' :
        'The input was expected to not match the regular expression ') +
      `${inspect(regexp)}. Input:\n\n${inspect(string)}\n`);
    const err = new AssertionError({
      actual: string,
      expected: regexp,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

/**
 * Expects the `string` input to match the regular expression.
 * @param {string} string
 * @param {RegExp} regexp
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match);
};

/**
 * Expects the `string` input not to match the regular expression.
 * @param {string} string
 * @param {RegExp} regexp
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch);
};

assert.CallTracker = CallTracker;

// import snapshot from 'internal/assert/snapshot';
assert.snapshot = undefined;

/**
 * Expose a strict only variant of assert.
 * @param {...any} args
 * @returns {void}
 */
function strict(...args) {
  innerOk(strict, args.length, ...args);
}

assert.strict = Object.assign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});

assert.strict.strict = assert.strict;

export default assert;

export { AssertionError };
```"
"```javascript:modules\internal\fs\utils.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
""use strict"";

import { Buffer } from ""../../buffer"";
import {
  ERR_FS_EISDIR,
  ERR_FS_INVALID_SYMLINK_TYPE,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
  ERR_OUT_OF_RANGE,
  hideStackFrames,
  uvException,
} from ""../errors"";

import {
  isArrayBufferView,
  isBigUint64Array,
  isDate,
  isUint8Array,
} from ""../util/types"";
import { deprecate, once } from ""../util"";
import { toPathIfFileURL } from ""../url"";
import {
  validateAbortSignal,
  validateBoolean,
  validateFunction,
  validateInt32,
  validateInteger,
  validateObject,
  validateUint32,
} from ""../validators"";
import * as pathModule from ""../../path"";
const kType = Symbol(""type"");
const kStats = Symbol(""stats"");
import { assert } from ""../assert"";
import { lstat, lstatSync } from ""../fs"";
import { stat, statSync } from ""../fs"";
const isWindows = false;
import * as process from ""../../process"";

import {
  fs as fsConstants,
  os as osConstants,
} from ""../../internal_binding/constants"";

import * as errors from ""../errors""

const {
  F_OK = 0,
  W_OK = 0,
  R_OK = 0,
  X_OK = 0,
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
  O_APPEND,
  O_CREAT,
  O_EXCL,
  O_RDONLY,
  O_RDWR,
  O_SYNC,
  O_TRUNC,
  O_WRONLY,
  S_IFBLK,
  S_IFCHR,
  S_IFDIR,
  S_IFIFO,
  S_IFLNK,
  S_IFMT,
  S_IFREG,
  S_IFSOCK,
  UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION,
  UV_DIRENT_UNKNOWN,
  UV_DIRENT_FILE,
  UV_DIRENT_DIR,
  UV_DIRENT_LINK,
  UV_DIRENT_FIFO,
  UV_DIRENT_SOCKET,
  UV_DIRENT_CHAR,
  UV_DIRENT_BLOCK,
} = fsConstants;
const {
  errno: {
    EISDIR,
  },
} = osConstants;

// The access modes can be any of F_OK, R_OK, W_OK or X_OK. Some might not be
// available on specific systems. They can be used in combination as well
// (F_OK | R_OK | W_OK | X_OK).
const kMinimumAccessMode = Math.min(F_OK, W_OK, R_OK, X_OK);
const kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;

const kDefaultCopyMode = 0;
// The copy modes can be any of COPYFILE_EXCL, COPYFILE_FICLONE or
// COPYFILE_FICLONE_FORCE. They can be used in combination as well
// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).
const kMinimumCopyMode = Math.min(
  kDefaultCopyMode,
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
);
const kMaximumCopyMode = COPYFILE_EXCL |
  COPYFILE_FICLONE |
  COPYFILE_FICLONE_FORCE;

// Most platforms don't allow reads or writes >= 2 GB.
// See https://github.com/libuv/libuv/pull/1501.
const kIoMaxLength = 2 ** 31 - 1;

// Use 64kb in case the file type is not a regular file and thus do not know the
// actual file size. Increasing the value further results in more frequent over
// allocation for small files and consumes CPU time and memory that should be
// used else wise.
// Use up to 512kb per read otherwise to partition reading big files to prevent
// blocking other threads in case the available threads are all in use.
const kReadFileUnknownBufferLength = 64 * 1024;
const kReadFileBufferLength = 512 * 1024;

const kWriteFileMaxChunkSize = 512 * 1024;

export const kMaxUserId = 2 ** 32 - 1;

export function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    const reason = ""is invalid encoding"";
    throw new ERR_INVALID_ARG_VALUE(encoding, ""encoding"", reason);
  }
}

export class Dirent {
  constructor(name, type) {
    this.name = name;
    this[kType] = type;
  }

  isDirectory() {
    return this[kType] === UV_DIRENT_DIR;
  }

  isFile() {
    return this[kType] === UV_DIRENT_FILE;
  }

  isBlockDevice() {
    return this[kType] === UV_DIRENT_BLOCK;
  }

  isCharacterDevice() {
    return this[kType] === UV_DIRENT_CHAR;
  }

  isSymbolicLink() {
    return this[kType] === UV_DIRENT_LINK;
  }

  isFIFO() {
    return this[kType] === UV_DIRENT_FIFO;
  }

  isSocket() {
    return this[kType] === UV_DIRENT_SOCKET;
  }
}

class DirentFromStats extends Dirent {
  constructor(name, stats) {
    super(name, null);
    this[kStats] = stats;
  }
}

for (const name of Reflect.ownKeys(Dirent.prototype)) {
  if (name === ""constructor"") {
    continue;
  }
  DirentFromStats.prototype[name] = function () {
    return this[kStats][name]();
  };
}

export function copyObject(source) {
  const target = {};
  for (const key in source) {
    target[key] = source[key];
  }
  return target;
}

const bufferSep = Buffer.from(pathModule.sep ?? '/');

function join(path, name) {
  if (
    (typeof path === ""string"" || isUint8Array(path)) &&
    name === undefined
  ) {
    return path;
  }

  if (typeof path === ""string"" && isUint8Array(name)) {
    const pathBuffer = Buffer.from(pathModule.join(path, pathModule.sep));
    return Buffer.concat([pathBuffer, name]);
  }

  if (typeof path === ""string"" && typeof name === ""string"") {
    return pathModule.join(path, name);
  }

  if (isUint8Array(path) && isUint8Array(name)) {
    return Buffer.concat([path, bufferSep, name]);
  }

  throw new ERR_INVALID_ARG_TYPE(
    ""path"",
    [""string"", ""Buffer""],
    path,
  );
}

export function getDirents(path, { 0: names, 1: types }, callback) {
  let i;
  if (typeof callback === ""function"") {
    const len = names.length;
    let toFinish = 0;
    callback = once(callback);
    for (i = 0; i < len; i++) {
      const type = types[i];
      if (type === UV_DIRENT_UNKNOWN) {
        const name = names[i];
        const idx = i;
        toFinish++;
        let filepath;
        try {
          filepath = join(path, name);
        } catch (err) {
          callback(err);
          return;
        }
        lstat(filepath, (err, stats) => {
          if (err) {
            callback(err);
            return;
          }
          names[idx] = new DirentFromStats(name, stats);
          if (--toFinish === 0) {
            callback(null, names);
          }
        });
      } else {
        names[i] = new Dirent(names[i], types[i]);
      }
    }
    if (toFinish === 0) {
      callback(null, names);
    }
  } else {
    const len = names.length;
    for (i = 0; i < len; i++) {
      names[i] = getDirent(path, names[i], types[i]);
    }
    return names;
  }
}

export function getDirent(path, name, type, callback) {
  if (typeof callback === ""function"") {
    if (type === UV_DIRENT_UNKNOWN) {
      let filepath;
      try {
        filepath = join(path, name);
      } catch (err) {
        callback(err);
        return;
      }
      lstat(filepath, (err, stats) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, new DirentFromStats(name, stats));
      });
    } else {
      callback(null, new Dirent(name, type));
    }
  } else if (type === UV_DIRENT_UNKNOWN) {
    const stats = lstatSync(join(path, name));
    return new DirentFromStats(name, stats);
  } else {
    return new Dirent(name, type);
  }
}

export function getOptions(options, defaultOptions) {
  if (
    options === null || options === undefined ||
    typeof options === ""function""
  ) {
    return defaultOptions;
  }

  if (typeof options === ""string"") {
    defaultOptions = { ...defaultOptions };
    defaultOptions.encoding = options;
    options = defaultOptions;
  } else if (typeof options !== ""object"") {
    throw new ERR_INVALID_ARG_TYPE(""options"", [""string"", ""Object""], options);
  }

  if (options.encoding !== ""buffer"") {
    assertEncoding(options.encoding);
  }

  if (options.signal !== undefined) {
    validateAbortSignal(options.signal, ""options.signal"");
  }
  return options;
}

/**
 * @param {InternalFSBinding.FSSyncContext} ctx
 */
export function handleErrorFromBinding(ctx) {
  if (ctx.errno !== undefined) { // libuv error numbers
    const err = uvException(ctx);
    Error.captureStackTrace(err, handleErrorFromBinding);
    throw err;
  }
  if (ctx.error !== undefined) { // Errors created in C++ land.
    // TODO(joyeecheung): currently, ctx.error are encoding errors
    // usually caused by memory problems. We need to figure out proper error
    // code(s) for this.
    Error.captureStackTrace(ctx.error, handleErrorFromBinding);
    throw ctx.error;
  }
}

// Check if the path contains null types if it is a string nor Uint8Array,
// otherwise return silently.
export const nullCheck = hideStackFrames(
  (path, propName, throwError = true) => {
    const pathIsString = typeof path === ""string"";
    const pathIsUint8Array = isUint8Array(path);

    // We can only perform meaningful checks on strings and Uint8Arrays.
    if (
      (!pathIsString && !pathIsUint8Array) ||
      (pathIsString && !path.includes(""\u0000"")) ||
      (pathIsUint8Array && !path.includes(0))
    ) {
      return;
    }

    const err = new ERR_INVALID_ARG_VALUE(
      propName,
      path,
      ""must be a string or Uint8Array without null bytes"",
    );
    if (throwError) {
      throw err;
    }
    return err;
  },
);

export function preprocessSymlinkDestination(path, type, linkPath) {
  if (!isWindows) {
    // No preprocessing is needed on Unix.
    return path;
  }
  path = """" + path;
  if (type === ""junction"") {
    // Junctions paths need to be absolute and \\?\-prefixed.
    // A relative target is relative to the link's parent directory.
    path = pathModule.resolve(linkPath, "".."", path);
    return pathModule.toNamespacedPath(path);
  }
  if (pathModule.isAbsolute(path)) {
    // If the path is absolute, use the \\?\-prefix to enable long filenames
    return pathModule.toNamespacedPath(path);
  }
  // Windows symlinks don't tolerate forward slashes.
  return path.replace(/\//g, ""\\"");
}

// Constructor for file stats.
function StatsBase(
  dev,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  blksize,
  ino,
  size,
  blocks,
) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
}

StatsBase.prototype.isDirectory = function () {
  return this._checkModeProperty(S_IFDIR);
};

StatsBase.prototype.isFile = function () {
  return this._checkModeProperty(S_IFREG);
};

StatsBase.prototype.isBlockDevice = function () {
  return this._checkModeProperty(S_IFBLK);
};

StatsBase.prototype.isCharacterDevice = function () {
  return this._checkModeProperty(S_IFCHR);
};

StatsBase.prototype.isSymbolicLink = function () {
  return this._checkModeProperty(S_IFLNK);
};

StatsBase.prototype.isFIFO = function () {
  return this._checkModeProperty(S_IFIFO);
};

StatsBase.prototype.isSocket = function () {
  return this._checkModeProperty(S_IFSOCK);
};

const kNsPerMsBigInt = 10n ** 6n;
const kNsPerSecBigInt = 10n ** 9n;
const kMsPerSec = 10 ** 3;
const kNsPerMs = 10 ** 6;
function msFromTimeSpec(sec, nsec) {
  return sec * kMsPerSec + nsec / kNsPerMs;
}

function nsFromTimeSpecBigInt(sec, nsec) {
  return sec * kNsPerSecBigInt + nsec;
}

// The Date constructor performs Math.floor() to the timestamp.
// https://www.ecma-international.org/ecma-262/#sec-timeclip
// Since there may be a precision loss when the timestamp is
// converted to a floating point number, we manually round
// the timestamp here before passing it to Date().
// Refs: https://github.com/nodejs/node/pull/12607
function dateFromMs(ms) {
  return new Date(Number(ms) + 0.5);
}

export function BigIntStats(
  dev,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  blksize,
  ino,
  size,
  blocks,
  atimeNs,
  mtimeNs,
  ctimeNs,
  birthtimeNs,
) {
  Reflect.apply(StatsBase, this, [
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks,
  ]);

  this.atimeMs = atimeNs / kNsPerMsBigInt;
  this.mtimeMs = mtimeNs / kNsPerMsBigInt;
  this.ctimeMs = ctimeNs / kNsPerMsBigInt;
  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
  this.atimeNs = atimeNs;
  this.mtimeNs = mtimeNs;
  this.ctimeNs = ctimeNs;
  this.birthtimeNs = birthtimeNs;
  this.atime = dateFromMs(this.atimeMs);
  this.mtime = dateFromMs(this.mtimeMs);
  this.ctime = dateFromMs(this.ctimeMs);
  this.birthtime = dateFromMs(this.birthtimeMs);
}

Object.setPrototypeOf(BigIntStats.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats, StatsBase);

BigIntStats.prototype._checkModeProperty = function (property) {
  if (
    isWindows && (property === S_IFIFO || property === S_IFBLK ||
      property === S_IFSOCK)
  ) {
    return false; // Some types are not available on Windows
  }
  return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};

export function Stats(
  dev,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  blksize,
  ino,
  size,
  blocks,
  atimeMs,
  mtimeMs,
  ctimeMs,
  birthtimeMs,
) {
  StatsBase.call(
    this,
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks,
  );
  this.atimeMs = atimeMs;
  this.mtimeMs = mtimeMs;
  this.ctimeMs = ctimeMs;
  this.birthtimeMs = birthtimeMs;
  this.atime = dateFromMs(atimeMs);
  this.mtime = dateFromMs(mtimeMs);
  this.ctime = dateFromMs(ctimeMs);
  this.birthtime = dateFromMs(birthtimeMs);
}

Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);

// HACK: Workaround for https://github.com/standard-things/esm/issues/821.
// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.
Stats.prototype.isFile = StatsBase.prototype.isFile;

Stats.prototype._checkModeProperty = function (property) {
  if (
    isWindows && (property === S_IFIFO || property === S_IFBLK ||
      property === S_IFSOCK)
  ) {
    return false; // Some types are not available on Windows
  }
  return (this.mode & S_IFMT) === property;
};

/**
 * @param {Float64Array | BigUint64Array} stats
 * @param {number} offset
 * @returns
 */
export function getStatsFromBinding(stats, offset = 0) {
  if (isBigUint64Array(stats)) {
    return new BigIntStats(
      stats[0 + offset],
      stats[1 + offset],
      stats[2 + offset],
      stats[3 + offset],
      stats[4 + offset],
      stats[5 + offset],
      stats[6 + offset],
      stats[7 + offset],
      stats[8 + offset],
      stats[9 + offset],
      nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]),
      nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]),
      nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]),
      nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]),
    );
  }
  return new Stats(
    stats[0 + offset],
    stats[1 + offset],
    stats[2 + offset],
    stats[3 + offset],
    stats[4 + offset],
    stats[5 + offset],
    stats[6 + offset],
    stats[7 + offset],
    stats[8 + offset],
    stats[9 + offset],
    msFromTimeSpec(stats[10 + offset], stats[11 + offset]),
    msFromTimeSpec(stats[12 + offset], stats[13 + offset]),
    msFromTimeSpec(stats[14 + offset], stats[15 + offset]),
    msFromTimeSpec(stats[16 + offset], stats[17 + offset]),
  );
}

export function stringToFlags(flags, name = ""flags"") {
  if (typeof flags === ""number"") {
    validateInt32(flags, name);
    return flags;
  }

  if (flags == null) {
    return O_RDONLY;
  }

  switch (flags) {
    case ""r"":
      return O_RDONLY;
    case ""rs"": // Fall through.
    case ""sr"":
      return O_RDONLY | O_SYNC;
    case ""r+"":
      return O_RDWR;
    case ""rs+"": // Fall through.
    case ""sr+"":
      return O_RDWR | O_SYNC;

    case ""w"":
      return O_TRUNC | O_CREAT | O_WRONLY;
    case ""wx"": // Fall through.
    case ""xw"":
      return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;

    case ""w+"":
      return O_TRUNC | O_CREAT | O_RDWR;
    case ""wx+"": // Fall through.
    case ""xw+"":
      return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;

    case ""a"":
      return O_APPEND | O_CREAT | O_WRONLY;
    case ""ax"": // Fall through.
    case ""xa"":
      return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
    case ""as"": // Fall through.
    case ""sa"":
      return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;

    case ""a+"":
      return O_APPEND | O_CREAT | O_RDWR;
    case ""ax+"": // Fall through.
    case ""xa+"":
      return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
    case ""as+"": // Fall through.
    case ""sa+"":
      return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
  }

  throw new ERR_INVALID_ARG_VALUE(""flags"", flags);
}

export const stringToSymlinkType = hideStackFrames((type) => {
  let flags = 0;
  if (typeof type === ""string"") {
    switch (type) {
      case ""dir"":
        flags |= UV_FS_SYMLINK_DIR;
        break;
      case ""junction"":
        flags |= UV_FS_SYMLINK_JUNCTION;
        break;
      case ""file"":
        break;
      default:
        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);
    }
  }
  return flags;
});

// converts Date or number to a fractional UNIX timestamp
export function toUnixTimestamp(time, name = ""time"") {
  // eslint-disable-next-line eqeqeq
  if (typeof time === ""string"" && +time == time) {
    return +time;
  }
  if (Number.isFinite(time)) {
    if (time < 0) {
      return Date.now() / 1000;
    }
    return time;
  }
  if (isDate(time)) {
    // Convert to 123.456 UNIX timestamp
    return Date.getTime(time) / 1000;
  }
  throw new ERR_INVALID_ARG_TYPE(name, [""Date"", ""Time in seconds""], time);
}

export const validateOffsetLengthRead = hideStackFrames(
  (offset, length, bufferLength) => {
    if (offset < 0) {
      throw new ERR_OUT_OF_RANGE(""offset"", "">= 0"", offset);
    }
    if (length < 0) {
      throw new ERR_OUT_OF_RANGE(""length"", "">= 0"", length);
    }
    if (offset + length > bufferLength) {
      throw new ERR_OUT_OF_RANGE(
        ""length"",
        `<= ${bufferLength - offset}`,
        length,
      );
    }
  },
);

export const validateOffsetLengthWrite = hideStackFrames(
  (offset, length, byteLength) => {
    if (offset > byteLength) {
      throw new ERR_OUT_OF_RANGE(""offset"", `<= ${byteLength}`, offset);
    }

    if (length > byteLength - offset) {
      throw new ERR_OUT_OF_RANGE(""length"", `<= ${byteLength - offset}`, length);
    }

    if (length < 0) {
      throw new ERR_OUT_OF_RANGE(""length"", "">= 0"", length);
    }

    validateInt32(length, ""length"", 0);
  },
);

export const validatePath = hideStackFrames((path, propName = ""path"") => {
  if (typeof path !== ""string"" && !isUint8Array(path)) {
    throw new ERR_INVALID_ARG_TYPE(propName, [""string"", ""Buffer"", ""URL""], path);
  }

  const err = nullCheck(path, propName, false);

  if (err !== undefined) {
    throw err;
  }
});

export const getValidatedPath = hideStackFrames(
  (fileURLOrPath, propName = ""path"") => {
    const path = toPathIfFileURL(fileURLOrPath);
    validatePath(path, propName);
    return typeof(path) === ""string"" ? path : path.toString();
  },
);

export const getValidatedFd = hideStackFrames((fd, propName = ""fd"") => {
  if (Object.is(fd, -0)) {
    return 0;
  }

  validateInt32(fd, propName, 0);

  return fd;
});

export const validateBufferArray = hideStackFrames(
  (buffers, propName = ""buffers"") => {
    if (!Array.isArray(buffers)) {
      throw new ERR_INVALID_ARG_TYPE(propName, ""ArrayBufferView[]"", buffers);
    }

    for (let i = 0; i < buffers.length; i++) {
      if (!isArrayBufferView(buffers[i])) {
        throw new ERR_INVALID_ARG_TYPE(propName, ""ArrayBufferView[]"", buffers);
      }
    }

    return buffers;
  },
);

let nonPortableTemplateWarn = true;

export function warnOnNonPortableTemplate(template) {
  // Template strings passed to the mkdtemp() family of functions should not
  // end with 'X' because they are handled inconsistently across platforms.
  if (nonPortableTemplateWarn && template.endsWith(""X"")) {
    process.emitWarning(
      ""mkdtemp() templates ending with X are not portable. "" +
      ""For details see: https://nodejs.org/api/fs.html"",
    );
    nonPortableTemplateWarn = false;
  }
}

const defaultCpOptions = {
  dereference: false,
  errorOnExist: false,
  filter: undefined,
  force: true,
  preserveTimestamps: false,
  recursive: false,
};

const defaultRmOptions = {
  recursive: false,
  force: false,
  retryDelay: 100,
  maxRetries: 0,
};

const defaultRmdirOptions = {
  retryDelay: 100,
  maxRetries: 0,
  recursive: false,
};

export const validateCpOptions = hideStackFrames((options) => {
  if (options === undefined) {
    return { ...defaultCpOptions };
  }
  validateObject(options, ""options"");
  options = { ...defaultCpOptions, ...options };
  validateBoolean(options.dereference, ""options.dereference"");
  validateBoolean(options.errorOnExist, ""options.errorOnExist"");
  validateBoolean(options.force, ""options.force"");
  validateBoolean(options.preserveTimestamps, ""options.preserveTimestamps"");
  validateBoolean(options.recursive, ""options.recursive"");
  if (options.filter !== undefined) {
    validateFunction(options.filter, ""options.filter"");
  }
  return options;
});

export const validateRmOptions = hideStackFrames(
  (path, options, expectDir, cb) => {
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, ""options.force"");

    stat(path, (err, stats) => {
      if (err) {
        if (options.force && err.code === ""ENOENT"") {
          return cb(null, options);
        }
        return cb(err, options);
      }

      if (expectDir && !stats.isDirectory()) {
        return cb(false);
      }

      if (stats.isDirectory() && !options.recursive) {
        return cb(
          new ERR_FS_EISDIR({
            code: ""EISDIR"",
            message: ""is a directory"",
            path,
            syscall: ""rm"",
            errno: EISDIR,
          }),
        );
      }
      return cb(null, options);
    });
  },
);

export const validateRmOptionsSync = hideStackFrames(
  (path, options, expectDir) => {
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, ""options.force"");

    if (!options.force || expectDir || !options.recursive) {
      const isDirectory = statSync(path, { throwIfNoEntry: !options.force })
        ?.isDirectory();

      if (expectDir && !isDirectory) {
        return false;
      }

      if (isDirectory && !options.recursive) {
        throw new ERR_FS_EISDIR({
          code: ""EISDIR"",
          message: ""is a directory"",
          path,
          syscall: ""rm"",
          errno: EISDIR,
        });
      }
    }

    return options;
  },
);

let recursiveRmdirWarned = process.noDeprecation;
export function emitRecursiveRmdirWarning() {
  if (!recursiveRmdirWarned) {
    process.emitWarning(
      ""In future versions of Node.js, fs.rmdir(path, { recursive: true }) "" +
      ""will be removed. Use fs.rm(path, { recursive: true }) instead"",
      ""DeprecationWarning"",
      ""DEP0147"",
    );
    recursiveRmdirWarned = true;
  }
}

export const validateRmdirOptions = hideStackFrames(
  (options, defaults = defaultRmdirOptions) => {
    if (options === undefined) {
      return defaults;
    }
    validateObject(options, ""options"");

    options = { ...defaults, ...options };

    validateBoolean(options.recursive, ""options.recursive"");
    validateInt32(options.retryDelay, ""options.retryDelay"", 0);
    validateUint32(options.maxRetries, ""options.maxRetries"");

    return options;
  },
);

export const getValidMode = hideStackFrames((mode, type) => {
  let min = kMinimumAccessMode;
  let max = kMaximumAccessMode;
  let def = F_OK;
  if (type === ""copyFile"") {
    min = kMinimumCopyMode;
    max = kMaximumCopyMode;
    def = mode || kDefaultCopyMode;
  } else {
    assert(type === ""access"");
  }
  if (mode == null) {
    return def;
  }
  if (Number.isInteger(mode) && mode >= min && mode <= max) {
    return mode;
  }
  if (typeof mode !== ""number"") {
    throw new ERR_INVALID_ARG_TYPE(""mode"", ""integer"", mode);
  }
  throw new ERR_OUT_OF_RANGE(
    ""mode"",
    `an integer >= ${min} && <= ${max}`,
    mode,
  );
});

export const validateStringAfterArrayBufferView = hideStackFrames(
  (buffer, name) => {
    if (typeof buffer === ""string"") {
      return;
    }

    if (
      typeof buffer === ""object"" &&
      buffer !== null &&
      typeof buffer.toString === ""function"" &&
      Object.prototype.hasOwnProperty.call(buffer, ""toString"")
    ) {
      return;
    }

    throw new ERR_INVALID_ARG_TYPE(
      name,
      [""string"", ""Buffer"", ""TypedArray"", ""DataView""],
      buffer,
    );
  },
);

export const validatePosition = hideStackFrames((position) => {
  if (typeof position === ""number"") {
    validateInteger(position, ""position"");
  } else if (typeof position === ""bigint"") {
    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
      throw new ERR_OUT_OF_RANGE(
        ""position"",
        `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`,
        position,
      );
    }
  } else {
    throw new ERR_INVALID_ARG_TYPE(""position"", [""integer"", ""bigint""], position);
  }
});

export const realpathCacheKey = Symbol(""realpathCacheKey"");
export const constants = {
  kIoMaxLength,
  kMaxUserId,
  kReadFileBufferLength,
  kReadFileUnknownBufferLength,
  kWriteFileMaxChunkSize,
};

export const showStringCoercionDeprecation = deprecate(
  () => { },
  ""Implicit coercion of objects with own toString property is deprecated."",
  ""DEP0162"",
);


export const validateEncoding = hideStackFrames((value, name) => {
  let exist = [
      'utf8', 'utf-8', '', 'hex', 'base64', 'latin1', 'usc2', 'utf16le', 'ascii', 'base64url'
  ].indexOf(value);

  if (exist < 0) {
      throw new errors.ERR_INVALID_ARG_VALUE(name, value);
  }
})

export default {
  constants,
  assertEncoding,
  BigIntStats, // for testing
  copyObject,
  Dirent,
  emitRecursiveRmdirWarning,
  getDirent,
  getDirents,
  getOptions,
  getValidatedFd,
  getValidatedPath,
  getValidMode,
  handleErrorFromBinding,
  kMaxUserId,
  nullCheck,
  preprocessSymlinkDestination,
  realpathCacheKey,
  getStatsFromBinding,
  showStringCoercionDeprecation,
  stringToFlags,
  stringToSymlinkType,
  Stats,
  toUnixTimestamp,
  validateBufferArray,
  validateCpOptions,
  validateOffsetLengthRead,
  validateOffsetLengthWrite,
  validatePath,
  validatePosition,
  validateRmOptions,
  validateRmOptionsSync,
  validateRmdirOptions,
  validateStringAfterArrayBufferView,
  warnOnNonPortableTemplate,
  validateEncoding
};
```"
"```javascript:modules\internal\streams\writable.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { addAbortSignalNoValidate } from ""./add-abort-signal.js"";
import { Buffer } from ""buffer"";
import { getDefaultHighWaterMark, getHighWaterMark } from ""./state.js"";
import { isUint8Array } from ""../util/types.js"";
import { Stream } from ""./legacy.js"";
import {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING,
} from ""../errors.js"";
import destroyImpl from ""./destroy.js"";
import EE from ""events"";
import Readable from ""./readable.js"";

function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(
        chunk.buffer,
        chunk.byteOffset,
        chunk.byteLength,
    );
}

const { errorOrDestroy } = destroyImpl;

// This function prevents a circular dependency with Duplex
// This checks if the passed stream is an instance of a Readable stream
// and one of its prototypes is named Duplex
function isDuplexStream(maybe_duplex) {
    const isReadable = Readable.prototype.isPrototypeOf(maybe_duplex);

    let prototype = maybe_duplex;
    let isDuplex = false;
    while (prototype?.constructor && prototype.constructor.name !== ""Object"") {
        if (prototype.constructor.name === ""Duplex"") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }

    return isReadable && isDuplex;
}


function nop() { }

const kOnFinished = Symbol(""kOnFinished"");

function WritableState(options, stream, isDuplex) {
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== ""boolean"") {
        isDuplex = isDuplexStream(stream);
    }

    // Object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!(options && options.objectMode);

    if (isDuplex) {
        this.objectMode = this.objectMode ||
            !!(options && options.writableObjectMode);
    }

    // The point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write().
    this.highWaterMark = options
        ? getHighWaterMark(this, options, ""writableHighWaterMark"", isDuplex)
        : getDefaultHighWaterMark(false);

    // if _final has been called.
    this.finalCalled = false;

    // drain event flag.
    this.needDrain = false;
    // At the start of calling end()
    this.ending = false;
    // When end() has been called, and returned.
    this.ended = false;
    // When 'finish' is emitted.
    this.finished = false;

    // Has it been destroyed
    this.destroyed = false;

    // Should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = (options && options.defaultEncoding) || ""utf8"";

    // Not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;

    // A flag to see when we're in the middle of a write.
    this.writing = false;

    // When true all writes will be buffered until .uncork() call.
    this.corked = 0;

    // A flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until ""later"" should generally also
    // not happen before the first write call.
    this.sync = true;

    // A flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;

    // The callback that's passed to _write(chunk, cb).
    this.onwrite = onwrite.bind(undefined, stream);

    // The callback that the user supplies to write(chunk, encoding, cb).
    this.writecb = null;

    // The amount that is being written when _write is called.
    this.writelen = 0;

    // Storage for data passed to the afterWrite() callback in case of
    // synchronous _write() completion.
    this.afterWriteTickInfo = null;

    resetBuffer(this);

    // Number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted.
    this.pendingcb = 0;

    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    this.constructed = true;

    // Emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams.
    this.prefinished = false;

    // True if the error was already emitted and should not be thrown again.
    this.errorEmitted = false;

    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = !options || options.emitClose !== false;

    // Should .destroy() be called after 'finish' (and potentially 'end').
    this.autoDestroy = !options || options.autoDestroy !== false;

    // Indicates whether the stream has errored. When true all write() calls
    // should return false. This is needed since when autoDestroy
    // is disabled we need a way to tell whether the stream has failed.
    this.errored = null;

    // Indicates whether the stream has finished destroying.
    this.closed = false;

    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    this.closeEmitted = false;

    this[kOnFinished] = [];
}

function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
}

WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};

Object.defineProperty(WritableState.prototype, ""bufferedRequestCount"", {
    get() {
        return this.buffered.length - this.bufferedIndex;
    },
});

function Writable(options) {
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.

    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.

    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5.
    const isDuplex = isDuplexStream(this);

    if (
        !isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)
    ) {
        return new Writable(options);
    }

    this._writableState = new WritableState(options, this, isDuplex);

    if (options) {
        if (typeof options.write === ""function"") {
            this._write = options.write;
        }

        if (typeof options.writev === ""function"") {
            this._writev = options.writev;
        }

        if (typeof options.destroy === ""function"") {
            this._destroy = options.destroy;
        }

        if (typeof options.final === ""function"") {
            this._final = options.final;
        }

        if (typeof options.construct === ""function"") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }

    Stream.call(this, options);

    destroyImpl.construct(this, () => {
        const state = this._writableState;

        if (!state.writing) {
            clearBuffer(this, state);
        }

        finishMaybe(this, state);
    });
}

Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);

Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;

        return object && object._writableState instanceof WritableState;
    },
});

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;

    if (typeof encoding === ""function"") {
        cb = encoding;
        encoding = state.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state.defaultEncoding;
        } else if (encoding !== ""buffer"" && !Buffer.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== ""function"") {
            cb = nop;
        }
    }

    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state.objectMode) {
        if (typeof chunk === ""string"") {
            if (state.decodeStrings !== false) {
                chunk = Buffer.from(chunk, encoding);
                encoding = ""buffer"";
            }
        } else if (chunk instanceof Buffer) {
            encoding = ""buffer"";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = ""buffer"";
        } else {
            throw new ERR_INVALID_ARG_TYPE(
                ""chunk"",
                [""string"", ""Buffer"", ""Uint8Array""],
                chunk,
            );
        }
    }

    let err;
    if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED(""write"");
    }

    if (err) {
        nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
}

Writable.prototype.write = function (chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};

Writable.prototype.cork = function () {
    this._writableState.corked++;
};

Writable.prototype.uncork = function () {
    const state = this._writableState;

    if (state.corked) {
        state.corked--;

        if (!state.writing) {
            clearBuffer(this, state);
        }
    }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === ""string"") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};

// If we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;

    state.length += len;

    // stream._write resets state.length
    const ret = state.length < state.highWaterMark;
    // We must ensure that previous needDrain will not be reset to false.
    if (!ret) {
        state.needDrain = true;
    }

    if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({ chunk, encoding, callback });
        if (state.allBuffers && encoding !== ""buffer"") {
            state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
            state.allNoop = false;
        }
    } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
    }

    // Return false if errored or destroyed in order to break
    // any synchronous while(stream.write(data)) loops.
    return ret && !state.errored && !state.destroyed;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) {
        state.onwrite(new ERR_STREAM_DESTROYED(""write""));
    } else if (writev) {
        stream._writev(chunk, state.onwrite);
    } else {
        stream._write(chunk, encoding, state.onwrite);
    }
    state.sync = false;
}

function onwriteError(stream, state, er, cb) {
    --state.pendingcb;

    cb(er);
    // Ensure callbacks are invoked even when autoDestroy is
    // not enabled. Passing `er` here doesn't make sense since
    // it's related to one specific write, not to the buffered
    // writes.
    errorBuffer(state);
    // This can emit error, but error must always follow cb.
    errorOrDestroy(stream, er);
}

function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;

    if (typeof cb !== ""function"") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }

    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;

    if (er) {
        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
        er.stack; // eslint-disable-line no-unused-expressions

        if (!state.errored) {
            state.errored = er;
        }

        // In case of duplex streams we need to notify the readable side of the
        // error.
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }

        if (sync) {
            nextTick(onwriteError, stream, state, er, cb);
        } else {
            onwriteError(stream, state, er, cb);
        }
    } else {
        if (state.buffered.length > state.bufferedIndex) {
            clearBuffer(stream, state);
        }

        if (sync) {
            // It is a common case that the callback passed to .write() is always
            // the same. In that case, we do not schedule a new nextTick(), but
            // rather just increase a counter, to improve performance and avoid
            // memory allocations.
            if (
                state.afterWriteTickInfo !== null &&
                state.afterWriteTickInfo.cb === cb
            ) {
                state.afterWriteTickInfo.count++;
            } else {
                state.afterWriteTickInfo = { count: 1, cb, stream, state };
                nextTick(afterWriteTick, state.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state, 1, cb);
        }
    }
}

function afterWriteTick({ stream, state, count, cb }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
}

function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&
        state.needDrain;
    if (needDrain) {
        state.needDrain = false;
        stream.emit(""drain"");
    }

    while (count-- > 0) {
        state.pendingcb--;
        cb();
    }

    if (state.destroyed) {
        errorBuffer(state);
    }

    finishMaybe(stream, state);
}

// If there's something in the buffer waiting, then invoke callbacks.
function errorBuffer(state) {
    if (state.writing) {
        return;
    }

    for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(new ERR_STREAM_DESTROYED(""write""));
    }

    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](new ERR_STREAM_DESTROYED(""end""));
    }

    resetBuffer(state);
}

// If there's something in the buffer waiting, then process it.
function clearBuffer(stream, state) {
    if (
        state.corked ||
        state.bufferProcessing ||
        state.destroyed ||
        !state.constructed
    ) {
        return;
    }

    const { buffered, bufferedIndex, objectMode } = state;
    const bufferedLength = buffered.length - bufferedIndex;

    if (!bufferedLength) {
        return;
    }

    let i = bufferedIndex;

    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;

        const callback = state.allNoop ? nop : (err) => {
            for (let n = i; n < buffered.length; ++n) {
                buffered[n].callback(err);
            }
        };
        // Make a copy of `buffered` if it's going to be used by `callback` above,
        // since `doWrite` will mutate the array.
        const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
        chunks.allBuffers = state.allBuffers;

        doWrite(stream, state, true, state.length, chunks, """", callback);

        resetBuffer(state);
    } else {
        do {
            const { chunk, encoding, callback } = buffered[i];
            buffered[i++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);

        if (i === buffered.length) {
            resetBuffer(state);
        } else if (i > 256) {
            buffered.splice(0, i);
            state.bufferedIndex = 0;
        } else {
            state.bufferedIndex = i;
        }
    }
    state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
    if (this._writev) {
        this._writev([{ chunk, encoding }], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED(""_write()"");
    }
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
    const state = this._writableState;

    if (typeof chunk === ""function"") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === ""function"") {
        cb = encoding;
        encoding = null;
    }

    let err;

    if (chunk !== null && chunk !== undefined) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error) {
            err = ret;
        }
    }

    // .end() fully uncorks.
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }

    if (err) {
        // Do nothing...
    } else if (!state.errored && !state.ending) {
        // This is forgiving in terms of unnecessary calls to end() and can hide
        // logic errors. However, usually such errors are harmless and causing a
        // hard error can be disproportionately destructive. It is not always
        // trivial for the user to determine whether end() needs to be called
        // or not.

        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
    } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED(""end"");
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED(""end"");
    }

    if (typeof cb === ""function"") {
        if (err || state.finished) {
            nextTick(cb, err);
        } else {
            state[kOnFinished].push(cb);
        }
    }

    return this;
};

function needFinish(state) {
    return (state.ending &&
        state.constructed &&
        state.length === 0 &&
        !state.errored &&
        state.buffered.length === 0 &&
        !state.finished &&
        !state.writing &&
        !state.errorEmitted &&
        !state.closeEmitted);
}

function callFinal(stream, state) {
    let called = false;

    function onFinish(err) {
        if (called) {
            errorOrDestroy(stream, err ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;

        state.pendingcb--;
        if (err) {
            const onfinishCallbacks = state[kOnFinished].splice(0);
            for (let i = 0; i < onfinishCallbacks.length; i++) {
                onfinishCallbacks[i](err);
            }
            errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
            state.prefinished = true;
            stream.emit(""prefinish"");
            // Backwards compat. Don't check state.sync here.
            // Some streams assume 'finish' will be emitted
            // asynchronously relative to _final callback.
            state.pendingcb++;
            nextTick(finish, stream, state);
        }
    }

    state.sync = true;
    state.pendingcb++;

    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    function () {
                        nextTick(onFinish, null);
                    },
                    function (err) {
                        nextTick(onFinish, err);
                    },
                );
            }
        }
    } catch (err) {
        onFinish(stream, state, err);
    }

    state.sync = false;
}

function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === ""function"" && !state.destroyed) {
            state.finalCalled = true;
            callFinal(stream, state);
        } else {
            state.prefinished = true;
            stream.emit(""prefinish"");
        }
    }
}

function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0 && needFinish(state)) {
            state.pendingcb++;
            if (sync) {
                nextTick(finish, stream, state);
            } else {
                finish(stream, state);
            }
        }
    }
}

function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;

    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
    }

    stream.emit(""finish"");

    if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well.
        const rState = stream._readableState;
        const autoDestroy = !rState || (
            rState.autoDestroy &&
            // We don't expect the readable to ever 'end'
            // if readable is explicitly set to false.
            (rState.endEmitted || rState.readable === false)
        );
        if (autoDestroy) {
            stream.destroy();
        }
    }
}

Object.defineProperties(Writable.prototype, {
    destroyed: {
        get() {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
            // Backward compatibility, the user is explicitly managing destroyed.
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        },
    },

    writable: {
        get() {
            const w = this._writableState;
            // w.writable === false means that this is part of a Duplex stream
            // where the writable side was disabled upon construction.
            // Compat. The user might manually disable writable side through
            // deprecated setter.
            return !!w && w.writable !== false && !w.destroyed && !w.errored &&
                !w.ending && !w.ended;
        },
        set(val) {
            // Backwards compatible.
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        },
    },

    writableFinished: {
        get() {
            return this._writableState ? this._writableState.finished : false;
        },
    },

    writableObjectMode: {
        get() {
            return this._writableState ? this._writableState.objectMode : false;
        },
    },

    writableBuffer: {
        get() {
            return this._writableState && this._writableState.getBuffer();
        },
    },

    writableEnded: {
        get() {
            return this._writableState ? this._writableState.ending : false;
        },
    },

    writableNeedDrain: {
        get() {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        },
    },

    writableHighWaterMark: {
        get() {
            return this._writableState && this._writableState.highWaterMark;
        },
    },

    writableCorked: {
        get() {
            return this._writableState ? this._writableState.corked : 0;
        },
    },

    writableLength: {
        get() {
            return this._writableState && this._writableState.length;
        },
    },
});

const destroy = destroyImpl.destroy;
Writable.prototype.destroy = function (err, cb) {
    const state = this._writableState;

    // Invoke pending callbacks.
    if (
        !state.destroyed &&
        (state.bufferedIndex < state.buffered.length ||
            state[kOnFinished].length)
    ) {
        nextTick(errorBuffer, state);
    }

    destroy.call(this, err, cb);
    return this;
};

Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
    cb(err);
};

Writable.prototype[EE.captureRejectionSymbol] = function (err) {
    this.destroy(err);
};

Writable.WritableState = WritableState;

export default Writable;
export { Writable, WritableState };
```"
"```javascript:test\fs\test-fs-cp.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import { mustCall, mustNotMutateObjectDeep } from '../common';

import assert from 'assert';
import fs from 'fs';
const {
  cp,
  cpSync,
  lstatSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  readlinkSync,
  symlinkSync,
  statSync,
  writeFileSync,
} = fs;
// import net from 'net';
import { join } from 'path';
import { pathToFileURL } from 'url';
import process from 'process';

const setTimeoutAsync = (timeout, val) => {
  print(""setTimeoutAsync"", timeout)
  return new Promise((res, rej) => {
    setTimeout(() => {
      res(val);
    }, timeout);
  })
}

const isWindows = process.platform === 'win32';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

let dirc = 0;
function nextdir() {
  return join(tmpdir.path, `copy_${++dirc}`);
}

// Synchronous implementation of copy.

// It copies a nested folder structure with files and folders.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assertDirEquivalent(src, dest);
}

// It does not throw errors when directory is copied over and force is false.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'README.md'), 'hello world', 'utf8');
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  const initialStat = lstatSync(join(dest, 'README.md'));
  cpSync(src, dest, mustNotMutateObjectDeep({ force: false, recursive: true }));
  // File should not have been copied over, so access times will be identical:
  assertDirEquivalent(src, dest);
  const finalStat = lstatSync(join(dest, 'README.md'));
  assert.strictEqual(finalStat.ctime.getTime(), initialStat.ctime.getTime());
}

// It overwrites existing files if force is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'README.md'), '# Goodbye', 'utf8');
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assertDirEquivalent(src, dest);
  const content = readFileSync(join(dest, 'README.md'), 'utf8');
  assert.strictEqual(content.trim(), '# Hello');
}

// It does not fail if the same directory is copied to dest twice,
// when dereference is true, and force is false (fails silently).
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const destFile = join(dest, 'a/b/README2.md');
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  const stat = lstatSync(destFile);
  assert(stat.isFile());
}

// path_readlink is unusable in wasmedge, so skip the tests about symlink
/*
// It copies file itself, rather than symlink, when dereference is true.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync(join(src, 'foo.js'), join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  const destFile = join(dest, 'foo.js');

  cpSync(join(src, 'bar.js'), destFile, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  const stat = lstatSync(destFile);
  assert(stat.isFile());
}


// It throws error when verbatimSymlinks is not a boolean.
{
  const src = './test/fixtures/copy/kitchen-sink';
  [1, [], {}, null, 1n, undefined, null, Symbol(), '', () => { }]
    .forEach((verbatimSymlinks) => {
      assert.throws(
        () => cpSync(src, src, { verbatimSymlinks }),
        { code: 'ERR_INVALID_ARG_TYPE' }
      );
    });
}


// It throws an error when both dereference and verbatimSymlinks are enabled.
{
  const src = './test/fixtures/copy/kitchen-sink';
  assert.throws(
    () => cpSync(src, src, mustNotMutateObjectDeep({ dereference: true, verbatimSymlinks: true })),
    { code: 'ERR_INCOMPATIBLE_OPTION_PAIR' }
  );
}


// It resolves relative symlinks to their absolute path by default.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync('foo.js', join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));

  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  const link = readlinkSync(join(dest, 'bar.js'));
  assert.strictEqual(link, join(src, 'foo.js'));
}


// It resolves relative symlinks when verbatimSymlinks is false.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync('foo.js', join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));

  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true, verbatimSymlinks: false }));
  const link = readlinkSync(join(dest, 'bar.js'));
  assert.strictEqual(link, join(src, 'foo.js'));
}


// It does not resolve relative symlinks when verbatimSymlinks is true.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync('foo.js', join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));

  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true, verbatimSymlinks: true }));
  const link = readlinkSync(join(dest, 'bar.js'));
  assert.strictEqual(link, 'foo.js');
}

*/
// It throws error when src and dest are identical.
{
  const src = './test/fixtures/copy/kitchen-sink';
  assert.throws(
    () => cpSync(src, src),
    { code: 'ERR_FS_CP_EINVAL' }
  );
}
/*
// It throws error if symlink in src points to location in dest.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest);
  symlinkSync(dest, join(src, 'link'));
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.throws(
    () => cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true })),
    {
      code: 'ERR_FS_CP_EINVAL'
    }
  );
}

// It throws error if symlink in dest points to location in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(dest, 'a', 'c'));
  assert.throws(
    () => cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true })),
    { code: 'ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY' }
  );
}

// It throws error if parent directory of symlink in dest points to src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  // Create symlink in dest pointing to src.
  const destLink = join(dest, 'b');
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, destLink);
  assert.throws(
    () => cpSync(src, join(dest, 'b', 'c')),
    { code: 'ERR_FS_CP_EINVAL' }
  );
}
*/
// It throws error if attempt is made to copy directory to file.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = './test/fixtures/copy/kitchen-sink/README.md';
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_CP_DIR_TO_NON_DIR' }
  );
}

// It allows file to be copied to a file path.
{
  const srcFile = './test/fixtures/copy/kitchen-sink/index.js';
  const destFile = join(nextdir(), 'index.js');
  cpSync(srcFile, destFile, mustNotMutateObjectDeep({ dereference: true }));
  const stat = lstatSync(destFile);
  assert(stat.isFile());
}

// It throws error if directory copied without recursive flag.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_EISDIR' }
  );
}


// It throws error if attempt is made to copy file to directory.
{
  const src = './test/fixtures/copy/kitchen-sink/README.md';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_CP_NON_DIR_TO_DIR' }
  );
}

// It throws error if attempt is made to copy to subdirectory of self.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = './test/fixtures/copy/kitchen-sink/a';
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_CP_EINVAL' }
  );
}

// It throws an error if attempt is made to copy socket.
if (!isWindows && false) {
  const dest = nextdir();
  const sock = `${process.pid}.sock`;
  const server = net.createServer();
  server.listen(sock);
  assert.throws(
    () => cpSync(sock, dest),
    { code: 'ERR_FS_CP_SOCKET' }
  );
  server.close();
}

// It copies timestamps from src to dest if preserveTimestamps is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ preserveTimestamps: true, recursive: true }));
  assertDirEquivalent(src, dest);
  const srcStat = lstatSync(join(src, 'index.js'));
  const destStat = lstatSync(join(dest, 'index.js'));
  assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
}

// It applies filter function.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, {
    filter: (path) => {
      const pathStat = statSync(path);
      return pathStat.isDirectory() || path.endsWith('.js');
    },
    dereference: true,
    recursive: true,
  });
  const destEntries = [];
  collectEntries(dest, destEntries);
  for (const entry of destEntries) {
    assert.strictEqual(
      entry.isDirectory() || entry.name.endsWith('.js'),
      true
    );
  }
}

// It throws error if filter function is asynchronous.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  assert.throws(() => {
    cpSync(src, dest, {
      filter: async (path) => {
        await setTimeoutAsync(500, 'done');
        const pathStat = statSync(path);
        return pathStat.isDirectory() || path.endsWith('.js');
      },
      dereference: true,
      recursive: true,
    });
  }, { code: 'ERR_INVALID_RETURN_VALUE' });
}

// It throws error if errorOnExist is true, force is false, and file or folder
// copied over.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.throws(
    () => cpSync(src, dest, {
      dereference: true,
      errorOnExist: true,
      force: false,
      recursive: true,
    }),
    { code: 'ERR_FS_CP_EEXIST' }
  );
}
/*
// It throws EEXIST error if attempt is made to copy symlink over file.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'a', 'c'), 'hello', 'utf8');
  assert.throws(
    () => cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true })),
    { code: 'EEXIST' }
  );
}
*/
// It makes file writeable when updating timestamp, if not writeable.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.txt'), 'foo', mustNotMutateObjectDeep({ mode: 0o444 }));
  cpSync(src, dest, mustNotMutateObjectDeep({ preserveTimestamps: true, recursive: true }));
  assertDirEquivalent(src, dest);
  const srcStat = lstatSync(join(src, 'foo.txt'));
  const destStat = lstatSync(join(dest, 'foo.txt'));
  assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
}
/*
// It copies link if it does not point to folder in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(src, 'a', 'c'));
  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(dest, join(dest, 'a', 'c'));
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  const link = readlinkSync(join(dest, 'a', 'c'));
  assert.strictEqual(link, src);
}
*/
// It accepts file URL as src and dest.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(pathToFileURL(src), pathToFileURL(dest), mustNotMutateObjectDeep({ recursive: true }));
  assertDirEquivalent(src, dest);
}

// It throws if options is not object.
{
  assert.throws(
    () => cpSync('a', 'b', () => { }),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
}

// Callback implementation of copy.

// It copies a nested folder structure with files and folders.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
  }));
}

// It does not throw errors when directory is copied over and force is false.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'README.md'), 'hello world', 'utf8');
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  const initialStat = lstatSync(join(dest, 'README.md'));
  cp(src, dest, {
    dereference: true,
    force: false,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    // File should not have been copied over, so access times will be identical:
    const finalStat = lstatSync(join(dest, 'README.md'));
    assert.strictEqual(finalStat.ctime.getTime(), initialStat.ctime.getTime());
  }));
}

// It overwrites existing files if force is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'README.md'), '# Goodbye', 'utf8');

  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    const content = readFileSync(join(dest, 'README.md'), 'utf8');
    assert.strictEqual(content.trim(), '# Hello');
  }));
}

// It does not fail if the same directory is copied to dest twice,
// when dereference is true, and force is false (fails silently).
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const destFile = join(dest, 'a/b/README2.md');
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  cp(src, dest, {
    dereference: true,
    recursive: true
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    const stat = lstatSync(destFile);
    assert(stat.isFile());
  }));
}
/*
// It copies file itself, rather than symlink, when dereference is true.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync(join(src, 'foo.js'), join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  const destFile = join(dest, 'foo.js');

  cp(join(src, 'bar.js'), destFile, mustNotMutateObjectDeep({ dereference: true }),
    mustCall((err) => {
      assert.strictEqual(err, null);
      const stat = lstatSync(destFile);
      assert(stat.isFile());
    })
  );
}
*/
// It returns error when src and dest are identical.
{
  const src = './test/fixtures/copy/kitchen-sink';
  cp(src, src, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}
/*
// It returns error if symlink in src points to location in dest.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest);
  symlinkSync(dest, join(src, 'link'));
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}

// It returns error if symlink in dest points to location in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(dest, 'a', 'c'));
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY');
  }));
}

// It returns error if parent directory of symlink in dest points to src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  // Create symlink in dest pointing to src.
  const destLink = join(dest, 'b');
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, destLink);
  cp(src, join(dest, 'b', 'c'), mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}
*/
// It returns error if attempt is made to copy directory to file.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = './test/fixtures/copy/kitchen-sink/README.md';
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_DIR_TO_NON_DIR');
  }));
}

// It allows file to be copied to a file path.
{
  const srcFile = './test/fixtures/copy/kitchen-sink/README.md';
  const destFile = join(nextdir(), 'index.js');
  cp(srcFile, destFile, mustNotMutateObjectDeep({ dereference: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    const stat = lstatSync(destFile);
    assert(stat.isFile());
  }));
}

// It returns error if directory copied without recursive flag.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_EISDIR');
  }));
}

// It returns error if attempt is made to copy file to directory.
{
  const src = './test/fixtures/copy/kitchen-sink/README.md';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_NON_DIR_TO_DIR');
  }));
}

// It returns error if attempt is made to copy to subdirectory of self.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = './test/fixtures/copy/kitchen-sink/a';
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}

// It returns an error if attempt is made to copy socket.
if (!isWindows && false) {
  const dest = nextdir();
  const sock = `${process.pid}.sock`;
  const server = net.createServer();
  server.listen(sock);
  cp(sock, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_SOCKET');
    server.close();
  }));
}

// It copies timestamps from src to dest if preserveTimestamps is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, {
    preserveTimestamps: true,
    recursive: true
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    const srcStat = lstatSync(join(src, 'index.js'));
    const destStat = lstatSync(join(dest, 'index.js'));
    assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
  }));
}

// It applies filter function.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, {
    filter: (path) => {
      const pathStat = statSync(path);
      return pathStat.isDirectory() || path.endsWith('.js');
    },
    dereference: true,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    const destEntries = [];
    collectEntries(dest, destEntries);
    for (const entry of destEntries) {
      assert.strictEqual(
        entry.isDirectory() || entry.name.endsWith('.js'),
        true
      );
    }
  }));
}

// It supports async filter function.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, {
    filter: async (path) => {
      await setTimeout(5, 'done');
      const pathStat = statSync(path);
      return pathStat.isDirectory() || path.endsWith('.js');
    },
    dereference: true,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    const destEntries = [];
    collectEntries(dest, destEntries);
    for (const entry of destEntries) {
      assert.strictEqual(
        entry.isDirectory() || entry.name.endsWith('.js'),
        true
      );
    }
  }));
}

// It returns error if errorOnExist is true, force is false, and file or folder
// copied over.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  cp(src, dest, {
    dereference: true,
    errorOnExist: true,
    force: false,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EEXIST');
  }));
}
/*
// It returns EEXIST error if attempt is made to copy symlink over file.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'a', 'c'), 'hello', 'utf8');
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err.code, 'EEXIST');
  }));
}
*/
// It makes file writeable when updating timestamp, if not writeable.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.txt'), 'foo', mustNotMutateObjectDeep({ mode: 0o444 }));
  cp(src, dest, {
    preserveTimestamps: true,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    const srcStat = lstatSync(join(src, 'foo.txt'));
    const destStat = lstatSync(join(dest, 'foo.txt'));
    assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
  }));
}
/*
// It copies link if it does not point to folder in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(src, 'a', 'c'));
  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(dest, join(dest, 'a', 'c'));
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    const link = readlinkSync(join(dest, 'a', 'c'));
    assert.strictEqual(link, src);
  }));
}
*/
// It accepts file URL as src and dest.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(pathToFileURL(src), pathToFileURL(dest), mustNotMutateObjectDeep({ recursive: true }),
    mustCall((err) => {
      assert.strictEqual(err, null);
      assertDirEquivalent(src, dest);
    }));
}

// It throws if options is not object.
{
  assert.throws(
    () => cp('a', 'b', 'hello', () => { }),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
}

// Promises implementation of copy.

// It copies a nested folder structure with files and folders.
(async function () {
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const p = await fs.promises.cp(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(p, undefined);
  assertDirEquivalent(src, dest);
})();

// It accepts file URL as src and dest.
(async function () {
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const p = await fs.promises.cp(
    pathToFileURL(src),
    pathToFileURL(dest),
    { recursive: true }
  );
  assert.strictEqual(p, undefined);
  assertDirEquivalent(src, dest);
})();

// It allows async error to be caught.
(async function () {
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  await fs.promises.cp(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  await assert.rejects(
    fs.promises.cp(src, dest, {
      dereference: true,
      errorOnExist: true,
      force: false,
      recursive: true,
    }),
    { code: 'ERR_FS_CP_EEXIST' }
  );
})();

// It rejects if options is not object.
(async function () {
  await assert.rejects(
    fs.promises.cp('a', 'b', () => { }),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
})();

function assertDirEquivalent(dir1, dir2) {
  const dir1Entries = [];
  collectEntries(dir1, dir1Entries);
  const dir2Entries = [];
  collectEntries(dir2, dir2Entries);
  assert.strictEqual(dir1Entries.length, dir2Entries.length);
  for (const entry1 of dir1Entries) {
    const entry2 = dir2Entries.find((entry) => {
      return entry.name === entry1.name;
    });
    assert(entry2, `entry ${entry2.name} not copied`);
    if (entry1.isFile()) {
      assert(entry2.isFile(), `${entry2.name} was not file`);
    } else if (entry1.isDirectory()) {
      assert(entry2.isDirectory(), `${entry2.name} was not directory`);
    } else if (entry1.isSymbolicLink()) {
      assert(entry2.isSymbolicLink(), `${entry2.name} was not symlink`);
    }
  }
}

function collectEntries(dir, dirEntries) {
  const newEntries = readdirSync(dir, mustNotMutateObjectDeep({ withFileTypes: true }));
  for (const entry of newEntries) {
    if (entry.isDirectory()) {
      collectEntries(join(dir, entry.name), dirEntries);
    }
  }
  dirEntries.push(...newEntries);
}

```"
"```javascript:test\crypto\test-crypto-key-objects.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const {
  createCipheriv,
  createDecipheriv,
  createSign,
  createVerify,
  createSecretKey,
  createPublicKey,
  createPrivateKey,
  KeyObject,
  randomBytes,
  publicDecrypt,
  publicEncrypt,
  privateDecrypt,
  privateEncrypt,
  getCurves,
  generateKeySync,
  generateKeyPairSync,
} = require('crypto');

const fixtures = require('../common/fixtures');

const publicPem = fixtures.readKey('rsa_public.pem', 'ascii');
const privatePem = fixtures.readKey('rsa_private.pem', 'ascii');

const publicDsa = fixtures.readKey('dsa_public_1025.pem', 'ascii');
const privateDsa = fixtures.readKey('dsa_private_encrypted_1025.pem',
                                    'ascii');

{
  // Attempting to create a key of a wrong type should throw
  const TYPE = 'wrong_type';

  assert.throws(() => new KeyObject(TYPE), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_VALUE',
    message: `The argument 'type' is invalid. Received '${TYPE}'`
  });
}

{
  // Attempting to create a key with non-object handle should throw
  assert.throws(() => new KeyObject('secret', ''), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message:
      'The ""handle"" argument must be of type object. Received type ' +
      ""string ('')""
  });
}

{
  assert.throws(() => KeyObject.from('invalid_key'), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message:
      'The ""key"" argument must be an instance of CryptoKey. Received type ' +
      ""string ('invalid_key')""
  });
}

{
  const keybuf = randomBytes(32);
  const key = createSecretKey(keybuf);
  assert.strictEqual(key.type, 'secret');
  assert.strictEqual(key.symmetricKeySize, 32);
  assert.strictEqual(key.asymmetricKeyType, undefined);
  assert.strictEqual(key.asymmetricKeyDetails, undefined);

  const exportedKey = key.export();
  assert(keybuf.equals(exportedKey));

  const plaintext = Buffer.from('Hello world', 'utf8');

  const cipher = createCipheriv('aes-256-ecb', key, null);
  const ciphertext = Buffer.concat([
    cipher.update(plaintext), cipher.final(),
  ]);

  const decipher = createDecipheriv('aes-256-ecb', key, null);
  const deciphered = Buffer.concat([
    decipher.update(ciphertext), decipher.final(),
  ]);

  assert(plaintext.equals(deciphered));
}

{
  // Passing an existing public key object to createPublicKey should throw.
  const publicKey = createPublicKey(publicPem);
  assert.throws(() => createPublicKey(publicKey), {
    name: 'TypeError',
    code: 'ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE',
    message: 'Invalid key object type public, expected private.'
  });

  // Constructing a private key from a public key should be impossible, even
  // if the public key was derived from a private key.
  assert.throws(() => createPrivateKey(createPublicKey(privatePem)), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
  });

  // Similarly, passing an existing private key object to createPrivateKey
  // should throw.
  const privateKey = createPrivateKey(privatePem);
  assert.throws(() => createPrivateKey(privateKey), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
  });
}

{
  const jwk = {
    e: 'AQAB',
    n: 't9xYiIonscC3vz_A2ceR7KhZZlDu_5bye53nCVTcKnWd2seY6UAdKersX6njr83Dd5OVe' +
       '1BW_wJvp5EjWTAGYbFswlNmeD44edEGM939B6Lq-_8iBkrTi8mGN4YCytivE24YI0D4XZ' +
       'MPfkLSpab2y_Hy4DjQKBq1ThZ0UBnK-9IhX37Ju_ZoGYSlTIGIhzyaiYBh7wrZBoPczIE' +
       'u6et_kN2VnnbRUtkYTF97ggcv5h-hDpUQjQW0ZgOMcTc8n-RkGpIt0_iM_bTjI3Tz_gsF' +
       'di6hHcpZgbopPL630296iByyigQCPJVzdusFrQN5DeC-zT_nGypQkZanLb4ZspSx9Q',
    d: 'ktnq2LvIMqBj4txP82IEOorIRQGVsw1khbm8A-cEpuEkgM71Yi_0WzupKktucUeevQ5i0' +
       'Yh8w9e1SJiTLDRAlJz66kdky9uejiWWl6zR4dyNZVMFYRM43ijLC-P8rPne9Fz16IqHFW' +
       '5VbJqA1xCBhKmuPMsD71RNxZ4Hrsa7Kt_xglQTYsLbdGIwDmcZihId9VGXRzvmCPsDRf2' +
       'fCkAj7HDeRxpUdEiEDpajADc-PWikra3r3b40tVHKWm8wxJLivOIN7GiYXKQIW6RhZgH-' +
       'Rk45JIRNKxNagxdeXUqqyhnwhbTo1Hite0iBDexN9tgoZk0XmdYWBn6ElXHRZ7VCDQ',
    p: '8UovlB4nrBm7xH-u7XXBMbqxADQm5vaEZxw9eluc-tP7cIAI4sglMIvL_FMpbd2pEeP_B' +
       'kR76NTDzzDuPAZvUGRavgEjy0O9j2NAs_WPK4tZF-vFdunhnSh4EHAF4Ij9kbsUi90NOp' +
       'bGfVqPdOaHqzgHKoR23Cuusk9wFQ2XTV8',
    q: 'wxHdEYT9xrpfrHPqSBQPpO0dWGKJEkrWOb-76rSfuL8wGR4OBNmQdhLuU9zTIh22pog-X' +
       'PnLPAecC-4yu_wtJ2SPCKiKDbJBre0CKPyRfGqzvA3njXwMxXazU4kGs-2Fg-xu_iKbaI' +
       'jxXrclBLhkxhBtySrwAFhxxOk6fFcPLSs',
    dp: 'qS_Mdr5CMRGGMH0bKhPUWEtAixUGZhJaunX5wY71Xoc_Gh4cnO-b7BNJ_-5L8WZog0vr' +
       '6PgiLhrqBaCYm2wjpyoG2o2wDHm-NAlzN_wp3G2EFhrSxdOux-S1c0kpRcyoiAO2n29rN' +
       'Da-jOzwBBcU8ACEPdLOCQl0IEFFJO33tl8',
    dq: 'WAziKpxLKL7LnL4dzDcx8JIPIuwnTxh0plCDdCffyLaT8WJ9lXbXHFTjOvt8WfPrlDP_' +
       'Ylxmfkw5BbGZOP1VLGjZn2DkH9aMiwNmbDXFPdG0G3hzQovx_9fajiRV4DWghLHeT9wzJ' +
       'fZabRRiI0VQR472300AVEeX4vgbrDBn600',
    qi: 'k7czBCT9rHn_PNwCa17hlTy88C4vXkwbz83Oa-aX5L4e5gw5lhcR2ZuZHLb2r6oMt9rl' +
       'D7EIDItSs-u21LOXWPTAlazdnpYUyw_CzogM_PN-qNwMRXn5uXFFhmlP2mVg2EdELTahX' +
       'ch8kWqHaCSX53yvqCtRKu_j76V31TfQZGM',
    kty: 'RSA',
  };
  const publicJwk = { kty: jwk.kty, e: jwk.e, n: jwk.n };

  const publicKey = createPublicKey(publicPem);
  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(publicKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(publicKey.symmetricKeySize, undefined);

  const privateKey = createPrivateKey(privatePem);
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(privateKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(privateKey.symmetricKeySize, undefined);

  // It should be possible to derive a public key from a private key.
  const derivedPublicKey = createPublicKey(privateKey);
  assert.strictEqual(derivedPublicKey.type, 'public');
  assert.strictEqual(derivedPublicKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(derivedPublicKey.symmetricKeySize, undefined);

  const publicKeyFromJwk = createPublicKey({ key: publicJwk, format: 'jwk' });
  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(publicKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(publicKey.symmetricKeySize, undefined);

  const privateKeyFromJwk = createPrivateKey({ key: jwk, format: 'jwk' });
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(privateKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(privateKey.symmetricKeySize, undefined);

  // It should also be possible to import an encrypted private key as a public
  // key.
  const decryptedKey = createPublicKey({
    key: privateKey.export({
      type: 'pkcs8',
      format: 'pem',
      passphrase: '123',
      cipher: 'aes-128-cbc'
    }),
    format: 'pem',
    passphrase: '123'
  });
  assert.strictEqual(decryptedKey.type, 'public');
  assert.strictEqual(decryptedKey.asymmetricKeyType, 'rsa');

  // Test exporting with an invalid options object, this should throw.
  for (const opt of [undefined, null, 'foo', 0, NaN]) {
    assert.throws(() => publicKey.export(opt), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""options"" argument must be of type object/
    });
  }

  for (const keyObject of [publicKey, derivedPublicKey, publicKeyFromJwk]) {
    assert.deepStrictEqual(
      keyObject.export({ format: 'jwk' }),
      { kty: 'RSA', n: jwk.n, e: jwk.e }
    );
  }

  for (const keyObject of [privateKey, privateKeyFromJwk]) {
    assert.deepStrictEqual(
      keyObject.export({ format: 'jwk' }),
      jwk
    );
  }

  // Exporting the key using JWK should not work since this format does not
  // support key encryption
  assert.throws(() => {
    privateKey.export({ format: 'jwk', passphrase: 'secret' });
  }, {
    message: 'The selected key encoding jwk does not support encryption.',
    code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'
  });

  const publicDER = publicKey.export({
    format: 'der',
    type: 'pkcs1'
  });

  const privateDER = privateKey.export({
    format: 'der',
    type: 'pkcs1'
  });

  assert(Buffer.isBuffer(publicDER));
  assert(Buffer.isBuffer(privateDER));

  const plaintext = Buffer.from('Hello world', 'utf8');
  const testDecryption = (fn, ciphertexts, decryptionKeys) => {
    for (const ciphertext of ciphertexts) {
      for (const key of decryptionKeys) {
        const deciphered = fn(key, ciphertext);
        assert.deepStrictEqual(deciphered, plaintext);
      }
    }
  };

  testDecryption(privateDecrypt, [
    // Encrypt using the public key.
    publicEncrypt(publicKey, plaintext),
    publicEncrypt({ key: publicKey }, plaintext),
    publicEncrypt({ key: publicJwk, format: 'jwk' }, plaintext),

    // Encrypt using the private key.
    publicEncrypt(privateKey, plaintext),
    publicEncrypt({ key: privateKey }, plaintext),
    publicEncrypt({ key: jwk, format: 'jwk' }, plaintext),

    // Encrypt using a public key derived from the private key.
    publicEncrypt(derivedPublicKey, plaintext),
    publicEncrypt({ key: derivedPublicKey }, plaintext),

    // Test distinguishing PKCS#1 public and private keys based on the
    // DER-encoded data only.
    publicEncrypt({ format: 'der', type: 'pkcs1', key: publicDER }, plaintext),
    publicEncrypt({ format: 'der', type: 'pkcs1', key: privateDER }, plaintext),
  ], [
    privateKey,
    { format: 'pem', key: privatePem },
    { format: 'der', type: 'pkcs1', key: privateDER },
    { key: jwk, format: 'jwk' },
  ]);

  testDecryption(publicDecrypt, [
    privateEncrypt(privateKey, plaintext),
  ], [
    // Decrypt using the public key.
    publicKey,
    { format: 'pem', key: publicPem },
    { format: 'der', type: 'pkcs1', key: publicDER },
    { key: publicJwk, format: 'jwk' },

    // Decrypt using the private key.
    privateKey,
    { format: 'pem', key: privatePem },
    { format: 'der', type: 'pkcs1', key: privateDER },
    { key: jwk, format: 'jwk' },
  ]);
}

{
  // This should not cause a crash: https://github.com/nodejs/node/issues/25247
  assert.throws(() => {
    createPrivateKey({ key: '' });
  }, common.hasOpenSSL3 ? {
    message: 'error:1E08010C:DECODER routines::unsupported',
  } : {
    message: 'error:0909006C:PEM routines:get_name:no start line',
    code: 'ERR_OSSL_PEM_NO_START_LINE',
    reason: 'no start line',
    library: 'PEM routines',
    function: 'get_name',
  });

  // This should not abort either: https://github.com/nodejs/node/issues/29904
  assert.throws(() => {
    createPrivateKey({ key: Buffer.alloc(0), format: 'der', type: 'spki' });
  }, {
    code: 'ERR_INVALID_ARG_VALUE',
    message: ""The property 'options.type' is invalid. Received 'spki'""
  });

  // Unlike SPKI, PKCS#1 is a valid encoding for private keys (and public keys),
  // so it should be accepted by createPrivateKey, but OpenSSL won't parse it.
  assert.throws(() => {
    const key = createPublicKey(publicPem).export({
      format: 'der',
      type: 'pkcs1'
    });
    createPrivateKey({ key, format: 'der', type: 'pkcs1' });
  }, common.hasOpenSSL3 ? {
    message: /error:1E08010C:DECODER routines::unsupported/,
    library: 'DECODER routines'
  } : {
    message: /asn1 encoding/,
    library: 'asn1 encoding routines'
  });
}

[
  { private: fixtures.readKey('ed25519_private.pem', 'ascii'),
    public: fixtures.readKey('ed25519_public.pem', 'ascii'),
    keyType: 'ed25519',
    jwk: {
      crv: 'Ed25519',
      x: 'K1wIouqnuiA04b3WrMa-xKIKIpfHetNZRv3h9fBf768',
      d: 'wVK6M3SMhQh3NK-7GRrSV-BVWQx1FO5pW8hhQeu_NdA',
      kty: 'OKP'
    } },
  { private: fixtures.readKey('ed448_private.pem', 'ascii'),
    public: fixtures.readKey('ed448_public.pem', 'ascii'),
    keyType: 'ed448',
    jwk: {
      crv: 'Ed448',
      x: 'oX_ee5-jlcU53-BbGRsGIzly0V-SZtJ_oGXY0udf84q2hTW2RdstLktvwpkVJOoNb7o' +
         'Dgc2V5ZUA',
      d: '060Ke71sN0GpIc01nnGgMDkp0sFNQ09woVo4AM1ffax1-mjnakK0-p-S7-Xf859QewX' +
         'jcR9mxppY',
      kty: 'OKP'
    } },
  { private: fixtures.readKey('x25519_private.pem', 'ascii'),
    public: fixtures.readKey('x25519_public.pem', 'ascii'),
    keyType: 'x25519',
    jwk: {
      crv: 'X25519',
      x: 'aSb8Q-RndwfNnPeOYGYPDUN3uhAPnMLzXyfi-mqfhig',
      d: 'mL_IWm55RrALUGRfJYzw40gEYWMvtRkesP9mj8o8Omc',
      kty: 'OKP'
    } },
  { private: fixtures.readKey('x448_private.pem', 'ascii'),
    public: fixtures.readKey('x448_public.pem', 'ascii'),
    keyType: 'x448',
    jwk: {
      crv: 'X448',
      x: 'ioHSHVpTs6hMvghosEJDIR7ceFiE3-Xccxati64oOVJ7NWjfozE7ae31PXIUFq6cVYg' +
         'vSKsDFPA',
      d: 'tMNtrO_q8dlY6Y4NDeSTxNQ5CACkHiPvmukidPnNIuX_EkcryLEXt_7i6j6YZMKsrWy' +
         'S0jlSYJk',
      kty: 'OKP'
    } },
].forEach((info) => {
  const keyType = info.keyType;

  {
    const key = createPrivateKey(info.private);
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    const key = createPrivateKey({ key: info.jwk, format: 'jwk' });
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    for (const input of [
      info.private, info.public, { key: info.jwk, format: 'jwk' }]) {
      const key = createPublicKey(input);
      assert.strictEqual(key.type, 'public');
      assert.strictEqual(key.asymmetricKeyType, keyType);
      assert.strictEqual(key.symmetricKeySize, undefined);
      assert.strictEqual(
        key.export({ type: 'spki', format: 'pem' }), info.public);
      const jwk = { ...info.jwk };
      delete jwk.d;
      assert.deepStrictEqual(
        key.export({ format: 'jwk' }), jwk);
    }
  }
});

[
  { private: fixtures.readKey('ec_p256_private.pem', 'ascii'),
    public: fixtures.readKey('ec_p256_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'prime256v1',
    jwk: {
      crv: 'P-256',
      d: 'DxBsPQPIgMuMyQbxzbb9toew6Ev6e9O6ZhpxLNgmAEo',
      kty: 'EC',
      x: 'X0mMYR_uleZSIPjNztIkAS3_ud5LhNpbiIFp6fNf2Gs',
      y: 'UbJuPy2Xi0lW7UYTBxPK3yGgDu9EAKYIecjkHX5s2lI'
    } },
  { private: fixtures.readKey('ec_secp256k1_private.pem', 'ascii'),
    public: fixtures.readKey('ec_secp256k1_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'secp256k1',
    jwk: {
      crv: 'secp256k1',
      d: 'c34ocwTwpFa9NZZh3l88qXyrkoYSxvC0FEsU5v1v4IM',
      kty: 'EC',
      x: 'cOzhFSpWxhalCbWNdP2H_yUkdC81C9T2deDpfxK7owA',
      y: '-A3DAZTk9IPppN-f03JydgHaFvL1fAHaoXf4SX4NXyo'
    } },
  { private: fixtures.readKey('ec_p384_private.pem', 'ascii'),
    public: fixtures.readKey('ec_p384_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'secp384r1',
    jwk: {
      crv: 'P-384',
      d: 'dwfuHuAtTlMRn7ZBCBm_0grpc1D_4hPeNAgevgelljuC0--k_LDFosDgBlLLmZsi',
      kty: 'EC',
      x: 'hON3nzGJgv-08fdHpQxgRJFZzlK-GZDGa5f3KnvM31cvvjJmsj4UeOgIdy3rDAjV',
      y: 'fidHhtecNCGCfLqmrLjDena1NSzWzWH1u_oUdMKGo5XSabxzD7-8JZxjpc8sR9cl'
    } },
  { private: fixtures.readKey('ec_p521_private.pem', 'ascii'),
    public: fixtures.readKey('ec_p521_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'secp521r1',
    jwk: {
      crv: 'P-521',
      d: 'ABIIbmn3Gm_Y11uIDkC3g2ijpRxIrJEBY4i_JJYo5OougzTl3BX2ifRluPJMaaHcNer' +
         'bQH_WdVkLLX86ShlHrRyJ',
      kty: 'EC',
      x: 'AaLFgjwZtznM3N7qsfb86awVXe6c6djUYOob1FN-kllekv0KEXV0bwcDjPGQz5f6MxL' +
         'CbhMeHRavUS6P10rsTtBn',
      y: 'Ad3flexBeAfXceNzRBH128kFbOWD6W41NjwKRqqIF26vmgW_8COldGKZjFkOSEASxPB' +
         'cvA2iFJRUyQ3whC00j0Np'
    } },
].forEach((info) => {
  const { keyType, namedCurve } = info;

  {
    const key = createPrivateKey(info.private);
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.deepStrictEqual(key.asymmetricKeyDetails, { namedCurve });
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    const key = createPrivateKey({ key: info.jwk, format: 'jwk' });
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.deepStrictEqual(key.asymmetricKeyDetails, { namedCurve });
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    for (const input of [
      info.private, info.public, { key: info.jwk, format: 'jwk' }]) {
      const key = createPublicKey(input);
      assert.strictEqual(key.type, 'public');
      assert.strictEqual(key.asymmetricKeyType, keyType);
      assert.deepStrictEqual(key.asymmetricKeyDetails, { namedCurve });
      assert.strictEqual(key.symmetricKeySize, undefined);
      assert.strictEqual(
        key.export({ type: 'spki', format: 'pem' }), info.public);
      const jwk = { ...info.jwk };
      delete jwk.d;
      assert.deepStrictEqual(
        key.export({ format: 'jwk' }), jwk);
    }
  }
});

{
  // Reading an encrypted key without a passphrase should fail.
  assert.throws(() => createPrivateKey(privateDsa), common.hasOpenSSL3 ? {
    name: 'Error',
    message: 'error:07880109:common libcrypto routines::interrupted or ' +
             'cancelled',
  } : {
    name: 'TypeError',
    code: 'ERR_MISSING_PASSPHRASE',
    message: 'Passphrase required for encrypted key'
  });

  // Reading an encrypted key with a passphrase that exceeds OpenSSL's buffer
  // size limit should fail with an appropriate error code.
  assert.throws(() => createPrivateKey({
    key: privateDsa,
    format: 'pem',
    passphrase: Buffer.alloc(1025, 'a')
  }), common.hasOpenSSL3 ? { name: 'Error' } : {
    code: 'ERR_OSSL_PEM_BAD_PASSWORD_READ',
    name: 'Error'
  });

  // The buffer has a size of 1024 bytes, so this passphrase should be permitted
  // (but will fail decryption).
  assert.throws(() => createPrivateKey({
    key: privateDsa,
    format: 'pem',
    passphrase: Buffer.alloc(1024, 'a')
  }), {
    message: /bad decrypt/
  });

  const publicKey = createPublicKey(publicDsa);
  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(publicKey.asymmetricKeyType, 'dsa');
  assert.strictEqual(publicKey.symmetricKeySize, undefined);
  assert.throws(
    () => publicKey.export({ format: 'jwk' }),
    { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });

  const privateKey = createPrivateKey({
    key: privateDsa,
    format: 'pem',
    passphrase: 'secret'
  });
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(privateKey.asymmetricKeyType, 'dsa');
  assert.strictEqual(privateKey.symmetricKeySize, undefined);
  assert.throws(
    () => privateKey.export({ format: 'jwk' }),
    { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });
}

{
  // Test RSA-PSS.
  {
    // This key pair does not restrict the message digest algorithm or salt
    // length.
    const publicPem = fixtures.readKey('rsa_pss_public_2048.pem');
    const privatePem = fixtures.readKey('rsa_pss_private_2048.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    // Because no RSASSA-PSS-params appears in the PEM, no defaults should be
    // added for the PSS parameters. This is different from an empty
    // RSASSA-PSS-params sequence (see test below).
    const expectedKeyDetails = {
      modulusLength: 2048,
      publicExponent: 65537n
    };

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.throws(
      () => publicKey.export({ format: 'jwk' }),
      { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });
    assert.throws(
      () => privateKey.export({ format: 'jwk' }),
      { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });

    for (const key of [privatePem, privateKey]) {
      // Any algorithm should work.
      for (const algo of ['sha1', 'sha256']) {
        // Any salt length should work.
        for (const saltLength of [undefined, 8, 10, 12, 16, 18, 20]) {
          const signature = createSign(algo)
                            .update('foo')
                            .sign({ key, saltLength });

          for (const pkey of [key, publicKey, publicPem]) {
            const okay = createVerify(algo)
                         .update('foo')
                         .verify({ key: pkey, saltLength }, signature);

            assert.ok(okay);
          }
        }
      }
    }

    // Exporting the key using PKCS#1 should not work since this would discard
    // any algorithm restrictions.
    assert.throws(() => {
      publicKey.export({ format: 'pem', type: 'pkcs1' });
    }, {
      code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'
    });
  }

  {
    // This key pair enforces sha1 as the message digest and the MGF1
    // message digest and a salt length of 20 bytes.

    const publicPem = fixtures.readKey('rsa_pss_public_2048_sha1_sha1_20.pem');
    const privatePem =
        fixtures.readKey('rsa_pss_private_2048_sha1_sha1_20.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    // Unlike the previous key pair, this key pair contains an RSASSA-PSS-params
    // sequence. However, because all values in the RSASSA-PSS-params are set to
    // their defaults (see RFC 3447), the ASN.1 structure contains an empty
    // sequence. Node.js should add the default values to the key details.
    const expectedKeyDetails = {
      modulusLength: 2048,
      publicExponent: 65537n,
      hashAlgorithm: 'sha1',
      mgf1HashAlgorithm: 'sha1',
      saltLength: 20
    };

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, expectedKeyDetails);
  }

  {
    // This key pair enforces sha256 as the message digest and the MGF1
    // message digest and a salt length of at least 16 bytes.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha256_sha256_16.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha256_sha256_16.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');

    for (const key of [privatePem, privateKey]) {
      // Signing with anything other than sha256 should fail.
      assert.throws(() => {
        createSign('sha1').sign(key);
      }, /digest not allowed/);

      // Signing with salt lengths less than 16 bytes should fail.
      for (const saltLength of [8, 10, 12]) {
        assert.throws(() => {
          createSign('sha1').sign({ key, saltLength });
        }, /pss saltlen too small/);
      }

      // Signing with sha256 and appropriate salt lengths should work.
      for (const saltLength of [undefined, 16, 18, 20]) {
        const signature = createSign('sha256')
                          .update('foo')
                          .sign({ key, saltLength });

        for (const pkey of [key, publicKey, publicPem]) {
          const okay = createVerify('sha256')
                       .update('foo')
                       .verify({ key: pkey, saltLength }, signature);

          assert.ok(okay);
        }
      }
    }
  }

  {
    // This key enforces sha512 as the message digest and sha256 as the MGF1
    // message digest.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha512_sha256_20.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha512_sha256_20.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    const expectedKeyDetails = {
      modulusLength: 2048,
      publicExponent: 65537n,
      hashAlgorithm: 'sha512',
      mgf1HashAlgorithm: 'sha256',
      saltLength: 20
    };

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, expectedKeyDetails);

    // Node.js usually uses the same hash function for the message and for MGF1.
    // However, when a different MGF1 message digest algorithm has been
    // specified as part of the key, it should automatically switch to that.
    // This behavior is required by sections 3.1 and 3.3 of RFC4055.
    for (const key of [privatePem, privateKey]) {
      // sha256 matches the MGF1 hash function and should be used internally,
      // but it should not be permitted as the main message digest algorithm.
      for (const algo of ['sha1', 'sha256']) {
        assert.throws(() => {
          createSign(algo).sign(key);
        }, /digest not allowed/);
      }

      // sha512 should produce a valid signature.
      const signature = createSign('sha512')
                        .update('foo')
                        .sign(key);

      for (const pkey of [key, publicKey, publicPem]) {
        const okay = createVerify('sha512')
                     .update('foo')
                     .verify(pkey, signature);

        assert.ok(okay);
      }
    }
  }
}

{
  // Exporting an encrypted private key requires a cipher
  const privateKey = createPrivateKey(privatePem);
  assert.throws(() => {
    privateKey.export({
      format: 'pem', type: 'pkcs8', passphrase: 'super-secret'
    });
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_VALUE',
    message: ""The property 'options.cipher' is invalid. Received undefined""
  });
}

{
  // SecretKeyObject export buffer format (default)
  const buffer = Buffer.from('Hello World');
  const keyObject = createSecretKey(buffer);
  assert.deepStrictEqual(keyObject.export(), buffer);
  assert.deepStrictEqual(keyObject.export({}), buffer);
  assert.deepStrictEqual(keyObject.export({ format: 'buffer' }), buffer);
  assert.deepStrictEqual(keyObject.export({ format: undefined }), buffer);
}

{
  // Exporting an ""oct"" JWK from a SecretKeyObject
  const buffer = Buffer.from('Hello World');
  const keyObject = createSecretKey(buffer);
  assert.deepStrictEqual(
    keyObject.export({ format: 'jwk' }),
    { kty: 'oct', k: 'SGVsbG8gV29ybGQ' }
  );
}

{
  // Exporting a JWK unsupported curve EC key
  const supported = ['prime256v1', 'secp256k1', 'secp384r1', 'secp521r1'];
  // Find an unsupported curve regardless of whether a FIPS compliant crypto
  // provider is currently in use.
  const namedCurve = getCurves().find((curve) => !supported.includes(curve));
  assert(namedCurve);
  const keyPair = generateKeyPairSync('ec', { namedCurve });
  const { publicKey, privateKey } = keyPair;
  assert.throws(
    () => publicKey.export({ format: 'jwk' }),
    {
      code: 'ERR_CRYPTO_JWK_UNSUPPORTED_CURVE',
      message: `Unsupported JWK EC curve: ${namedCurve}.`
    });
  assert.throws(
    () => privateKey.export({ format: 'jwk' }),
    {
      code: 'ERR_CRYPTO_JWK_UNSUPPORTED_CURVE',
      message: `Unsupported JWK EC curve: ${namedCurve}.`
    });
}

{
  const first = Buffer.from('Hello');
  const second = Buffer.from('World');
  const keyObject = createSecretKey(first);
  assert(createSecretKey(first).equals(createSecretKey(first)));
  assert(!createSecretKey(first).equals(createSecretKey(second)));

  assert.throws(() => keyObject.equals(0), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The ""otherKeyObject"" argument must be an instance of KeyObject. Received type number (0)'
  });

  assert(keyObject.equals(keyObject));
  assert(!keyObject.equals(createPublicKey(publicPem)));
  assert(!keyObject.equals(createPrivateKey(privatePem)));
}

{
  const first = generateKeyPairSync('ed25519');
  const second = generateKeyPairSync('ed25519');
  const secret = generateKeySync('aes', { length: 128 });

  assert(first.publicKey.equals(first.publicKey));
  assert(first.publicKey.equals(createPublicKey(
    first.publicKey.export({ format: 'pem', type: 'spki' }))));
  assert(!first.publicKey.equals(second.publicKey));
  assert(!first.publicKey.equals(second.privateKey));
  assert(!first.publicKey.equals(secret));

  assert(first.privateKey.equals(first.privateKey));
  assert(first.privateKey.equals(createPrivateKey(
    first.privateKey.export({ format: 'pem', type: 'pkcs8' }))));
  assert(!first.privateKey.equals(second.privateKey));
  assert(!first.privateKey.equals(second.publicKey));
  assert(!first.privateKey.equals(secret));
}

{
  const first = generateKeyPairSync('ed25519');
  const second = generateKeyPairSync('ed448');

  assert(!first.publicKey.equals(second.publicKey));
  assert(!first.publicKey.equals(second.privateKey));
  assert(!first.privateKey.equals(second.privateKey));
  assert(!first.privateKey.equals(second.publicKey));
}

{
  const first = createSecretKey(Buffer.alloc(0));
  const second = createSecretKey(new ArrayBuffer(0));
  const third = createSecretKey(Buffer.alloc(1));
  assert(first.equals(first));
  assert(first.equals(second));
  assert(!first.equals(third));
  assert(!third.equals(first));
}

{
  // This should not cause a crash: https://github.com/nodejs/node/issues/44471
  for (const key of ['', 'foo', null, undefined, true, Boolean]) {
    assert.throws(() => {
      createPublicKey({ key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      createPrivateKey({ key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
  }
}

```"
"```javascript:test\crypto\test-crypto-authenticated.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// Flags: --no-warnings
'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { inspect } = require('util');
const fixtures = require('../common/fixtures');

crypto.DEFAULT_ENCODING = 'buffer';

//
// Test authenticated encryption modes.
//
// !NEVER USE STATIC IVs IN REAL LIFE!
//

const TEST_CASES = require(fixtures.path('aead-vectors.js'));

const errMessages = {
  auth: / auth/,
  state: / state/,
  FIPS: /not supported in FIPS mode/,
  length: /Invalid initialization vector/,
  authTagLength: /Invalid authentication tag length/
};

const ciphers = crypto.getCiphers();

const expectedWarnings = common.hasFipsCrypto ?
  [] : [
    ['Use Cipheriv for counter mode of aes-192-gcm'],
    ['Use Cipheriv for counter mode of aes-192-ccm'],
    ['Use Cipheriv for counter mode of aes-192-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
  ];

const expectedDeprecationWarnings = [
  ['crypto.DEFAULT_ENCODING is deprecated.', 'DEP0091'],
  ['crypto.createCipher is deprecated.', 'DEP0106'],
];

common.expectWarning({
  Warning: expectedWarnings,
  DeprecationWarning: expectedDeprecationWarnings
});

for (const test of TEST_CASES) {
  if (!ciphers.includes(test.algo)) {
    common.printSkipMessage(`unsupported ${test.algo} test`);
    continue;
  }

  if (common.hasFipsCrypto && test.iv.length < 24) {
    common.printSkipMessage('IV len < 12 bytes unsupported in FIPS mode');
    continue;
  }

  const isCCM = /^aes-(128|192|256)-ccm$/.test(test.algo);
  const isOCB = /^aes-(128|192|256)-ocb$/.test(test.algo);

  let options;
  if (isCCM || isOCB)
    options = { authTagLength: test.tag.length / 2 };

  const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';

  let aadOptions;
  if (isCCM) {
    aadOptions = {
      plaintextLength: Buffer.from(test.plain, inputEncoding).length
    };
  }

  {
    const encrypt = crypto.createCipheriv(test.algo,
                                          Buffer.from(test.key, 'hex'),
                                          Buffer.from(test.iv, 'hex'),
                                          options);

    if (test.aad)
      encrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);

    let hex = encrypt.update(test.plain, inputEncoding, 'hex');
    hex += encrypt.final('hex');

    const auth_tag = encrypt.getAuthTag();
    // Only test basic encryption run if output is marked as tampered.
    if (!test.tampered) {
      assert.strictEqual(hex, test.ct);
      assert.strictEqual(auth_tag.toString('hex'), test.tag);
    }
  }

  {
    if (isCCM && common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createDecipheriv(test.algo,
                                Buffer.from(test.key, 'hex'),
                                Buffer.from(test.iv, 'hex'),
                                options);
      }, errMessages.FIPS);
    } else {
      const decrypt = crypto.createDecipheriv(test.algo,
                                              Buffer.from(test.key, 'hex'),
                                              Buffer.from(test.iv, 'hex'),
                                              options);
      decrypt.setAuthTag(Buffer.from(test.tag, 'hex'));
      if (test.aad)
        decrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);

      const outputEncoding = test.plainIsHex ? 'hex' : 'ascii';

      let msg = decrypt.update(test.ct, 'hex', outputEncoding);
      if (!test.tampered) {
        msg += decrypt.final(outputEncoding);
        assert.strictEqual(msg, test.plain);
      } else {
        // Assert that final throws if input data could not be verified!
        assert.throws(function() { decrypt.final('hex'); }, errMessages.auth);
      }
    }
  }

  if (test.password) {
    if (common.hasFipsCrypto) {
      assert.throws(() => { crypto.createCipher(test.algo, test.password); },
                    errMessages.FIPS);
    } else {
      const encrypt = crypto.createCipher(test.algo, test.password, options);
      if (test.aad)
        encrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);
      let hex = encrypt.update(test.plain, 'ascii', 'hex');
      hex += encrypt.final('hex');
      const auth_tag = encrypt.getAuthTag();
      // Only test basic encryption run if output is marked as tampered.
      if (!test.tampered) {
        assert.strictEqual(hex, test.ct);
        assert.strictEqual(auth_tag.toString('hex'), test.tag);
      }
    }
  }

  if (test.password) {
    if (common.hasFipsCrypto) {
      assert.throws(() => { crypto.createDecipher(test.algo, test.password); },
                    errMessages.FIPS);
    } else {
      const decrypt = crypto.createDecipher(test.algo, test.password, options);
      decrypt.setAuthTag(Buffer.from(test.tag, 'hex'));
      if (test.aad)
        decrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);
      let msg = decrypt.update(test.ct, 'hex', 'ascii');
      if (!test.tampered) {
        msg += decrypt.final('ascii');
        assert.strictEqual(msg, test.plain);
      } else {
        // Assert that final throws if input data could not be verified!
        assert.throws(function() { decrypt.final('ascii'); }, errMessages.auth);
      }
    }
  }

  {
    // Trying to get tag before inputting all data:
    const encrypt = crypto.createCipheriv(test.algo,
                                          Buffer.from(test.key, 'hex'),
                                          Buffer.from(test.iv, 'hex'),
                                          options);
    encrypt.update('blah', 'ascii');
    assert.throws(function() { encrypt.getAuthTag(); }, errMessages.state);
  }

  {
    // Trying to create cipher with incorrect IV length
    assert.throws(function() {
      crypto.createCipheriv(
        test.algo,
        Buffer.from(test.key, 'hex'),
        Buffer.alloc(0)
      );
    }, errMessages.length);
  }
}

// Non-authenticating mode:
{
  const encrypt =
      crypto.createCipheriv('aes-128-cbc',
                            'ipxp9a6i1Mb4USb4',
                            '6fKjEjR3Vl30EUYC');
  encrypt.update('blah', 'ascii');
  encrypt.final();
  assert.throws(() => encrypt.getAuthTag(), errMessages.state);
  assert.throws(() => encrypt.setAAD(Buffer.from('123', 'ascii')),
                errMessages.state);
}

// GCM only supports specific authentication tag lengths, invalid lengths should
// throw.
{
  for (const length of [0, 1, 2, 6, 9, 10, 11, 17]) {
    assert.throws(() => {
      const decrypt = crypto.createDecipheriv('aes-128-gcm',
                                              'FxLKsqdmv0E9xrQh',
                                              'qkuZpJWCewa6Szih');
      decrypt.setAuthTag(Buffer.from('1'.repeat(length)));
    }, {
      name: 'TypeError',
      message: /Invalid authentication tag length/
    });

    assert.throws(() => {
      crypto.createCipheriv('aes-256-gcm',
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6Szih',
                            {
                              authTagLength: length
                            });
    }, {
      name: 'TypeError',
      message: /Invalid authentication tag length/
    });

    assert.throws(() => {
      crypto.createDecipheriv('aes-256-gcm',
                              'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                              'qkuZpJWCewa6Szih',
                              {
                                authTagLength: length
                              });
    }, {
      name: 'TypeError',
      message: /Invalid authentication tag length/
    });
  }
}

// Test that GCM can produce shorter authentication tags than 16 bytes.
{
  const fullTag = '1debb47b2c91ba2cea16fad021703070';
  for (const [authTagLength, e] of [[undefined, 16], [12, 12], [4, 4]]) {
    const cipher = crypto.createCipheriv('aes-256-gcm',
                                         'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                         'qkuZpJWCewa6Szih', {
                                           authTagLength
                                         });
    cipher.setAAD(Buffer.from('abcd'));
    cipher.update('01234567', 'hex');
    cipher.final();
    const tag = cipher.getAuthTag();
    assert.strictEqual(tag.toString('hex'), fullTag.substr(0, 2 * e));
  }
}

// Test that users can manually restrict the GCM tag length to a single value.
{
  const decipher = crypto.createDecipheriv('aes-256-gcm',
                                           'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                           'qkuZpJWCewa6Szih', {
                                             authTagLength: 8
                                           });

  assert.throws(() => {
    // This tag would normally be allowed.
    decipher.setAuthTag(Buffer.from('1'.repeat(12)));
  }, {
    name: 'TypeError',
    message: /Invalid authentication tag length/
  });

  // The Decipher object should be left intact.
  decipher.setAuthTag(Buffer.from('445352d3ff85cf94', 'hex'));
  const text = Buffer.concat([
    decipher.update('3a2a3647', 'hex'),
    decipher.final(),
  ]);
  assert.strictEqual(text.toString('utf8'), 'node');
}

// Test that create(De|C)ipher(iv)? throws if the mode is CCM and an invalid
// authentication tag length has been specified.
{
  for (const authTagLength of [-1, true, false, NaN, 5.5]) {
    assert.throws(() => {
      crypto.createCipheriv('aes-256-ccm',
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6S',
                            {
                              authTagLength
                            });
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: ""The property 'options.authTagLength' is invalid. "" +
               `Received ${inspect(authTagLength)}`
    });

    assert.throws(() => {
      crypto.createDecipheriv('aes-256-ccm',
                              'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                              'qkuZpJWCewa6S',
                              {
                                authTagLength
                              });
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: ""The property 'options.authTagLength' is invalid. "" +
        `Received ${inspect(authTagLength)}`
    });

    if (!common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createCipher('aes-256-ccm', 'bad password', { authTagLength });
      }, {
        name: 'TypeError',
        code: 'ERR_INVALID_ARG_VALUE',
        message: ""The property 'options.authTagLength' is invalid. "" +
          `Received ${inspect(authTagLength)}`
      });

      assert.throws(() => {
        crypto.createDecipher('aes-256-ccm', 'bad password', { authTagLength });
      }, {
        name: 'TypeError',
        code: 'ERR_INVALID_ARG_VALUE',
        message: ""The property 'options.authTagLength' is invalid. "" +
          `Received ${inspect(authTagLength)}`
      });
    }
  }

  // The following values will not be caught by the JS layer and thus will not
  // use the default error codes.
  for (const authTagLength of [0, 1, 2, 3, 5, 7, 9, 11, 13, 15, 17, 18]) {
    assert.throws(() => {
      crypto.createCipheriv('aes-256-ccm',
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6S',
                            {
                              authTagLength
                            });
    }, errMessages.authTagLength);

    if (!common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createDecipheriv('aes-256-ccm',
                                'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                'qkuZpJWCewa6S',
                                {
                                  authTagLength
                                });
      }, errMessages.authTagLength);

      assert.throws(() => {
        crypto.createCipher('aes-256-ccm', 'bad password', { authTagLength });
      }, errMessages.authTagLength);

      assert.throws(() => {
        crypto.createDecipher('aes-256-ccm', 'bad password', { authTagLength });
      }, errMessages.authTagLength);
    }
  }
}

// Test that create(De|C)ipher(iv)? throws if the mode is CCM or OCB and no
// authentication tag has been specified.
{
  for (const mode of ['ccm', 'ocb']) {
    assert.throws(() => {
      crypto.createCipheriv(`aes-256-${mode}`,
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6S');
    }, {
      message: `authTagLength required for aes-256-${mode}`
    });

    // CCM decryption and create(De|C)ipher are unsupported in FIPS mode.
    if (!common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createDecipheriv(`aes-256-${mode}`,
                                'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                'qkuZpJWCewa6S');
      }, {
        message: `authTagLength required for aes-256-${mode}`
      });

      assert.throws(() => {
        crypto.createCipher(`aes-256-${mode}`, 'very bad password');
      }, {
        message: `authTagLength required for aes-256-${mode}`
      });

      assert.throws(() => {
        crypto.createDecipher(`aes-256-${mode}`, 'very bad password');
      }, {
        message: `authTagLength required for aes-256-${mode}`
      });
    }
  }
}

// Test that setAAD throws if an invalid plaintext length has been specified.
{
  const cipher = crypto.createCipheriv('aes-256-ccm',
                                       'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                       'qkuZpJWCewa6S',
                                       {
                                         authTagLength: 10
                                       });

  for (const plaintextLength of [-1, true, false, NaN, 5.5]) {
    assert.throws(() => {
      cipher.setAAD(Buffer.from('0123456789', 'hex'), { plaintextLength });
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: ""The property 'options.plaintextLength' is invalid. "" +
        `Received ${inspect(plaintextLength)}`
    });
  }
}

// Test that setAAD and update throw if the plaintext is too long.
{
  for (const ivLength of [13, 12]) {
    const maxMessageSize = (1 << (8 * (15 - ivLength))) - 1;
    const key = 'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8';
    const cipher = () => crypto.createCipheriv('aes-256-ccm', key,
                                               '0'.repeat(ivLength),
                                               {
                                                 authTagLength: 10
                                               });

    assert.throws(() => {
      cipher().setAAD(Buffer.alloc(0), {
        plaintextLength: maxMessageSize + 1
      });
    }, /Invalid message length$/);

    const msg = Buffer.alloc(maxMessageSize + 1);
    assert.throws(() => {
      cipher().update(msg);
    }, /Invalid message length/);

    const c = cipher();
    c.setAAD(Buffer.alloc(0), {
      plaintextLength: maxMessageSize
    });
    c.update(msg.slice(1));
  }
}

// Test that setAAD throws if the mode is CCM and the plaintext length has not
// been specified.
{
  assert.throws(() => {
    const cipher = crypto.createCipheriv('aes-256-ccm',
                                         'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                         'qkuZpJWCewa6S',
                                         {
                                           authTagLength: 10
                                         });
    cipher.setAAD(Buffer.from('0123456789', 'hex'));
  }, /options\.plaintextLength required for CCM mode with AAD/);

  if (!common.hasFipsCrypto) {
    assert.throws(() => {
      const cipher = crypto.createDecipheriv('aes-256-ccm',
                                             'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                             'qkuZpJWCewa6S',
                                             {
                                               authTagLength: 10
                                             });
      cipher.setAAD(Buffer.from('0123456789', 'hex'));
    }, /options\.plaintextLength required for CCM mode with AAD/);
  }
}

// Test that final() throws in CCM mode when no authentication tag is provided.
{
  if (!common.hasFipsCrypto) {
    const key = Buffer.from('1ed2233fa2223ef5d7df08546049406c', 'hex');
    const iv = Buffer.from('7305220bca40d4c90e1791e9', 'hex');
    const ct = Buffer.from('8beba09d4d4d861f957d51c0794f4abf8030848e', 'hex');
    const decrypt = crypto.createDecipheriv('aes-128-ccm', key, iv, {
      authTagLength: 10
    });
    // Normally, we would do this:
    // decrypt.setAuthTag(Buffer.from('0d9bcd142a94caf3d1dd', 'hex'));
    assert.throws(() => {
      decrypt.setAAD(Buffer.from('63616c76696e', 'hex'), {
        plaintextLength: ct.length
      });
      decrypt.update(ct);
      decrypt.final();
    }, errMessages.state);
  }
}

// Test that setAuthTag does not throw in GCM mode when called after setAAD.
{
  const key = Buffer.from('1ed2233fa2223ef5d7df08546049406c', 'hex');
  const iv = Buffer.from('579d9dfde9cd93d743da1ceaeebb86e4', 'hex');
  const decrypt = crypto.createDecipheriv('aes-128-gcm', key, iv);
  decrypt.setAAD(Buffer.from('0123456789', 'hex'));
  decrypt.setAuthTag(Buffer.from('1bb9253e250b8069cde97151d7ef32d9', 'hex'));
  assert.strictEqual(decrypt.update('807022', 'hex', 'hex'), 'abcdef');
  assert.strictEqual(decrypt.final('hex'), '');
}

// Test that an IV length of 11 does not overflow max_message_size_.
{
  const key = 'x'.repeat(16);
  const iv = Buffer.from('112233445566778899aabb', 'hex');
  const options = { authTagLength: 8 };
  const encrypt = crypto.createCipheriv('aes-128-ccm', key, iv, options);
  encrypt.update('boom');  // Should not throw 'Message exceeds maximum size'.
  encrypt.final();
}

// Test that the authentication tag can be set at any point before calling
// final() in GCM or OCB mode.
{
  const plain = Buffer.from('Hello world', 'utf8');
  const key = Buffer.from('0123456789abcdef', 'utf8');
  const iv = Buffer.from('0123456789ab', 'utf8');

  for (const mode of ['gcm', 'ocb']) {
    for (const authTagLength of mode === 'gcm' ? [undefined, 8] : [8]) {
      const cipher = crypto.createCipheriv(`aes-128-${mode}`, key, iv, {
        authTagLength
      });
      const ciphertext = Buffer.concat([cipher.update(plain), cipher.final()]);
      const authTag = cipher.getAuthTag();

      for (const authTagBeforeUpdate of [true, false]) {
        const decipher = crypto.createDecipheriv(`aes-128-${mode}`, key, iv, {
          authTagLength
        });
        if (authTagBeforeUpdate) {
          decipher.setAuthTag(authTag);
        }
        const resultUpdate = decipher.update(ciphertext);
        if (!authTagBeforeUpdate) {
          decipher.setAuthTag(authTag);
        }
        const resultFinal = decipher.final();
        const result = Buffer.concat([resultUpdate, resultFinal]);
        assert(result.equals(plain));
      }
    }
  }
}

// Test that setAuthTag can only be called once.
{
  const plain = Buffer.from('Hello world', 'utf8');
  const key = Buffer.from('0123456789abcdef', 'utf8');
  const iv = Buffer.from('0123456789ab', 'utf8');
  const opts = { authTagLength: 8 };

  for (const mode of ['gcm', 'ccm', 'ocb']) {
    const cipher = crypto.createCipheriv(`aes-128-${mode}`, key, iv, opts);
    const ciphertext = Buffer.concat([cipher.update(plain), cipher.final()]);
    const tag = cipher.getAuthTag();

    const decipher = crypto.createDecipheriv(`aes-128-${mode}`, key, iv, opts);
    decipher.setAuthTag(tag);
    assert.throws(() => {
      decipher.setAuthTag(tag);
    }, errMessages.state);
    // Decryption should still work.
    const plaintext = Buffer.concat([
      decipher.update(ciphertext),
      decipher.final(),
    ]);
    assert(plain.equals(plaintext));
  }
}


// Test chacha20-poly1305 rejects invalid IV lengths of 13, 14, 15, and 16 (a
// length of 17 or greater was already rejected).
// - https://www.openssl.org/news/secadv/20190306.txt
{
  // Valid extracted from TEST_CASES, check that it detects IV tampering.
  const valid = {
    algo: 'chacha20-poly1305',
    key: '808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f',
    iv: '070000004041424344454647',
    plain: '4c616469657320616e642047656e746c656d656e206f662074686520636c6173' +
           '73206f66202739393a204966204920636f756c64206f6666657220796f75206f' +
           '6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73' +
           '637265656e20776f756c642062652069742e',
    plainIsHex: true,
    aad: '50515253c0c1c2c3c4c5c6c7',
    ct: 'd31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5' +
        'a736ee62d63dbea45e8ca9671282fafb69da92728b1a71de0a9e06' +
        '0b2905d6a5b67ecd3b3692ddbd7f2d778b8c9803aee328091b58fa' +
        'b324e4fad675945585808b4831d7bc3ff4def08e4b7a9de576d265' +
        '86cec64b6116',
    tag: '1ae10b594f09e26a7e902ecbd0600691',
    tampered: false,
  };

  // Invalid IV lengths should be detected:
  // - 12 and below are valid.
  // - 13-16 are not detected as invalid by some OpenSSL versions.
  check(13);
  check(14);
  check(15);
  check(16);
  // - 17 and above were always detected as invalid by OpenSSL.
  check(17);

  function check(ivLength) {
    const prefix = ivLength - valid.iv.length / 2;
    assert.throws(() => crypto.createCipheriv(
      valid.algo,
      Buffer.from(valid.key, 'hex'),
      Buffer.from(H(prefix) + valid.iv, 'hex')
    ), errMessages.length, `iv length ${ivLength} was not rejected`);

    function H(length) { return '00'.repeat(length); }
  }
}

{
  // CCM cipher without data should not crash, see https://github.com/nodejs/node/issues/38035.
  const algo = 'aes-128-ccm';
  const key = Buffer.alloc(16);
  const iv = Buffer.alloc(12);
  const opts = { authTagLength: 10 };

  for (const cipher of [
    crypto.createCipher(algo, 'foo', opts),
    crypto.createCipheriv(algo, key, iv, opts),
  ]) {
    assert.throws(() => {
      cipher.final();
    }, common.hasOpenSSL3 ? {
      code: 'ERR_OSSL_TAG_NOT_SET'
    } : {
      message: /Unsupported state/
    });
  }
}

{
  const key = Buffer.alloc(32);
  const iv = Buffer.alloc(12);

  for (const authTagLength of [0, 17]) {
    assert.throws(() => {
      crypto.createCipheriv('chacha20-poly1305', key, iv, { authTagLength });
    }, {
      code: 'ERR_CRYPTO_INVALID_AUTH_TAG',
      message: errMessages.authTagLength
    });
  }
}

// ChaCha20-Poly1305 should respect the authTagLength option and should not
// require the authentication tag before calls to update() during decryption.
{
  const key = Buffer.alloc(32);
  const iv = Buffer.alloc(12);

  for (let authTagLength = 1; authTagLength <= 16; authTagLength++) {
    const cipher =
        crypto.createCipheriv('chacha20-poly1305', key, iv, { authTagLength });
    const ciphertext = Buffer.concat([cipher.update('foo'), cipher.final()]);
    const authTag = cipher.getAuthTag();
    assert.strictEqual(authTag.length, authTagLength);

    // The decipher operation should reject all authentication tags other than
    // that of the expected length.
    for (let other = 1; other <= 16; other++) {
      const decipher = crypto.createDecipheriv('chacha20-poly1305', key, iv, {
        authTagLength: other
      });
      // ChaCha20 is a stream cipher so we do not need to call final() to obtain
      // the full plaintext.
      const plaintext = decipher.update(ciphertext);
      assert.strictEqual(plaintext.toString(), 'foo');
      if (other === authTagLength) {
        // The authentication tag length is as expected and the tag itself is
        // correct, so this should work.
        decipher.setAuthTag(authTag);
        decipher.final();
      } else {
        // The authentication tag that we are going to pass to setAuthTag is
        // either too short or too long. If other < authTagLength, the
        // authentication tag is still correct, but it should still be rejected
        // because its security assurance is lower than expected.
        assert.throws(() => {
          decipher.setAuthTag(authTag);
        }, {
          code: 'ERR_CRYPTO_INVALID_AUTH_TAG',
          message: `Invalid authentication tag length: ${authTagLength}`
        });
      }
    }
  }
}

// ChaCha20-Poly1305 should default to an authTagLength of 16. When encrypting,
// this matches the behavior of GCM ciphers. When decrypting, however, it is
// stricter than GCM in that it only allows authentication tags that are exactly
// 16 bytes long, whereas, when no authTagLength was specified, GCM would accept
// shorter tags as long as their length was valid according to NIST SP 800-38D.
// For ChaCha20-Poly1305, we intentionally deviate from that because there are
// no recommended or approved authentication tag lengths below 16 bytes.
{
  const rfcTestCases = TEST_CASES.filter(({ algo, tampered }) => {
    return algo === 'chacha20-poly1305' && tampered === false;
  });
  assert.strictEqual(rfcTestCases.length, 1);

  const [testCase] = rfcTestCases;
  const key = Buffer.from(testCase.key, 'hex');
  const iv = Buffer.from(testCase.iv, 'hex');
  const aad = Buffer.from(testCase.aad, 'hex');

  for (const opt of [
    undefined,
    { authTagLength: undefined },
    { authTagLength: 16 },
  ]) {
    const cipher = crypto.createCipheriv('chacha20-poly1305', key, iv, opt);
    const ciphertext = Buffer.concat([
      cipher.setAAD(aad).update(testCase.plain, 'hex'),
      cipher.final(),
    ]);
    const authTag = cipher.getAuthTag();

    assert.strictEqual(ciphertext.toString('hex'), testCase.ct);
    assert.strictEqual(authTag.toString('hex'), testCase.tag);

    const decipher = crypto.createDecipheriv('chacha20-poly1305', key, iv, opt);
    const plaintext = Buffer.concat([
      decipher.setAAD(aad).update(ciphertext),
      decipher.setAuthTag(authTag).final(),
    ]);

    assert.strictEqual(plaintext.toString('hex'), testCase.plain);
  }
}

```"
"```javascript:modules\internal\errors.js
import { inspect } from ""./util/inspect"";

/**
 * 
 * @template T
 * @param {T} fn 
 * @return {T}
 */
export function hideStackFrames(fn) {
    const hidden = ""__node_internal_"" + fn.name;
    Object.defineProperty(fn, ""name"", { value: hidden });

    return fn;
}

export class ERR_HTTP_HEADERS_SENT extends Error {
    constructor(x) {
        super(
            `Cannot ${x} headers after they are sent to the client`,
        );
        this.code = ""ERR_HTTP_HEADERS_SENT"";
    }
}

export class ERR_HTTP_INVALID_HEADER_VALUE extends TypeError {
    constructor(x, y) {
        super(
            `Invalid value ""${x}"" for header ""${y}""`,
        );
        this.code = ""ERR_HTTP_INVALID_HEADER_VALUE"";
    }
}

export class ERR_HTTP_TRAILER_INVALID extends Error {
    constructor() {
        super(
            `Trailers are invalid with this transfer encoding`,
        );
        this.code = ""ERR_HTTP_TRAILER_INVALID"";
    }
}

export class ERR_INVALID_HTTP_TOKEN extends TypeError {
    constructor(x, y) {
        super(`${x} must be a valid HTTP token [""${y}""]`);
        this.code = ""ERR_INVALID_HTTP_TOKEN"";
    }
}

const classRegExp = /^([A-Z][a-z0-9]*)+$/;

const kTypes = [
    ""string"",
    ""function"",
    ""number"",
    ""object"",
    ""Function"",
    ""Object"",
    ""boolean"",
    ""bigint"",
    ""symbol"",
];

function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [expected];
    let msg = ""The "";
    if (name.endsWith("" argument"")) {
        msg += `${name} `;
    } else {
        const type = name.includes(""."") ? ""property"" : ""argument"";
        msg += `""${name}"" ${type} `;
    }
    msg += ""must be "";

    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }

    if (instances.length > 0) {
        const pos = types.indexOf(""object"");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push(""Object"");
        }
    }

    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join("", "")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += "" or "";
        }
    }

    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join("", "")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += "" or "";
        }
    }

    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join("", "")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += ""an "";
            }
            msg += `${other[0]}`;
        }
    }

    return msg;
}

function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === ""function"" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === ""object"") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, { depth: -1 })}`;
    }
    let inspected = inspect(input, { colors: false });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}

/**
 * 
 * @param {string} val 
 * @returns {string}
 */
function addNumericalSeparator(val) {
    let res = """";
    let i = val.length;
    const start = val[0] === ""-"" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}

export class ERR_OUT_OF_RANGE extends RangeError {
    code = ""ERR_OUT_OF_RANGE"";

    /**
     * 
     * @param {string} str 
     * @param {string} range 
     * @param {unknown} input 
     * @param {boolean} replaceDefaultBoolean 
     */
    constructor(
        str,
        range,
        input,
        replaceDefaultBoolean = false,
    ) {
        // assert(range, 'Missing ""range"" argument');
        let msg = replaceDefaultBoolean
            ? str
            : `The value of ""${str}"" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === ""bigint"") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += ""n"";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;

        super(msg);

        const { name } = this;
        // Add the error code to the name to include it in the stack trace.
        this.name = `${name} [${this.code}]`;
        // Access the stack to generate the error message including the error code from the name.
        this.stack;
        // Reset the name to the actual name.
        this.name = name;
    }
}

export class ERR_INVALID_ARG_TYPE_RANGE extends RangeError {
    constructor(name, expected, actual) {
        const msg = createInvalidArgType(name, expected);

        super(`${msg}.${invalidArgTypeHelper(actual)}`);
        this.code = ""ERR_INVALID_ARG_TYPE"";
    }
}

export class ERR_INVALID_ARG_TYPE extends TypeError {
    /**
     * 
     * @param {string} name 
     * @param {string | string[]} expected 
     * @param {unknown} actual 
     */
    constructor(name, expected, actual) {
        const msg = createInvalidArgType(name, expected);

        super(`${msg}.${invalidArgTypeHelper(actual)}`);
        this.code = ""ERR_INVALID_ARG_TYPE"";
    }

    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}

export class ERR_INVALID_ARG_VALUE_RANGE extends RangeError {
    constructor(name, value, reason = ""is invalid"") {
        const type = name.includes(""."") ? ""property"" : ""argument"";
        const inspected = JSON.stringify(value);

        super(`The ${type} '${name}' ${reason}. Received ${inspected}`,);

        this.code = ""ERR_INVALID_ARG_VALUE""
    }
}

export class ERR_INVALID_ARG_VALUE extends TypeError {
    constructor(name, value, reason = ""is invalid"") {
        const type = name.includes(""."") ? ""property"" : ""argument"";
        const inspected = JSON.stringify(value);

        super(`The ${type} '${name}' ${reason}. Received ${inspected}`,);

        this.code = ""ERR_INVALID_ARG_VALUE""
    }
}

export class ERR_INVALID_CHAR extends TypeError {
    constructor(name, field) {
        super(field
            ? `Invalid character in ${name}`
            : `Invalid character in ${name} [""${field}""]`,
        );
        this.code = ""ERR_INVALID_CHAR"";
    }
}

export class ERR_METHOD_NOT_IMPLEMENTED extends Error {
    constructor(x) {
        super(`The ${x} method is not implemented`);
        this.code = ""ERR_METHOD_NOT_IMPLEMENTED"";
    }
}

export class ERR_STREAM_CANNOT_PIPE extends Error {
    constructor() {
        super(`Cannot pipe, not readable`);
        this.code = ""ERR_STREAM_CANNOT_PIPE"";
    }
}

export class ERR_STREAM_ALREADY_FINISHED extends Error {
    constructor(x) {
        super(
            `Cannot call ${x} after a stream was finished`,
        );
        this.code = ""ERR_STREAM_ALREADY_FINISHED"";
    }
}

export class ERR_STREAM_WRITE_AFTER_END extends Error {
    constructor() {
        super(`write after end`);
        this.code = ""ERR_STREAM_WRITE_AFTER_END"";
    }
}

export class ERR_STREAM_NULL_VALUES extends TypeError {
    constructor() {
        super(`May not write null values to stream`);
        this.code = ""ERR_STREAM_NULL_VALUES"";
    }
}

export class ERR_STREAM_DESTROYED extends Error {
    constructor(x) {
        super(
            `Cannot call ${x} after a stream was destroyed`,
        );
        this.code = ""ERR_STREAM_DESTROYED"";
    }
}

export function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            // If `outerError` is already an `AggregateError`.
            outerError.errors.push(innerError);
            return outerError;
        }
        // eslint-disable-next-line no-restricted-syntax
        const err = new AggregateError(
            [
                outerError,
                innerError,
            ],
            outerError.message,
        );
        // deno-lint-ignore no-explicit-any
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}

export class ERR_SOCKET_BAD_PORT extends RangeError {
    constructor(name, port, allowZero = true) {
        assert(
            typeof allowZero === ""boolean"",
            ""The 'allowZero' argument must be of type boolean."",
        );

        const operator = allowZero ? "">="" : "">"";

        super(
            `${name} should be ${operator} 0 and < 65536. Received ${port}.`,
        );
        this.code = ""ERR_SOCKET_BAD_PORT"";
    }
}

export class ERR_STREAM_PREMATURE_CLOSE extends Error {
    constructor() {
        super(`Premature close`);
        this.code = ""ERR_STREAM_PREMATURE_CLOSE"";
    }
}

export class AbortError extends Error {
    constructor() {
        super(""The operation was aborted"");
        this.code = ""ABORT_ERR"";
        this.name = ""AbortError"";
    }
}

export class ERR_INVALID_CALLBACK extends TypeError {
    constructor(object) {
        super(
            `Callback must be a function. Received ${JSON.stringify(object)}`,
        );
        this.code = ""ERR_INVALID_CALLBACK"";
    }
}

export class ERR_MISSING_ARGS extends TypeError {
    constructor(...args) {
        let msg = ""The "";

        const len = args.length;

        const wrap = (a) => `""${a}""`;

        args = args.map((a) =>
            Array.isArray(a) ? a.map(wrap).join("" or "") : wrap(a)
        );

        switch (len) {
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join("", "");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }

        super(`${msg} must be specified`);
        this.code = ""ERR_MISSING_ARGS"";
    }
}
export class ERR_MISSING_OPTION extends TypeError {
    constructor(x) {
        super(`${x} is required`);
        this.code = ""ERR_MISSING_OPTION"";
    }
}
export class ERR_MULTIPLE_CALLBACK extends Error {
    constructor() {
        super(`Callback called multiple times`);
        this.code = ""ERR_MULTIPLE_CALLBACK"";
    }
}

export class ERR_STREAM_PUSH_AFTER_EOF extends Error {
    constructor() {
        super(`stream.push() after EOF`);
        this.code = ""ERR_STREAM_PUSH_AFTER_EOF"";
    }
}

export class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends Error {
    constructor() {
        super(
            `stream.unshift() after end event`,
        );
        this.code = ""ERR_STREAM_UNSHIFT_AFTER_END_EVENT"";
    }
}

export class ERR_UNKNOWN_ENCODING extends TypeError {
    constructor(x) {
        super(`Unknown encoding: ${x}`);
        this.code = ""ERR_UNKNOWN_ENCODING"";
    }
}

function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}

export class ERR_INVALID_RETURN_VALUE extends TypeError {
    constructor(input, name, value) {
        super(
            `Expected ${input} to be returned from the ""${name}"" function but got ${buildReturnPropertyType(value)}.`,
        );
        this.code = ""ERR_INVALID_RETURN_VALUE"";
    }
}

export class ERR_INCOMPATIBLE_OPTION_PAIR extends TypeError {
    constructor(input, name) {
        super(
            `Option ""${input}"" cannot be used in combination with option ""${name}""`,
        );
        this.code = ""ERR_INCOMPATIBLE_OPTION_PAIR"";
    }
}

export const captureStackTrace = hideStackFrames(
    function captureStackTrace(err) {
        // Error.captureStackTrace is only available in V8
        const e = new Error();
        Object.defineProperties(err, {
            stack: {
                configurable: true,
                writable: true,
                get: () => e.stack
            }
        })
        return err;
    },
);

const captureLargerStackTrace = hideStackFrames(
    function captureLargerStackTrace(err) {
        captureStackTrace(err);

        return err;
    },
);


/**
 * All error instances in Node have additional methods and properties
 * This export class is meant to be extended by these instances abstracting native JS error instances
 */
export class NodeErrorAbstraction extends Error {
    /**
     * @type {string}
     */
    code;

    /**
     * 
     * @param {string} name 
     * @param {string} code 
     * @param {string} message 
     */
    constructor(name, code, message) {
        super(message);
        this.code = code;
        this.name = name;
        //This number changes depending on the name of this class
        //20 characters as of now
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }

    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}

const kIsNodeError = Symbol(""kIsNodeError"");

/**
 * @typedef {Object} NodeSystemErrorCtx
 * @property {string} code
 * @property {string} syscall
 * @property {string} message
 * @property {number} errno
 * @property {string=} path
 * @property {string=} dest
 */

class NodeSystemError extends NodeErrorAbstraction {
    /**
     * 
     * @param {string} key 
     * @param {NodeSystemErrorCtx} context 
     * @param {string} msgPrefix 
     */
    constructor(key, context, msgPrefix) {
        let message = `${msgPrefix}: ${context.syscall} returned ` +
            `${context.code} (${context.message})`;

        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }

        super(""SystemError"", key, message);
        // captureLargerStackTrace(this);

        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true,
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false,
            },
            errno: {
                get() {
                    return context.errno;
                },
                set: (value) => {
                    context.errno = value;
                },
                enumerable: true,
                configurable: true,
            },
            syscall: {
                get() {
                    return context.syscall;
                },
                set: (value) => {
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true,
            },
        });

        if (context.path !== undefined) {
            Object.defineProperty(this, ""path"", {
                get() {
                    return context.path;
                },
                set: (value) => {
                    context.path = value;
                },
                enumerable: true,
                configurable: true,
            });
        }

        if (context.dest !== undefined) {
            Object.defineProperty(this, ""dest"", {
                get() {
                    return context.dest;
                },
                set: (value) => {
                    context.dest = value;
                },
                enumerable: true,
                configurable: true,
            });
        }
    }

    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}

/**
 * 
 * @param {string} key 
 * @param {string} msgPrfix 
 */
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        /**
         * 
         * @param {NodeSystemErrorCtx} ctx 
         */
        constructor(ctx) {
            super(key, ctx, msgPrfix);
        }
    };
}

export const ERR_FS_EISDIR = makeSystemErrorWithCode(
    ""ERR_FS_EISDIR"",
    ""Path is a directory"",
);

export const ERR_FS_CP_DIR_TO_NON_DIR = makeSystemErrorWithCode('ERR_FS_CP_DIR_TO_NON_DIR',
    'Cannot overwrite directory with non-directory');
export const ERR_FS_CP_EEXIST = makeSystemErrorWithCode('ERR_FS_CP_EEXIST', 'Target already exists');
export const ERR_FS_CP_EINVAL = makeSystemErrorWithCode('ERR_FS_CP_EINVAL', 'Invalid src or dest');
export const ERR_FS_CP_FIFO_PIPE = makeSystemErrorWithCode('ERR_FS_CP_FIFO_PIPE', 'Cannot copy a FIFO pipe');
export const ERR_FS_CP_NON_DIR_TO_DIR = makeSystemErrorWithCode('ERR_FS_CP_NON_DIR_TO_DIR',
    'Cannot overwrite non-directory with directory');
export const ERR_FS_CP_SOCKET = makeSystemErrorWithCode('ERR_FS_CP_SOCKET', 'Cannot copy a socket file');
export const ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY = makeSystemErrorWithCode('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY',
    'Cannot overwrite symlink in subdirectory of self');
export const ERR_FS_CP_UNKNOWN = makeSystemErrorWithCode('ERR_FS_CP_UNKNOWN', 'Cannot copy an unknown file type');

/**
 * 
 * @param {number} name 
 * @returns {[string, string]}
 */
function uvErrmapGet(name) {
    return errorMap.get(name);
}

const uvUnmappedError = [""UNKNOWN"", ""unknown error""];

/**
 * This creates an error compatible with errors produced in the C++
 * function UVException using a context object with data assembled in C++.
 * The goal is to migrate them to ERR_* errors later when compatibility is
 * not a concern.
 */
export const uvException = hideStackFrames(
    /**
     * 
     * @param {NodeSystemErrorCtx} ctx 
     * @returns 
     */
    function uvException(ctx) {
        const { 0: code, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;

        let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;

        let path;
        let dest;

        if (ctx.path) {
            path = ctx.path.toString();
            message += ` '${path}'`;
        }
        if (ctx.dest) {
            dest = ctx.dest.toString();
            message += ` -> '${dest}'`;
        }


        const err = new Error(message);

        for (const prop of Object.keys(ctx)) {
            if (prop === ""message"" || prop === ""path"" || prop === ""dest"") {
                continue;
            }

            err[prop] = ctx[prop];
        }

        err.code = code;

        if (path) {
            err.path = path;
        }

        if (dest) {
            err.dest = dest;
        }

        return captureLargerStackTrace(err);
    }
);

export function isErrorStackTraceLimitWritable() {
    // Do no touch Error.stackTraceLimit as V8 would attempt to install
    // it again during deserialization.
    if (false && import('v8').startupSnapshot.isBuildingSnapshot()) {
        return false;
    }

    const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');
    if (desc === undefined) {
        return Object.isExtensible(Error);
    }

    return Object.prototype.hasOwnProperty(desc, 'writable') ?
        desc.writable :
        desc.set !== undefined;
}

export class ERR_UNAVAILABLE_DURING_EXIT extends Error {
    constructor() {
        super(
            ""ERR_UNAVAILABLE_DURING_EXIT"",
            `Cannot call function in process exit handler`,
        );
    }
}

export class ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED extends TypeError {
    constructor() {
        super(
            ""ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED"",
            `Snapshot is not supported in this context`,
        );
    }
}

export class ERR_AMBIGUOUS_ARGUMENT extends TypeError {
    constructor(arg, msg) {
        super(
            ""ERR_AMBIGUOUS_ARGUMENT"",
            `The ${arg} argument is ambiguous. ${msg}`,
        );
    }
}

export class ERR_DIR_CLOSED extends Error {
    constructor() {
        super(""Directory handle was closed"");
        this.code = ""ERR_DIR_CLOSED"";
    }
}

export class ERR_DIR_CONCURRENT_OPERATION extends Error {
    constructor() {
        super(
            ""Cannot do synchronous work on directory handle with concurrent asynchronous operations"",
        );
        this.code = ""ERR_DIR_CONCURRENT_OPERATION"";
    }
}

export class ERR_FS_FILE_TOO_LARGE extends RangeError {
    constructor(x) {
        super(
            `File size (${x}) is greater than 2 GB`,
        );
        this.code = ""ERR_FS_FILE_TOO_LARGE"";
    }
}

export class AggregateError extends Error {
    constructor(errs) {
        super();
        this.name = ""AggregateError"";
        this.code = errs[0].code;
        this.errors = errs;
    }
}

export class ERR_FS_INVALID_SYMLINK_TYPE extends Error {
    constructor(x) {
        super(
            `Symlink type must be one of ""dir"", ""file"", or ""junction"". Received ""${x}""`,
        );
        this.code = ""ERR_FS_INVALID_SYMLINK_TYPE"";
    }
}

export class ERR_CRYPTO_FIPS_FORCED extends Error {
    constructor() {
        super(
            'Cannot set FIPS mode, it was forced with --force-fips at startup.',
        );
        this.code = ""ERR_CRYPTO_FIPS_FORCED"";
    }
}

export class ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH extends RangeError {
    constructor() {
        super(
            'Input buffers must have the same byte length',
        );
        this.code = ""ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH"";
    }
}

export class ERR_OPERATION_FAILED extends Error {
    constructor(x) {
        super(
            `Operation failed: ${x}`,
        );
        this.code = ""ERR_OPERATION_FAILED"";
    }
}

export class ERR_CRYPTO_ENGINE_UNKNOWN extends Error {
    constructor(x) {
        super(
            `Engine ""${x}"" was not found`,
        );
        this.code = ""ERR_CRYPTO_ENGINE_UNKNOWN"";
    }
}

export class ERR_CRYPTO_INVALID_DIGEST extends TypeError {
    constructor(x) {
        super(`Invalid digest: ${x}`);
        this.code = ""ERR_CRYPTO_INVALID_DIGEST"";
    }
}

export class ERR_CRYPTO_SCRYPT_INVALID_PARAMETER extends Error {
    constructor() {
        super(`Invalid scrypt parameter`);
        this.code = ""ERR_CRYPTO_SCRYPT_INVALID_PARAMETER"";
    }
}

export class ERR_CRYPTO_SCRYPT_NOT_SUPPORTED extends Error {
    constructor() {
        super(`Scrypt algorithm not supported`);
        this.code = ""ERR_CRYPTO_SCRYPT_NOT_SUPPORTED"";
    }
}

export class ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS extends Error {
    constructor(a, b) {
        super(`The selected key encoding ${a} ${b}.`);
        this.code = ""ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS"";
    }
}

export class ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE extends TypeError {
    constructor(t, e) {
        super(`Invalid key object type ${t}, expected ${e}.`);
        this.code = ""ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE"";
    }
}

export class ERR_CRYPTO_INVALID_JWK extends TypeError {
    constructor() {
        super(`Invalid JWK data`);
        this.code = ""ERR_CRYPTO_INVALID_JWK"";
    }
}

export class ERR_ILLEGAL_CONSTRUCTOR extends TypeError {
    constructor() {
        super(`Illegal constructor`);
        this.code = ""ERR_ILLEGAL_CONSTRUCTOR"";
    }
}

export class ERR_CRYPTO_INVALID_KEYLEN extends RangeError {
    constructor() {
        super(`Invalid key length`);
        this.code = ""ERR_CRYPTO_INVALID_KEYLEN"";
    }
}

export class ERR_CRYPTO_HASH_FINALIZED extends Error {
    constructor() {
        super(`Digest already called`);
        this.code = ""ERR_CRYPTO_HASH_FINALIZED"";
    }
}

export class ERR_CRYPTO_HASH_UPDATE_FAILED extends Error {
    constructor() {
        super(`Hash update failed`);
        this.code = ""ERR_CRYPTO_HASH_UPDATE_FAILED"";
    }
}

export class ERR_CRYPTO_INVALID_STATE extends Error {
    constructor() {
        super(`Invalid state`);
        this.code = ""ERR_CRYPTO_INVALID_STATE"";
    }
}

export class ERR_CRYPTO_UNKNOWN_CIPHER extends Error {
    constructor() {
        super(`Unknown cipher`);
        this.code = ""ERR_CRYPTO_UNKNOWN_CIPHER"";
    }
}

```"
"```javascript:modules\http.js
import * as net from 'wasi_net'
import * as httpx from 'wasi_http'
import { TextDecoder } from 'util'
import { Buffer } from 'buffer'
import { EventEmitter } from 'events'
import process from 'process'
import { validatePort } from 'internal/validators'
import { Readable, Writable } from ""stream"";
import { isTypedArray } from 'util/types'

const URL = httpx.URL;

export class Request {
    constructor(input, init = {}) {

        let parsedURL

        if (input instanceof Request) {
            parsedURL = new URL(input.url)
        } else {
            parsedURL = new URL(input)
            input = {}
        }

        this.url = parsedURL;

        if (parsedURL.username !== '' || parsedURL.password !== '') {
            throw new TypeError(`${parsedURL} is an url with embedded credentails.`)
        }

        let method = init.method || input.method || 'GET'
        this.method = method.toUpperCase();

        let headers = init.headers || input.headers || {}
        if (!headers.has('Accept')) {
            headers.set('Accept', '*/*')
        }

        this.headers = headers
    }

    get [Symbol.toStringTag]() {
        return 'Request'
    }

    clone() {
        return new Request(this)
    }
}

export class Response {
    #chunked = false;
    #chunkBuff = null;
    #bodyUsed = false

    constructor(resp, buffer, reader, option = {}) {
        this.response = resp
        this.buffer = buffer
        this.reader = reader
        this.url = option.url

        this.headers = resp.headers
        this.statusText = resp.statusText
        this.status = resp.status

        if (typeof (resp.bodyLength) === ""number"") {
            this.#chunked = false
        } else {
            this.#chunked = true
            this.#chunkBuff = buffer
            this.buffer = new httpx.Buffer()
        }

        this.onChunk = undefined;
    }

    get chunked() {
        return this.#chunked
    }

    get ok() {
        return this.status >= 200 && this.status < 300;
    }

    get bodyUsed() {
        return this.#bodyUsed
    }

    async #readChunk() {
        while (true) {
            let chunk = this.#chunkBuff.parseChunk();

            if (chunk === undefined) {
                let data = await this.reader.read()
                if (data === undefined) {
                    throw new Error('socket is shutdown')
                }
                this.#chunkBuff.write(data)
                continue
            } else if (chunk === null) {
                // end
                return null
            } else if (chunk instanceof ArrayBuffer) {
                return chunk
            } else {
                throw chunk
            }
        }
    }

    async #readBody() {
        while (true) {

            if (this.buffer.byteLength >= this.response.bodyLength) {
                let buf = this.buffer.buffer;
                this.buffer.clear();
                return buf;
            }

            let data = await this.reader.read()
            if (data === undefined) {
                let buf = this.buffer.buffer;
                this.buffer.clear();
                return buf;
            }

            this.buffer.write(data)
        }
    }

    async arrayBuffer() {
        this.#bodyUsed = true;
        if (this.#chunked) {
            while (true) {
                let chunk = await this.#readChunk();
                if (chunk === null) {
                    let buf = this.buffer.buffer;
                    this.buffer.clear();
                    return buf;
                }
                this.buffer.write(chunk)
                if (typeof this.onChunk === 'function') {
                    let onChunk = this.onChunk;
                    onChunk(chunk)
                }
            }
        } else {
            let body = await this.#readBody()
            if (typeof this.onChunk === 'function') {
                let onChunk = this.onChunk;
                onChunk(body)
            }
            return body
        }
    }

    async text() {
        return new TextDecoder().decode(await this.arrayBuffer())
    }

    async json() {
        return JSON.parse(await this.text())
    }

    get [Symbol.toStringTag]() {
        return 'Response'
    }
}

async function wait_response(reader, url) {
    let buf = new httpx.Buffer()
    let resp = undefined
    while (true) {
        let buff = await reader.read()
        if (buff == undefined && resp == undefined) {
            throw new TypeError('Illegal response')
        }
        buf.append(buff)
        resp = buf.parseResponse()
        if (resp instanceof httpx.WasiResponse) {
            return new Response(resp, buf, reader, { url })
        }
    }
}

export async function fetch(input, init = {}) {
    let url = new httpx.URL(input)
    if (url.username !== '' || url.password != '') {
        throw new TypeError(`${input} is an url with embedded credentails.`)
    }

    let method = init.method || 'GET'
    method = method.toUpperCase();

    let headers = init.headers || {}
    if (!headers['Accept']) {
        headers['Accept'] = '*/*'
    }
    if (!headers['Host']) {
        headers['Host'] = url.host
    }

    var s;
    if (url.scheme == 'https' && net.WasiTlsConn) {
        s = await net.WasiTlsConn.connect(url.host, url.port);
    } else {
        s = await net.WasiTcpConn.connect(url.host, url.port);
    }

    let req = new httpx.WasiRequest()
    req.version = init.version || 'HTTP/1.1'
    req.headers = headers

    let path = url.path
    let query = url.query
    if (query != undefined) {
        req.uri = `${path}?${query}`
    } else {
        req.uri = path
    }

    req.method = method
    req.body = init.body || ''
    s.write(req.encode())
    return await wait_response(s, url)
}

const STATUS_CODES = {
    100: 'Continue',                   // RFC 7231 6.2.1
    101: 'Switching Protocols',        // RFC 7231 6.2.2
    102: 'Processing',                 // RFC 2518 10.1 (obsoleted by RFC 4918)
    103: 'Early Hints',                // RFC 8297 2
    200: 'OK',                         // RFC 7231 6.3.1
    201: 'Created',                    // RFC 7231 6.3.2
    202: 'Accepted',                   // RFC 7231 6.3.3
    203: 'Non-Authoritative Information', // RFC 7231 6.3.4
    204: 'No Content',                 // RFC 7231 6.3.5
    205: 'Reset Content',              // RFC 7231 6.3.6
    206: 'Partial Content',            // RFC 7233 4.1
    207: 'Multi-Status',               // RFC 4918 11.1
    208: 'Already Reported',           // RFC 5842 7.1
    226: 'IM Used',                    // RFC 3229 10.4.1
    300: 'Multiple Choices',           // RFC 7231 6.4.1
    301: 'Moved Permanently',          // RFC 7231 6.4.2
    302: 'Found',                      // RFC 7231 6.4.3
    303: 'See Other',                  // RFC 7231 6.4.4
    304: 'Not Modified',               // RFC 7232 4.1
    305: 'Use Proxy',                  // RFC 7231 6.4.5
    307: 'Temporary Redirect',         // RFC 7231 6.4.7
    308: 'Permanent Redirect',         // RFC 7238 3
    400: 'Bad Request',                // RFC 7231 6.5.1
    401: 'Unauthorized',               // RFC 7235 3.1
    402: 'Payment Required',           // RFC 7231 6.5.2
    403: 'Forbidden',                  // RFC 7231 6.5.3
    404: 'Not Found',                  // RFC 7231 6.5.4
    405: 'Method Not Allowed',         // RFC 7231 6.5.5
    406: 'Not Acceptable',             // RFC 7231 6.5.6
    407: 'Proxy Authentication Required', // RFC 7235 3.2
    408: 'Request Timeout',            // RFC 7231 6.5.7
    409: 'Conflict',                   // RFC 7231 6.5.8
    410: 'Gone',                       // RFC 7231 6.5.9
    411: 'Length Required',            // RFC 7231 6.5.10
    412: 'Precondition Failed',        // RFC 7232 4.2
    413: 'Payload Too Large',          // RFC 7231 6.5.11
    414: 'URI Too Long',               // RFC 7231 6.5.12
    415: 'Unsupported Media Type',     // RFC 7231 6.5.13
    416: 'Range Not Satisfiable',      // RFC 7233 4.4
    417: 'Expectation Failed',         // RFC 7231 6.5.14
    418: 'I\'m a Teapot',              // RFC 7168 2.3.3
    421: 'Misdirected Request',        // RFC 7540 9.1.2
    422: 'Unprocessable Entity',       // RFC 4918 11.2
    423: 'Locked',                     // RFC 4918 11.3
    424: 'Failed Dependency',          // RFC 4918 11.4
    425: 'Too Early',                  // RFC 8470 5.2
    426: 'Upgrade Required',           // RFC 2817 and RFC 7231 6.5.15
    428: 'Precondition Required',      // RFC 6585 3
    429: 'Too Many Requests',          // RFC 6585 4
    431: 'Request Header Fields Too Large', // RFC 6585 5
    451: 'Unavailable For Legal Reasons', // RFC 7725 3
    500: 'Internal Server Error',      // RFC 7231 6.6.1
    501: 'Not Implemented',            // RFC 7231 6.6.2
    502: 'Bad Gateway',                // RFC 7231 6.6.3
    503: 'Service Unavailable',        // RFC 7231 6.6.4
    504: 'Gateway Timeout',            // RFC 7231 6.6.5
    505: 'HTTP Version Not Supported', // RFC 7231 6.6.6
    506: 'Variant Also Negotiates',    // RFC 2295 8.1
    507: 'Insufficient Storage',       // RFC 4918 11.5
    508: 'Loop Detected',              // RFC 5842 7.2
    509: 'Bandwidth Limit Exceeded',
    510: 'Not Extended',               // RFC 2774 7
    511: 'Network Authentication Required' // RFC 6585 6
};

const METHODS = [
    'GET',
    'POST',
    'PUT',
    'DELETE',
    'CONNECT',
    'HEAD',
    'OPTIONS',
    'TRACE',
    'PATCH'
];

function chunkToU8(chunk) {
    if (typeof chunk === ""string"") {
        return Buffer.from(chunk);
    }
    if (isTypedArray(chunk)) {
        return Buffer.from(chunk);
    }
    return chunk;
}

class ClientRequest extends Writable {
    body = null;
    constructor(opts, cb) {
        super();
        this.opts = opts;
        this.cb = cb
        this.body = new httpx.Buffer()
    }

    // deno-lint-ignore no-explicit-any
    _write(chunk, _enc, cb) {
        this.body.write(chunkToU8(chunk)?.buffer)
        cb()
    }

    async _final() {
        try {
            const opts = { body: this.body, method: this.opts.method, headers: this.opts.headers };
            const mayResponse = await fetch(this._createUrlStrFromOptions(this.opts), opts)
            const res = new IncomingMessageForClient(mayResponse);
            this.emit(""response"", res);
            this.cb?.(res);
        } catch (e) {
            this.emit('error', e)
        }
    }

    abort() {
        this.destroy();
    }

    _createCustomClient() {
        return Promise.resolve(undefined);
    }

    // deno-lint-ignore no-explicit-any
    _createUrlStrFromOptions(opts) {
        if (opts.href) {
            return opts.href;
        } else {
            const {
                auth,
                protocol,
                host,
                hostname,
                path,
                port,
            } = opts;
            return `${protocol}//${auth ? `${auth}@` : """"}${host ?? hostname}${port ? `:${port}` : """"}${path}`;
        }
    }

    get [Symbol.toStringTag]() {
        return 'Request'
    }
}

export class IncomingMessageForClient extends Readable {
    constructor(response) {
        super();
        this.response = response;
    }

    async _read(_size) {
        try {
            this.response.onChunk = (chunk) => {
                this.push(Buffer.from(chunk));
            }

            const _ = await this.response.arrayBuffer();
            this.emit('end')
        } catch (e) {
            // deno-lint-ignore no-explicit-any
            this.destroy(e);
        }
    }

    get headers() {
        if (this.response) {
            return Object.fromEntries(this.response.headers.entries());
        }
        return {};
    }

    get trailers() {
        return {};
    }

    get statusCode() {
        return this.response?.status || 0;
    }

    get statusMessage() {
        return this.response?.statusText || """";
    }
}

export class ServerResponse extends Writable {
    statusCode = undefined;
    statusMessage = undefined;
    #headers = {};
    headersSent = false;
    #conn;
    #firstChunk = null;
    #_end = false;

    constructor(conn) {
        super({
            autoDestroy: true,
            defaultEncoding: ""utf-8"",
            emitClose: true,
            write: (chunk, _encoding, cb) => {
                if (!this.headersSent) {
                    if (this.#firstChunk === null) {
                        this.#firstChunk = chunk;
                        if (!this.#_end) {
                            this.respond(false, this.#firstChunk);
                            this.#firstChunk = null;
                        }
                        return cb();
                    } else {
                        this.respond(false, this.#firstChunk);
                        this.#firstChunk = null;
                    }
                }

                this.#conn.write(chunk);
                return cb();
            },
            final: (cb) => {
                if (this.#firstChunk) {
                    this.respond(true, this.#firstChunk);
                } else if (!this.headersSent) {
                    this.respond(true);
                }
                if (this.#conn.connection == 'close') {
                    this.#conn.close()
                } else {
                    this.#conn.end();
                }
                return cb();
            },
            destroy: (err, cb) => {
                // if (err) {
                //     controller.error(err);
                // }
                return cb(null);
            },
        });
        this.#conn = conn;
    }

    setHeader(name, value) {
        this.#headers[name.toLowerCase()] = value;
        return this;
    }

    getHeader(name) {
        return this.#headers[name.toLowerCase()];
    }
    removeHeader(name) {
        return delete this.#headers[name.toLowerCase()];
    }
    getHeaderNames() {
        return Array.from(Object.keys(this.#headers));
    }
    hasHeader(name) {
        return this.#headers[name.toLowerCase()] != undefined;
    }

    writeHead(status, headers) {
        this.statusCode = status;
        for (const k in headers) {
            this.#headers[k.toLowerCase()] = headers[k];
        }
        return this;
    }

    #ensureHeaders(singleChunk) {
        if (this.statusCode === undefined) {
            this.statusCode = 200;
            this.statusMessage = ""OK"";
        }
        if (typeof singleChunk === ""string"" && !this.hasHeader(""content-type"")) {
            this.setHeader(""content-type"", ""text/plain;charset=UTF-8"");
        }
    }

    respond(final, singleChunk) {

        this.headersSent = true;
        this.#ensureHeaders(singleChunk);
        if (final) {
            this.#conn.respondWith(
                singleChunk, {
                headers: this.#headers,
                status: this.statusCode,
                statusText: this.statusMessage,
            }
            ).catch(() => {
                // ignore this error
            });
        } else {
            this.#conn.chunk({
                headers: this.#headers,
                status: this.statusCode,
                statusText: this.statusMessage,
            });
            this.#conn.write(singleChunk)
        }
    }

    // deno-lint-ignore no-explicit-any
    end(chunk, encoding, cb) {
        if (!this.headersSent) {
            if (!chunk && this.hasHeader(""transfer-encoding"")) {
                // FIXME(bnoordhuis) Node sends a zero length chunked body instead, i.e.,
                // the trailing ""0\r\n"", but respondWith() just hangs when I try that.
                this.setHeader(""content-length"", ""0"");
                this.removeHeader(""transfer-encoding"");
            }
        }
        this.#_end = true;

        // @ts-expect-error The signature for cb is stricter than the one implemented here
        return super.end(chunk, encoding, cb);
    }
}

export class IncomingMessageForServer extends Readable {
    #req;
    url;

    constructor(req, conn) {
        // Check if no body (GET/HEAD/OPTIONS/...)
        let value = req.body;
        super({
            autoDestroy: true,
            emitClose: true,
            objectMode: false,
            read: async function (_size) {
                if (!value) {
                    this.push(null);
                } else {
                    this.push(Buffer.from(value));
                    value = null;
                }
            },
            destroy: (err, cb) => {
                conn.close();
                cb(err);
            },
        });
        this.#req = req;
        this.url = req.uri;
    }

    get aborted() {
        return false;
    }
    get httpVersion() {
        return this.#req.version;
    }

    get headers() {
        return this.#req.headers;
    }
    get method() {
        return this.#req.method;
    }
}

class HttpConn {

    #chunk = undefined;
    #connection = 'close';
    #version = ""HTTP/1.1"";
    #chunkBuffer = undefined;
    #respHeaders;

    constructor(socket) {
        this.socket = socket
    }

    get connection() {
        return this.#connection;
    }

    get version() {
        return this.#version
    }

    async nextRequest() {
        let buffer = new httpx.Buffer();
        while (true) {
            let d = await this.socket.read();
            if (d == undefined || d.byteLength <= 0) {
                return null;
            }
            buffer.append(d);
            try {
                let req = buffer.parseRequest();
                if (req instanceof httpx.WasiRequest) {
                    this.#version = req.version;
                    if (this.#version == ""HTTP/1.1"") {
                        this.#connection = (req.getHeader('connection') ?? ""keep-alive"").toLowerCase()
                    } else if (this.#version == ""HTTP/1.0"") {
                        this.#connection = (req.getHeader('connection') ?? ""close"").toLowerCase()
                    }
                    return req
                }
            } catch (e) {
                return null;
            }
        }
    }

    respondWith(body, resp_header) {
        if (!this.socket) {
            return
        }
        if (body) {
            body = chunkToU8(body)?.buffer;
        }
        let resp = new httpx.WasiResponse()
        resp.version = this.#version;
        resp.headers = resp_header.headers;
        resp.status = resp_header.status;
        resp.statusText = resp_header.statusText;
        this.socket.write(resp.encode(body))
    }

    chunk(resp_header) {
        if (this.#version == ""HTTP/1.1"") {
            let resp = new httpx.WasiResponse()
            resp.version = this.#version;
            resp.headers = resp_header.headers;
            resp.status = resp_header.status;
            resp.statusText = resp_header.statusText;
            this.#chunk = resp.chunk(this.socket)
        } else {
            this.#chunkBuffer = new httpx.Buffer();
            this.#respHeaders = resp_header;
        }
    }

    write(chunk) {
        if (chunk) {
            let conn = this.#chunkBuffer ?? this.#chunk ?? this.socket;
            conn?.write(chunkToU8(chunk).buffer);
        }
    }

    end(chunk) {
        if (this.#chunk) {
            this.#chunk.end(chunk)
            this.#chunk = undefined
            return
        }

        if (this.#chunkBuffer && chunk) {
            this.#chunkBuffer.write(chunk)
        }

        if (this.#chunkBuffer) {
            this.respondWith(this.#chunkBuffer, this.#respHeaders);
            this.#chunkBuffer = null;
        }
    }

    close() {
        this.end()
        this.socket = undefined
    }
}


export function Server(handler) {
    return new ServerImpl(handler);
}


function _normalizeArgs(args) {
    let arr;

    if (args.length === 0) {
        arr = [{}, null];

        return arr;
    }

    const arg0 = args[0];
    let options = {};

    if (typeof arg0 === ""object"" && arg0 !== null) {
        // (options[...][, cb])
        options = arg0;
    } else {
        // ([port][, host][...][, cb])
        options.port = arg0;

        if (args.length > 1 && typeof args[1] === ""string"") {
            options.host = args[1];
        }
    }

    const cb = args[args.length - 1];

    if (typeof cb !== ""function"") {
        arr = [options, null];
    } else {
        arr = [options, cb];
    }

    return arr;
}


class ServerImpl extends EventEmitter {
    #httpConnections = new Set();
    #listener = undefined;
    #listening = false;

    constructor(handler) {
        super();

        if (handler !== undefined) {
            this.on(""request"", handler);
        }
    }

    listen(...args) {
        // TODO(bnoordhuis) Delegate to net.Server#listen().
        const normalized = _normalizeArgs(args);
        const options = normalized[0];
        const cb = normalized[1];

        if (cb != null) {
            // @ts-ignore change EventEmitter's sig to use CallableFunction
            this.once(""listening"", cb);
        }

        let port = 0;
        if (typeof options.port === ""number"" || typeof options.port === ""string"") {
            validatePort(options.port, ""options.port"");
            port = options.port | 0;
        }

        // TODO(bnoordhuis) Node prefers [::] when host is omitted,
        // we on the other hand default to 0.0.0.0.
        // const hostname = options.host ?? """";

        this.#listener = new net.WasiTcpServer(port);
        this.#listening = true;
        this.#listenLoop();

        return this;
    }

    async #listenLoop() {
        const go = async (httpConn) => {
            try {
                for (; ;) {
                    let request = null;
                    try {
                        // Note: httpConn.nextRequest() calls httpConn.close() on error.
                        request = await httpConn.nextRequest();
                    } catch {
                        // Connection closed.
                        // TODO(bnoordhuis) Emit ""clientError"" event on the http.Server
                        // instance? Node emits it when request parsing fails and expects
                        // the listener to send a raw 4xx HTTP response on the underlying
                        // net.Socket but we don't have one to pass to the listener.
                    }
                    if (request === null) {
                        break;
                    }
                    const req = new IncomingMessageForServer(request, httpConn);
                    const res = new ServerResponse(httpConn);
                    this.emit(""request"", req, res);
                }
            } finally {
                this.#httpConnections.delete(httpConn);
                httpConn.close()
            }
        };

        const listener = this.#listener;

        if (listener !== undefined) {
            this.emit(""listening"");

            try {
                while (this.#listening) {
                    let tcp_conn = await listener.accept();
                    try {
                        let httpConn = new HttpConn(tcp_conn);
                        this.#httpConnections.add(httpConn);
                        go(httpConn);
                    } catch {
                        continue;
                    }
                }
            } catch (e) {
                this.emit('error', e)
            } finally {
                this.listening = false
            }
        }
    }

    get listening() {
        return this.#listening !== undefined;
    }

    close(cb) {
        const listening = this.#listening;

        if (typeof cb === ""function"") {
            if (listening) {
                this.once(""close"", cb);
            } else {
                this.once(""close"", function close() {
                    cb(new ERR_SERVER_NOT_RUNNING());
                });
            }
        }

        process.nextTick(() => this.emit(""close""));

        if (listening) {
            this.#listener.close();
            this.#listener = undefined;
            this.#listening = false;

            for (const httpConn of this.#httpConnections) {
                try {
                    httpConn.close();
                } catch {
                    // Already closed.
                }
            }

            this.#httpConnections.clear();
        }

        return this;
    }

    get listening() {
        return this.#listener
    }

    address() {
        const addr = this.#listener.addr;
        return {
            port: addr.port,
            address: addr.hostname,
        };
    }
}

Server.prototype = ServerImpl.prototype;

export function createServer(handler) {
    return Server(handler);
}

function urlToHttpOptions(url) {
    // deno-lint-ignore no-explicit-any
    const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === ""string"" &&
            url.hostname.startsWith(""["")
            ? url.hostname.slice(1, -1)
            : url.hostname,
        path: url.path,
        href: url.href,
    };
    if (url.port !== """") {
        options.port = url.port;
    }
    if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
    }
    return options;
}

export function request(...args) {
    let options = {};
    if (typeof args[0] === ""string"") {
        options = urlToHttpOptions(new URL(args.shift()));
    } else if (args[0] instanceof URL) {
        options = urlToHttpOptions(args.shift());
    }
    if (args[0] && typeof args[0] !== ""function"") {
        Object.assign(options, args.shift());
    }
    args.unshift(options);
    return new ClientRequest(args[0], args[1]);
}

export function get(...args) {
    const req = request(args[0], args[1], args[2]);
    req.end();
    return req;
}

export default {
    ClientRequest,
    STATUS_CODES,
    METHODS,
    createServer,
    Server,
    IncomingMessage: IncomingMessageForServer,
    ServerResponse,
    request,
    get,
};
```"
"```javascript:modules\fmt\printf.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
/**
 * This implementation is inspired by POSIX and Golang but does not port
 * implementation code. */

const State = {
    PASSTHROUGH: 1,
    PERCENT: 2,
    POSITIONAL: 3,
    PRECISION: 4,
    WIDTH: 5,
}

const WorP = {
    WIDTH: 'WIDTH',
    PRECISION: 'PREC',
}

class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}

const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = ""\ufffd"";
const DEFAULT_PRECISION = 6;
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;

const F = {
    sign: 1,
    mantissa: 2,
    fractional: 3,
    esign: 4,
    exponent: 5,
}

class Printf {
    format;
    args = [];
    i;

    state = State.PASSTHROUGH;
    verb = """";
    buf = """";
    argNum = 0;
    flags = new Flags();

    haveSeen;

    // barf, store precision and width errors for later processing ...
    tmpError;

    constructor(format, ...args) {
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({ length: args.length });
        this.i = 0;
    }

    doPrintf() {
        for (; this.i < this.format.length; ++this.i) {
            const c = this.format[this.i];
            switch (this.state) {
                case State.PASSTHROUGH:
                    if (c === ""%"") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === ""%"") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error(""Should be unreachable, certainly a bug in the lib."");
            }
        }
        let extras = false;
        let err = ""%!(EXTRA)"";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }

    // %[<positional>]<flag>...<verb>
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for (; this.i < this.format.length; ++this.i) {
            const c = this.format[this.i];
            switch (this.state) {
                case State.PERCENT:
                    switch (c) {
                        case ""["":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case ""+"":
                            flags.plus = true;
                            break;
                        case ""<"":
                            flags.lessthan = true;
                            break;
                        case ""-"":
                            flags.dash = true;
                            flags.zero = false; // only left pad zeros, dash takes precedence
                            break;
                        case ""#"":
                            flags.sharp = true;
                            break;
                        case "" "":
                            flags.space = true;
                            break;
                        case ""0"":
                            // only left pad zeros, dash takes precedence
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ((""1"" <= c && c <= ""9"") || c === ""."" || c === ""*"") {
                                if (c === ""."") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return; // always end in verb
                            }
                    } // switch c
                    break;
                case State.POSITIONAL:
                    // TODO(bartlomieju): either a verb or * only verb for now
                    if (c === ""*"") {
                        const worp = this.flags.precision === -1
                            ? WorP.WIDTH
                            : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return; // always end in verb
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            } // switch state
        }
    }

    /**
     * Handle width or precision
     * @param wOrP
     */
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            // handle Positional should have already taken care of it...
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === ""number"") {
            switch (wOrP) {
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? ""WIDTH"" : ""PREC"";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }

    /**
     * Handle width and precision
     * @param flags
     */
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for (; this.i !== this.format.length; ++this.i) {
            const c = fmt[this.i];
            switch (this.state) {
                case State.WIDTH:
                    switch (c) {
                        case ""."":
                            // initialize precision, %9.f -> precision=0
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case ""*"":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            // force . or flag at this point
                            break;
                        default: {
                            const val = parseInt(c);
                            // most likely parseInt does something stupid that makes
                            // it unusable for this scenario ...
                            // if we encounter a non (number|*|.) we're done with prec & wid
                            if (isNaN(val)) {
                                this.i--;
                                this.state = State.PERCENT;
                                return;
                            }
                            flags.width = flags.width == -1 ? 0 : flags.width;
                            flags.width *= 10;
                            flags.width += val;
                        }
                    } // switch c
                    break;
                case State.PRECISION: {
                    if (c === ""*"") {
                        this.handleWidthOrPrecisionRef(WorP.PRECISION);
                        break;
                    }
                    const val = parseInt(c);
                    if (isNaN(val)) {
                        // one too far, rewind
                        this.i--;
                        this.state = State.PERCENT;
                        return;
                    }
                    flags.precision *= 10;
                    flags.precision += val;
                    break;
                }
                default:
                    throw new Error(""can't be here. bug."");
            } // switch state
        }
    }

    /** Handle positional */
    handlePositional() {
        if (this.format[this.i] !== ""["") {
            // sanity only
            throw new Error(""Can't happen? Bug."");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for (; this.i !== this.format.length; ++this.i) {
            if (format[this.i] === ""]"") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                //throw new Error(
                //  `invalid character in positional: ${format}[${format[this.i]}]`
                //);
                this.tmpError = ""%!(BAD INDEX)"";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = ""%!(BAD INDEX)"";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }

    /** Handle less than */
    handleLessThan() {
        // deno-lint-ignore no-explicit-any
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== ""Array"") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = ""[ "";
        for (let i = 0; i !== arg.length; ++i) {
            if (i !== 0) str += "", "";
            str += this._handleVerb(arg[i]);
        }
        return str + "" ]"";
    }

    /** Handle verb */
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true; // keep track of used args
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum]; // check out of range
            this.haveSeen[this.argNum] = true; // keep track of used args
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++; // if there is a further positional, it will reset.
        this.state = State.PASSTHROUGH;
    }

    // deno-lint-ignore no-explicit-any
    _handleVerb(arg) {
        switch (this.verb) {
            case ""t"":
                return this.pad(arg.toString());
            case ""b"":
                return this.fmtNumber(arg, 2);
            case ""c"":
                return this.fmtNumberCodePoint(arg);
            case ""d"":
                return this.fmtNumber(arg, 10);
            case ""o"":
                return this.fmtNumber(arg, 8);
            case ""x"":
                return this.fmtHex(arg);
            case ""X"":
                return this.fmtHex(arg, true);
            case ""e"":
                return this.fmtFloatE(arg);
            case ""E"":
                return this.fmtFloatE(arg, true);
            case ""f"":
            case ""F"":
                return this.fmtFloatF(arg);
            case ""g"":
                return this.fmtFloatG(arg);
            case ""G"":
                return this.fmtFloatG(arg, true);
            case ""s"":
                return this.fmtString(arg);
            case ""T"":
                return this.fmtString(typeof arg);
            case ""v"":
                return this.fmtV(arg);
            case ""j"":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }

    /**
     * Pad a string
     * @param s text to pad
     */
    pad(s) {
        const padding = this.flags.zero ? ""0"" : "" "";

        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }

        return s.padStart(this.flags.width, padding);
    }

    /**
     * Pad a number
     * @param nStr
     * @param neg
     */
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = ""-"";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? ""+"" : "" "";
        } else {
            sign = """";
        }
        const zero = this.flags.zero;
        if (!zero) {
            // sign comes in front of padding when padding w/ zero,
            // in from of value if padding with spaces.
            nStr = sign + nStr;
        }

        const pad = zero ? ""0"" : "" "";
        const len = zero ? this.flags.width - sign.length : this.flags.width;

        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }

        if (zero) {
            // see above
            nStr = sign + nStr;
        }
        return nStr;
    }

    /**
     * Format a number
     * @param n
     * @param radix
     * @param upcase
     */
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? """" : num;
            while (num.length < prec) {
                num = ""0"" + num;
            }
        }
        let prefix = """";
        if (this.flags.sharp) {
            switch (radix) {
                case 2:
                    prefix += ""0b"";
                    break;
                case 8:
                    // don't annotate octal 0 with 0...
                    prefix += num.startsWith(""0"") ? """" : ""0"";
                    break;
                case 16:
                    prefix += ""0x"";
                    break;
                default:
                    throw new Error(""cannot handle base: "" + radix);
            }
        }
        // don't add prefix in front of value truncated by precision=0, val=0
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }

    /**
     * Format number with code points
     * @param n
     */
    fmtNumberCodePoint(n) {
        let s = """";
        try {
            s = String.fromCodePoint(n);
        } catch {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }

    /**
     * Format special float
     * @param n
     */
    fmtFloatSpecial(n) {
        // formatting of NaN and Inf are pants-on-head
        // stupid and more or less arbitrary.

        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum(""NaN"", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum(""Inf"", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum(""Inf"", true);
        }
        return """";
    }

    /**
     * Round fraction to precision
     * @param fractional
     * @param precision
     * @returns tuple of fractional and round
     */
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = ""1"" + fractional; // prepend a 1 in case of leading 0
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === ""2"";
            fractional = fractional.substr(1); // remove extra 1
        } else {
            while (fractional.length < precision) {
                fractional += ""0"";
            }
        }
        return [fractional, round];
    }

    /**
     * Format float E
     * @param n
     * @param upcase
     */
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== """") {
            return special;
        }

        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error(""can't happen, bug"");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1
            ? this.flags.precision
            : DEFAULT_PRECISION;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(
            fractional,
            precision,
        );

        let e = m[F.exponent];
        let esign = m[F.esign];
        // scientific notation output with exponent padded to minlen 2
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? ""-"" : ""+"";
            }
        }
        e = e.length == 1 ? ""0"" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? ""E"" : ""e""}${esign}${e}`;
        return this.padNum(val, n < 0);
    }

    /**
     * Format float F
     * @param n
     */
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== """") {
            return special;
        }

        // stupid helper that turns a number into a (potentially)
        // VERY long string.
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ""."";
            }

            const t = n.toExponential().split(""e"");
            let m = t[0].replace(""."", """");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = ""0."";
                for (let i = 0; i !== Math.abs(e) - 1; ++i) {
                    nStr += ""0"";
                }
                return (nStr += m);
            } else {
                const splIdx = e + 1;
                while (m.length < splIdx) {
                    m += ""0"";
                }
                return m.substr(0, splIdx) + ""."" + m.substr(splIdx);
            }
        }
        // avoiding sign makes padding easier
        const val = expandNumber(Math.abs(n));
        const arr = val.split(""."");
        let dig = arr[0];
        let fractional = arr[1];

        const precision = this.flags.precision !== -1
            ? this.flags.precision
            : DEFAULT_PRECISION;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }

    /**
     * Format float G
     * @param n
     * @param upcase
     */
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== """") {
            return special;
        }

        // The double argument representing a floating-point number shall be
        // converted in the style f or e (or in the style F or E in
        // the case of a G conversion specifier), depending on the
        // value converted and the precision. Let P equal the
        // precision if non-zero, 6 if the precision is omitted, or 1
        // if the precision is zero. Then, if a conversion with style E would
        // have an exponent of X:

        //     - If P > X>=-4, the conversion shall be with style f (or F )
        //     and precision P -( X+1).

        //     - Otherwise, the conversion shall be with style e (or E )
        //     and precision P -1.

        // Finally, unless the '#' flag is used, any trailing zeros shall be
        // removed from the fractional portion of the result and the
        // decimal-point character shall be removed if there is no
        // fractional portion remaining.

        // A double argument representing an infinity or NaN shall be
        // converted in the style of an f or F conversion specifier.
        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html

        let P = this.flags.precision !== -1
            ? this.flags.precision
            : DEFAULT_PRECISION;
        P = P === 0 ? 1 : P;

        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error(""can't happen"");
        }

        const X = parseInt(m[F.exponent]) * (m[F.esign] === ""-"" ? -1 : 1);
        let nStr = """";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, """");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? ""E"" : ""e"");
            }
        }
        return nStr;
    }

    /**
     * Format string
     * @param s
     */
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }

    /**
     * Format hex
     * @param val
     * @param upper
     */
    fmtHex(val, upper = false) {
        // allow others types ?
        switch (typeof val) {
            case ""number"":
                return this.fmtNumber(val, 16, upper);
            case ""string"": {
                const sharp = this.flags.sharp && val.length !== 0;
                let hex = sharp ? ""0x"" : """";
                const prec = this.flags.precision;
                const end = prec !== -1 ? min(prec, val.length) : val.length;
                for (let i = 0; i !== end; ++i) {
                    if (i !== 0 && this.flags.space) {
                        hex += sharp ? "" 0x"" : "" "";
                    }
                    // TODO(bartlomieju): for now only taking into account the
                    // lower half of the codePoint, ie. as if a string
                    // is a list of 8bit values instead of UCS2 runes
                    const c = (val.charCodeAt(i) & 0xff).toString(16);
                    hex += c.length === 1 ? `0${c}` : c;
                }
                if (upper) {
                    hex = hex.toUpperCase();
                }
                return this.pad(hex);
            }
            default:
                throw new Error(
                    ""currently only number and string are implemented for hex"",
                );
        }
    }

    /**
     * Format value
     * @param val
     */
    fmtV(val) {
        if (this.flags.sharp) {
            return this.pad(JSON.stringify(val));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }

    /**
     * Format JSON
     * @param val
     */
    fmtJ(val) {
        return JSON.stringify(val);
    }
}

/**
 * Converts and format a variable number of `args` as is specified by `format`.
 * `sprintf` returns the formatted string.
 *
 * @param format
 * @param args
 */
export function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}

/**
 * Converts and format a variable number of `args` as is specified by `format`.
 * `printf` writes the formatted string to standard output.
 * @param format
 * @param args
 */
export function printf(format, ...args) {
    const s = sprintf(format, ...args);
    print(s);
}
```"
"```javascript:modules\path.js
import process from 'process';
import { ERR_INVALID_ARG_TYPE } from './internal/errors';
import { getValidatedPath } from './internal/fs/utils';

var exports$1 = {},
    _dewExec = false;
function dew() {
  if (_dewExec) { return exports$1; }
  _dewExec = true;
  var process$1 = process;

  function assertPath(path) {
    if (typeof path !== ""string"") {
      throw new ERR_INVALID_ARG_TYPE(""path"", ""string"", path);
    }
  } // Resolves . and .. elements in a path with directory names


  function normalizeStringPosix(path, allowAboveRoot) {
    var res = """";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;

    for (var i = 0; i <= path.length; ++i) {
      if (i < path.length) { code = path.charCodeAt(i); }else if (code === 47
      /*/*/
      ) { break; }else { code = 47
      /*/*/
      ; }

      if (code === 47
      /*/*/
      ) {
        if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46
          /*.*/
          || res.charCodeAt(res.length - 2) !== 46
          /*.*/
          ) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf(""/"");

              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = """";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf(""/"");
                }

                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = """";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }

          if (allowAboveRoot) {
            if (res.length > 0) { res += ""/..""; }else { res = ""..""; }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) { res += ""/"" + path.slice(lastSlash + 1, i); }else { res = path.slice(lastSlash + 1, i); }
          lastSegmentLength = i - lastSlash - 1;
        }

        lastSlash = i;
        dots = 0;
      } else if (code === 46
      /*.*/
      && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }

    return res;
  }

  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || """") + (pathObject.ext || """");

    if (!dir) {
      return base;
    }

    if (dir === pathObject.root) {
      return dir + base;
    }

    return dir + sep + base;
  }

  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
      var arguments$1 = arguments;

      var resolvedPath = """";
      var resolvedAbsolute = false;
      var cwd;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path;
        if (i >= 0) { path = arguments$1[i]; }else {
          if (cwd === undefined) { cwd = process$1.cwd(); }
          path = cwd;
        }
        assertPath(path); // Skip empty entries

        if (path.length === 0) {
          continue;
        }

        resolvedPath = path + ""/"" + resolvedPath;
        resolvedAbsolute = path.charCodeAt(0) === 47
        /*/*/
        ;
      } // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path


      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) { return ""/"" + resolvedPath; }else { return ""/""; }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ""."";
      }
    },
    normalize: function normalize(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var isAbsolute = path.charCodeAt(0) === 47
      /*/*/
      ;
      var trailingSeparator = path.charCodeAt(path.length - 1) === 47
      /*/*/
      ; // Normalize the path

      path = normalizeStringPosix(path, !isAbsolute);
      if (path.length === 0 && !isAbsolute) { path = "".""; }
      if (path.length > 0 && trailingSeparator) { path += ""/""; }
      if (isAbsolute) { return ""/"" + path; }
      return path;
    },
    isAbsolute: function isAbsolute(path) {
      assertPath(path);
      return path.length > 0 && path.charCodeAt(0) === 47
      /*/*/
      ;
    },
    join: function join() {
      var arguments$1 = arguments;

      if (arguments.length === 0) { return "".""; }
      var joined;

      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments$1[i];
        assertPath(arg);

        if (arg.length > 0) {
          if (joined === undefined) { joined = arg; }else { joined += ""/"" + arg; }
        }
      }

      if (joined === undefined) { return "".""; }
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) { return """"; }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) { return """"; } // Trim any leading backslashes

      var fromStart = 1;

      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47
        /*/*/
        ) { break; }
      }

      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart; // Trim any leading backslashes

      var toStart = 1;

      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47
        /*/*/
        ) { break; }
      }

      var toEnd = to.length;
      var toLen = toEnd - toStart; // Compare paths to find the longest common path from root

      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;

      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47
            /*/*/
            ) {
              // We get here if `from` is the exact base path for `to`.
              // For example: from='/foo/bar'; to='/foo/bar/baz'
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              // We get here if `from` is the root
              // For example: from='/'; to='/foo'
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47
            /*/*/
            ) {
              // We get here if `to` is the exact base path for `from`.
              // For example: from='/foo/bar/baz'; to='/foo/bar'
              lastCommonSep = i;
            } else if (i === 0) {
              // We get here if `to` is the root.
              // For example: from='/foo'; to='/'
              lastCommonSep = 0;
            }
          }

          break;
        }

        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) { break; }else if (fromCode === 47
        /*/*/
        ) { lastCommonSep = i; }
      }

      var out = """"; // Generate the relative path based on the path difference between `to`
      // and `from`

      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47
        /*/*/
        ) {
          if (out.length === 0) { out += ""..""; }else { out += ""/..""; }
        }
      } // Lastly, append the rest of the destination (`to`) path that comes after
      // the common path parts


      if (out.length > 0) { return out + to.slice(toStart + lastCommonSep); }else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47
        /*/*/
        ) { ++toStart; }
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path) {
      return path;
    },
    dirname: function dirname(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var code = path.charCodeAt(0);
      var hasRoot = code === 47
      /*/*/
      ;
      var end = -1;
      var matchedSlash = true;

      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }

      if (end === -1) { return hasRoot ? ""/"" : "".""; }
      if (hasRoot && end === 1) { return ""//""; }
      return path.slice(0, end);
    },
    basename: function basename(path, ext) {
      if (ext !== undefined && typeof ext !== ""string"") { throw new ERR_INVALID_ARG_TYPE(""ext"", ""string"", ext); }
      assertPath(path);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;

      if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) { return """"; }
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;

        for (i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);

          if (code === 47
          /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              // We saw the first non-path separator, remember this index in case
              // we need it if the extension ends up not matching
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }

            if (extIdx >= 0) {
              // Try to match the explicit extension
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  // We matched the extension, so mark this as the end of our path
                  // component
                  end = i;
                }
              } else {
                // Extension does not match, so our result is the entire path
                // component
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }

        if (start === end) { end = firstNonSlashEnd; }else if (end === -1) { end = path.length; }
        return path.slice(start, end);
      } else {
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === 47
          /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // path component
            matchedSlash = false;
            end = i + 1;
          }
        }

        if (end === -1) { return """"; }
        return path.slice(start, end);
      }
    },
    extname: function extname(path) {
      assertPath(path);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0;

      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
        /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; }else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return """";
      }

      return path.slice(startDot, end);
    },
    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== ""object"") {
        throw new ERR_INVALID_ARG_TYPE(""pathObject"", ""object"", pathObject);
      }

      return _format(""/"", pathObject);
    },
    parse: function parse(path) {
      assertPath(path);
      var ret = {
        root: """",
        dir: """",
        base: """",
        ext: """",
        name: """"
      };
      if (path.length === 0) { return ret; }
      var code = path.charCodeAt(0);
      var isAbsolute = code === 47
      /*/*/
      ;
      var start;

      if (isAbsolute) {
        ret.root = ""/"";
        start = 1;
      } else {
        start = 0;
      }

      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0; // Get non-dir info

      for (; i >= start; --i) {
        code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
        /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; }else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute) { ret.base = ret.name = path.slice(1, end); }else { ret.base = ret.name = path.slice(startPart, end); }
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
        }

        ret.ext = path.slice(startDot, end);
      }

      if (startPart > 0) { ret.dir = path.slice(0, startPart - 1); }else if (isAbsolute) { ret.dir = ""/""; }
      return ret;
    },
    toNamespacedPath: (val) => val,
    sep: ""/"",
    delimiter: "":"",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports$1 = posix;
  return exports$1;
}

var exports = dew();

var _makeLong = exports._makeLong;
var basename = exports.basename;
var delimiter = exports.delimiter;
var dirname = exports.dirname;
var extname = exports.extname;
var format = exports.format;
var isAbsolute = exports.isAbsolute;
var join = exports.join;
var normalize = exports.normalize;
var parse = exports.parse;
var posix = exports.posix;
var relative = exports.relative;
var resolve = exports.resolve;
var sep = exports.sep;
var win32 = exports.win32;
var toNamespacedPath = exports.toNamespacedPath;

export { _makeLong, basename, exports as default, delimiter, dirname, extname, format, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32, toNamespacedPath };

```"
"```javascript:test\crypto\test-crypto-sign-verify.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const fs = require('fs');
const path = require('path');
const exec = require('child_process').exec;
const crypto = require('crypto');
const fixtures = require('../common/fixtures');

// Test certificates
const certPem = fixtures.readKey('rsa_cert.crt');
const keyPem = fixtures.readKey('rsa_private.pem');
const keySize = 2048;

{
  const Sign = crypto.Sign;
  const instance = Sign('SHA256');
  assert(instance instanceof Sign, 'Sign is expected to return a new ' +
                                   'instance when called without `new`');
}

{
  const Verify = crypto.Verify;
  const instance = Verify('SHA256');
  assert(instance instanceof Verify, 'Verify is expected to return a new ' +
                                     'instance when called without `new`');
}

// Test handling of exceptional conditions
{
  const library = {
    configurable: true,
    set() {
      throw new Error('bye, bye, library');
    }
  };
  Object.defineProperty(Object.prototype, 'library', library);

  assert.throws(() => {
    crypto.createSign('sha1').sign(
      `-----BEGIN RSA PRIVATE KEY-----
      AAAAAAAAAAAA
      -----END RSA PRIVATE KEY-----`);
  }, { message: 'bye, bye, library' });

  delete Object.prototype.library;

  const errorStack = {
    configurable: true,
    set() {
      throw new Error('bye, bye, error stack');
    }
  };
  Object.defineProperty(Object.prototype, 'opensslErrorStack', errorStack);

  assert.throws(() => {
    crypto.createSign('SHA1')
      .update('Test123')
      .sign({
        key: keyPem,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
      });
  }, { message: common.hasOpenSSL3 ?
    'error:1C8000A5:Provider routines::illegal or unsupported padding mode' :
    'bye, bye, error stack' });

  delete Object.prototype.opensslErrorStack;
}

assert.throws(
  () => crypto.createVerify('SHA256').verify({
    key: certPem,
    padding: null,
  }, ''),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    name: 'TypeError',
    message: ""The property 'options.padding' is invalid. Received null"",
  });

assert.throws(
  () => crypto.createVerify('SHA256').verify({
    key: certPem,
    saltLength: null,
  }, ''),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    name: 'TypeError',
    message: ""The property 'options.saltLength' is invalid. Received null"",
  });

// Test signing and verifying
{
  const s1 = crypto.createSign('SHA1')
                   .update('Test123')
                   .sign(keyPem, 'base64');
  let s1stream = crypto.createSign('SHA1');
  s1stream.end('Test123');
  s1stream = s1stream.sign(keyPem, 'base64');
  assert.strictEqual(s1, s1stream, `${s1} should equal ${s1stream}`);

  const verified = crypto.createVerify('SHA1')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s1, 'base64');
  assert.strictEqual(verified, true);
}

{
  const s2 = crypto.createSign('SHA256')
                   .update('Test123')
                   .sign(keyPem, 'latin1');
  let s2stream = crypto.createSign('SHA256');
  s2stream.end('Test123');
  s2stream = s2stream.sign(keyPem, 'latin1');
  assert.strictEqual(s2, s2stream, `${s2} should equal ${s2stream}`);

  let verified = crypto.createVerify('SHA256')
                       .update('Test')
                       .update('123')
                       .verify(certPem, s2, 'latin1');
  assert.strictEqual(verified, true);

  const verStream = crypto.createVerify('SHA256');
  verStream.write('Tes');
  verStream.write('t12');
  verStream.end('3');
  verified = verStream.verify(certPem, s2, 'latin1');
  assert.strictEqual(verified, true);
}

{
  const s3 = crypto.createSign('SHA1')
                   .update('Test123')
                   .sign(keyPem, 'buffer');
  let verified = crypto.createVerify('SHA1')
                       .update('Test')
                       .update('123')
                       .verify(certPem, s3);
  assert.strictEqual(verified, true);

  const verStream = crypto.createVerify('SHA1');
  verStream.write('Tes');
  verStream.write('t12');
  verStream.end('3');
  verified = verStream.verify(certPem, s3);
  assert.strictEqual(verified, true);
}

// Special tests for RSA_PKCS1_PSS_PADDING
{
  function testPSS(algo, hLen) {
    // Maximum permissible salt length
    const max = keySize / 8 - hLen - 2;

    function getEffectiveSaltLength(saltLength) {
      switch (saltLength) {
        case crypto.constants.RSA_PSS_SALTLEN_DIGEST:
          return hLen;
        case crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN:
          return max;
        default:
          return saltLength;
      }
    }

    const signSaltLengths = [
      crypto.constants.RSA_PSS_SALTLEN_DIGEST,
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_DIGEST),
      crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN,
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN),
      0, 16, 32, 64, 128,
    ];

    const verifySaltLengths = [
      crypto.constants.RSA_PSS_SALTLEN_DIGEST,
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_DIGEST),
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN),
      0, 16, 32, 64, 128,
    ];
    const errMessage = /^Error:.*data too large for key size$/;

    const data = Buffer.from('Test123');

    signSaltLengths.forEach((signSaltLength) => {
      if (signSaltLength > max) {
        // If the salt length is too big, an Error should be thrown
        assert.throws(() => {
          crypto.createSign(algo)
            .update(data)
            .sign({
              key: keyPem,
              padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
              saltLength: signSaltLength
            });
        }, errMessage);
        assert.throws(() => {
          crypto.sign(algo, data, {
            key: keyPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: signSaltLength
          });
        }, errMessage);
      } else {
        // Otherwise, a valid signature should be generated
        const s4 = crypto.createSign(algo)
                         .update(data)
                         .sign({
                           key: keyPem,
                           padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                           saltLength: signSaltLength
                         });
        const s4_2 = crypto.sign(algo, data, {
          key: keyPem,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: signSaltLength
        });

        [s4, s4_2].forEach((sig) => {
          let verified;
          verifySaltLengths.forEach((verifySaltLength) => {
            // Verification should succeed if and only if the salt length is
            // correct
            verified = crypto.createVerify(algo)
                             .update(data)
                             .verify({
                               key: certPem,
                               padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                               saltLength: verifySaltLength
                             }, sig);
            assert.strictEqual(verified, crypto.verify(algo, data, {
              key: certPem,
              padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
              saltLength: verifySaltLength
            }, sig));
            const saltLengthCorrect = getEffectiveSaltLength(signSaltLength) ===
                                      getEffectiveSaltLength(verifySaltLength);
            assert.strictEqual(verified, saltLengthCorrect);
          });

          // Verification using RSA_PSS_SALTLEN_AUTO should always work
          verified = crypto.createVerify(algo)
                           .update(data)
                           .verify({
                             key: certPem,
                             padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                             saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
                           }, sig);
          assert.strictEqual(verified, true);
          assert.strictEqual(verified, crypto.verify(algo, data, {
            key: certPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
          }, sig));

          // Verifying an incorrect message should never work
          const wrongData = Buffer.from('Test1234');
          verified = crypto.createVerify(algo)
                           .update(wrongData)
                           .verify({
                             key: certPem,
                             padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                             saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
                           }, sig);
          assert.strictEqual(verified, false);
          assert.strictEqual(verified, crypto.verify(algo, wrongData, {
            key: certPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
          }, sig));
        });
      }
    });
  }

  testPSS('SHA1', 20);
  testPSS('SHA256', 32);
}

// Test vectors for RSA_PKCS1_PSS_PADDING provided by the RSA Laboratories:
// https://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm
{
  // We only test verification as we cannot specify explicit salts when signing
  function testVerify(cert, vector) {
    const verified = crypto.createVerify('SHA1')
                          .update(Buffer.from(vector.message, 'hex'))
                          .verify({
                            key: cert,
                            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                            saltLength: vector.salt.length / 2
                          }, vector.signature, 'hex');
    assert.strictEqual(verified, true);
  }

  const examples = JSON.parse(fixtures.readSync('pss-vectors.json', 'utf8'));

  for (const key in examples) {
    const example = examples[key];
    const publicKey = example.publicKey.join('\n');
    example.tests.forEach((test) => testVerify(publicKey, test));
  }
}

// Test exceptions for invalid `padding` and `saltLength` values
{
  [null, NaN, 'boom', {}, [], true, false]
    .forEach((invalidValue) => {
      assert.throws(() => {
        crypto.createSign('SHA256')
          .update('Test123')
          .sign({
            key: keyPem,
            padding: invalidValue
          });
      }, {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError'
      });

      assert.throws(() => {
        crypto.createSign('SHA256')
          .update('Test123')
          .sign({
            key: keyPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: invalidValue
          });
      }, {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError'
      });
    });

  assert.throws(() => {
    crypto.createSign('SHA1')
      .update('Test123')
      .sign({
        key: keyPem,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
      });
  }, common.hasOpenSSL3 ? {
    code: 'ERR_OSSL_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE',
    message: /illegal or unsupported padding mode/,
  } : {
    code: 'ERR_OSSL_RSA_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE',
    message: /illegal or unsupported padding mode/,
    opensslErrorStack: [
      'error:06089093:digital envelope routines:EVP_PKEY_CTX_ctrl:' +
      'command not supported',
    ],
  });
}

// Test throws exception when key options is null
{
  assert.throws(() => {
    crypto.createSign('SHA1').update('Test123').sign(null, 'base64');
  }, {
    code: 'ERR_CRYPTO_SIGN_KEY_REQUIRED',
    name: 'Error'
  });
}

{
  const sign = crypto.createSign('SHA1');
  const verify = crypto.createVerify('SHA1');

  [1, [], {}, undefined, null, true, Infinity].forEach((input) => {
    const errObj = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""algorithm"" argument must be of type string.' +
               `${common.invalidArgTypeHelper(input)}`
    };
    assert.throws(() => crypto.createSign(input), errObj);
    assert.throws(() => crypto.createVerify(input), errObj);

    errObj.message = 'The ""data"" argument must be of type string or an ' +
                     'instance of Buffer, TypedArray, or DataView.' +
                     common.invalidArgTypeHelper(input);
    assert.throws(() => sign.update(input), errObj);
    assert.throws(() => verify.update(input), errObj);
    assert.throws(() => sign._write(input, 'utf8', () => {}), errObj);
    assert.throws(() => verify._write(input, 'utf8', () => {}), errObj);
  });

  [
    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,
  ].forEach((clazz) => {
    // These should all just work
    sign.update(new clazz());
    verify.update(new clazz());
  });

  [1, {}, [], Infinity].forEach((input) => {
    const errObj = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    };
    assert.throws(() => sign.sign(input), errObj);
    assert.throws(() => verify.verify(input), errObj);
    assert.throws(() => verify.verify('test', input), errObj);
  });
}

{
  assert.throws(
    () => crypto.createSign('sha8'),
    /Invalid digest/);
  assert.throws(
    () => crypto.sign('sha8', Buffer.alloc(1), keyPem),
    /Invalid digest/);
}

[
  { private: fixtures.readKey('ed25519_private.pem', 'ascii'),
    public: fixtures.readKey('ed25519_public.pem', 'ascii'),
    algo: null,
    sigLen: 64 },
  { private: fixtures.readKey('ed448_private.pem', 'ascii'),
    public: fixtures.readKey('ed448_public.pem', 'ascii'),
    algo: null,
    sigLen: 114 },
  { private: fixtures.readKey('rsa_private_2048.pem', 'ascii'),
    public: fixtures.readKey('rsa_public_2048.pem', 'ascii'),
    algo: 'sha1',
    sigLen: 256 },
].forEach((pair) => {
  const algo = pair.algo;

  {
    const data = Buffer.from('Hello world');
    const sig = crypto.sign(algo, data, pair.private);
    assert.strictEqual(sig.length, pair.sigLen);

    assert.strictEqual(crypto.verify(algo, data, pair.private, sig),
                       true);
    assert.strictEqual(crypto.verify(algo, data, pair.public, sig),
                       true);
  }

  {
    const data = Buffer.from('Hello world');
    const privKeyObj = crypto.createPrivateKey(pair.private);
    const pubKeyObj = crypto.createPublicKey(pair.public);

    const sig = crypto.sign(algo, data, privKeyObj);
    assert.strictEqual(sig.length, pair.sigLen);

    assert.strictEqual(crypto.verify(algo, data, privKeyObj, sig), true);
    assert.strictEqual(crypto.verify(algo, data, pubKeyObj, sig), true);
  }

  {
    const data = Buffer.from('Hello world');
    const otherData = Buffer.from('Goodbye world');
    const otherSig = crypto.sign(algo, otherData, pair.private);
    assert.strictEqual(crypto.verify(algo, data, pair.private, otherSig),
                       false);
  }

  [
    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,
  ].forEach((clazz) => {
    const data = new clazz();
    const sig = crypto.sign(algo, data, pair.private);
    assert.strictEqual(crypto.verify(algo, data, pair.private, sig),
                       true);
  });
});

[1, {}, [], true, Infinity].forEach((input) => {
  const data = Buffer.alloc(1);
  const sig = Buffer.alloc(1);
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  };

  assert.throws(() => crypto.sign(null, input, 'asdf'), errObj);
  assert.throws(() => crypto.verify(null, input, 'asdf', sig), errObj);

  assert.throws(() => crypto.sign(null, data, input), errObj);
  assert.throws(() => crypto.verify(null, data, input, sig), errObj);

  errObj.message = 'The ""signature"" argument must be an instance of ' +
                   'Buffer, TypedArray, or DataView.' +
                   common.invalidArgTypeHelper(input);
  assert.throws(() => crypto.verify(null, data, 'test', input), errObj);
});

{
  const data = Buffer.from('Hello world');
  const keys = [['ec-key.pem', 64], ['dsa_private_1025.pem', 40]];

  for (const [file, length] of keys) {
    const privKey = fixtures.readKey(file);
    [
      crypto.createSign('sha1').update(data).sign(privKey),
      crypto.sign('sha1', data, privKey),
      crypto.sign('sha1', data, { key: privKey, dsaEncoding: 'der' }),
    ].forEach((sig) => {
      // Signature length variability due to DER encoding
      assert(sig.length >= length + 4 && sig.length <= length + 8);

      assert.strictEqual(
        crypto.createVerify('sha1').update(data).verify(privKey, sig),
        true
      );
      assert.strictEqual(crypto.verify('sha1', data, privKey, sig), true);
    });

    // Test (EC)DSA signature conversion.
    const opts = { key: privKey, dsaEncoding: 'ieee-p1363' };
    let sig = crypto.sign('sha1', data, opts);
    // Unlike DER signatures, IEEE P1363 signatures have a predictable length.
    assert.strictEqual(sig.length, length);
    assert.strictEqual(crypto.verify('sha1', data, opts, sig), true);
    assert.strictEqual(crypto.createVerify('sha1')
                             .update(data)
                             .verify(opts, sig), true);

    // Test invalid signature lengths.
    for (const i of [-2, -1, 1, 2, 4, 8]) {
      sig = crypto.randomBytes(length + i);
      let result;
      try {
        result = crypto.verify('sha1', data, opts, sig);
      } catch (err) {
        assert.match(err.message, /asn1 encoding/);
        assert.strictEqual(err.library, 'asn1 encoding routines');
        continue;
      }
      assert.strictEqual(result, false);
    }
  }

  // Test verifying externally signed messages.
  const extSig = Buffer.from('494c18ab5c8a62a72aea5041966902bcfa229821af2bf65' +
                             '0b5b4870d1fe6aebeaed9460c62210693b5b0a300033823' +
                             '33d9529c8abd8c5948940af944828be16c', 'hex');
  for (const ok of [true, false]) {
    assert.strictEqual(
      crypto.verify('sha256', data, {
        key: fixtures.readKey('ec-key.pem'),
        dsaEncoding: 'ieee-p1363'
      }, extSig),
      ok
    );

    assert.strictEqual(
      crypto.createVerify('sha256').update(data).verify({
        key: fixtures.readKey('ec-key.pem'),
        dsaEncoding: 'ieee-p1363'
      }, extSig),
      ok
    );

    extSig[Math.floor(Math.random() * extSig.length)] ^= 1;
  }

  // Non-(EC)DSA keys should ignore the option.
  const sig = crypto.sign('sha1', data, {
    key: keyPem,
    dsaEncoding: 'ieee-p1363'
  });
  assert.strictEqual(crypto.verify('sha1', data, certPem, sig), true);
  assert.strictEqual(
    crypto.verify('sha1', data, {
      key: certPem,
      dsaEncoding: 'ieee-p1363'
    }, sig),
    true
  );
  assert.strictEqual(
    crypto.verify('sha1', data, {
      key: certPem,
      dsaEncoding: 'der'
    }, sig),
    true
  );

  for (const dsaEncoding of ['foo', null, {}, 5, true, NaN]) {
    assert.throws(() => {
      crypto.sign('sha1', data, {
        key: certPem,
        dsaEncoding
      });
    }, {
      code: 'ERR_INVALID_ARG_VALUE'
    });
  }
}


// RSA-PSS Sign test by verifying with 'openssl dgst -verify'
// Note: this particular test *must* be the last in this file as it will exit
// early if no openssl binary is found
{
  if (!common.opensslCli)
    common.skip('node compiled without OpenSSL CLI.');

  const pubfile = fixtures.path('keys', 'rsa_public_2048.pem');
  const privkey = fixtures.readKey('rsa_private_2048.pem');

  const msg = 'Test123';
  const s5 = crypto.createSign('SHA256')
    .update(msg)
    .sign({
      key: privkey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING
    });

  const tmpdir = require('../common/tmpdir');
  tmpdir.refresh();

  const sigfile = path.join(tmpdir.path, 's5.sig');
  fs.writeFileSync(sigfile, s5);
  const msgfile = path.join(tmpdir.path, 's5.msg');
  fs.writeFileSync(msgfile, msg);

  const cmd =
    `""${common.opensslCli}"" dgst -sha256 -verify ""${pubfile}"" -signature ""${
      sigfile}"" -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-2 ""${
      msgfile}""`;

  exec(cmd, common.mustCall((err, stdout, stderr) => {
    assert(stdout.includes('Verified OK'));
  }));
}

{
  // Test RSA-PSS.
  {
    // This key pair does not restrict the message digest algorithm or salt
    // length.
    const publicPem = fixtures.readKey('rsa_pss_public_2048.pem');
    const privatePem = fixtures.readKey('rsa_pss_private_2048.pem');

    const publicKey = crypto.createPublicKey(publicPem);
    const privateKey = crypto.createPrivateKey(privatePem);

    for (const key of [privatePem, privateKey]) {
      // Any algorithm should work.
      for (const algo of ['sha1', 'sha256']) {
        // Any salt length should work.
        for (const saltLength of [undefined, 8, 10, 12, 16, 18, 20]) {
          const signature = crypto.sign(algo, 'foo', { key, saltLength });

          for (const pkey of [key, publicKey, publicPem]) {
            const okay = crypto.verify(
              algo,
              'foo',
              { key: pkey, saltLength },
              signature
            );

            assert.ok(okay);
          }
        }
      }
    }
  }

  {
    // This key pair enforces sha256 as the message digest and the MGF1
    // message digest and a salt length of at least 16 bytes.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha256_sha256_16.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha256_sha256_16.pem');

    const publicKey = crypto.createPublicKey(publicPem);
    const privateKey = crypto.createPrivateKey(privatePem);

    for (const key of [privatePem, privateKey]) {
      // Signing with anything other than sha256 should fail.
      assert.throws(() => {
        crypto.sign('sha1', 'foo', key);
      }, /digest not allowed/);

      // Signing with salt lengths less than 16 bytes should fail.
      for (const saltLength of [8, 10, 12]) {
        assert.throws(() => {
          crypto.sign('sha256', 'foo', { key, saltLength });
        }, /pss saltlen too small/);
      }

      // Signing with sha256 and appropriate salt lengths should work.
      for (const saltLength of [undefined, 16, 18, 20]) {
        const signature = crypto.sign('sha256', 'foo', { key, saltLength });

        for (const pkey of [key, publicKey, publicPem]) {
          const okay = crypto.verify(
            'sha256',
            'foo',
            { key: pkey, saltLength },
            signature
          );

          assert.ok(okay);
        }
      }
    }
  }

  {
    // This key enforces sha512 as the message digest and sha256 as the MGF1
    // message digest.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha512_sha256_20.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha512_sha256_20.pem');

    const publicKey = crypto.createPublicKey(publicPem);
    const privateKey = crypto.createPrivateKey(privatePem);

    // Node.js usually uses the same hash function for the message and for MGF1.
    // However, when a different MGF1 message digest algorithm has been
    // specified as part of the key, it should automatically switch to that.
    // This behavior is required by sections 3.1 and 3.3 of RFC4055.
    for (const key of [privatePem, privateKey]) {
      // sha256 matches the MGF1 hash function and should be used internally,
      // but it should not be permitted as the main message digest algorithm.
      for (const algo of ['sha1', 'sha256']) {
        assert.throws(() => {
          crypto.sign(algo, 'foo', key);
        }, /digest not allowed/);
      }

      // sha512 should produce a valid signature.
      const signature = crypto.sign('sha512', 'foo', key);

      for (const pkey of [key, publicKey, publicPem]) {
        const okay = crypto.verify('sha512', 'foo', pkey, signature);

        assert.ok(okay);
      }
    }
  }
}

// The sign function should not swallow OpenSSL errors.
// Regression test for https://github.com/nodejs/node/issues/40794.
{
  assert.throws(() => {
    const { privateKey } = crypto.generateKeyPairSync('rsa', {
      modulusLength: 512
    });
    crypto.sign('sha512', 'message', privateKey);
  }, {
    code: 'ERR_OSSL_RSA_DIGEST_TOO_BIG_FOR_RSA_KEY',
    message: /digest too big for rsa key/
  });
}

{
  // This should not cause a crash: https://github.com/nodejs/node/issues/44471
  for (const key of ['', 'foo', null, undefined, true, Boolean]) {
    assert.throws(() => {
      crypto.verify('sha256', 'foo', { key, format: 'jwk' }, Buffer.alloc(0));
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      crypto.createVerify('sha256').verify({ key, format: 'jwk' }, Buffer.alloc(0));
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      crypto.sign('sha256', 'foo', { key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      crypto.createSign('sha256').sign({ key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
  }
}

```"
"```javascript:modules\internal\crypto\keys.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

class SecretKeyHandle {
  #keyBuffer

  constructor(key) {
    this.#keyBuffer = Buffer.from(key);
  }

  // base
  equals(key) {
    return this.export().equals(key.export());
  }

  // secretKey
  getSymmetricKeySize() {
    return this.#keyBuffer.byteLength;
  }

  export() {
    return Buffer.from(this.#keyBuffer)
  }

  exportJwk(_obj, _bool) {
    return {
      kty: 'oct',
      k: this.#keyBuffer.toString(""base64"").replace(/=+$/, '')
    };
  }
}

const kKeyTypeSecret = Symbol(""kKeyTypeSecret"");
const kKeyTypePublic = Symbol(""kKeyTypePublic"");
const kKeyTypePrivate = Symbol(""kKeyTypePrivate"");
const kKeyFormatPEM = Symbol(""kKeyFormatPEM"");
const kKeyFormatDER = Symbol(""kKeyFormatDER"");
const kKeyFormatJWK = Symbol(""kKeyFormatJWK"");
const kKeyEncodingPKCS1 = Symbol(""kKeyEncodingPKCS1"");
const kKeyEncodingPKCS8 = Symbol(""kKeyEncodingPKCS8"");
const kKeyEncodingSPKI = Symbol(""kKeyEncodingSPKI"");
const kKeyEncodingSEC1 = Symbol(""kKeyEncodingSEC1"");

import {
  validateObject,
  validateOneOf,
  validateString,
} from '../validators';

import {
  ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,
  ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,
  ERR_CRYPTO_INVALID_JWK,
  ERR_ILLEGAL_CONSTRUCTOR,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
} from '../errors';

import {
  kHandle,
  kKeyObject,
  getArrayBufferOrView,
  bigIntArrayToUnsignedBigInt,
} from '../crypto/util';

import {
  isAnyArrayBuffer,
  isArrayBufferView,
} from '../util/types';

/*const {
  JSTransferable,
  kClone,
  kDeserialize,
} = require('internal/worker/js_transferable');*/

const kClone = Symbol('kClone');
const kDeserialize = Symbol('kDeserialize');

import {
  customInspectSymbol as kInspect,
} from '../util';

import { inspect } from '../util/inspect';

import { Buffer } from '../../buffer';

const kAlgorithm = Symbol('kAlgorithm');
const kExtractable = Symbol('kExtractable');
const kKeyType = Symbol('kKeyType');
const kKeyUsages = Symbol('kKeyUsages');

// Key input contexts.
const kConsumePublic = 0;
const kConsumePrivate = 1;
const kCreatePublic = 2;
const kCreatePrivate = 3;

const encodingNames = [];
for (const m of [[kKeyEncodingPKCS1, 'pkcs1'], [kKeyEncodingPKCS8, 'pkcs8'],
[kKeyEncodingSPKI, 'spki'], [kKeyEncodingSEC1, 'sec1']])
  encodingNames[m[0]] = m[1];

// Creating the KeyObject class is a little complicated due to inheritance
// and the fact that KeyObjects should be transferrable between threads,
// which requires the KeyObject base class to be implemented in C++.
// The creation requires a callback to make sure that the NativeKeyObject
// base class cannot exist without the other KeyObject implementations.
/*const {
  0: KeyObject,
  1: SecretKeyObject,
  2: PublicKeyObject,
  3: PrivateKeyObject,
} = createNativeKeyObjectClass((NativeKeyObject) => {*/
// Publicly visible KeyObject class.
class KeyObject/* extends NativeKeyObject*/ {
  constructor(type, handle) {
    if (type !== 'secret' && type !== 'public' && type !== 'private')
      throw new ERR_INVALID_ARG_VALUE('type', type);
    if (typeof handle !== 'object'/* || !(handle instanceof KeyObjectHandle)*/)
      throw new ERR_INVALID_ARG_TYPE('handle', 'object', handle);

    // super(handle);

    this[kKeyType] = type;

    Object.defineProperty(this, kHandle, {
      __proto__: null,
      value: handle,
      enumerable: false,
      configurable: false,
      writable: false
    });
  }

  get type() {
    return this[kKeyType];
  }

  static from(key) {
    if (!isCryptoKey(key))
      throw new ERR_INVALID_ARG_TYPE('key', 'CryptoKey', key);
    return key[kKeyObject];
  }

  equals(otherKeyObject) {
    if (!isKeyObject(otherKeyObject)) {
      throw new ERR_INVALID_ARG_TYPE(
        'otherKeyObject', 'KeyObject', otherKeyObject);
    }

    return otherKeyObject.type === this.type &&
      this[kHandle].equals(otherKeyObject[kHandle]);
  }
}

class SecretKeyObject extends KeyObject {
  constructor(handle) {
    super('secret', handle);
  }

  get symmetricKeySize() {
    return this[kHandle].getSymmetricKeySize();
  }

  export(options) {
    if (options !== undefined) {
      validateObject(options, 'options');
      validateOneOf(
        options.format, 'options.format', [undefined, 'buffer', 'jwk']);
      if (options.format === 'jwk') {
        return this[kHandle].exportJwk({}, false);
      }
    }
    return this[kHandle].export();
  }
}

const kAsymmetricKeyType = Symbol('kAsymmetricKeyType');
const kAsymmetricKeyDetails = Symbol('kAsymmetricKeyDetails');

function normalizeKeyDetails(details = {}) {
  if (details.publicExponent !== undefined) {
    return {
      ...details,
      publicExponent:
        bigIntArrayToUnsignedBigInt(new Uint8Array(details.publicExponent))
    };
  }
  return details;
}

class AsymmetricKeyObject extends KeyObject {
  // eslint-disable-next-line no-useless-constructor
  constructor(type, handle) {
    super(type, handle);
  }

  get asymmetricKeyType() {
    return this[kAsymmetricKeyType] ||
      (this[kAsymmetricKeyType] = this[kHandle].getAsymmetricKeyType());
  }

  get asymmetricKeyDetails() {
    switch (this.asymmetricKeyType) {
      case 'rsa':
      case 'rsa-pss':
      case 'dsa':
      case 'ec':
        return this[kAsymmetricKeyDetails] ||
          (this[kAsymmetricKeyDetails] = normalizeKeyDetails(
            this[kHandle].keyDetail({})
          ));
      default:
        return {};
    }
  }
}

class PublicKeyObject extends AsymmetricKeyObject {
  constructor(handle) {
    super('public', handle);
  }

  export(options) {
    if (options && options.format === 'jwk') {
      return this[kHandle].exportJwk({}, false);
    }
    const {
      format,
      type
    } = parsePublicKeyEncoding(options, this.asymmetricKeyType);
    return this[kHandle].export(format, type);
  }
}

class PrivateKeyObject extends AsymmetricKeyObject {
  constructor(handle) {
    super('private', handle);
  }

  export(options) {
    if (options && options.format === 'jwk') {
      if (options.passphrase !== undefined) {
        throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
          'jwk', 'does not support encryption');
      }
      return this[kHandle].exportJwk({}, false);
    }
    const {
      format,
      type,
      cipher,
      passphrase
    } = parsePrivateKeyEncoding(options, this.asymmetricKeyType);
    return this[kHandle].export(format, type, cipher, passphrase);
  }
}
/*
  return [KeyObject, SecretKeyObject, PublicKeyObject, PrivateKeyObject];
});*/

function parseKeyFormat(formatStr, defaultFormat, optionName) {
  if (formatStr === undefined && defaultFormat !== undefined)
    return defaultFormat;
  else if (formatStr === 'pem')
    return kKeyFormatPEM;
  else if (formatStr === 'der')
    return kKeyFormatDER;
  else if (formatStr === 'jwk')
    return kKeyFormatJWK;
  throw new ERR_INVALID_ARG_VALUE(optionName, formatStr);
}

function parseKeyType(typeStr, required, keyType, isPublic, optionName) {
  if (typeStr === undefined && !required) {
    return undefined;
  } else if (typeStr === 'pkcs1') {
    if (keyType !== undefined && keyType !== 'rsa') {
      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
        typeStr, 'can only be used for RSA keys');
    }
    return kKeyEncodingPKCS1;
  } else if (typeStr === 'spki' && isPublic !== false) {
    return kKeyEncodingSPKI;
  } else if (typeStr === 'pkcs8' && isPublic !== true) {
    return kKeyEncodingPKCS8;
  } else if (typeStr === 'sec1' && isPublic !== true) {
    if (keyType !== undefined && keyType !== 'ec') {
      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
        typeStr, 'can only be used for EC keys');
    }
    return kKeyEncodingSEC1;
  }

  throw new ERR_INVALID_ARG_VALUE(optionName, typeStr);
}

function option(name, objName) {
  return objName === undefined ?
    `options.${name}` : `options.${objName}.${name}`;
}

function parseKeyFormatAndType(enc, keyType, isPublic, objName) {
  const { format: formatStr, type: typeStr } = enc;

  const isInput = keyType === undefined;
  const format = parseKeyFormat(formatStr,
    isInput ? kKeyFormatPEM : undefined,
    option('format', objName));

  const isRequired = (!isInput ||
    format === kKeyFormatDER) &&
    format !== kKeyFormatJWK;
  const type = parseKeyType(typeStr,
    isRequired,
    keyType,
    isPublic,
    option('type', objName));
  return { format, type };
}

function isStringOrBuffer(val) {
  return typeof val === 'string' ||
    isArrayBufferView(val) ||
    isAnyArrayBuffer(val);
}

function parseKeyEncoding(enc, keyType, isPublic, objName) {
  validateObject(enc, 'options');

  const isInput = keyType === undefined;

  const {
    format,
    type
  } = parseKeyFormatAndType(enc, keyType, isPublic, objName);

  let cipher, passphrase, encoding;
  if (isPublic !== true) {
    ({ cipher, passphrase, encoding } = enc);

    if (!isInput) {
      if (cipher != null) {
        if (typeof cipher !== 'string')
          throw new ERR_INVALID_ARG_VALUE(option('cipher', objName), cipher);
        if (format === kKeyFormatDER &&
          (type === kKeyEncodingPKCS1 ||
            type === kKeyEncodingSEC1)) {
          throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
            encodingNames[type], 'does not support encryption');
        }
      } else if (passphrase !== undefined) {
        throw new ERR_INVALID_ARG_VALUE(option('cipher', objName), cipher);
      }
    }

    if ((isInput && passphrase !== undefined &&
      !isStringOrBuffer(passphrase)) ||
      (!isInput && cipher != null && !isStringOrBuffer(passphrase))) {
      throw new ERR_INVALID_ARG_VALUE(option('passphrase', objName),
        passphrase);
    }
  }

  if (passphrase !== undefined)
    passphrase = getArrayBufferOrView(passphrase, 'key.passphrase', encoding);

  return { format, type, cipher, passphrase };
}

// Parses the public key encoding based on an object. keyType must be undefined
// when this is used to parse an input encoding and must be a valid key type if
// used to parse an output encoding.
function parsePublicKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, keyType ? true : undefined, objName);
}

// Parses the private key encoding based on an object. keyType must be undefined
// when this is used to parse an input encoding and must be a valid key type if
// used to parse an output encoding.
function parsePrivateKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, false, objName);
}

function getKeyObjectHandle(key, ctx) {
  if (ctx === kCreatePrivate) {
    throw new ERR_INVALID_ARG_TYPE(
      'key',
      ['string', 'ArrayBuffer', 'Buffer', 'TypedArray', 'DataView'],
      key
    );
  }

  if (key.type !== 'private') {
    if (ctx === kConsumePrivate || ctx === kCreatePublic)
      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, 'private');
    if (key.type !== 'public') {
      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type,
        'private or public');
    }
  }

  return key[kHandle];
}

function getKeyTypes(allowKeyObject, bufferOnly = false) {
  const types = [
    'ArrayBuffer',
    'Buffer',
    'TypedArray',
    'DataView',
    'string', // Only if bufferOnly == false
    'KeyObject', // Only if allowKeyObject == true && bufferOnly == false
    'CryptoKey', // Only if allowKeyObject == true && bufferOnly == false
  ];
  if (bufferOnly) {
    return Array.prototype.slice.call(types, 0, 4);
  } else if (!allowKeyObject) {
    return Array.prototype.slice.call(types, 0, 5);
  }
  return types;
}

function getKeyObjectHandleFromJwk(key, ctx) {
  validateObject(key, 'key');
  validateOneOf(
    key.kty, 'key.kty', ['RSA', 'EC', 'OKP']);
  const isPublic = ctx === kConsumePublic || ctx === kCreatePublic;

  if (key.kty === 'OKP') {
    validateString(key.crv, 'key.crv');
    validateOneOf(
      key.crv, 'key.crv', ['Ed25519', 'Ed448', 'X25519', 'X448']);
    validateString(key.x, 'key.x');

    if (!isPublic)
      validateString(key.d, 'key.d');

    let keyData;
    if (isPublic)
      keyData = Buffer.from(key.x, 'base64');
    else
      keyData = Buffer.from(key.d, 'base64');

    switch (key.crv) {
      case 'Ed25519':
      case 'X25519':
        if (keyData.byteLength !== 32) {
          throw new ERR_CRYPTO_INVALID_JWK();
        }
        break;
      case 'Ed448':
        if (keyData.byteLength !== 57) {
          throw new ERR_CRYPTO_INVALID_JWK();
        }
        break;
      case 'X448':
        if (keyData.byteLength !== 56) {
          throw new ERR_CRYPTO_INVALID_JWK();
        }
        break;
    }

    const handle = new KeyObjectHandle();

    const keyType = isPublic ? kKeyTypePublic : kKeyTypePrivate;
    if (!handle.initEDRaw(key.crv, keyData, keyType)) {
      throw new ERR_CRYPTO_INVALID_JWK();
    }

    return handle;
  }

  if (key.kty === 'EC') {
    validateString(key.crv, 'key.crv');
    validateOneOf(
      key.crv, 'key.crv', ['P-256', 'secp256k1', 'P-384', 'P-521']);
    validateString(key.x, 'key.x');
    validateString(key.y, 'key.y');

    const jwk = {
      kty: key.kty,
      crv: key.crv,
      x: key.x,
      y: key.y
    };

    if (!isPublic) {
      validateString(key.d, 'key.d');
      jwk.d = key.d;
    }

    const handle = new KeyObjectHandle();
    const type = handle.initJwk(jwk, jwk.crv);
    if (type === undefined)
      throw new ERR_CRYPTO_INVALID_JWK();

    return handle;
  }

  // RSA
  validateString(key.n, 'key.n');
  validateString(key.e, 'key.e');

  const jwk = {
    kty: key.kty,
    n: key.n,
    e: key.e
  };

  if (!isPublic) {
    validateString(key.d, 'key.d');
    validateString(key.p, 'key.p');
    validateString(key.q, 'key.q');
    validateString(key.dp, 'key.dp');
    validateString(key.dq, 'key.dq');
    validateString(key.qi, 'key.qi');
    jwk.d = key.d;
    jwk.p = key.p;
    jwk.q = key.q;
    jwk.dp = key.dp;
    jwk.dq = key.dq;
    jwk.qi = key.qi;
  }

  const handle = new KeyObjectHandle();
  const type = handle.initJwk(jwk);
  if (type === undefined)
    throw new ERR_CRYPTO_INVALID_JWK();

  return handle;
}

function prepareAsymmetricKey(key, ctx) {
  if (isKeyObject(key)) {
    // Best case: A key object, as simple as that.
    return { data: getKeyObjectHandle(key, ctx) };
  } else if (isCryptoKey(key)) {
    return { data: getKeyObjectHandle(key[kKeyObject], ctx) };
  } else if (isStringOrBuffer(key)) {
    // Expect PEM by default, mostly for backward compatibility.
    return { format: kKeyFormatPEM, data: getArrayBufferOrView(key, 'key') };
  } else if (typeof key === 'object') {
    const { key: data, encoding, format } = key;

    // The 'key' property can be a KeyObject as well to allow specifying
    // additional options such as padding along with the key.
    if (isKeyObject(data))
      return { data: getKeyObjectHandle(data, ctx) };
    else if (isCryptoKey(data))
      return { data: getKeyObjectHandle(data[kKeyObject], ctx) };
    else if (format === 'jwk') {
      validateObject(data, 'key.key');
      return { data: getKeyObjectHandleFromJwk(data, ctx), format: 'jwk' };
    }

    // Either PEM or DER using PKCS#1 or SPKI.
    if (!isStringOrBuffer(data)) {
      throw new ERR_INVALID_ARG_TYPE(
        'key.key',
        getKeyTypes(ctx !== kCreatePrivate),
        data);
    }

    const isPublic =
      (ctx === kConsumePrivate || ctx === kCreatePrivate) ? false : undefined;
    return {
      data: getArrayBufferOrView(data, 'key', encoding),
      ...parseKeyEncoding(key, undefined, isPublic)
    };
  }
  throw new ERR_INVALID_ARG_TYPE(
    'key',
    getKeyTypes(ctx !== kCreatePrivate),
    key);
}

function preparePrivateKey(key) {
  return prepareAsymmetricKey(key, kConsumePrivate);
}

function preparePublicOrPrivateKey(key) {
  return prepareAsymmetricKey(key, kConsumePublic);
}

function prepareSecretKey(key, encoding, bufferOnly = false) {
  if (!bufferOnly) {
    if (isKeyObject(key)) {
      if (key.type !== 'secret')
        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, 'secret');
      return key[kHandle];
    } else if (isCryptoKey(key)) {
      if (key.type !== 'secret')
        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, 'secret');
      return key[kKeyObject][kHandle];
    }
  }
  if (typeof key !== 'string' &&
    !isArrayBufferView(key) &&
    !isAnyArrayBuffer(key)) {
    throw new ERR_INVALID_ARG_TYPE(
      'key',
      getKeyTypes(!bufferOnly, bufferOnly),
      key);
  }
  return getArrayBufferOrView(key, 'key', encoding);
}

function createSecretKey(key, encoding) {
  key = prepareSecretKey(key, encoding, true);
  const handle = new SecretKeyHandle(key);
  // handle.init(kKeyTypeSecret, key);
  return new SecretKeyObject(handle);
}

function createPublicKey(key) {
  const { format, type, data, passphrase } =
    prepareAsymmetricKey(key, kCreatePublic);
  let handle;
  if (format === 'jwk') {
    handle = data;
  } else {
    handle = new KeyObjectHandle();
    handle.init(kKeyTypePublic, data, format, type, passphrase);
  }
  return new PublicKeyObject(handle);
}

function createPrivateKey(key) {
  const { format, type, data, passphrase } =
    prepareAsymmetricKey(key, kCreatePrivate);
  let handle;
  if (format === 'jwk') {
    handle = data;
  } else {
    handle = new KeyObjectHandle();
    handle.init(kKeyTypePrivate, data, format, type, passphrase);
  }
  return new PrivateKeyObject(handle);
}

function isKeyObject(obj) {
  return obj != null && obj[kKeyType] !== undefined;
}

// Our implementation of CryptoKey is a simple wrapper around a KeyObject
// that adapts it to the standard interface. This implementation also
// extends the JSTransferable class, allowing the CryptoKey to be cloned
// to Workers.
// TODO(@jasnell): Embedder environments like electron may have issues
// here similar to other things like URL. A chromium provided CryptoKey
// will not be recognized as a Node.js CryptoKey, and vice versa. It
// would be fantastic if we could find a way of making those interop.
class CryptoKey /*extends JSTransferable*/ {
  constructor() {
    throw new ERR_ILLEGAL_CONSTRUCTOR();
  }

  [kInspect](depth, options) {
    if (depth < 0)
      return this;

    const opts = {
      ...options,
      depth: options.depth == null ? null : options.depth - 1
    };

    return `CryptoKey ${inspect({
      type: this.type,
      extractable: this.extractable,
      algorithm: this.algorithm,
      usages: this.usages
    }, opts)}`;
  }

  get type() {
    return this[kKeyObject].type;
  }

  get extractable() {
    return this[kExtractable];
  }

  get algorithm() {
    return this[kAlgorithm];
  }

  get usages() {
    return Array.from(this[kKeyUsages]);
  }

  [kClone]() {
    const keyObject = this[kKeyObject];
    const algorithm = this.algorithm;
    const extractable = this.extractable;
    const usages = this.usages;

    return {
      data: {
        keyObject,
        algorithm,
        usages,
        extractable,
      },
      deserializeInfo: 'internal/crypto/keys:InternalCryptoKey'
    };
  }

  [kDeserialize]({ keyObject, algorithm, usages, extractable }) {
    this[kKeyObject] = keyObject;
    this[kAlgorithm] = algorithm;
    this[kKeyUsages] = usages;
    this[kExtractable] = extractable;
  }
}

// All internal code must use new InternalCryptoKey to create
// CryptoKey instances. The CryptoKey class is exposed to end
// user code but is not permitted to be constructed directly.
class InternalCryptoKey /*extends JSTransferable*/ {
  constructor(
    keyObject,
    algorithm,
    keyUsages,
    extractable) {
    // super();
    // Using symbol properties here currently instead of private
    // properties because (for now) the performance penalty of
    // private fields is still too high.
    this[kKeyObject] = keyObject;
    this[kAlgorithm] = algorithm;
    this[kExtractable] = extractable;
    this[kKeyUsages] = keyUsages;
  }
}

InternalCryptoKey.prototype.constructor = CryptoKey;
Object.setPrototypeOf(InternalCryptoKey.prototype, CryptoKey.prototype);

function isCryptoKey(obj) {
  return obj != null && obj[kKeyObject] !== undefined;
}

export {
  // Public API.
  createSecretKey,
  createPublicKey,
  createPrivateKey,
  KeyObject,
  CryptoKey,
  InternalCryptoKey,

  // These are designed for internal use only and should not be exposed.
  parsePublicKeyEncoding,
  parsePrivateKeyEncoding,
  parseKeyEncoding,
  preparePrivateKey,
  preparePublicOrPrivateKey,
  prepareSecretKey,
  SecretKeyObject,
  PublicKeyObject,
  PrivateKeyObject,
  isKeyObject,
  isCryptoKey,
};

```"
"```javascript:modules\internal\assert\assertion_error.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import { inspect } from 'internal/util/inspect';
import { removeColors } from 'internal/util';
import { blue, white, green, red, refresh } from 'internal/util/colors';
import { validateObject } from 'internal/validators';
import { isErrorStackTraceLimitWritable } from 'internal/errors';

const kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected ""actual"" to be reference-equal to ""expected"":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  notDeepStrictEqual: 'Expected ""actual"" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected ""actual"" to be strictly unequal to:',
  notStrictEqualObject:
    'Expected ""actual"" not to be reference-equal to ""expected"":',
  notDeepEqual: 'Expected ""actual"" not to be loosely deep-equal to:',
  notIdentical: 'Values have same structure but are not reference-equal:',
  notDeepEqualUnequal: 'Expected values not to be loosely deep-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
const kMaxShortLength = 12;

function copyError(source) {
  const keys = Object.keys(source);
  const target = Object.create(Object.getPrototypeOf(source));
  for (const key of keys) {
    target[key] = source[key];
  }
  Object.defineProperty(target, 'message', { __proto__: null, value: source.message });
  return target;
}

function inspectValue(val) {
  // return JSON.stringify(val) || ""undefined"";
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(
    val,
    {
      compact: false,
      customInspect: false,
      depth: 1000,
      maxArrayLength: Infinity,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: false,
      // Assert does not detect proxies currently.
      showProxy: false,
      sorted: true,
      // Inspect getters as we also check them when comparing entries.
      getters: true,
    }
  ) ?? JSON.stringify(val);
}

function createErrDiff(actual, expected, operator) {
  let other = '';
  let res = '';
  let end = '';
  let skipped = false;
  const actualInspected = inspectValue(actual);
  const actualLines = String.prototype.split.call(actualInspected, '\n');
  const expectedLines = String.prototype.split.call(inspectValue(expected), '\n');

  let i = 0;
  let indicator = '';

  // In case both values are objects or functions explicitly mark them as not
  // reference equal for the `strictEqual` operator.
  if (operator === 'strictEqual' &&
      ((typeof actual === 'object' && actual !== null &&
        typeof expected === 'object' && expected !== null) ||
       (typeof actual === 'function' && typeof expected === 'function'))) {
    operator = 'strictEqualObject';
  }

  // If ""actual"" and ""expected"" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 &&
    actualLines[0] !== expectedLines[0]) {
    // Check for the visible length using the `removeColors()` function, if
    // appropriate.
    const c = inspect.defaultOptions.colors;
    const actualRaw = c ? removeColors(actualLines[0]) : actualLines[0];
    const expectedRaw = c ? removeColors(expectedLines[0]) : expectedLines[0];
    const inputLength = actualRaw.length + expectedRaw.length;
    // If the character length of ""actual"" and ""expected"" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((typeof actual !== 'object' || actual === null) &&
          (typeof expected !== 'object' || expected === null) &&
          (actual !== 0 || expected !== 0)) { // -0 === +0
        return `${kReadableOperator[operator]}\n\n` +
            `${actualLines[0]} !== ${expectedLines[0]}\n`;
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      const maxLength = /*process.stderr.isTTY ? process.stderr.columns :*/ 80;
      if (inputLength < maxLength) {
        while (actualRaw[i] === expectedRaw[i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = `\n  ${String.prototype.repeat.call(' ', i)}^`;
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  let a = actualLines[actualLines.length - 1];
  let b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 3) {
      end = `\n  ${a}${end}`;
    } else {
      other = a;
    }
    Array.prototype.pop.call(actualLines);
    Array.prototype.pop.call(expectedLines);
    if (actualLines.length === 0 || expectedLines.length === 0)
      break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  const maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    const actualLines = String.prototype.split.call(actualInspected, '\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (actualLines.length > 50) {
      actualLines[46] = `${blue}...${white}`;
      while (actualLines.length > 47) {
        Array.prototype.pop.call(actualLines);
      }
    }

    return `${kReadableOperator.notIdentical}\n\n` +
           `${Array.prototype.join.call(actualLines, '\n')}\n`;
  }

  // There were at least five identical lines at the end. Mark a couple of
  // skipped.
  if (i >= 5) {
    end = `\n${blue}...${white}${end}`;
    skipped = true;
  }
  if (other !== '') {
    end = `\n  ${other}${end}`;
    other = '';
  }

  let printedLines = 0;
  let identical = 0;
  const msg = kReadableOperator[operator] +
        `\n${green}+ actual${white} ${red}- expected${white}`;
  const skippedMsg = ` ${blue}...${white} Lines skipped`;

  let lines = actualLines;
  let plusMinus = `${green}+${white}`;
  let maxLength = expectedLines.length;
  if (actualLines.length < maxLines) {
    lines = expectedLines;
    plusMinus = `${red}-${white}`;
    maxLength = actualLines.length;
  }

  for (i = 0; i < maxLines; i++) {
    if (maxLength < i + 1) {
      // If more than two former lines are identical, print them. Collapse them
      // in case more than five lines were identical.
      if (identical > 2) {
        if (identical > 3) {
          if (identical > 4) {
            if (identical === 5) {
              res += `\n  ${lines[i - 3]}`;
              printedLines++;
            } else {
              res += `\n${blue}...${white}`;
              skipped = true;
            }
          }
          res += `\n  ${lines[i - 2]}`;
          printedLines++;
        }
        res += `\n  ${lines[i - 1]}`;
        printedLines++;
      }
      // No identical lines before.
      identical = 0;
      // Add the expected line to the cache.
      if (lines === actualLines) {
        res += `\n${plusMinus} ${lines[i]}`;
      } else {
        other += `\n${plusMinus} ${lines[i]}`;
      }
      printedLines++;
    // Only extra actual lines exist
    // Lines diverge
    } else {
      const expectedLine = expectedLines[i];
      let actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      let divergingLines =
        actualLine !== expectedLine &&
        (!String.prototype.endsWith.call(actualLine, ',') ||
         String.prototype.slice.call(actualLine, 0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines &&
          String.prototype.endsWith.call(expectedLine, ',') &&
          String.prototype.slice.call(expectedLine, 0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If more than two former lines are identical, print them. Collapse
        // them in case more than five lines were identical.
        if (identical > 2) {
          if (identical > 3) {
            if (identical > 4) {
              if (identical === 5) {
                res += `\n  ${actualLines[i - 3]}`;
                printedLines++;
              } else {
                res += `\n${blue}...${white}`;
                skipped = true;
              }
            }
            res += `\n  ${actualLines[i - 2]}`;
            printedLines++;
          }
          res += `\n  ${actualLines[i - 1]}`;
          printedLines++;
        }
        // No identical lines before.
        identical = 0;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += `\n${green}+${white} ${actualLine}`;
        other += `\n${red}-${white} ${expectedLine}`;
        printedLines += 2;
      // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        identical++;
        // The very first identical line since the last diverging line is be
        // added to the result.
        if (identical <= 2) {
          res += `\n  ${actualLine}`;
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~50 rows max)
    if (printedLines > 50 && i < maxLines - 2) {
      return `${msg}${skippedMsg}\n${res}\n${blue}...${white}${other}\n` +
             `${blue}...${white}`;
    }
  }

  return `${msg}${skipped ? skippedMsg : ''}\n${res}${other}${end}${indicator}`;
}

function addEllipsis(string) {
  const lines = String.prototype.split.call(string, '\n', 11);
  if (lines.length > 10) {
    lines.length = 10;
    return `${Array.prototype.join.call(lines, '\n')}\n...`;
  } else if (string.length > 512) {
    return `${String.prototype.slice.call(string, 512)}...`;
  }
  return string;
}

class AssertionError extends Error {
  constructor(options) {

    // let quickjs context know assertion has failed
    globalThis.assertPass = false;
    print(""assert fail"");
    print(new Error().stack);

    validateObject(options, 'options');
    const {
      message,
      operator,
      stackStartFn,
      details,
      // Compatibility with older versions.
      stackStartFunction
    } = options;
    let {
      actual,
      expected
    } = options;

    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;

    if (message != null) {
      super(String(message));
    } else {
      // Reset colors on each call to make sure we handle dynamically set environment
      // variables correct.
      refresh();
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (typeof actual === 'object' && actual !== null &&
          typeof expected === 'object' && expected !== null &&
          'stack' in actual && actual instanceof Error &&
          'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        super(createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' ||
        operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        let base = kReadableOperator[operator];
        const res = String.prototype.split.call(inspectValue(actual), '\n');

        // In case ""actual"" is an object or a function, it should not be
        // reference equal.
        if (operator === 'notStrictEqual' &&
            ((typeof actual === 'object' && actual !== null) ||
             typeof actual === 'function')) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 50) {
          res[46] = `${blue}...${white}`;
          while (res.length > 47) {
            Array.prototype.pop.call(res);
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          super(`${base}${res[0].length > 5 ? '\n\n' : ' '}${res[0]}`);
        } else {
          super(`${base}\n\n${Array.prototype.join.call(res, '\n')}\n`);
        }
      } else {
        let res = inspectValue(actual);
        let other = inspectValue(expected);
        const knownOperator = kReadableOperator[operator];
        if (operator === 'notDeepEqual' && res === other) {
          res = `${knownOperator}\n\n${res}`;
          if (res.length > 1024) {
            res = `${String.prototype.slice.call(res, 0, 1021)}...`;
          }
          super(res);
        } else {
          if (res.length > 512) {
            res = `${String.prototype.slice.call(res, 0, 509)}...`;
          }
          if (other.length > 512) {
            other = `${String.prototype.slice.call(other, 0, 509)}...`;
          }
          if (operator === 'deepEqual') {
            res = `${knownOperator}\n\n${res}\n\nshould loosely deep-equal\n\n`;
          } else {
            const newOp = kReadableOperator[`${operator}Unequal`];
            if (newOp) {
              res = `${newOp}\n\n${res}\n\nshould not loosely deep-equal\n\n`;
            } else {
              other = ` ${operator} ${other}`;
            }
          }
          super(`${res}${other}`);
        }
      }
    }

    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;

    this.generatedMessage = !message;
    Object.defineProperty(this, 'name', {
      __proto__: null,
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    this.code = 'ERR_ASSERTION';
    if (details) {
      this.actual = undefined;
      this.expected = undefined;
      this.operator = undefined;
      for (let i = 0; i < details.length; i++) {
        this['message ' + i] = details[i].message;
        this['actual ' + i] = details[i].actual;
        this['expected ' + i] = details[i].expected;
        this['operator ' + i] = details[i].operator;
        this['stack trace ' + i] = details[i].stack;
      }
    } else {
      this.actual = actual;
      this.expected = expected;
      this.operator = operator;
    }
    // Error.captureStackTrace(this, stackStartFn || stackStartFunction);
    // Create error message including the error code in the name.
    this.stack; // eslint-disable-line no-unused-expressions
    // Reset the name.
    this.name = 'AssertionError';

    print(this);
    print(this.stack);
  }

  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }

  [inspect.custom](recurseTimes, ctx) {
    // Long strings should not be fully inspected.
    const tmpActual = this.actual;
    const tmpExpected = this.expected;

    if (typeof this.actual === 'string') {
      this.actual = addEllipsis(this.actual);
    }
    if (typeof this.expected === 'string') {
      this.expected = addEllipsis(this.expected);
    }

    // This limits the `actual` and `expected` property default inspection to
    // the minimum depth. Otherwise those values would be too verbose compared
    // to the actual error message which contains a combined view of these two
    // input values.
    const result = inspect(this, {
      ...ctx,
      customInspect: false,
      depth: 0
    });

    // Reset the properties after inspection.
    this.actual = tmpActual;
    this.expected = tmpExpected;

    return result;
  }
}

export default AssertionError;

```"
"```javascript:test\fs\test-fs-error-messages.js
// Flags: --expose-internals
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();


const nonexistentFile = path.join(tmpdir.path, 'non-existent');
const nonexistentDir = path.join(tmpdir.path, 'non-existent', 'foo', 'bar');
const existingFile = path.join(tmpdir.path, 'existingFile.js');
const existingFile2 = path.join(tmpdir.path, 'existingFile2.js');
const existingDir = path.join(tmpdir.path, 'dir');
const existingDir2 = fixtures.path('keys');
fs.mkdirSync(existingDir);
fs.writeFileSync(existingFile, 'test', 'utf-8');
fs.writeFileSync(existingFile2, 'test', 'utf-8');


const { COPYFILE_EXCL } = fs.constants;
import { internalBinding } from 'internal/test/binding';
const {
  UV_EBADF,
  UV_EEXIST,
  UV_EINVAL,
  UV_ENOENT,
  UV_ENOTDIR,
  UV_ENOTEMPTY,
  UV_EPERM
} = internalBinding('uv');

// Template tag function for escaping special characters in strings so that:
// new RegExp(re`${str}`).test(str) === true
function re(literals, ...values) {
  const escapeRE = /[\\^$.*+?()[\]{}|=!<>:-]/g;
  let result = literals[0].replace(escapeRE, '\\$&');
  for (const [i, value] of values.entries()) {
    result += value.replace(escapeRE, '\\$&');
    result += literals[i + 1].replace(escapeRE, '\\$&');
  }
  return result;
}

// stat
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, stat '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'stat');
    return true;
  };

  fs.stat(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.statSync(nonexistentFile),
    validateError
  );
}

// lstat
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, lstat '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'lstat');
    return true;
  };

  fs.lstat(nonexistentFile, common.mustCall(validateError));
  assert.throws(
    () => fs.lstatSync(nonexistentFile),
    validateError
  );
}

// fstat
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fstat');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fstat');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fstat(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.fstatSync(fd),
      validateError
    );
  });
}

// realpath
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, lstat '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'lstat');
    return true;
  };

  fs.realpath(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.realpathSync(nonexistentFile),
    validateError
  );
}

// native realpath
/*{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, realpath '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'realpath');
    return true;
  };

  fs.realpath.native(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.realpathSync.native(nonexistentFile),
    validateError
  );
}*/

// readlink
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, readlink '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'readlink');
    return true;
  };

  fs.readlink(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.readlinkSync(nonexistentFile),
    validateError
  );
}

// Link nonexistent file
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    // Could be resolved to an absolute path
    assert.ok(err.dest.endsWith('foo'),
              `expect ${err.dest} to end with 'foo'`);
    const regexp = new RegExp('^ENOENT: no such file or directory, link ' +
                              re`'${nonexistentFile}' -> ` + '\'.*foo\'');
    assert.match(err.message, regexp);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'link');
    return true;
  };

  fs.link(nonexistentFile, 'foo', common.mustCall(validateError));

  assert.throws(
    () => fs.linkSync(nonexistentFile, 'foo'),
    validateError
  );
}

// link existing file
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(existingFile2, err.dest);
    assert.strictEqual(
      err.message,
      `EEXIST: file already exists, link '${existingFile}' -> ` +
      `'${existingFile2}'`);
    assert.strictEqual(err.errno, UV_EEXIST);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'link');
    return true;
  };

  fs.link(existingFile, existingFile2, common.mustCall(validateError));

  assert.throws(
    () => fs.linkSync(existingFile, existingFile2),
    validateError
  );
}

// symlink
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(existingFile2, err.dest);
    assert.strictEqual(
      err.message,
      `EEXIST: file already exists, symlink '${existingFile}' -> ` +
      `'${existingFile2}'`);
    assert.strictEqual(err.errno, UV_EEXIST);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'symlink');
    return true;
  };

  fs.symlink(existingFile, existingFile2, common.mustCall(validateError));

  assert.throws(
    () => fs.symlinkSync(existingFile, existingFile2),
    validateError
  );
}

// unlink
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, unlink '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'unlink');
    return true;
  };

  fs.unlink(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.unlinkSync(nonexistentFile),
    validateError
  );
}

// rename
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    // Could be resolved to an absolute path
    assert.ok(err.dest.endsWith('foo'),
              `expect ${err.dest} to end with 'foo'`);
    const regexp = new RegExp('ENOENT: no such file or directory, rename ' +
                              re`'${nonexistentFile}' -> ` + '\'.*foo\'');
    assert.match(err.message, regexp);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'rename');
    return true;
  };

  const destFile = path.join(tmpdir.path, 'foo');
  fs.rename(nonexistentFile, destFile, common.mustCall(validateError));

  assert.throws(
    () => fs.renameSync(nonexistentFile, destFile),
    validateError
  );
}

// Rename non-empty directory
{
  const validateError = (err) => {
    assert.strictEqual(existingDir, err.path);
    assert.strictEqual(existingDir2, err.dest);
    assert.strictEqual(err.syscall, 'rename');
    // Could be ENOTEMPTY, EEXIST, or EPERM, depending on the platform
    if (err.code === 'ENOTEMPTY') {
      assert.strictEqual(
        err.message,
        `ENOTEMPTY: directory not empty, rename '${existingDir}' -> ` +
        `'${existingDir2}'`);
      assert.strictEqual(err.errno, UV_ENOTEMPTY);
    } else if (err.code === 'EXDEV') {  // Not on the same mounted filesystem
      assert.strictEqual(
        err.message,
        `EXDEV: cross-device link not permitted, rename '${existingDir}' -> ` +
            `'${existingDir2}'`);
    } else if (err.code === 'EEXIST') {  // smartos and aix
      assert.strictEqual(
        err.message,
        `EEXIST: file already exists, rename '${existingDir}' -> ` +
        `'${existingDir2}'`);
      assert.strictEqual(err.errno, UV_EEXIST);
    } else {  // windows
      assert.strictEqual(
        err.message,
        `EPERM: operation not permitted, rename '${existingDir}' -> ` +
        `'${existingDir2}'`);
      assert.strictEqual(err.errno, UV_EPERM);
      assert.strictEqual(err.code, 'EPERM');
    }
    return true;
  };

  fs.rename(existingDir, existingDir2, common.mustCall(validateError));

  assert.throws(
    () => fs.renameSync(existingDir, existingDir2),
    validateError
  );
}

// rmdir
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, rmdir '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'rmdir');
    return true;
  };

  fs.rmdir(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.rmdirSync(nonexistentFile),
    validateError
  );
}

// rmdir a file
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(err.syscall, 'rmdir');
    if (err.code === 'ENOTDIR') {
      assert.strictEqual(
        err.message,
        `ENOTDIR: not a directory, rmdir '${existingFile}'`);
      assert.strictEqual(err.errno, UV_ENOTDIR);
    } else {  // windows
      assert.strictEqual(
        err.message,
        `ENOENT: no such file or directory, rmdir '${existingFile}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
    }
    return true;
  };

  fs.rmdir(existingFile, common.mustCall(validateError));

  assert.throws(
    () => fs.rmdirSync(existingFile),
    validateError
  );
}

// mkdir
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(
      err.message,
      `EEXIST: file already exists, mkdir '${existingFile}'`);
    assert.strictEqual(err.errno, UV_EEXIST);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'mkdir');
    return true;
  };

  fs.mkdir(existingFile, 0o666, common.mustCall(validateError));

  assert.throws(
    () => fs.mkdirSync(existingFile, 0o666),
    validateError
  );
}

// chmod
/*
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, chmod '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'chmod');
    return true;
  };

  fs.chmod(nonexistentFile, 0o666, common.mustCall(validateError));

  assert.throws(
    () => fs.chmodSync(nonexistentFile, 0o666),
    validateError
  );
}*/

// open
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, open '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'open');
    return true;
  };

  fs.open(nonexistentFile, 'r', 0o666, common.mustCall(validateError));

  assert.throws(
    () => fs.openSync(nonexistentFile, 'r', 0o666),
    validateError
  );
}


// close
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, close');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'close');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.close(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.closeSync(fd),
      validateError
    );
  });
}

// readFile
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, open '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'open');
    return true;
  };

  fs.readFile(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.readFileSync(nonexistentFile),
    validateError
  );
}

// readdir
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, scandir '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'scandir');
    return true;
  };

  fs.readdir(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.readdirSync(nonexistentFile),
    validateError
  );
}

// ftruncate
{
  const validateError = (err) => {
    assert.strictEqual(err.syscall, 'ftruncate');
    // Could be EBADF or EINVAL, depending on the platform
    if (err.code === 'EBADF') {
      assert.strictEqual(err.message, 'EBADF: bad file descriptor, ftruncate');
      assert.strictEqual(err.errno, UV_EBADF);
    } else {
      assert.strictEqual(err.message, 'EINVAL: invalid argument, ftruncate');
      assert.strictEqual(err.errno, UV_EINVAL);
      assert.strictEqual(err.code, 'EINVAL');
    }
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.ftruncate(fd, 4, common.mustCall(validateError));

    assert.throws(
      () => fs.ftruncateSync(fd, 4),
      validateError
    );
  });
}

// fdatasync
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fdatasync');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fdatasync');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fdatasync(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.fdatasyncSync(fd),
      validateError
    );
  });
}

// fsync
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fsync');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fsync');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fsync(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.fsyncSync(fd),
      validateError
    );
  });
}

// chown
/*if (!common.isWindows) {
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, chown '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'chown');
    return true;
  };

  fs.chown(nonexistentFile, process.getuid(), process.getgid(),
           common.mustCall(validateError));

  assert.throws(
    () => fs.chownSync(nonexistentFile,
                       process.getuid(), process.getgid()),
    validateError
  );
}*/

// utimes
if (!common.isAIX) {
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, utime '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'utime');
    return true;
  };

  fs.utimes(nonexistentFile, new Date(), new Date(),
            common.mustCall(validateError));

  assert.throws(
    () => fs.utimesSync(nonexistentFile, new Date(), new Date()),
    validateError
  );
}

// mkdtemp
{
  const validateError = (err) => {
    const pathPrefix = new RegExp('^' + re`${nonexistentDir}`);
    assert.match(err.path, pathPrefix);

    const prefix = new RegExp('^ENOENT: no such file or directory, mkdtemp ' +
                              re`'${nonexistentDir}`);
    assert.match(err.message, prefix);

    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'mkdtemp');
    return true;
  };

  fs.mkdtemp(nonexistentDir, common.mustCall(validateError));

  assert.throws(
    () => fs.mkdtempSync(nonexistentDir),
    validateError
  );
}

// Check copyFile with invalid modes.
{
  const validateError = {
    message: /""mode"".+must be an integer >= 0 && <= 7\. Received -1/,
    code: 'ERR_OUT_OF_RANGE'
  };

  assert.throws(
    () => fs.copyFile(existingFile, nonexistentFile, -1, () => {}),
    validateError
  );
  assert.throws(
    () => fs.copyFileSync(existingFile, nonexistentFile, -1),
    validateError
  );
}

// copyFile: destination exists but the COPYFILE_EXCL flag is provided.
{
  const validateError = (err) => {
    if (err.code === 'ENOENT') {  // Could be ENOENT or EEXIST
      assert.strictEqual(err.message,
                         'ENOENT: no such file or directory, copyfile ' +
                         `'${existingFile}' -> '${existingFile2}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
      assert.strictEqual(err.syscall, 'copyfile');
    } else {
      assert.strictEqual(err.message,
                         'EEXIST: file already exists, copyfile ' +
                         `'${existingFile}' -> '${existingFile2}'`);
      assert.strictEqual(err.errno, UV_EEXIST);
      assert.strictEqual(err.code, 'EEXIST');
      assert.strictEqual(err.syscall, 'copyfile');
    }
    return true;
  };

  fs.copyFile(existingFile, existingFile2, COPYFILE_EXCL,
              common.mustCall(validateError));

  assert.throws(
    () => fs.copyFileSync(existingFile, existingFile2, COPYFILE_EXCL),
    validateError
  );
}

// copyFile: the source does not exist.
{
  const validateError = (err) => {
    assert.strictEqual(err.message,
                       'ENOENT: no such file or directory, copyfile ' +
                       `'${nonexistentFile}' -> '${existingFile2}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'copyfile');
    return true;
  };

  fs.copyFile(nonexistentFile, existingFile2, COPYFILE_EXCL,
              common.mustCall(validateError));

  assert.throws(
    () => fs.copyFileSync(nonexistentFile, existingFile2, COPYFILE_EXCL),
    validateError
  );
}

// read
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, read');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'read');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    const buf = Buffer.alloc(5);
    fs.read(fd, buf, 0, 1, 1, common.mustCall(validateError));

    assert.throws(
      () => fs.readSync(fd, buf, 0, 1, 1),
      validateError
    );
  });
}

// fchmod
/*{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fchmod');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fchmod');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fchmod(fd, 0o666, common.mustCall(validateError));

    assert.throws(
      () => fs.fchmodSync(fd, 0o666),
      validateError
    );
  });
}

// fchown
if (!common.isWindows) {
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fchown');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fchown');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fchown(fd, process.getuid(), process.getgid(),
              common.mustCall(validateError));

    assert.throws(
      () => fs.fchownSync(fd, process.getuid(), process.getgid()),
      validateError
    );
  });
}*/

// write buffer
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, write');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'write');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    const buf = Buffer.alloc(5);
    fs.write(fd, buf, 0, 1, 1, common.mustCall(validateError));

    assert.throws(
      () => fs.writeSync(fd, buf, 0, 1, 1),
      validateError
    );
  });
}

// write string
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, write');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'write');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.write(fd, 'test', 1, common.mustCall(validateError));

    assert.throws(
      () => fs.writeSync(fd, 'test', 1),
      validateError
    );
  });
}


// futimes
if (!common.isAIX) {
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, futime');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'futime');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.futimes(fd, new Date(), new Date(), common.mustCall(validateError));

    assert.throws(
      () => fs.futimesSync(fd, new Date(), new Date()),
      validateError
    );
  });
}

```"
"```javascript:modules\punycode.js
'use strict';

/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	const parts = string.split('@');
	let result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	const labels = string.split('.');
	const encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter < length) {
		const value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = array => String.fromCodePoint(...array);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function(delta, numPoints, firstTime) {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function(input) {
	// Don't use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (let j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		let oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index >= inputLength) {
				error('invalid-input');
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error('overflow');
			}

			i += digit * w;
			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

			if (digit < t) {
				break;
			}

			const baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error('overflow');
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function(input) {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	let inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue < 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	let basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue >= n && currentValue < m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue < n && ++delta > maxInt) {
				error('overflow');
			}
			if (currentValue == n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
					if (q < t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function(input) {
	return mapDomain(input, function(string) {
		return regexPunycode.test(string)
			? decode(string.slice(4).toLowerCase())
			: string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function(input) {
	return mapDomain(input, function(string) {
		return regexNonASCII.test(string)
			? 'xn--' + encode(string)
			: string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	'version': '2.1.0',
	/**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

export { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };
export default punycode;

```"
"```javascript:test\crypto\test-crypto-binary-default.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Flags: --expose-internals

// This is the same as test/simple/test-crypto, but from before the shift
// to use buffers by default.


const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const fs = require('fs');
const tls = require('tls');
const fixtures = require('../common/fixtures');

require('internal/crypto/util').setDefaultEncoding('latin1');

// Test Certificates
const certPem = fixtures.readKey('rsa_cert.crt');
const certPfx = fixtures.readKey('rsa_cert.pfx');
const keyPem = fixtures.readKey('rsa_private.pem');
const rsaPubPem = fixtures.readKey('rsa_public.pem', 'ascii');
const rsaKeyPem = fixtures.readKey('rsa_private.pem', 'ascii');

// PFX tests
tls.createSecureContext({ pfx: certPfx, passphrase: 'sample' });

assert.throws(function() {
  tls.createSecureContext({ pfx: certPfx });
}, /^Error: mac verify failure$/);

assert.throws(function() {
  tls.createSecureContext({ pfx: certPfx, passphrase: 'test' });
}, /^Error: mac verify failure$/);

assert.throws(function() {
  tls.createSecureContext({ pfx: 'sample', passphrase: 'test' });
}, /^Error: not enough data$/);

// Test HMAC
{
  const hmacHash = crypto.createHmac('sha1', 'Node')
                         .update('some data')
                         .update('to hmac')
                         .digest('hex');
  assert.strictEqual(hmacHash, '19fd6e1ba73d9ed2224dd5094a71babe85d9a892');
}

// Test HMAC-SHA-* (rfc 4231 Test Cases)
{
  const rfc4231 = [
    {
      key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
      data: Buffer.from('4869205468657265', 'hex'), // 'Hi There'
      hmac: {
        sha224: '896fb1128abbdf196832107cd49df33f47b4b1169912ba4f53684b22',
        sha256:
            'b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c' +
            '2e32cff7',
        sha384:
            'afd03944d84895626b0825f4ab46907f15f9dadbe4101ec682aa034c' +
            '7cebc59cfaea9ea9076ede7f4af152e8b2fa9cb6',
        sha512:
            '87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b305' +
            '45e17cdedaa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f170' +
            '2e696c203a126854'
      }
    },
    {
      key: Buffer.from('4a656665', 'hex'), // 'Jefe'
      data: Buffer.from('7768617420646f2079612077616e7420666f72206e6f74686' +
                        '96e673f', 'hex'), // 'what do ya want for nothing?'
      hmac: {
        sha224: 'a30e01098bc6dbbf45690f3a7e9e6d0f8bbea2a39e6148008fd05e44',
        sha256:
            '5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b9' +
            '64ec3843',
        sha384:
            'af45d2e376484031617f78d2b58a6b1b9c7ef464f5a01b47e42ec373' +
            '6322445e8e2240ca5e69e2c78b3239ecfab21649',
        sha512:
            '164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7' +
            'ea2505549758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b' +
            '636e070a38bce737'
      }
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
      data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                        'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                        'hex'),
      hmac: {
        sha224: '7fb3cb3588c6c1f6ffa9694d7d6ad2649365b0c1f65d69d1ec8333ea',
        sha256:
            '773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514' +
            'ced565fe',
        sha384:
            '88062608d3e6ad8a0aa2ace014c8a86f0aa635d947ac9febe83ef4e5' +
            '5966144b2a5ab39dc13814b94e3ab6e101a34f27',
        sha512:
            'fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33' +
            'b2279d39bf3e848279a722c806b485a47e67c807b946a337bee89426' +
            '74278859e13292fb'
      }
    },
    {
      key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                       'hex'),
      data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                        'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd',
                        'hex'),
      hmac: {
        sha224: '6c11506874013cac6a2abc1bb382627cec6a90d86efc012de7afec5a',
        sha256:
            '82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff4' +
            '6729665b',
        sha384:
            '3e8a69b7783c25851933ab6290af6ca77a9981480850009cc5577c6e' +
            '1f573b4e6801dd23c4a7d679ccf8a386c674cffb',
        sha512:
            'b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050' +
            '361ee3dba91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2d' +
            'e2adebeb10a298dd'
      }
    },
    {
      key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
      // 'Test With Truncation'
      data: Buffer.from('546573742057697468205472756e636174696f6e', 'hex'),
      hmac: {
        sha224: '0e2aea68a90c8d37c988bcdb9fca6fa8',
        sha256: 'a3b6167473100ee06e0c796c2955552b',
        sha384: '3abf34c3503b2a23a46efc619baef897',
        sha512: '415fad6271580a531d4179bc891d87a6'
      },
      truncate: true
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaa', 'hex'),
      // 'Test Using Larger Than Block-Size Key - Hash Key First'
      data: Buffer.from('54657374205573696e67204c6172676572205468616e20426' +
                        'c6f636b2d53697a65204b6579202d2048617368204b657920' +
                        '4669727374', 'hex'),
      hmac: {
        sha224: '95e9a0db962095adaebe9b2d6f0dbce2d499f112f2d2b7273fa6870e',
        sha256:
            '60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f' +
            '0ee37f54',
        sha384:
            '4ece084485813e9088d2c63a041bc5b44f9ef1012a2b588f3cd11f05' +
            '033ac4c60c2ef6ab4030fe8296248df163f44952',
        sha512:
            '80b24263c7c1a3ebb71493c1dd7be8b49b46d1f41b4aeec1121b0137' +
            '83f8f3526b56d037e05f2598bd0fd2215d6a1e5295e64f73f63f0aec' +
            '8b915a985d786598'
      }
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaa', 'hex'),
      // 'This is a test using a larger than block-size key and a larger ' +
      // 'than block-size data. The key needs to be hashed before being ' +
      // 'used by the HMAC algorithm.'
      data: Buffer.from('5468697320697320612074657374207573696e672061206c6' +
                        '172676572207468616e20626c6f636b2d73697a65206b6579' +
                        '20616e642061206c6172676572207468616e20626c6f636b2' +
                        'd73697a6520646174612e20546865206b6579206e65656473' +
                        '20746f20626520686173686564206265666f7265206265696' +
                        'e6720757365642062792074686520484d414320616c676f72' +
                        '6974686d2e', 'hex'),
      hmac: {
        sha224: '3a854166ac5d9f023f54d517d0b39dbd946770db9c2b95c9f6f565d1',
        sha256:
            '9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f5153' +
            '5c3a35e2',
        sha384:
            '6617178e941f020d351e2f254e8fd32c602420feb0b8fb9adccebb82' +
            '461e99c5a678cc31e799176d3860e6110c46523e',
        sha512:
            'e37b6a775dc87dbaa4dfa9f96e5e3ffddebd71f8867289865df5a32d' +
            '20cdc944b6022cac3c4982b10d5eeb55c3e4de15134676fb6de04460' +
            '65c97440fa8c6a58'
      }
    },
  ];

  for (const testCase of rfc4231) {
    for (const hash in testCase.hmac) {
      let result = crypto.createHmac(hash, testCase.key)
                       .update(testCase.data)
                       .digest('hex');
      if (testCase.truncate) {
        result = result.substr(0, 32); // first 128 bits == 32 hex chars
      }
      assert.strictEqual(
        testCase.hmac[hash],
        result
      );
    }
  }
}

// Test HMAC-MD5/SHA1 (rfc 2202 Test Cases)
{
  const rfc2202_md5 = [
    {
      key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
      data: 'Hi There',
      hmac: '9294727a3638bb1c13f48ef8158bfc9d'
    },
    {
      key: 'Jefe',
      data: 'what do ya want for nothing?',
      hmac: '750c783e6ab0b503eaa86e310a5db738'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
      data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                        'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                        'hex'),
      hmac: '56be34521d144c88dbb8c733f0e8b3f6'
    },
    {
      key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                       'hex'),
      data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                        'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                        'cdcdcdcdcd',
                        'hex'),
      hmac: '697eaf0aca3a3aea3a75164746ffaa79'
    },
    {
      key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
      data: 'Test With Truncation',
      hmac: '56461ef2342edc00f9bab995690efd4c'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data: 'Test Using Larger Than Block-Size Key - Hash Key First',
      hmac: '6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data:
          'Test Using Larger Than Block-Size Key and Larger Than One ' +
          'Block-Size Data',
      hmac: '6f630fad67cda0ee1fb1f562db3aa53e'
    },
  ];
  const rfc2202_sha1 = [
    {
      key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
      data: 'Hi There',
      hmac: 'b617318655057264e28bc0b6fb378c8ef146be00'
    },
    {
      key: 'Jefe',
      data: 'what do ya want for nothing?',
      hmac: 'effcdf6ae5eb2fa2d27416d5f184df9c259a7c79'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
      data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddd' +
                        'ddddddddddddddddddddddddddddddddddddddddddddd' +
                        'dddddddddd',
                        'hex'),
      hmac: '125d7342b9ac11cd91a39af48aa17b4f63f175d3'
    },
    {
      key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                       'hex'),
      data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                        'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                        'cdcdcdcdcd',
                        'hex'),
      hmac: '4c9007f4026250c6bc8414f9bf50c86c2d7235da'
    },
    {
      key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
      data: 'Test With Truncation',
      hmac: '4c1a03424b55e07fe7f27be1d58bb9324a9a5a04'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data: 'Test Using Larger Than Block-Size Key - Hash Key First',
      hmac: 'aa4ae5e15272d00e95705637ce8a3b55ed402112'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data:
          'Test Using Larger Than Block-Size Key and Larger Than One ' +
          'Block-Size Data',
      hmac: 'e8e99d0f45237d786d6bbaa7965c7808bbff1a91'
    },
  ];

  if (!common.hasFipsCrypto) {
    for (const testCase of rfc2202_md5) {
      assert.strictEqual(
        testCase.hmac,
        crypto.createHmac('md5', testCase.key)
          .update(testCase.data)
          .digest('hex')
      );
    }
  }
  for (const testCase of rfc2202_sha1) {
    assert.strictEqual(
      testCase.hmac,
      crypto.createHmac('sha1', testCase.key)
        .update(testCase.data)
        .digest('hex')
    );
  }
}

// Test hashing
{
  const a1 = crypto.createHash('sha1').update('Test123').digest('hex');
  const a2 = crypto.createHash('sha256').update('Test123').digest('base64');
  const a3 = crypto.createHash('sha512').update('Test123').digest(); // binary
  const a4 = crypto.createHash('sha1').update('Test123').digest('buffer');

  if (!common.hasFipsCrypto) {
    const a0 = crypto.createHash('md5').update('Test123').digest('latin1');
    assert.strictEqual(
      a0,
      'h\u00ea\u00cb\u0097\u00d8o\fF!\u00fa+\u000e\u0017\u00ca\u00bd\u008c'
    );
  }

  assert.strictEqual(a1, '8308651804facb7b9af8ffc53a33a22d6a1c8ac2');

  assert.strictEqual(a2, '2bX1jws4GYKTlxhloUB09Z66PoJZW+y+hq5R8dnx9l4=');

  // Test SHA512 as assumed latin1
  assert.strictEqual(
    a3,
    '\u00c1(4\u00f1\u0003\u001fd\u0097!O\'\u00d4C/&Qz\u00d4' +
    '\u0094\u0015l\u00b8\u008dQ+\u00db\u001d\u00c4\u00b5}\u00b2' +
    '\u00d6\u0092\u00a3\u00df\u00a2i\u00a1\u009b\n\n*\u000f' +
    '\u00d7\u00d6\u00a2\u00a8\u0085\u00e3<\u0083\u009c\u0093' +
    '\u00c2\u0006\u00da0\u00a1\u00879(G\u00ed\''
  );

  assert.deepStrictEqual(
    a4,
    Buffer.from('8308651804facb7b9af8ffc53a33a22d6a1c8ac2', 'hex')
  );
}

// Test multiple updates to same hash
{
  const h1 = crypto.createHash('sha1').update('Test123').digest('hex');
  const h2 = crypto.createHash('sha1').update('Test').update('123')
    .digest('hex');
  assert.strictEqual(h1, h2);
}

// Test hashing for binary files
{
  const fn = fixtures.path('sample.png');
  const sha1Hash = crypto.createHash('sha1');
  const fileStream = fs.createReadStream(fn);
  fileStream.on('data', function(data) {
    sha1Hash.update(data);
  });
  fileStream.on('close', common.mustCall(function() {
    assert.strictEqual(
      sha1Hash.digest('hex'),
      '22723e553129a336ad96e10f6aecdf0f45e4149e'
    );
  }));
}

// Unknown digest method should throw an error:
// https://github.com/nodejs/node-v0.x-archive/issues/2227
assert.throws(function() {
  crypto.createHash('xyzzy');
}, /^Error: Digest method not supported$/);

// Test signing and verifying
{
  const s1 = crypto.createSign('SHA1')
                 .update('Test123')
                 .sign(keyPem, 'base64');
  const s1Verified = crypto.createVerify('SHA1')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s1, 'base64');
  assert.strictEqual(s1Verified, true);

  const s2 = crypto.createSign('SHA256')
                 .update('Test123')
                 .sign(keyPem); // binary
  const s2Verified = crypto.createVerify('SHA256')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s2); // binary
  assert.strictEqual(s2Verified, true);

  const s3 = crypto.createSign('SHA1')
                 .update('Test123')
                 .sign(keyPem, 'buffer');
  const s3Verified = crypto.createVerify('SHA1')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s3);
  assert.strictEqual(s3Verified, true);
}


function testCipher1(key) {
  // Test encryption and decryption
  const plaintext = 'Keep this a secret? No! Tell everyone about node.js!';
  const cipher = crypto.createCipher('aes192', key);

  // Encrypt plaintext which is in utf8 format
  // to a ciphertext which will be in hex
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  // Only use binary or hex, not base64.
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipher('aes192', key);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher2(key) {
  // Encryption and decryption with Base64.
  // Reported in https://github.com/joyent/node/issues/738
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipher('aes256', key);

  // Encrypt plaintext which is in utf8 format
  // to a ciphertext which will be in Base64
  let ciph = cipher.update(plaintext, 'utf8', 'base64');
  ciph += cipher.final('base64');

  const decipher = crypto.createDecipher('aes256', key);
  let txt = decipher.update(ciph, 'base64', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher3(key, iv) {
  // Test encryption and decryption with explicit key and iv
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher4(key, iv) {
  // Test encryption and decryption with explicit key and iv
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'buffer', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher5(key, iv) {
  // Test encryption and decryption with explicit key with aes128-wrap
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipher('id-aes128-wrap', key);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);

  const decipher = crypto.createDecipher('id-aes128-wrap', key);
  let txt = decipher.update(ciph, 'buffer', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}

if (!common.hasFipsCrypto) {
  testCipher1('MySecretKey123');
  testCipher1(Buffer.from('MySecretKey123'));

  testCipher2('0123456789abcdef');
  testCipher2(Buffer.from('0123456789abcdef'));

  testCipher5(Buffer.from('0123456789abcd0123456789'));
}

testCipher3('0123456789abcd0123456789', '12345678');
testCipher3('0123456789abcd0123456789', Buffer.from('12345678'));
testCipher3(Buffer.from('0123456789abcd0123456789'), '12345678');
testCipher3(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));

testCipher4(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));


// update() should only take buffers / strings
assert.throws(
  () => crypto.createHash('sha1').update({ foo: 'bar' }),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });


// Test Diffie-Hellman with two parties sharing a secret,
// using various encodings as we go along
{
  const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
  const dh1 = crypto.createDiffieHellman(size);
  const p1 = dh1.getPrime('buffer');
  const dh2 = crypto.createDiffieHellman(p1, 'base64');
  const key1 = dh1.generateKeys();
  const key2 = dh2.generateKeys('hex');
  const secret1 = dh1.computeSecret(key2, 'hex', 'base64');
  const secret2 = dh2.computeSecret(key1, 'latin1', 'buffer');

  assert.strictEqual(secret1, secret2.toString('base64'));

  // Create ""another dh1"" using generated keys from dh1,
  // and compute secret again
  const dh3 = crypto.createDiffieHellman(p1, 'buffer');
  const privkey1 = dh1.getPrivateKey();
  dh3.setPublicKey(key1);
  dh3.setPrivateKey(privkey1);

  assert.strictEqual(dh1.getPrime(), dh3.getPrime());
  assert.strictEqual(dh1.getGenerator(), dh3.getGenerator());
  assert.strictEqual(dh1.getPublicKey(), dh3.getPublicKey());
  assert.strictEqual(dh1.getPrivateKey(), dh3.getPrivateKey());

  const secret3 = dh3.computeSecret(key2, 'hex', 'base64');

  assert.strictEqual(secret1, secret3);

  // https://github.com/joyent/node/issues/2338
  const p = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +
            '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +
            '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +
            'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF';
  crypto.createDiffieHellman(p, 'hex');

  // Test RSA key signing/verification
  const rsaSign = crypto.createSign('SHA1');
  const rsaVerify = crypto.createVerify('SHA1');
  assert.ok(rsaSign instanceof crypto.Sign);
  assert.ok(rsaVerify instanceof crypto.Verify);

  rsaSign.update(rsaPubPem);
  const rsaSignature = rsaSign.sign(rsaKeyPem, 'hex');
  const expectedSignature = fixtures.readKey(
    'rsa_public_sha1_signature_signedby_rsa_private.sha1',
    'hex'
  );
  assert.strictEqual(rsaSignature, expectedSignature);

  rsaVerify.update(rsaPubPem);
  assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);
}

//
// Test RSA signing and verification
//
{
  const privateKey = fixtures.readKey('rsa_private_b.pem');
  const publicKey = fixtures.readKey('rsa_public_b.pem');

  const input = 'I AM THE WALRUS';

  const signature = fixtures.readKey(
    'I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256',
    'hex'
  );

  const sign = crypto.createSign('SHA256');
  sign.update(input);

  const output = sign.sign(privateKey, 'hex');
  assert.strictEqual(output, signature);

  const verify = crypto.createVerify('SHA256');
  verify.update(input);

  assert.strictEqual(verify.verify(publicKey, signature, 'hex'), true);
}


//
// Test DSA signing and verification
//
{
  const privateKey = fixtures.readKey('dsa_private.pem');
  const publicKey = fixtures.readKey('dsa_public.pem');

  const input = 'I AM THE WALRUS';

  // DSA signatures vary across runs so there is no static string to verify
  // against
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signature = sign.sign(privateKey, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(publicKey, signature, 'hex'), true);
}


//
// Test PBKDF2 with RFC 6070 test vectors (except #4)
//
function testPBKDF2(password, salt, iterations, keylen, expected) {
  const actual = crypto.pbkdf2Sync(password, salt, iterations, keylen,
                                   'sha256');
  assert.strictEqual(actual, expected);

  const cb = common.mustCall((err, actual) => {
    assert.strictEqual(actual, expected);
  });
  crypto.pbkdf2(password, salt, iterations, keylen, 'sha256', cb);
}


testPBKDF2('password', 'salt', 1, 20,
           '\x12\x0f\xb6\xcf\xfc\xf8\xb3\x2c\x43\xe7\x22\x52' +
           '\x56\xc4\xf8\x37\xa8\x65\x48\xc9');

testPBKDF2('password', 'salt', 2, 20,
           '\xae\x4d\x0c\x95\xaf\x6b\x46\xd3\x2d\x0a\xdf\xf9' +
           '\x28\xf0\x6d\xd0\x2a\x30\x3f\x8e');

testPBKDF2('password', 'salt', 4096, 20,
           '\xc5\xe4\x78\xd5\x92\x88\xc8\x41\xaa\x53\x0d\xb6' +
           '\x84\x5c\x4c\x8d\x96\x28\x93\xa0');

testPBKDF2('passwordPASSWORDpassword',
           'saltSALTsaltSALTsaltSALTsaltSALTsalt',
           4096,
           25,
           '\x34\x8c\x89\xdb\xcb\xd3\x2b\x2f\x32\xd8\x14\xb8' +
           '\x11\x6e\x84\xcf\x2b\x17\x34\x7e\xbc\x18\x00\x18\x1c');

testPBKDF2('pass\0word', 'sa\0lt', 4096, 16,
           '\x89\xb6\x9d\x05\x16\xf8\x29\x89\x3c\x69\x62\x26' +
           '\x65\x0a\x86\x87');

```"
"```javascript:modules\internal\util\comparisons.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// deno-lint-ignore-file
import {
  isAnyArrayBuffer,
  isArrayBufferView,
  isBigIntObject,
  isBooleanObject,
  isBoxedPrimitive,
  isDate,
  isFloat32Array,
  isFloat64Array,
  isMap,
  isNativeError,
  isNumberObject,
  isRegExp,
  isSet,
  isStringObject,
  isSymbolObject,
  isTypedArray,
} from ""./types.js"";

import { Buffer } from ""buffer"";
import {
  getOwnNonIndexProperties,
  ONLY_ENUMERABLE,
  SKIP_SYMBOLS,
} from ""../../internal_binding/util"";

const valueType = {
  noIterator: 0,
  isArray: 1,
  isSet: 2,
  isMap: 3,
}

let memo;

export function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, true);
}
export function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, false);
}

function innerDeepEqual(
  val1,
  val2,
  strict,
  memos = memo,
) {
  // Basic case covered by Strict Equality Comparison
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    // Cases where the values are not objects
    // If both values are Not a Number NaN
    if (typeof val1 !== ""object"") {
      return (
        typeof val1 === ""number"" && Number.isNaN(val1) && Number.isNaN(val2)
      );
    }
    // If either value is null
    if (typeof val2 !== ""object"" || val1 === null || val2 === null) {
      return false;
    }
    // If the prototype are not the same
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    // Non strict case where values are either null or NaN
    if (val1 === null || typeof val1 !== ""object"") {
      if (val2 === null || typeof val2 !== ""object"") {
        return val1 == val2 || (Number.isNaN(val1) && Number.isNaN(val2));
      }
      return false;
    }
    if (val2 === null || typeof val2 !== ""object"") {
      return false;
    }
  }

  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);

  // prototype must be Strictly Equal
  if (
    val1Tag !== val2Tag
  ) {
    return false;
  }

  // handling when values are array
  if (Array.isArray(val1)) {
    // quick rejection cases
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keys1 = getOwnNonIndexProperties(val1, filter);
    const keys2 = getOwnNonIndexProperties(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
  } else if (val1Tag === ""[object Object]"") {
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.noIterator,
    );
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // stack may or may not be same, hence it shouldn't be compared
    if (
      // How to handle the type errors here
      (!isNativeError(val2) && !(val2 instanceof Error)) ||
      (val1).message !== (val2).message ||
      (val1).name !== (val2).name
    ) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) =>
      Object.getOwnPropertySymbols(val)
        .map((item) => item.toString())
        .toString();
    if (
      isTypedArray(val1) &&
      isTypedArray(val2) &&
      (TypedArrayPrototypeGetSymbolToStringTag(val1) !==
        TypedArrayPrototypeGetSymbolToStringTag(val2))
    ) {
      return false;
    }

    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keysVal1 = getOwnNonIndexProperties(val1, filter);
    const keysVal2 = getOwnNonIndexProperties(val2, filter);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.noIterator,
      keysVal1,
    );
  } else if (isSet(val1)) {
    if (
      !isSet(val2) ||
      (val1).size !== (val2).size
    ) {
      return false;
    }
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.isSet,
    );
  } else if (isMap(val1)) {
    if (
      !isMap(val2) ||
      (val1).size !== (val2).size
    ) {
      return false;
    }
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.isMap,
    );
  } else if (isAnyArrayBuffer(val1)) {
    if (!isAnyArrayBuffer(val2) || !areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1)) {
    if (!isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
  } else if (
    Array.isArray(val2) ||
    isArrayBufferView(val2) ||
    isSet(val2) ||
    isMap(val2) ||
    isDate(val2) ||
    isRegExp(val2) ||
    isAnyArrayBuffer(val2) ||
    isBoxedPrimitive(val2) ||
    isNativeError(val2) ||
    val2 instanceof Error
  ) {
    return false;
  }
  return keyCheck(
    val1,
    val2,
    strict,
    memos,
    valueType.noIterator,
  );
}

function keyCheck(
  val1,
  val2,
  strict,
  memos,
  iterationType,
  aKeys = [],
) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key)) {
          if (!val2.propertyIsEnumerable(key)) {
            return false;
          }
          // added toString here
          aKeys.push(key.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (
        symbolKeysA.length !== symbolKeysB.length &&
        getEnumerables(val2, symbolKeysB).length !== count
      ) {
        return false;
      }
    } else {
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (
        symbolKeysB.length !== 0 &&
        getEnumerables(val2, symbolKeysB).length !== 0
      ) {
        return false;
      }
    }
  }
  if (
    aKeys.length === 0 &&
    (iterationType === valueType.noIterator ||
      (iterationType === valueType.isArray && (val1).length === 0) ||
      (val1).size === 0)
  ) {
    return true;
  }

  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0,
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);

  const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);

  memos.val1.delete(val1);
  memos.val2.delete(val2);

  return areEq;
}

function areSimilarRegExps(a, b) {
  return a.source === b.source && a.flags === b.flags &&
    a.lastIndex === b.lastIndex;
}

// TODO(standvpmnt): add type for arguments
function areSimilarFloatArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

// TODO(standvpmnt): add type for arguments
function areSimilarTypedArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return (
    Buffer.compare(
      new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength),
      new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength),
    ) === 0
  );
}
// TODO(standvpmnt): add type for arguments
function areEqualArrayBuffers(buf1, buf2) {
  return (
    buf1.byteLength === buf2.byteLength &&
    Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0
  );
}

// TODO(standvpmnt):  this check of getOwnPropertySymbols and getOwnPropertyNames
// length is sufficient to handle the current test case, however this will fail
// to catch a scenario wherein the getOwnPropertySymbols and getOwnPropertyNames
// length is the same(will be very contrived but a possible shortcoming
function isEqualBoxedPrimitive(a, b) {
  if (
    Object.getOwnPropertyNames(a).length !==
    Object.getOwnPropertyNames(b).length
  ) {
    return false;
  }
  if (
    Object.getOwnPropertySymbols(a).length !==
    Object.getOwnPropertySymbols(b).length
  ) {
    return false;
  }
  if (isNumberObject(a)) {
    return (
      isNumberObject(b) &&
      Object.is(
        Number.prototype.valueOf.call(a),
        Number.prototype.valueOf.call(b),
      )
    );
  }
  if (isStringObject(a)) {
    return (
      isStringObject(b) &&
      (String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b))
    );
  }
  if (isBooleanObject(a)) {
    return (
      isBooleanObject(b) &&
      (Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b))
    );
  }
  if (isBigIntObject(a)) {
    return (
      isBigIntObject(b) &&
      (BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b))
    );
  }
  if (isSymbolObject(a)) {
    return (
      isSymbolObject(b) &&
      (Symbol.prototype.valueOf.call(a) ===
        Symbol.prototype.valueOf.call(b))
    );
  }
  // assert.fail(`Unknown boxed type ${val1}`);
  // return false;
  throw Error(`Unknown boxed type`);
}

function getEnumerables(val, keys) {
  return keys.filter((key) => val.propertyIsEnumerable(key));
}

function objEquiv(
  obj1,
  obj2,
  strict,
  keys,
  memos,
  iterationType,
) {
  let i = 0;

  if (iterationType === valueType.isSet) {
    if (!setEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType.isMap) {
    if (!mapEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType.isArray) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (
          !obj2.hasOwnProperty(i) ||
          !innerDeepEqual(obj1[i], obj2[i], strict, memos)
        ) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key = keys1[i];
          if (
            !obj2.hasOwnProperty(key) ||
            !innerDeepEqual(obj1[key], obj2[key], strict, memos)
          ) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }

  // Expensive test
  for (i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
      return false;
    }
  }
  return true;
}

function findLooseMatchingPrimitives(
  primitive,
) {
  switch (typeof primitive) {
    case ""undefined"":
      return null;
    case ""object"":
      return undefined;
    case ""symbol"":
      return false;
    case ""string"":
      primitive = +primitive;
    case ""number"":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}

function setMightHaveLoosePrim(
  set1,
  set2,
  primitive,
) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null) return altValue;

  return set2.has(altValue) && !set1.has(altValue);
}

function setHasEqualElement(
  set,
  val1,
  strict,
  memos,
) {
  for (const val2 of set) {
    if (innerDeepEqual(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }

  return false;
}

function setEquiv(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === ""object"" && item !== null) {
      if (set === null) {
        // What is SafeSet from primordials?
        // set = new SafeSet();
        set = new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict) return false;

      if (!setMightHaveLoosePrim(set1, set2, item)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }
      set.add(item);
    }
  }

  if (set !== null) {
    for (const item of set2) {
      if (typeof item === ""object"" && item !== null) {
        if (!setHasEqualElement(set, item, strict, memos)) return false;
      } else if (
        !strict &&
        !set1.has(item) &&
        !setHasEqualElement(set, item, strict, memos)
      ) {
        return false;
      }
    }
    return set.size === 0;
  }

  return true;
}

// TODO(standvpmnt): add types for argument
function mapMightHaveLoosePrimitive(
  map1,
  map2,
  primitive,
  item,
  memos,
) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (
    (curB === undefined && !map2.has(altValue)) ||
    !innerDeepEqual(item, curB, false, memo)
  ) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}

function mapEquiv(map1, map2, strict, memos) {
  let set = null;

  for (const { 0: key, 1: item1 } of map1) {
    if (typeof key === ""object"" && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      const item2 = map2.get(key);
      if (
        (
          (item2 === undefined && !map2.has(key)) ||
          !innerDeepEqual(item1, item2, strict, memos)
        )
      ) {
        if (strict) return false;
        if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }

  if (set !== null) {
    for (const { 0: key, 1: item } of map2) {
      if (typeof key === ""object"" && key !== null) {
        if (!mapHasEqualEntry(set, map1, key, item, strict, memos)) {
          return false;
        }
      } else if (
        !strict && (!map1.has(key) ||
          !innerDeepEqual(map1.get(key), item, false, memos)) &&
        !mapHasEqualEntry(set, map1, key, item, false, memos)
      ) {
        return false;
      }
    }
    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(
  set,
  map,
  key1,
  item1,
  strict,
  memos
) {
  for (const key2 of set) {
    if (
      innerDeepEqual(key1, key2, strict, memos) &&
      innerDeepEqual(item1, map.get(key2), strict, memos)
    ) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}

```"
"```javascript:modules\events.js
'use strict';

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a ""clean"" empty
// object (tested with v8 v4.9).

const kRejection = Symbol.for(""nodejs.rejection"");


function EventHandlers() { }
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

const captureRejectionSymbol = EventEmitter.captureRejectionSymbol;
EventEmitter.captureRejectionSymbol = kRejection;

export default EventEmitter;
export { EventEmitter, captureRejectionSymbol };

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function () {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('""n"" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified ""error"" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified ""error"" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('""listener"" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === ""newListener""! Before
    // adding it to the listeners, first emit ""newListener"".
    if (events.newListener) {
      target.emit('newListener', type,
        listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
        [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
          existing.length + ' ' + type + ' listeners added. ' +
          'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
  function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('""listener"" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
  function prependOnceListener(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('""listener"" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
  function removeListener(type, listener) {
    var list, events, position, i, originalListener;

    if (typeof listener !== 'function')
      throw new TypeError('""listener"" argument must be a function');

    events = this._events;
    if (!events)
      return this;

    list = events[type];
    if (!list)
      return this;

    if (list === listener || (list.listener && list.listener === listener)) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else {
        delete events[type];
        if (events.removeListener)
          this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length; i-- > 0;) {
        if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0)
        return this;

      if (list.length === 1) {
        list[0] = undefined;
        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }

      if (events.removeListener)
        this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

EventEmitter.prototype.removeAllListeners =
  function removeAllListeners(type) {
    var listeners, events;

    events = this._events;
    if (!events)
      return this;

    // not listening for removeListener, no need to emit
    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else
          delete events[type];
      }
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      var keys = Object.keys(events);
      for (var i = 0, key; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }

    return this;
  };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/**
 * Creates a `Promise` that is fulfilled when the emitter
 * emits the given event.
 * @param {EventEmitter} emitter
 * @param {string} name
 * @param {{ signal: AbortSignal; }} [options]
 * @returns {Promise}
 */
export async function once(emitter, name, options = kEmptyObject) {
  const signal = options?.signal;
  validateAbortSignal(signal, 'options.signal');
  if (signal?.aborted)
    throw new AbortError(undefined, { cause: signal?.reason });
  return new Promise((resolve, reject) => {
    const errorListener = (err) => {
      emitter.removeListener(name, resolver);
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);
      }
      reject(err);
    };
    const resolver = (...args) => {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);
      }
      resolve(args);
    };
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error' && typeof emitter.once === 'function') {
      // EventTarget does not have `error` event semantics like Node
      // EventEmitters, we listen to `error` events only on EventEmitters.
      emitter.once('error', errorListener);
    }
    function abortListener() {
      eventTargetAgnosticRemoveListener(emitter, name, resolver);
      eventTargetAgnosticRemoveListener(emitter, 'error', errorListener);
      reject(new AbortError(undefined, { cause: signal?.reason }));
    }
    if (signal != null) {
      eventTargetAgnosticAddListener(
        signal, 'abort', abortListener, { once: true });
    }
  });
}
```"
"```javascript:test\fs\test-fs-realpath.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';

if (!common.isMainThread)
  common.skip('process.chdir is not available in Workers');

import assert from 'assert';
import fs from 'fs';
import path from 'path';
let async_completed = 0;
let async_expected = 0;
const unlink = [];
const skipSymlinks = !common.canCreateSymLink();
const tmpDir = tmpdir.path;

tmpdir.refresh();

let root = '/';
let assertEqualPath = assert.strictEqual;
if (common.isWindows) {
  // Something like ""C:\\""
  root = process.cwd().substr(0, 3);
  assertEqualPath = function(path_left, path_right, message) {
    assert
      .strictEqual(path_left.toLowerCase(), path_right.toLowerCase(), message);
  };
}

process.nextTick(runTest);

function tmp(p) {
  return path.join(tmpDir, p);
}

const targetsAbsDir = path.join(tmpDir, 'targets');
const tmpAbsDir = tmpDir;

// Set up targetsAbsDir and expected subdirectories
fs.mkdirSync(targetsAbsDir);
fs.mkdirSync(path.join(targetsAbsDir, 'nested-index'));
fs.mkdirSync(path.join(targetsAbsDir, 'nested-index', 'one'));
fs.mkdirSync(path.join(targetsAbsDir, 'nested-index', 'two'));

function asynctest(testBlock, args, callback, assertBlock) {
  async_expected++;
  testBlock.apply(testBlock, args.concat(function(err) {
    let ignoreError = false;
    if (assertBlock) {
      try {
        ignoreError = assertBlock.apply(assertBlock, arguments);
      } catch (e) {
        err = e;
      }
    }
    async_completed++;
    callback(ignoreError ? null : err);
  }));
}

// sub-tests:
function test_simple_error_callback(realpath, realpathSync, cb) {
  realpath('/this/path/does/not/exist', common.mustCall(function(err, s) {
    assert(err);
    assert(!s);
    cb();
  }));
}

function test_simple_error_cb_with_null_options(realpath, realpathSync, cb) {
  realpath('/this/path/does/not/exist', null, common.mustCall(function(err, s) {
    assert(err);
    assert(!s);
    cb();
  }));
}

function test_simple_relative_symlink(realpath, realpathSync, callback) {
  console.log('test_simple_relative_symlink');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const entry = `${tmpDir}/symlink`;
  const expected = `${tmpDir}/cycles/root.js`;
  [
    [entry, `../${path.basename(tmpDir)}/cycles/root.js`],
  ].forEach(function(t) {
    try { fs.unlinkSync(t[0]); } catch {
      // Continue regardless of error.
    }
    console.log('fs.symlinkSync(%j, %j, %j)', t[1], t[0], 'file');
    fs.symlinkSync(t[1], t[0], 'file');
    unlink.push(t[0]);
  });
  const result = realpathSync(entry);
  assertEqualPath(result, path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_simple_absolute_symlink(realpath, realpathSync, callback) {
  console.log('test_simple_absolute_symlink');

  // This one should still run, even if skipSymlinks is set,
  // because it uses a junction.
  const type = skipSymlinks ? 'junction' : 'dir';

  console.log('using type=%s', type);

  const entry = `${tmpAbsDir}/symlink`;
  const expected = fixtures.path('nested-index', 'one');
  [
    [entry, expected],
  ].forEach(function(t) {
    try { fs.unlinkSync(t[0]); } catch {
      // Continue regardless of error.
    }
    console.error('fs.symlinkSync(%j, %j, %j)', t[1], t[0], type);
    fs.symlinkSync(t[1], t[0], type);
    unlink.push(t[0]);
  });
  const result = realpathSync(entry);
  assertEqualPath(result, path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_deep_relative_file_symlink(realpath, realpathSync, callback) {
  console.log('test_deep_relative_file_symlink');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }

  const expected = fixtures.path('cycles', 'root.js');
  const linkData1 = path
                      .relative(path.join(targetsAbsDir, 'nested-index', 'one'),
                                expected);
  const linkPath1 = path.join(targetsAbsDir,
                              'nested-index', 'one', 'symlink1.js');
  try { fs.unlinkSync(linkPath1); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData1, linkPath1, 'file');

  const linkData2 = '../one/symlink1.js';
  const entry = path.join(targetsAbsDir,
                          'nested-index', 'two', 'symlink1-b.js');
  try { fs.unlinkSync(entry); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData2, entry, 'file');
  unlink.push(linkPath1);
  unlink.push(entry);

  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_deep_relative_dir_symlink(realpath, realpathSync, callback) {
  console.log('test_deep_relative_dir_symlink');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const expected = fixtures.path('cycles', 'folder');
  const path1b = path.join(targetsAbsDir, 'nested-index', 'one');
  const linkPath1b = path.join(path1b, 'symlink1-dir');
  const linkData1b = path.relative(path1b, expected);
  try { fs.unlinkSync(linkPath1b); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData1b, linkPath1b, 'dir');

  const linkData2b = '../one/symlink1-dir';
  const entry = path.join(targetsAbsDir,
                          'nested-index', 'two', 'symlink12-dir');
  try { fs.unlinkSync(entry); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData2b, entry, 'dir');
  unlink.push(linkPath1b);
  unlink.push(entry);

  assertEqualPath(realpathSync(entry), path.resolve(expected));

  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_cyclic_link_protection(realpath, realpathSync, callback) {
  console.log('test_cyclic_link_protection');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const entry = path.join(tmpDir, '/cycles/realpath-3a');
  [
    [entry, '../cycles/realpath-3b'],
    [path.join(tmpDir, '/cycles/realpath-3b'), '../cycles/realpath-3c'],
    [path.join(tmpDir, '/cycles/realpath-3c'), '../cycles/realpath-3a'],
  ].forEach(function(t) {
    try { fs.unlinkSync(t[0]); } catch {
      // Continue regardless of error.
    }
    fs.symlinkSync(t[1], t[0], 'dir');
    unlink.push(t[0]);
  });
  assert.throws(() => {
    realpathSync(entry);
  }, { code: 'ELOOP', name: 'Error' });
  asynctest(
    realpath, [entry], callback, common.mustCall(function(err, result) {
      assert.strictEqual(err.path, entry);
      assert.strictEqual(result, undefined);
      return true;
    }));
}

function test_cyclic_link_overprotection(realpath, realpathSync, callback) {
  console.log('test_cyclic_link_overprotection');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const cycles = `${tmpDir}/cycles`;
  const expected = realpathSync(cycles);
  const folder = `${cycles}/folder`;
  const link = `${folder}/cycles`;
  let testPath = cycles;
  testPath += '/folder/cycles'.repeat(10);
  try { fs.unlinkSync(link); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(cycles, link, 'dir');
  unlink.push(link);
  assertEqualPath(realpathSync(testPath), path.resolve(expected));
  asynctest(realpath, [testPath], callback, function(er, res) {
    assertEqualPath(res, path.resolve(expected));
  });
}

function test_relative_input_cwd(realpath, realpathSync, callback) {
  console.log('test_relative_input_cwd');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }

  // We need to calculate the relative path to the tmp dir from cwd
  const entrydir = process.cwd();
  const entry = path.relative(entrydir,
                              path.join(`${tmpDir}/cycles/realpath-3a`));
  const expected = `${tmpDir}/cycles/root.js`;
  [
    [entry, '../cycles/realpath-3b'],
    [`${tmpDir}/cycles/realpath-3b`, '../cycles/realpath-3c'],
    [`${tmpDir}/cycles/realpath-3c`, 'root.js'],
  ].forEach(function(t) {
    const fn = t[0];
    console.error('fn=%j', fn);
    try { fs.unlinkSync(fn); } catch {
      // Continue regardless of error.
    }
    const b = path.basename(t[1]);
    const type = (b === 'root.js' ? 'file' : 'dir');
    console.log('fs.symlinkSync(%j, %j, %j)', t[1], fn, type);
    fs.symlinkSync(t[1], fn, 'file');
    unlink.push(fn);
  });

  const origcwd = process.cwd();
  process.chdir(entrydir);
  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    process.chdir(origcwd);
    assertEqualPath(result, path.resolve(expected));
    return true;
  });
}

function test_deep_symlink_mix(realpath, realpathSync, callback) {
  console.log('test_deep_symlink_mix');
  if (common.isWindows) {
    // This one is a mix of files and directories, and it's quite tricky
    // to get the file/dir links sorted out correctly.
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }

  // /tmp/node-test-realpath-f1 -> $tmpDir/node-test-realpath-d1/foo
  // /tmp/node-test-realpath-d1 -> $tmpDir/node-test-realpath-d2
  // /tmp/node-test-realpath-d2/foo -> $tmpDir/node-test-realpath-f2
  // /tmp/node-test-realpath-f2
  //   -> $tmpDir/targets/nested-index/one/realpath-c
  // $tmpDir/targets/nested-index/one/realpath-c
  //   -> $tmpDir/targets/nested-index/two/realpath-c
  // $tmpDir/targets/nested-index/two/realpath-c -> $tmpDir/cycles/root.js
  // $tmpDir/targets/cycles/root.js (hard)

  const entry = tmp('node-test-realpath-f1');
  try { fs.unlinkSync(tmp('node-test-realpath-d2/foo')); } catch {
    // Continue regardless of error.
  }
  try { fs.rmdirSync(tmp('node-test-realpath-d2')); } catch {
    // Continue regardless of error.
  }
  fs.mkdirSync(tmp('node-test-realpath-d2'), 0o700);
  try {
    [
      [entry, `${tmpDir}/node-test-realpath-d1/foo`],
      [tmp('node-test-realpath-d1'),
       `${tmpDir}/node-test-realpath-d2`],
      [tmp('node-test-realpath-d2/foo'), '../node-test-realpath-f2'],
      [tmp('node-test-realpath-f2'),
       `${targetsAbsDir}/nested-index/one/realpath-c`],
      [`${targetsAbsDir}/nested-index/one/realpath-c`,
       `${targetsAbsDir}/nested-index/two/realpath-c`],
      [`${targetsAbsDir}/nested-index/two/realpath-c`,
       `${tmpDir}/cycles/root.js`],
    ].forEach(function(t) {
      try { fs.unlinkSync(t[0]); } catch {
        // Continue regardless of error.
      }
      fs.symlinkSync(t[1], t[0]);
      unlink.push(t[0]);
    });
  } finally {
    unlink.push(tmp('node-test-realpath-d2'));
  }
  const expected = `${tmpAbsDir}/cycles/root.js`;
  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
    return true;
  });
}

function test_non_symlinks(realpath, realpathSync, callback) {
  console.log('test_non_symlinks');
  const entrydir = path.dirname(tmpAbsDir);
  const entry = `${tmpAbsDir.substr(entrydir.length + 1)}/cycles/root.js`;
  const expected = `${tmpAbsDir}/cycles/root.js`;
  const origcwd = process.cwd();
  process.chdir(entrydir);
  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    process.chdir(origcwd);
    assertEqualPath(result, path.resolve(expected));
    return true;
  });
}

const upone = path.join(process.cwd(), '..');
function test_escape_cwd(realpath, realpathSync, cb) {
  console.log('test_escape_cwd');
  asynctest(realpath, ['..'], cb, function(er, uponeActual) {
    assertEqualPath(
      upone, uponeActual,
      `realpath("".."") expected: ${path.resolve(upone)} actual:${uponeActual}`);
  });
}

function test_upone_actual(realpath, realpathSync, cb) {
  console.log('test_upone_actual');
  const uponeActual = realpathSync('..');
  assertEqualPath(upone, uponeActual);
  cb();
}

import tmpdir from '../common/tmpdir';

// Going up with .. multiple times
// .
// `-- a/
//     |-- b/
//     |   `-- e -> ..
//     `-- d -> ..
// realpath(a/b/e/d/a/b/e/d/a) ==> a
function test_up_multiple(realpath, realpathSync, cb) {
  console.error('test_up_multiple');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return cb();
  }
  
  tmpdir.refresh();
  fs.mkdirSync(tmp('a'), 0o755);
  fs.mkdirSync(tmp('a/b'), 0o755);
  fs.symlinkSync('..', tmp('a/d'), 'dir');
  unlink.push(tmp('a/d'));
  fs.symlinkSync('..', tmp('a/b/e'), 'dir');
  unlink.push(tmp('a/b/e'));

  const abedabed = tmp('abedabed'.split('').join('/'));
  const abedabed_real = tmp('');

  const abedabeda = tmp('abedabeda'.split('').join('/'));
  const abedabeda_real = tmp('a');

  assertEqualPath(realpathSync(abedabeda), abedabeda_real);
  assertEqualPath(realpathSync(abedabed), abedabed_real);

  realpath(abedabeda, function(er, real) {
    assert.ifError(er);
    assertEqualPath(abedabeda_real, real);
    realpath(abedabed, function(er, real) {
      assert.ifError(er);
      assertEqualPath(abedabed_real, real);
      cb();
    });
  });
}


// Going up with .. multiple times with options = null
// .
// `-- a/
//     |-- b/
//     |   `-- e -> ..
//     `-- d -> ..
// realpath(a/b/e/d/a/b/e/d/a) ==> a
function test_up_multiple_with_null_options(realpath, realpathSync, cb) {
  console.error('test_up_multiple');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return cb();
  }
  tmpdir.refresh();
  fs.mkdirSync(tmp('a'), 0o755);
  fs.mkdirSync(tmp('a/b'), 0o755);
  fs.symlinkSync('..', tmp('a/d'), 'dir');
  unlink.push(tmp('a/d'));
  fs.symlinkSync('..', tmp('a/b/e'), 'dir');
  unlink.push(tmp('a/b/e'));

  const abedabed = tmp('abedabed'.split('').join('/'));
  const abedabed_real = tmp('');

  const abedabeda = tmp('abedabeda'.split('').join('/'));
  const abedabeda_real = tmp('a');

  assertEqualPath(realpathSync(abedabeda), abedabeda_real);
  assertEqualPath(realpathSync(abedabed), abedabed_real);

  realpath(abedabeda, null, function(er, real) {
    assert.ifError(er);
    assertEqualPath(abedabeda_real, real);
    realpath(abedabed, null, function(er, real) {
      assert.ifError(er);
      assertEqualPath(abedabed_real, real);
      cb();
    });
  });
}

// Absolute symlinks with children.
// .
// `-- a/
//     |-- b/
//     |   `-- c/
//     |       `-- x.txt
//     `-- link -> /tmp/node-test-realpath-abs-kids/a/b/
// realpath(root+'/a/link/c/x.txt') ==> root+'/a/b/c/x.txt'
function test_abs_with_kids(realpath, realpathSync, cb) {
  console.log('test_abs_with_kids');

  // This one should still run, even if skipSymlinks is set,
  // because it uses a junction.
  const type = skipSymlinks ? 'junction' : 'dir';

  console.log('using type=%s', type);

  const root = `${tmpAbsDir}/node-test-realpath-abs-kids`;
  function cleanup() {
    ['/a/b/c/x.txt',
     '/a/link',
    ].forEach(function(file) {
      try { fs.unlinkSync(root + file); } catch {
        // Continue regardless of error.
      }
    });
    ['/a/b/c',
     '/a/b',
     '/a',
     '',
    ].forEach(function(folder) {
      try { fs.rmdirSync(root + folder); } catch {
        // Continue regardless of error.
      }
    });
  }

  function setup() {
    cleanup();
    ['',
     '/a',
     '/a/b',
     '/a/b/c',
    ].forEach(function(folder) {
      console.log(`mkdir ${root}${folder}`);
      fs.mkdirSync(root + folder, 0o700);
    });
    fs.writeFileSync(`${root}/a/b/c/x.txt`, 'foo');
    fs.symlinkSync(`${root}/a/b`, `${root}/a/link`, type);
  }
  setup();
  const linkPath = `${root}/a/link/c/x.txt`;
  const expectPath = `${root}/a/b/c/x.txt`;
  const actual = realpathSync(linkPath);
  // console.log({link:linkPath,expect:expectPath,actual:actual},'sync');
  assertEqualPath(actual, path.resolve(expectPath));
  asynctest(realpath, [linkPath], cb, function(er, actual) {
    // console.log({link:linkPath,expect:expectPath,actual:actual},'async');
    assertEqualPath(actual, path.resolve(expectPath));
    cleanup();
  });
}

function test_root(realpath, realpathSync, cb) {
  assertEqualPath(root, realpathSync('/'));
  realpath('/', function(err, result) {
    assert.ifError(err);
    assertEqualPath(root, result);
    cb();
  });
}

function test_root_with_null_options(realpath, realpathSync, cb) {
  realpath('/', null, function(err, result) {
    assert.ifError(err);
    assertEqualPath(root, result);
    cb();
  });
}

// ----------------------------------------------------------------------------

const tests = [
  test_simple_error_callback,
  test_simple_error_cb_with_null_options,
  test_simple_relative_symlink,
  test_simple_absolute_symlink,
  test_deep_relative_file_symlink,
  test_deep_relative_dir_symlink,
  test_cyclic_link_protection,
  test_cyclic_link_overprotection,
  test_relative_input_cwd,
  test_deep_symlink_mix,
  test_non_symlinks,
  test_escape_cwd,
  test_upone_actual,
  test_abs_with_kids,
  test_up_multiple,
  test_up_multiple_with_null_options,
  test_root,
  test_root_with_null_options,
];
const numtests = tests.length;
let testsRun = 0;
function runNextTest(err) {
  assert.ifError(err);
  const test = tests.shift();
  if (!test) {
    return console.log(`${numtests} subtests completed OK for fs.realpath`);
  }
  testsRun++;
  test(fs.realpath, fs.realpathSync, common.mustSucceed(() => {
    testsRun++;
    test(fs.realpath.native,
         fs.realpathSync.native,
         common.mustCall(runNextTest));
  }));
}

function runTest() {
  const tmpDirs = ['cycles', 'cycles/folder'];
  tmpDirs.forEach(function(t) {
    t = tmp(t);
    fs.mkdirSync(t, 0o700);
  });
  fs.writeFileSync(tmp('cycles/root.js'), ""console.error('roooot!');"");
  console.error('start tests');
  runNextTest();
}


process.on('exit', function() {
  assert.strictEqual(2 * numtests, testsRun);
  assert.strictEqual(async_completed, async_expected);
});

```"
"```javascript:modules\internal\crypto\random.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import { kEmptyObject } from '../util';

import { Buffer, kMaxLength, FastBuffer } from '../../buffer';

import { ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, ERR_OPERATION_FAILED } from '../errors';

import { validateNumber, validateBoolean, validateFunction, validateInt32, validateObject, validateUint32 } from '../validators';

import { isArrayBufferView, isAnyArrayBuffer, isTypedArray, isFloat32Array, isFloat64Array } from '../util/types';

import { lazyDOMException } from '../util';

import { random_fill } from ""_node:crypto"";

import process from ""process"";

const kMaxInt32 = 2 ** 31 - 1;
const kMaxPossibleLength = Math.min(kMaxLength, kMaxInt32);

function assertOffset(offset, elementSize, length) {
  validateNumber(offset, 'offset');
  offset *= elementSize;

  const maxLength = Math.min(length, kMaxPossibleLength);
  if (Number.isNaN(offset) || offset > maxLength || offset < 0) {
    throw new ERR_OUT_OF_RANGE('offset', `>= 0 && <= ${maxLength}`, offset);
  }

  return offset >>> 0;  // Convert to uint32.
}

function assertSize(size, elementSize, offset, length) {
  validateNumber(size, 'size');
  size *= elementSize;

  if (Number.isNaN(size) || size > kMaxPossibleLength || size < 0) {
    throw new ERR_OUT_OF_RANGE('size',
      `>= 0 && <= ${kMaxPossibleLength}`, size);
  }

  if (size + offset > length) {
    throw new ERR_OUT_OF_RANGE('size + offset', `<= ${length}`, size + offset);
  }

  return size >>> 0;  // Convert to uint32.
}

function randomBytes(size, callback) {
  size = assertSize(size, 1, 0, Infinity);
  if (callback !== undefined) {
    validateFunction(callback, 'callback');
  }

  const buf = new Buffer(size);

  if (callback === undefined) {
    randomFillSync(buf.buffer, 0, size);
    return buf;
  }

  // Keep the callback as a regular function so this is propagated.
  randomFill(buf.buffer, 0, size, function (error) {
    if (error) return Function.prototype.call.call(callback, this, error);
    Function.prototype.call.call(callback, this, null, buf);
  });
}

function randomFillSync(buf, offset = 0, size) {
  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {
    throw new ERR_INVALID_ARG_TYPE(
      'buf',
      ['ArrayBuffer', 'ArrayBufferView'],
      buf);
  }

  const elementSize = buf.BYTES_PER_ELEMENT || 1;

  offset = assertOffset(offset, elementSize, buf.byteLength);

  if (size === undefined) {
    size = buf.byteLength - offset;
  } else {
    size = assertSize(size, elementSize, offset, buf.byteLength);
  }

  if (size === 0)
    return buf;

  random_fill(buf.buffer ?? buf, offset + (buf.byteOffset ?? 0), size);
  return buf;
}

function randomFill(buf, offset, size, callback) {
  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {
    throw new ERR_INVALID_ARG_TYPE(
      'buf',
      ['ArrayBuffer', 'ArrayBufferView'],
      buf);
  }

  const elementSize = buf.BYTES_PER_ELEMENT || 1;

  if (typeof offset === 'function') {
    callback = offset;
    offset = 0;
    // Size is a length here, assertSize() call turns it into a number of bytes
    size = buf.length;
  } else if (typeof size === 'function') {
    callback = size;
    size = buf.length - offset;
  } else {
    validateFunction(callback, 'callback');
  }

  offset = assertOffset(offset, elementSize, buf.byteLength);

  if (size === undefined) {
    size = buf.byteLength - offset;
  } else {
    size = assertSize(size, elementSize, offset, buf.byteLength);
  }

  if (size === 0) {
    callback(null, buf);
    return;
  }

  setTimeout(() => {
    random_fill(buf.buffer ?? buf, offset + (buf.byteOffset ?? 0), size);
    callback(null, buf);
  }, 0);
}

// Largest integer we can read from a buffer.
// e.g.: Buffer.from(""ff"".repeat(6), ""hex"").readUIntBE(0, 6);
const RAND_MAX = 0xFFFF_FFFF_FFFF;

// Cache random data to use in randomInt. The cache size must be evenly
// divisible by 6 because each attempt to obtain a random int uses 6 bytes.
const randomCache = new Buffer(6 * 1024);
let randomCacheOffset = randomCache.length;
let asyncCacheFillInProgress = false;
const asyncCachePendingTasks = [];

// Generates an integer in [min, max) range where min is inclusive and max is
// exclusive.
function randomInt(min, max, callback) {
  // Detect optional min syntax
  // randomInt(max)
  // randomInt(max, callback)
  const minNotSpecified = typeof max === 'undefined' ||
    typeof max === 'function';

  if (minNotSpecified) {
    callback = max;
    max = min;
    min = 0;
  }

  const isSync = typeof callback === 'undefined';
  if (!isSync) {
    validateFunction(callback, 'callback');
  }
  if (!Number.isSafeInteger(min)) {
    throw new ERR_INVALID_ARG_TYPE('min', 'a safe integer', min);
  }
  if (!Number.isSafeInteger(max)) {
    throw new ERR_INVALID_ARG_TYPE('max', 'a safe integer', max);
  }
  if (max <= min) {
    throw new ERR_OUT_OF_RANGE(
      'max', `greater than the value of ""min"" (${min})`, max
    );
  }

  // First we generate a random int between [0..range)
  const range = max - min;

  if (!(range <= RAND_MAX)) {
    throw new ERR_OUT_OF_RANGE(`max${minNotSpecified ? '' : ' - min'}`,
      `<= ${RAND_MAX}`, range);
  }

  // For (x % range) to produce an unbiased value greater than or equal to 0 and
  // less than range, x must be drawn randomly from the set of integers greater
  // than or equal to 0 and less than randLimit.
  const randLimit = RAND_MAX - (RAND_MAX % range);

  // If we don't have a callback, or if there is still data in the cache, we can
  // do this synchronously, which is super fast.
  while (isSync || (randomCacheOffset < randomCache.length)) {
    if (randomCacheOffset === randomCache.length) {
      // This might block the thread for a bit, but we are in sync mode.
      randomFillSync(randomCache);
      randomCacheOffset = 0;
    }

    const x = randomCache.readUIntBE(randomCacheOffset, 6);
    randomCacheOffset += 6;

    if (x < randLimit) {
      const n = (x % range) + min;
      if (isSync) return n;
      process.nextTick(callback, undefined, n);
      return;
    }
  }

  // At this point, we are in async mode with no data in the cache. We cannot
  // simply refill the cache, because another async call to randomInt might
  // already be doing that. Instead, queue this call for when the cache has
  // been refilled.
  Array.prototype.push.call(asyncCachePendingTasks, { min, max, callback });
  asyncRefillRandomIntCache();
}

function asyncRefillRandomIntCache() {
  if (asyncCacheFillInProgress)
    return;

  asyncCacheFillInProgress = true;
  randomFill(randomCache, (err) => {
    asyncCacheFillInProgress = false;

    const tasks = asyncCachePendingTasks;
    const errorReceiver = err && Array.prototype.shift.call(tasks);
    if (!err)
      randomCacheOffset = 0;

    // Restart all pending tasks. If an error occurred, we only notify a single
    // callback (errorReceiver) about it. This way, every async call to
    // randomInt has a chance of being successful, and it avoids complex
    // exception handling here.
    Array.prototype.forEach.call(Array.prototype.splice.call(tasks, 0), (task) => {
      randomInt(task.min, task.max, task.callback);
    });

    // This is the only call that might throw, and is therefore done at the end.
    if (errorReceiver)
      errorReceiver.callback(err);
  });
}

// Really just the Web Crypto API alternative
// to require('crypto').randomFillSync() with an
// additional limitation that the input buffer is
// not allowed to exceed 65536 bytes, and can only
// be an integer-type TypedArray.
function getRandomValues(data) {
  if (!isTypedArray(data) ||
    isFloat32Array(data) ||
    isFloat64Array(data)) {
    // Ordinarily this would be an ERR_INVALID_ARG_TYPE. However,
    // the Web Crypto API and web platform tests expect this to
    // be a DOMException with type TypeMismatchError.
    throw lazyDOMException(
      'The data argument must be an integer-type TypedArray',
      'TypeMismatchError');
  }
  if (data.byteLength > 65536) {
    throw lazyDOMException(
      'The requested length exceeds 65,536 bytes',
      'QuotaExceededError');
  }
  randomFillSync(data, 0);
  return data;
}

// Implements an RFC 4122 version 4 random UUID.
// To improve performance, random data is generated in batches
// large enough to cover kBatchSize UUID's at a time. The uuidData
// buffer is reused. Each call to randomUUID() consumes 16 bytes
// from the buffer.

const kBatchSize = 128;
let uuidData;
let uuidNotBuffered;
let uuidBatch = 0;

let hexBytesCache;
function getHexBytes() {
  if (hexBytesCache === undefined) {
    hexBytesCache = new Array(256);
    for (let i = 0; i < hexBytesCache.length; i++) {
      const hex = Number.prototype.toString.call(i, 16);
      hexBytesCache[i] = String.prototype.padStart.call(hex, 2, '0');
    }
  }
  return hexBytesCache;
}

function serializeUUID(buf, offset = 0) {
  const kHexBytes = getHexBytes();
  // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  return kHexBytes[buf[offset]] +
    kHexBytes[buf[offset + 1]] +
    kHexBytes[buf[offset + 2]] +
    kHexBytes[buf[offset + 3]] +
    '-' +
    kHexBytes[buf[offset + 4]] +
    kHexBytes[buf[offset + 5]] +
    '-' +
    kHexBytes[(buf[offset + 6] & 0x0f) | 0x40] +
    kHexBytes[buf[offset + 7]] +
    '-' +
    kHexBytes[(buf[offset + 8] & 0x3f) | 0x80] +
    kHexBytes[buf[offset + 9]] +
    '-' +
    kHexBytes[buf[offset + 10]] +
    kHexBytes[buf[offset + 11]] +
    kHexBytes[buf[offset + 12]] +
    kHexBytes[buf[offset + 13]] +
    kHexBytes[buf[offset + 14]] +
    kHexBytes[buf[offset + 15]];
}

function getBufferedUUID() {
  // uuidData ??= secureBuffer(16 * kBatchSize);
  uuidData ??= new Uint8Array(16 * kBatchSize);
  if (uuidData === undefined)
    throw new ERR_OPERATION_FAILED('Out of memory');

  if (uuidBatch === 0) randomFillSync(uuidData);
  uuidBatch = (uuidBatch + 1) % kBatchSize;
  return serializeUUID(uuidData, uuidBatch * 16);
}

function getUnbufferedUUID() {
  // uuidNotBuffered ??= secureBuffer(16);
  uuidNotBuffered ??= new Uint8Array(16);
  if (uuidNotBuffered === undefined)
    throw new ERR_OPERATION_FAILED('Out of memory');
  randomFillSync(uuidNotBuffered);
  return serializeUUID(uuidNotBuffered);
}

function randomUUID(options) {
  if (options !== undefined)
    validateObject(options, 'options');
  const {
    disableEntropyCache = false,
  } = options || kEmptyObject;

  validateBoolean(disableEntropyCache, 'options.disableEntropyCache');

  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();
}

function generatePrime(size, options, callback) {
  validateInt32(size, 'size', 1);
  if (typeof options === 'function') {
    callback = options;
    options = kEmptyObject;
  }
  validateFunction(callback, 'callback');

  throw new Error(""crypto.generatePrime is unimplemented"");
}

function generatePrimeSync(size, options = kEmptyObject) {
  validateInt32(size, 'size', 1);

  throw new Error(""crypto.generatePrimeSync is unimplemented"");

}

function unsignedBigIntToBuffer(bigint, name) {
  if (bigint < 0) {
    throw new ERR_OUT_OF_RANGE(name, '>= 0', bigint);
  }

  const hex = bigint.toString(16);
  const padded = hex.padStart(hex.length + (hex.length % 2), 0);
  return Buffer.from(padded, 'hex');
}

function checkPrime(candidate, options = kEmptyObject, callback) {
  if (typeof candidate === 'bigint')
    candidate = unsignedBigIntToBuffer(candidate, 'candidate');
  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {
    throw new ERR_INVALID_ARG_TYPE(
      'candidate',
      [
        'ArrayBuffer',
        'TypedArray',
        'Buffer',
        'DataView',
        'bigint',
      ],
      candidate
    );
  }
  if (typeof options === 'function') {
    callback = options;
    options = kEmptyObject;
  }
  validateFunction(callback, 'callback');
  validateObject(options, 'options');
  const {
    checks = 0,
  } = options;

  validateUint32(checks, 'options.checks');

  throw new Error(""crypto.checkPrime is unimplemented"");

}

function checkPrimeSync(candidate, options = kEmptyObject) {
  if (typeof candidate === 'bigint')
    candidate = unsignedBigIntToBuffer(candidate, 'candidate');
  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {
    throw new ERR_INVALID_ARG_TYPE(
      'candidate',
      [
        'ArrayBuffer',
        'TypedArray',
        'Buffer',
        'DataView',
        'bigint',
      ],
      candidate
    );
  }
  validateObject(options, 'options');
  const {
    checks = 0,
  } = options;

  validateUint32(checks, 'options.checks');

  throw new Error(""crypto.checkPrimeSync is unimplemented"");
}

export {
  checkPrime,
  checkPrimeSync,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  getRandomValues,
  randomUUID,
  generatePrime,
  generatePrimeSync,
}

export default {
  checkPrime,
  checkPrimeSync,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  getRandomValues,
  randomUUID,
  generatePrime,
  generatePrimeSync,
};

```"
"```javascript:test\crypto\test-crypto-random.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Flags: --pending-deprecation
'use strict';
import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';
// const cryptop = require('crypto').webcrypto;
import { kMaxLength } from 'buffer';

const kMaxInt32 = 2 ** 31 - 1;
const kMaxPossibleLength = Math.min(kMaxLength, kMaxInt32);

common.expectWarning('DeprecationWarning',
                     'crypto.pseudoRandomBytes is deprecated.', 'DEP0115');

{
  [crypto.randomBytes/*, crypto.pseudoRandomBytes*/].forEach((f) => {
    [undefined, null, false, true, {}, []].forEach((value) => {
      const errObj = {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""size"" argument must be of type number.' +
                 common.invalidArgTypeHelper(value)
      };
      assert.throws(() => f(value), errObj);
      assert.throws(() => f(value, common.mustNotCall()), errObj);
    });

    [-1, NaN, 2 ** 32, 2 ** 31].forEach((value) => {
      const errObj = {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""size"" is out of range. It must be >= 0 && <= ' +
                 `${kMaxPossibleLength}. Received ${value}`
      };
      assert.throws(() => f(value), errObj);
      assert.throws(() => f(value, common.mustNotCall()), errObj);
    });

    [0, 1, 2, 4, 16, 256, 1024, 101.2].forEach((len) => {
      f(len, common.mustCall((ex, buf) => {
        assert.strictEqual(ex, null);
        assert.strictEqual(buf.length, Math.floor(len));
        assert.ok(Buffer.isBuffer(buf));
      }));
    });
  });
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  const after = crypto.randomFillSync(buf).toString('hex');
  assert.notStrictEqual(before, after);
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFillSync(buf);
  const after = Buffer.from(buf).toString('hex');
  assert.notStrictEqual(before, after);
}

{
  [
    new Uint16Array(10),
    new Uint32Array(10),
    new Float32Array(10),
    new Float64Array(10),
    new DataView(new ArrayBuffer(10)),
  ].forEach((buf) => {
    const before = Buffer.from(buf.buffer).toString('hex');
    crypto.randomFillSync(buf);
    const after = Buffer.from(buf.buffer).toString('hex');
    assert.notStrictEqual(before, after);
  });
}

/*{
  [
    new Uint16Array(10),
    new Uint32Array(10),
  ].forEach((buf) => {
    const before = Buffer.from(buf.buffer).toString('hex');
    cryptop.getRandomValues(buf);
    const after = Buffer.from(buf.buffer).toString('hex');
    assert.notStrictEqual(before, after);
  });
}*/

{
  [
    new ArrayBuffer(10),
    new SharedArrayBuffer(10),
  ].forEach((buf) => {
    const before = Buffer.from(buf).toString('hex');
    crypto.randomFillSync(buf);
    const after = Buffer.from(buf).toString('hex');
    assert.notStrictEqual(before, after);
  });
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFill(buf, common.mustSucceed((buf) => {
    const after = buf.toString('hex');
    assert.notStrictEqual(before, after);
  }));
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFill(buf, common.mustSucceed((buf) => {
    const after = Buffer.from(buf).toString('hex');
    assert.notStrictEqual(before, after);
  }));
}

{
  [
    new Uint16Array(10),
    new Uint32Array(10),
    new Float32Array(10),
    new Float64Array(10),
    new DataView(new ArrayBuffer(10)),
  ].forEach((buf) => {
    const before = Buffer.from(buf.buffer).toString('hex');
    crypto.randomFill(buf, common.mustSucceed((buf) => {
      const after = Buffer.from(buf.buffer).toString('hex');
      assert.notStrictEqual(before, after);
    }));
  });
}

{
  [
    new ArrayBuffer(10),
    new SharedArrayBuffer(10),
  ].forEach((buf) => {
    const before = Buffer.from(buf).toString('hex');
    crypto.randomFill(buf, common.mustSucceed((buf) => {
      const after = Buffer.from(buf).toString('hex');
      assert.notStrictEqual(before, after);
    }));
  });
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFillSync(buf, 5, 5);
  const after = buf.toString('hex');
  assert.notStrictEqual(before, after);
  assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFillSync(buf, 5, 5);
  const after = Buffer.from(buf).toString('hex');
  assert.notStrictEqual(before, after);
  assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFillSync(buf, 5);
  const after = buf.toString('hex');
  assert.notStrictEqual(before, after);
  assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFill(buf, 5, 5, common.mustSucceed((buf) => {
    const after = buf.toString('hex');
    assert.notStrictEqual(before, after);
    assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
  }));
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFill(buf, 5, 5, common.mustSucceed((buf) => {
    const after = Buffer.from(buf).toString('hex');
    assert.notStrictEqual(before, after);
    assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
  }));
}

{
  [
    Buffer.alloc(10),
    new Uint8Array(new Array(10).fill(0)),
  ].forEach((buf) => {
    const len = Buffer.byteLength(buf);
    assert.strictEqual(len, 10, `Expected byteLength of 10, got ${len}`);

    const typeErrObj = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""offset"" argument must be of type number. ' +
               ""Received type string ('test')""
    };

    assert.throws(() => crypto.randomFillSync(buf, 'test'), typeErrObj);

    assert.throws(
      () => crypto.randomFill(buf, 'test', common.mustNotCall()),
      typeErrObj);

    typeErrObj.message = typeErrObj.message.replace('offset', 'size');
    assert.throws(() => crypto.randomFillSync(buf, 0, 'test'), typeErrObj);

    assert.throws(
      () => crypto.randomFill(buf, 0, 'test', common.mustNotCall()),
      typeErrObj
    );

    [NaN, kMaxPossibleLength + 1, -10, (-1 >>> 0) + 1].forEach((offsetSize) => {
      const errObj = {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""offset"" is out of range. ' +
                 `It must be >= 0 && <= 10. Received ${offsetSize}`
      };

      assert.throws(() => crypto.randomFillSync(buf, offsetSize), errObj);

      assert.throws(
        () => crypto.randomFill(buf, offsetSize, common.mustNotCall()),
        errObj);

      errObj.message = 'The value of ""size"" is out of range. It must be >= ' +
                       `0 && <= ${kMaxPossibleLength}. Received ${offsetSize}`;
      assert.throws(() => crypto.randomFillSync(buf, 1, offsetSize), errObj);

      assert.throws(
        () => crypto.randomFill(buf, 1, offsetSize, common.mustNotCall()),
        errObj
      );
    });

    const rangeErrObj = {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""size + offset"" is out of range. ' +
               'It must be <= 10. Received 11'
    };
    assert.throws(() => crypto.randomFillSync(buf, 1, 10), rangeErrObj);

    assert.throws(
      () => crypto.randomFill(buf, 1, 10, common.mustNotCall()),
      rangeErrObj
    );
  });
}

// https://github.com/nodejs/node-v0.x-archive/issues/5126,
// ""FATAL ERROR: v8::Object::SetIndexedPropertiesToExternalArrayData() length
// exceeds max acceptable value""
assert.throws(
  () => crypto.randomBytes((-1 >>> 0) + 1),
  {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""size"" is out of range. ' +
             `It must be >= 0 && <= ${kMaxPossibleLength}. Received 4294967296`
  }
);

[1, true, NaN, null, undefined, {}, []].forEach((i) => {
  const buf = Buffer.alloc(10);
  assert.throws(
    () => crypto.randomFillSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => crypto.randomFill(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => crypto.randomFill(buf, 0, 10, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
});

[1, true, NaN, null, {}, []].forEach((i) => {
  assert.throws(
    () => crypto.randomBytes(1, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );
});

/*['pseudoRandomBytes', 'prng', 'rng'].forEach((f) => {
  const desc = Object.getOwnPropertyDescriptor(crypto, f);
  assert.ok(desc);
  assert.strictEqual(desc.configurable, true);
  assert.strictEqual(desc.enumerable, false);
});*/


{
  // Asynchronous API
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    crypto.randomInt(3, common.mustSucceed((n) => {
      assert.ok(n >= 0);
      assert.ok(n < 3);
      randomInts.push(n);
      if (randomInts.length === 100) {
        assert.ok(!randomInts.includes(-1));
        assert.ok(randomInts.includes(0));
        assert.ok(randomInts.includes(1));
        assert.ok(randomInts.includes(2));
        assert.ok(!randomInts.includes(3));
      }
    }));
  }
}
{
  // Synchronous API
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    const n = crypto.randomInt(3);
    assert.ok(n >= 0);
    assert.ok(n < 3);
    randomInts.push(n);
  }

  assert.ok(!randomInts.includes(-1));
  assert.ok(randomInts.includes(0));
  assert.ok(randomInts.includes(1));
  assert.ok(randomInts.includes(2));
  assert.ok(!randomInts.includes(3));
}
{
  // Positive range
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    crypto.randomInt(1, 3, common.mustSucceed((n) => {
      assert.ok(n >= 1);
      assert.ok(n < 3);
      randomInts.push(n);
      if (randomInts.length === 100) {
        assert.ok(!randomInts.includes(0));
        assert.ok(randomInts.includes(1));
        assert.ok(randomInts.includes(2));
        assert.ok(!randomInts.includes(3));
      }
    }));
  }
}
{
  // Negative range
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    crypto.randomInt(-10, -8, common.mustSucceed((n) => {
      assert.ok(n >= -10);
      assert.ok(n < -8);
      randomInts.push(n);
      if (randomInts.length === 100) {
        assert.ok(!randomInts.includes(-11));
        assert.ok(randomInts.includes(-10));
        assert.ok(randomInts.includes(-9));
        assert.ok(!randomInts.includes(-8));
      }
    }));
  }
}
{

  ['10', true, NaN, null, {}, []].forEach((i) => {
    const invalidMinError = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""min"" argument must be a safe integer.' +
               `${common.invalidArgTypeHelper(i)}`,
    };
    const invalidMaxError = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""max"" argument must be a safe integer.' +
               `${common.invalidArgTypeHelper(i)}`,
    };

    assert.throws(
      () => crypto.randomInt(i, 100),
      invalidMinError
    );
    assert.throws(
      () => crypto.randomInt(i, 100, common.mustNotCall()),
      invalidMinError
    );
    assert.throws(
      () => crypto.randomInt(i),
      invalidMaxError
    );
    assert.throws(
      () => crypto.randomInt(i, common.mustNotCall()),
      invalidMaxError
    );
    assert.throws(
      () => crypto.randomInt(0, i, common.mustNotCall()),
      invalidMaxError
    );
    assert.throws(
      () => crypto.randomInt(0, i),
      invalidMaxError
    );
  });

  const maxInt = Number.MAX_SAFE_INTEGER;
  const minInt = Number.MIN_SAFE_INTEGER;

  crypto.randomInt(minInt, minInt + 5, common.mustSucceed());
  crypto.randomInt(maxInt - 5, maxInt, common.mustSucceed());

  assert.throws(
    () => crypto.randomInt(minInt - 1, minInt + 5, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""min"" argument must be a safe integer.' +
      `${common.invalidArgTypeHelper(minInt - 1)}`,
    }
  );

  assert.throws(
    () => crypto.randomInt(maxInt + 1, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""max"" argument must be a safe integer.' +
      `${common.invalidArgTypeHelper(maxInt + 1)}`,
    }
  );

  crypto.randomInt(1, common.mustSucceed());
  crypto.randomInt(0, 1, common.mustSucceed());
  for (const arg of [[0], [1, 1], [3, 2], [-5, -5], [11, -10]]) {
    assert.throws(() => crypto.randomInt(...arg, common.mustNotCall()), {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""max"" is out of range. It must be greater than ' +
      `the value of ""min"" (${arg[arg.length - 2] || 0}). ` +
      `Received ${arg[arg.length - 1]}`
    });
  }

  const MAX_RANGE = 0xFFFF_FFFF_FFFF;
  crypto.randomInt(MAX_RANGE, common.mustSucceed());
  crypto.randomInt(1, MAX_RANGE + 1, common.mustSucceed());
  assert.throws(
    () => crypto.randomInt(1, MAX_RANGE + 2, common.mustNotCall()),
    {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""max - min"" is out of range. ' +
               `It must be <= ${MAX_RANGE}. ` +
               'Received 281_474_976_710_656'
    }
  );

  assert.throws(() => crypto.randomInt(MAX_RANGE + 1, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""max"" is out of range. ' +
             `It must be <= ${MAX_RANGE}. ` +
             'Received 281_474_976_710_656'
  });

  [true, NaN, null, {}, [], 10].forEach((i) => {
    const cbError = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    };
    assert.throws(() => crypto.randomInt(0, 1, i), cbError);
  });
}

{
  // Verify that it doesn't throw or abort
  crypto.randomFill(new Uint16Array(10), 0, common.mustSucceed());
  crypto.randomFill(new Uint32Array(10), 0, common.mustSucceed());
  crypto.randomFill(new Uint32Array(10), 0, 1, common.mustSucceed());
}

```"
"```javascript:test\fs\test-fs-rm.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import { pathToFileURL } from 'url';
// import { execSync } from 'child_process';

import { validateRmOptionsSync } from 'internal/fs/utils';

tmpdir.refresh();

let count = 0;
const nextDirPath = (name = 'rm') =>
  path.join(tmpdir.path, `${name}-${count++}`);

const isGitPresent = (() => {
  // try { execSync('git --version'); return true; } catch { return false; }
  return false;
})();

/*function gitInit(gitDirectory) {
  fs.mkdirSync(gitDirectory);
  execSync('git init', common.mustNotMutateObjectDeep({ cwd: gitDirectory }));
}*/

function makeNonEmptyDirectory(depth, files, folders, dirname, createSymLinks) {
  fs.mkdirSync(dirname, common.mustNotMutateObjectDeep({ recursive: true }));
  fs.writeFileSync(path.join(dirname, 'text.txt'), 'hello', 'utf8');

  const options = common.mustNotMutateObjectDeep({ flag: 'wx' });

  for (let f = files; f > 0; f--) {
    fs.writeFileSync(path.join(dirname, `f-${depth}-${f}`), '', options);
  }

  if (createSymLinks) {
    // Valid symlink
    fs.symlinkSync(
      `f-${depth}-1`,
      path.join(dirname, `link-${depth}-good`),
      'file'
    );

    // Invalid symlink
    fs.symlinkSync(
      'does-not-exist',
      path.join(dirname, `link-${depth}-bad`),
      'file'
    );
  }

  // File with a name that looks like a glob
  fs.writeFileSync(path.join(dirname, '[a-z0-9].txt'), '', options);

  depth--;
  if (depth <= 0) {
    return;
  }

  for (let f = folders; f > 0; f--) {
    fs.mkdirSync(
      path.join(dirname, `folder-${depth}-${f}`),
      { recursive: true }
    );
    makeNonEmptyDirectory(
      depth,
      files,
      folders,
      path.join(dirname, `d-${depth}-${f}`),
      createSymLinks
    );
  }
}

function removeAsync(dir) {
  // Removal should fail without the recursive option.
  fs.rm(dir, common.mustCall((err) => {
    assert.strictEqual(err.syscall, 'rm');

    // Removal should fail without the recursive option set to true.
    fs.rm(dir, common.mustNotMutateObjectDeep({ recursive: false }), common.mustCall((err) => {
      assert.strictEqual(err.syscall, 'rm');

      // Recursive removal should succeed.
      fs.rm(dir, common.mustNotMutateObjectDeep({ recursive: true }), common.mustSucceed(() => {

        // Attempted removal should fail now because the directory is gone.
        fs.rm(dir, common.mustCall((err) => {
          assert.strictEqual(err.syscall, 'rm');
          // assert.strictEqual(err.syscall, 'stat'); nodejs doc api not indicate the implement ways.
        }));
      }));
    }));
  }));
}

// Test the asynchronous version
{
  // Create a 4-level folder hierarchy including symlinks
  let dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  removeAsync(dir);

  // Create a 2-level folder hierarchy without symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(dir);

  // Same test using URL instead of a path
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(pathToFileURL(dir));

  // Create a flat folder including symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(1, 10, 2, dir, true);
  removeAsync(dir);

  // Should fail if target does not exist
  fs.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    common.mustNotMutateObjectDeep({ recursive: true }),
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
    })
  );

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-async-file.txt');
  fs.writeFileSync(filePath, '');
  fs.rm(filePath, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall((err) => {
    try {
      assert.strictEqual(err, null);
      assert.strictEqual(fs.existsSync(filePath), false);
    } finally {
      fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
    }
  }));
}

// Removing a .git directory should not throw an EPERM.
// Refs: https://github.com/isaacs/rimraf/issues/21.
if (isGitPresent) {
  const gitDirectory = nextDirPath();
  gitInit(gitDirectory);
  fs.rm(gitDirectory, common.mustNotMutateObjectDeep({ recursive: true }), common.mustSucceed(() => {
    assert.strictEqual(fs.existsSync(gitDirectory), false);
  }));
}

// Test the synchronous version.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  assert.throws(() => {
    fs.rmSync(dir);
  }, { syscall: 'rm' });
  assert.throws(() => {
    fs.rmSync(dir, common.mustNotMutateObjectDeep({ recursive: false }));
  }, { syscall: 'rm' });

  // Should fail if target does not exist
  assert.throws(() => {
    fs.rmSync(path.join(tmpdir.path, 'noexist.txt'), common.mustNotMutateObjectDeep({ recursive: true }));
  }, {
    code: 'ENOENT',
    name: 'Error',
    // message: /^ENOENT: no such file or directory, stat/
    message: /^ENOENT: no such file or directory, rm/
  });

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-file.txt');
  fs.writeFileSync(filePath, '');

  try {
    fs.rmSync(filePath, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
  }

  // Should accept URL
  const fileURL = pathToFileURL(path.join(tmpdir.path, 'rm-file.txt'));
  fs.writeFileSync(fileURL, '');

  try {
    fs.rmSync(fileURL, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(fileURL, common.mustNotMutateObjectDeep({ force: true }));
  }

  // Recursive removal should succeed.
  fs.rmSync(dir, { recursive: true });

  // Attempted removal should fail now because the directory is gone.
  // assert.throws(() => fs.rmSync(dir), { syscall: 'stat' });
  assert.throws(() => fs.rmSync(dir), { syscall: 'rm' });
}

// Removing a .git directory should not throw an EPERM.
// Refs: https://github.com/isaacs/rimraf/issues/21.
if (isGitPresent) {
  const gitDirectory = nextDirPath();
  gitInit(gitDirectory);
  fs.rmSync(gitDirectory, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(gitDirectory), false);
}

// Test the Promises based version.
(async () => {
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  await assert.rejects(fs.promises.rm(dir), { syscall: 'rm' });
  await assert.rejects(fs.promises.rm(dir, common.mustNotMutateObjectDeep({ recursive: false })), {
    syscall: 'rm'
  });

  // Recursive removal should succeed.
  await fs.promises.rm(dir, common.mustNotMutateObjectDeep({ recursive: true }));

  // Attempted removal should fail now because the directory is gone.
  // await assert.rejects(fs.promises.rm(dir), { syscall: 'stat' });
  await assert.rejects(fs.promises.rm(dir), { syscall: 'rm' });

  // Should fail if target does not exist
  await assert.rejects(fs.promises.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true }
  ), {
    code: 'ENOENT',
    name: 'Error',
    message: /^ENOENT: no such file or directory, rm/
    // message: /^ENOENT: no such file or directory, stat/
  });

  // Should not fail if target does not exist and force option is true
  await fs.promises.rm(path.join(tmpdir.path, 'noexist.txt'), common.mustNotMutateObjectDeep({ force: true }));

  // Should delete file
  const filePath = path.join(tmpdir.path, 'rm-promises-file.txt');
  fs.writeFileSync(filePath, '');

  try {
    await fs.promises.rm(filePath, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
  }

  // Should accept URL
  const fileURL = pathToFileURL(path.join(tmpdir.path, 'rm-promises-file.txt'));
  fs.writeFileSync(fileURL, '');

  try {
    await fs.promises.rm(fileURL, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(fileURL, common.mustNotMutateObjectDeep({ force: true }));
  }
})().then(common.mustCall());

// Removing a .git directory should not throw an EPERM.
// Refs: https://github.com/isaacs/rimraf/issues/21.
if (isGitPresent) {
  (async () => {
    const gitDirectory = nextDirPath();
    gitInit(gitDirectory);
    await fs.promises.rm(gitDirectory, common.mustNotMutateObjectDeep({ recursive: true }));
    assert.strictEqual(fs.existsSync(gitDirectory), false);
  })().then(common.mustCall());
}

// Test input validation.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  const filePath = (path.join(tmpdir.path, 'rm-args-file.txt'));
  fs.writeFileSync(filePath, '');

  const defaults = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false,
    force: false
  };
  const modified = {
    retryDelay: 953,
    maxRetries: 5,
    recursive: true,
    force: false
  };

  assert.deepStrictEqual(validateRmOptionsSync(filePath), defaults);
  assert.deepStrictEqual(validateRmOptionsSync(filePath, {}), defaults);
  assert.deepStrictEqual(validateRmOptionsSync(filePath, modified), modified);
  assert.deepStrictEqual(validateRmOptionsSync(filePath, {
    maxRetries: 99
  }), {
    retryDelay: 100,
    maxRetries: 99,
    recursive: false,
    force: false
  });

  [null, 'foo', 5, NaN].forEach((bad) => {
    assert.throws(() => {
      validateRmOptionsSync(filePath, bad);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options"" argument must be of type object\./
    });
  });

  [undefined, null, 'foo', Infinity, function() {}].forEach((bad) => {
    assert.throws(() => {
      validateRmOptionsSync(filePath, { recursive: bad });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options\.recursive"" property must be of type boolean\./
    });
  });

  [undefined, null, 'foo', Infinity, function() {}].forEach((bad) => {
    assert.throws(() => {
      validateRmOptionsSync(filePath, { force: bad });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options\.force"" property must be of type boolean\./
    });
  });

  assert.throws(() => {
    validateRmOptionsSync(filePath, { retryDelay: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.retryDelay"" is out of range\./
  });

  assert.throws(() => {
    validateRmOptionsSync(filePath, { maxRetries: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.maxRetries"" is out of range\./
  });
}

// unsupport for chmod
/*{
  // IBMi has a different access permission mechanism
  // This test should not be run as `root`
  if (!common.isIBMi && (common.isWindows || process.getuid() !== 0)) {
    function makeDirectoryReadOnly(dir, mode) {
      let accessErrorCode = 'EACCES';
      if (common.isWindows) {
        accessErrorCode = 'EPERM';
        execSync(`icacls ${dir} /deny ""everyone:(OI)(CI)(DE,DC)""`);
      } else {
        fs.chmodSync(dir, mode);
      }
      return accessErrorCode;
    }

    function makeDirectoryWritable(dir) {
      if (fs.existsSync(dir)) {
        if (common.isWindows) {
          execSync(`icacls ${dir} /remove:d ""everyone""`);
        } else {
          fs.chmodSync(dir, 0o777);
        }
      }
    }

    {
      // Check that deleting a file that cannot be accessed using rmsync throws
      // https://github.com/nodejs/node/issues/38683
      const dirname = nextDirPath();
      const filePath = path.join(dirname, 'text.txt');
      try {
        fs.mkdirSync(dirname, common.mustNotMutateObjectDeep({ recursive: true }));
        fs.writeFileSync(filePath, 'hello');
        const code = makeDirectoryReadOnly(dirname, 0o444);
        assert.throws(() => {
          fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
        }, {
          code,
          name: 'Error',
        });
      } finally {
        makeDirectoryWritable(dirname);
      }
    }

    {
      // Check endless recursion.
      // https://github.com/nodejs/node/issues/34580
      const dirname = nextDirPath();
      fs.mkdirSync(dirname, common.mustNotMutateObjectDeep({ recursive: true }));
      const root = fs.mkdtempSync(path.join(dirname, 'fs-'));
      const middle = path.join(root, 'middle');
      fs.mkdirSync(middle);
      fs.mkdirSync(path.join(middle, 'leaf')); // Make `middle` non-empty
      try {
        const code = makeDirectoryReadOnly(middle, 0o555);
        try {
          assert.throws(() => {
            fs.rmSync(root, common.mustNotMutateObjectDeep({ recursive: true }));
          }, {
            code,
            name: 'Error',
          });
        } catch (err) {
          // Only fail the test if the folder was not deleted.
          // as in some cases rmSync succesfully deletes read-only folders.
          if (fs.existsSync(root)) {
            throw err;
          }
        }
      } finally {
        makeDirectoryWritable(middle);
      }
    }
  }
}*/

```"
"```javascript:modules\internal\fs\cp\cp.js
// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

'use strict';

// This file is a modified version of the fs-extra's copy method.

import * as errors from ""../../errors""
import { os } from ""../../../internal_binding/constants"";

const {
  ERR_FS_CP_DIR_TO_NON_DIR,
  ERR_FS_CP_EEXIST,
  ERR_FS_CP_EINVAL,
  ERR_FS_CP_FIFO_PIPE,
  ERR_FS_CP_NON_DIR_TO_DIR,
  ERR_FS_CP_SOCKET,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
  ERR_FS_CP_UNKNOWN,
  ERR_FS_EISDIR,
} = errors;
const {
  errno: {
    EEXIST,
    EISDIR,
    EINVAL,
    ENOTDIR,
  }
} = os;
import {
  chmod,
  copyFile,
  lstat,
  mkdir,
  opendir,
  readlink,
  stat,
  symlink,
  unlink,
  utimes,
} from ""fs/promises"";
import {
  dirname,
  isAbsolute,
  join,
  parse,
  resolve,
  sep,
} from ""path"";

import process from ""process"";

async function cpFn(src, dest, opts) {
  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    const warning = 'Using the preserveTimestamps option in 32-bit ' +
      'node is not recommended';
    process.emitWarning(warning, 'TimestampPrecisionWarning');
  }
  const stats = await checkPaths(src, dest, opts);
  const { srcStat, destStat } = stats;
  await checkParentPaths(src, srcStat, dest);
  if (opts.filter) {
    return handleFilter(checkParentDir, destStat, src, dest, opts);
  }
  return checkParentDir(destStat, src, dest, opts);
}

async function checkPaths(src, dest, opts) {
  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts);
  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL({
        message: 'src and dest cannot be the same',
        path: dest,
        syscall: 'cp',
        errno: EINVAL,
        code: 'EINVAL',
      });
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new ERR_FS_CP_DIR_TO_NON_DIR({
        message: `cannot overwrite directory ${src} ` +
          `with non-directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: EISDIR,
        code: 'EISDIR',
      });
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new ERR_FS_CP_NON_DIR_TO_DIR({
        message: `cannot overwrite non-directory ${src} ` +
          `with directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: ENOTDIR,
        code: 'ENOTDIR',
      });
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return { srcStat, destStat };
}

function areIdentical(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino &&
    destStat.dev === srcStat.dev;
}

function getStats(src, dest, opts) {
  const statFunc = opts.dereference ?
    (file) => stat(file, { bigint: true }) :
    (file) => lstat(file, { bigint: true });
  return Promise.all([
    statFunc(src),
    Promise.prototype.then.call(statFunc(dest), undefined, (err) => {
      if (err.code === 'ENOENT') return null;
      throw err;
    }),
  ]);
}

async function checkParentDir(destStat, src, dest, opts) {
  const destParent = dirname(dest);
  const dirExists = await pathExists(destParent);
  if (dirExists) return getStatsForCopy(destStat, src, dest, opts);
  await mkdir(destParent, { recursive: true });
  return getStatsForCopy(destStat, src, dest, opts);
}

function pathExists(dest) {
  return Promise.prototype.then.call(
    stat(dest),
    () => true,
    (err) => (err.code === 'ENOENT' ? false : PromiseReject(err)));
}

// Recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
async function checkParentPaths(src, srcStat, dest) {
  const srcParent = resolve(dirname(src));
  const destParent = resolve(dirname(dest));
  if (destParent === srcParent || destParent === parse(destParent).root || destParent === ""."") {
    return;
  }
  let destStat;
  try {
    destStat = await stat(destParent, { bigint: true });
  } catch (err) {
    if (err.code === 'ENOENT') return;
    throw err;
  }
  if (areIdentical(srcStat, destStat)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return checkParentPaths(src, srcStat, destParent);
}

const normalizePathToArray = (path) =>
  Array.prototype.filter.call(String.prototype.split.call(resolve(path), sep), Boolean);

// Return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir(src, dest) {
  const srcArr = normalizePathToArray(src);
  const destArr = normalizePathToArray(dest);
  return Array.prototype.every.call(srcArr, (cur, i) => destArr[i] === cur);
}

async function handleFilter(onInclude, destStat, src, dest, opts, cb) {
  const include = await opts.filter(src, dest);
  if (include) return onInclude(destStat, src, dest, opts, cb);
}

function startCopy(destStat, src, dest, opts) {
  if (opts.filter) {
    return handleFilter(getStatsForCopy, destStat, src, dest, opts);
  }
  return getStatsForCopy(destStat, src, dest, opts);
}

async function getStatsForCopy(destStat, src, dest, opts) {
  const statFn = opts.dereference ? stat : lstat;
  const srcStat = await statFn(src);
  if (srcStat.isDirectory() && opts.recursive) {
    return onDir(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isDirectory()) {
    throw new ERR_FS_EISDIR({
      message: `${src} is a directory (not copied)`,
      path: src,
      syscall: 'cp',
      errno: EISDIR,
      code: 'EISDIR',
    });
  } else if (srcStat.isFile() ||
    srcStat.isCharacterDevice() ||
    srcStat.isBlockDevice()) {
    return onFile(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isSymbolicLink()) {
    return onLink(destStat, src, dest, opts);
  } else if (srcStat.isSocket()) {
    throw new ERR_FS_CP_SOCKET({
      message: `cannot copy a socket file: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  } else if (srcStat.isFIFO()) {
    throw new ERR_FS_CP_FIFO_PIPE({
      message: `cannot copy a FIFO pipe: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  throw new ERR_FS_CP_UNKNOWN({
    message: `cannot copy an unknown file type: ${dest}`,
    path: dest,
    syscall: 'cp',
    errno: EINVAL,
    code: 'EINVAL',
  });
}

function onFile(srcStat, destStat, src, dest, opts) {
  if (!destStat) return _copyFile(srcStat, src, dest, opts);
  return mayCopyFile(srcStat, src, dest, opts);
}

async function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.force) {
    await unlink(dest);
    return _copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new ERR_FS_CP_EEXIST({
      message: `${dest} already exists`,
      path: dest,
      syscall: 'cp',
      errno: EEXIST,
      code: 'EEXIST',
    });
  }
}

async function _copyFile(srcStat, src, dest, opts) {
  await copyFile(src, dest);
  if (opts.preserveTimestamps) {
    return handleTimestampsAndMode(srcStat.mode, src, dest);
  }
  return setDestMode(dest, srcStat.mode);
}

async function handleTimestampsAndMode(srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) {
    await makeFileWritable(dest, srcMode);
    return setDestTimestampsAndMode(srcMode, src, dest);
  }
  return setDestTimestampsAndMode(srcMode, src, dest);
}

function fileIsNotWritable(srcMode) {
  return (srcMode & 0o200) === 0;
}

function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200);
}

async function setDestTimestampsAndMode(srcMode, src, dest) {
  await setDestTimestamps(src, dest);
  return setDestMode(dest, srcMode);
}

function setDestMode(dest, srcMode) {
  return chmod(dest, srcMode);
}

async function setDestTimestamps(src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = await stat(src);
  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}

function onDir(srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
  return copyDir(src, dest, opts);
}

async function mkDirAndCopy(srcMode, src, dest, opts) {
  await mkdir(dest);
  await copyDir(src, dest, opts);
  return setDestMode(dest, srcMode);
}

async function copyDir(src, dest, opts) {
  const dir = await opendir(src);

  for await (const { name } of dir) {
    const srcItem = join(src, name);
    const destItem = join(dest, name);
    const { destStat } = await checkPaths(srcItem, destItem, opts);
    await startCopy(destStat, srcItem, destItem, opts);
  }
}

async function onLink(destStat, src, dest, opts) {
  let resolvedSrc = await readlink(src);
  if (!opts.verbatimSymlinks && !isAbsolute(resolvedSrc)) {
    resolvedSrc = resolve(dirname(src), resolvedSrc);
  }
  if (!destStat) {
    return symlink(resolvedSrc, dest);
  }
  let resolvedDest;
  try {
    resolvedDest = await readlink(dest);
  } catch (err) {
    // Dest exists and is a regular file or directory,
    // Windows may throw UNKNOWN error. If dest already exists,
    // fs throws error anyway, so no need to guard against it here.
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {
      return symlink(resolvedSrc, dest);
    }
    throw err;
  }
  if (!isAbsolute(resolvedDest)) {
    resolvedDest = resolve(dirname(dest), resolvedDest);
  }
  if (isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +
        `${resolvedDest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  // Do not copy if src is a subdir of dest since unlinking
  // dest in this case would result in removing src contents
  // and therefore a broken symlink would be created.
  const srcStat = await stat(src);
  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return copyLink(resolvedSrc, dest);
}

async function copyLink(resolvedSrc, dest) {
  await unlink(dest);
  return symlink(resolvedSrc, dest);
}

export {
  areIdentical,
  cpFn,
  isSrcSubdir,
};

```"
"```javascript:test\fs\test-fs-promises.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
import fixtures from '../common/fixtures';
import path from 'path';
import fs from 'fs';
const fsPromises = fs.promises;
const {
  access,
  //chmod,
  //chown,
  copyFile,
  //lchown,
  link,
  //lchmod,
  lstat,
  lutimes,
  mkdir,
  mkdtemp,
  open,
  readFile,
  readdir,
  //readlink,
  //realpath,
  rename,
  rmdir,
  stat,
  symlink,
  truncate,
  unlink,
  utimes,
  writeFile
} = fsPromises;

const tmpDir = tmpdir.path;

let dirc = 0;
function nextdir() {
  return `test${++dirc}`;
}

const __filename = args[0];

// fs.promises should be enumerable.
assert.strictEqual(
  Object.prototype.propertyIsEnumerable.call(fs, 'promises'),
  true
);

{
  access(__filename, 0)
    .then(common.mustCall());

  assert.rejects(
    access('this file does not exist', 0),
    {
      code: 'ENOENT',
      name: 'Error',
      message: /^ENOENT: no such file or directory, access/
    }
  );

  assert.rejects(
    access(__filename, 8),
    {
      code: 'ERR_OUT_OF_RANGE',
      message: /""mode"".*must be an integer >= 0 && <= 7\. Received 8$/
    }
  );

  assert.rejects(
    access(__filename, { [Symbol.toPrimitive]() { return 5; } }),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""mode"" argument.+integer\. Received an instance of Object$/
    }
  );
}

function verifyStatObject(stat) {
  assert.strictEqual(typeof stat, 'object');
  assert.strictEqual(typeof stat.dev, 'number');
  assert.strictEqual(typeof stat.mode, 'number');
}

async function getHandle(dest) {
  await copyFile(fixtures.path('baz.js'), dest);
  await access(dest);

  return open(dest, 'r+');
}

async function executeOnHandle(dest, func) {
  let handle;
  try {
    handle = await getHandle(dest);
    await func(handle);
  } finally {
    if (handle) {
      await handle.close();
    }
  }
}

{
  async function doTest() {
    tmpdir.refresh();

    const dest = path.resolve(tmpDir, 'baz.js');

    // handle is object
    {
      await executeOnHandle(dest, async (handle) => {
        assert.strictEqual(typeof handle, 'object');
      });
    }

    // file stats
    {
      await executeOnHandle(dest, async (handle) => {
        let stats = await handle.stat();
        verifyStatObject(stats);
        assert.strictEqual(stats.size, 35);

        await handle.truncate(1);

        stats = await handle.stat();
        verifyStatObject(stats);
        assert.strictEqual(stats.size, 1);

        stats = await stat(dest);
        verifyStatObject(stats);

        stats = await handle.stat();
        verifyStatObject(stats);

        await handle.datasync();
        await handle.sync();
      });
    }

    // Test fs.read promises when length to read is zero bytes
    {
      const dest = path.resolve(tmpDir, 'test1.js');
      await executeOnHandle(dest, async (handle) => {
        const buf = Buffer.from('DAWGS WIN');
        const bufLen = buf.length;
        await handle.write(buf);
        const ret = await handle.read(Buffer.alloc(bufLen), 0, 0, 0);
        assert.strictEqual(ret.bytesRead, 0);

        await unlink(dest);
      });
    }


    /* Undocumented usage
    // Use fallback buffer allocation when input not buffer
    {
      await executeOnHandle(dest, async (handle) => {
        const ret = await handle.read(0, 0, 0, 0);
        assert.strictEqual(ret.buffer.length, 16384);
      });
    }
    */

    // Bytes written to file match buffer
    {
      await executeOnHandle(dest, async (handle) => {
        const buf = Buffer.from('hello fsPromises');
        const bufLen = buf.length;
        await handle.write(buf);
        const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);
        assert.strictEqual(ret.bytesRead, bufLen);
        assert.deepStrictEqual(ret.buffer, buf);
      });
    }

    // Truncate file to specified length
    {
      await executeOnHandle(dest, async (handle) => {
        const buf = Buffer.from('hello FileHandle');
        const bufLen = buf.length;
        await handle.write(buf, 0, bufLen, 0);
        const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);
        assert.strictEqual(ret.bytesRead, bufLen);
        assert.deepStrictEqual(ret.buffer, buf);
        await truncate(dest, 5);
        assert.strictEqual((await readFile(dest)).toString(), 'hello');
      });
    }

    /*
    // Invalid change of ownership
    {
      await executeOnHandle(dest, async (handle) => {
        await chmod(dest, 0o666);
        await handle.chmod(0o666);

        await chmod(dest, (0o10777));
        await handle.chmod(0o10777);

        if (!common.isWindows) {
          await chown(dest, process.getuid(), process.getgid());
          await handle.chown(process.getuid(), process.getgid());
        }

        await assert.rejects(
          async () => {
            await chown(dest, 1, -2);
          },
          {
            code: 'ERR_OUT_OF_RANGE',
            name: 'RangeError',
            message: 'The value of ""gid"" is out of range. ' +
                     'It must be >= -1 && <= 4294967295. Received -2'
          });

        await assert.rejects(
          async () => {
            await handle.chown(1, -2);
          },
          {
            code: 'ERR_OUT_OF_RANGE',
            name: 'RangeError',
            message: 'The value of ""gid"" is out of range. ' +
                      'It must be >= -1 && <= 4294967295. Received -2'
          });
      });
    }
    */

    // Set modification times
    {
      await executeOnHandle(dest, async (handle) => {

        await utimes(dest, new Date(), new Date());

        try {
          await handle.utimes(new Date(), new Date());
        } catch (err) {
          // Some systems do not have futimes. If there is an error,
          // expect it to be ENOSYS
          common.expectsError({
            code: 'ENOSYS',
            name: 'Error'
          })(err);
        }
      });
    }

    /*
    // Set modification times with lutimes
    {
      const a_time = new Date();
      a_time.setMinutes(a_time.getMinutes() - 1);
      const m_time = new Date();
      m_time.setHours(m_time.getHours() - 1);
      await lutimes(dest, a_time, m_time);
      const stats = await stat(dest);

      assert.strictEqual(a_time.toString(), stats.atime.toString());
      assert.strictEqual(m_time.toString(), stats.mtime.toString());
    }
    */

    // create symlink
    {
      const newPath = path.resolve(tmpDir, 'baz2.js');
      await rename(dest, newPath);
      let stats = await stat(newPath);
      verifyStatObject(stats);

      if (common.canCreateSymLink()) {
        const newLink = path.resolve(tmpDir, 'baz3.js');
        await symlink(newPath, newLink);
        /*
        if (!common.isWindows) {
          await lchown(newLink, process.getuid(), process.getgid());
        }
        */
        stats = await lstat(newLink);
        verifyStatObject(stats);

        /*
        assert.strictEqual(newPath.toLowerCase(),
                           (await realpath(newLink)).toLowerCase());
        assert.strictEqual(newPath.toLowerCase(),
                           (await readlink(newLink)).toLowerCase());

        const newMode = 0o666;
        if (common.isOSX) {
          // `lchmod` is only available on macOS.
          await lchmod(newLink, newMode);
          stats = await lstat(newLink);
          assert.strictEqual(stats.mode & 0o777, newMode);
        } else {
          await Promise.all([
            assert.rejects(
              lchmod(newLink, newMode),
              common.expectsError({
                code: 'ERR_METHOD_NOT_IMPLEMENTED',
                name: 'Error',
                message: 'The lchmod() method is not implemented'
              })
            ),
          ]);
        }
        */

        await unlink(newLink);
      }
    }

    /*
    // specify symlink type
    {
      const dir = path.join(tmpDir, nextdir());
      await symlink(tmpDir, dir, 'dir');
      const stats = await lstat(dir);
      assert.strictEqual(stats.isSymbolicLink(), true);
      await unlink(dir);
    }
    */

    // create hard link
    {
      const newPath = path.resolve(tmpDir, 'baz2.js');
      const newLink = path.resolve(tmpDir, 'baz4.js');
      await link(newPath, newLink);

      await unlink(newLink);
    }

    // Testing readdir lists both files and directories
    {
      const newDir = path.resolve(tmpDir, 'dir');
      const newFile = path.resolve(tmpDir, 'foo.js');

      await mkdir(newDir);
      await writeFile(newFile, 'DAWGS WIN!', 'utf8');

      const stats = await stat(newDir);
      assert(stats.isDirectory());
      const list = await readdir(tmpDir);
      assert.notStrictEqual(list.indexOf('dir'), -1);
      assert.notStrictEqual(list.indexOf('foo.js'), -1);
      await rmdir(newDir);
      await unlink(newFile);
    }

    // Use fallback encoding when input is null
    {
      const newFile = path.resolve(tmpDir, 'dogs_running.js');
      await writeFile(newFile, 'dogs running', { encoding: null });
      const fileExists = fs.existsSync(newFile);
      assert.strictEqual(fileExists, true);
    }

    // `mkdir` when options is number.
    {
      const dir = path.join(tmpDir, nextdir());
      await mkdir(dir, 777);
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // `mkdir` when options is string.
    {
      const dir = path.join(tmpDir, nextdir());
      await mkdir(dir, '777');
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // `mkdirp` when folder does not yet exist.
    {
      const dir = path.join(tmpDir, nextdir(), nextdir());
      await mkdir(dir, { recursive: true });
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // `mkdirp` when path is a file.
    {
      const dir = path.join(tmpDir, nextdir(), nextdir());
      await mkdir(path.dirname(dir));
      await writeFile(dir, '');
      assert.rejects(
        mkdir(dir, { recursive: true }),
        {
          code: 'EEXIST',
          message: /EEXIST: .*mkdir/,
          name: 'Error',
          syscall: 'mkdir',
        }
      );
    }

    // `mkdirp` when part of the path is a file.
    {
      const file = path.join(tmpDir, nextdir(), nextdir());
      const dir = path.join(file, nextdir(), nextdir());
      await mkdir(path.dirname(file));
      await writeFile(file, '');
      assert.rejects(
        mkdir(dir, { recursive: true }),
        {
          code: 'ENOTDIR',
          message: /ENOTDIR: .*mkdir/,
          name: 'Error',
          syscall: 'mkdir',
        }
      );
    }

    // mkdirp ./
    {
      const dir = path.resolve(tmpDir, `${nextdir()}/./${nextdir()}`);
      await mkdir(dir, { recursive: true });
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // mkdirp ../
    {
      const dir = path.resolve(tmpDir, `${nextdir()}/../${nextdir()}`);
      await mkdir(dir, { recursive: true });
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // fs.mkdirp requires the recursive option to be of type boolean.
    // Everything else generates an error.
    {
      const dir = path.join(tmpDir, nextdir(), nextdir());
      ['', 1, {}, [], null, Symbol('test'), () => {}].forEach((recursive) => {
        assert.rejects(
          // mkdir() expects to get a boolean value for options.recursive.
          async () => mkdir(dir, { recursive }),
          {
            code: 'ERR_INVALID_ARG_TYPE',
            name: 'TypeError'
          }
        );
      });
    }

    // `mkdtemp` with invalid numeric prefix
    {
      await mkdtemp(path.resolve(tmpDir, 'FOO'));
      assert.rejects(
        // mkdtemp() expects to get a string prefix.
        async () => mkdtemp(1),
        {
          code: 'ERR_INVALID_ARG_TYPE',
          name: 'TypeError'
        }
      );
    }

    // Regression test for https://github.com/nodejs/node/issues/38168
    {
      await executeOnHandle(dest, async (handle) => {
        await assert.rejects(
          async () => handle.write('abc', 0, 'hex'),
          {
            code: 'ERR_INVALID_ARG_VALUE',
            message: /'encoding' is invalid for data of length 3/
          }
        );

        const ret = await handle.write('abcd', 0, 'hex');
        assert.strictEqual(ret.bytesWritten, 2);
      });
    }

    /*
    // Test prototype methods calling with contexts other than FileHandle
    {
      await executeOnHandle(dest, async (handle) => {
        await assert.rejects(() => handle.stat.call({}), {
          code: 'ERR_INTERNAL_ASSERTION',
          message: /handle must be an instance of FileHandle/
        });
      });
    }
    */
  }

  doTest().then(common.mustCall()).catch(err => print(err, err.stack));
}

```"
"```javascript:test\fs\test-fs-mkdir.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import process from 'process';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

let dirc = 0;
function nextdir() {
  return `test${++dirc}`;
}

// fs.mkdir creates directory using assigned path
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdir(pathname, common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
  }));
}

// fs.mkdir creates directory with assigned mode value
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdir(pathname, 0o777, common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
  }));
}

// fs.mkdir creates directory with mode passed as an options object
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ mode: 0o777 }), common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
  }));
}

// fs.mkdirSync creates directory with mode passed as an options object
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ mode: 0o777 }));

  assert.strictEqual(fs.existsSync(pathname), true);
}

// mkdirSync successfully creates directory from given path
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdirSync(pathname);

  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
}

// mkdirSync and mkdir require path to be a string, buffer or url.
// Anything else generates an error.
[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.mkdir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.mkdirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// mkdirpSync when both top-level, and sub-folders do not exist.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));

  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
}

// mkdirpSync when folder already exists.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(pathname, { recursive: true });
  // Should not cause an error.
  fs.mkdirSync(pathname, { recursive: true });

  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
}

// mkdirpSync ../
{
  const pathname = `${tmpdir.path}/${nextdir()}/../${nextdir()}/${nextdir()}`;
  fs.mkdirSync(pathname, { recursive: true });
  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
}

// mkdirpSync when path is a file.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(pathname));
  fs.writeFileSync(pathname, '', 'utf8');

  assert.throws(
    () => { fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true })); },
    {
      code: 'EEXIST',
      message: /EEXIST: .*mkdir/,
      name: 'Error',
      syscall: 'mkdir',
    }
  );
}

// mkdirpSync when part of the path is a file.
{
  const filename = path.join(tmpdir.path, nextdir(), nextdir());
  const pathname = path.join(filename, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(filename));
  fs.writeFileSync(filename, '', 'utf8');

  assert.throws(
    () => { fs.mkdirSync(pathname, { recursive: true }); },
    {
      code: 'ENOTDIR',
      message: /ENOTDIR: .*mkdir/,
      name: 'Error',
      syscall: 'mkdir',
      path: pathname // See: https://github.com/nodejs/node/issues/28015
    }
  );
}

// `mkdirp` when folder does not yet exist.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  }));
}

// `mkdirp` when path is a file.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(pathname));
  fs.writeFileSync(pathname, '', 'utf8');
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall((err) => {
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'mkdir');
    assert.strictEqual(fs.statSync(pathname).isDirectory(), false);
  }));
}

// `mkdirp` when part of the path is a file.
{
  const filename = path.join(tmpdir.path, nextdir(), nextdir());
  const pathname = path.join(filename, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(filename));
  fs.writeFileSync(filename, '', 'utf8');
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall((err) => {
    assert.strictEqual(err.code, 'ENOTDIR');
    assert.strictEqual(err.syscall, 'mkdir');
    assert.strictEqual(fs.existsSync(pathname), false);
    // See: https://github.com/nodejs/node/issues/28015
    // The path field varies slightly in Windows errors, vs., other platforms
    // see: https://github.com/libuv/libuv/issues/2661, for this reason we
    // use startsWith() rather than comparing to the full ""pathname"".
    assert(err.path.startsWith(filename));
  }));
}

// mkdirpSync dirname loop
// XXX: windows and smartos have issues removing a directory that you're in.
if (common.isMainThread && (common.isLinux || common.isOSX)) {
  const pathname = path.join(tmpdir.path, nextdir());
  fs.mkdirSync(pathname);
  process.chdir(pathname);
  fs.rmdirSync(pathname);
  assert.throws(
    () => { fs.mkdirSync('X', common.mustNotMutateObjectDeep({ recursive: true })); },
    {
      code: 'ENOENT',
      message: /ENOENT: .*mkdir/,
      name: 'Error',
      syscall: 'mkdir',
    }
  );
  fs.mkdir('X', common.mustNotMutateObjectDeep({ recursive: true }), (err) => {
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'mkdir');
  });
}

// mkdirSync and mkdir require options.recursive to be a boolean.
// Anything else generates an error.
{
  const pathname = path.join(tmpdir.path, nextdir());
  ['', 1, {}, [], null, Symbol('test'), () => {}].forEach((recursive) => {
    const received = common.invalidArgTypeHelper(recursive);
    assert.throws(
      () => fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive }), common.mustNotCall()),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""options.recursive"" property must be of type boolean.' +
          received
      }
    );
    assert.throws(
      () => fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive })),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""options.recursive"" property must be of type boolean.' +
          received
      }
    );
  });
}

// `mkdirp` returns first folder created, when all folders are new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const firstPathCreated = path.join(tmpdir.path, dir1);
  const pathname = path.join(tmpdir.path, dir1, dir2);

  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err, path) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(path, firstPathCreated);
  }));
}

// `mkdirp` returns first folder created, when last folder is new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1));
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err, path) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(path, pathname);
  }));
}

// `mkdirp` returns undefined, when no new folders are created.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1, dir2), common.mustNotMutateObjectDeep({ recursive: true }));
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err, path) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(path, undefined);
  }));
}

// `mkdirp.sync` returns first folder created, when all folders are new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const firstPathCreated = path.join(tmpdir.path, dir1);
  const pathname = path.join(tmpdir.path, dir1, dir2);
  const p = fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(pathname), true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  assert.strictEqual(p, firstPathCreated);
}

// `mkdirp.sync` returns first folder created, when last folder is new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1), common.mustNotMutateObjectDeep({ recursive: true }));
  const p = fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(pathname), true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  assert.strictEqual(p, pathname);
}

// `mkdirp.sync` returns undefined, when no new folders are created.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1, dir2), common.mustNotMutateObjectDeep({ recursive: true }));
  const p = fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(pathname), true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  assert.strictEqual(p, undefined);
}

// `mkdirp.promises` returns first folder created, when all folders are new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const firstPathCreated = path.join(tmpdir.path, dir1);
  const pathname = path.join(tmpdir.path, dir1, dir2);
  async function testCase() {
    const p = await fs.promises.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(p, firstPathCreated);
  }
  testCase();
}

// Keep the event loop alive so the async mkdir() requests
// have a chance to run (since they don't ref the event loop).
process.nextTick(() => {});

```"
"```javascript:modules\internal\validators.js
import {
    ERR_SOCKET_BAD_PORT,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_CALLBACK,
    ERR_OUT_OF_RANGE,
    hideStackFrames,
    ERR_INVALID_ARG_VALUE
} from './errors'

export function validatePort(port, name = ""Port"", allowZero = true) {
    if (
        (typeof port !== ""number"" && typeof port !== ""string"") ||
        (typeof port === ""string"" &&
            port.trim().length === 0) ||
        +port !== (+port >>> 0) ||
        port > 0xFFFF ||
        (port === 0 && !allowZero)
    ) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }

    return port;
}

export const validateFunction = hideStackFrames(
    (value, name) => {
        if (typeof value !== ""function"") {
            throw new ERR_INVALID_ARG_TYPE(name, ""Function"", value);
        }
    },
);

export function validateString(value, name) {
    if (typeof value !== ""string"") {
        throw new ERR_INVALID_ARG_TYPE(name, ""string"", value);
    }
}

/**
 * @param {unknown} value
 * @param {string} name
 */
export function validateBoolean(value, name) {
    if (typeof value !== ""boolean"") {
        throw new ERR_INVALID_ARG_TYPE(name, ""boolean"", value);
    }
}


/**
 * @param {unknown} signal
 * @param {string} name
 */
export const validateAbortSignal = hideStackFrames(
    (signal, name) => {
        if (
            signal !== undefined &&
            (signal === null ||
                typeof signal !== ""object"" ||
                !(""aborted"" in signal))
        ) {
            throw new ERR_INVALID_ARG_TYPE(name, ""AbortSignal"", signal);
        }
    },
);

export const validateObject = hideStackFrames((value, name, options) => {
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (
        (!nullable && value === null) ||
        (!allowArray && Array.isArray(value)) ||
        (typeof value !== ""object"" && (
            !allowFunction || typeof value !== ""function""
        ))
    ) {
        throw new ERR_INVALID_ARG_TYPE(name, ""Object"", value);
    }
});

export const validateCallback = hideStackFrames((callback) => {
    if (typeof callback !== ""function"") {
        throw new ERR_INVALID_CALLBACK(callback);
    }
});

/**
 * @param {number} value
 * @returns {boolean}
 */
function isInt32(value) {
    return value === (value | 0);
}

/**
 * @param {unknown} value
 * @returns {boolean}
 */
function isUint32(value) {
    return value === (value >>> 0);
}

export const validateInt32 = hideStackFrames(
    (value, name, min = -2147483648, max = 2147483647) => {
        // The defaults for min and max correspond to the limits of 32-bit integers.
        if (!isInt32(value)) {
            if (typeof value !== ""number"") {
                throw new ERR_INVALID_ARG_TYPE(name, ""number"", value);
            }

            if (!Number.isInteger(value)) {
                throw new ERR_OUT_OF_RANGE(name, ""an integer"", value);
            }

            throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
        }

        if (value < min || value > max) {
            throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
        }
    },
);

export const validateUint32 = hideStackFrames(
    (value, name, positive) => {
        if (!isUint32(value)) {
            if (typeof value !== ""number"") {
                throw new ERR_INVALID_ARG_TYPE(name, ""number"", value);
            }
            if (!Number.isInteger(value)) {
                throw new ERR_OUT_OF_RANGE(name, ""an integer"", value);
            }
            const min = positive ? 1 : 0;
            // 2 ** 32 === 4294967296
            throw new ERR_OUT_OF_RANGE(
                name,
                `>= ${min} && < 4294967296`,
                value,
            );
        }
        if (positive && value === 0) {
            throw new ERR_OUT_OF_RANGE(name, "">= 1 && < 4294967296"", value);
        }
    },
);

export const validateInteger = hideStackFrames(
    (
        value,
        name,
        min = Number.MIN_SAFE_INTEGER,
        max = Number.MAX_SAFE_INTEGER,
    ) => {
        if (typeof value !== ""number"") {
            throw new ERR_INVALID_ARG_TYPE(name, ""number"", value);
        }
        if (!Number.isInteger(value)) {
            throw new ERR_OUT_OF_RANGE(name, ""an integer"", value);
        }
        if (value < min || value > max) {
            throw new ERR_OUT_OF_RANGE(name, `an integer >= ${min} && <= ${max}`, value);
        }
    },
);

export const getValidMode = hideStackFrames((mode, type) => {
    let min = kMinimumAccessMode;
    let max = kMaximumAccessMode;
    let def = F_OK;
    if (type === ""copyFile"") {
        min = kMinimumCopyMode;
        max = kMaximumCopyMode;
        def = mode || kDefaultCopyMode;
    } else {
        // assert(type === ""access"");
    }
    if (mode == null) {
        return def;
    }
    if (Number.isInteger(mode) && mode >= min && mode <= max) {
        return mode;
    }
    if (typeof mode !== ""number"") {
        throw new ERR_INVALID_ARG_TYPE(""mode"", ""integer"", mode);
    }
    throw new ERR_OUT_OF_RANGE(
        ""mode"",
        `an integer >= ${min} && <= ${max}`,
        mode,
    );
});

/**
 * @callback validateNumber
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateNumber} */
export function validateNumber(value, name, min = undefined, max) {
    if (typeof value !== 'number')
        throw new ERR_INVALID_ARG_TYPE(name, 'number', value);

    if ((min != null && value < min) || (max != null && value > max) ||
        ((min != null || max != null) && Number.isNaN(value))) {
        throw new ERR_OUT_OF_RANGE(
            name,
            `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,
            value);
    }
}

/**
 * @callback validateArray
 * @param {*} value
 * @param {string} name
 * @param {number} [minLength]
 * @returns {asserts value is any[]}
 */

/** @type {validateArray} */
export const validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!Array.isArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, 'Array', value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});

/**
 * @callback validateOneOf
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} oneOf
 */

/** @type {validateOneOf} */
export const validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(
            Array.prototype.map.call(oneOf, (v) =>
                (typeof v === 'string' ? `'${v}'` : String(v))),
            ', ');
        const reason = 'must be one of: ' + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});

// Return undefined if there is no match.
// Move the ""slow cases"" to a separate function to make sure this function gets
// inlined properly. That prioritizes the common case.
function normalizeEncoding(enc) {
    if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';
    return slowCases(enc);
}

function slowCases(enc) {
    switch (enc.length) {
        case 4:
            if (enc === 'UTF8') return 'utf8';
            if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';
            enc = `${enc}`.toLowerCase();
            if (enc === 'utf8') return 'utf8';
            if (enc === 'ucs2') return 'utf16le';
            break;
        case 3:
            if (enc === 'hex' || enc === 'HEX' ||
                `${enc}`.toLowerCase() === 'hex')
                return 'hex';
            break;
        case 5:
            if (enc === 'ascii') return 'ascii';
            if (enc === 'ucs-2') return 'utf16le';
            if (enc === 'UTF-8') return 'utf8';
            if (enc === 'ASCII') return 'ascii';
            if (enc === 'UCS-2') return 'utf16le';
            enc = `${enc}`.toLowerCase();
            if (enc === 'utf-8') return 'utf8';
            if (enc === 'ascii') return 'ascii';
            if (enc === 'ucs-2') return 'utf16le';
            break;
        case 6:
            if (enc === 'base64') return 'base64';
            if (enc === 'latin1' || enc === 'binary') return 'latin1';
            if (enc === 'BASE64') return 'base64';
            if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';
            enc = `${enc}`.toLowerCase();
            if (enc === 'base64') return 'base64';
            if (enc === 'latin1' || enc === 'binary') return 'latin1';
            break;
        case 7:
            if (enc === 'utf16le' || enc === 'UTF16LE' ||
                `${enc}`.toLowerCase() === 'utf16le')
                return 'utf16le';
            break;
        case 8:
            if (enc === 'utf-16le' || enc === 'UTF-16LE' ||
                `${enc}`.toLowerCase() === 'utf-16le')
                return 'utf16le';
            break;
        case 9:
            if (enc === 'base64url' || enc === 'BASE64URL' ||
                `${enc}`.toLowerCase() === 'base64url')
                return 'base64url';
            break;
        default:
            if (enc === '') return 'utf8';
    }
}


/**
 * @param {string} data
 * @param {string} encoding
 */
export function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;

    if (normalizedEncoding === 'hex' && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE('encoding', encoding,
            `is invalid for data of length ${length}`);
    }
}

export default {
    validatePort,
    validateFunction,
    validateString,
    validateBoolean,
    validateObject,
    validateAbortSignal,
    validateCallback,
    validateInteger,
    validateNumber,
    validateArray,
    getValidMode,
    validateOneOf,
    validateEncoding
}
```"
"```javascript:test\crypto\test-crypto-rsa-dsa.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const constants = crypto.constants;

const fixtures = require('../common/fixtures');

// Test certificates
const certPem = fixtures.readKey('rsa_cert.crt');
const keyPem = fixtures.readKey('rsa_private.pem');
const rsaKeySize = 2048;
const rsaPubPem = fixtures.readKey('rsa_public.pem', 'ascii');
const rsaKeyPem = fixtures.readKey('rsa_private.pem', 'ascii');
const rsaKeyPemEncrypted = fixtures.readKey('rsa_private_encrypted.pem',
                                            'ascii');
const dsaPubPem = fixtures.readKey('dsa_public.pem', 'ascii');
const dsaKeyPem = fixtures.readKey('dsa_private.pem', 'ascii');
const dsaKeyPemEncrypted = fixtures.readKey('dsa_private_encrypted.pem',
                                            'ascii');
const rsaPkcs8KeyPem = fixtures.readKey('rsa_private_pkcs8.pem');
const dsaPkcs8KeyPem = fixtures.readKey('dsa_private_pkcs8.pem');

const ec = new TextEncoder();

const openssl1DecryptError = {
  message: 'error:06065064:digital envelope routines:EVP_DecryptFinal_ex:' +
    'bad decrypt',
  code: 'ERR_OSSL_EVP_BAD_DECRYPT',
  reason: 'bad decrypt',
  function: 'EVP_DecryptFinal_ex',
  library: 'digital envelope routines',
};

const decryptError = common.hasOpenSSL3 ?
  { message: 'error:1C800064:Provider routines::bad decrypt' } :
  openssl1DecryptError;

const decryptPrivateKeyError = common.hasOpenSSL3 ? {
  message: 'error:1C800064:Provider routines::bad decrypt',
} : openssl1DecryptError;

function getBufferCopy(buf) {
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

// Test RSA encryption/decryption
{
  const input = 'I AM THE WALRUS';
  const bufferToEncrypt = Buffer.from(input);
  const bufferPassword = Buffer.from('password');

  let encryptedBuffer = crypto.publicEncrypt(rsaPubPem, bufferToEncrypt);

  // Test other input types
  let otherEncrypted;
  {
    const ab = getBufferCopy(ec.encode(rsaPubPem));
    const ab2enc = getBufferCopy(bufferToEncrypt);

    crypto.publicEncrypt(ab, ab2enc);
    crypto.publicEncrypt(new Uint8Array(ab), new Uint8Array(ab2enc));
    crypto.publicEncrypt(new DataView(ab), new DataView(ab2enc));
    otherEncrypted = crypto.publicEncrypt({
      key: Buffer.from(ab).toString('hex'),
      encoding: 'hex'
    }, Buffer.from(ab2enc).toString('hex'));
  }

  let decryptedBuffer = crypto.privateDecrypt(rsaKeyPem, encryptedBuffer);
  const otherDecrypted = crypto.privateDecrypt(rsaKeyPem, otherEncrypted);
  assert.strictEqual(decryptedBuffer.toString(), input);
  assert.strictEqual(otherDecrypted.toString(), input);

  decryptedBuffer = crypto.privateDecrypt(rsaPkcs8KeyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  let decryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, encryptedBuffer);

  const otherDecryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: ec.encode('password')
  }, encryptedBuffer);

  assert.strictEqual(
    otherDecryptedBufferWithPassword.toString(),
    decryptedBufferWithPassword.toString());

  decryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, encryptedBuffer);

  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  encryptedBuffer = crypto.publicEncrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, bufferToEncrypt);

  decryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  encryptedBuffer = crypto.privateEncrypt({
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, bufferToEncrypt);

  decryptedBufferWithPassword = crypto.publicDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  // Now with explicit RSA_PKCS1_PADDING.
  encryptedBuffer = crypto.privateEncrypt({
    padding: crypto.constants.RSA_PKCS1_PADDING,
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, bufferToEncrypt);

  decryptedBufferWithPassword = crypto.publicDecrypt({
    padding: crypto.constants.RSA_PKCS1_PADDING,
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  // Omitting padding should be okay because RSA_PKCS1_PADDING is the default.
  decryptedBufferWithPassword = crypto.publicDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  // Now with RSA_NO_PADDING. Plaintext needs to match key size.
  // OpenSSL 3.x has a rsa_check_padding that will cause an error if
  // RSA_NO_PADDING is used.
  if (!common.hasOpenSSL3) {
    {
      const plaintext = 'x'.repeat(rsaKeySize / 8);
      encryptedBuffer = crypto.privateEncrypt({
        padding: crypto.constants.RSA_NO_PADDING,
        key: rsaKeyPemEncrypted,
        passphrase: bufferPassword
      }, Buffer.from(plaintext));

      decryptedBufferWithPassword = crypto.publicDecrypt({
        padding: crypto.constants.RSA_NO_PADDING,
        key: rsaKeyPemEncrypted,
        passphrase: bufferPassword
      }, encryptedBuffer);
      assert.strictEqual(decryptedBufferWithPassword.toString(), plaintext);
    }
  }

  encryptedBuffer = crypto.publicEncrypt(certPem, bufferToEncrypt);

  decryptedBuffer = crypto.privateDecrypt(keyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  encryptedBuffer = crypto.publicEncrypt(keyPem, bufferToEncrypt);

  decryptedBuffer = crypto.privateDecrypt(keyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  encryptedBuffer = crypto.privateEncrypt(keyPem, bufferToEncrypt);

  decryptedBuffer = crypto.publicDecrypt(keyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  assert.throws(() => {
    crypto.privateDecrypt({
      key: rsaKeyPemEncrypted,
      passphrase: 'wrong'
    }, bufferToEncrypt);
  }, decryptError);

  assert.throws(() => {
    crypto.publicEncrypt({
      key: rsaKeyPemEncrypted,
      passphrase: 'wrong'
    }, encryptedBuffer);
  }, decryptError);

  encryptedBuffer = crypto.privateEncrypt({
    key: rsaKeyPemEncrypted,
    passphrase: Buffer.from('password')
  }, bufferToEncrypt);

  assert.throws(() => {
    crypto.publicDecrypt({
      key: rsaKeyPemEncrypted,
      passphrase: Buffer.from('wrong')
    }, encryptedBuffer);
  }, decryptError);
}

function test_rsa(padding, encryptOaepHash, decryptOaepHash) {
  const size = (padding === 'RSA_NO_PADDING') ? rsaKeySize / 8 : 32;
  const input = Buffer.allocUnsafe(size);
  for (let i = 0; i < input.length; i++)
    input[i] = (i * 7 + 11) & 0xff;
  const bufferToEncrypt = Buffer.from(input);

  padding = constants[padding];

  const encryptedBuffer = crypto.publicEncrypt({
    key: rsaPubPem,
    padding: padding,
    oaepHash: encryptOaepHash
  }, bufferToEncrypt);

  let decryptedBuffer = crypto.privateDecrypt({
    key: rsaKeyPem,
    padding: padding,
    oaepHash: decryptOaepHash
  }, encryptedBuffer);
  assert.deepStrictEqual(decryptedBuffer, input);

  decryptedBuffer = crypto.privateDecrypt({
    key: rsaPkcs8KeyPem,
    padding: padding,
    oaepHash: decryptOaepHash
  }, encryptedBuffer);
  assert.deepStrictEqual(decryptedBuffer, input);
}

test_rsa('RSA_NO_PADDING');
test_rsa('RSA_PKCS1_PADDING');
test_rsa('RSA_PKCS1_OAEP_PADDING');

// Test OAEP with different hash functions.
test_rsa('RSA_PKCS1_OAEP_PADDING', undefined, 'sha1');
test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha1', undefined);
test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha256', 'sha256');
test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha512', 'sha512');
assert.throws(() => {
  test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha256', 'sha512');
}, {
  code: 'ERR_OSSL_RSA_OAEP_DECODING_ERROR'
});

// The following RSA-OAEP test cases were created using the WebCrypto API to
// ensure compatibility when using non-SHA1 hash functions.
{
  const { decryptionTests } =
      JSON.parse(fixtures.readSync('rsa-oaep-test-vectors.js', 'utf8'));

  for (const { ct, oaepHash, oaepLabel } of decryptionTests) {
    const label = oaepLabel ? Buffer.from(oaepLabel, 'hex') : undefined;
    const copiedLabel = oaepLabel ? getBufferCopy(label) : undefined;

    const decrypted = crypto.privateDecrypt({
      key: rsaPkcs8KeyPem,
      oaepHash,
      oaepLabel: oaepLabel ? label : undefined
    }, Buffer.from(ct, 'hex'));

    assert.strictEqual(decrypted.toString('utf8'), 'Hello Node.js');

    const otherDecrypted = crypto.privateDecrypt({
      key: rsaPkcs8KeyPem,
      oaepHash,
      oaepLabel: copiedLabel
    }, Buffer.from(ct, 'hex'));

    assert.strictEqual(otherDecrypted.toString('utf8'), 'Hello Node.js');
  }
}

// Test invalid oaepHash and oaepLabel options.
for (const fn of [crypto.publicEncrypt, crypto.privateDecrypt]) {
  assert.throws(() => {
    fn({
      key: rsaPubPem,
      oaepHash: 'Hello world'
    }, Buffer.alloc(10));
  }, {
    code: 'ERR_OSSL_EVP_INVALID_DIGEST'
  });

  for (const oaepHash of [0, false, null, Symbol(), () => {}]) {
    assert.throws(() => {
      fn({
        key: rsaPubPem,
        oaepHash
      }, Buffer.alloc(10));
    }, {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  }

  for (const oaepLabel of [0, false, null, Symbol(), () => {}, {}]) {
    assert.throws(() => {
      fn({
        key: rsaPubPem,
        oaepLabel
      }, Buffer.alloc(10));
    }, {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  }
}

// Test RSA key signing/verification
let rsaSign = crypto.createSign('SHA1');
let rsaVerify = crypto.createVerify('SHA1');
assert.ok(rsaSign);
assert.ok(rsaVerify);

const expectedSignature = fixtures.readKey(
  'rsa_public_sha1_signature_signedby_rsa_private_pkcs8.sha1',
  'hex'
);

rsaSign.update(rsaPubPem);
let rsaSignature = rsaSign.sign(rsaKeyPem, 'hex');
assert.strictEqual(rsaSignature, expectedSignature);

rsaVerify.update(rsaPubPem);
assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);

// Test RSA PKCS#8 key signing/verification
rsaSign = crypto.createSign('SHA1');
rsaSign.update(rsaPubPem);
rsaSignature = rsaSign.sign(rsaPkcs8KeyPem, 'hex');
assert.strictEqual(rsaSignature, expectedSignature);

rsaVerify = crypto.createVerify('SHA1');
rsaVerify.update(rsaPubPem);
assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);

// Test RSA key signing/verification with encrypted key
rsaSign = crypto.createSign('SHA1');
rsaSign.update(rsaPubPem);
const signOptions = { key: rsaKeyPemEncrypted, passphrase: 'password' };
rsaSignature = rsaSign.sign(signOptions, 'hex');
assert.strictEqual(rsaSignature, expectedSignature);

rsaVerify = crypto.createVerify('SHA1');
rsaVerify.update(rsaPubPem);
assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);

rsaSign = crypto.createSign('SHA1');
rsaSign.update(rsaPubPem);
assert.throws(() => {
  const signOptions = { key: rsaKeyPemEncrypted, passphrase: 'wrong' };
  rsaSign.sign(signOptions, 'hex');
}, decryptPrivateKeyError);

//
// Test RSA signing and verification
//
{
  const privateKey = fixtures.readKey('rsa_private_b.pem');
  const publicKey = fixtures.readKey('rsa_public_b.pem');

  const input = 'I AM THE WALRUS';

  const signature = fixtures.readKey(
    'I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256',
    'hex'
  );

  const sign = crypto.createSign('SHA256');
  sign.update(input);

  const output = sign.sign(privateKey, 'hex');
  assert.strictEqual(output, signature);

  const verify = crypto.createVerify('SHA256');
  verify.update(input);

  assert.strictEqual(verify.verify(publicKey, signature, 'hex'), true);

  // Test the legacy signature algorithm name.
  const sign2 = crypto.createSign('RSA-SHA256');
  sign2.update(input);

  const output2 = sign2.sign(privateKey, 'hex');
  assert.strictEqual(output2, signature);

  const verify2 = crypto.createVerify('SHA256');
  verify2.update(input);

  assert.strictEqual(verify2.verify(publicKey, signature, 'hex'), true);
}


//
// Test DSA signing and verification
//
{
  const input = 'I AM THE WALRUS';

  // DSA signatures vary across runs so there is no static string to verify
  // against.
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signature = sign.sign(dsaKeyPem, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(dsaPubPem, signature, 'hex'), true);

  // Test the legacy 'DSS1' name.
  const sign2 = crypto.createSign('DSS1');
  sign2.update(input);
  const signature2 = sign2.sign(dsaKeyPem, 'hex');

  const verify2 = crypto.createVerify('DSS1');
  verify2.update(input);

  assert.strictEqual(verify2.verify(dsaPubPem, signature2, 'hex'), true);
}


//
// Test DSA signing and verification with PKCS#8 private key
//
{
  const input = 'I AM THE WALRUS';

  // DSA signatures vary across runs so there is no static string to verify
  // against.
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signature = sign.sign(dsaPkcs8KeyPem, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(dsaPubPem, signature, 'hex'), true);
}


//
// Test DSA signing and verification with encrypted key
//
const input = 'I AM THE WALRUS';

{
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  assert.throws(() => {
    sign.sign({ key: dsaKeyPemEncrypted, passphrase: 'wrong' }, 'hex');
  }, decryptPrivateKeyError);
}

{
  // DSA signatures vary across runs so there is no static string to verify
  // against.
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signOptions = { key: dsaKeyPemEncrypted, passphrase: 'password' };
  const signature = sign.sign(signOptions, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(dsaPubPem, signature, 'hex'), true);
}

```"
"```javascript:test\crypto\test-crypto.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

common.expectWarning({
  DeprecationWarning: [
    ['crypto.createCipher is deprecated.', 'DEP0106'],
  ]
});

const assert = require('assert');
const crypto = require('crypto');
const tls = require('tls');
const fixtures = require('../common/fixtures');

// Test Certificates
const certPfx = fixtures.readKey('rsa_cert.pfx');

// 'this' safety
// https://github.com/joyent/node/issues/6690
assert.throws(() => {
  const credentials = tls.createSecureContext();
  const context = credentials.context;
  const notcontext = { setOptions: context.setOptions };

  // Methods of native objects should not segfault when reassigned to a new
  // object and called illegally. This core dumped in 0.10 and was fixed in
  // 0.11.
  notcontext.setOptions();
}, (err) => {
  // Throws TypeError, so there is no opensslErrorStack property.
  return err instanceof TypeError &&
         err.name === 'TypeError' &&
         /^TypeError: Illegal invocation$/.test(err) &&
         !('opensslErrorStack' in err);
});

// PFX tests
tls.createSecureContext({ pfx: certPfx, passphrase: 'sample' });

assert.throws(() => {
  tls.createSecureContext({ pfx: certPfx });
}, (err) => {
  // Throws general Error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         err.name === 'Error' &&
         /^Error: mac verify failure$/.test(err) &&
         !('opensslErrorStack' in err);
});

assert.throws(() => {
  tls.createSecureContext({ pfx: certPfx, passphrase: 'test' });
}, (err) => {
  // Throws general Error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         err.name === 'Error' &&
         /^Error: mac verify failure$/.test(err) &&
         !('opensslErrorStack' in err);
});

assert.throws(() => {
  tls.createSecureContext({ pfx: 'sample', passphrase: 'test' });
}, (err) => {
  // Throws general Error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         err.name === 'Error' &&
         /^Error: not enough data$/.test(err) &&
         !('opensslErrorStack' in err);
});


// update() should only take buffers / strings
assert.throws(
  () => crypto.createHash('sha1').update({ foo: 'bar' }),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });


function validateList(list) {
  // The list must not be empty
  assert(list.length > 0);

  // The list should be sorted.
  // Array#sort() modifies the list in place so make a copy.
  const sorted = [...list].sort();
  assert.deepStrictEqual(list, sorted);

  // Each element should be unique.
  assert.strictEqual([...new Set(list)].length, list.length);

  // Each element should be a string.
  assert(list.every((value) => typeof value === 'string'));
}

// Assume that we have at least AES-128-CBC.
const cryptoCiphers = crypto.getCiphers();
assert(crypto.getCiphers().includes('aes-128-cbc'));
validateList(cryptoCiphers);
// Make sure all of the ciphers are supported by OpenSSL
for (const algo of cryptoCiphers) {
  const { ivLength, keyLength, mode } = crypto.getCipherInfo(algo);
  let options;
  if (mode === 'ccm')
    options = { authTagLength: 8 };
  else if (mode === 'ocb' || algo === 'chacha20-poly1305')
    options = { authTagLength: 16 };
  crypto.createCipheriv(algo,
                        crypto.randomBytes(keyLength),
                        crypto.randomBytes(ivLength || 0),
                        options);
}

// Assume that we have at least AES256-SHA.
const tlsCiphers = tls.getCiphers();
assert(tls.getCiphers().includes('aes256-sha'));
assert(tls.getCiphers().includes('tls_aes_128_ccm_8_sha256'));
// There should be no capital letters in any element.
const noCapitals = /^[^A-Z]+$/;
assert(tlsCiphers.every((value) => noCapitals.test(value)));
validateList(tlsCiphers);

// Assert that we have sha1 and sha256 but not SHA1 and SHA256.
assert.notStrictEqual(crypto.getHashes().length, 0);
assert(crypto.getHashes().includes('sha1'));
assert(crypto.getHashes().includes('sha256'));
assert(!crypto.getHashes().includes('SHA1'));
assert(!crypto.getHashes().includes('SHA256'));
assert(crypto.getHashes().includes('RSA-SHA1'));
assert(!crypto.getHashes().includes('rsa-sha1'));
validateList(crypto.getHashes());
// Make sure all of the hashes are supported by OpenSSL
for (const algo of crypto.getHashes())
  crypto.createHash(algo);

// Assume that we have at least secp384r1.
assert.notStrictEqual(crypto.getCurves().length, 0);
assert(crypto.getCurves().includes('secp384r1'));
assert(!crypto.getCurves().includes('SECP384R1'));
validateList(crypto.getCurves());

// Modifying return value from get* functions should not mutate subsequent
// return values.
function testImmutability(fn) {
  const list = fn();
  const copy = [...list];
  list.push('some-arbitrary-value');
  assert.deepStrictEqual(fn(), copy);
}

testImmutability(crypto.getCiphers);
testImmutability(tls.getCiphers);
testImmutability(crypto.getHashes);
testImmutability(crypto.getCurves);

const encodingError = {
  code: 'ERR_INVALID_ARG_VALUE',
  name: 'TypeError',
  message: ""The argument 'encoding' is invalid for data of length 1."" +
           "" Received 'hex'"",
};

// Regression tests for https://github.com/nodejs/node-v0.x-archive/pull/5725:
// hex input that's not a power of two should throw, not assert in C++ land.
['createCipher', 'createDecipher'].forEach((funcName) => {
  assert.throws(
    () => crypto[funcName]('aes192', 'test').update('0', 'hex'),
    (error) => {
      assert.ok(!('opensslErrorStack' in error));
      if (common.hasFipsCrypto) {
        return error instanceof Error &&
               error.name === 'Error' &&
               /^Error: not supported in FIPS mode$/.test(error);
      }
      assert.throws(() => { throw error; }, encodingError);
      return true;
    }
  );
});

assert.throws(
  () => crypto.createHash('sha1').update('0', 'hex'),
  (error) => {
    assert.ok(!('opensslErrorStack' in error));
    assert.throws(() => { throw error; }, encodingError);
    return true;
  }
);

assert.throws(
  () => crypto.createHmac('sha256', 'a secret').update('0', 'hex'),
  (error) => {
    assert.ok(!('opensslErrorStack' in error));
    assert.throws(() => { throw error; }, encodingError);
    return true;
  }
);

assert.throws(() => {
  const priv = [
    '-----BEGIN RSA PRIVATE KEY-----',
    'MIGrAgEAAiEA+3z+1QNF2/unumadiwEr+C5vfhezsb3hp4jAnCNRpPcCAwEAAQIgQNriSQK4',
    'EFwczDhMZp2dvbcz7OUUyt36z3S4usFPHSECEQD/41K7SujrstBfoCPzwC1xAhEA+5kt4BJy',
    'eKN7LggbF3Dk5wIQN6SL+fQ5H/+7NgARsVBp0QIRANxYRukavs4QvuyNhMx+vrkCEQCbf6j/',
    'Ig6/HueCK/0Jkmp+',
    '-----END RSA PRIVATE KEY-----',
    '',
  ].join('\n');
  crypto.createSign('SHA256').update('test').sign(priv);
}, (err) => {
  if (!common.hasOpenSSL3)
    assert.ok(!('opensslErrorStack' in err));
  assert.throws(() => { throw err; }, common.hasOpenSSL3 ? {
    name: 'Error',
    message: 'error:02000070:rsa routines::digest too big for rsa key',
    library: 'rsa routines',
  } : {
    name: 'Error',
    message: /routines:RSA_sign:digest too big for rsa key$/,
    library: 'rsa routines',
    function: 'RSA_sign',
    reason: 'digest too big for rsa key',
    code: 'ERR_OSSL_RSA_DIGEST_TOO_BIG_FOR_RSA_KEY'
  });
  return true;
});

if (!common.hasOpenSSL3) {
  assert.throws(() => {
    // The correct header inside `rsa_private_pkcs8_bad.pem` should have been
    // -----BEGIN PRIVATE KEY----- and -----END PRIVATE KEY-----
    // instead of
    // -----BEGIN RSA PRIVATE KEY----- and -----END RSA PRIVATE KEY-----
    const sha1_privateKey = fixtures.readKey('rsa_private_pkcs8_bad.pem',
                                             'ascii');
    // This would inject errors onto OpenSSL's error stack
    crypto.createSign('sha1').sign(sha1_privateKey);
  }, (err) => {
    // Do the standard checks, but then do some custom checks afterwards.
    assert.throws(() => { throw err; }, {
      message: 'error:0D0680A8:asn1 encoding routines:asn1_check_tlen:' +
               'wrong tag',
      library: 'asn1 encoding routines',
      function: 'asn1_check_tlen',
      reason: 'wrong tag',
      code: 'ERR_OSSL_ASN1_WRONG_TAG',
    });
    // Throws crypto error, so there is an opensslErrorStack property.
    // The openSSL stack should have content.
    assert(Array.isArray(err.opensslErrorStack));
    assert(err.opensslErrorStack.length > 0);
    return true;
  });
}

// Make sure memory isn't released before being returned
console.log(crypto.randomBytes(16));

assert.throws(() => {
  tls.createSecureContext({ crl: 'not a CRL' });
}, (err) => {
  // Throws general error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         /^Error: Failed to parse CRL$/.test(err) &&
         !('opensslErrorStack' in err);
});

/**
 * Check if the stream function uses utf8 as a default encoding.
 */

function testEncoding(options, assertionHash) {
  const hash = crypto.createHash('sha256', options);
  let hashValue = '';

  hash.on('data', (data) => {
    hashValue += data.toString('hex');
  });

  hash.on('end', common.mustCall(() => {
    assert.strictEqual(hashValue, assertionHash);
  }));

  hash.write('������');
  hash.end();
}

// Hash of ""������"" in utf8 format
const assertionHashUtf8 =
  '4f53d15bee524f082380e6d7247cc541e7cb0d10c64efdcc935ceeb1e7ea345c';

// Hash of ""������"" in latin1 format
const assertionHashLatin1 =
  'cd37bccd5786e2e76d9b18c871e919e6eb11cc12d868f5ae41c40ccff8e44830';

testEncoding(undefined, assertionHashUtf8);
testEncoding({}, assertionHashUtf8);

testEncoding({
  defaultEncoding: 'utf8'
}, assertionHashUtf8);

testEncoding({
  defaultEncoding: 'latin1'
}, assertionHashLatin1);

```"
"```javascript:modules\internal\crypto\util.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

/*const {
  getCiphers: _getCiphers,
  getCurves: _getCurves,
  getHashes: _getHashes,
  setEngine: _setEngine,
  secureHeapUsed: _secureHeapUsed,
} = internalBinding('crypto');*/

import { getOptionValue } from '../options';

import { crypto } from '../../internal_binding/constants';
const { ENGINE_METHOD_ALL } = crypto;
import normalizeHashName from './hashnames';

import {
  hideStackFrames,
  ERR_CRYPTO_ENGINE_UNKNOWN,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
  ERR_OUT_OF_RANGE,
} from '../errors';

import {
  validateArray,
  validateNumber,
  validateString
} from '../validators';

import { Buffer } from 'buffer';

import {
  cachedResult,
  filterDuplicateStrings,
  lazyDOMException,
} from '../util';

import {
  isArrayBufferView,
  isAnyArrayBuffer,
} from '../util/types';

const kHandle = Symbol('kHandle');
const kKeyObject = Symbol('kKeyObject');

let defaultEncoding = 'buffer';

function setDefaultEncoding(val) {
  defaultEncoding = val;
}

function getDefaultEncoding() {
  return defaultEncoding;
}

// This is here because many functions accepted binary strings without
// any explicit encoding in older versions of node, and we don't want
// to break them unnecessarily.
function toBuf(val, encoding) {
  if (typeof val === 'string') {
    if (encoding === 'buffer')
      encoding = 'utf8';
    return Buffer.from(val, encoding);
  }
  return val;
}

const getCiphers = () => [""aes-128-gcm"", ""aes-256-gcm""];
const getHashes = () => [""sha256"", ""sha512"", ""sha512-256""];
const getCurves = () => [];

function setEngine(id, flags) {
  validateString(id, 'id');
  if (flags)
    validateNumber(flags, 'flags');
  flags = flags >>> 0;

  // Use provided engine for everything by default
  if (flags === 0)
    flags = ENGINE_METHOD_ALL;

  /*if (!_setEngine(id, flags))
    throw new ERR_CRYPTO_ENGINE_UNKNOWN(id);*/
}

const getArrayBufferOrView = hideStackFrames((buffer, name, encoding) => {
  if (isAnyArrayBuffer(buffer))
    return buffer;
  if (typeof buffer === 'string') {
    if (encoding === 'buffer')
      encoding = 'utf8';
    return Buffer.from(buffer, encoding);
  }
  if (!isArrayBufferView(buffer)) {
    throw new ERR_INVALID_ARG_TYPE(
      name,
      [
        'string',
        'ArrayBuffer',
        'Buffer',
        'TypedArray',
        'DataView',
      ],
      buffer
    );
  }
  return buffer;
});

// The maximum buffer size that we'll support in the WebCrypto impl
const kMaxBufferLength = (2 ** 31) - 1;

// The EC named curves that we currently support via the Web Crypto API.
const kNamedCurveAliases = {
  'P-256': 'prime256v1',
  'P-384': 'secp384r1',
  'P-521': 'secp521r1',
};

const kAesKeyLengths = [128, 192, 256];

// These are the only algorithms we currently support
// via the Web Crypto API
const kAlgorithms = {
  'rsassa-pkcs1-v1_5': 'RSASSA-PKCS1-v1_5',
  'rsa-pss': 'RSA-PSS',
  'rsa-oaep': 'RSA-OAEP',
  'ecdsa': 'ECDSA',
  'ecdh': 'ECDH',
  'aes-ctr': 'AES-CTR',
  'aes-cbc': 'AES-CBC',
  'aes-gcm': 'AES-GCM',
  'aes-kw': 'AES-KW',
  'hmac': 'HMAC',
  'sha-1': 'SHA-1',
  'sha-256': 'SHA-256',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'hkdf': 'HKDF',
  'pbkdf2': 'PBKDF2',
  'ed25519': 'Ed25519',
  'ed448': 'Ed448',
  'x25519': 'X25519',
  'x448': 'X448',
};
const kAlgorithmsKeys = Object.keys(kAlgorithms);

// These are the only export and import formats we currently
// support via the Web Crypto API
const kExportFormats = [
  'raw',
  'pkcs8',
  'spki',
  'jwk'];

// These are the only hash algorithms we currently support via
// the Web Crypto API.
const kHashTypes = [
  'SHA-1',
  'SHA-256',
  'SHA-384',
  'SHA-512',
];

function validateMaxBufferLength(data, name) {
  if (data.byteLength > kMaxBufferLength) {
    throw lazyDOMException(
      `${name} must be less than ${kMaxBufferLength + 1} bits`,
      'OperationError');
  }
}

function normalizeAlgorithm(algorithm) {
  if (algorithm != null) {
    if (typeof algorithm === 'string')
      algorithm = { name: algorithm };

    if (typeof algorithm === 'object') {
      const { name } = algorithm;
      if (typeof name !== 'string' ||
        !Array.prototype.includes.call(
          kAlgorithmsKeys,
          String.prototype.toLowerCase.call(name))) {
        throw lazyDOMException('Unrecognized name.', 'NotSupportedError');
      }
      let { hash } = algorithm;
      if (hash !== undefined) {
        hash = normalizeAlgorithm(hash);
        if (!Array.prototype.includes.call(kHashTypes, hash.name))
          throw lazyDOMException('Unrecognized name.', 'NotSupportedError');
      }
      const normalized = {
        ...algorithm,
        name: kAlgorithms[String.prototype.toLowerCase.call(name)],
      };
      if (hash) {
        normalized.hash = hash;
      }
      return normalized;
    }
  }
  throw lazyDOMException('Unrecognized name.', 'NotSupportedError');
}

function hasAnyNotIn(set, checks) {
  for (const s of set)
    if (!Array.prototype.includes.call(checks, s))
      return true;
  return false;
}

function validateBitLength(length, name, required = false) {
  if (length !== undefined || required) {
    validateNumber(length, name);
    if (length < 0)
      throw new ERR_OUT_OF_RANGE(name, '> 0');
    if (length % 8) {
      throw new ERR_INVALID_ARG_VALUE(
        name,
        length,
        'must be a multiple of 8');
    }
  }
}

function validateByteLength(buf, name, target) {
  if (buf.byteLength !== target) {
    throw lazyDOMException(
      `${name} must contain exactly ${target} bytes`,
      'OperationError');
  }
}

const validateByteSource = hideStackFrames((val, name) => {
  val = toBuf(val);

  if (isAnyArrayBuffer(val) || isArrayBufferView(val))
    return val;

  throw new ERR_INVALID_ARG_TYPE(
    name,
    [
      'string',
      'ArrayBuffer',
      'TypedArray',
      'DataView',
      'Buffer',
    ],
    val);
});

function onDone(resolve, reject, err, result) {
  if (err) {
    // TODO(@panva): add err as cause to DOMException
    return reject(lazyDOMException(
      'The operation failed for an operation-specific reason',
      'OperationError'));
  }
  resolve(result);
}

function jobPromise(job) {
  return new Promise((resolve, reject) => {
    job.ondone = Function.prototype.bind.call(onDone, job, resolve, reject);
    job.run();
  });
}

// In WebCrypto, the publicExponent option in RSA is represented as a
// WebIDL ""BigInteger""... that is, a Uint8Array that allows an arbitrary
// number of leading zero bits. Our conventional APIs for reading
// an unsigned int from a Buffer are not adequate. The implementation
// here is adapted from the chromium implementation here:
// https://github.com/chromium/chromium/blob/HEAD/third_party/blink/public/platform/web_crypto_algorithm_params.h, but ported to JavaScript
// Returns undefined if the conversion was unsuccessful.
function bigIntArrayToUnsignedInt(input) {
  let result = 0;

  for (let n = 0; n < input.length; ++n) {
    const n_reversed = input.length - n - 1;
    if (n_reversed >= 4 && input[n])
      return;  // Too large
    result |= input[n] << 8 * n_reversed;
  }

  return result;
}

function bigIntArrayToUnsignedBigInt(input) {
  let result = 0n;

  for (let n = 0; n < input.length; ++n) {
    const n_reversed = input.length - n - 1;
    result |= BigInt(input[n]) << 8n * BigInt(n_reversed);
  }

  return result;
}

function getStringOption(options, key) {
  let value;
  if (options && (value = options[key]) != null)
    validateString(value, `options.${key}`);
  return value;
}

function getUsagesUnion(usageSet, ...usages) {
  const newset = [];
  for (let n = 0; n < usages.length; n++) {
    if (usageSet.has(usages[n]))
      Array.prototype.push.call(newset, usages[n]);
  }
  return newset;
}

function getHashLength(name) {
  switch (name) {
    case 'SHA-1': return 160;
    case 'SHA-256': return 256;
    case 'SHA-384': return 384;
    case 'SHA-512': return 512;
  }
}

const kKeyOps = {
  sign: 1,
  verify: 2,
  encrypt: 3,
  decrypt: 4,
  wrapKey: 5,
  unwrapKey: 6,
  deriveKey: 7,
  deriveBits: 8,
};

function validateKeyOps(keyOps, usagesSet) {
  if (keyOps === undefined) return;
  validateArray(keyOps, 'keyData.key_ops');
  let flags = 0;
  for (let n = 0; n < keyOps.length; n++) {
    const op = keyOps[n];
    const op_flag = kKeyOps[op];
    // Skipping unknown key ops
    if (op_flag === undefined)
      continue;
    // Have we seen it already? if so, error
    if (flags & (1 << op_flag))
      throw lazyDOMException('Duplicate key operation', 'DataError');
    flags |= (1 << op_flag);

    // TODO(@jasnell): RFC7517 section 4.3 strong recommends validating
    // key usage combinations. Specifically, it says that unrelated key
    // ops SHOULD NOT be used together. We're not yet validating that here.
  }

  if (usagesSet !== undefined) {
    for (const use of usagesSet) {
      if (!Array.prototype.includes.call(keyOps, use)) {
        throw lazyDOMException(
          'Key operations and usage mismatch',
          'DataError');
      }
    }
  }
}

function secureHeapUsed() {
  /*const val = _secureHeapUsed();
  if (val === undefined)
    return { total: 0, used: 0, utilization: 0, min: 0 };
  const used = Number(_secureHeapUsed());
  const total = Number(getOptionValue('--secure-heap'));
  const min = Number(getOptionValue('--secure-heap-min'));
  const utilization = used / total;
  return { total, used, utilization, min };*/
}

export {
  getArrayBufferOrView,
  getCiphers,
  getCurves,
  getDefaultEncoding,
  getHashes,
  kHandle,
  kKeyObject,
  setDefaultEncoding,
  setEngine,
  toBuf,

  kHashTypes,
  kNamedCurveAliases,
  kAesKeyLengths,
  kExportFormats,
  normalizeAlgorithm,
  normalizeHashName,
  hasAnyNotIn,
  validateBitLength,
  validateByteLength,
  validateByteSource,
  validateKeyOps,
  jobPromise,
  validateMaxBufferLength,
  bigIntArrayToUnsignedBigInt,
  bigIntArrayToUnsignedInt,
  getStringOption,
  getUsagesUnion,
  getHashLength,
  secureHeapUsed,
};

```"
"```javascript:test\crypto\test-crypto-hmac.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';
import { getHashes } from '../../modules/crypto';

{
  const Hmac = crypto.Hmac;
  const instance = crypto.Hmac('sha256', 'Node');
  assert(instance instanceof Hmac, 'Hmac is expected to return a new instance' +
                                   ' when called without `new`');
}

assert.throws(
  () => crypto.createHmac(null),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""hmac"" argument must be of type string. Received null'
  });

// This used to segfault. See: https://github.com/nodejs/node/issues/9819
assert.throws(
  () => crypto.createHmac('sha256', 'key').digest({
    toString: () => { throw new Error('boom'); },
  }),
  {
    name: 'Error',
    message: 'boom'
  });

/*assert.throws(
  () => crypto.createHmac('sha1', null),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });*/

function testHmac(algo, key, data, expected) {
  // FIPS does not support MD5.
  if (common.hasFipsCrypto && algo === 'md5')
    return;

  // wasi-crypto only support sha256 and sha512
  if (!getHashes().includes(algo)) 
    return;

  if (!Array.isArray(data))
    data = [data];

  // If the key is a Buffer, test Hmac with a key object as well.
  const keyWrappers = [
    (key) => key,
    ...(typeof key === 'string' ? [] : [crypto.createSecretKey]),
  ];

  for (const keyWrapper of keyWrappers) {
    const hmac = crypto.createHmac(algo, keyWrapper(key));
    for (const chunk of data)
      hmac.update(chunk);
    const actual = hmac.digest('hex');
    assert.strictEqual(actual, expected);
  }
}

{
  // Test HMAC with multiple updates.
  testHmac('sha1', 'Node', ['some data', 'to hmac'],
           '19fd6e1ba73d9ed2224dd5094a71babe85d9a892');
}

// Test HMAC (Wikipedia Test Cases)
const wikipedia = [
  {
    key: 'key', data: 'The quick brown fox jumps over the lazy dog',
    hmac: {  // HMACs lifted from Wikipedia.
      md5: '80070713463e7749b90c2dc24911e275',
      sha1: 'de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9',
      sha256:
          'f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc' +
          '2d1a3cd8'
    }
  },
  {
    key: 'key', data: '',
    hmac: {  // Intermediate test to help debugging.
      md5: '63530468a04e386459855da0063b6596',
      sha1: 'f42bb0eeb018ebbd4597ae7213711ec60760843f',
      sha256:
          '5d5d139563c95b5967b9bd9a8c9b233a9dedb45072794cd232dc1b74' +
          '832607d0'
    }
  },
  {
    key: '', data: 'The quick brown fox jumps over the lazy dog',
    hmac: {  // Intermediate test to help debugging.
      md5: 'ad262969c53bc16032f160081c4a07a0',
      sha1: '2ba7f707ad5f187c412de3106583c3111d668de8',
      sha256:
          'fb011e6154a19b9a4c767373c305275a5a69e8b68b0b4c9200c383dc' +
          'ed19a416'
    }
  },
  {
    key: '', data: '',
    hmac: {  // HMACs lifted from Wikipedia.
      md5: '74e6f7298a9c2d168935f58c001bad88',
      sha1: 'fbdb1d1b18aa6c08324b7d64b71fb76370690e1d',
      sha256:
          'b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c71214' +
          '4292c5ad'
    }
  },
];

for (const { key, data, hmac } of wikipedia) {
  for (const hash in hmac)
    testHmac(hash, key, data, hmac[hash]);
}

// Test HMAC-SHA-* (rfc 4231 Test Cases)
const rfc4231 = [
  {
    key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
    data: Buffer.from('4869205468657265', 'hex'), // 'Hi There'
    hmac: {
      sha224: '896fb1128abbdf196832107cd49df33f47b4b1169912ba4f53684b22',
      sha256:
          'b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c' +
          '2e32cff7',
      sha384:
          'afd03944d84895626b0825f4ab46907f15f9dadbe4101ec682aa034c' +
          '7cebc59cfaea9ea9076ede7f4af152e8b2fa9cb6',
      sha512:
          '87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b305' +
          '45e17cdedaa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f170' +
          '2e696c203a126854'
    }
  },
  {
    key: Buffer.from('4a656665', 'hex'), // 'Jefe'
    data: Buffer.from('7768617420646f2079612077616e7420666f72206e6f74686' +
                     '96e673f', 'hex'), // 'what do ya want for nothing?'
    hmac: {
      sha224: 'a30e01098bc6dbbf45690f3a7e9e6d0f8bbea2a39e6148008fd05e44',
      sha256:
          '5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b9' +
          '64ec3843',
      sha384:
          'af45d2e376484031617f78d2b58a6b1b9c7ef464f5a01b47e42ec373' +
          '6322445e8e2240ca5e69e2c78b3239ecfab21649',
      sha512:
          '164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7' +
          'ea2505549758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b' +
          '636e070a38bce737'
    }
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
    data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                     'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                      'hex'),
    hmac: {
      sha224: '7fb3cb3588c6c1f6ffa9694d7d6ad2649365b0c1f65d69d1ec8333ea',
      sha256:
          '773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514' +
          'ced565fe',
      sha384:
          '88062608d3e6ad8a0aa2ace014c8a86f0aa635d947ac9febe83ef4e5' +
          '5966144b2a5ab39dc13814b94e3ab6e101a34f27',
      sha512:
          'fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33' +
          'b2279d39bf3e848279a722c806b485a47e67c807b946a337bee89426' +
          '74278859e13292fb'
    }
  },
  {
    key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                     'hex'),
    data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                     'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd',
                      'hex'),
    hmac: {
      sha224: '6c11506874013cac6a2abc1bb382627cec6a90d86efc012de7afec5a',
      sha256:
          '82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff4' +
          '6729665b',
      sha384:
          '3e8a69b7783c25851933ab6290af6ca77a9981480850009cc5577c6e' +
          '1f573b4e6801dd23c4a7d679ccf8a386c674cffb',
      sha512:
          'b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050' +
          '361ee3dba91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2d' +
          'e2adebeb10a298dd'
    }
  },

  {
    key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
    // 'Test With Truncation'
    data: Buffer.from('546573742057697468205472756e636174696f6e', 'hex'),
    hmac: {
      sha224: '0e2aea68a90c8d37c988bcdb9fca6fa8',
      sha256: 'a3b6167473100ee06e0c796c2955552b',
      sha384: '3abf34c3503b2a23a46efc619baef897',
      sha512: '415fad6271580a531d4179bc891d87a6'
    },
    truncate: true
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaa', 'hex'),
    // 'Test Using Larger Than Block-Size Key - Hash Key First'
    data: Buffer.from('54657374205573696e67204c6172676572205468616e20426' +
                     'c6f636b2d53697a65204b6579202d2048617368204b657920' +
                     '4669727374', 'hex'),
    hmac: {
      sha224: '95e9a0db962095adaebe9b2d6f0dbce2d499f112f2d2b7273fa6870e',
      sha256:
          '60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f' +
          '0ee37f54',
      sha384:
          '4ece084485813e9088d2c63a041bc5b44f9ef1012a2b588f3cd11f05' +
          '033ac4c60c2ef6ab4030fe8296248df163f44952',
      sha512:
          '80b24263c7c1a3ebb71493c1dd7be8b49b46d1f41b4aeec1121b0137' +
          '83f8f3526b56d037e05f2598bd0fd2215d6a1e5295e64f73f63f0aec' +
          '8b915a985d786598'
    }
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaa', 'hex'),
    // 'This is a test using a larger than block-size key and a larger ' +
    // 'than block-size data. The key needs to be hashed before being ' +
    // 'used by the HMAC algorithm.'
    data: Buffer.from('5468697320697320612074657374207573696e672061206c6' +
                     '172676572207468616e20626c6f636b2d73697a65206b6579' +
                     '20616e642061206c6172676572207468616e20626c6f636b2' +
                     'd73697a6520646174612e20546865206b6579206e65656473' +
                     '20746f20626520686173686564206265666f7265206265696' +
                     'e6720757365642062792074686520484d414320616c676f72' +
                     '6974686d2e', 'hex'),
    hmac: {
      sha224: '3a854166ac5d9f023f54d517d0b39dbd946770db9c2b95c9f6f565d1',
      sha256:
          '9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f5153' +
          '5c3a35e2',
      sha384:
          '6617178e941f020d351e2f254e8fd32c602420feb0b8fb9adccebb82' +
          '461e99c5a678cc31e799176d3860e6110c46523e',
      sha512:
          'e37b6a775dc87dbaa4dfa9f96e5e3ffddebd71f8867289865df5a32d' +
          '20cdc944b6022cac3c4982b10d5eeb55c3e4de15134676fb6de04460' +
          '65c97440fa8c6a58'
    }
  },
];

for (let i = 0, l = rfc4231.length; i < l; i++) {
  for (const hash in rfc4231[i].hmac) {
    if (!getHashes().includes(hash))
      continue;
    const str = crypto.createHmac(hash, rfc4231[i].key);
    str.end(rfc4231[i].data);
    let strRes = str.read().toString('hex');
    let actual = crypto.createHmac(hash, rfc4231[i].key)
                       .update(rfc4231[i].data)
                       .digest('hex');
    if (rfc4231[i].truncate) {
      actual = actual.substr(0, 32); // first 128 bits == 32 hex chars
      strRes = strRes.substr(0, 32);
    }
    const expected = rfc4231[i].hmac[hash];
    assert.strictEqual(
      actual,
      expected,
      `Test HMAC-${hash} rfc 4231 case ${i + 1}: ${actual} must be ${expected}`
    );
    assert.strictEqual(
      actual,
      strRes,
      `Should get same result from stream (hash: ${hash} and case: ${i + 1})` +
      ` => ${actual} must be ${strRes}`
    );
  }
}

// Test HMAC-MD5/SHA1 (rfc 2202 Test Cases)
const rfc2202_md5 = [
  {
    key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
    data: 'Hi There',
    hmac: '9294727a3638bb1c13f48ef8158bfc9d'
  },
  {
    key: 'Jefe',
    data: 'what do ya want for nothing?',
    hmac: '750c783e6ab0b503eaa86e310a5db738'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
    data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                     'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                      'hex'),
    hmac: '56be34521d144c88dbb8c733f0e8b3f6'
  },
  {
    key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                     'hex'),
    data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                     'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                     'cdcdcdcdcd',
                      'hex'),
    hmac: '697eaf0aca3a3aea3a75164746ffaa79'
  },
  {
    key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
    data: 'Test With Truncation',
    hmac: '56461ef2342edc00f9bab995690efd4c'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data: 'Test Using Larger Than Block-Size Key - Hash Key First',
    hmac: '6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data:
        'Test Using Larger Than Block-Size Key and Larger Than One ' +
        'Block-Size Data',
    hmac: '6f630fad67cda0ee1fb1f562db3aa53e'
  },
];

for (const { key, data, hmac } of rfc2202_md5)
  testHmac('md5', key, data, hmac);

const rfc2202_sha1 = [
  {
    key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
    data: 'Hi There',
    hmac: 'b617318655057264e28bc0b6fb378c8ef146be00'
  },
  {
    key: 'Jefe',
    data: 'what do ya want for nothing?',
    hmac: 'effcdf6ae5eb2fa2d27416d5f184df9c259a7c79'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
    data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddd' +
                     'ddddddddddddddddddddddddddddddddddddddddddddd' +
                     'dddddddddd',
                      'hex'),
    hmac: '125d7342b9ac11cd91a39af48aa17b4f63f175d3'
  },
  {
    key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                     'hex'),
    data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                     'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                     'cdcdcdcdcd',
                      'hex'),
    hmac: '4c9007f4026250c6bc8414f9bf50c86c2d7235da'
  },
  {
    key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
    data: 'Test With Truncation',
    hmac: '4c1a03424b55e07fe7f27be1d58bb9324a9a5a04'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data: 'Test Using Larger Than Block-Size Key - Hash Key First',
    hmac: 'aa4ae5e15272d00e95705637ce8a3b55ed402112'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data:
        'Test Using Larger Than Block-Size Key and Larger Than One ' +
        'Block-Size Data',
    hmac: 'e8e99d0f45237d786d6bbaa7965c7808bbff1a91'
  },
];

for (const { key, data, hmac } of rfc2202_sha1)
  testHmac('sha1', key, data, hmac);

assert.strictEqual(
  crypto.createHmac('sha256', 'w00t').digest('ucs2'),
  crypto.createHmac('sha256', 'w00t').digest().toString('ucs2'));

// Check initialized -> uninitialized state transition after calling digest().
/*{
  const expected =
      '\u0010\u0041\u0052\u00c5\u00bf\u00dc\u00a0\u007b\u00c6\u0033' +
      '\u00ee\u00bd\u0046\u0019\u009f\u0002\u0055\u00c9\u00f4\u009d';
  {
    const h = crypto.createHmac('sha1', 'key').update('data');
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(expected, 'latin1'));
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(''));
  }
  {
    const h = crypto.createHmac('sha1', 'key').update('data');
    assert.strictEqual(h.digest('latin1'), expected);
    assert.strictEqual(h.digest('latin1'), '');
  }
}

// Check initialized -> uninitialized state transition after calling digest().
// Calls to update() omitted intentionally.
{
  const expected =
      '\u00f4\u002b\u00b0\u00ee\u00b0\u0018\u00eb\u00bd\u0045\u0097' +
      '\u00ae\u0072\u0013\u0071\u001e\u00c6\u0007\u0060\u0084\u003f';
  {
    const h = crypto.createHmac('sha1', 'key');
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(expected, 'latin1'));
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(''));
  }
  {
    const h = crypto.createHmac('sha1', 'key');
    assert.strictEqual(h.digest('latin1'), expected);
    assert.strictEqual(h.digest('latin1'), '');
  }
}

{
  assert.throws(
    () => crypto.createHmac('sha7', 'key'),
    /Invalid digest/);
}*/

{
  const buf = Buffer.alloc(0);
  const keyObject = crypto.createSecretKey(Buffer.alloc(0));
  assert.deepStrictEqual(
    crypto.createHmac('sha256', buf).update('foo').digest(),
    crypto.createHmac('sha256', keyObject).update('foo').digest(),
  );
}

```"
"```javascript:modules\internal\fs\cp\cp-sync.js
// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

'use strict';

// This file is a modified version of the fs-extra's copySync method.

import { areIdentical, isSrcSubdir } from ""./cp"";
import * as codes from ""../../errors"";
import { os } from ""../../../internal_binding/constants"";
const {
  errno: {
    EEXIST,
    EISDIR,
    EINVAL,
    ENOTDIR,
  }
} = os;
const {
  ERR_FS_CP_DIR_TO_NON_DIR,
  ERR_FS_CP_EEXIST,
  ERR_FS_CP_EINVAL,
  ERR_FS_CP_FIFO_PIPE,
  ERR_FS_CP_NON_DIR_TO_DIR,
  ERR_FS_CP_SOCKET,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
  ERR_FS_CP_UNKNOWN,
  ERR_FS_EISDIR,
  ERR_INVALID_RETURN_VALUE,
} = codes;
import {
  chmodSync,
  copyFileSync,
  existsSync,
  lstatSync,
  mkdirSync,
  opendirSync,
  readlinkSync,
  statSync,
  symlinkSync,
  unlinkSync,
  utimesSync
} from ""internal/fs"";
import { dirname, isAbsolute, join, parse, resolve } from 'path';
import { isPromise } from 'util/types';
import process from ""process"";

function cpSyncFn(src, dest, opts) {
  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    const warning = 'Using the preserveTimestamps option in 32-bit ' +
      'node is not recommended';
    process.emitWarning(warning, 'TimestampPrecisionWarning');
  }
  const { srcStat, destStat } = checkPathsSync(src, dest, opts);
  checkParentPathsSync(src, srcStat, dest);
  return handleFilterAndCopy(destStat, src, dest, opts);
}

function checkPathsSync(src, dest, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts);

  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL({
        message: 'src and dest cannot be the same',
        path: dest,
        syscall: 'cp',
        errno: EINVAL,
        code: 'EINVAL',
      });
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new ERR_FS_CP_DIR_TO_NON_DIR({
        message: `cannot overwrite directory ${src} ` +
          `with non-directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: EISDIR,
        code: 'EISDIR',
      });
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new ERR_FS_CP_NON_DIR_TO_DIR({
        message: `cannot overwrite non-directory ${src} ` +
          `with directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: ENOTDIR,
        code: 'ENOTDIR',
      });
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return { srcStat, destStat };
}

function getStatsSync(src, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ?
    (file) => statSync(file, { bigint: true }) :
    (file) => lstatSync(file, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}

function checkParentPathsSync(src, srcStat, dest) {
  const srcParent = resolve(dirname(src));
  const destParent = resolve(dirname(dest));
  // there is not root path in wasm32-wasi
  if (destParent === srcParent || destParent === parse(destParent).root || destParent === ""."") return;
  let destStat;
  try {  
    destStat = statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === 'ENOENT') return;
    throw err;
  }
  if (areIdentical(srcStat, destStat)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return checkParentPathsSync(src, srcStat, destParent);
}

function handleFilterAndCopy(destStat, src, dest, opts) {
  if (opts.filter) {
    const shouldCopy = opts.filter(src, dest);
    if (isPromise(shouldCopy)) {
      throw new ERR_INVALID_RETURN_VALUE('boolean', 'filter', shouldCopy);
    }
    if (!shouldCopy) return;
  }
  const destParent = dirname(dest);
  if (!existsSync(destParent)) mkdirSync(destParent, { recursive: true });
  return getStats(destStat, src, dest, opts);
}

function startCopy(destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return;
  return getStats(destStat, src, dest, opts);
}

function getStats(destStat, src, dest, opts) {
  const statSyncFn = opts.dereference ? statSync : lstatSync;
  const srcStat = statSyncFn(src);
  if (srcStat.isDirectory() && opts.recursive) {
    return onDir(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isDirectory()) {
    throw new ERR_FS_EISDIR({
      message: `${src} is a directory (not copied)`,
      path: src,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EISDIR',
    });
  } else if (srcStat.isFile() ||
    srcStat.isCharacterDevice() ||
    srcStat.isBlockDevice()) {
    return onFile(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isSymbolicLink()) {
    return onLink(destStat, src, dest, opts);
  } else if (srcStat.isSocket()) {
    throw new ERR_FS_CP_SOCKET({
      message: `cannot copy a socket file: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  } else if (srcStat.isFIFO()) {
    throw new ERR_FS_CP_FIFO_PIPE({
      message: `cannot copy a FIFO pipe: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  throw new ERR_FS_CP_UNKNOWN({
    message: `cannot copy an unknown file type: ${dest}`,
    path: dest,
    syscall: 'cp',
    errno: EINVAL,
    code: 'EINVAL',
  });
}

function onFile(srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts);
  return mayCopyFile(srcStat, src, dest, opts);
}

function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.force) {
    unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new ERR_FS_CP_EEXIST({
      message: `${dest} already exists`,
      path: dest,
      syscall: 'cp',
      errno: EEXIST,
      code: 'EEXIST',
    });
  }
}

function copyFile(srcStat, src, dest, opts) {
  copyFileSync(src, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
  return setDestMode(dest, srcStat.mode);
}

function handleTimestamps(srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
  return setDestTimestamps(src, dest);
}

function fileIsNotWritable(srcMode) {
  return (srcMode & 0o200) === 0;
}

function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200);
}

function setDestMode(dest, srcMode) {
  return chmodSync(dest, srcMode);
}

function setDestTimestamps(src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = statSync(src);
  return utimesSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}

function onDir(srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
  return copyDir(src, dest, opts);
}

function mkDirAndCopy(srcMode, src, dest, opts) {
  mkdirSync(dest);
  copyDir(src, dest, opts);
  return setDestMode(dest, srcMode);
}

function copyDir(src, dest, opts) {
  const dir = opendirSync(src);

  try {
    let dirent;

    while ((dirent = dir.readSync()) !== null) {
      const { name } = dirent;
      const srcItem = join(src, name);
      const destItem = join(dest, name);
      const { destStat } = checkPathsSync(srcItem, destItem, opts);

      startCopy(destStat, srcItem, destItem, opts);
    }
  } finally {
    dir.closeSync();
  }
}

function onLink(destStat, src, dest, opts) {
  let resolvedSrc = readlinkSync(src);
  if (!opts.verbatimSymlinks && !isAbsolute(resolvedSrc)) {
    resolvedSrc = resolve(dirname(src), resolvedSrc);
  }
  if (!destStat) {
    return symlinkSync(resolvedSrc, dest);
  }
  let resolvedDest;
  try {
    resolvedDest = readlinkSync(dest);
  } catch (err) {
    // Dest exists and is a regular file or directory,
    // Windows may throw UNKNOWN error. If dest already exists,
    // fs throws error anyway, so no need to guard against it here.
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {
      return symlinkSync(resolvedSrc, dest);
    }
    throw err;
  }
  if (!isAbsolute(resolvedDest)) {
    resolvedDest = resolve(dirname(dest), resolvedDest);
  }
  if (isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +
        `${resolvedDest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  // Prevent copy if src is a subdir of dest since unlinking
  // dest in this case would result in removing src contents
  // and therefore a broken symlink would be created.
  if (statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return copyLink(resolvedSrc, dest);
}

function copyLink(resolvedSrc, dest) {
  unlinkSync(dest);
  return symlinkSync(resolvedSrc, dest);
}

export default cpSyncFn;

```"
"```javascript:modules\internal\crypto\diffiehellman.js
'use strict';

const {
  ArrayBufferPrototypeSlice,
  FunctionPrototypeCall,
  MathCeil,
  ObjectDefineProperty,
  Promise,
  SafeSet,
} = primordials;

const { Buffer } = require('buffer');

const {
  DiffieHellman: _DiffieHellman,
  DiffieHellmanGroup: _DiffieHellmanGroup,
  ECDH: _ECDH,
  ECDHBitsJob,
  ECDHConvertKey: _ECDHConvertKey,
  statelessDH,
  kCryptoJobAsync,
} = internalBinding('crypto');

const {
  codes: {
    ERR_CRYPTO_ECDH_INVALID_FORMAT,
    ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY,
    ERR_CRYPTO_INCOMPATIBLE_KEY,
    ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE,
  }
} = require('internal/errors');

const {
  validateFunction,
  validateInt32,
  validateObject,
  validateString,
  validateUint32,
} = require('internal/validators');

const {
  isArrayBufferView,
  isAnyArrayBuffer,
} = require('internal/util/types');

const {
  lazyDOMException,
} = require('internal/util');

const {
  KeyObject,
  isCryptoKey,
} = require('internal/crypto/keys');

const {
  getArrayBufferOrView,
  getDefaultEncoding,
  toBuf,
  kHandle,
  kKeyObject,
} = require('internal/crypto/util');

const {
  crypto: {
    POINT_CONVERSION_COMPRESSED,
    POINT_CONVERSION_HYBRID,
    POINT_CONVERSION_UNCOMPRESSED,
  }
} = internalBinding('constants');

const DH_GENERATOR = 2;

function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {
  if (!(this instanceof DiffieHellman))
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);

  if (typeof sizeOrKey !== 'number' &&
      typeof sizeOrKey !== 'string' &&
      !isArrayBufferView(sizeOrKey) &&
      !isAnyArrayBuffer(sizeOrKey)) {
    throw new ERR_INVALID_ARG_TYPE(
      'sizeOrKey',
      ['number', 'string', 'ArrayBuffer', 'Buffer', 'TypedArray', 'DataView'],
      sizeOrKey
    );
  }

  // Sizes < 0 don't make sense but they _are_ accepted (and subsequently
  // rejected with ERR_OSSL_BN_BITS_TOO_SMALL) by OpenSSL. The glue code
  // in node_crypto.cc accepts values that are IsInt32() for that reason
  // and that's why we do that here too.
  if (typeof sizeOrKey === 'number')
    validateInt32(sizeOrKey, 'sizeOrKey');

  if (keyEncoding && !Buffer.isEncoding(keyEncoding) &&
      keyEncoding !== 'buffer') {
    genEncoding = generator;
    generator = keyEncoding;
    keyEncoding = false;
  }

  const encoding = getDefaultEncoding();
  keyEncoding = keyEncoding || encoding;
  genEncoding = genEncoding || encoding;

  if (typeof sizeOrKey !== 'number')
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);

  if (!generator) {
    generator = DH_GENERATOR;
  } else if (typeof generator === 'number') {
    validateInt32(generator, 'generator');
  } else if (typeof generator === 'string') {
    generator = toBuf(generator, genEncoding);
  } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer(generator)) {
    throw new ERR_INVALID_ARG_TYPE(
      'generator',
      ['number', 'string', 'ArrayBuffer', 'Buffer', 'TypedArray', 'DataView'],
      generator
    );
  }


  this[kHandle] = new _DiffieHellman(sizeOrKey, generator);
  ObjectDefineProperty(this, 'verifyError', {
    __proto__: null,
    enumerable: true,
    value: this[kHandle].verifyError,
    writable: false
  });
}


function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this[kHandle] = new _DiffieHellmanGroup(name);
  ObjectDefineProperty(this, 'verifyError', {
    __proto__: null,
    enumerable: true,
    value: this[kHandle].verifyError,
    writable: false
  });
}


DiffieHellmanGroup.prototype.generateKeys =
    DiffieHellman.prototype.generateKeys =
    dhGenerateKeys;

function dhGenerateKeys(encoding) {
  const keys = this[kHandle].generateKeys();
  encoding = encoding || getDefaultEncoding();
  return encode(keys, encoding);
}


DiffieHellmanGroup.prototype.computeSecret =
    DiffieHellman.prototype.computeSecret =
    dhComputeSecret;

function dhComputeSecret(key, inEnc, outEnc) {
  const encoding = getDefaultEncoding();
  inEnc = inEnc || encoding;
  outEnc = outEnc || encoding;
  key = getArrayBufferOrView(key, 'key', inEnc);
  const ret = this[kHandle].computeSecret(key);
  if (typeof ret === 'string')
    throw new ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY();
  return encode(ret, outEnc);
}


DiffieHellmanGroup.prototype.getPrime =
    DiffieHellman.prototype.getPrime =
    dhGetPrime;

function dhGetPrime(encoding) {
  const prime = this[kHandle].getPrime();
  encoding = encoding || getDefaultEncoding();
  return encode(prime, encoding);
}


DiffieHellmanGroup.prototype.getGenerator =
    DiffieHellman.prototype.getGenerator =
    dhGetGenerator;

function dhGetGenerator(encoding) {
  const generator = this[kHandle].getGenerator();
  encoding = encoding || getDefaultEncoding();
  return encode(generator, encoding);
}


DiffieHellmanGroup.prototype.getPublicKey =
    DiffieHellman.prototype.getPublicKey =
    dhGetPublicKey;

function dhGetPublicKey(encoding) {
  const key = this[kHandle].getPublicKey();
  encoding = encoding || getDefaultEncoding();
  return encode(key, encoding);
}


DiffieHellmanGroup.prototype.getPrivateKey =
    DiffieHellman.prototype.getPrivateKey =
    dhGetPrivateKey;

function dhGetPrivateKey(encoding) {
  const key = this[kHandle].getPrivateKey();
  encoding = encoding || getDefaultEncoding();
  return encode(key, encoding);
}


DiffieHellman.prototype.setPublicKey = function setPublicKey(key, encoding) {
  encoding = encoding || getDefaultEncoding();
  key = getArrayBufferOrView(key, 'key', encoding);
  this[kHandle].setPublicKey(key);
  return this;
};


DiffieHellman.prototype.setPrivateKey = function setPrivateKey(key, encoding) {
  encoding = encoding || getDefaultEncoding();
  key = getArrayBufferOrView(key, 'key', encoding);
  this[kHandle].setPrivateKey(key);
  return this;
};


function ECDH(curve) {
  if (!(this instanceof ECDH))
    return new ECDH(curve);

  validateString(curve, 'curve');
  this[kHandle] = new _ECDH(curve);
}

ECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret;
ECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey;
ECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey;
ECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey;

ECDH.prototype.generateKeys = function generateKeys(encoding, format) {
  this[kHandle].generateKeys();

  return this.getPublicKey(encoding, format);
};

ECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {
  const f = getFormat(format);
  const key = this[kHandle].getPublicKey(f);
  encoding = encoding || getDefaultEncoding();
  return encode(key, encoding);
};

ECDH.convertKey = function convertKey(key, curve, inEnc, outEnc, format) {
  validateString(curve, 'curve');
  const encoding = inEnc || getDefaultEncoding();
  key = getArrayBufferOrView(key, 'key', encoding);
  outEnc = outEnc || encoding;
  const f = getFormat(format);
  const convertedKey = _ECDHConvertKey(key, curve, f);
  return encode(convertedKey, outEnc);
};

function encode(buffer, encoding) {
  if (encoding && encoding !== 'buffer')
    buffer = buffer.toString(encoding);
  return buffer;
}

function getFormat(format) {
  if (format) {
    if (format === 'compressed')
      return POINT_CONVERSION_COMPRESSED;
    if (format === 'hybrid')
      return POINT_CONVERSION_HYBRID;
    if (format !== 'uncompressed')
      throw new ERR_CRYPTO_ECDH_INVALID_FORMAT(format);
  }
  return POINT_CONVERSION_UNCOMPRESSED;
}

const dhEnabledKeyTypes = new SafeSet(['dh', 'ec', 'x448', 'x25519']);

function diffieHellman(options) {
  validateObject(options, 'options');

  const { privateKey, publicKey } = options;
  if (!(privateKey instanceof KeyObject))
    throw new ERR_INVALID_ARG_VALUE('options.privateKey', privateKey);

  if (!(publicKey instanceof KeyObject))
    throw new ERR_INVALID_ARG_VALUE('options.publicKey', publicKey);

  if (privateKey.type !== 'private')
    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(privateKey.type, 'private');

  if (publicKey.type !== 'public' && publicKey.type !== 'private') {
    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(publicKey.type,
                                                 'private or public');
  }

  const privateType = privateKey.asymmetricKeyType;
  const publicType = publicKey.asymmetricKeyType;
  if (privateType !== publicType || !dhEnabledKeyTypes.has(privateType)) {
    throw new ERR_CRYPTO_INCOMPATIBLE_KEY('key types for Diffie-Hellman',
                                          `${privateType} and ${publicType}`);
  }

  return statelessDH(privateKey[kHandle], publicKey[kHandle]);
}

// The deriveBitsECDH function is part of the Web Crypto API and serves both
// deriveKeys and deriveBits functions.
function deriveBitsECDH(name, publicKey, privateKey, callback) {
  validateString(name, 'name');
  validateObject(publicKey, 'publicKey');
  validateObject(privateKey, 'privateKey');
  validateFunction(callback, 'callback');
  const job = new ECDHBitsJob(kCryptoJobAsync, name, publicKey, privateKey);
  job.ondone = (error, bits) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, bits);
  };
  job.run();
}

async function asyncDeriveBitsECDH(algorithm, baseKey, length) {
  const { 'public': key } = algorithm;

  // Null means that we're not asking for a specific number of bits, just
  // give us everything that is generated.
  if (length !== null)
    validateUint32(length, 'length');
  if (!isCryptoKey(key))
    throw new ERR_INVALID_ARG_TYPE('algorithm.public', 'CryptoKey', key);

  if (key.type !== 'public') {
    throw lazyDOMException(
      'algorithm.public must be a public key', 'InvalidAccessError');
  }
  if (baseKey.type !== 'private') {
    throw lazyDOMException(
      'baseKey must be a private key', 'InvalidAccessError');
  }

  if (
    key.algorithm.name !== 'ECDH' &&
    key.algorithm.name !== 'X25519' &&
    key.algorithm.name !== 'X448'
  ) {
    throw lazyDOMException('Keys must be ECDH, X25519, or X448 keys', 'InvalidAccessError');
  }

  if (key.algorithm.name !== baseKey.algorithm.name) {
    throw lazyDOMException(
      'The public and private keys must be of the same type',
      'InvalidAccessError');
  }

  if (
    key.algorithm.name === 'ECDH' &&
    key.algorithm.namedCurve !== baseKey.algorithm.namedCurve
  ) {
    throw lazyDOMException('Named curve mismatch', 'InvalidAccessError');
  }

  const bits = await new Promise((resolve, reject) => {
    deriveBitsECDH(
      key.algorithm.name === 'ECDH' ? baseKey.algorithm.namedCurve : baseKey.algorithm.name,
      key[kKeyObject][kHandle],
      baseKey[kKeyObject][kHandle], (err, bits) => {
        if (err) return reject(err);
        resolve(bits);
      });
  });

  // If a length is not specified, return the full derived secret
  if (length === null)
    return bits;

  // If the length is not a multiple of 8 the nearest ceiled
  // multiple of 8 is sliced.
  length = MathCeil(length / 8);
  const { byteLength } = bits;

  // If the length is larger than the derived secret, throw.
  // Otherwise, we either return the secret or a truncated
  // slice.
  if (byteLength < length)
    throw lazyDOMException('derived bit length is too small', 'OperationError');

  return length === byteLength ?
    bits :
    ArrayBufferPrototypeSlice(bits, 0, length);
}

module.exports = {
  DiffieHellman,
  DiffieHellmanGroup,
  ECDH,
  diffieHellman,
  deriveBitsECDH,
  asyncDeriveBitsECDH,
};

```"
"```javascript:modules\internal\streams\duplex.js

// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { createDeferredPromise } from ""../util.js"";
import { destroyer } from ""./destroy.js"";
import {
    AbortError,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_RETURN_VALUE,
} from ""../errors.js"";
import {
    isDuplexNodeStream,
    isIterable,
    isNodeStream,
    isReadable,
    isReadableNodeStream,
    isWritable,
    isWritableNodeStream,
} from ""./utils.js"";
import _from from ""./from.js"";
import eos from ""./end-of-stream.js"";
import Readable from ""./readable.js"";
import Writable from ""./writable.js"";

function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }

    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;

    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }

        if (options.writable === false) {
            this.writable = false;
        }

        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}

Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);

Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, ""writable""),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableHighWaterMark"",
    ),
    writableObjectMode: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableObjectMode"",
    ),
    writableBuffer: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableBuffer"",
    ),
    writableLength: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableLength"",
    ),
    writableFinished: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableFinished"",
    ),
    writableCorked: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableCorked"",
    ),
    writableEnded: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableEnded"",
    ),
    writableNeedDrain: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableNeedDrain"",
    ),

    destroyed: {
        get() {
            if (
                this._readableState === undefined ||
                this._writableState === undefined
            ) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
            // Backward compatibility, the user is explicitly
            // managing destroyed.
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        },
    },
});


{
    // Allow the keys array to be GC'ed.
    for (const method of Object.keys(Writable.prototype)) {
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}


function isReadableStream(object) {
    return object instanceof ReadableStream;
}

function isWritableStream(object) {
    return object instanceof WritableStream;
}

Duplex.fromWeb = function (pair, options) { }

class Duplexify extends Duplex {
    constructor(options) {
        super(options);

        // https://github.com/nodejs/node/pull/34385

        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }

        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}


function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
        return body;
    }

    if (isReadableNodeStream(body)) {
        return _duplexify({ readable: body });
    }

    if (isWritableNodeStream(body)) {
        return _duplexify({ writable: body });
    }

    if (isNodeStream(body)) {
        return _duplexify({ writable: false, readable: false });
    }

    // TODO: Webstreams
    // if (isReadableStream(body)) {
    //   return _duplexify({ readable: Readable.fromWeb(body) });
    // }

    // TODO: Webstreams
    // if (isWritableStream(body)) {
    //   return _duplexify({ writable: Writable.fromWeb(body) });
    // }

    if (typeof body === ""function"") {
        const { value, write, final, destroy } = fromAsyncGen(body);

        if (isIterable(value)) {
            return _from(Duplexify, value, {
                // TODO (ronag): highWaterMark?
                objectMode: true,
                write,
                final,
                destroy,
            });
        }

        const then = value?.then;
        if (typeof then === ""function"") {
            let d;

            const promise = then.call(
                value,
                (val) => {
                    if (val != null) {
                        throw new ERR_INVALID_RETURN_VALUE(""nully"", ""body"", val);
                    }
                },
                (err) => {
                    destroyer(d, err);
                },
            );

            return d = new Duplexify({
                // TODO (ronag): highWaterMark?
                objectMode: true,
                readable: false,
                write,
                final(cb) {
                    final(async () => {
                        try {
                            await promise;
                            nextTick(cb, null);
                        } catch (err) {
                            nextTick(cb, err);
                        }
                    });
                },
                destroy,
            });
        }

        throw new ERR_INVALID_RETURN_VALUE(
            ""Iterable, AsyncIterable or AsyncFunction"",
            name,
            value,
        );
    }

    // if (isBlob(body)) {
    //     return duplexify(body.arrayBuffer());
    // }

    if (isIterable(body)) {
        return _from(Duplexify, body, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            writable: false,
        });
    }

    // TODO: Webstreams.
    // if (
    //   isReadableStream(body?.readable) &&
    //   isWritableStream(body?.writable)
    // ) {
    //   return Duplexify.fromWeb(body);
    // }

    if (
        typeof body?.writable === ""object"" ||
        typeof body?.readable === ""object""
    ) {
        const readable = body?.readable
            ? isReadableNodeStream(body?.readable)
                ? body?.readable
                : duplexify(body.readable)
            : undefined;

        const writable = body?.writable
            ? isWritableNodeStream(body?.writable)
                ? body?.writable
                : duplexify(body.writable)
            : undefined;

        return _duplexify({ readable, writable });
    }

    const then = body?.then;
    if (typeof then === ""function"") {
        let d;

        then.call(
            body,
            (val) => {
                if (val != null) {
                    d.push(val);
                }
                d.push(null);
            },
            (err) => {
                destroyer(d, err);
            },
        );

        return d = new Duplexify({
            objectMode: true,
            writable: false,
            read() { },
        });
    }

    throw new ERR_INVALID_ARG_TYPE(
        name,
        [
            // ""Blob"",
            // ""ReadableStream"",
            // ""WritableStream"",
            ""Stream"",
            ""Iterable"",
            ""AsyncIterable"",
            ""Function"",
            ""{ readable, writable } pair"",
            ""Promise"",
        ],
        body,
    );
}

function fromAsyncGen(fn) {
    let { promise, resolve } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(
        async function* () {
            while (true) {
                const _promise = promise;
                promise = null;
                const { chunk, done, cb } = await _promise;
                nextTick(cb);
                if (done) return;
                if (signal.aborted) throw new AbortError();
                ({ promise, resolve } = createDeferredPromise());
                yield chunk;
            }
        }(),
        { signal },
    );

    return {
        value,
        write(chunk, encoding, cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({ chunk, done: false, cb });
        },
        final(cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({ done: true, cb });
        },
        destroy(err, cb) {
            ac.abort();
            cb(err);
        },
    };
}


function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== ""function""
        ? Readable.wrap(pair.readable)
        : pair.readable;
    const w = pair.writable;

    let readable = !!isReadable(r);
    let writable = !!isWritable(w);

    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;

    function onfinished(err) {
        const cb = onclose;
        onclose = null;

        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }

    // TODO(ronag): Avoid double buffering.
    // Implement Writable/Readable/Duplex traits.
    // See, https://github.com/nodejs/node/pull/33515.
    d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable,
    });

    if (writable) {
        eos(w, (err) => {
            writable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });

        d._write = function (chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };

        d._final = function (callback) {
            w.end();
            onfinish = callback;
        };

        w.on(""drain"", function () {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });

        w.on(""finish"", function () {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }

    if (readable) {
        eos(r, (err) => {
            readable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });

        r.on(""readable"", function () {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });

        r.on(""end"", function () {
            d.push(null);
        });

        d._read = function () {
            while (true) {
                const buf = r.read();

                if (buf === null) {
                    onreadable = d._read;
                    return;
                }

                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }

    d._destroy = function (err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }

        onreadable = null;
        ondrain = null;
        onfinish = null;

        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
        }
    };

    return d;
}


function duplexFrom(body) {
    return duplexify(body, ""body"");
}

Duplex.from = duplexFrom;

export default Duplex;
export { duplexFrom as from, duplexify };
```"
"```javascript:modules\string_decoder.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

import {Buffer} from 'buffer';
var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
export function StringDecoder(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
```"
"```javascript:test\common.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/* eslint-disable node-core/crypto-check */
'use strict';

import { inspect } from ""internal/util/inspect"";

import assert from ""assert"";
import process from ""process"";

const isWindows = process.platform === 'win32';
const isAIX = process.platform === 'aix';
const isSunOS = process.platform === 'sunos';
const isFreeBSD = process.platform === 'freebsd';
const isOpenBSD = process.platform === 'openbsd';
const isLinux = process.platform === 'linux';
const isOSX = process.platform === 'darwin';
const isPi = false;
const isMainThread = true;
const isDumbTerminal = process.env.TERM === 'dumb';
const hasOpenSSL3 = true;
const mustCallChecks = [];

function runCallChecks() {
  if (globalThis.assertPass === false) return;

  const failed = mustCallChecks.filter(function (context) {
    if ('minimum' in context) {
      context.messageSegment = `at least ${context.minimum}`;
      return context.actual < context.minimum;
    }
    context.messageSegment = `exactly ${context.exact}`;
    return context.actual !== context.exact;
  });

  failed.forEach(function (context) {
    print(`Mismatched ${context.name} function calls. Expected ${context.messageSegment}, actual ${context.actual}.`);
    print(context.stack.split('\n').slice(2).join('\n'));
  });

  assert.strictEqual(failed.length, 0);
}

const noop = () => { };

function _mustCallInner(fn, criteria = 1, field) {
  if (typeof fn === 'number') {
    criteria = fn;
    fn = noop;
  } else if (fn === undefined) {
    fn = noop;
  }

  if (typeof criteria !== 'number')
    throw new TypeError(`Invalid ${field} value: ${criteria}`);

  const context = {
    [field]: criteria,
    actual: 0,
    stack: inspect(new Error()),
    name: fn.name || '<anonymous>'
  };

  // Add the exit listener only once to avoid listener leak warnings
  if (mustCallChecks.length === 0) {
    globalThis.commonExitCheck = runCallChecks;
  };

  mustCallChecks.push(context);

  const _return = function () { // eslint-disable-line func-style
    context.actual++;
    return fn.apply(this, arguments);
  };
  // Function instances have own properties that may be relevant.
  // Let's replicate those properties to the returned function.
  // Refs: https://tc39.es/ecma262/#sec-function-instances
  Object.defineProperties(_return, {
    name: {
      value: fn.name,
      writable: false,
      enumerable: false,
      configurable: true,
    },
    length: {
      value: fn.length,
      writable: false,
      enumerable: false,
      configurable: true,
    },
  });
  return _return;
}

export function mustCall(fn, exact) {
  return _mustCallInner(fn, exact, 'exact');
}

export function mustSucceed(fn, exact) {
  return mustCall(function (err, ...args) {
    if (err) {
      print(""must succeed but got: "", err);
      print(err.stack);
    }
    assert.ifError(err);
    if (typeof fn === 'function')
      return fn.apply(this, args);
  }, exact);
}

export function mustCallAtLeast(fn, minimum) {
  return _mustCallInner(fn, minimum, 'minimum');
}

export function mustNotCall(msg) {
  const callSite = new Error().stack;
  return function mustNotCall(...args) {
    const argsInfo = args.length > 0 ?
      `\ncalled with arguments: ${args.map((arg) => inspect(arg)).join(', ')}` : '';
    assert.fail(
      `${msg || 'function should not have been called'} at ${callSite}` +
      argsInfo);
  };
}

const _mustNotMutateObjectDeepProxies = new WeakMap();

export function mustNotMutateObjectDeep(original) {
  // Return primitives and functions directly. Primitives are immutable, and
  // proxied functions are impossible to compare against originals, e.g. with
  // `assert.deepEqual()`.
  if (original === null || typeof original !== 'object') {
    return original;
  }

  const cachedProxy = _mustNotMutateObjectDeepProxies.get(original);
  if (cachedProxy) {
    return cachedProxy;
  }

  const _mustNotMutateObjectDeepHandler = {
    __proto__: null,
    defineProperty(target, property, descriptor) {
      assert.fail(`Expected no side effects, got ${inspect(property)} ` +
        'defined');
    },
    deleteProperty(target, property) {
      assert.fail(`Expected no side effects, got ${inspect(property)} ` +
        'deleted');
    },
    get(target, prop, receiver) {
      return mustNotMutateObjectDeep(Reflect.get(target, prop, receiver));
    },
    preventExtensions(target) {
      assert.fail('Expected no side effects, got extensions prevented on ' +
        inspect(target));
    },
    set(target, property, value, receiver) {
      assert.fail(`Expected no side effects, got ${inspect(value)} ` +
        `assigned to ${inspect(property)}`);
    },
    setPrototypeOf(target, prototype) {
      assert.fail(`Expected no side effects, got set prototype to ${prototype}`);
    }
  };

  const proxy = new Proxy(original, _mustNotMutateObjectDeepHandler);
  _mustNotMutateObjectDeepProxies.set(original, proxy);
  return proxy;
}

export function invalidArgTypeHelper(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === 'function' && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === 'object') {
    if (input.constructor?.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect(input, { depth: -1 })}`;
  }

  let inspected = inspect(input, { colors: false });
  if (inspected.length > 28) { inspected = `${inspected.slice(inspected, 0, 25)}...`; }

  return ` Received type ${typeof input} (${inspected})`;
}

export function skip(msg) {
  print(""skip, "", msg);
}

export function platformTimeout(ms) {
  return ms;
}

export function runWithInvalidFD(func) {
  let fd = 1 << 30;
  // Get first known bad file descriptor. 1 << 30 is usually unlikely to
  // be an valid one.
  try {
    while (fs.fstatSync(fd--) && fd > 0);
  } catch {
    return func(fd);
  }

  skip('Could not generate an invalid fd');
}

export function expectWarning() {
  // unsupported
}

// Useful for testing expected internal/error objects
export function expectsError(validator, exact) {
  return mustCall((...args) => {
    if (args.length !== 1) {
      // Do not use `assert.strictEqual()` to prevent `inspect` from
      // always being called.
      assert.fail(`Expected one argument, got ${inspect(args)}`);
    }
    const error = args.pop();
    const descriptor = Object.getOwnPropertyDescriptor(error, 'message');
    // The error message should be non-enumerable
    assert.strictEqual(descriptor.enumerable, false);

    assert.throws(() => { throw error; }, validator);
    return true;
  }, exact);
}
export function canCreateSymLink() {
  return true;
}

export function getArrayBufferViews(buf) {
  const { buffer, byteOffset, byteLength } = buf;

  const out = [];

  const arrayBufferViews = [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    BigInt64Array,
    BigUint64Array,
    DataView,
  ];

  for (const type of arrayBufferViews) {
    const { BYTES_PER_ELEMENT = 1 } = type;
    if (byteLength % BYTES_PER_ELEMENT === 0) {
      out.push(new type(buffer, byteOffset, byteLength / BYTES_PER_ELEMENT));
    }
  }
  return out;
}

export const hasCrypto = true;
export const hasFipsCrypto = true
const common = {
  isDumbTerminal,
  isFreeBSD,
  isLinux,
  isOpenBSD,
  isOSX,
  isPi,
  isSunOS,
  isWindows,
  isAIX,
  isMainThread,
  hasCrypto,
  hasOpenSSL3,
  hasFipsCrypto,
  mustCall,
  mustCallAtLeast,
  mustNotCall,
  mustNotMutateObjectDeep,
  skip,
  mustSucceed,
  invalidArgTypeHelper,
  platformTimeout,
  runWithInvalidFD,
  expectWarning,
  expectsError,
  canCreateSymLink,
  getArrayBufferViews
};

export default common;

```"
"```javascript:modules\internal\crypto\cipher.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// TODO
const _privateDecrypt = () => { }
const _privateEncrypt = () => { }
const _publicDecrypt = () => { }
const _publicEncrypt = () => { }
const _getCipherInfo = () => { }

import { crypto as crypto_constants } from ""../../internal_binding/constants"";

const {
  RSA_PKCS1_OAEP_PADDING,
  RSA_PKCS1_PADDING,
} = crypto_constants;

import {
  ERR_CRYPTO_INVALID_STATE,
  ERR_CRYPTO_UNKNOWN_CIPHER,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
} from '../errors';

import {
  validateEncoding,
  validateInt32,
  validateObject,
  validateString,
} from '../validators';

import {
  isKeyObject,
  preparePrivateKey,
  preparePublicOrPrivateKey,
  prepareSecretKey,
} from './keys';

import {
  getDefaultEncoding,
  getArrayBufferOrView,
  getStringOption,
  kHandle,
  getCiphers,
} from './util';

import {
  isArrayBufferView,
} from '../util/types';

import { assert } from '../assert';

import { LazyTransform } from '../streams/lazy_transform';

import { normalizeEncoding } from '../util';

import { StringDecoder } from 'string_decoder';

import { JsCipher as CipherBase } from ""_node:crypto"";

function rsaFunctionFor(method, defaultPadding, keyType) {
  return (options, buffer) => {
    const { format, type, data, passphrase } =
      keyType === 'private' ?
        preparePrivateKey(options) :
        preparePublicOrPrivateKey(options);
    const padding = options.padding || defaultPadding;
    const { oaepHash, encoding } = options;
    let { oaepLabel } = options;
    if (oaepHash !== undefined)
      validateString(oaepHash, 'key.oaepHash');
    if (oaepLabel !== undefined)
      oaepLabel = getArrayBufferOrView(oaepLabel, 'key.oaepLabel', encoding);
    buffer = getArrayBufferOrView(buffer, 'buffer', encoding);
    return method(data, format, type, passphrase, buffer, padding, oaepHash,
      oaepLabel);
  };
}

const publicEncrypt = rsaFunctionFor(_publicEncrypt, RSA_PKCS1_OAEP_PADDING,
  'public');
const publicDecrypt = rsaFunctionFor(_publicDecrypt, RSA_PKCS1_PADDING,
  'public');
const privateEncrypt = rsaFunctionFor(_privateEncrypt, RSA_PKCS1_PADDING,
  'private');
const privateDecrypt = rsaFunctionFor(_privateDecrypt, RSA_PKCS1_OAEP_PADDING,
  'private');

function getDecoder(decoder, encoding) {
  encoding = normalizeEncoding(encoding);
  decoder = decoder || new StringDecoder(encoding);
  assert(decoder.encoding === encoding, 'Cannot change encoding');
  return decoder;
}

function getUIntOption(options, key) {
  let value;
  if (options && (value = options[key]) != null) {
    if (value >>> 0 !== value)
      throw new ERR_INVALID_ARG_VALUE(`options.${key}`, value);
    return value;
  }
  return -1;
}

function createCipherBase(cipher, credential, options, decipher, iv) {
  const authTagLength = getUIntOption(options, 'authTagLength');
  if (iv === undefined) {
    // this[kHandle].init(cipher, credential, authTagLength);
  } else {
    this[kHandle] = new CipherBase(cipher, credential.buffer ?? credential, iv.buffer ?? iv, authTagLength, decipher);
  }
  this._decoder = null;

  Reflect.apply(LazyTransform, this, [options]);
}

function createCipher(cipher, password, options, decipher) {
  validateString(cipher, 'cipher');
  password = getArrayBufferOrView(password, 'password');

  Reflect.apply(createCipherBase, this, [cipher, password, options, decipher]);
}

function createCipherWithIV(cipher, key, options, decipher, iv) {
  validateString(cipher, 'cipher');
  const encoding = getStringOption(options, 'encoding');
  key = prepareSecretKey(key, encoding);
  if (isKeyObject(key)) {
    key = key.export();
  }
  iv = iv === null ? null : getArrayBufferOrView(iv, 'iv');
  if (!getCiphers().includes(cipher)) {
    throw new ERR_CRYPTO_UNKNOWN_CIPHER();
  }
  // Zero-sized IV should be rejected in GCM mode. 
  // Wasi-crypto current implemention only support GCM mode,
  // so always check
  if (iv.byteLength === 0) {
    throw new Error(""Invalid initialization vector"");
  }
  Reflect.apply(createCipherBase, this, [cipher, key, options, decipher, iv]);
}

// The Cipher class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Cipher class is defined using the legacy function syntax rather than
// ES6 classes.

function Cipher(cipher, password, options) {
  if (!(this instanceof Cipher))
    return new Cipher(cipher, password, options);

  Reflect.apply(createCipher, this, [cipher, password, options, true]);
}

Object.setPrototypeOf(Cipher.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Cipher, LazyTransform);

Cipher.prototype._transform = function _transform(chunk, encoding, callback) {
  this.push(this.update(chunk, encoding));
  callback();
};

Cipher.prototype._flush = function _flush(callback) {
  try {
    this.push(this.final());
  } catch (e) {
    callback(e);
    return;
  }
  callback();
};

Cipher.prototype.update = function update(data, inputEncoding, outputEncoding) {
  const encoding = getDefaultEncoding();
  inputEncoding = inputEncoding || encoding;
  outputEncoding = outputEncoding || encoding;

  if (typeof data === 'string') {
    validateEncoding(data, inputEncoding);
  } else if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data', ['string', 'Buffer', 'TypedArray', 'DataView'], data);
  }

  let buf = getArrayBufferOrView(data, ""data"", inputEncoding);
  const ret = this[kHandle].update(buf.buffer ?? buf);

  if (outputEncoding && outputEncoding !== 'buffer') {
    return """"; // current implemented doesn't return anything from update
    // this._decoder = getDecoder(this._decoder, outputEncoding);
    // return this._decoder.write(ret);
  }

  return ret;
};


Cipher.prototype.final = function final(outputEncoding) {
  outputEncoding = outputEncoding || getDefaultEncoding();
  const ret = this[kHandle].final();
  if (outputEncoding && outputEncoding !== 'buffer') {
    return Buffer.from(ret).toString(outputEncoding);
    // this._decoder = getDecoder(this._decoder, outputEncoding);
    // return this._decoder.end(ret);
  }

  return ret;
};


Cipher.prototype.setAutoPadding = function setAutoPadding(ap) {
  if (!this[kHandle].setAutoPadding(!!ap))
    throw new ERR_CRYPTO_INVALID_STATE('setAutoPadding');
  return this;
};

Cipher.prototype.getAuthTag = function getAuthTag() {
  const ret = this[kHandle].getAuthTag();
  if (ret === undefined)
    throw new ERR_CRYPTO_INVALID_STATE('getAuthTag');
  return ret;
};


function setAuthTag(tagbuf, encoding) {
  tagbuf = getArrayBufferOrView(tagbuf, 'buffer', encoding);
  if (!this[kHandle].setAuthTag(tagbuf.buffer ?? tagbuf))
    throw new ERR_CRYPTO_INVALID_STATE('setAuthTag');
  return this;
}

Cipher.prototype.setAAD = function setAAD(aadbuf, options) {
  const encoding = getStringOption(options, 'encoding');
  const plaintextLength = getUIntOption(options, 'plaintextLength');
  aadbuf = getArrayBufferOrView(aadbuf, 'aadbuf', encoding);
  if (!this[kHandle].setAAD(aadbuf.buffer ?? aadbuf, plaintextLength))
    throw new ERR_CRYPTO_INVALID_STATE('setAAD');
  return this;
};

// The Cipheriv class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Cipheriv class is defined using the legacy function syntax rather than
// ES6 classes.

function Cipheriv(cipher, key, iv, options) {
  if (!(this instanceof Cipheriv))
    return new Cipheriv(cipher, key, iv, options);

  Reflect.apply(createCipherWithIV, this, [cipher, key, options, true, iv]);
}

function addCipherPrototypeFunctions(constructor) {
  constructor.prototype._transform = Cipher.prototype._transform;
  constructor.prototype._flush = Cipher.prototype._flush;
  constructor.prototype.update = Cipher.prototype.update;
  constructor.prototype.final = Cipher.prototype.final;
  constructor.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;
  if (constructor === Cipheriv) {
    constructor.prototype.getAuthTag = Cipher.prototype.getAuthTag;
  } else {
    constructor.prototype.setAuthTag = setAuthTag;
  }
  constructor.prototype.setAAD = Cipher.prototype.setAAD;
}

Object.setPrototypeOf(Cipheriv.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Cipheriv, LazyTransform);
addCipherPrototypeFunctions(Cipheriv);

// The Decipher class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Decipher class is defined using the legacy function syntax rather than
// ES6 classes.

function Decipher(cipher, password, options) {
  if (!(this instanceof Decipher))
    return new Decipher(cipher, password, options);

  Reflect.apply(createCipher, this, [cipher, password, options, false]);
}

Object.setPrototypeOf(Decipher.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Decipher, LazyTransform);
addCipherPrototypeFunctions(Decipher);

// The Decipheriv class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Decipheriv class is defined using the legacy function syntax rather than
// ES6 classes.

function Decipheriv(cipher, key, iv, options) {
  if (!(this instanceof Decipheriv))
    return new Decipheriv(cipher, key, iv, options);

  Reflect.apply(createCipherWithIV, this, [cipher, key, options, false, iv]);
}

Object.setPrototypeOf(Decipheriv.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Decipheriv, LazyTransform);
addCipherPrototypeFunctions(Decipheriv);

function getCipherInfo(nameOrNid, options) {
  if (typeof nameOrNid !== 'string' && typeof nameOrNid !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(
      'nameOrNid',
      ['string', 'number'],
      nameOrNid);
  }
  if (typeof nameOrNid === 'number')
    validateInt32(nameOrNid, 'nameOrNid');
  let keyLength, ivLength;
  if (options !== undefined) {
    validateObject(options, 'options');
    ({ keyLength, ivLength } = options);
    if (keyLength !== undefined)
      validateInt32(keyLength, 'options.keyLength');
    if (ivLength !== undefined)
      validateInt32(ivLength, 'options.ivLength');
  }

  const ret = _getCipherInfo({}, nameOrNid, keyLength, ivLength);
  if (ret !== undefined) {
    if (ret.name) ret.name = String.prototype.toLowerCase.call(ret.name);
    if (ret.type) ret.type = String.prototype.toLowerCase.call(ret.type);
  }
  return ret;
}

export {
  // Cipher,
  Cipheriv,
  // Decipher,
  Decipheriv,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  getCipherInfo,
};

```"
"```javascript:modules\timers.js
import process from 'process';

var exports$2 = {},
    _dewExec$1 = false;

var _global$1 = typeof globalThis !== ""undefined"" ? globalThis : typeof self !== ""undefined"" ? self : global;

function dew$1() {
  if (_dewExec$1) { return exports$2; }
  _dewExec$1 = true;
  var process$1 = process;

  (function (global, undefined$1) {

    if (global.setImmediate) {
      return;
    }

    var nextHandle = 1; // Spec says greater than zero

    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      var arguments$1 = arguments;

      // Callback can either be a function or a string
      if (typeof callback !== ""function"") {
        callback = new Function("""" + callback);
      } // Copy function arguments


      var args = new Array(arguments.length - 1);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments$1[i + 1];
      } // Store and register the task


      var task = {
        callback: callback,
        args: args
      };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }

    function run(task) {
      var callback = task.callback;
      var args = task.args;

      switch (args.length) {
        case 0:
          callback();
          break;

        case 1:
          callback(args[0]);
          break;

        case 2:
          callback(args[0], args[1]);
          break;

        case 3:
          callback(args[0], args[1], args[2]);
          break;

        default:
          callback.apply(undefined$1, args);
          break;
      }
    }

    function runIfPresent(handle) {
      // From the spec: ""Wait until any invocations of this algorithm started before this one have completed.""
      // So if we're currently running a task, we'll need to delay this invocation.
      if (currentlyRunningATask) {
        // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
        // ""too much recursion"" error.
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];

        if (task) {
          currentlyRunningATask = true;

          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }

    function installNextTickImplementation() {
      registerImmediate = function (handle) {
        process$1.nextTick(function () {
          runIfPresent(handle);
        });
      };
    }

    function canUsePostMessage() {
      // The test against `importScripts` prevents this implementation from being installed inside a web worker,
      // where `global.postMessage` means something completely different and can't be used for this purpose.
      if (global.postMessage && !global.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global.onmessage;

        global.onmessage = function () {
          postMessageIsAsynchronous = false;
        };

        global.postMessage("""", ""*"");
        global.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }

    function installPostMessageImplementation() {
      // Installs an event handler on `global` for the `message` event: see
      // * https://developer.mozilla.org/en/DOM/window.postMessage
      // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
      var messagePrefix = ""setImmediate$"" + Math.random() + ""$"";

      var onGlobalMessage = function (event) {
        if (event.source === global && typeof event.data === ""string"" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };

      if (global.addEventListener) {
        global.addEventListener(""message"", onGlobalMessage, false);
      } else {
        global.attachEvent(""onmessage"", onGlobalMessage);
      }

      registerImmediate = function (handle) {
        global.postMessage(messagePrefix + handle, ""*"");
      };
    }

    function installMessageChannelImplementation() {
      var channel = new MessageChannel();

      channel.port1.onmessage = function (event) {
        var handle = event.data;
        runIfPresent(handle);
      };

      registerImmediate = function (handle) {
        channel.port2.postMessage(handle);
      };
    }

    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;

      registerImmediate = function (handle) {
        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
        var script = doc.createElement(""script"");

        script.onreadystatechange = function () {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };

        html.appendChild(script);
      };
    }

    function installSetTimeoutImplementation() {
      registerImmediate = function (handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

    if ({}.toString.call(global.process) === ""[object process]"") {
      // For Node.js before 0.9
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      // For non-IE10 modern browsers
      installPostMessageImplementation();
    } else if (global.MessageChannel) {
      // For web workers, where supported
      installMessageChannelImplementation();
    } else if (doc && ""onreadystatechange"" in doc.createElement(""script"")) {
      // For IE 6���8
      installReadyStateChangeImplementation();
    } else {
      // For older browsers
      installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === ""undefined"" ? typeof _global$1 === ""undefined"" ? exports$2 : _global$1 : self);

  return exports$2;
}

var exports$1 = {},
    _dewExec = false;

var _global = typeof globalThis !== ""undefined"" ? globalThis : typeof self !== ""undefined"" ? self : global;

function dew() {
  if (_dewExec) { return exports$1; }
  _dewExec = true;
  var scope = typeof _global !== ""undefined"" && _global || typeof self !== ""undefined"" && self || window;
  var apply = Function.prototype.apply; // DOM APIs, for completeness

  exports$1.setTimeout = function () {
    return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
  };

  exports$1.setInterval = function () {
    return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
  };

  exports$1.clearTimeout = exports$1.clearInterval = function (timeout) {
    if (timeout) {
      timeout.close();
    }
  };

  function Timeout(id, clearFn) {
    (this || _global)._id = id;
    (this || _global)._clearFn = clearFn;
  }

  Timeout.prototype.unref = Timeout.prototype.ref = function () {};

  Timeout.prototype.close = function () {
    (this || _global)._clearFn.call(scope, (this || _global)._id);
  }; // Does not start the time, just sets up the members needed.


  exports$1.enroll = function (item, msecs) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = msecs;
  };

  exports$1.unenroll = function (item) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = -1;
  };

  exports$1._unrefActive = exports$1.active = function (item) {
    clearTimeout(item._idleTimeoutId);
    var msecs = item._idleTimeout;

    if (msecs >= 0) {
      item._idleTimeoutId = setTimeout(function onTimeout() {
        if (item._onTimeout) { item._onTimeout(); }
      }, msecs);
    }
  }; // setimmediate attaches itself to the global object


  dew$1(); // On some exotic environments, it's not clear which object `setimmediate` was
  // able to install onto.  Search each possibility in the same order as the
  // `setimmediate` library.


  exports$1.setImmediate = typeof self !== ""undefined"" && self.setImmediate || typeof _global !== ""undefined"" && _global.setImmediate || exports$1 && exports$1.setImmediate;
  exports$1.clearImmediate = typeof self !== ""undefined"" && self.clearImmediate || typeof _global !== ""undefined"" && _global.clearImmediate || exports$1 && exports$1.clearImmediate;
  return exports$1;
}

var exports = dew();
exports['setTimeout']; exports['setInterval']; exports['clearTimeout']; exports['clearInterval']; exports['enroll']; exports['unenroll']; exports['_unrefActive']; exports['active']; exports['setImmediate']; exports['clearImmediate'];

var _unrefActive = exports._unrefActive;
var active = exports.active;
var clearImmediate = exports.clearImmediate;
var clearInterval$1 = exports.clearInterval;
var clearTimeout$1 = exports.clearTimeout;
var enroll = exports.enroll;
var setImmediate = exports.setImmediate;
var setInterval$1 = exports.setInterval;
var setTimeout$1 = exports.setTimeout;
var unenroll = exports.unenroll;

export { _unrefActive, active, clearImmediate, clearInterval$1 as clearInterval, clearTimeout$1 as clearTimeout, exports as default, enroll, setImmediate, setInterval$1 as setInterval, setTimeout$1 as setTimeout, unenroll };

```"
"```javascript:modules\internal\crypto\keygen.js
'use strict';

const {
  FunctionPrototypeCall,
  ObjectDefineProperty,
  SafeArrayIterator,
} = primordials;

const {
  DhKeyPairGenJob,
  DsaKeyPairGenJob,
  EcKeyPairGenJob,
  NidKeyPairGenJob,
  RsaKeyPairGenJob,
  SecretKeyGenJob,
  kCryptoJobAsync,
  kCryptoJobSync,
  kKeyVariantRSA_PSS,
  kKeyVariantRSA_SSA_PKCS1_v1_5,
  EVP_PKEY_ED25519,
  EVP_PKEY_ED448,
  EVP_PKEY_X25519,
  EVP_PKEY_X448,
  OPENSSL_EC_NAMED_CURVE,
  OPENSSL_EC_EXPLICIT_CURVE,
} = internalBinding('crypto');

const {
  PublicKeyObject,
  PrivateKeyObject,
  SecretKeyObject,
  parsePublicKeyEncoding,
  parsePrivateKeyEncoding,
} = require('internal/crypto/keys');

const {
  kAesKeyLengths,
} = require('internal/crypto/util');

const {
  customPromisifyArgs,
  kEmptyObject,
} = require('internal/util');

const {
  validateFunction,
  validateBuffer,
  validateString,
  validateInteger,
  validateObject,
  validateOneOf,
  validateInt32,
  validateUint32,
} = require('internal/validators');

const {
  codes: {
    ERR_INCOMPATIBLE_OPTION_PAIR,
    ERR_INVALID_ARG_VALUE,
    ERR_MISSING_OPTION,
  }
} = require('internal/errors');

const { isArrayBufferView } = require('internal/util/types');

const { getOptionValue } = require('internal/options');

function isJwk(obj) {
  return obj != null && obj.kty !== undefined;
}

function wrapKey(key, ctor) {
  if (typeof key === 'string' ||
      isArrayBufferView(key) ||
      isJwk(key))
    return key;
  return new ctor(key);
}

function generateKeyPair(type, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }
  validateFunction(callback, 'callback');

  const job = createJob(kCryptoJobAsync, type, options);

  job.ondone = (error, result) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    // If no encoding was chosen, return key objects instead.
    let { 0: pubkey, 1: privkey } = result;
    pubkey = wrapKey(pubkey, PublicKeyObject);
    privkey = wrapKey(privkey, PrivateKeyObject);
    FunctionPrototypeCall(callback, job, null, pubkey, privkey);
  };

  job.run();
}

ObjectDefineProperty(generateKeyPair, customPromisifyArgs, {
  __proto__: null,
  value: ['publicKey', 'privateKey'],
  enumerable: false
});

function generateKeyPairSync(type, options) {
  return handleError(createJob(kCryptoJobSync, type, options).run());
}

function handleError(ret) {
  if (ret == null)
    return; // async

  const { 0: err, 1: keys } = ret;
  if (err !== undefined)
    throw err;

  const { 0: publicKey, 1: privateKey } = keys;

  // If no encoding was chosen, return key objects instead.
  return {
    publicKey: wrapKey(publicKey, PublicKeyObject),
    privateKey: wrapKey(privateKey, PrivateKeyObject)
  };
}

function parseKeyEncoding(keyType, options = kEmptyObject) {
  const { publicKeyEncoding, privateKeyEncoding } = options;

  let publicFormat, publicType;
  if (publicKeyEncoding == null) {
    publicFormat = publicType = undefined;
  } else if (typeof publicKeyEncoding === 'object') {
    ({
      format: publicFormat,
      type: publicType
    } = parsePublicKeyEncoding(publicKeyEncoding, keyType,
                               'publicKeyEncoding'));
  } else {
    throw new ERR_INVALID_ARG_VALUE('options.publicKeyEncoding',
                                    publicKeyEncoding);
  }

  let privateFormat, privateType, cipher, passphrase;
  if (privateKeyEncoding == null) {
    privateFormat = privateType = undefined;
  } else if (typeof privateKeyEncoding === 'object') {
    ({
      format: privateFormat,
      type: privateType,
      cipher,
      passphrase
    } = parsePrivateKeyEncoding(privateKeyEncoding, keyType,
                                'privateKeyEncoding'));
  } else {
    throw new ERR_INVALID_ARG_VALUE('options.privateKeyEncoding',
                                    privateKeyEncoding);
  }

  return [
    publicFormat,
    publicType,
    privateFormat,
    privateType,
    cipher,
    passphrase,
  ];
}

function createJob(mode, type, options) {
  validateString(type, 'type');

  const encoding = new SafeArrayIterator(parseKeyEncoding(type, options));

  if (options !== undefined)
    validateObject(options, 'options');

  switch (type) {
    case 'rsa':
    case 'rsa-pss':
    {
      validateObject(options, 'options');
      const { modulusLength } = options;
      validateUint32(modulusLength, 'options.modulusLength');

      let { publicExponent } = options;
      if (publicExponent == null) {
        publicExponent = 0x10001;
      } else {
        validateUint32(publicExponent, 'options.publicExponent');
      }

      if (type === 'rsa') {
        return new RsaKeyPairGenJob(
          mode,
          kKeyVariantRSA_SSA_PKCS1_v1_5,  // Used also for RSA-OAEP
          modulusLength,
          publicExponent,
          ...encoding);
      }

      const {
        hash, mgf1Hash, hashAlgorithm, mgf1HashAlgorithm, saltLength
      } = options;

      const pendingDeprecation = getOptionValue('--pending-deprecation');

      if (saltLength !== undefined)
        validateInt32(saltLength, 'options.saltLength', 0);
      if (hashAlgorithm !== undefined)
        validateString(hashAlgorithm, 'options.hashAlgorithm');
      if (mgf1HashAlgorithm !== undefined)
        validateString(mgf1HashAlgorithm, 'options.mgf1HashAlgorithm');
      if (hash !== undefined) {
        pendingDeprecation && process.emitWarning(
          '""options.hash"" is deprecated, ' +
          'use ""options.hashAlgorithm"" instead.',
          'DeprecationWarning',
          'DEP0154');
        validateString(hash, 'options.hash');
        if (hashAlgorithm && hash !== hashAlgorithm) {
          throw new ERR_INVALID_ARG_VALUE('options.hash', hash);
        }
      }
      if (mgf1Hash !== undefined) {
        pendingDeprecation && process.emitWarning(
          '""options.mgf1Hash"" is deprecated, ' +
          'use ""options.mgf1HashAlgorithm"" instead.',
          'DeprecationWarning',
          'DEP0154');
        validateString(mgf1Hash, 'options.mgf1Hash');
        if (mgf1HashAlgorithm && mgf1Hash !== mgf1HashAlgorithm) {
          throw new ERR_INVALID_ARG_VALUE('options.mgf1Hash', mgf1Hash);
        }
      }

      return new RsaKeyPairGenJob(
        mode,
        kKeyVariantRSA_PSS,
        modulusLength,
        publicExponent,
        hashAlgorithm || hash,
        mgf1HashAlgorithm || mgf1Hash,
        saltLength,
        ...encoding);
    }
    case 'dsa':
    {
      validateObject(options, 'options');
      const { modulusLength } = options;
      validateUint32(modulusLength, 'options.modulusLength');

      let { divisorLength } = options;
      if (divisorLength == null) {
        divisorLength = -1;
      } else
        validateInt32(divisorLength, 'options.divisorLength', 0);

      return new DsaKeyPairGenJob(
        mode,
        modulusLength,
        divisorLength,
        ...encoding);
    }
    case 'ec':
    {
      validateObject(options, 'options');
      const { namedCurve } = options;
      validateString(namedCurve, 'options.namedCurve');
      let { paramEncoding } = options;
      if (paramEncoding == null || paramEncoding === 'named')
        paramEncoding = OPENSSL_EC_NAMED_CURVE;
      else if (paramEncoding === 'explicit')
        paramEncoding = OPENSSL_EC_EXPLICIT_CURVE;
      else
        throw new ERR_INVALID_ARG_VALUE('options.paramEncoding', paramEncoding);

      return new EcKeyPairGenJob(
        mode,
        namedCurve,
        paramEncoding,
        ...encoding);
    }
    case 'ed25519':
    case 'ed448':
    case 'x25519':
    case 'x448':
    {
      let id;
      switch (type) {
        case 'ed25519':
          id = EVP_PKEY_ED25519;
          break;
        case 'ed448':
          id = EVP_PKEY_ED448;
          break;
        case 'x25519':
          id = EVP_PKEY_X25519;
          break;
        case 'x448':
          id = EVP_PKEY_X448;
          break;
      }
      return new NidKeyPairGenJob(mode, id, ...encoding);
    }
    case 'dh':
    {
      validateObject(options, 'options');
      const { group, primeLength, prime, generator } = options;
      if (group != null) {
        if (prime != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'prime');
        if (primeLength != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'primeLength');
        if (generator != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'generator');

        validateString(group, 'options.group');

        return new DhKeyPairGenJob(mode, group, ...encoding);
      }

      if (prime != null) {
        if (primeLength != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('prime', 'primeLength');

        validateBuffer(prime, 'options.prime');
      } else if (primeLength != null) {
        validateInt32(primeLength, 'options.primeLength', 0);
      } else {
        throw new ERR_MISSING_OPTION(
          'At least one of the group, prime, or primeLength options');
      }

      if (generator != null) {
        validateInt32(generator, 'options.generator', 0);
      }
      return new DhKeyPairGenJob(
        mode,
        prime != null ? prime : primeLength,
        generator == null ? 2 : generator,
        ...encoding);
    }
    default:
      // Fall through
  }
  throw new ERR_INVALID_ARG_VALUE('type', type, 'must be a supported key type');
}

// Symmetric Key Generation

function generateKeyJob(mode, keyType, options) {
  validateString(keyType, 'type');
  validateObject(options, 'options');
  const { length } = options;
  switch (keyType) {
    case 'hmac':
      validateInteger(length, 'options.length', 8, 2 ** 31 - 1);
      break;
    case 'aes':
      validateOneOf(length, 'options.length', kAesKeyLengths);
      break;
    default:
      throw new ERR_INVALID_ARG_VALUE(
        'type',
        keyType,
        'must be a supported key type');
  }

  return new SecretKeyGenJob(mode, length);
}

function handleGenerateKeyError(ret) {
  if (ret === undefined)
    return; // async

  const { 0: err, 1: key } = ret;
  if (err !== undefined)
    throw err;

  return wrapKey(key, SecretKeyObject);
}

function generateKey(type, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }

  validateFunction(callback, 'callback');

  const job = generateKeyJob(kCryptoJobAsync, type, options);

  job.ondone = (error, key) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, wrapKey(key, SecretKeyObject));
  };

  handleGenerateKeyError(job.run());
}

function generateKeySync(type, options) {
  return handleGenerateKeyError(
    generateKeyJob(kCryptoJobSync, type, options).run());
}

module.exports = {
  generateKeyPair,
  generateKeyPairSync,
  generateKey,
  generateKeySync,
};

```"
"```javascript:test\crypto\test-crypto-fips.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const spawnSync = require('child_process').spawnSync;
const path = require('path');
const fixtures = require('../common/fixtures');
const { internalBinding } = require('internal/test/binding');
const { testFipsCrypto } = internalBinding('crypto');

const FIPS_ENABLED = 1;
const FIPS_DISABLED = 0;
const FIPS_ERROR_STRING2 =
  'Error [ERR_CRYPTO_FIPS_FORCED]: Cannot set FIPS mode, it was forced with ' +
  '--force-fips at startup.';
const FIPS_UNSUPPORTED_ERROR_STRING = 'fips mode not supported';
const FIPS_ENABLE_ERROR_STRING = 'OpenSSL error when trying to enable FIPS:';

const CNF_FIPS_ON = fixtures.path('openssl_fips_enabled.cnf');
const CNF_FIPS_OFF = fixtures.path('openssl_fips_disabled.cnf');

let num_children_ok = 0;

function sharedOpenSSL() {
  return process.config.variables.node_shared_openssl;
}

function testHelper(stream, args, expectedOutput, cmd, env) {
  const fullArgs = args.concat(['-e', `console.log(${cmd})`]);
  const child = spawnSync(process.execPath, fullArgs, {
    cwd: path.dirname(process.execPath),
    env: env
  });

  console.error(
    `Spawned child [pid:${child.pid}] with cmd '${cmd}' expect %j with args '${
      args}' OPENSSL_CONF=%j`, expectedOutput, env.OPENSSL_CONF);

  function childOk(child) {
    console.error(`Child #${++num_children_ok} [pid:${child.pid}] OK.`);
  }

  function responseHandler(buffer, expectedOutput) {
    const response = buffer.toString();
    assert.notStrictEqual(response.length, 0);
    if (FIPS_ENABLED !== expectedOutput && FIPS_DISABLED !== expectedOutput) {
      // In the case of expected errors just look for a substring.
      assert.ok(response.includes(expectedOutput));
    } else {
      const getFipsValue = Number(response);
      if (!Number.isNaN(getFipsValue))
        // Normal path where we expect either FIPS enabled or disabled.
        assert.strictEqual(getFipsValue, expectedOutput);
    }
    childOk(child);
  }

  responseHandler(child[stream], expectedOutput);
}

// --enable-fips should raise an error if OpenSSL is not FIPS enabled.
testHelper(
  testFipsCrypto() ? 'stdout' : 'stderr',
  ['--enable-fips'],
  testFipsCrypto() ? FIPS_ENABLED : FIPS_ENABLE_ERROR_STRING,
  'process.versions',
  process.env);

// --force-fips should raise an error if OpenSSL is not FIPS enabled.
testHelper(
  testFipsCrypto() ? 'stdout' : 'stderr',
  ['--force-fips'],
  testFipsCrypto() ? FIPS_ENABLED : FIPS_ENABLE_ERROR_STRING,
  'process.versions',
  process.env);

// By default FIPS should be off in both FIPS and non-FIPS builds.
testHelper(
  'stdout',
  [],
  FIPS_DISABLED,
  'require(""crypto"").getFips()',
  { ...process.env, 'OPENSSL_CONF': ' ' });

// Toggling fips with setFips should not be allowed from a worker thread
testHelper(
  'stderr',
  [],
  'Calling crypto.setFips() is not supported in workers',
  'new worker_threads.Worker(\'require(""crypto"").setFips(true);\', { eval: true })',
  process.env);

// This should succeed for both FIPS and non-FIPS builds in combination with
// OpenSSL 1.1.1 or OpenSSL 3.0
const test_result = testFipsCrypto();
assert.ok(test_result === 1 || test_result === 0);

// If Node was configured using --shared-openssl fips support might be
// available depending on how OpenSSL was built. If fips support is
// available the tests that toggle the fips_mode on/off using the config
// file option will succeed and return 1 instead of 0.
//
// Note that this case is different from when calling the fips setter as the
// configuration file is handled by OpenSSL, so it is not possible for us
// to try to call the fips setter, to try to detect this situation, as
// that would throw an error:
// (""Error: Cannot set FIPS mode in a non-FIPS build."").
// Due to this uncertainty the following tests are skipped when configured
// with --shared-openssl.
if (!sharedOpenSSL() && !common.hasOpenSSL3) {
  // OpenSSL config file should be able to turn on FIPS mode
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_ON}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_DISABLED,
    'require(""crypto"").getFips()',
    process.env);

  // OPENSSL_CONF should be able to turn on FIPS mode
  testHelper(
    'stdout',
    [],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_DISABLED,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_ON }));

  // --openssl-config option should override OPENSSL_CONF
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_ON}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_DISABLED,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_OFF }));
}

// OpenSSL 3.x has changed the configuration files so the following tests
// will not work as expected with that version.
// TODO(danbev) Revisit these test once FIPS support is available in
// OpenSSL 3.x.
if (!common.hasOpenSSL3) {
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_OFF}`],
    FIPS_DISABLED,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_ON }));

  // --enable-fips should take precedence over OpenSSL config file
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips', `--openssl-config=${CNF_FIPS_OFF}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);
  // --force-fips should take precedence over OpenSSL config file
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips', `--openssl-config=${CNF_FIPS_OFF}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);
  // --enable-fips should turn FIPS mode on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);

  // --force-fips should turn FIPS mode on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);

  // OPENSSL_CONF should _not_ make a difference to --enable-fips
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_OFF }));

  // Using OPENSSL_CONF should not make a difference to --force-fips
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_OFF }));

  // setFipsCrypto should be able to turn FIPS mode on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    [],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").getFips())',
    process.env);

  // setFipsCrypto should be able to turn FIPS mode on and off
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    [],
    testFipsCrypto() ? FIPS_DISABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").setFips(false),' +
    'require(""crypto"").getFips())',
    process.env);

  // setFipsCrypto takes precedence over OpenSSL config file, FIPS on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    [`--openssl-config=${CNF_FIPS_OFF}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").getFips())',
    process.env);

  // setFipsCrypto takes precedence over OpenSSL config file, FIPS off
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_ON}`],
    FIPS_DISABLED,
    '(require(""crypto"").setFips(false),' +
    'require(""crypto"").getFips())',
    process.env);

  // --enable-fips does not prevent use of setFipsCrypto API
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips'],
    testFipsCrypto() ? FIPS_DISABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(false),' +
    'require(""crypto"").getFips())',
    process.env);

  // --force-fips prevents use of setFipsCrypto API
  testHelper(
    'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ERROR_STRING2 : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").setFips(false)',
    process.env);

  // --force-fips makes setFipsCrypto enable a no-op (FIPS stays on)
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").getFips())',
    process.env);

  // --force-fips and --enable-fips order does not matter
  testHelper(
    'stderr',
    ['--force-fips', '--enable-fips'],
    testFipsCrypto() ? FIPS_ERROR_STRING2 : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").setFips(false)',
    process.env);

  // --enable-fips and --force-fips order does not matter
  testHelper(
    'stderr',
    ['--enable-fips', '--force-fips'],
    testFipsCrypto() ? FIPS_ERROR_STRING2 : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").setFips(false)',
    process.env);
}

```"
"```javascript:modules\internal\streams\pipeline.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { isIterable, isNodeStream, isReadableNodeStream } from ""./utils.js"";
import { once } from ""../util.js"";
import { validateAbortSignal, validateCallback } from ""../validators.js"";
import {
    AbortError,
    aggregateTwoErrors,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED,
} from ""../errors.js"";
import destroyImpl from ""./destroy.js"";
import Duplex from ""./duplex.js"";
import eos from ""./end-of-stream.js"";
import Readable from ""./readable.js"";
import PassThrough from ""./passthrough.js"";

function destroyer(stream, reading, writing, callback) {
    callback = once(callback);

    let finished = false;
    stream.on(""close"", () => {
        finished = true;
    });

    eos(stream, { readable: reading, writable: writing }, (err) => {
        finished = !err;

        const rState = stream._readableState;
        if (
            err &&
            err.code === ""ERR_STREAM_PREMATURE_CLOSE"" &&
            reading &&
            (rState && rState.ended && !rState.errored && !rState.errorEmitted)
        ) {
            // Some readable streams will emit 'close' before 'end'. However, since
            // this is on the readable side 'end' should still be emitted if the
            // stream has been ended and no error emitted. This should be allowed in
            // favor of backwards compatibility. Since the stream is piped to a
            // destination this should not result in any observable difference.
            // We don't need to check if this is a writable premature close since
            // eos will only fail with premature close on the reading side for
            // duplex streams.
            stream
                .once(""end"", callback)
                .once(""error"", callback);
        } else {
            callback(err);
        }
    });

    return (err) => {
        if (finished) return;
        finished = true;
        destroyImpl.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED(""pipe""));
    };
}

function popCallback(streams) {
    // Streams should never be an empty array. It should always contain at least
    // a single stream. Therefore optimize for the average case instead of
    // checking for length === 0 as well.
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}

function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        // Legacy streams are not Iterable.
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE(
        ""val"",
        [""Readable"", ""Iterable"", ""AsyncIterable""],
        val,
    );
}

async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}

async function pump(iterable, writable, finish) {
    let error;
    let onresolve = null;

    const resume = (err) => {
        if (err) {
            error = err;
        }

        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };

    const wait = () =>
        new Promise((resolve, reject) => {
            if (error) {
                reject(error);
            } else {
                onresolve = () => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                };
            }
        });

    writable.on(""drain"", resume);
    const cleanup = eos(writable, { readable: false }, resume);

    try {
        if (writable.writableNeedDrain) {
            await wait();
        }

        for await (const chunk of iterable) {
            if (!writable.write(chunk)) {
                await wait();
            }
        }

        writable.end();

        await wait();

        finish();
    } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally {
        cleanup();
        writable.off(""drain"", resume);
    }
}

function pipeline(...streams) {
    const callback = once(popCallback(streams));

    // stream.pipeline(streams, callback)
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }

    return pipelineImpl(streams, callback);
}

function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS(""streams"");
    }

    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;

    validateAbortSignal(outerSignal, ""options.signal"");

    function abort() {
        finishImpl(new AbortError());
    }

    outerSignal?.addEventListener(""abort"", abort);

    let error;
    let value;
    const destroys = [];

    let finishCount = 0;

    function finish(err) {
        finishImpl(err, --finishCount === 0);
    }

    function finishImpl(err, final) {
        if (err && (!error || error.code === ""ERR_STREAM_PREMATURE_CLOSE"")) {
            error = err;
        }

        if (!error && !final) {
            return;
        }

        while (destroys.length) {
            destroys.shift()(error);
        }

        outerSignal?.removeEventListener(""abort"", abort);
        ac.abort();

        if (final) {
            callback(error, value);
        }
    }

    let ret;
    for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;

        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer(stream, reading, writing, finish));
        }

        if (i === 0) {
            if (typeof stream === ""function"") {
                ret = stream({ signal });
                if (!isIterable(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE(
                        ""Iterable, AsyncIterable or Stream"",
                        ""source"",
                        ret,
                    );
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret = stream;
            } else {
                ret = Duplex.from(stream);
            }
        } else if (typeof stream === ""function"") {
            ret = makeAsyncIterable(ret);
            ret = stream(ret, { signal });

            if (reading) {
                if (!isIterable(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE(
                        ""AsyncIterable"",
                        `transform[${i - 1}]`,
                        ret,
                    );
                }
            } else {
                // If the last argument to pipeline is not a stream
                // we must create a proxy stream so that pipeline(...)
                // always returns a stream which can be further
                // composed through `.pipe(stream)`.

                const pt = new PassThrough({
                    objectMode: true,
                });

                // Handle Promises/A+ spec, `then` could be a getter that throws on
                // second use.
                const then = ret?.then;
                if (typeof then === ""function"") {
                    then.call(ret, (val) => {
                        value = val;
                        pt.end(val);
                    }, (err) => {
                        pt.destroy(err);
                    });
                } else if (isIterable(ret, true)) {
                    finishCount++;
                    pump(ret, pt, finish);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE(
                        ""AsyncIterable or Promise"",
                        ""destination"",
                        ret,
                    );
                }

                ret = pt;

                finishCount++;
                destroys.push(destroyer(ret, false, true, finish));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
                ret.pipe(stream);

                // Compat. Before node v10.12.0 stdio used to throw an error so
                // pipe() did/does not end() stdio destinations.
                // Now they allow it but ""secretly"" don't close the underlying fd.
                // if (stream === stdio.stdout || stream === stdio.stderr) {
                //     ret.on(""end"", () => stream.end());
                // }
            } else {
                ret = makeAsyncIterable(ret);

                finishCount++;
                pump(ret, stream, finish);
            }
            ret = stream;
        } else {
            ret = Duplex.from(stream);
        }
    }

    if (signal?.aborted || outerSignal?.aborted) {
        nextTick(abort);
    }

    return ret;
}

export default { pipeline, pipelineImpl };
export { pipeline, pipelineImpl };
```"
"```javascript:test\fs\test-fs-truncate.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const tmp = tmpdir.path;
const filename = path.resolve(tmp, 'truncate-file.txt');
const data = Buffer.alloc(1024 * 16, 'x');

let onExit = [];
globalThis.commonExitCheck = () => {
  for (const fn of onExit) {
    fn();
  }
}

tmpdir.refresh();

let stat;

const msg = 'Using fs.truncate with a file descriptor is deprecated.' +
            ' Please use fs.ftruncate with a file descriptor instead.';

// Check truncateSync
fs.writeFileSync(filename, data);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024 * 16);

fs.truncateSync(filename, 1024);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024);

fs.truncateSync(filename);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 0);

// Check ftruncateSync
fs.writeFileSync(filename, data);
const fd = fs.openSync(filename, 'r+');

stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024 * 16);

fs.ftruncateSync(fd, 1024);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024);

fs.ftruncateSync(fd);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 0);

// truncateSync
common.expectWarning('DeprecationWarning', msg, 'DEP0081');
fs.truncateSync(fd);

fs.closeSync(fd);

// Async tests
testTruncate(common.mustSucceed(() => {
  testFtruncate(common.mustSucceed());
}));

function testTruncate(cb) {
  fs.writeFile(filename, data, function(er) {
    if (er) return cb(er);
    fs.stat(filename, function(er, stat) {
      if (er) return cb(er);
      assert.strictEqual(stat.size, 1024 * 16);

      fs.truncate(filename, 1024, function(er) {
        if (er) return cb(er);
        fs.stat(filename, function(er, stat) {
          if (er) return cb(er);
          assert.strictEqual(stat.size, 1024);

          fs.truncate(filename, function(er) {
            if (er) return cb(er);
            fs.stat(filename, function(er, stat) {
              if (er) return cb(er);
              assert.strictEqual(stat.size, 0);
              cb();
            });
          });
        });
      });
    });
  });
}

function testFtruncate(cb) {
  fs.writeFile(filename, data, function(er) {
    if (er) return cb(er);
    fs.stat(filename, function(er, stat) {
      if (er) return cb(er);
      assert.strictEqual(stat.size, 1024 * 16);

      fs.open(filename, 'w', function(er, fd) {
        if (er) return cb(er);
        fs.ftruncate(fd, 1024, function(er) {
          if (er) return cb(er);
          fs.stat(filename, function(er, stat) {
            if (er) return cb(er);
            assert.strictEqual(stat.size, 1024);

            fs.ftruncate(fd, function(er) {
              if (er) return cb(er);
              fs.stat(filename, function(er, stat) {
                if (er) return cb(er);
                assert.strictEqual(stat.size, 0);
                fs.close(fd, cb);
              });
            });
          });
        });
      });
    });
  });
}

// Make sure if the size of the file is smaller than the length then it is
// filled with zeroes.

{
  const file1 = path.resolve(tmp, 'truncate-file-1.txt');
  fs.writeFileSync(file1, 'Hi');
  fs.truncateSync(file1, 4);
  assert(fs.readFileSync(file1).equals(Buffer.from('Hi\u0000\u0000')));
}

{
  const file2 = path.resolve(tmp, 'truncate-file-2.txt');
  fs.writeFileSync(file2, 'Hi');
  const fd = fs.openSync(file2, 'r+');
  onExit.push(() => fs.closeSync(fd));
  fs.ftruncateSync(fd, 4);
  assert(fs.readFileSync(file2).equals(Buffer.from('Hi\u0000\u0000')));
}

{
  const file3 = path.resolve(tmp, 'truncate-file-3.txt');
  fs.writeFileSync(file3, 'Hi');
  fs.truncate(file3, 4, common.mustSucceed(() => {
    assert(fs.readFileSync(file3).equals(Buffer.from('Hi\u0000\u0000')));
  }));
}

{
  const file4 = path.resolve(tmp, 'truncate-file-4.txt');
  fs.writeFileSync(file4, 'Hi');
  const fd = fs.openSync(file4, 'r+');
  onExit.push(() => fs.closeSync(fd));
  fs.ftruncate(fd, 4, common.mustSucceed(() => {
    assert(fs.readFileSync(file4).equals(Buffer.from('Hi\u0000\u0000')));
  }));
}

{
  const file5 = path.resolve(tmp, 'truncate-file-5.txt');
  fs.writeFileSync(file5, 'Hi');
  const fd = fs.openSync(file5, 'r+');
  onExit.push(() => fs.closeSync(fd));

  ['', false, null, {}, []].forEach((input) => {
    const received = common.invalidArgTypeHelper(input);
    assert.throws(
      () => fs.truncate(file5, input, common.mustNotCall()),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""len"" argument must be of type number.${received}`
      }
    );

    assert.throws(
      () => fs.ftruncate(fd, input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""len"" argument must be of type number.${received}`
      }
    );
  });

  [-1.5, 1.5].forEach((input) => {
    assert.throws(
      () => fs.truncate(file5, input),
      {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""len"" is out of range. It must be ' +
                  `an integer. Received ${input}`
      }
    );

    assert.throws(
      () => fs.ftruncate(fd, input),
      {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""len"" is out of range. It must be ' +
                  `an integer. Received ${input}`
      }
    );
  });

  fs.ftruncate(fd, undefined, common.mustSucceed(() => {
    assert(fs.readFileSync(file5).equals(Buffer.from('')));
  }));
}

{
  const file6 = path.resolve(tmp, 'truncate-file-6.txt');
  fs.writeFileSync(file6, 'Hi');
  const fd = fs.openSync(file6, 'r+');
  onExit.push(() => fs.closeSync(fd));
  fs.ftruncate(fd, -1, common.mustSucceed(() => {
    assert(fs.readFileSync(file6).equals(Buffer.from('')));
  }));
}

{
  const file7 = path.resolve(tmp, 'truncate-file-7.txt');
  fs.writeFileSync(file7, 'Hi');
  fs.truncate(file7, undefined, common.mustSucceed(() => {
    assert(fs.readFileSync(file7).equals(Buffer.from('')));
  }));
}

{
  const file8 = path.resolve(tmp, 'non-existent-truncate-file.txt');
  const validateError = (err) => {
    assert.strictEqual(file8, err.path);
    /*assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, open '${file8}'`);*/
    assert.strictEqual(err.code, 'ENOENT');
    // assert.strictEqual(err.syscall, 'open');
    return true;
  };
  fs.truncate(file8, 0, common.mustCall(validateError));
}

['', false, null, {}, []].forEach((input) => {
  assert.throws(
    () => fs.truncate('/foo/bar', input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""len"" argument must be of type number.' +
               common.invalidArgTypeHelper(input)
    }
  );
});

['', false, null, undefined, {}, []].forEach((input) => {
  ['ftruncate', 'ftruncateSync'].forEach((fnName) => {
    assert.throws(
      () => fs[fnName](input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""fd"" argument must be of type number.' +
                 common.invalidArgTypeHelper(input)
      }
    );
  });
});

{
  const file1 = path.resolve(tmp, 'truncate-file-1.txt');
  fs.writeFileSync(file1, 'Hi');
  fs.truncateSync(file1, -1);  // Negative coerced to 0, No error.
  assert(fs.readFileSync(file1).equals(Buffer.alloc(0)));
}

{
  const file1 = path.resolve(tmp, 'truncate-file-2.txt');
  fs.writeFileSync(file1, 'Hi');
  // Negative coerced to 0, No error.
  fs.truncate(file1, -1, common.mustSucceed(() => {
    assert(fs.readFileSync(file1).equals(Buffer.alloc(0)));
  }));
}

```"
"```javascript:modules\internal\crypto\x509.js
'use strict';

const {
  ObjectSetPrototypeOf,
  SafeMap,
  Symbol,
} = primordials;

const {
  parseX509,
  X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT,
  X509_CHECK_FLAG_NEVER_CHECK_SUBJECT,
  X509_CHECK_FLAG_NO_WILDCARDS,
  X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS,
  X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS,
  X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS,
} = internalBinding('crypto');

const {
  PublicKeyObject,
  isKeyObject,
} = require('internal/crypto/keys');

const {
  customInspectSymbol: kInspect,
  kEmptyObject,
} = require('internal/util');

const {
  validateBoolean,
  validateObject,
  validateString,
} = require('internal/validators');

const { inspect } = require('internal/util/inspect');

const { Buffer } = require('buffer');

const {
  isArrayBufferView,
} = require('internal/util/types');

const {
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE,
  }
} = require('internal/errors');

const {
  JSTransferable,
  kClone,
  kDeserialize,
} = require('internal/worker/js_transferable');

const {
  kHandle,
} = require('internal/crypto/util');

let lazyTranslatePeerCertificate;

const kInternalState = Symbol('kInternalState');

function isX509Certificate(value) {
  return value[kInternalState] !== undefined;
}

function getFlags(options = kEmptyObject) {
  validateObject(options, 'options');
  const {
    subject = 'default',  // Can be 'default', 'always', or 'never'
    wildcards = true,
    partialWildcards = true,
    multiLabelWildcards = false,
    singleLabelSubdomains = false,
  } = { ...options };
  let flags = 0;
  validateString(subject, 'options.subject');
  validateBoolean(wildcards, 'options.wildcards');
  validateBoolean(partialWildcards, 'options.partialWildcards');
  validateBoolean(multiLabelWildcards, 'options.multiLabelWildcards');
  validateBoolean(singleLabelSubdomains, 'options.singleLabelSubdomains');
  switch (subject) {
    case 'default': /* Matches OpenSSL's default, no flags. */ break;
    case 'always': flags |= X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT; break;
    case 'never': flags |= X509_CHECK_FLAG_NEVER_CHECK_SUBJECT; break;
    default:
      throw new ERR_INVALID_ARG_VALUE('options.subject', subject);
  }
  if (!wildcards) flags |= X509_CHECK_FLAG_NO_WILDCARDS;
  if (!partialWildcards) flags |= X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;
  if (multiLabelWildcards) flags |= X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS;
  if (singleLabelSubdomains) flags |= X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS;
  return flags;
}

class InternalX509Certificate extends JSTransferable {
  [kInternalState] = new SafeMap();

  constructor(handle) {
    super();
    this[kHandle] = handle;
  }
}

class X509Certificate extends JSTransferable {
  [kInternalState] = new SafeMap();

  constructor(buffer) {
    if (typeof buffer === 'string')
      buffer = Buffer.from(buffer);
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE(
        'buffer',
        ['string', 'Buffer', 'TypedArray', 'DataView'],
        buffer);
    }
    super();
    this[kHandle] = parseX509(buffer);
  }

  [kInspect](depth, options) {
    if (depth < 0)
      return this;

    const opts = {
      ...options,
      depth: options.depth == null ? null : options.depth - 1
    };

    return `X509Certificate ${inspect({
      subject: this.subject,
      subjectAltName: this.subjectAltName,
      issuer: this.issuer,
      infoAccess: this.infoAccess,
      validFrom: this.validFrom,
      validTo: this.validTo,
      fingerprint: this.fingerprint,
      fingerprint256: this.fingerprint256,
      fingerprint512: this.fingerprint512,
      keyUsage: this.keyUsage,
      serialNumber: this.serialNumber,
    }, opts)}`;
  }

  [kClone]() {
    const handle = this[kHandle];
    return {
      data: { handle },
      deserializeInfo: 'internal/crypto/x509:InternalX509Certificate'
    };
  }

  [kDeserialize]({ handle }) {
    this[kHandle] = handle;
  }

  get subject() {
    let value = this[kInternalState].get('subject');
    if (value === undefined) {
      value = this[kHandle].subject();
      this[kInternalState].set('subject', value);
    }
    return value;
  }

  get subjectAltName() {
    let value = this[kInternalState].get('subjectAltName');
    if (value === undefined) {
      value = this[kHandle].subjectAltName();
      this[kInternalState].set('subjectAltName', value);
    }
    return value;
  }

  get issuer() {
    let value = this[kInternalState].get('issuer');
    if (value === undefined) {
      value = this[kHandle].issuer();
      this[kInternalState].set('issuer', value);
    }
    return value;
  }

  get issuerCertificate() {
    let value = this[kInternalState].get('issuerCertificate');
    if (value === undefined) {
      const cert = this[kHandle].getIssuerCert();
      if (cert)
        value = new InternalX509Certificate(this[kHandle].getIssuerCert());
      this[kInternalState].set('issuerCertificate', value);
    }
    return value;
  }

  get infoAccess() {
    let value = this[kInternalState].get('infoAccess');
    if (value === undefined) {
      value = this[kHandle].infoAccess();
      this[kInternalState].set('infoAccess', value);
    }
    return value;
  }

  get validFrom() {
    let value = this[kInternalState].get('validFrom');
    if (value === undefined) {
      value = this[kHandle].validFrom();
      this[kInternalState].set('validFrom', value);
    }
    return value;
  }

  get validTo() {
    let value = this[kInternalState].get('validTo');
    if (value === undefined) {
      value = this[kHandle].validTo();
      this[kInternalState].set('validTo', value);
    }
    return value;
  }

  get fingerprint() {
    let value = this[kInternalState].get('fingerprint');
    if (value === undefined) {
      value = this[kHandle].fingerprint();
      this[kInternalState].set('fingerprint', value);
    }
    return value;
  }

  get fingerprint256() {
    let value = this[kInternalState].get('fingerprint256');
    if (value === undefined) {
      value = this[kHandle].fingerprint256();
      this[kInternalState].set('fingerprint256', value);
    }
    return value;
  }

  get fingerprint512() {
    let value = this[kInternalState].get('fingerprint512');
    if (value === undefined) {
      value = this[kHandle].fingerprint512();
      this[kInternalState].set('fingerprint512', value);
    }
    return value;
  }

  get keyUsage() {
    let value = this[kInternalState].get('keyUsage');
    if (value === undefined) {
      value = this[kHandle].keyUsage();
      this[kInternalState].set('keyUsage', value);
    }
    return value;
  }

  get serialNumber() {
    let value = this[kInternalState].get('serialNumber');
    if (value === undefined) {
      value = this[kHandle].serialNumber();
      this[kInternalState].set('serialNumber', value);
    }
    return value;
  }

  get raw() {
    let value = this[kInternalState].get('raw');
    if (value === undefined) {
      value = this[kHandle].raw();
      this[kInternalState].set('raw', value);
    }
    return value;
  }

  get publicKey() {
    let value = this[kInternalState].get('publicKey');
    if (value === undefined) {
      value = new PublicKeyObject(this[kHandle].publicKey());
      this[kInternalState].set('publicKey', value);
    }
    return value;
  }

  toString() {
    let value = this[kInternalState].get('pem');
    if (value === undefined) {
      value = this[kHandle].pem();
      this[kInternalState].set('pem', value);
    }
    return value;
  }

  // There's no standardized JSON encoding for X509 certs so we
  // fallback to providing the PEM encoding as a string.
  toJSON() { return this.toString(); }

  get ca() {
    let value = this[kInternalState].get('ca');
    if (value === undefined) {
      value = this[kHandle].checkCA();
      this[kInternalState].set('ca', value);
    }
    return value;
  }

  checkHost(name, options) {
    validateString(name, 'name');
    return this[kHandle].checkHost(name, getFlags(options));
  }

  checkEmail(email, options) {
    validateString(email, 'email');
    return this[kHandle].checkEmail(email, getFlags(options));
  }

  checkIP(ip, options) {
    validateString(ip, 'ip');
    // The options argument is currently undocumented since none of the options
    // have any effect on the behavior of this function. However, we still parse
    // the options argument in case OpenSSL adds flags in the future that do
    // affect the behavior of X509_check_ip. This ensures that no invalid values
    // are passed as the second argument in the meantime.
    return this[kHandle].checkIP(ip, getFlags(options));
  }

  checkIssued(otherCert) {
    if (!isX509Certificate(otherCert))
      throw new ERR_INVALID_ARG_TYPE('otherCert', 'X509Certificate', otherCert);
    return this[kHandle].checkIssued(otherCert[kHandle]);
  }

  checkPrivateKey(pkey) {
    if (!isKeyObject(pkey))
      throw new ERR_INVALID_ARG_TYPE('pkey', 'KeyObject', pkey);
    if (pkey.type !== 'private')
      throw new ERR_INVALID_ARG_VALUE('pkey', pkey);
    return this[kHandle].checkPrivateKey(pkey[kHandle]);
  }

  verify(pkey) {
    if (!isKeyObject(pkey))
      throw new ERR_INVALID_ARG_TYPE('pkey', 'KeyObject', pkey);
    if (pkey.type !== 'public')
      throw new ERR_INVALID_ARG_VALUE('pkey', pkey);
    return this[kHandle].verify(pkey[kHandle]);
  }

  toLegacyObject() {
    // TODO(tniessen): do not depend on translatePeerCertificate here, return
    // the correct legacy representation from the binding
    lazyTranslatePeerCertificate ??=
      require('_tls_common').translatePeerCertificate;
    return lazyTranslatePeerCertificate(this[kHandle].toLegacy());
  }
}

InternalX509Certificate.prototype.constructor = X509Certificate;
ObjectSetPrototypeOf(
  InternalX509Certificate.prototype,
  X509Certificate.prototype);

module.exports = {
  X509Certificate,
  InternalX509Certificate,
  isX509Certificate,
};

```"
"```javascript:test\path\test-path-parse-format.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';

const winPaths = [
  // [path, root]
  ['C:\\path\\dir\\index.html', 'C:\\'],
  ['C:\\another_path\\DIR\\1\\2\\33\\\\index', 'C:\\'],
  ['another_path\\DIR with spaces\\1\\2\\33\\index', ''],
  ['\\', '\\'],
  ['\\foo\\C:', '\\'],
  ['file', ''],
  ['file:stream', ''],
  ['.\\file', ''],
  ['C:', 'C:'],
  ['C:.', 'C:'],
  ['C:..', 'C:'],
  ['C:abc', 'C:'],
  ['C:\\', 'C:\\'],
  ['C:\\abc', 'C:\\' ],
  ['', ''],

  // unc
  ['\\\\server\\share\\file_path', '\\\\server\\share\\'],
  ['\\\\server two\\shared folder\\file path.zip',
   '\\\\server two\\shared folder\\'],
  ['\\\\teela\\admin$\\system32', '\\\\teela\\admin$\\'],
  ['\\\\?\\UNC\\server\\share', '\\\\?\\UNC\\'],
];

const winSpecialCaseParseTests = [
  ['t', { base: 't', name: 't', root: '', dir: '', ext: '' }],
  ['/foo/bar', { root: '/', dir: '/foo', base: 'bar', ext: '', name: 'bar' }],
];

const winSpecialCaseFormatTests = [
  [{ dir: 'some\\dir' }, 'some\\dir\\'],
  [{ base: 'index.html' }, 'index.html'],
  [{ root: 'C:\\' }, 'C:\\'],
  [{ name: 'index', ext: '.html' }, 'index.html'],
  [{ dir: 'some\\dir', name: 'index', ext: '.html' }, 'some\\dir\\index.html'],
  [{ root: 'C:\\', name: 'index', ext: '.html' }, 'C:\\index.html'],
  [{}, ''],
];

const unixPaths = [
  // [path, root]
  ['/home/user/dir/file.txt', '/'],
  ['/home/user/a dir/another File.zip', '/'],
  ['/home/user/a dir//another&File.', '/'],
  ['/home/user/a$$$dir//another File.zip', '/'],
  ['user/dir/another File.zip', ''],
  ['file', ''],
  ['.\\file', ''],
  ['./file', ''],
  ['C:\\foo', ''],
  ['/', '/'],
  ['', ''],
  ['.', ''],
  ['..', ''],
  ['/foo', '/'],
  ['/foo.', '/'],
  ['/foo.bar', '/'],
  ['/.', '/'],
  ['/.foo', '/'],
  ['/.foo.bar', '/'],
  ['/foo/bar.baz', '/'],
];

const unixSpecialCaseFormatTests = [
  [{ dir: 'some/dir' }, 'some/dir/'],
  [{ base: 'index.html' }, 'index.html'],
  [{ root: '/' }, '/'],
  [{ name: 'index', ext: '.html' }, 'index.html'],
  [{ dir: 'some/dir', name: 'index', ext: '.html' }, 'some/dir/index.html'],
  [{ root: '/', name: 'index', ext: '.html' }, '/index.html'],
  [{}, ''],
];

const errors = [
  { method: 'parse', input: [null] },
  { method: 'parse', input: [{}] },
  { method: 'parse', input: [true] },
  { method: 'parse', input: [1] },
  { method: 'parse', input: [] },
  { method: 'format', input: [null] },
  { method: 'format', input: [''] },
  { method: 'format', input: [true] },
  { method: 'format', input: [1] },
];

//checkParseFormat(path.win32, winPaths);
checkParseFormat(path.posix, unixPaths);
//checkSpecialCaseParseFormat(path.win32, winSpecialCaseParseTests);
//checkErrors(path.win32);
checkErrors(path.posix);
//checkFormat(path.win32, winSpecialCaseFormatTests);
checkFormat(path.posix, unixSpecialCaseFormatTests);

// Test removal of trailing path separators
const trailingTests = [
  /*[ path.win32.parse,
    [['.\\', { root: '', dir: '', base: '.', ext: '', name: '.' }],
     ['\\\\', { root: '\\', dir: '\\', base: '', ext: '', name: '' }],
     ['\\\\', { root: '\\', dir: '\\', base: '', ext: '', name: '' }],
     ['c:\\foo\\\\\\',
      { root: 'c:\\', dir: 'c:\\', base: 'foo', ext: '', name: 'foo' }],
     ['D:\\foo\\\\\\bar.baz',
      { root: 'D:\\',
        dir: 'D:\\foo\\\\',
        base: 'bar.baz',
        ext: '.baz',
        name: 'bar' },
     ],
    ],
  ],*/
  [ path.posix.parse,
    [['./', { root: '', dir: '', base: '.', ext: '', name: '.' }],
     ['//', { root: '/', dir: '/', base: '', ext: '', name: '' }],
     ['///', { root: '/', dir: '/', base: '', ext: '', name: '' }],
     ['/foo///', { root: '/', dir: '/', base: 'foo', ext: '', name: 'foo' }],
     ['/foo///bar.baz',
      { root: '/', dir: '/foo//', base: 'bar.baz', ext: '.baz', name: 'bar' },
     ],
    ],
  ],
];
const failures = [];
trailingTests.forEach((test) => {
  const parse = test[0];
  const os = /*parse === path.win32.parse ? 'win32' : */'posix';
  test[1].forEach((test) => {
    const actual = parse(test[0]);
    const expected = test[1];
    const message = `path.${os}.parse(${JSON.stringify(test[0])})\n  expect=${
      JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    const actualKeys = Object.keys(actual);
    const expectedKeys = Object.keys(expected);
    let failed = (actualKeys.length !== expectedKeys.length);
    if (!failed) {
      for (let i = 0; i < actualKeys.length; ++i) {
        const key = actualKeys[i];
        if (!expectedKeys.includes(key) || actual[key] !== expected[key]) {
          failed = true;
          break;
        }
      }
    }
    if (failed)
      failures.push(`\n${message}`);
  });
});
assert.strictEqual(failures.length, 0, failures.join(''));

function checkErrors(path) {
  errors.forEach(({ method, input }) => {
    assert.throws(() => {
      path[method].apply(path, input);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  });
}

function checkParseFormat(path, paths) {
  paths.forEach(([element, root]) => {
    const output = path.parse(element);
    assert.strictEqual(typeof output.root, 'string');
    assert.strictEqual(typeof output.dir, 'string');
    assert.strictEqual(typeof output.base, 'string');
    assert.strictEqual(typeof output.ext, 'string');
    assert.strictEqual(typeof output.name, 'string');
    assert.strictEqual(path.format(output), element);
    assert.strictEqual(output.root, root);
    assert(output.dir.startsWith(output.root));
    assert.strictEqual(output.dir, output.dir ? path.dirname(element) : '');
    assert.strictEqual(output.base, path.basename(element));
    assert.strictEqual(output.ext, path.extname(element));
  });
}

function checkSpecialCaseParseFormat(path, testCases) {
  testCases.forEach(([element, expect]) => {
    assert.deepStrictEqual(path.parse(element), expect);
  });
}

function checkFormat(path, testCases) {
  testCases.forEach(([element, expect]) => {
    assert.strictEqual(path.format(element), expect);
  });

  [null, undefined, 1, true, false, 'string'].forEach((pathObject) => {
    assert.throws(() => {
      path.format(pathObject);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""pathObject"" argument must be of type object.' +
               common.invalidArgTypeHelper(pathObject)
    });
  });
}

```"
"```javascript:modules\internal\streams\destroy.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { aggregateTwoErrors, ERR_MULTIPLE_CALLBACK } from ""../errors.js"";

const kDestroy = Symbol(""kDestroy"");
const kConstruct = Symbol(""kConstruct"");

function checkError(err, w, r) {
    if (err) {
        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
        err.stack; // eslint-disable-line no-unused-expressions

        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}

// Backwards compat. cb() is undocumented and unused in core but
// unfortunately might be used by modules.
function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    // With duplex streams we use the writable side for state.
    const s = w || r;

    if ((w && w.destroyed) || (r && r.destroyed)) {
        if (typeof cb === ""function"") {
            cb();
        }

        return this;
    }

    // We set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    checkError(err, w, r);

    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }

    // If still constructing then defer calling _destroy.
    if (!s.constructed) {
        this.once(kDestroy, function (er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }

    return this;
}

function _destroy(self, err, cb) {
    let called = false;

    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;

        const r = self._readableState;
        const w = self._writableState;

        checkError(err, w, r);

        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }

        if (typeof cb === ""function"") {
            cb(err);
        }

        if (err) {
            nextTick(emitErrorCloseNT, self, err);
        } else {
            nextTick(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    function () {
                        nextTick(onDestroy, null);
                    },
                    function (err) {
                        nextTick(onDestroy, err);
                    },
                );
            }
        }
    } catch (err) {
        onDestroy(err);
    }
}

function emitErrorCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}

function emitCloseNT(self) {
    const r = self._readableState;
    const w = self._writableState;

    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }

    if ((w && w.emitClose) || (r && r.emitClose)) {
        self.emit(""close"");
    }
}

function emitErrorNT(self, err) {
    const r = self._readableState;
    const w = self._writableState;

    if ((w && w.errorEmitted) || (r && r.errorEmitted)) {
        return;
    }

    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }

    self.emit(""error"", err);
}

function undestroy() {
    const r = this._readableState;
    const w = this._writableState;

    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }

    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}

function errorOrDestroy(stream, err, sync) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.

    const r = stream._readableState;
    const w = stream._writableState;

    if ((w && w.destroyed) || (r && r.destroyed)) {
        return this;
    }

    if ((r && r.autoDestroy) || (w && w.autoDestroy)) {
        stream.destroy(err);
    } else if (err) {
        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
        err.stack; // eslint-disable-line no-unused-expressions

        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}

function construct(stream, cb) {
    if (typeof stream._construct !== ""function"") {
        return;
    }

    const r = stream._readableState;
    const w = stream._writableState;

    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }

    stream.once(kConstruct, cb);

    if (stream.listenerCount(kConstruct) > 1) {
        // Duplex
        return;
    }

    nextTick(constructNT, stream);
}

function constructNT(stream) {
    let called = false;

    function onConstruct(err) {
        if (called) {
            errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;

        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;

        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }

        if (s.destroyed) {
            stream.emit(kDestroy, err);
        } else if (err) {
            errorOrDestroy(stream, err, true);
        } else {
            nextTick(emitConstructNT, stream);
        }
    }

    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    function () {
                        nextTick(onConstruct, null);
                    },
                    function (err) {
                        nextTick(onConstruct, err);
                    },
                );
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}

function emitConstructNT(stream) {
    stream.emit(kConstruct);
}

function isRequest(stream) {
    return stream && stream.setHeader && typeof stream.abort === ""function"";
}

// Normalize destroy for legacy.
function destroyer(stream, err) {
    if (!stream) return;
    if (isRequest(stream)) return stream.abort();
    if (isRequest(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === ""function"") return stream.destroy(err);
    if (typeof stream.close === ""function"") return stream.close();
}

export default {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy,
};
export { construct, destroy, destroyer, errorOrDestroy, undestroy };
```"
"```javascript:modules\internal_binding\constants.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
export const os = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4,
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18,
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30, // TODO(uki00a): In Solaris, this should be `19`. Is there any way to address this difference?
    SIGSTKFLT: 16,
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20,
  },
};
export const fs = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4,
};
export const crypto = {
  OPENSSL_VERSION_NUMBER: 269488319,
  SSL_OP_ALL: 2147485780,
  SSL_OP_ALLOW_NO_DHE_KEX: 1024,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
  SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
  SSL_OP_CISCO_ANYCONNECT: 32768,
  SSL_OP_COOKIE_EXCHANGE: 8192,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
  SSL_OP_EPHEMERAL_RSA: 0,
  SSL_OP_LEGACY_SERVER_CONNECT: 4,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
  SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
  SSL_OP_NETSCAPE_CA_DN_BUG: 0,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NO_COMPRESSION: 131072,
  SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
  SSL_OP_NO_QUERY_MTU: 4096,
  SSL_OP_NO_RENEGOTIATION: 1073741824,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
  SSL_OP_NO_SSLv2: 0,
  SSL_OP_NO_SSLv3: 33554432,
  SSL_OP_NO_TICKET: 16384,
  SSL_OP_NO_TLSv1: 67108864,
  SSL_OP_NO_TLSv1_1: 268435456,
  SSL_OP_NO_TLSv1_2: 134217728,
  SSL_OP_NO_TLSv1_3: 536870912,
  SSL_OP_PKCS1_CHECK_1: 0,
  SSL_OP_PKCS1_CHECK_2: 0,
  SSL_OP_PRIORITIZE_CHACHA: 2097152,
  SSL_OP_SINGLE_DH_USE: 0,
  SSL_OP_SINGLE_ECDH_USE: 0,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
  SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
  SSL_OP_TLS_D5_BUG: 0,
  SSL_OP_TLS_ROLLBACK_BUG: 8388608,
  ENGINE_METHOD_RSA: 1,
  ENGINE_METHOD_DSA: 2,
  ENGINE_METHOD_DH: 4,
  ENGINE_METHOD_RAND: 8,
  ENGINE_METHOD_EC: 2048,
  ENGINE_METHOD_CIPHERS: 64,
  ENGINE_METHOD_DIGESTS: 128,
  ENGINE_METHOD_PKEY_METHS: 512,
  ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
  ENGINE_METHOD_ALL: 65535,
  ENGINE_METHOD_NONE: 0,
  DH_CHECK_P_NOT_SAFE_PRIME: 2,
  DH_CHECK_P_NOT_PRIME: 1,
  DH_UNABLE_TO_CHECK_GENERATOR: 4,
  DH_NOT_SUITABLE_GENERATOR: 8,
  ALPN_ENABLED: 1,
  RSA_PKCS1_PADDING: 1,
  RSA_SSLV23_PADDING: 2,
  RSA_NO_PADDING: 3,
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_X931_PADDING: 5,
  RSA_PKCS1_PSS_PADDING: 6,
  RSA_PSS_SALTLEN_DIGEST: -1,
  RSA_PSS_SALTLEN_MAX_SIGN: -2,
  RSA_PSS_SALTLEN_AUTO: -2,
  defaultCoreCipherList:
    ""TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"",
  TLS1_VERSION: 769,
  TLS1_1_VERSION: 770,
  TLS1_2_VERSION: 771,
  TLS1_3_VERSION: 772,
  POINT_CONVERSION_COMPRESSED: 2,
  POINT_CONVERSION_UNCOMPRESSED: 4,
  POINT_CONVERSION_HYBRID: 6,
};
export const zlib = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  ZLIB_VERNUM: 4784,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_PARAM_MODE: 0,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31,
};
export const trace = {
  TRACE_EVENT_PHASE_BEGIN: 66,
  TRACE_EVENT_PHASE_END: 69,
  TRACE_EVENT_PHASE_COMPLETE: 88,
  TRACE_EVENT_PHASE_INSTANT: 73,
  TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
  TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
  TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
  TRACE_EVENT_PHASE_ASYNC_END: 70,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
  TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
  TRACE_EVENT_PHASE_FLOW_STEP: 116,
  TRACE_EVENT_PHASE_FLOW_END: 102,
  TRACE_EVENT_PHASE_METADATA: 77,
  TRACE_EVENT_PHASE_COUNTER: 67,
  TRACE_EVENT_PHASE_SAMPLE: 80,
  TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
  TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
  TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
  TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
  TRACE_EVENT_PHASE_MARK: 82,
  TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
  TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
  TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
  TRACE_EVENT_PHASE_LINK_IDS: 61,
};

```"
"```javascript:test\crypto\test-crypto-scrypt.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from'assert';
import crypto from 'crypto';

const good = [
  // Zero-length key is legal, functions as a parameter validation check.
  {
    pass: '',
    salt: '',
    keylen: 0,
    N: 16,
    p: 1,
    r: 1,
    expected: '',
  },
  // Test vectors from https://tools.ietf.org/html/rfc7914#page-13 that
  // should pass.  Note that the test vector with N=1048576 is omitted
  // because it takes too long to complete and uses over 1 GiB of memory.
  {
    pass: '',
    salt: '',
    keylen: 64,
    N: 16,
    p: 1,
    r: 1,
    expected:
        '77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442' +
        'fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906',
  },
  {
    pass: 'password',
    salt: 'NaCl',
    keylen: 64,
    N: 1024,
    p: 16,
    r: 8,
    expected:
        'fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b373162' +
        '2eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640',
  },
  {
    pass: 'pleaseletmein',
    salt: 'SodiumChloride',
    keylen: 64,
    N: 16384,
    p: 1,
    r: 8,
    expected:
        '7023bdcb3afd7348461c06cd81fd38ebfda8fbba904f8e3ea9b543f6545da1f2' +
        'd5432955613f0fcf62d49705242a9af9e61e85dc0d651e40dfcf017b45575887',
  },
  {
    pass: '',
    salt: '',
    keylen: 64,
    cost: 16,
    parallelization: 1,
    blockSize: 1,
    expected:
        '77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442' +
        'fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906',
  },
  {
    pass: 'password',
    salt: 'NaCl',
    keylen: 64,
    cost: 1024,
    parallelization: 16,
    blockSize: 8,
    expected:
        'fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b373162' +
        '2eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640',
  },
  {
    pass: 'pleaseletmein',
    salt: 'SodiumChloride',
    keylen: 64,
    cost: 16384,
    parallelization: 1,
    blockSize: 8,
    expected:
        '7023bdcb3afd7348461c06cd81fd38ebfda8fbba904f8e3ea9b543f6545da1f2' +
        'd5432955613f0fcf62d49705242a9af9e61e85dc0d651e40dfcf017b45575887',
  },
];

// Test vectors that should fail.
const bad = [
  { N: 1, p: 1, r: 1 },         // N < 2
  { N: 3, p: 1, r: 1 },         // Not power of 2.
  { N: 1, cost: 1 },            // Both N and cost
  { p: 1, parallelization: 1 }, // Both p and parallelization
  { r: 1, blockSize: 1 },        // Both r and blocksize
];

// Test vectors where 128*N*r exceeds maxmem.
const toobig = [
  { N: 2 ** 16, p: 1, r: 1 },   // N >= 2**(r*16)
  { N: 2, p: 2 ** 30, r: 1 },   // p > (2**30-1)/r
  { N: 2 ** 20, p: 1, r: 8 },
  { N: 2 ** 10, p: 1, r: 8, maxmem: 2 ** 20 },
];

const badargs = [
  {
    args: [],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""password""/ },
  },
  {
    args: [null],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""password""/ },
  },
  {
    args: [''],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""salt""/ },
  },
  {
    args: ['', null],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""salt""/ },
  },
  {
    args: ['', ''],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""keylen""/ },
  },
  {
    args: ['', '', null],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""keylen""/ },
  },
  {
    args: ['', '', .42],
    expected: { code: 'ERR_OUT_OF_RANGE', message: /""keylen""/ },
  },
  {
    args: ['', '', -42],
    expected: { code: 'ERR_OUT_OF_RANGE', message: /""keylen""/ },
  },
  {
    args: ['', '', 2147485780],
    expected: { code: 'ERR_OUT_OF_RANGE', message: /""keylen""/ },
  },
];

for (const options of good) {
  const { pass, salt, keylen, expected } = options;
  const actual = crypto.scryptSync(pass, salt, keylen, options);
  assert.strictEqual(actual.toString('hex'), expected);
  crypto.scrypt(pass, salt, keylen, options, common.mustSucceed((actual) => {
    assert.strictEqual(actual.toString('hex'), expected);
  }));
}

for (const options of bad) {
  const expected = {
    message: /Invalid scrypt param/,
  };
  assert.throws(() => crypto.scrypt('pass', 'salt', 1, options, () => {}),
                expected);
  assert.throws(() => crypto.scryptSync('pass', 'salt', 1, options),
                expected);
}

for (const options of toobig) {
  const expected = {
    message: /Invalid scrypt param/
  };
  assert.throws(() => crypto.scrypt('pass', 'salt', 1, options, () => {}),
                expected);
  assert.throws(() => crypto.scryptSync('pass', 'salt', 1, options),
                expected);
}

{
  const defaults = { N: 16384, p: 1, r: 8 };
  const expected = crypto.scryptSync('pass', 'salt', 1, defaults);
  const actual = crypto.scryptSync('pass', 'salt', 1);
  assert.deepStrictEqual(actual.toString('hex'), expected.toString('hex'));
  crypto.scrypt('pass', 'salt', 1, common.mustSucceed((actual) => {
    assert.deepStrictEqual(actual.toString('hex'), expected.toString('hex'));
  }));
}
/* deprecated
{
  const defaultEncoding = crypto.DEFAULT_ENCODING;
  const defaults = { N: 16384, p: 1, r: 8 };
  const expected = crypto.scryptSync('pass', 'salt', 1, defaults);

  const testEncoding = 'latin1';
  crypto.DEFAULT_ENCODING = testEncoding;
  const actual = crypto.scryptSync('pass', 'salt', 1);
  assert.deepStrictEqual(actual, expected.toString(testEncoding));

  crypto.scrypt('pass', 'salt', 1, common.mustSucceed((actual) => {
    assert.deepStrictEqual(actual, expected.toString(testEncoding));
  }));

  crypto.DEFAULT_ENCODING = defaultEncoding;
}
*/
for (const { args, expected } of badargs) {
  assert.throws(() => crypto.scrypt(...args), expected);
  assert.throws(() => crypto.scryptSync(...args), expected);
}

{
  const expected = { code: 'ERR_INVALID_ARG_TYPE' };
  assert.throws(() => crypto.scrypt('', '', 42, null), expected);
  assert.throws(() => crypto.scrypt('', '', 42, {}, null), expected);
  assert.throws(() => crypto.scrypt('', '', 42, {}), expected);
  assert.throws(() => crypto.scrypt('', '', 42, {}, {}), expected);
}

{
  // Values for maxmem that do not fit in 32 bits but that are still safe
  // integers should be allowed.
  crypto.scrypt('', '', 4, { maxmem: 2 ** 52 },
                common.mustSucceed((actual) => {
                  assert.strictEqual(actual.toString('hex'), 'd72c87d0');
                }));

  // Values that exceed Number.isSafeInteger should not be allowed.
  assert.throws(() => crypto.scryptSync('', '', 0, { maxmem: 2 ** 53 }), {
    code: 'ERR_OUT_OF_RANGE'
  });
}

{
  // Regression test for https://github.com/nodejs/node/issues/28836.

  function testParameter(name, value) {
    let accessCount = 0;

    // Find out how often the value is accessed.
    crypto.scryptSync('', '', 1, {
      get [name]() {
        accessCount++;
        return value;
      }
    });

    // Try to crash the process on the last access.
    assert.throws(() => {
      crypto.scryptSync('', '', 1, {
        get [name]() {
          if (--accessCount === 0)
            return '';
          return value;
        }
      });
    }, {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  }

  [
    ['N', 16384], ['cost', 16384],
    ['r', 8], ['blockSize', 8],
    ['p', 1], ['parallelization', 1],
  ].forEach((arg) => testParameter(...arg));
}

```"
"```javascript:test\crypto\test-crypto-prime.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const {
  generatePrime,
  generatePrimeSync,
  checkPrime,
  checkPrimeSync,
} = require('crypto');

const { promisify } = require('util');
const pgeneratePrime = promisify(generatePrime);
const pCheckPrime = promisify(checkPrime);

['hello', false, {}, []].forEach((i) => {
  assert.throws(() => generatePrime(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

['hello', false, 123].forEach((i) => {
  assert.throws(() => generatePrime(80, i, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(80, i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

['hello', false, 123].forEach((i) => {
  assert.throws(() => generatePrime(80, {}), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

[-1, 0, 2 ** 31, 2 ** 31 + 1, 2 ** 32 - 1, 2 ** 32].forEach((size) => {
  assert.throws(() => generatePrime(size, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: />= 1 && <= 2147483647/
  });
  assert.throws(() => generatePrimeSync(size), {
    code: 'ERR_OUT_OF_RANGE',
    message: />= 1 && <= 2147483647/
  });
});

['test', -1, {}, []].forEach((i) => {
  assert.throws(() => generatePrime(8, { safe: i }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrime(8, { rem: i }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrime(8, { add: i }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(8, { safe: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(8, { rem: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(8, { add: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

{
  // Negative BigInts should not be converted to 0 silently.

  assert.throws(() => generatePrime(20, { add: -1n }, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""options.add"" is out of range. It must be >= 0. ' +
             'Received -1n'
  });

  assert.throws(() => generatePrime(20, { rem: -1n }, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""options.rem"" is out of range. It must be >= 0. ' +
             'Received -1n'
  });

  assert.throws(() => checkPrime(-1n, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""candidate"" is out of range. It must be >= 0. ' +
             'Received -1n'
  });
}

generatePrime(80, common.mustSucceed((prime) => {
  assert(checkPrimeSync(prime));
  checkPrime(prime, common.mustSucceed((result) => {
    assert(result);
  }));
}));

assert(checkPrimeSync(generatePrimeSync(80)));

generatePrime(80, {}, common.mustSucceed((prime) => {
  assert(checkPrimeSync(prime));
}));

assert(checkPrimeSync(generatePrimeSync(80, {})));

generatePrime(32, { safe: true }, common.mustSucceed((prime) => {
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  const check = (val - 1) / 2;
  buf.writeUInt32BE(check);
  assert(checkPrimeSync(buf));
}));

{
  const prime = generatePrimeSync(32, { safe: true });
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  const check = (val - 1) / 2;
  buf.writeUInt32BE(check);
  assert(checkPrimeSync(buf));
}

const add = 12;
const rem = 11;
const add_buf = Buffer.from([add]);
const rem_buf = Buffer.from([rem]);
generatePrime(
  32,
  { add: add_buf, rem: rem_buf },
  common.mustSucceed((prime) => {
    assert(checkPrimeSync(prime));
    const buf = Buffer.from(prime);
    const val = buf.readUInt32BE();
    assert.strictEqual(val % add, rem);
  }));

{
  const prime = generatePrimeSync(32, { add: add_buf, rem: rem_buf });
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  assert.strictEqual(val % add, rem);
}

{
  const prime = generatePrimeSync(32, { add: BigInt(add), rem: BigInt(rem) });
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  assert.strictEqual(val % add, rem);
}

{
  // The behavior when specifying only add without rem should depend on the
  // safe option.

  if (process.versions.openssl >= '1.1.1f') {
    generatePrime(128, {
      bigint: true,
      add: 5n
    }, common.mustSucceed((prime) => {
      assert(checkPrimeSync(prime));
      assert.strictEqual(prime % 5n, 1n);
    }));

    generatePrime(128, {
      bigint: true,
      safe: true,
      add: 5n
    }, common.mustSucceed((prime) => {
      assert(checkPrimeSync(prime));
      assert.strictEqual(prime % 5n, 3n);
    }));
  }
}

{
  // This is impossible because it implies (prime % 2**64) == 1 and
  // prime < 2**64, meaning prime = 1, but 1 is not prime.
  for (const add of [2n ** 64n, 2n ** 65n]) {
    assert.throws(() => {
      generatePrimeSync(64, { add });
    }, {
      code: 'ERR_OUT_OF_RANGE',
      message: 'invalid options.add'
    });
  }

  // Any parameters with rem >= add lead to an impossible condition.
  for (const rem of [7n, 8n, 3000n]) {
    assert.throws(() => {
      generatePrimeSync(64, { add: 7n, rem });
    }, {
      code: 'ERR_OUT_OF_RANGE',
      message: 'invalid options.rem'
    });
  }

  // This is possible, but not allowed. It implies prime == 7, which means that
  // we did not actually generate a random prime.
  assert.throws(() => {
    generatePrimeSync(3, { add: 8n, rem: 7n });
  }, {
    code: 'ERR_OUT_OF_RANGE'
  });

  if (process.versions.openssl >= '1.1.1f') {
    // This is possible and allowed (but makes little sense).
    assert.strictEqual(generatePrimeSync(4, {
      add: 15n,
      rem: 13n,
      bigint: true
    }), 13n);
  }
}

[1, 'hello', {}, []].forEach((i) => {
  assert.throws(() => checkPrime(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

['hello', {}, []].forEach((i) => {
  assert.throws(() => checkPrime(2, { checks: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  }, common.mustNotCall());
  assert.throws(() => checkPrimeSync(2, { checks: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

assert(!checkPrimeSync(Buffer.from([0x1])));
assert(checkPrimeSync(Buffer.from([0x2])));
assert(checkPrimeSync(Buffer.from([0x3])));
assert(!checkPrimeSync(Buffer.from([0x4])));

assert(
  !checkPrimeSync(
    Buffer.from([0x1]),
    {
      fast: true,
      trialDivision: true,
      checks: 10
    }));

(async function() {
  const prime = await pgeneratePrime(36);
  assert(await pCheckPrime(prime));
})().then(common.mustCall());

assert.throws(() => {
  generatePrimeSync(32, { bigint: '' });
}, { code: 'ERR_INVALID_ARG_TYPE' });

assert.throws(() => {
  generatePrime(32, { bigint: '' }, common.mustNotCall());
}, { code: 'ERR_INVALID_ARG_TYPE' });

{
  const prime = generatePrimeSync(3, { bigint: true });
  assert.strictEqual(typeof prime, 'bigint');
  assert.strictEqual(prime, 7n);
  assert(checkPrimeSync(prime));
  checkPrime(prime, common.mustSucceed(assert));
}

{
  generatePrime(3, { bigint: true }, common.mustSucceed((prime) => {
    assert.strictEqual(typeof prime, 'bigint');
    assert.strictEqual(prime, 7n);
    assert(checkPrimeSync(prime));
    checkPrime(prime, common.mustSucceed(assert));
  }));
}

```"
"```javascript:test\fs\test-fs-read-stream.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

import child_process from 'child_process';
import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const fn = fixtures.path('elipses.txt');
const rangeFile = fixtures.path('x.txt');

function test1(options) {
  let paused = false;
  let bytesRead = 0;

  const file = fs.createReadStream(fn, options);
  const fileSize = fs.statSync(fn).size;

  assert.strictEqual(file.bytesRead, 0);

  file.on('open', common.mustCall(function(fd) {
    file.length = 0;
    assert.strictEqual(typeof fd, 'number');
    assert.strictEqual(file.bytesRead, 0);
    assert.ok(file.readable);

    // GH-535
    file.pause();
    file.resume();
    file.pause();
    file.resume();
  }));

  file.on('data', function(data) {
    assert.ok(data instanceof Buffer);
    assert.ok(data.byteOffset % 8 === 0);
    assert.ok(!paused);
    file.length += data.length;

    bytesRead += data.length;
    assert.strictEqual(file.bytesRead, bytesRead);

    paused = true;
    file.pause();

    setTimeout(function() {
      paused = false;
      file.resume();
    }, 10);
  });


  file.on('end', common.mustCall(function(chunk) {
    assert.strictEqual(bytesRead, fileSize);
    assert.strictEqual(file.bytesRead, fileSize);
  }));


  file.on('close', common.mustCall(function() {
    assert.strictEqual(bytesRead, fileSize);
    assert.strictEqual(file.bytesRead, fileSize);
  }));

  process.on('exit', function() {
    assert.strictEqual(file.length, 30000);
  });
}

test1({});
test1({
  fs: {
    open: common.mustCall(fs.open),
    read: common.mustCallAtLeast(fs.read, 1),
    close: common.mustCall(fs.close),
  }
});

{
  const file = fs.createReadStream(fn, common.mustNotMutateObjectDeep({ encoding: 'utf8' }));
  file.length = 0;
  file.on('data', function(data) {
    assert.strictEqual(typeof data, 'string');
    file.length += data.length;

    for (let i = 0; i < data.length; i++) {
      // http://www.fileformat.info/info/unicode/char/2026/index.htm
      assert.strictEqual(data[i], '\u2026');
    }
  });

  file.on('close', common.mustCall());

  process.on('exit', function() {
    assert.strictEqual(file.length, 10000);
  });
}

{
  const file =
    fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ bufferSize: 1, start: 1, end: 2 }));
  let contentRead = '';
  file.on('data', function(data) {
    contentRead += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function(data) {
    assert.strictEqual(contentRead, 'yz');
  }));
}

{
  const file = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ bufferSize: 1, start: 1 }));
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

{
  // Ref: https://github.com/nodejs/node-v0.x-archive/issues/2320
  const file = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ bufferSize: 1.23, start: 1 }));
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

assert.throws(
  () => {
    fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ start: 10, end: 2 }));
  },
  {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""start"" is out of range. It must be <= ""end""' +
             ' (here: 2). Received 10',
    name: 'RangeError'
  });

{
  const stream = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ start: 0, end: 0 }));
  stream.data = '';

  stream.on('data', function(chunk) {
    stream.data += chunk;
  });

  stream.on('end', common.mustCall(function() {
    assert.strictEqual(stream.data, 'x');
  }));
}

{
  // Verify that end works when start is not specified.
  const stream = new fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ end: 1 }));
  stream.data = '';

  stream.on('data', function(chunk) {
    stream.data += chunk;
  });

  stream.on('end', common.mustCall(function() {
    assert.strictEqual(stream.data, 'xy');
  }));
}

if (!common.isWindows) {
  // Verify that end works when start is not specified, and we do not try to
  // use positioned reads. This makes sure that this keeps working for
  // non-seekable file descriptors.
  tmpdir.refresh();
  const filename = `${tmpdir.path}/foo.pipe`;
  const mkfifoResult = child_process.spawnSync('mkfifo', [filename]);
  if (!mkfifoResult.error) {
    child_process.exec(`echo ""xyz foobar"" > '${filename}'`);
    const stream = new fs.createReadStream(filename, common.mustNotMutateObjectDeep({ end: 1 }));
    stream.data = '';

    stream.on('data', function(chunk) {
      stream.data += chunk;
    });

    stream.on('end', common.mustCall(function() {
      assert.strictEqual(stream.data, 'xy');
      fs.unlinkSync(filename);
    }));
  } else {
    common.printSkipMessage('mkfifo not available');
  }
}

{
  // Pause and then resume immediately.
  const pauseRes = fs.createReadStream(rangeFile);
  pauseRes.pause();
  pauseRes.resume();
}

{
  let file = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ autoClose: false }));
  let data = '';
  file.on('data', function(chunk) { data += chunk; });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(data, 'xyz\n');
    process.nextTick(function() {
      assert(!file.closed);
      assert(!file.destroyed);
      fileNext();
    });
  }));

  function fileNext() {
    // This will tell us if the fd is usable again or not.
    file = fs.createReadStream(null, common.mustNotMutateObjectDeep({ fd: file.fd, start: 0 }));
    file.data = '';
    file.on('data', function(data) {
      file.data += data;
    });
    file.on('end', common.mustCall(function(err) {
      assert.strictEqual(file.data, 'xyz\n');
    }));
    process.on('exit', function() {
      assert(file.closed);
      assert(file.destroyed);
    });
  }
}

{
  // Just to make sure autoClose won't close the stream because of error.
  const file = fs.createReadStream(null, common.mustNotMutateObjectDeep({ fd: 13337, autoClose: false }));
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());
  process.on('exit', function() {
    assert(!file.closed);
    assert(!file.destroyed);
    assert(file.fd);
  });
}

{
  // Make sure stream is destroyed when file does not exist.
  const file = fs.createReadStream('/path/to/file/that/does/not/exist');
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());

  process.on('exit', function() {
    assert(file.closed);
    assert(file.destroyed);
  });
}

```"
"```javascript:test\crypto\test-crypto-cipher-decipher.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

if (common.hasFipsCrypto)
  common.skip('not supported in FIPS mode');

const crypto = require('crypto');
const assert = require('assert');

common.expectWarning({
  Warning: [
    ['Use Cipheriv for counter mode of aes-256-gcm'],
  ],
  DeprecationWarning: [
    ['crypto.createCipher is deprecated.', 'DEP0106'],
  ]
});

function testCipher1(key) {
  // Test encryption and decryption
  const plaintext = 'Keep this a secret? No! Tell everyone about node.js!';
  const cipher = crypto.createCipher('aes192', key);

  // Encrypt plaintext which is in utf8 format
  // to a ciphertext which will be in hex
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  // Only use binary or hex, not base64.
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipher('aes192', key);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);

  // Streaming cipher interface
  // NB: In real life, it's not guaranteed that you can get all of it
  // in a single read() like this.  But in this case, we know it's
  // quite small, so there's no harm.
  const cStream = crypto.createCipher('aes192', key);
  cStream.end(plaintext);
  ciph = cStream.read();

  const dStream = crypto.createDecipher('aes192', key);
  dStream.end(ciph);
  txt = dStream.read().toString('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher2(key) {
  // Encryption and decryption with Base64.
  // Reported in https://github.com/joyent/node/issues/738
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipher('aes256', key);

  // Encrypt plaintext which is in utf8 format to a ciphertext which will be in
  // Base64.
  let ciph = cipher.update(plaintext, 'utf8', 'base64');
  ciph += cipher.final('base64');

  const decipher = crypto.createDecipher('aes256', key);
  let txt = decipher.update(ciph, 'base64', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}

testCipher1('MySecretKey123');
testCipher1(Buffer.from('MySecretKey123'));

testCipher2('0123456789abcdef');
testCipher2(Buffer.from('0123456789abcdef'));

{
  const Cipher = crypto.Cipher;
  const instance = crypto.Cipher('aes-256-cbc', 'secret');
  assert(instance instanceof Cipher, 'Cipher is expected to return a new ' +
                                     'instance when called without `new`');

  assert.throws(
    () => crypto.createCipher(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createCipher('aes-256-cbc', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });

  assert.throws(
    () => crypto.createCipher('aes-256-cbc', 'secret').update(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createCipher('aes-256-cbc', 'secret').setAAD(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

{
  const Decipher = crypto.Decipher;
  const instance = crypto.Decipher('aes-256-cbc', 'secret');
  assert(instance instanceof Decipher, 'Decipher is expected to return a new ' +
                                       'instance when called without `new`');

  assert.throws(
    () => crypto.createDecipher(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createDecipher('aes-256-cbc', 'secret').setAuthTag(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createDecipher('aes-256-cbc', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

// Base64 padding regression test, see
// https://github.com/nodejs/node-v0.x-archive/issues/4837.
{
  const c = crypto.createCipher('aes-256-cbc', 'secret');
  const s = c.update('test', 'utf8', 'base64') + c.final('base64');
  assert.strictEqual(s, '375oxUQCIocvxmC5At+rvA==');
}

// Calling Cipher.final() or Decipher.final() twice should error but
// not assert. See https://github.com/nodejs/node-v0.x-archive/issues/4886.
{
  const c = crypto.createCipher('aes-256-cbc', 'secret');
  try { c.final('xxx'); } catch { /* Ignore. */ }
  try { c.final('xxx'); } catch { /* Ignore. */ }
  try { c.final('xxx'); } catch { /* Ignore. */ }
  const d = crypto.createDecipher('aes-256-cbc', 'secret');
  try { d.final('xxx'); } catch { /* Ignore. */ }
  try { d.final('xxx'); } catch { /* Ignore. */ }
  try { d.final('xxx'); } catch { /* Ignore. */ }
}

// Regression test for https://github.com/nodejs/node-v0.x-archive/issues/5482:
// string to Cipher#update() should not assert.
{
  const c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update');
  c.final();
}

// https://github.com/nodejs/node-v0.x-archive/issues/5655 regression tests,
// 'utf-8' and 'utf8' are identical.
{
  let c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update', '');  // Defaults to ""utf8"".
  c.final('utf-8');  // Should not throw.

  c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update', 'utf8');
  c.final('utf-8');  // Should not throw.

  c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update', 'utf-8');
  c.final('utf8');  // Should not throw.
}

// Regression tests for https://github.com/nodejs/node/issues/8236.
{
  const key = '0123456789abcdef';
  const plaintext = 'Top secret!!!';
  const c = crypto.createCipher('aes192', key);
  let ciph = c.update(plaintext, 'utf16le', 'base64');
  ciph += c.final('base64');

  let decipher = crypto.createDecipher('aes192', key);

  let txt;
  txt = decipher.update(ciph, 'base64', 'ucs2');
  txt += decipher.final('ucs2');
  assert.strictEqual(txt, plaintext);

  decipher = crypto.createDecipher('aes192', key);
  txt = decipher.update(ciph, 'base64', 'ucs-2');
  txt += decipher.final('ucs-2');
  assert.strictEqual(txt, plaintext);

  decipher = crypto.createDecipher('aes192', key);
  txt = decipher.update(ciph, 'base64', 'utf-16le');
  txt += decipher.final('utf-16le');
  assert.strictEqual(txt, plaintext);
}

// setAutoPadding/setAuthTag/setAAD should return `this`
{
  const key = '0123456789';
  const tagbuf = Buffer.from('auth_tag');
  const aadbuf = Buffer.from('aadbuf');
  const decipher = crypto.createDecipher('aes-256-gcm', key);
  assert.strictEqual(decipher.setAutoPadding(), decipher);
  assert.strictEqual(decipher.setAuthTag(tagbuf), decipher);
  assert.strictEqual(decipher.setAAD(aadbuf), decipher);
}

// Error throwing in setAAD/setAuthTag/getAuthTag/setAutoPadding
{
  const key = '0123456789';
  const aadbuf = Buffer.from('aadbuf');
  const data = Buffer.from('test-crypto-cipher-decipher');

  const cipher = crypto.createCipher('aes-256-gcm', key);
  cipher.setAAD(aadbuf);
  cipher.setAutoPadding();

  assert.throws(
    () => cipher.getAuthTag(),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation getAuthTag'
    }
  );

  const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);

  const decipher = crypto.createDecipher('aes-256-gcm', key);
  decipher.setAAD(aadbuf);
  decipher.setAuthTag(cipher.getAuthTag());
  decipher.setAutoPadding();
  decipher.update(encrypted);
  decipher.final();

  assert.throws(
    () => decipher.setAAD(aadbuf),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation setAAD'
    });

  assert.throws(
    () => decipher.setAuthTag(cipher.getAuthTag()),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation setAuthTag'
    });

  assert.throws(
    () => decipher.setAutoPadding(),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation setAutoPadding'
    }
  );
}

```"
"```javascript:test\crypto\test-crypto-cipheriv-decipheriv.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

function testCipher1(key, iv) {
  return; // unsupport des-ebe3-cbc
  // Test encryption and decryption with explicit key and iv
  const plaintext =
          '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
          'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
          'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext,
                     `encryption/decryption with key ${key} and iv ${iv}`);

  // Streaming cipher interface
  // NB: In real life, it's not guaranteed that you can get all of it
  // in a single read() like this.  But in this case, we know it's
  // quite small, so there's no harm.
  const cStream = crypto.createCipheriv('des-ede3-cbc', key, iv);
  cStream.end(plaintext);
  ciph = cStream.read();

  const dStream = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  dStream.end(ciph);
  txt = dStream.read().toString('utf8');

  assert.strictEqual(txt, plaintext,
                     `streaming cipher with key ${key} and iv ${iv}`);
}


function testCipher2(key, iv) {
  return; // unsupport des-ebe3-cbc
  // Test encryption and decryption with explicit key and iv
  const plaintext =
          '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
          'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
          'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'buffer', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext,
                     `encryption/decryption with key ${key} and iv ${iv}`);
}


function testCipher3(key, iv) {
  return; // unsupport id-aes128-wrap
  // Test encryption and decryption with explicit key and iv.
  // AES Key Wrap test vector comes from RFC3394
  const plaintext = Buffer.from('00112233445566778899AABBCCDDEEFF', 'hex');

  const cipher = crypto.createCipheriv('id-aes128-wrap', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);
  const ciph2 = Buffer.from('1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5',
                            'hex');
  assert(ciph.equals(ciph2));
  const decipher = crypto.createDecipheriv('id-aes128-wrap', key, iv);
  let deciph = decipher.update(ciph, 'buffer');
  deciph = Buffer.concat([deciph, decipher.final()]);

  assert(deciph.equals(plaintext),
         `encryption/decryption with key ${key} and iv ${iv}`);
}

// copy from testCipher1 but used aes-128-gcm
function testCipher4(key, iv) {
  // Test encryption and decryption with explicit key and iv
  const plaintext =
          '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
          'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
          'jAfaFg**';
  
  const cipher = crypto.createCipheriv('aes-128-gcm', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  ciph += cipher.final('hex');
  let tag = cipher.getAuthTag();

  const decipher = crypto.createDecipheriv('aes-128-gcm', key, iv);
  decipher.setAuthTag(tag);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext,
                     `encryption/decryption with key ${key} and iv ${iv}`);
}

{
  const Cipheriv = crypto.Cipheriv;
  const key = '1234567890123456';
  const iv = '123456789012';

  const instance = Cipheriv('aes-128-gcm', key, iv);
  assert(instance instanceof Cipheriv, 'Cipheriv is expected to return a new ' +
                                       'instance when called without `new`');

  assert.throws(
    () => crypto.createCipheriv(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createCipheriv('aes-128-gcm', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createCipheriv('aes-128-gcm', key, 10),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

{
  const Decipheriv = crypto.Decipheriv;
  const key = '1234567890123456';
  const iv = '123456789012';

  const instance = Decipheriv('aes-128-gcm', key, iv);
  assert(instance instanceof Decipheriv, 'Decipheriv expected to return a new' +
                                         ' instance when called without `new`');

  assert.throws(
    () => crypto.createDecipheriv(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createDecipheriv('aes-128-gcm', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createDecipheriv('aes-128-gcm', key, 10),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

testCipher4('0123456789abcdef', '0123456789ab');
testCipher4('0123456789abcdef', Buffer.from('0123456789ab'));
testCipher4(Buffer.from('0123456789abcdef'), '0123456789ab');
testCipher4(Buffer.from('0123456789abcdef'), Buffer.from('0123456789ab'));

/*
testCipher1('0123456789abcd0123456789', '12345678');
testCipher1('0123456789abcd0123456789', Buffer.from('12345678'));
testCipher1(Buffer.from('0123456789abcd0123456789'), '12345678');
testCipher1(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));
testCipher2(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));

if (!common.hasFipsCrypto) {
  testCipher3(Buffer.from('000102030405060708090A0B0C0D0E0F', 'hex'),
              Buffer.from('A6A6A6A6A6A6A6A6', 'hex'));
}

// Zero-sized IV or null should be accepted in ECB mode.
crypto.createCipheriv('aes-128-ecb', Buffer.alloc(16), Buffer.alloc(0));
crypto.createCipheriv('aes-128-ecb', Buffer.alloc(16), null);
*/
const errMessage = /Invalid initialization vector/;
/*
// But non-empty IVs should be rejected.
for (let n = 1; n < 256; n += 1) {
  assert.throws(
    () => crypto.createCipheriv('aes-128-ecb', Buffer.alloc(16),
                                Buffer.alloc(n)),
    errMessage);
}

// Correctly sized IV should be accepted in CBC mode.
crypto.createCipheriv('aes-128-cbc', Buffer.alloc(16), Buffer.alloc(16));

// But all other IV lengths should be rejected.
for (let n = 0; n < 256; n += 1) {
  if (n === 16) continue;
  assert.throws(
    () => crypto.createCipheriv('aes-128-cbc', Buffer.alloc(16),
                                Buffer.alloc(n)),
    errMessage);
}

// And so should null be.
assert.throws(() => {
  crypto.createCipheriv('aes-128-cbc', Buffer.alloc(16), null);
}, /Invalid initialization vector/);
*/
// Zero-sized IV should be rejected in GCM mode.
assert.throws(
  () => crypto.createCipheriv('aes-128-gcm', Buffer.alloc(16),
                              Buffer.alloc(0)),
  errMessage);

// But all other IV lengths should be accepted.
/* Unsupported
const minIvLength = common.hasOpenSSL3 ? 8 : 1;
const maxIvLength = common.hasOpenSSL3 ? 64 : 256;
for (let n = minIvLength; n < maxIvLength; n += 1) {
  if (common.hasFipsCrypto && n < 12) continue;
  crypto.createCipheriv('aes-128-gcm', Buffer.alloc(16), Buffer.alloc(n));
}*/

{
  // Passing an invalid cipher name should throw.
  assert.throws(
    () => crypto.createCipheriv('aes-127', Buffer.alloc(16), null),
    {
      name: 'Error',
      code: 'ERR_CRYPTO_UNKNOWN_CIPHER',
      message: 'Unknown cipher'
    });

  // Passing a key with an invalid length should throw.
  /*assert.throws(
    () => crypto.createCipheriv('aes-128-ecb', Buffer.alloc(17), null),
    /Invalid key length/);*/
}

```"
"```javascript:test\fs\test-fs-opendir.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const testDir = tmpdir.path;
const files = ['empty', 'files', 'for', 'just', 'testing'];

const __filename = args[0];

// Make sure tmp directory is clean
tmpdir.refresh();

// Create the necessary files
files.forEach(function (filename) {
  fs.closeSync(fs.openSync(path.join(testDir, filename), 'w'));
});

function assertDirent(dirent) {
  assert(dirent instanceof fs.Dirent);
  assert.strictEqual(dirent.isFile(), true);
  assert.strictEqual(dirent.isDirectory(), false);
  assert.strictEqual(dirent.isSocket(), false);
  assert.strictEqual(dirent.isBlockDevice(), false);
  assert.strictEqual(dirent.isCharacterDevice(), false);
  assert.strictEqual(dirent.isFIFO(), false);
  assert.strictEqual(dirent.isSymbolicLink(), false);
}

const dirclosedError = {
  code: 'ERR_DIR_CLOSED'
};

const dirconcurrentError = {
  code: 'ERR_DIR_CONCURRENT_OPERATION'
};

const invalidCallbackObj = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
};

// Check the opendir Sync version
{
  const dir = fs.opendirSync(testDir);
  const entries = files.map(() => {
    const dirent = dir.readSync();
    assertDirent(dirent);
    return dirent.name;
  });
  assert.deepStrictEqual(files, entries.sort());

  // dir.read should return null when no more entries exist
  assert.strictEqual(dir.readSync(), null);

  // check .path
  assert.strictEqual(dir.path, testDir);

  dir.closeSync();

  assert.throws(() => dir.readSync(), dirclosedError);
  assert.throws(() => dir.closeSync(), dirclosedError);
}

// Check the opendir async version
fs.opendir(testDir, common.mustSucceed((dir) => {
  let sync = true;
  dir.read(common.mustSucceed((dirent) => {
    assert(!sync);

    // Order is operating / file system dependent
    assert(files.includes(dirent.name), `'files' should include ${dirent}`);
    assertDirent(dirent);

    let syncInner = true;
    dir.read(common.mustSucceed((dirent) => {
      assert(!syncInner);

      dir.close(common.mustSucceed());
    }));
    syncInner = false;
  }));
  sync = false;
}));

// opendir() on file should throw ENOTDIR
assert.throws(function () {
  fs.opendirSync(__filename);
}, /Error: ENOTDIR: not a directory/);

assert.throws(function () {
  fs.opendir(__filename);
}, /TypeError( \[ERR_INVALID_ARG_TYPE\])?: The ""callback"" argument must be of type function/);

fs.opendir(__filename, common.mustCall(function (e) {
  assert.strictEqual(e.code, 'ENOTDIR');
}));

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.opendir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.opendirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Promise-based tests
async function doPromiseTest() {
  // Check the opendir Promise version
  const dir = await fs.promises.opendir(testDir);
  const entries = [];

  let i = files.length;
  while (i--) {
    const dirent = await dir.read();
    entries.push(dirent.name);
    assertDirent(dirent);
  }

  assert.deepStrictEqual(files, entries.sort());

  // dir.read should return null when no more entries exist
  assert.strictEqual(await dir.read(), null);

  await dir.close();
}
doPromiseTest().then(common.mustCall());

// Async iterator
async function doAsyncIterTest() {
  const entries = [];
  for await (const dirent of await fs.promises.opendir(testDir)) {
    entries.push(dirent.name);
    assertDirent(dirent);
  }

  assert.deepStrictEqual(files, entries.sort());

  // Automatically closed during iterator
}
doAsyncIterTest().then(common.mustCall());

// Async iterators should do automatic cleanup

async function doAsyncIterBreakTest() {
  const dir = await fs.promises.opendir(testDir);
  for await (const dirent of dir) { // eslint-disable-line no-unused-vars
    break;
  }
  
  await assert.rejects(async () => dir.read(), dirclosedError);
}
doAsyncIterBreakTest().then(common.mustCall());

async function doAsyncIterReturnTest() {
  const dir = await fs.promises.opendir(testDir);
  await (async function () {
    for await (const dirent of dir) {
      return;
    }
  })();

  await assert.rejects(async () => dir.read(), dirclosedError);
}
doAsyncIterReturnTest().then(common.mustCall());

async function doAsyncIterThrowTest() {
  const dir = await fs.promises.opendir(testDir);
  try {
    for await (const dirent of dir) { // eslint-disable-line no-unused-vars
      throw new Error('oh no');
    }
  } catch (err) {
    if (err.message !== 'oh no') {
      throw err;
    }
  }

  await assert.rejects(async () => dir.read(), dirclosedError);
}
doAsyncIterThrowTest().then(common.mustCall());

// Check error thrown on invalid values of bufferSize
for (const bufferSize of [-1, 0, 0.5, 1.5, Infinity, NaN]) {
  assert.throws(
    () => fs.opendirSync(testDir, common.mustNotMutateObjectDeep({ bufferSize })),
    {
      code: 'ERR_OUT_OF_RANGE'
    });
}
for (const bufferSize of ['', '1', null]) {
  assert.throws(
    () => fs.opendirSync(testDir, common.mustNotMutateObjectDeep({ bufferSize })),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    });
}

// Check that passing a positive integer as bufferSize works
{
  const dir = fs.opendirSync(testDir, common.mustNotMutateObjectDeep({ bufferSize: 1024 }));
  assertDirent(dir.readSync());
  dir.close();
}

// Check that when passing a string instead of function - throw an exception
async function doAsyncIterInvalidCallbackTest() {
  const dir = await fs.promises.opendir(testDir);
  assert.throws(() => dir.close('not function'), invalidCallbackObj);
}
doAsyncIterInvalidCallbackTest().then(common.mustCall());

// Check first call to close() - should not report an error.
async function doAsyncIterDirClosedTest() {
  const dir = await fs.promises.opendir(testDir);
  await dir.close();
  await assert.rejects(() => dir.close(), dirclosedError);
}
doAsyncIterDirClosedTest().then(common.mustCall());

// Check that readSync() and closeSync() during read() throw exceptions
async function doConcurrentAsyncAndSyncOps() {
  const dir = await fs.promises.opendir(testDir);
  const promise = dir.read();

  assert.throws(() => dir.closeSync(), dirconcurrentError);
  assert.throws(() => dir.readSync(), dirconcurrentError);

  await promise;
  dir.closeSync();
}
doConcurrentAsyncAndSyncOps().then(common.mustCall());

// Check read throw exceptions on invalid callback
{
  const dir = fs.opendirSync(testDir);
  assert.throws(() => dir.read('INVALID_CALLBACK'), { code: /ERR_INVALID_ARG_TYPE/ });
}

// Check that concurrent read() operations don't do weird things.
async function doConcurrentAsyncOps() {
  const dir = await fs.promises.opendir(testDir);
  const promise1 = dir.read();
  const promise2 = dir.read();

  assertDirent(await promise1);
  assertDirent(await promise2);
  dir.closeSync();
}
doConcurrentAsyncOps().then(common.mustCall());

// Check that concurrent read() + close() operations don't do weird things.
async function doConcurrentAsyncMixedOps() {
  const dir = await fs.promises.opendir(testDir);
  const promise1 = dir.read();
  const promise2 = dir.close();

  assertDirent(await promise1);
  await promise2;
}
doConcurrentAsyncMixedOps().then(common.mustCall());

// Check if directory already closed - the callback should pass an error.
{
  const dir = fs.opendirSync(testDir);
  dir.closeSync();
  dir.close(common.mustCall((error) => {
    assert.strictEqual(error.code, dirclosedError.code);
  }));
}

// Check if directory already closed - throw an promise exception.
{
  const dir = fs.opendirSync(testDir);
  dir.closeSync();
  assert.rejects(dir.close(), dirclosedError).then(common.mustCall());
}

```"
"```javascript:test\fs\test-fs-rmdir-recursive.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import { validateRmdirOptions } from 'internal/fs/utils';

common.expectWarning(
  'DeprecationWarning',
  'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
  'DEP0147'
);

tmpdir.refresh();

let count = 0;
const nextDirPath = (name = 'rmdir-recursive') =>
  path.join(tmpdir.path, `${name}-${count++}`);

function makeNonEmptyDirectory(depth, files, folders, dirname, createSymLinks) {
  fs.mkdirSync(dirname, { recursive: true });
  fs.writeFileSync(path.join(dirname, 'text.txt'), 'hello', 'utf8');

  const options = { flag: 'wx' };

  for (let f = files; f > 0; f--) {
    fs.writeFileSync(path.join(dirname, `f-${depth}-${f}`), '', options);
  }

  if (createSymLinks) {
    // Valid symlink
    fs.symlinkSync(
      `f-${depth}-1`,
      path.join(dirname, `link-${depth}-good`),
      'file'
    );

    // Invalid symlink
    fs.symlinkSync(
      'does-not-exist',
      path.join(dirname, `link-${depth}-bad`),
      'file'
    );
  }

  // File with a name that looks like a glob
  fs.writeFileSync(path.join(dirname, '[a-z0-9].txt'), '', options);

  depth--;
  if (depth <= 0) {
    return;
  }

  for (let f = folders; f > 0; f--) {
    fs.mkdirSync(
      path.join(dirname, `folder-${depth}-${f}`),
      { recursive: true }
    );
    makeNonEmptyDirectory(
      depth,
      files,
      folders,
      path.join(dirname, `d-${depth}-${f}`),
      createSymLinks
    );
  }
}

function removeAsync(dir) {
  // Removal should fail without the recursive option.
  fs.rmdir(dir, common.mustCall((err) => {
    assert.strictEqual(err.syscall, 'rmdir');

    // Removal should fail without the recursive option set to true.
    fs.rmdir(dir, { recursive: false }, common.mustCall((err) => {
      assert.strictEqual(err.syscall, 'rmdir');

      // Recursive removal should succeed.
      fs.rmdir(dir, { recursive: true }, common.mustSucceed(() => {
        // An error should occur if recursive and the directory does not exist.
        fs.rmdir(dir, { recursive: true }, common.mustCall((err) => {
          assert.strictEqual(err.code, 'ENOENT');
          // Attempted removal should fail now because the directory is gone.
          fs.rmdir(dir, common.mustCall((err) => {
            assert.strictEqual(err.syscall, 'rmdir');
          }));
        }));
      }));
    }));
  }));
}

// Test the asynchronous version
{
  // Create a 4-level folder hierarchy including symlinks
  let dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  removeAsync(dir);

  // Create a 2-level folder hierarchy without symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(dir);

  // Create a flat folder including symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(1, 10, 2, dir, true);
  removeAsync(dir);
}

// Test the synchronous version.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  assert.throws(() => {
    fs.rmdirSync(dir);
  }, { syscall: 'rmdir' });
  assert.throws(() => {
    fs.rmdirSync(dir, { recursive: false });
  }, { syscall: 'rmdir' });

  // Recursive removal should succeed.
  fs.rmdirSync(dir, { recursive: true });

  // An error should occur if recursive and the directory does not exist.
  assert.throws(() => fs.rmdirSync(dir, { recursive: true }),
                { code: 'ENOENT' });

  // Attempted removal should fail now because the directory is gone.
  assert.throws(() => fs.rmdirSync(dir), { syscall: 'rmdir' });
}

// Test the Promises based version.
(async () => {
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  await assert.rejects(fs.promises.rmdir(dir), { syscall: 'rmdir' });
  await assert.rejects(fs.promises.rmdir(dir, { recursive: false }), {
    syscall: 'rmdir'
  });

  // Recursive removal should succeed.
  await fs.promises.rmdir(dir, { recursive: true });

  // An error should occur if recursive and the directory does not exist.
  await assert.rejects(fs.promises.rmdir(dir, { recursive: true }),
                       { code: 'ENOENT' });

  // Attempted removal should fail now because the directory is gone.
  await assert.rejects(fs.promises.rmdir(dir), { syscall: 'rmdir' });
})().then(common.mustCall());

// Test input validation.
{
  const defaults = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false
  };
  const modified = {
    retryDelay: 953,
    maxRetries: 5,
    recursive: true
  };

  assert.deepStrictEqual(validateRmdirOptions(), defaults);
  assert.deepStrictEqual(validateRmdirOptions({}), defaults);
  assert.deepStrictEqual(validateRmdirOptions(modified), modified);
  assert.deepStrictEqual(validateRmdirOptions({
    maxRetries: 99
  }), {
    retryDelay: 100,
    maxRetries: 99,
    recursive: false
  });

  [null, 'foo', 5, NaN].forEach((bad) => {
    assert.throws(() => {
      validateRmdirOptions(bad);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options"" argument must be of type object\./
    });
  });

  [undefined, null, 'foo', Infinity, function() {}].forEach((bad) => {
    assert.throws(() => {
      validateRmdirOptions({ recursive: bad });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options\.recursive"" property must be of type boolean\./
    });
  });

  assert.throws(() => {
    validateRmdirOptions({ retryDelay: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.retryDelay"" is out of range\./
  });

  assert.throws(() => {
    validateRmdirOptions({ maxRetries: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.maxRetries"" is out of range\./
  });
}

// It should not pass recursive option to rmdirSync, when called from
// rimraf (see: #35566)
/*{
  // Make a non-empty directory:
  const original = fs.rmdirSync;
  const dir = `${nextDirPath()}/foo/bar`;
  fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(`${dir}/foo.txt`, 'hello world', 'utf8');

  // When called the second time from rimraf, the recursive option should
  // not be set for rmdirSync:
  let callCount = 0;
  let rmdirSyncOptionsFromRimraf;
  fs.rmdirSync = (path, options) => {
    if (callCount > 0) {
      rmdirSyncOptionsFromRimraf = { ...options };
    }
    callCount++;
    return original(path, options);
  };
  fs.rmdirSync(dir, { recursive: true });
  fs.rmdirSync = original;
  assert.strictEqual(rmdirSyncOptionsFromRimraf.recursive, undefined);
}*/

```"
"```javascript:modules\internal\streams\end-of-stream.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { AbortError, ERR_STREAM_PREMATURE_CLOSE } from ""../errors.js"";
import { once } from ""../util.js"";
import {
    validateAbortSignal,
    validateFunction,
    validateObject,
} from ""../validators.js"";

function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === ""function"";
}

function isServerResponse(stream) {
    return (
        typeof stream._sent100 === ""boolean"" &&
        typeof stream._removedConnection === ""boolean"" &&
        typeof stream._removedContLen === ""boolean"" &&
        typeof stream._removedTE === ""boolean"" &&
        typeof stream._closed === ""boolean""
    );
}


function isReadable(stream) {
    return typeof stream.readable === ""boolean"" ||
        typeof stream.readableEnded === ""boolean"" ||
        !!stream._readableState;
}

function isWritable(stream) {
    return typeof stream.writable === ""boolean"" ||
        typeof stream.writableEnded === ""boolean"" ||
        !!stream._writableState;
}

function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || (wState.ended && wState.length === 0);
}

const nop = () => { };

function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || (rState.ended && rState.length === 0);
}


export function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, ""options"");
    }
    validateFunction(callback, ""callback"");
    validateAbortSignal(options.signal, ""options.signal"");

    callback = once(callback);

    const readable = options.readable ||
        (options.readable !== false && isReadable(stream));
    const writable = options.writable ||
        (options.writable !== false && isWritable(stream));

    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;

    const onlegacyfinish = () => {
        if (!stream.writable) onfinish();
    };

    // TODO (ronag): Improve soft detection to include core modules and
    // common ecosystem modules that do properly emit 'close' but fail
    // this generic check.
    let willEmitClose = isServerResponse(stream) || (
        state &&
        state.autoDestroy &&
        state.emitClose &&
        state.closed === false &&
        isReadable(stream) === readable &&
        isWritable(stream) === writable
    );

    let writableFinished = stream.writableFinished ||
        (wState && wState.finished);
    const onfinish = () => {
        writableFinished = true;
        // Stream should not be destroyed here. If it is that
        // means that user space is doing something differently and
        // we cannot trust willEmitClose.
        if (stream.destroyed) willEmitClose = false;

        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };

    let readableEnded = stream.readableEnded ||
        (rState && rState.endEmitted);
    const onend = () => {
        readableEnded = true;
        // Stream should not be destroyed here. If it is that
        // means that user space is doing something differently and
        // we cannot trust willEmitClose.
        if (stream.destroyed) willEmitClose = false;

        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };

    const onerror = (err) => {
        callback.call(stream, err);
    };

    const onclose = () => {
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };

    const onrequest = () => {
        stream.req.on(""finish"", onfinish);
    };

    if (isRequest(stream)) {
        stream.on(""complete"", onfinish);
        if (!willEmitClose) {
            stream.on(""abort"", onclose);
        }
        if (stream.req) onrequest();
        else stream.on(""request"", onrequest);
    } else if (writable && !wState) { // legacy streams
        stream.on(""end"", onlegacyfinish);
        stream.on(""close"", onlegacyfinish);
    }

    // Not all streams will emit 'close' after 'aborted'.
    if (!willEmitClose && typeof stream.aborted === ""boolean"") {
        stream.on(""aborted"", onclose);
    }

    stream.on(""end"", onend);
    stream.on(""finish"", onfinish);
    if (options.error !== false) stream.on(""error"", onerror);
    stream.on(""close"", onclose);

    // _closed is for OutgoingMessage which is not a proper Writable.
    const closed = (!wState && !rState && stream._closed === true) || (
        (wState && wState.closed) ||
        (rState && rState.closed) ||
        (wState && wState.errorEmitted) ||
        (rState && rState.errorEmitted) ||
        (rState && stream.req && stream.aborted) ||
        (
            (!wState || !willEmitClose || typeof wState.closed !== ""boolean"") &&
            (!rState || !willEmitClose || typeof rState.closed !== ""boolean"") &&
            (!writable || (wState && wState.finished)) &&
            (!readable || (rState && rState.endEmitted))
        )
    );

    if (closed) {
        // TODO(ronag): Re-throw error if errorEmitted?
        // TODO(ronag): Throw premature close as if finished was called?
        // before being closed? i.e. if closed but not errored, ended or finished.
        // TODO(ronag): Throw some kind of error? Does it make sense
        // to call finished() on a ""finished"" stream?
        // TODO(ronag): willEmitClose?
        nextTick(() => {
            callback();
        });
    }

    const cleanup = () => {
        callback = nop;
        stream.removeListener(""aborted"", onclose);
        stream.removeListener(""complete"", onfinish);
        stream.removeListener(""abort"", onclose);
        stream.removeListener(""request"", onrequest);
        if (stream.req) stream.req.removeListener(""finish"", onfinish);
        stream.removeListener(""end"", onlegacyfinish);
        stream.removeListener(""close"", onlegacyfinish);
        stream.removeListener(""finish"", onfinish);
        stream.removeListener(""end"", onend);
        stream.removeListener(""error"", onerror);
        stream.removeListener(""close"", onclose);
    };

    if (options.signal && !closed) {
        const abort = () => {
            // Keep it because cleanup removes it.
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args) => {
                options.signal.removeEventListener(""abort"", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener(""abort"", abort);
        }
    }

    return cleanup;
}

export default eos;

```"
"```javascript:test\fs\test-fs-utimes.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import { inspect } from '../../modules/internal/util/inspect';
import fs from 'fs';
import url from 'url';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const lpath = `${tmpdir.path}/symlink`;
fs.symlinkSync('unoent-entry', lpath);

function stat_resource(resource, statSync = fs.statSync) {
  if (typeof resource === 'string') {
    return statSync(resource);
  }
  const stats = fs.fstatSync(resource);
  // Ensure mtime has been written to disk
  // except for directories on AIX where it cannot be synced
  if (common.isAIX && stats.isDirectory())
    return stats;
  fs.fsyncSync(resource);
  return fs.fstatSync(resource);
}

function check_mtime(resource, mtime, statSync) {
  mtime = mtime.getTime();
  const stats = stat_resource(resource, statSync);
  const real_mtime = stats.mtime.getTime();
  return mtime - real_mtime;
}

function expect_errno(syscall, resource, err, errno) {
  assert(
    err && (err.code === errno || err.code === 'ENOSYS'),
    `FAILED: expect_errno ${inspect(arguments)}`
  );
}

function expect_ok(syscall, resource, err, atime, mtime, statSync) {
  const mtime_diff = check_mtime(resource, mtime, statSync);
  assert(
    // Check up to single-second precision.
    // Sub-second precision is OS and fs dependant.
    !err && (mtime_diff < 2) || err && err.code === 'ENOSYS',
    `FAILED: expect_ok ${inspect(arguments)}
     check_mtime: ${mtime_diff}`
  );
}

const stats = fs.statSync(tmpdir.path);

const asPath = (path) => path;
const asUrl = (path) => url.pathToFileURL(path);

const cases = [
  //[asPath, new Date('1982-09-10 13:37')],
  [asPath, new Date()],
  [asPath, 123456.789],
  [asPath, stats.mtime],
  [asPath, '123456'], // [asPath, '123456', -1], nodejs api doc didn't indicate how to deal with -1
  [asPath, new Date('2017-04-08T17:59:38.008Z')],
  [asUrl, new Date()],
];

runTests(cases.values());

function runTests(iter) {
  const { value, done } = iter.next();
  if (done) return;

  // Support easy setting same or different atime / mtime values.
  const [pathType, atime, mtime = atime] = value;

  let fd;
  //
  // test async code paths
  //
  fs.utimes(pathType(tmpdir.path), atime, mtime, common.mustCall((err) => {
    expect_ok('utimes', tmpdir.path, err, atime, mtime);

    fs.lutimes(pathType(lpath), atime, mtime, common.mustCall((err) => {
      expect_ok('lutimes', lpath, err, atime, mtime, fs.lstatSync);

      fs.utimes(pathType('foobarbaz'), atime, mtime, common.mustCall((err) => {
        expect_errno('utimes', 'foobarbaz', err, 'ENOENT');

        // don't close this fd
        if (common.isWindows) {
          fd = fs.openSync(tmpdir.path, 'r+');
        } else {
          fd = fs.openSync(tmpdir.path, 'r');
        }

        fs.futimes(fd, atime, mtime, common.mustCall((err) => {
          expect_ok('futimes', fd, err, atime, mtime);

          syncTests();

          setImmediate(common.mustCall(runTests), iter);
        }));
      }));
    }));
  }));

  //
  // test synchronized code paths, these functions throw on failure
  //
  function syncTests() {
    fs.utimesSync(pathType(tmpdir.path), atime, mtime);
    expect_ok('utimesSync', tmpdir.path, undefined, atime, mtime);

    fs.lutimesSync(pathType(lpath), atime, mtime);
    expect_ok('lutimesSync', lpath, undefined, atime, mtime, fs.lstatSync);

    // Some systems don't have futimes
    // if there's an error, it should be ENOSYS
    try {
      fs.futimesSync(fd, atime, mtime);
      expect_ok('futimesSync', fd, undefined, atime, mtime);
    } catch (ex) {
      expect_errno('futimesSync', fd, ex, 'ENOSYS');
    }

    let err;
    try {
      fs.utimesSync(pathType('foobarbaz'), atime, mtime);
    } catch (ex) {
      err = ex;
    }
    expect_errno('utimesSync', 'foobarbaz', err, 'ENOENT');

    err = undefined;
  }
}

const expectTypeError = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
};
// utimes-only error cases
{
  assert.throws(
    () => fs.utimes(0, new Date(), new Date(), common.mustNotCall()),
    expectTypeError
  );
  assert.throws(
    () => fs.utimesSync(0, new Date(), new Date()),
    expectTypeError
  );
}

// shared error cases
[false, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.utimes(i, new Date(), new Date(), common.mustNotCall()),
    expectTypeError
  );
  assert.throws(
    () => fs.utimesSync(i, new Date(), new Date()),
    expectTypeError
  );
  assert.throws(
    () => fs.futimes(i, new Date(), new Date(), common.mustNotCall()),
    expectTypeError
  );
  assert.throws(
    () => fs.futimesSync(i, new Date(), new Date()),
    expectTypeError
  );
});

const expectRangeError = {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""fd"" is out of range. ' +
           'It must be an integer >= 0 && <= 2147483647. Received -1'
};
// futimes-only error cases
{
  assert.throws(
    () => fs.futimes(-1, new Date(), new Date(), common.mustNotCall()),
    expectRangeError
  );
  assert.throws(
    () => fs.futimesSync(-1, new Date(), new Date()),
    expectRangeError
  );
}

```"
"```javascript:modules\internal\util\types.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
//
// Adapted from Node.js. Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const _toString = Object.prototype.toString;

const _isObjectLike = (value) =>
    value !== null && typeof value === ""object"";

const _isFunctionLike = (value) =>
    value !== null && typeof value === ""function"";

export function isAnyArrayBuffer(value) {
    return (
        _isObjectLike(value) &&
        (_toString.call(value) === ""[object ArrayBuffer]"" ||
            _toString.call(value) === ""[object SharedArrayBuffer]"")
    );
}

export function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Arguments]"";
}

export function isArrayBuffer(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object ArrayBuffer]""
    );
}

export function isAsyncFunction(value) {
    return (
        _isFunctionLike(value) && _toString.call(value) === ""[object AsyncFunction]""
    );
}

export function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Boolean]"";
}

export function isBoxedPrimitive(value) {
    return (
        isBooleanObject(value) ||
        isStringObject(value) ||
        isNumberObject(value) ||
        isSymbolObject(value) ||
        isBigIntObject(value)
    );
}

export function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object DataView]"";
}

export function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Date]"";
}

export function isGeneratorFunction(value) {
    return (
        _isFunctionLike(value) &&
        _toString.call(value) === ""[object GeneratorFunction]""
    );
}

export function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Generator]"";
}

export function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Map]"";
}

export function isMapIterator(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Map Iterator]""
    );
}

export function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Module]"";
}

export function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Error]"";
}

export function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Number]"";
}

export function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object BigInt]"";
}

export function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Promise]"";
}

export function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object RegExp]"";
}

export function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Set]"";
}

export function isSetIterator(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Set Iterator]""
    );
}

export function isSharedArrayBuffer(value) {
    return (
        _isObjectLike(value) &&
        _toString.call(value) === ""[object SharedArrayBuffer]""
    );
}

export function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object String]"";
}

export function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Symbol]"";
}

export function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object WeakMap]"";
}

export function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object WeakSet]"";
}

export function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}

export function isBigInt64Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object BigInt64Array]""
    );
}

export function isBigUint64Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object BigUint64Array]""
    );
}

export function isFloat32Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Float32Array]""
    );
}

export function isFloat64Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Float64Array]""
    );
}

export function isInt8Array(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Int8Array]"";
}

export function isInt16Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Int16Array]""
    );
}

export function isInt32Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Int32Array]""
    );
}

// Adapted from Lodash
export function isTypedArray(value) {
    /** Used to match `toStringTag` values of typed arrays. */
    const reTypedTag =
        /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike(value) && reTypedTag.test(_toString.call(value));
}

export function isUint8Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Uint8Array]""
    );
}

export function isUint8ClampedArray(value) {
    return (
        _isObjectLike(value) &&
        _toString.call(value) === ""[object Uint8ClampedArray]""
    );
}

export function isUint16Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Uint16Array]""
    );
}

export function isUint32Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Uint32Array]""
    );
}
```"
"```javascript:modules\process.js
function unimplemented(name) {
  throw new Error('Node.js process ' + name + ' is not supported');
}

var title = 'wasmedge_quickjs';
var arch = 'wasm';
var platform = 'wasi';
var env = globalThis.env;
var argv = globalThis.argv || globalThis.args;
var execArgv = [];
var version = 'v16.8.0';
var versions = {};

var emitWarning = function (message, type) {
  console.warn((type ? (type + ': ') : '') + message);
};

var binding = function (name) { unimplemented('binding'); };

var umask = function (mask) { return 0; };

var cwd = function () { return './'; };
var chdir = function (dir) { unimplemented('chdir'); };

var release = {
  name: 'wasmedge_quickjs',
  sourceUrl: '',
  headersUrl: '',
  libUrl: '',
};

function noop() { }

var _rawDebug = noop;
var moduleLoadList = [];
function _linkedBinding(name) { unimplemented('_linkedBinding'); }
var domain = {};
var _exiting = false;
var config = {};
function dlopen(name) { unimplemented('dlopen'); }
function _getActiveRequests() { return []; }
function _getActiveHandles() { return []; }
var reallyExit = noop;
var _kill = noop;
var cpuUsage = function () { return {}; };
var resourceUsage = cpuUsage;
var memoryUsage = cpuUsage;
var kill = noop;
var exit = globalThis.exit;
var openStdin = noop;
var allowedNodeEnvironmentFlags = {};
function assert(condition, message) {
  if (!condition) { throw new Error(message || 'assertion error'); }
}
var features = {
  inspector: false,
  debug: false,
  uv: false,
  ipv6: false,
  tls_alpn: false,
  tls_sni: false,
  tls_ocsp: false,
  tls: false,
  cached_builtins: true,
};
var _fatalExceptions = noop;
var setUncaughtExceptionCaptureCallback = noop;
function hasUncaughtExceptionCaptureCallback() { return false; } var _tickCallback = noop;
var _debugProcess = noop;
var _debugEnd = noop;
var _startProfilerIdleNotifier = noop;
var _stopProfilerIdleNotifier = noop;
var stdout = undefined;
var stderr = undefined;
var stdin = undefined;
var abort = noop;
var pid = 2;
var ppid = 1;
var execPath = 'wasmedge-quickjs';
var debugPort = 9229;
var argv0 = 'wasmedge-quickjs';
var _preload_modules = [];
var setSourceMapsEnabled = noop;

var _performance = {
  now: undefined,
  timing: undefined,
};
if (_performance.now === undefined) {
  var nowOffset = Date.now();

  if (_performance.timing && _performance.timing.navigationStart) {
    nowOffset = _performance.timing.navigationStart;
  }
  _performance.now = function () { return Date.now() - nowOffset; };
}

function uptime() {
  return _performance.now() / 1000;
}

var nanoPerSec = 1000000000;
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor((clocktime % 1) * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}

hrtime.bigint = function (time) {
  var diff = hrtime(time);
  if (typeof BigInt === 'undefined') {
    return diff[0] * nanoPerSec + diff[1];
  }
  return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
};

var _maxListeners = 10;
var _events = {};
var _eventsCount = 0;
function on() { return process } var addListener = on;
var once = on;
var off = on;
var removeListener = on;
var removeAllListeners = on;
var emit = noop;
var prependListener = on;
var prependOnceListener = on;
function listeners(name) { return []; }
var process = {
  version: version,
  versions: versions,
  arch: arch,
  platform: platform,
  release: release,
  _rawDebug: _rawDebug,
  moduleLoadList: moduleLoadList,
  binding: binding,
  _linkedBinding: _linkedBinding,
  _events: _events,
  _eventsCount: _eventsCount,
  _maxListeners: _maxListeners,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  prependListener: prependListener,
  prependOnceListener: prependOnceListener,
  listeners: listeners,
  domain: domain,
  _exiting: _exiting,
  config: config,
  dlopen: dlopen,
  uptime: uptime,
  _getActiveRequests: _getActiveRequests,
  _getActiveHandles: _getActiveHandles,
  reallyExit: reallyExit,
  _kill: _kill,
  cpuUsage: cpuUsage,
  resourceUsage: resourceUsage,
  memoryUsage: memoryUsage,
  kill: kill,
  exit: exit,
  openStdin: openStdin,
  allowedNodeEnvironmentFlags: allowedNodeEnvironmentFlags,
  assert: assert,
  features: features,
  _fatalExceptions: _fatalExceptions,
  setUncaughtExceptionCaptureCallback: setUncaughtExceptionCaptureCallback,
  hasUncaughtExceptionCaptureCallback: hasUncaughtExceptionCaptureCallback,
  emitWarning: emitWarning,
  nextTick: globalThis.nextTick,
  _tickCallback: _tickCallback,
  _debugProcess: _debugProcess,
  _debugEnd: _debugEnd,
  _startProfilerIdleNotifier: _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier: _stopProfilerIdleNotifier,
  stdout: stdout,
  stdin: stdin,
  stderr: stderr,
  abort: abort,
  umask: umask,
  chdir: chdir,
  cwd: cwd,
  env: env,
  title: title,
  argv: argv,
  execArgv: execArgv,
  pid: pid,
  ppid: ppid,
  execPath: execPath,
  debugPort: debugPort,
  hrtime: hrtime,
  argv0: argv0,
  _preload_modules: _preload_modules,
  setSourceMapsEnabled: setSourceMapsEnabled,
};

const nextTick = globalThis.nextTick;

export { _debugEnd, _debugProcess, _events, _eventsCount, _exiting, _fatalExceptions, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _maxListeners, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, assert, binding, chdir, config, cpuUsage, cwd, debugPort, process as default, dlopen, domain, emit, emitWarning, env, execArgv, execPath, exit, features, hasUncaughtExceptionCaptureCallback, hrtime, kill, listeners, memoryUsage, moduleLoadList, nextTick, off, on, once, openStdin, pid, platform, ppid, prependListener, prependOnceListener, reallyExit, release, removeAllListeners, removeListener, resourceUsage, setSourceMapsEnabled, setUncaughtExceptionCaptureCallback, stderr, stdin, stdout, title, umask, uptime, version, versions };

```"
"```javascript:test\crypto\test-crypto-hash.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from'../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert  from 'assert';
import crypto from 'crypto';
import fs from 'fs';

import fixtures from '../common/fixtures';

let cryptoType;
let digest;

// Test hashing
//const a1 = crypto.createHash('sha1').update('Test123').digest('hex');
const a2 = crypto.createHash('sha256').update('Test123').digest('base64');
const a3 = crypto.createHash('sha512').update('Test123').digest(); // buffer
//const a4 = crypto.createHash('sha1').update('Test123').digest('buffer');

// stream interface
let a5 = crypto.createHash('sha512');
a5.end('Test123');
a5 = a5.read();

let a6 = crypto.createHash('sha512');
a6.write('Te');
a6.write('st');
a6.write('123');
a6.end();
a6 = a6.read();

let a7 = crypto.createHash('sha512');
a7.end();
a7 = a7.read();

let a8 = crypto.createHash('sha512');
a8.write('');
a8.end();
a8 = a8.read();
/*
if (!common.hasFipsCrypto) {
  cryptoType = 'md5';
  digest = 'latin1';
  const a0 = crypto.createHash(cryptoType).update('Test123').digest(digest);
  assert.strictEqual(
    a0,
    'h\u00ea\u00cb\u0097\u00d8o\fF!\u00fa+\u000e\u0017\u00ca\u00bd\u008c',
    `${cryptoType} with ${digest} digest failed to evaluate to expected hash`
  );
}
cryptoType = 'md5';
digest = 'hex';
assert.strictEqual(
  a1,
  '8308651804facb7b9af8ffc53a33a22d6a1c8ac2',
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`);*/
cryptoType = 'sha256';
digest = 'base64';
assert.strictEqual(
  a2,
  '2bX1jws4GYKTlxhloUB09Z66PoJZW+y+hq5R8dnx9l4=',
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`);
cryptoType = 'sha512';
digest = 'latin1';
assert.deepStrictEqual(
  a3,
  Buffer.from(
    '\u00c1(4\u00f1\u0003\u001fd\u0097!O\'\u00d4C/&Qz\u00d4' +
    '\u0094\u0015l\u00b8\u008dQ+\u00db\u001d\u00c4\u00b5}\u00b2' +
    '\u00d6\u0092\u00a3\u00df\u00a2i\u00a1\u009b\n\n*\u000f' +
    '\u00d7\u00d6\u00a2\u00a8\u0085\u00e3<\u0083\u009c\u0093' +
    '\u00c2\u0006\u00da0\u00a1\u00879(G\u00ed\'',
    'latin1'),
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`);
/*cryptoType = 'sha1';
digest = 'hex';
assert.deepStrictEqual(
  a4,
  Buffer.from('8308651804facb7b9af8ffc53a33a22d6a1c8ac2', 'hex'),
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`
);*/

// Stream interface should produce the same result.
assert.deepStrictEqual(a5, a3);
assert.deepStrictEqual(a6, a3);
assert.notStrictEqual(a7, undefined);
assert.notStrictEqual(a8, undefined);

// Test multiple updates to same hash
/*const h1 = crypto.createHash('sha1').update('Test123').digest('hex');
const h2 = crypto.createHash('sha1').update('Test').update('123').digest('hex');
assert.strictEqual(h1, h2);*/

// Test hashing for binary files
/*const fn = fixtures.path('sample.png');
const sha1Hash = crypto.createHash('sha1');
const fileStream = fs.createReadStream(fn);
fileStream.on('data', function(data) {
  sha1Hash.update(data);
});
fileStream.on('close', common.mustCall(function() {
  // Test SHA1 of sample.png
  assert.strictEqual(sha1Hash.digest('hex'),
                     '22723e553129a336ad96e10f6aecdf0f45e4149e');
}));*/

// Issue https://github.com/nodejs/node-v0.x-archive/issues/2227: unknown digest
// method should throw an error.
assert.throws(function() {
  crypto.createHash('xyzzy');
}, /Digest method not supported/);

// Issue https://github.com/nodejs/node/issues/9819: throwing encoding used to
// segfault.
assert.throws(
  () => crypto.createHash('sha256').digest({
    toString: () => { throw new Error('boom'); },
  }),
  {
    name: 'Error',
    message: 'boom'
  });

// Issue https://github.com/nodejs/node/issues/25487: error message for invalid
// arg type to update method should include all possible types
assert.throws(
  () => crypto.createHash('sha256').update(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });

// Default UTF-8 encoding
const hutf8 = crypto.createHash('sha512').update('������-8 text').digest('hex');
assert.strictEqual(
  hutf8,
  '4b21bbd1a68e690a730ddcb5a8bc94ead9879ffe82580767ad7ec6fa8ba2dea6' +
        '43a821af66afa9a45b6a78c712fecf0e56dc7f43aef4bcfc8eb5b4d8dca6ea5b');

assert.notStrictEqual(
  hutf8,
  crypto.createHash('sha512').update('������-8 text', 'latin1').digest('hex'));

const h3 = crypto.createHash('sha256');
h3.digest();

assert.throws(
  () => h3.digest(),
  {
    code: 'ERR_CRYPTO_HASH_FINALIZED',
    name: 'Error'
  });

assert.throws(
  () => h3.update('foo'),
  {
    code: 'ERR_CRYPTO_HASH_FINALIZED',
    name: 'Error'
  });

assert.strictEqual(
  crypto.createHash('sha256').update('test').digest('ucs2'),
  crypto.createHash('sha256').update('test').digest().toString('ucs2'));

assert.throws(
  () => crypto.createHash(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""algorithm"" argument must be of type string. ' +
             'Received undefined'
  }
);

{
  const Hash = crypto.Hash;
  const instance = crypto.Hash('sha256');
  assert(instance instanceof Hash, 'Hash is expected to return a new instance' +
                                   ' when called without `new`');
}

// Test XOF hash functions and the outputLength option.
{
  // Default outputLengths.
  /*assert.strictEqual(crypto.createHash('shake128').digest('hex'),
                     '7f9c2ba4e88f827d616045507605853e');
  assert.strictEqual(crypto.createHash('shake128', null).digest('hex'),
                     '7f9c2ba4e88f827d616045507605853e');
  assert.strictEqual(crypto.createHash('shake256').digest('hex'),
                     '46b9dd2b0ba88d13233b3feb743eeb24' +
                     '3fcd52ea62b81b82b50c27646ed5762f');
  assert.strictEqual(crypto.createHash('shake256', { outputLength: 0 })
                           .copy()  // Default outputLength.
                           .digest('hex'),
                     '46b9dd2b0ba88d13233b3feb743eeb24' +
                     '3fcd52ea62b81b82b50c27646ed5762f');

  // Short outputLengths.
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 0 })
                           .digest('hex'),
                     '');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 5 })
                           .copy({ outputLength: 0 })
                           .digest('hex'),
                     '');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 5 })
                           .digest('hex'),
                     '7f9c2ba4e8');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 0 })
                           .copy({ outputLength: 5 })
                           .digest('hex'),
                     '7f9c2ba4e8');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 15 })
                           .digest('hex'),
                     '7f9c2ba4e88f827d61604550760585');
  assert.strictEqual(crypto.createHash('shake256', { outputLength: 16 })
                           .digest('hex'),
                     '46b9dd2b0ba88d13233b3feb743eeb24');

  // Large outputLengths.
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 128 })
                           .digest('hex'),
                     '7f9c2ba4e88f827d616045507605853e' +
                     'd73b8093f6efbc88eb1a6eacfa66ef26' +
                     '3cb1eea988004b93103cfb0aeefd2a68' +
                     '6e01fa4a58e8a3639ca8a1e3f9ae57e2' +
                     '35b8cc873c23dc62b8d260169afa2f75' +
                     'ab916a58d974918835d25e6a435085b2' +
                     'badfd6dfaac359a5efbb7bcc4b59d538' +
                     'df9a04302e10c8bc1cbf1a0b3a5120ea');
  const superLongHash = crypto.createHash('shake256', {
    outputLength: 1024 * 1024
  }).update('The message is shorter than the hash!')
    .digest('hex');
  assert.strictEqual(superLongHash.length, 2 * 1024 * 1024);
  assert.ok(superLongHash.endsWith('193414035ddba77bf7bba97981e656ec'));
  assert.ok(superLongHash.startsWith('a2a28dbc49cfd6e5d6ceea3d03e77748'));

  // Non-XOF hash functions should accept valid outputLength options as well.
  assert.strictEqual(crypto.createHash('sha224', { outputLength: 28 })
                           .digest('hex'),
                     'd14a028c2a3a2bc9476102bb288234c4' +
                     '15a2b01f828ea62ac5b3e42f');
  
  // Passing invalid sizes should throw during creation.
  assert.throws(() => {
    crypto.createHash('sha256', { outputLength: 28 });
  }, {
    code: 'ERR_OSSL_EVP_NOT_XOF_OR_INVALID_LENGTH'
  });*/

  for (const outputLength of [null, {}, 'foo', false]) {
    assert.throws(() => crypto.createHash('sha256', { outputLength }),
                  { code: 'ERR_INVALID_ARG_TYPE' });
  }

  for (const outputLength of [-1, .5, Infinity, 2 ** 90]) {
    assert.throws(() => crypto.createHash('sha256', { outputLength }),
                  { code: 'ERR_OUT_OF_RANGE' });
  }
}

{
  const h = crypto.createHash('sha512');
  h.digest();
  assert.throws(() => h.copy(), { code: 'ERR_CRYPTO_HASH_FINALIZED' });
  assert.throws(() => h.digest(), { code: 'ERR_CRYPTO_HASH_FINALIZED' });
}

{
  const a = crypto.createHash('sha512').update('abc');
  const b = a.copy();
  const c = b.copy().update('def');
  const d = crypto.createHash('sha512').update('abcdef');
  assert.strictEqual(a.digest('hex'), b.digest('hex'));
  assert.strictEqual(c.digest('hex'), d.digest('hex'));
}

```"
"```javascript:test\fs\test-fs-write.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Flags: --expose_externalize_string
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const fn = path.join(tmpdir.path, 'write.txt');
const fn2 = path.join(tmpdir.path, 'write2.txt');
const fn3 = path.join(tmpdir.path, 'write3.txt');
const fn4 = path.join(tmpdir.path, 'write4.txt');
const fn5 = path.join(tmpdir.path, 'write5.txt');
const expected = '��mlaut.';
const constants = fs.constants;
/*
const { externalizeString, isOneByteString } = global;

// Account for extra globals exposed by --expose_externalize_string.
common.allowGlobals(externalizeString, isOneByteString, global.x);

{
  const expected = '��mlaut sechzig';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), true);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'latin1');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'latin1'), expected);
}

{
  const expected = '��mlaut neunzig';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), true);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'utf8');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'utf8'), expected);
}

{
  const expected = 'Zh��ngw��n 1';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), false);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'ucs2');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'ucs2'), expected);
}

{
  const expected = 'Zh��ngw��n 2';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), false);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'utf8');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'utf8'), expected);
}
*/
fs.open(fn, 'w', 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
    const found = fs.readFileSync(fn, 'utf8');
    fs.unlinkSync(fn);
    assert.strictEqual(found, expected);
  });

  const written = common.mustSucceed((written) => {
    assert.strictEqual(written, 0);
    fs.write(fd, expected, 0, 'utf8', done);
  });

  fs.write(fd, '', 0, 'utf8', written);
}));

const args = constants.O_CREAT | constants.O_WRONLY | constants.O_TRUNC;
fs.open(fn2, args, 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
    const found = fs.readFileSync(fn2, 'utf8');
    fs.unlinkSync(fn2);
    assert.strictEqual(found, expected);
  });

  const written = common.mustSucceed((written) => {
    assert.strictEqual(written, 0);
    fs.write(fd, expected, 0, 'utf8', done);
  });

  fs.write(fd, '', 0, 'utf8', written);
}));

fs.open(fn3, 'w', 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
  });

  fs.write(fd, expected, done);
}));

/* It's deprecated, so I don't decide to implement.
// Test write with an object with an own toString function
// Runtime deprecated by DEP0162
common.expectWarning('DeprecationWarning',
                     'Implicit coercion of objects with own toString property is deprecated.',
                     'DEP0162');
fs.open(fn4, 'w', 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
  });

  const data = {
    toString() { return expected; }
  };
  fs.write(fd, data, done);
}));
*/
[false, 'test', {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.write(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.writeSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

[
  false, 5, {}, [], null, undefined,
  new String('notPrimitive'),
  { [Symbol.toPrimitive]: (hint) => 'amObject' },
].forEach((data) => {
  assert.throws(
    () => fs.write(1, data, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""buffer""/
    }
  );
  assert.throws(
    () => fs.writeSync(1, data),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""buffer""/
    }
  );
});

{
  // Regression test for https://github.com/nodejs/node/issues/38168
  const fd = fs.openSync(fn5, 'w');

  assert.throws(
    () => fs.writeSync(fd, 'abc', 0, 'hex'),
    {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /'encoding' is invalid for data of length 3/
    }
  );

  assert.throws(
    () => fs.writeSync(fd, 'abc', 0, 'hex', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /'encoding' is invalid for data of length 3/
    }
  );

  assert.strictEqual(fs.writeSync(fd, 'abcd', 0, 'hex'), 2);

  fs.write(fd, 'abcd', 0, 'hex', common.mustSucceed((written) => {
    assert.strictEqual(written, 2);
    fs.closeSync(fd);
  }));
}

```"
"```javascript:test\crypto\test-crypto-hkdf.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import { kMaxLength } from 'buffer';
import assert from 'assert';
import {
  createSecretKey,
  hkdf,
  hkdfSync,
  getHashes
} from 'crypto';

{
  assert.throws(() => hkdf(), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""digest"" argument must be of type string/
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf(i, 'a'), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""digest"" argument must be of type string/
    });
    assert.throws(() => hkdfSync(i, 'a'), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""digest"" argument must be of type string/
    });
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf('sha256', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""ikm"" argument must be /
    });
    assert.throws(() => hkdfSync('sha256', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""ikm"" argument must be /
    });
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf('sha256', 'secret', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""salt"" argument must be /
    });
    assert.throws(() => hkdfSync('sha256', 'secret', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""salt"" argument must be /
    });
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf('sha256', 'secret', 'salt', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""info"" argument must be /
    });
    assert.throws(() => hkdfSync('sha256', 'secret', 'salt', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""info"" argument must be /
    });
  });

  ['test', {}, [], false].forEach((i) => {
    assert.throws(() => hkdf('sha256', 'secret', 'salt', 'info', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""length"" argument must be of type number/
    });
    assert.throws(() => hkdfSync('sha256', 'secret', 'salt', 'info', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""length"" argument must be of type number/
    });
  });

  assert.throws(() => hkdf('sha256', 'secret', 'salt', 'info', -1), {
    code: 'ERR_OUT_OF_RANGE'
  });
  assert.throws(() => hkdfSync('sha256', 'secret', 'salt', 'info', -1), {
    code: 'ERR_OUT_OF_RANGE'
  });
  assert.throws(() => hkdf('sha256', 'secret', 'salt', 'info',
                           kMaxLength + 1), {
    code: 'ERR_OUT_OF_RANGE'
  });
  assert.throws(() => hkdfSync('sha256', 'secret', 'salt', 'info',
                               kMaxLength + 1), {
    code: 'ERR_OUT_OF_RANGE'
  });

  assert.throws(() => hkdfSync('unknown', 'a', '', '', 10), {
    code: 'ERR_CRYPTO_INVALID_DIGEST'
  });

  assert.throws(() => hkdf('unknown', 'a', '', '', 10, common.mustNotCall()), {
    code: 'ERR_CRYPTO_INVALID_DIGEST'
  });

  assert.throws(() => hkdf('unknown', 'a', '', Buffer.alloc(1025), 10,
                           common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE'
  });

  assert.throws(() => hkdfSync('unknown', 'a', '', Buffer.alloc(1025), 10), {
    code: 'ERR_OUT_OF_RANGE'
  });

  assert.throws(
    () => hkdf('sha512', 'a', '', '', 64 * 255 + 1, common.mustNotCall()), {
      code: 'ERR_CRYPTO_INVALID_KEYLEN'
    });

  assert.throws(
    () => hkdfSync('sha512', 'a', '', '', 64 * 255 + 1), {
      code: 'ERR_CRYPTO_INVALID_KEYLEN'
    });
}

const algorithms = [
  ['sha256', 'secret', 'salt', 'info', 10],
  ['sha256', '', '', '', 10],
  ['sha256', '', 'salt', '', 10],
  ['sha512', 'secret', 'salt', '', 15],
];
if (!common.hasOpenSSL3)
  algorithms.push(['whirlpool', 'secret', '', 'info', 20]);

algorithms.forEach(([ hash, secret, salt, info, length ]) => {
  {
    const syncResult = hkdfSync(hash, secret, salt, info, length);
    assert(syncResult instanceof ArrayBuffer);
    let is_async = false;
    hkdf(hash, secret, salt, info, length,
         common.mustSucceed((asyncResult) => {
           assert(is_async);
           assert(asyncResult instanceof ArrayBuffer);
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
    // Keep this after the hkdf call above. This verifies
    // that the callback is invoked asynchronously.
    is_async = true;
  }

  {
    const buf_secret = Buffer.from(secret);
    const buf_salt = Buffer.from(salt);
    const buf_info = Buffer.from(info);

    const syncResult = hkdfSync(hash, buf_secret, buf_salt, buf_info, length);
    hkdf(hash, buf_secret, buf_salt, buf_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const key_secret = createSecretKey(Buffer.from(secret));
    const buf_salt = Buffer.from(salt);
    const buf_info = Buffer.from(info);

    const syncResult = hkdfSync(hash, key_secret, buf_salt, buf_info, length);
    hkdf(hash, key_secret, buf_salt, buf_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const ta_secret = new Uint8Array(Buffer.from(secret));
    const ta_salt = new Uint16Array(Buffer.from(salt));
    const ta_info = new Uint32Array(Buffer.from(info));

    const syncResult = hkdfSync(hash, ta_secret, ta_salt, ta_info, length);
    hkdf(hash, ta_secret, ta_salt, ta_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const ta_secret = new Uint8Array(Buffer.from(secret));
    const ta_salt = new Uint16Array(Buffer.from(salt));
    const ta_info = new Uint32Array(Buffer.from(info));

    const syncResult = hkdfSync(
      hash,
      ta_secret.buffer,
      ta_salt.buffer,
      ta_info.buffer,
      length);
    hkdf(hash, ta_secret, ta_salt, ta_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const ta_secret = new Uint8Array(Buffer.from(secret));
    const sa_salt = new SharedArrayBuffer(0);
    const sa_info = new SharedArrayBuffer(1);

    const syncResult = hkdfSync(
      hash,
      ta_secret.buffer,
      sa_salt,
      sa_info,
      length);
    hkdf(hash, ta_secret, sa_salt, sa_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }
});


if (!common.hasOpenSSL3) {
  const kKnownUnsupported = ['shake128', 'shake256'];
  getHashes()
    .filter((hash) => !kKnownUnsupported.includes(hash))
    .forEach((hash) => {
      assert(hkdfSync(hash, 'key', 'salt', 'info', 5));
    });
}

```"
"```javascript:test\fs\test-fs-access.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';

// This tests that fs.access and fs.accessSync works as expected
// and the errors thrown from these APIs include the desired properties

import process from 'process';
import common from '../common';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import { internalBinding } from 'internal/test/binding';
const { UV_ENOENT } = internalBinding('uv');

import tmpdir from '../common/tmpdir';
const doesNotExist = path.join(tmpdir.path, '__this_should_not_exist');
const readOnlyFile = path.join(tmpdir.path, 'read_only_file');
const readWriteFile = path.join(tmpdir.path, 'read_write_file');

function createFileWithPerms(file, mode) {
  fs.writeFileSync(file, '');
  fs.chmodSync(file, mode);
}

tmpdir.refresh();
createFileWithPerms(readOnlyFile, 0o444);
createFileWithPerms(readWriteFile, 0o666);

// On non-Windows supported platforms, fs.access(readOnlyFile, W_OK, ...)
// always succeeds if node runs as the super user, which is sometimes the
// case for tests running on our continuous testing platform agents.
//
// In this case, this test tries to change its process user id to a
// non-superuser user so that the test that checks for write access to a
// read-only file can be more meaningful.
//
// The change of user id is done after creating the fixtures files for the same
// reason: the test may be run as the superuser within a directory in which
// only the superuser can create files, and thus it may need superuser
// privileges to create them.
//
// There's not really any point in resetting the process' user id to 0 after
// changing it to 'nobody', since in the case that the test runs without
// superuser privilege, it is not possible to change its process user id to
// superuser.
//
// It can prevent the test from removing files created before the change of user
// id, but that's fine. In this case, it is the responsibility of the
// continuous integration platform to take care of that.
let hasWriteAccessForReadonlyFile = false;

assert.strictEqual(typeof fs.F_OK, 'number');
assert.strictEqual(typeof fs.R_OK, 'number');
assert.strictEqual(typeof fs.W_OK, 'number');
assert.strictEqual(typeof fs.X_OK, 'number');

const throwNextTick = (e) => { process.nextTick(() => { throw e; }); };

let __filename = args[0];

fs.access(__filename, common.mustCall(function (...args) {
  assert.deepStrictEqual(args, [null]);
}));
fs.promises.access(__filename)
  .then(common.mustCall())
  .catch(throwNextTick);
fs.access(__filename, fs.R_OK, common.mustCall(function (...args) {
  assert.deepStrictEqual(args, [null]);
}));
fs.promises.access(__filename, fs.R_OK)
  .then(common.mustCall())
  .catch(throwNextTick);
fs.access(readOnlyFile, fs.R_OK, common.mustCall(function (...args) {
  assert.deepStrictEqual(args, [null]);
}));
fs.promises.access(readOnlyFile, fs.R_OK)
  .then(common.mustCall())
  .catch(throwNextTick);

{
  const expectedError = (err) => {
    assert.notStrictEqual(err, null);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.path, doesNotExist);
  };
  fs.access(doesNotExist, common.mustCall(expectedError));
  fs.promises.access(doesNotExist)
    .then(common.mustNotCall(), common.mustCall(expectedError))
    .catch(throwNextTick);
}
/* require chmod
{
  function expectedError(err) {
    assert.strictEqual(this, undefined);
    if (hasWriteAccessForReadonlyFile) {
      assert.ifError(err);
    } else {
      assert.notStrictEqual(err, null);
      assert.strictEqual(err.path, readOnlyFile);
    }
  }
  fs.access(readOnlyFile, fs.W_OK, common.mustCall(expectedError));
  fs.promises.access(readOnlyFile, fs.W_OK)
    .then(common.mustNotCall(), common.mustCall(expectedError))
    .catch(throwNextTick);
}
*/
{
  const expectedError = (err) => {
    assert.strictEqual(err.code, 'ERR_INVALID_ARG_TYPE');
    assert.ok(err instanceof TypeError);
    return true;
  };
  assert.throws(
    () => { fs.access(100, fs.F_OK, common.mustNotCall()); },
    expectedError
  );

  fs.promises.access(100, fs.F_OK)
    .then(common.mustNotCall(), common.mustCall(expectedError))
    .catch(throwNextTick);
}

assert.throws(
  () => {
    fs.access(__filename, fs.F_OK);
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.access(__filename, fs.F_OK, common.mustNotMutateObjectDeep({}));
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

// Regular access should not throw.
fs.accessSync(__filename);
const mode = fs.R_OK | fs.W_OK;
fs.accessSync(readWriteFile, mode);

// Invalid modes should throw.
[
  false,
  1n,
  { [Symbol.toPrimitive]() { return fs.R_OK; } },
  [1],
  'r',
].forEach((mode, i) => {
  console.log(mode, i);
  assert.throws(
    () => fs.access(readWriteFile, mode, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""mode"" argument.+integer/
    }
  );
  assert.throws(
    () => fs.accessSync(readWriteFile, mode),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""mode"" argument.+integer/
    }
  );
});

// Out of range modes should throw
[
  -1,
  8,
  Infinity,
  NaN,
].forEach((mode, i) => {
  console.log(mode, i);
  assert.throws(
    () => fs.access(readWriteFile, mode, common.mustNotCall()),
    {
      code: 'ERR_OUT_OF_RANGE',
      message: /""mode"".+It must be an integer >= 0 && <= 7/
    }
  );
  assert.throws(
    () => fs.accessSync(readWriteFile, mode),
    {
      code: 'ERR_OUT_OF_RANGE',
      message: /""mode"".+It must be an integer >= 0 && <= 7/
    }
  );
});


assert.throws(
  () => { fs.accessSync(doesNotExist); },
  (err) => {
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.path, doesNotExist);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, access '${doesNotExist}'`
    );
    assert.strictEqual(err.constructor, Error);
    assert.strictEqual(err.syscall, 'access');
    assert.strictEqual(err.errno, UV_ENOENT);
    return true;
  }
);

assert.throws(
  () => { fs.accessSync(Buffer.from(doesNotExist)); },
  (err) => {
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.path, doesNotExist);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, access '${doesNotExist}'`
    );
    assert.strictEqual(err.constructor, Error);
    assert.strictEqual(err.syscall, 'access');
    assert.strictEqual(err.errno, UV_ENOENT);
    return true;
  }
);

```"
"```javascript:modules\internal\streams\utils.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

const kIsDisturbed = Symbol(""kIsDisturbed"");

function isReadableNodeStream(obj) {
    return !!(
        obj &&
        typeof obj.pipe === ""function"" &&
        typeof obj.on === ""function"" &&
        (!obj._writableState || obj._readableState?.readable !== false) && // Duplex
        (!obj._writableState || obj._readableState) // Writable has .pipe.
    );
}

function isWritableNodeStream(obj) {
    return !!(
        obj &&
        typeof obj.write === ""function"" &&
        typeof obj.on === ""function"" &&
        (!obj._readableState || obj._writableState?.writable !== false) // Duplex
    );
}

function isDuplexNodeStream(obj) {
    return !!(
        obj &&
        (typeof obj.pipe === ""function"" && obj._readableState) &&
        typeof obj.on === ""function"" &&
        typeof obj.write === ""function""
    );
}

function isNodeStream(obj) {
    return (
        obj &&
        (
            obj._readableState ||
            obj._writableState ||
            (typeof obj.write === ""function"" && typeof obj.on === ""function"") ||
            (typeof obj.pipe === ""function"" && typeof obj.on === ""function"")
        )
    );
}

function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === ""function"";
    if (isAsync === false) return typeof obj[Symbol.iterator] === ""function"";
    return typeof obj[Symbol.asyncIterator] === ""function"" ||
        typeof obj[Symbol.iterator] === ""function"";
}

function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}

// Have been end():d.
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== ""boolean"") return null;
    return wState.ended;
}

// Have emitted 'finish'.
function isWritableFinished(stream, strict) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableFinished === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.finished !== ""boolean"") return null;
    return !!(
        wState.finished ||
        (strict === false && wState.ended === true && wState.length === 0)
    );
}

// Have been push(null):d.
function isReadableEnded(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== ""boolean"") return null;
    return rState.ended;
}

// Have emitted 'end'.
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== ""boolean"") return null;
    return !!(
        rState.endEmitted ||
        (strict === false && rState.ended === true && rState.length === 0)
    );
}

function isDisturbed(stream) {
    return !!(stream && (
        stream.readableDidRead ||
        stream.readableAborted ||
        stream[kIsDisturbed]
    ));
}

function isReadable(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== ""boolean"") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}

function isWritable(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== ""boolean"") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}

function isFinished(stream, opts) {
    if (!isNodeStream(stream)) {
        return null;
    }

    if (isDestroyed(stream)) {
        return true;
    }

    if (opts?.readable !== false && isReadable(stream)) {
        return false;
    }

    if (opts?.writable !== false && isWritable(stream)) {
        return false;
    }

    return true;
}

function isClosed(stream) {
    if (!isNodeStream(stream)) {
        return null;
    }

    const wState = stream._writableState;
    const rState = stream._readableState;

    if (
        typeof wState?.closed === ""boolean"" ||
        typeof rState?.closed === ""boolean""
    ) {
        return wState?.closed || rState?.closed;
    }

    if (typeof stream._closed === ""boolean"" && isOutgoingMessage(stream)) {
        return stream._closed;
    }

    return null;
}

function isOutgoingMessage(stream) {
    return (
        typeof stream._closed === ""boolean"" &&
        typeof stream._defaultKeepAlive === ""boolean"" &&
        typeof stream._removedConnection === ""boolean"" &&
        typeof stream._removedContLen === ""boolean""
    );
}

function isServerResponse(stream) {
    return (
        typeof stream._sent100 === ""boolean"" &&
        isOutgoingMessage(stream)
    );
}

function isServerRequest(stream) {
    return (
        typeof stream._consuming === ""boolean"" &&
        typeof stream._dumped === ""boolean"" &&
        stream.req?.upgradeOrConnect === undefined
    );
}

function willEmitClose(stream) {
    if (!isNodeStream(stream)) return null;

    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;

    return (!state && isServerResponse(stream)) || !!(
        state &&
        state.autoDestroy &&
        state.emitClose &&
        state.closed === false
    );
}

export default {
    isDisturbed,
    kIsDisturbed,
    isClosed,
    isDestroyed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isReadable,
    isReadableNodeStream,
    isReadableEnded,
    isReadableFinished,
    isNodeStream,
    isWritable,
    isWritableNodeStream,
    isWritableEnded,
    isWritableFinished,
    isServerRequest,
    isServerResponse,
    willEmitClose,
};
export {
    isClosed,
    isDestroyed,
    isDisturbed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isNodeStream,
    isReadable,
    isReadableEnded,
    isReadableFinished,
    isReadableNodeStream,
    isServerRequest,
    isServerResponse,
    isWritable,
    isWritableEnded,
    isWritableFinished,
    isWritableNodeStream,
    kIsDisturbed,
    willEmitClose,
};
```"
"```javascript:test\crypto\test-crypto-dh-stateless.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

assert.throws(() => crypto.diffieHellman(), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_TYPE',
  message: 'The ""options"" argument must be of type object. Received undefined'
});

assert.throws(() => crypto.diffieHellman(null), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_TYPE',
  message: 'The ""options"" argument must be of type object. Received null'
});

assert.throws(() => crypto.diffieHellman([]), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_TYPE',
  message:
    'The ""options"" argument must be of type object. ' +
    'Received an instance of Array',
});

function test({ publicKey: alicePublicKey, privateKey: alicePrivateKey },
              { publicKey: bobPublicKey, privateKey: bobPrivateKey },
              expectedValue) {
  const buf1 = crypto.diffieHellman({
    privateKey: alicePrivateKey,
    publicKey: bobPublicKey
  });
  const buf2 = crypto.diffieHellman({
    privateKey: bobPrivateKey,
    publicKey: alicePublicKey
  });
  assert.deepStrictEqual(buf1, buf2);

  if (expectedValue !== undefined)
    assert.deepStrictEqual(buf1, expectedValue);
}

const alicePrivateKey = crypto.createPrivateKey({
  key: '-----BEGIN PRIVATE KEY-----\n' +
       'MIIBoQIBADCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKL\n' +
       'gNwc0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVt\n' +
       'bVHCReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR\n' +
       '7ORbPcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkH\n' +
       'cJaWbWcMNU5KvJgE8XRsCMojcyf//////////wIBAgSBwwKBwEh82IAVnYNf0Kjb\n' +
       'qYSImDFyg9sH6CJ0GzRK05e6hM3dOSClFYi4kbA7Pr7zyfdn2SH6wSlNS14Jyrtt\n' +
       'HePrRSeYl1T+tk0AfrvaLmyM56F+9B3jwt/nzqr5YxmfVdXb2aQV53VS/mm3pB2H\n' +
       'iIt9FmvFaaOVe2DupqSr6xzbf/zyON+WF5B5HNVOWXswgpgdUsCyygs98hKy/Xje\n' +
       'TGzJUoWInW39t0YgMXenJrkS0m6wol8Rhxx81AGgELNV7EHZqg==\n' +
       '-----END PRIVATE KEY-----',
  format: 'pem'
});
const alicePublicKey = crypto.createPublicKey({
  key: '-----BEGIN PUBLIC KEY-----\n' +
       'MIIBnzCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKLgNwc\n' +
       '0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHC\n' +
       'ReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7ORb\n' +
       'PcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkHcJaW\n' +
       'bWcMNU5KvJgE8XRsCMojcyf//////////wIBAgOBxAACgcBR7+iL5qx7aOb9K+aZ\n' +
       'y2oLt7ST33sDKT+nxpag6cWDDWzPBKFDCJ8fr0v7yW453px8N4qi4R7SYYxFBaYN\n' +
       'Y3JvgDg1ct2JC9sxSuUOLqSFn3hpmAjW7cS0kExIVGfdLlYtIqbhhuo45cTEbVIM\n' +
       'rDEz8mjIlnvbWpKB9+uYmbjfVoc3leFvUBqfG2In2m23Md1swsPxr3n7g68H66JX\n' +
       'iBJKZLQMqNdbY14G9rdKmhhTJrQjC+i7Q/wI8JPhOFzHIGA=\n' +
       '-----END PUBLIC KEY-----',
  format: 'pem'
});

const bobPrivateKey = crypto.createPrivateKey({
  key: '-----BEGIN PRIVATE KEY-----\n' +
       'MIIBoQIBADCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKL\n' +
       'gNwc0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVt\n' +
       'bVHCReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR\n' +
       '7ORbPcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkH\n' +
       'cJaWbWcMNU5KvJgE8XRsCMojcyf//////////wIBAgSBwwKBwHxnT7Zw2Ehh1vyw\n' +
       'eolzQFHQzyuT0y+3BF+FxK2Ox7VPguTp57wQfGHbORJ2cwCdLx2mFM7gk4tZ6COS\n' +
       'E3Vta85a/PuhKXNLRdP79JgLnNtVtKXB+ePDS5C2GgXH1RHvqEdJh7JYnMy7Zj4P\n' +
       'GagGtIy3dV5f4FA0B/2C97jQ1pO16ah8gSLQRKsNpTCw2rqsZusE0rK6RaYAef7H\n' +
       'y/0tmLIsHxLIn+WK9CANqMbCWoP4I178BQaqhiOBkNyNZ0ndqA==\n' +
       '-----END PRIVATE KEY-----',
  format: 'pem'
});

const bobPublicKey = crypto.createPublicKey({
  key: '-----BEGIN PUBLIC KEY-----\n' +
       'MIIBoDCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKLgNwc\n' +
       '0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHC\n' +
       'ReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7ORb\n' +
       'PcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkHcJaW\n' +
       'bWcMNU5KvJgE8XRsCMojcyf//////////wIBAgOBxQACgcEAi26oq8z/GNSBm3zi\n' +
       'gNt7SA7cArUBbTxINa9iLYWp6bxrvCKwDQwISN36/QUw8nUAe8aRyMt0oYn+y6vW\n' +
       'Pw5OlO+TLrUelMVFaADEzoYomH0zVGb0sW4aBN8haC0mbrPt9QshgCvjr1hEPEna\n' +
       'QFKfjzNaJRNMFFd4f2Dn8MSB4yu1xpA1T2i0JSk24vS2H55jx24xhUYtfhT2LJgK\n' +
       'JvnaODey/xtY4Kql10ZKf43Lw6gdQC3G8opC9OxVxt9oNR7Z\n' +
       '-----END PUBLIC KEY-----',
  format: 'pem'
});

assert.throws(() => crypto.diffieHellman({ privateKey: alicePrivateKey }), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_VALUE',
  message: ""The property 'options.publicKey' is invalid. Received undefined""
});

assert.throws(() => crypto.diffieHellman({ publicKey: alicePublicKey }), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_VALUE',
  message: ""The property 'options.privateKey' is invalid. Received undefined""
});

const privateKey = Buffer.from(
  '487CD880159D835FD0A8DBA9848898317283DB07E822741B344AD397BA84CDDD3920A51588' +
  'B891B03B3EBEF3C9F767D921FAC1294D4B5E09CABB6D1DE3EB4527989754FEB64D007EBBDA' +
  '2E6C8CE7A17EF41DE3C2DFE7CEAAF963199F55D5DBD9A415E77552FE69B7A41D87888B7D16' +
  '6BC569A3957B60EEA6A4ABEB1CDB7FFCF238DF961790791CD54E597B3082981D52C0B2CA0B' +
  '3DF212B2FD78DE4C6CC95285889D6DFDB746203177A726B912D26EB0A25F11871C7CD401A0' +
  '10B355EC41D9AA', 'hex');
const publicKey = Buffer.from(
  '8b6ea8abccff18d4819b7ce280db7b480edc02b5016d3c4835af622d85a9e9bc6bbc22b00d' +
  '0c0848ddfafd0530f275007bc691c8cb74a189fecbabd63f0e4e94ef932eb51e94c5456800' +
  'c4ce8628987d335466f4b16e1a04df21682d266eb3edf50b21802be3af58443c49da40529f' +
  '8f335a25134c1457787f60e7f0c481e32bb5c690354f68b4252936e2f4b61f9e63c76e3185' +
  '462d7e14f62c980a26f9da3837b2ff1b58e0aaa5d7464a7f8dcbc3a81d402dc6f28a42f4ec' +
  '55c6df68351ed9', 'hex');

const group = crypto.getDiffieHellman('modp5');
const dh = crypto.createDiffieHellman(group.getPrime(), group.getGenerator());
dh.setPrivateKey(privateKey);

// Test simple Diffie-Hellman, no curves involved.
test({ publicKey: alicePublicKey, privateKey: alicePrivateKey },
     { publicKey: bobPublicKey, privateKey: bobPrivateKey },
     dh.computeSecret(publicKey));

test(crypto.generateKeyPairSync('dh', { group: 'modp5' }),
     crypto.generateKeyPairSync('dh', { group: 'modp5' }));

test(crypto.generateKeyPairSync('dh', { group: 'modp5' }),
     crypto.generateKeyPairSync('dh', { prime: group.getPrime() }));

const list = [
  // Same generator, but different primes.
  [{ group: 'modp5' }, { group: 'modp18' }]];

// TODO(danbev): Take a closer look if there should be a check in OpenSSL3
// when the dh parameters differ.
if (!common.hasOpenSSL3) {
  // Same primes, but different generator.
  list.push([{ group: 'modp5' }, { prime: group.getPrime(), generator: 5 }]);
  // Same generator, but different primes.
  list.push([{ primeLength: 1024 }, { primeLength: 1024 }]);
}

for (const [params1, params2] of list) {
  assert.throws(() => {
    test(crypto.generateKeyPairSync('dh', params1),
         crypto.generateKeyPairSync('dh', params2));
  }, common.hasOpenSSL3 ? {
    name: 'Error',
    code: 'ERR_OSSL_MISMATCHING_DOMAIN_PARAMETERS'
  } : {
    name: 'Error',
    code: 'ERR_OSSL_EVP_DIFFERENT_PARAMETERS'
  });
}
{
  const privateKey = crypto.createPrivateKey({
    key: '-----BEGIN PRIVATE KEY-----\n' +
         'MIIBoQIBADCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKL\n' +
         'gNwc0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVt\n' +
         'bVHCReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR\n' +
         '7ORbPcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkH\n' +
         'cJaWbWcMNU5KvJgE8XRsCMojcyf//////////wIBAgSBwwKBwHu9fpiqrfJJ+tl9\n' +
         'ujFtEWv4afub6A/1/7sgishOYN3YQ+nmWQlmPpveIY34an5dG82CTrixHwUzQTMF\n' +
         'JaiCW3ax9+qk31f2jTNKrQznmKgopVKXF0FEJC6H79W/8Y0U14gsI9sHpovKhfou\n' +
         'RQD0QogW7ejSwMG8hCYibfrvMm0b5PHlwimISyEKh7VtDQ1frYN/Wr9ZbiV+FePJ\n' +
         '2j6RUKYNj1Pv+B4zdMgiLLjILAs8WUfbHciU21KSJh1izVQaUQ==\n' +
         '-----END PRIVATE KEY-----'
  });
  const publicKey = crypto.createPublicKey({
    key: '-----BEGIN PUBLIC KEY-----\n' +
         'MIIBoDCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKLgNwc\n' +
         '0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHC\n' +
         'ReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7ORb\n' +
         'PcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkHcJaW\n' +
         'bWcMNU5KvJgE8XRsCMojcyf//////////wIBAgOBxQACgcEAmG9LpD8SAA6/W7oK\n' +
         'E4MCuuQtf5E8bqtcEAfYTOOvKyCS+eiX3TtZRsvHJjUBEyeO99PR/KrGVlkSuW52\n' +
         'ZOSXUOFu1L/0tqHrvRVHo+QEq3OvZ3EAyJkdtSEUTztxuUrMOyJXHDc1OUdNSnk0\n' +
         'taGX4mP3247golVx2DS4viDYs7UtaMdx03dWaP6y5StNUZQlgCIUzL7MYpC16V5y\n' +
         'KkFrE+Kp/Z77gEjivaG6YuxVj4GPLxJYbNFVTel42oSVeKuq\n' +
         '-----END PUBLIC KEY-----',
    format: 'pem'
  });

  // This key combination will result in an unusually short secret, and should
  // not cause an assertion failure.
  const secret = crypto.diffieHellman({ publicKey, privateKey });
  assert.strictEqual(secret.toString('hex'),
                     '0099d0fa242af5db9ea7330e23937a27db041f79c581500fc7f9976' +
                     '554d59d5b9ced934778d72e19a1fefc81e9d981013198748c0b5c6c' +
                     '762985eec687dc5bec5c9367b05837daee9d0bcc29024ed7f3abba1' +
                     '2794b65a745117fb0d87bc5b1b2b68c296c3f686cc29e450e4e1239' +
                     '21f56a5733fe58aabf71f14582954059c2185d342b9b0fa10c2598a' +
                     '5426c2baee7f9a686fc1e16cd4757c852bf7225a2732250548efe28' +
                     'debc26f1acdec51efe23d20786a6f8a14d360803bbc71972e87fd3');
}

// Test ECDH.

test(crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' }),
     crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' }));

const not256k1 = crypto.getCurves().find((c) => /^sec.*(224|384|512)/.test(c));
assert.throws(() => {
  test(crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' }),
       crypto.generateKeyPairSync('ec', { namedCurve: not256k1 }));
}, common.hasOpenSSL3 ? {
  name: 'Error',
  code: 'ERR_OSSL_MISMATCHING_DOMAIN_PARAMETERS'
} : {
  name: 'Error',
  code: 'ERR_OSSL_EVP_DIFFERENT_PARAMETERS'
});

// Test ECDH-ES.

test(crypto.generateKeyPairSync('x448'),
     crypto.generateKeyPairSync('x448'));

test(crypto.generateKeyPairSync('x25519'),
     crypto.generateKeyPairSync('x25519'));

assert.throws(() => {
  test(crypto.generateKeyPairSync('x448'),
       crypto.generateKeyPairSync('x25519'));
}, {
  name: 'Error',
  code: 'ERR_CRYPTO_INCOMPATIBLE_KEY',
  message: 'Incompatible key types for Diffie-Hellman: x448 and x25519'
});

```"
"```javascript:modules\internal\crypto\sig.js
'use strict';

const {
  FunctionPrototypeCall,
  ObjectSetPrototypeOf,
  ReflectApply,
} = primordials;

const {
  codes: {
    ERR_CRYPTO_SIGN_KEY_REQUIRED,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE,
  }
} = require('internal/errors');

const {
  validateFunction,
  validateEncoding,
  validateString,
} = require('internal/validators');

const {
  Sign: _Sign,
  SignJob,
  Verify: _Verify,
  kCryptoJobAsync,
  kCryptoJobSync,
  kSigEncDER,
  kSigEncP1363,
  kSignJobModeSign,
  kSignJobModeVerify,
} = internalBinding('crypto');

const {
  getArrayBufferOrView,
  getDefaultEncoding,
  kHandle,
} = require('internal/crypto/util');

const {
  preparePrivateKey,
  preparePublicOrPrivateKey,
} = require('internal/crypto/keys');

const { Writable } = require('stream');

const { Buffer } = require('buffer');

const {
  isArrayBufferView,
} = require('internal/util/types');

function Sign(algorithm, options) {
  if (!(this instanceof Sign))
    return new Sign(algorithm, options);
  validateString(algorithm, 'algorithm');
  this[kHandle] = new _Sign();
  this[kHandle].init(algorithm);

  ReflectApply(Writable, this, [options]);
}

ObjectSetPrototypeOf(Sign.prototype, Writable.prototype);
ObjectSetPrototypeOf(Sign, Writable);

Sign.prototype._write = function _write(chunk, encoding, callback) {
  this.update(chunk, encoding);
  callback();
};

Sign.prototype.update = function update(data, encoding) {
  encoding = encoding || getDefaultEncoding();

  if (typeof data === 'string') {
    validateEncoding(data, encoding);
  } else if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data', ['string', 'Buffer', 'TypedArray', 'DataView'], data);
  }

  this[kHandle].update(data, encoding);
  return this;
};

function getPadding(options) {
  return getIntOption('padding', options);
}

function getSaltLength(options) {
  return getIntOption('saltLength', options);
}

function getDSASignatureEncoding(options) {
  if (typeof options === 'object') {
    const { dsaEncoding = 'der' } = options;
    if (dsaEncoding === 'der')
      return kSigEncDER;
    else if (dsaEncoding === 'ieee-p1363')
      return kSigEncP1363;
    throw new ERR_INVALID_ARG_VALUE('options.dsaEncoding', dsaEncoding);
  }

  return kSigEncDER;
}

function getIntOption(name, options) {
  const value = options[name];
  if (value !== undefined) {
    if (value === value >> 0) {
      return value;
    }
    throw new ERR_INVALID_ARG_VALUE(`options.${name}`, value);
  }
  return undefined;
}

Sign.prototype.sign = function sign(options, encoding) {
  if (!options)
    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();

  const { data, format, type, passphrase } = preparePrivateKey(options, true);

  // Options specific to RSA
  const rsaPadding = getPadding(options);
  const pssSaltLength = getSaltLength(options);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(options);

  const ret = this[kHandle].sign(data, format, type, passphrase, rsaPadding,
                                 pssSaltLength, dsaSigEnc);

  encoding = encoding || getDefaultEncoding();
  if (encoding && encoding !== 'buffer')
    return ret.toString(encoding);

  return ret;
};

function signOneShot(algorithm, data, key, callback) {
  if (algorithm != null)
    validateString(algorithm, 'algorithm');

  if (callback !== undefined)
    validateFunction(callback, 'callback');

  data = getArrayBufferOrView(data, 'data');

  if (!key)
    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();

  // Options specific to RSA
  const rsaPadding = getPadding(key);
  const pssSaltLength = getSaltLength(key);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(key);

  const {
    data: keyData,
    format: keyFormat,
    type: keyType,
    passphrase: keyPassphrase
  } = preparePrivateKey(key);

  const job = new SignJob(
    callback ? kCryptoJobAsync : kCryptoJobSync,
    kSignJobModeSign,
    keyData,
    keyFormat,
    keyType,
    keyPassphrase,
    data,
    algorithm,
    pssSaltLength,
    rsaPadding,
    dsaSigEnc);

  if (!callback) {
    const { 0: err, 1: signature } = job.run();
    if (err !== undefined)
      throw err;

    return Buffer.from(signature);
  }

  job.ondone = (error, signature) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, Buffer.from(signature));
  };
  job.run();
}

function Verify(algorithm, options) {
  if (!(this instanceof Verify))
    return new Verify(algorithm, options);
  validateString(algorithm, 'algorithm');
  this[kHandle] = new _Verify();
  this[kHandle].init(algorithm);

  ReflectApply(Writable, this, [options]);
}

ObjectSetPrototypeOf(Verify.prototype, Writable.prototype);
ObjectSetPrototypeOf(Verify, Writable);

Verify.prototype._write = Sign.prototype._write;
Verify.prototype.update = Sign.prototype.update;

Verify.prototype.verify = function verify(options, signature, sigEncoding) {
  const {
    data,
    format,
    type,
    passphrase
  } = preparePublicOrPrivateKey(options, true);

  sigEncoding = sigEncoding || getDefaultEncoding();

  // Options specific to RSA
  const rsaPadding = getPadding(options);
  const pssSaltLength = getSaltLength(options);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(options);

  signature = getArrayBufferOrView(signature, 'signature', sigEncoding);

  return this[kHandle].verify(data, format, type, passphrase, signature,
                              rsaPadding, pssSaltLength, dsaSigEnc);
};

function verifyOneShot(algorithm, data, key, signature, callback) {
  if (algorithm != null)
    validateString(algorithm, 'algorithm');

  if (callback !== undefined)
    validateFunction(callback, 'callback');

  data = getArrayBufferOrView(data, 'data');

  if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data',
      ['Buffer', 'TypedArray', 'DataView'],
      data
    );
  }

  // Options specific to RSA
  const rsaPadding = getPadding(key);
  const pssSaltLength = getSaltLength(key);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(key);

  if (!isArrayBufferView(signature)) {
    throw new ERR_INVALID_ARG_TYPE(
      'signature',
      ['Buffer', 'TypedArray', 'DataView'],
      signature
    );
  }

  const {
    data: keyData,
    format: keyFormat,
    type: keyType,
    passphrase: keyPassphrase
  } = preparePublicOrPrivateKey(key);

  const job = new SignJob(
    callback ? kCryptoJobAsync : kCryptoJobSync,
    kSignJobModeVerify,
    keyData,
    keyFormat,
    keyType,
    keyPassphrase,
    data,
    algorithm,
    pssSaltLength,
    rsaPadding,
    dsaSigEnc,
    signature);

  if (!callback) {
    const { 0: err, 1: result } = job.run();
    if (err !== undefined)
      throw err;

    return result;
  }

  job.ondone = (error, result) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, result);
  };
  job.run();
}

module.exports = {
  Sign,
  signOneShot,
  Verify,
  verifyOneShot,
};

```"
"```javascript:modules\internal\fs\stream.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

import { Writable, Readable } from ""stream"";
import { validateEncoding } from ""./utils"";
import { URL } from ""url"";
import { toPathIfFileURL } from ""../url"";
import fs, { open, write, close, statSync } from ""../../fs"";
import { validateInteger, validateObject } from ""../validators"";
import { nextTick } from ""../../process"";

const kIsPerformingIO = Symbol('kIsPerformingIO');

const kFs = Symbol('kFs');

function notImplemented(msg) {
    throw new Error(msg);
}

export class WriteStreamClass extends Writable {
    fd = null;
    bytesWritten = 0;
    pos = 0;
    [kFs] = {
        open: fs.open,
        write: fs.write
    };
    [kIsPerformingIO] = false;
    constructor(path, opts) {
        super(opts);
        if (typeof (opts) === ""string"") {
            validateEncoding(opts, ""encoding"");
            opts = {};
        }
        if (opts === null || opts === undefined) {
            opts = {};
        }
        validateObject(opts, ""options"");
        if (opts.encoding) {
            validateEncoding(opts.encoding, ""encoding"");
            this.setDefaultEncoding(opts.encoding);
        }
        if (opts.start) {
            validateInteger(opts.start, ""start"");
        }
        this.pending = true;
        this.path = toPathIfFileURL(path);
        this.flags = opts.flags || ""w"";
        this.mode = opts.mode || 0o666;
        this[kFs] = opts.fs ?? {
            open: fs.open, write: fs.write, close: fs.close
        };
    }

    _construct(callback) {
        this[kFs].open(
            this.path.toString(),
            this.flags,
            this.mode,
            (err, fd) => {
                if (err) {
                    callback(err);
                    return;
                }
                this.pending = false;
                this.fd = fd;
                callback();
                this.emit(""open"", this.fd);
                this.emit(""ready"");
            },
        );
    }

    _write(
        data,
        _encoding,
        cb,
    ) {
        this[kIsPerformingIO] = true;
        this[kFs].write(
            this.fd,
            data,
            0,
            data.length,
            this.pos,
            (er) => {
                this[kIsPerformingIO] = false;
                if (this.destroyed) {
                    // Tell ._destroy() that it's safe to close the fd now.
                    cb(er);
                    return this.emit(kIoDone, er);
                }

                if (er) {
                    return cb(er);
                }

                this.bytesWritten += bytes;
                cb();
            },
        );

        if (this.pos !== undefined) {
            this.pos += data.length;
        }
    }

    _destroy(err, cb) {
        if (this[kIsPerformingIO]) {
            this.once(kIoDone, (er) => closeStream(this, err || er, cb));
        } else {
            closeStream(this, err, cb);
        }
    }
}

function closeStream(
    stream,
    err,
    cb,
) {
    if (!stream.fd) {
        cb(err);
    } else {
        stream[kFs].close(stream.fd, (er) => {
            cb(er || err);
        });
        stream.fd = null;
    }
}

export function WriteStream(
    path,
    opts,
) {
    return new WriteStreamClass(path, opts);
}

WriteStream.prototype = WriteStreamClass.prototype;

export function createWriteStream(
    path,
    opts,
) {
    return new WriteStreamClass(path, opts);
}

export class ReadStream extends Readable {
    constructor(path, opts) {
        path = path instanceof URL ? fromFileUrl(path) : path;
        if (opts && opts.start) {
            validateInteger(opts.start, ""start"");
        }
        if (opts && opts.end) {
            validateInteger(opts.end, ""end"");
        }
        const hasBadOptions = opts && (
            opts.start || opts.end || opts.fs
        );
        if (opts === null || typeof (opts) === ""undefined"") {
            opts = ""utf8"";
        }
        if (typeof (opts) === ""string"") {
            validateEncoding(opts, ""encoding"");
        } else {
            validateEncoding(opts.encoding || ""utf8"", ""encoding"");
        }
        // skip
        if (hasBadOptions && false) {
            notImplemented(
                `fs.ReadStream.prototype.constructor with unsupported options (${JSON.stringify(opts)
                })`,
            );
        }
        const buffer = Buffer.alloc(16 * 1024);
        let curPos = 0;
        let notClose = true;
        if (opts.fd) {
            setTimeout(() => {
                if (this.file === undefined) {
                    this.file = opts.fd;
                    this.pending = false;
                    this.emit(""ready"");
                }
            }, 0);
        } else {
            fs.promises.open(path, fs.constants.O_RDONLY).then(f => {
                if (this.file === undefined) {
                    notClose = false;
                    this.file = f;
                    this.pending = false;
                    this.emit(""ready"");
                }
            });
        }
        super({
            autoDestroy: true,
            emitClose: true,
            objectMode: false,
            read: async function (_size) {
                try {
                    if (this.file === undefined) {
                        if (opts.fd) {
                            if (opts.fd instanceof fs.FileHandle) {
                                this.file = opts.fd;
                            } else {
                                this.file = new fs.FileHandle(opts.fd, path);
                            }
                        } else {
                            this.file = new fs.FileHandle(fs.openSync(path, fs.constants.O_RDONLY), path);
                            notClose = false;
                        }
                        this.pending = false;
                        this.emit(""ready"");
                    }
                    opts.end = opts.end ?? fs.fstatSync(this.file.fd).size;
                    opts.start = opts.start ?? 0;
                    const { bytesRead: n } = await this.file.read(buffer, 0, opts.end - opts.start - curPos + 1, curPos === 0 ? opts.start : -1);
                    curPos += n;
                    if (n === 0) {
                        this.emit(""end"");
                    } else {
                        this.push(n ? Buffer.from(buffer.slice(0, n)) : null);
                        if (curPos >= opts.end) {
                            this.emit(""end"");
                        }
                    }
                } catch (err) {
                    this.destroy(err);
                }
            },
            destroy: (err, cb) => {
                try {
                    if (!notClose) {
                        this.file.close();
                    }
                    // deno-lint-ignore no-empty
                } catch { }
                cb(err);
            },
        });
        this.pending = true;
        this.path = path;
    }
}

export function createReadStream(
    path,
    options,
) {
    return new ReadStream(path, options);
}


```"
"```javascript:test\fs\test-fs-null-bytes.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { URL } from ""url"";

function check(async, sync) {
  const argsSync = Array.prototype.slice.call(arguments, 2);
  const argsAsync = argsSync.concat(common.mustNotCall());

  if (sync) {
    assert.throws(
      () => {
        sync.apply(null, argsSync);
      },
      {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError',
      });
  }

  if (async) {
    assert.throws(
      () => {
        async.apply(null, argsAsync);
      },
      {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError'
      });
  }
}

check(fs.access, fs.accessSync, 'foo\u0000bar');
check(fs.access, fs.accessSync, 'foo\u0000bar', fs.F_OK);
check(fs.appendFile, fs.appendFileSync, 'foo\u0000bar', 'abc');
// check(fs.chmod, fs.chmodSync, 'foo\u0000bar', '0644');
// check(fs.chown, fs.chownSync, 'foo\u0000bar', 12, 34);
check(fs.copyFile, fs.copyFileSync, 'foo\u0000bar', 'abc');
check(fs.copyFile, fs.copyFileSync, 'abc', 'foo\u0000bar');
// check(fs.lchown, fs.lchownSync, 'foo\u0000bar', 12, 34);
check(fs.link, fs.linkSync, 'foo\u0000bar', 'foobar');
check(fs.link, fs.linkSync, 'foobar', 'foo\u0000bar');
check(fs.lstat, fs.lstatSync, 'foo\u0000bar');
check(fs.mkdir, fs.mkdirSync, 'foo\u0000bar', '0755');
check(fs.open, fs.openSync, 'foo\u0000bar', 'r');
check(fs.readFile, fs.readFileSync, 'foo\u0000bar');
check(fs.readdir, fs.readdirSync, 'foo\u0000bar');
check(fs.readlink, fs.readlinkSync, 'foo\u0000bar');
check(fs.realpath, fs.realpathSync, 'foo\u0000bar');
check(fs.rename, fs.renameSync, 'foo\u0000bar', 'foobar');
check(fs.rename, fs.renameSync, 'foobar', 'foo\u0000bar');
check(fs.rmdir, fs.rmdirSync, 'foo\u0000bar');
check(fs.stat, fs.statSync, 'foo\u0000bar');
check(fs.symlink, fs.symlinkSync, 'foo\u0000bar', 'foobar');
check(fs.symlink, fs.symlinkSync, 'foobar', 'foo\u0000bar');
check(fs.truncate, fs.truncateSync, 'foo\u0000bar');
check(fs.unlink, fs.unlinkSync, 'foo\u0000bar');
// check(null, fs.unwatchFile, 'foo\u0000bar', common.mustNotCall());
check(fs.utimes, fs.utimesSync, 'foo\u0000bar', 0, 0);
// check(null, fs.watch, 'foo\u0000bar', common.mustNotCall());
// check(null, fs.watchFile, 'foo\u0000bar', common.mustNotCall());
// check(fs.writeFile, fs.writeFileSync, 'foo\u0000bar', 'abc');

// null bytes will lost in this url module
/*
const fileUrl = new URL('file:///C:/foo\u0000bar');
const fileUrl2 = new URL('file:///C:/foo%00bar');

check(fs.access, fs.accessSync, fileUrl);
check(fs.access, fs.accessSync, fileUrl, fs.F_OK);
check(fs.appendFile, fs.appendFileSync, fileUrl, 'abc');
// check(fs.chmod, fs.chmodSync, fileUrl, '0644');
// check(fs.chown, fs.chownSync, fileUrl, 12, 34);
check(fs.copyFile, fs.copyFileSync, fileUrl, 'abc');
check(fs.copyFile, fs.copyFileSync, 'abc', fileUrl);
// check(fs.lchown, fs.lchownSync, fileUrl, 12, 34);
check(fs.link, fs.linkSync, fileUrl, 'foobar');
check(fs.link, fs.linkSync, 'foobar', fileUrl);
check(fs.lstat, fs.lstatSync, fileUrl);
check(fs.mkdir, fs.mkdirSync, fileUrl, '0755');
check(fs.open, fs.openSync, fileUrl, 'r');
check(fs.readFile, fs.readFileSync, fileUrl);
check(fs.readdir, fs.readdirSync, fileUrl);
check(fs.readlink, fs.readlinkSync, fileUrl);
check(fs.realpath, fs.realpathSync, fileUrl);
check(fs.rename, fs.renameSync, fileUrl, 'foobar');
check(fs.rename, fs.renameSync, 'foobar', fileUrl);
check(fs.rmdir, fs.rmdirSync, fileUrl);
check(fs.stat, fs.statSync, fileUrl);
check(fs.symlink, fs.symlinkSync, fileUrl, 'foobar');
check(fs.symlink, fs.symlinkSync, 'foobar', fileUrl);
check(fs.truncate, fs.truncateSync, fileUrl);
check(fs.unlink, fs.unlinkSync, fileUrl);
// check(null, fs.unwatchFile, fileUrl, assert.fail);
check(fs.utimes, fs.utimesSync, fileUrl, 0, 0);
// check(null, fs.watch, fileUrl, assert.fail);
// check(null, fs.watchFile, fileUrl, assert.fail);
check(fs.writeFile, fs.writeFileSync, fileUrl, 'abc');

check(fs.access, fs.accessSync, fileUrl2);
check(fs.access, fs.accessSync, fileUrl2, fs.F_OK);
check(fs.appendFile, fs.appendFileSync, fileUrl2, 'abc');
// check(fs.chmod, fs.chmodSync, fileUrl2, '0644');
// check(fs.chown, fs.chownSync, fileUrl2, 12, 34);
check(fs.copyFile, fs.copyFileSync, fileUrl2, 'abc');
check(fs.copyFile, fs.copyFileSync, 'abc', fileUrl2);
// check(fs.lchown, fs.lchownSync, fileUrl2, 12, 34);
check(fs.link, fs.linkSync, fileUrl2, 'foobar');
check(fs.link, fs.linkSync, 'foobar', fileUrl2);
check(fs.lstat, fs.lstatSync, fileUrl2);
check(fs.mkdir, fs.mkdirSync, fileUrl2, '0755');
check(fs.open, fs.openSync, fileUrl2, 'r');
check(fs.readFile, fs.readFileSync, fileUrl2);
check(fs.readdir, fs.readdirSync, fileUrl2);
check(fs.readlink, fs.readlinkSync, fileUrl2);
check(fs.realpath, fs.realpathSync, fileUrl2);
check(fs.rename, fs.renameSync, fileUrl2, 'foobar');
check(fs.rename, fs.renameSync, 'foobar', fileUrl2);
check(fs.rmdir, fs.rmdirSync, fileUrl2);
check(fs.stat, fs.statSync, fileUrl2);
check(fs.symlink, fs.symlinkSync, fileUrl2, 'foobar');
check(fs.symlink, fs.symlinkSync, 'foobar', fileUrl2);
check(fs.truncate, fs.truncateSync, fileUrl2);
check(fs.unlink, fs.unlinkSync, fileUrl2);
// check(null, fs.unwatchFile, fileUrl2, assert.fail);
check(fs.utimes, fs.utimesSync, fileUrl2, 0, 0);
// check(null, fs.watch, fileUrl2, assert.fail);
// check(null, fs.watchFile, fileUrl2, assert.fail);
// check(fs.writeFile, fs.writeFileSync, fileUrl2, 'abc');
*/

// An 'error' for exists means that it doesn't exist.
// One of many reasons why this file is the absolute worst.
fs.exists('foo\u0000bar', common.mustCall((exists) => {
  assert(!exists);
}));
assert(!fs.existsSync('foo\u0000bar'));

```"
"```javascript:modules\internal\util.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
import { validateFunction, validateString } from ""./validators.js"";
import { normalizeEncoding, slowCases } from ""./normalize_encoding.js"";
export { normalizeEncoding, slowCases };

export const customInspectSymbol = Symbol.for(""nodejs.util.inspect.custom"");
export const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;

export function once(callback) {
    let called = false;
    return function (...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}

export function createDeferredPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });

    return { promise, resolve, reject };
}

// Keep a list of deprecation codes that have been warned on so we only warn on
// each one once.
const codesWarned = new Set();

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
export function deprecate(fn, msg, code) {
    // TODO(kt3k): Uncomment this
    // if (process.noDeprecation === true) {
    //  return fn;
    // }

    if (code !== undefined) {
        validateString(code, ""code"");
    }

    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code !== undefined) {
                if (!codesWarned.has(code)) {
                    process.emitWarning(msg, ""DeprecationWarning"", code, deprecated);
                    codesWarned.add(code);
                }
            } else {
                process.emitWarning(msg, ""DeprecationWarning"", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }

    // The wrapper will keep the same prototype as fn to maintain prototype chain
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        // Setting this (rather than using Object.setPrototype, as above) ensures
        // that calling the unwrapped constructor gives an instanceof the wrapped
        // constructor.
        deprecated.prototype = fn.prototype;
    }

    return deprecated;
}

// In addition to being accessible through util.promisify.custom,
// this symbol is registered globally and can be accessed in any environment as
// Symbol.for('nodejs.util.promisify.custom').
export const kCustomPromisifiedSymbol = Symbol.for(""nodejs.util.promisify.custom"");
// This is an internal Node symbol used by functions returning multiple
// arguments, e.g. ['bytesRead', 'buffer'] for fs.read().
const kCustomPromisifyArgsSymbol = Symbol.for(
    ""nodejs.util.promisify.customArgs"",
);

export const customPromisifyArgs = kCustomPromisifyArgsSymbol;

export function promisify(
    original,
) {
    validateFunction(original, ""original"");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];

        validateFunction(fn, ""util.promisify.custom"");

        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true,
        });
    }

    // Names to create an object from in case the callback receives multiple
    // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve, reject) => {
            args.push((err, ...values) => {
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for (let i = 0; i < argumentNames.length; i++) {
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            try {
                Reflect.apply(original, this, args);
            } catch (err) {
                return reject(err);
            }
        });
    }

    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true,
    });
    return Object.defineProperties(
        fn,
        Object.getOwnPropertyDescriptors(original),
    );
}

promisify.custom = kCustomPromisifiedSymbol;

const colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

export function removeColors(str) {
    return String.prototype.replace(str, colorRegExp, '');
}

export function isError(e) {
    // An error could be an instance of Error while not being a native error
    // or could be from a different realm and not be instance of Error but still
    // be a native error.
    return e instanceof Error;
}

export const kEmptyObject = Object.freeze(Object.create(null));

export function lazyDOMException(msg, name) {
    let e = new Error(msg)
    e.name = name;
    return e;
}

export function filterDuplicateStrings(items, low) {
    const map = new SafeMap();
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const key = String.prototype.toLowerCase.call(item);
        if (low) {
            map.set(key, key);
        } else {
            map.set(key, item);
        }
    }
    return Array.prototype.sort.call(Array.from(map.values()));
}

export function cachedResult(fn) {
    let result;
    return () => {
        if (result === undefined)
            result = fn();
        return Array.prototype.slice.call(result);
    };
}

export default {
    createDeferredPromise,
    customInspectSymbol,
    kEnumerableProperty,
    normalizeEncoding,
    once,
    deprecate,
    promisify,
    removeColors,
    isError,
    kEmptyObject,
    cachedResult,
    filterDuplicateStrings
};
```"
"```javascript:test\crypto\test-crypto-dh-curves.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

// Second OAKLEY group, see
// https://github.com/nodejs/node-v0.x-archive/issues/2338 and
// https://xml2rfc.tools.ietf.org/public/rfc/html/rfc2412.html#anchor49
const p = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +
          '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +
          '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +
          'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF';
crypto.createDiffieHellman(p, 'hex');

// Confirm DH_check() results are exposed for optional examination.
const bad_dh = crypto.createDiffieHellman('02', 'hex');
assert.notStrictEqual(bad_dh.verifyError, 0);

const availableCurves = new Set(crypto.getCurves());
const availableHashes = new Set(crypto.getHashes());

// Oakley curves do not clean up ERR stack, it was causing unexpected failure
// when accessing other OpenSSL APIs afterwards.
if (availableCurves.has('Oakley-EC2N-3')) {
  crypto.createECDH('Oakley-EC2N-3');
  crypto.createHash('sha256');
}

// Test ECDH
if (availableCurves.has('prime256v1') && availableCurves.has('secp256k1')) {
  const ecdh1 = crypto.createECDH('prime256v1');
  const ecdh2 = crypto.createECDH('prime256v1');
  const key1 = ecdh1.generateKeys();
  const key2 = ecdh2.generateKeys('hex');
  const secret1 = ecdh1.computeSecret(key2, 'hex', 'base64');
  const secret2 = ecdh2.computeSecret(key1, 'latin1', 'buffer');

  assert.strictEqual(secret1, secret2.toString('base64'));

  // Point formats
  assert.strictEqual(ecdh1.getPublicKey('buffer', 'uncompressed')[0], 4);
  let firstByte = ecdh1.getPublicKey('buffer', 'compressed')[0];
  assert(firstByte === 2 || firstByte === 3);
  firstByte = ecdh1.getPublicKey('buffer', 'hybrid')[0];
  assert(firstByte === 6 || firstByte === 7);
  // Format value should be string

  assert.throws(
    () => ecdh1.getPublicKey('buffer', 10),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_FORMAT',
      name: 'TypeError',
      message: 'Invalid ECDH format: 10'
    });

  // ECDH should check that point is on curve
  const ecdh3 = crypto.createECDH('secp256k1');
  const key3 = ecdh3.generateKeys();

  assert.throws(
    () => ecdh2.computeSecret(key3, 'latin1', 'buffer'),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY',
      name: 'Error',
      message: 'Public key is not valid for specified curve'
    });

  // ECDH should allow .setPrivateKey()/.setPublicKey()
  const ecdh4 = crypto.createECDH('prime256v1');

  ecdh4.setPrivateKey(ecdh1.getPrivateKey());
  ecdh4.setPublicKey(ecdh1.getPublicKey());

  assert.throws(() => {
    ecdh4.setPublicKey(ecdh3.getPublicKey());
  }, { message: 'Failed to convert Buffer to EC_POINT' });

  // Verify that we can use ECDH without having to use newly generated keys.
  const ecdh5 = crypto.createECDH('secp256k1');

  // Verify errors are thrown when retrieving keys from an uninitialized object.
  assert.throws(() => {
    ecdh5.getPublicKey();
  }, /^Error: Failed to get ECDH public key$/);

  assert.throws(() => {
    ecdh5.getPrivateKey();
  }, /^Error: Failed to get ECDH private key$/);

  // A valid private key for the secp256k1 curve.
  const cafebabeKey = 'cafebabe'.repeat(8);
  // Associated compressed and uncompressed public keys (points).
  const cafebabePubPtComp =
  '03672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3';
  const cafebabePubPtUnComp =
  '04672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3' +
  '2e02c7f93d13dc2732b760ca377a5897b9dd41a1c1b29dc0442fdce6d0a04d1d';
  ecdh5.setPrivateKey(cafebabeKey, 'hex');
  assert.strictEqual(ecdh5.getPrivateKey('hex'), cafebabeKey);
  // Show that the public point (key) is generated while setting the
  // private key.
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);

  // Compressed and uncompressed public points/keys for other party's
  // private key.
  // 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF
  const peerPubPtComp =
  '02c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae';
  const peerPubPtUnComp =
  '04c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae' +
  'b651944a574a362082a77e3f2b5d9223eb54d7f2f76846522bf75f3bedb8178e';

  const sharedSecret =
  '1da220b5329bbe8bfd19ceef5a5898593f411a6f12ea40f2a8eead9a5cf59970';

  assert.strictEqual(ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex'),
                     sharedSecret);
  assert.strictEqual(ecdh5.computeSecret(peerPubPtUnComp, 'hex', 'hex'),
                     sharedSecret);

  // Verify that we still have the same key pair as before the computation.
  assert.strictEqual(ecdh5.getPrivateKey('hex'), cafebabeKey);
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);

  // Verify setting and getting compressed and non-compressed serializations.
  ecdh5.setPublicKey(cafebabePubPtComp, 'hex');
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
  assert.strictEqual(
    ecdh5.getPublicKey('hex', 'compressed'),
    cafebabePubPtComp
  );
  ecdh5.setPublicKey(cafebabePubPtUnComp, 'hex');
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
  assert.strictEqual(
    ecdh5.getPublicKey('hex', 'compressed'),
    cafebabePubPtComp
  );

  // Show why allowing the public key to be set on this type
  // does not make sense.
  ecdh5.setPublicKey(peerPubPtComp, 'hex');
  assert.strictEqual(ecdh5.getPublicKey('hex'), peerPubPtUnComp);
  assert.throws(() => {
    // Error because the public key does not match the private key anymore.
    ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex');
  }, /Invalid key pair/);

  // Set to a valid key to show that later attempts to set an invalid key are
  // rejected.
  ecdh5.setPrivateKey(cafebabeKey, 'hex');

  // Some invalid private keys for the secp256k1 curve.
  const errMessage = /Private key is not valid for specified curve/;
  ['0000000000000000000000000000000000000000000000000000000000000000',
   'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141',
   'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',
  ].forEach((element) => {
    assert.throws(() => {
      ecdh5.setPrivateKey(element, 'hex');
    }, errMessage);
    // Verify object state did not change.
    assert.strictEqual(ecdh5.getPrivateKey('hex'), cafebabeKey);
  });
}

// Use of invalid keys was not cleaning up ERR stack, and was causing
// unexpected failure in subsequent signing operations.
if (availableCurves.has('prime256v1') && availableHashes.has('sha256')) {
  const curve = crypto.createECDH('prime256v1');
  const invalidKey = Buffer.alloc(65);
  invalidKey.fill('\0');
  curve.generateKeys();
  assert.throws(
    () => curve.computeSecret(invalidKey),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY',
      name: 'Error',
      message: 'Public key is not valid for specified curve'
    });
  // Check that signing operations are not impacted by the above error.
  const ecPrivateKey =
    '-----BEGIN EC PRIVATE KEY-----\n' +
    'MHcCAQEEIF+jnWY1D5kbVYDNvxxo/Y+ku2uJPDwS0r/VuPZQrjjVoAoGCCqGSM49\n' +
    'AwEHoUQDQgAEurOxfSxmqIRYzJVagdZfMMSjRNNhB8i3mXyIMq704m2m52FdfKZ2\n' +
    'pQhByd5eyj3lgZ7m7jbchtdgyOF8Io/1ng==\n' +
    '-----END EC PRIVATE KEY-----';
  crypto.createSign('SHA256').sign(ecPrivateKey);
}

```"
"```javascript:test\fs\test-fs-stat-bigint.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import promiseFs from 'fs/promises';
import path from 'path';
import tmpdir from '../common/tmpdir';
import { isDate } from 'internal/util/types';
import { inspect } from 'internal/util/inspect';

import process from ""process"";

tmpdir.refresh();

let testIndex = 0;

function getFilename() {
  const filename = path.join(tmpdir.path, `test-file-${++testIndex}`);
  fs.writeFileSync(filename, 'test');
  return filename;
}

function verifyStats(bigintStats, numStats, allowableDelta) {
  // allowableDelta: It's possible that the file stats are updated between the
  // two stat() calls so allow for a small difference.
  for (const key of Object.keys(numStats)) {
    const val = numStats[key];
    if (isDate(val)) {
      const time = val.getTime();
      const time2 = bigintStats[key].getTime();
      assert(
        time - time2 <= allowableDelta,
        `difference of ${key}.getTime() should <= ${allowableDelta}.\n` +
        `Number version ${time}, BigInt version ${time2}n`);
    } else if (key === 'mode') {
      assert.strictEqual(bigintStats[key], BigInt(val));
      assert.strictEqual(
        bigintStats.isBlockDevice(),
        numStats.isBlockDevice()
      );
      assert.strictEqual(
        bigintStats.isCharacterDevice(),
        numStats.isCharacterDevice()
      );
      assert.strictEqual(
        bigintStats.isDirectory(),
        numStats.isDirectory()
      );
      assert.strictEqual(
        bigintStats.isFIFO(),
        numStats.isFIFO()
      );
      assert.strictEqual(
        bigintStats.isFile(),
        numStats.isFile()
      );
      assert.strictEqual(
        bigintStats.isSocket(),
        numStats.isSocket()
      );
      assert.strictEqual(
        bigintStats.isSymbolicLink(),
        numStats.isSymbolicLink()
      );
    } else if (key.endsWith('Ms')) {
      const nsKey = key.replace('Ms', 'Ns');
      const msFromBigInt = bigintStats[key];
      const nsFromBigInt = bigintStats[nsKey];
      const msFromBigIntNs = Number(nsFromBigInt / (10n ** 6n));
      const msFromNum = numStats[key];

      assert(
        msFromNum - Number(msFromBigInt) <= allowableDelta,
        `Number version ${key} = ${msFromNum}, ` +
        `BigInt version ${key} = ${msFromBigInt}n, ` +
        `Allowable delta = ${allowableDelta}`);

      assert(
        msFromNum - Number(msFromBigIntNs) <= allowableDelta,
        `Number version ${key} = ${msFromNum}, ` +
        `BigInt version ${nsKey} = ${nsFromBigInt}n` +
        ` = ${msFromBigIntNs}ms, Allowable delta = ${allowableDelta}`);
    } else if (Number.isSafeInteger(val)) {
      assert.strictEqual(
        bigintStats[key], BigInt(val),
        `${inspect(bigintStats[key])} !== ${inspect(BigInt(val))}\n` +
        `key=${key}, val=${val}`
      );
    } else {
      assert(
        Number(bigintStats[key]) - val < 1,
        `${key} is not a safe integer, difference should < 1.\n` +
        `Number version ${val}, BigInt version ${bigintStats[key]}n`);
    }
  }
}

const runSyncTest = (func, arg) => {
  const startTime = process.hrtime.bigint();
  const bigintStats = func(arg, common.mustNotMutateObjectDeep({ bigint: true }));
  const numStats = func(arg);
  const endTime = process.hrtime.bigint();
  const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
  verifyStats(bigintStats, numStats, allowableDelta);
};

{
  const filename = getFilename();
  runSyncTest(fs.statSync, filename);
}

if (!common.isWindows) {
  const filename = getFilename();
  const link = `${filename}-link`;
  fs.symlinkSync(filename, link);
  runSyncTest(fs.lstatSync, link);
}

{
  const filename = getFilename();
  const fd = fs.openSync(filename, 'r');
  runSyncTest(fs.fstatSync, fd);
  fs.closeSync(fd);
}

{
  assert.throws(
    () => fs.statSync('does_not_exist'),
    { code: 'ENOENT' });
  assert.strictEqual(
    fs.statSync('does_not_exist', common.mustNotMutateObjectDeep({ throwIfNoEntry: false })),
    undefined);
}

{
  assert.throws(
    () => fs.lstatSync('does_not_exist'),
    { code: 'ENOENT' });
  assert.strictEqual(
    fs.lstatSync('does_not_exist', common.mustNotMutateObjectDeep({ throwIfNoEntry: false })),
    undefined);
}

{
  assert.throws(
    () => fs.fstatSync(9999),
    { code: 'EBADF' });
  assert.throws(
    () => fs.fstatSync(9999, common.mustNotMutateObjectDeep({ throwIfNoEntry: false })),
    { code: 'EBADF' });
}

const runCallbackTest = (func, arg, done) => {
  const startTime = process.hrtime.bigint();
  func(arg, common.mustNotMutateObjectDeep({ bigint: true }), common.mustCall((err, bigintStats) => {
    func(arg, common.mustCall((err, numStats) => {
      const endTime = process.hrtime.bigint();
      const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
      verifyStats(bigintStats, numStats, allowableDelta);
      if (done) {
        done();
      }
    }));
  }));
};

{
  const filename = getFilename();
  runCallbackTest(fs.stat, filename);
}

if (!common.isWindows) {
  const filename = getFilename();
  const link = `${filename}-link`;
  fs.symlinkSync(filename, link);
  runCallbackTest(fs.lstat, link);
}

{
  const filename = getFilename();
  const fd = fs.openSync(filename, 'r');
  runCallbackTest(fs.fstat, fd, () => { fs.closeSync(fd); });
}

const runPromiseTest = async (func, arg) => {
  const startTime = process.hrtime.bigint();
  const bigintStats = await func(arg, common.mustNotMutateObjectDeep({ bigint: true }));
  const numStats = await func(arg);
  const endTime = process.hrtime.bigint();
  const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
  verifyStats(bigintStats, numStats, allowableDelta);
};

{
  const filename = getFilename();
  runPromiseTest(promiseFs.stat, filename);
}

if (!common.isWindows) {
  const filename = getFilename();
  const link = `${filename}-link`;
  fs.symlinkSync(filename, link);
  runPromiseTest(promiseFs.lstat, link);
}

(async function() {
  const filename = getFilename();
  const handle = await promiseFs.open(filename, 'r');
  const startTime = process.hrtime.bigint();
  const bigintStats = await handle.stat(common.mustNotMutateObjectDeep({ bigint: true }));
  const numStats = await handle.stat();
  const endTime = process.hrtime.bigint();
  const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
  verifyStats(bigintStats, numStats, allowableDelta);
  await handle.close();
})().then(common.mustCall());

```"
"```javascript:test\fs\test-fs-append-file.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';

const currentFileData = 'ABCD';

const s = '���������������203���������111���������������������������������������������������������������������������������������������������' +
          '������������������������������������������������������������������������������������������������������������������' +
          '���������������������������������������������������������203���������������������������������������������' +
          '���196���������179������������������������������������������������������������������������������������������112������' +
          '������������������������������������������������������������������������111������������������������������93������' +
          '���������������������������������������������������������������������������������������������������������������������������������' +
          '���������������������������������������������������������������������������������������������������������������������##������������\n';

tmpdir.refresh();

const throwNextTick = (e) => { process.nextTick(() => { throw e; }); };

// Test that empty file will be created and have content added (callback API).
{
  const filename = join(tmpdir.path, 'append.txt');
  fs.appendFile(filename, s, common.mustSucceed(() => {
    fs.readFile(filename, common.mustSucceed((buffer) => {
      assert.strictEqual(Buffer.byteLength(s), buffer.length);
    }));
  }));
}

// Test that empty file will be created and have content added (promise API).
{
  const filename = join(tmpdir.path, 'append-promise.txt');
  fs.promises.appendFile(filename, s)
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then((buffer) => {
      assert.strictEqual(Buffer.byteLength(s), buffer.length);
    })
    .catch(throwNextTick);
}

// Test that appends data to a non-empty file (callback API).
{
  const filename = join(tmpdir.path, 'append-non-empty.txt');
  fs.writeFileSync(filename, currentFileData);
  fs.appendFile(filename, s, common.mustSucceed(() => {
    fs.readFile(filename, common.mustSucceed((buffer) => {
      assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                         buffer.length);
    }));
  }));
}

// Test that appends data to a non-empty file (promise API).
{
  const filename = join(tmpdir.path, 'append-non-empty-promise.txt');
  fs.writeFileSync(filename, currentFileData);

  fs.promises.appendFile(filename, s)
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then((buffer) => {
      assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                         buffer.length);
    })
    .catch(throwNextTick);
}

// Test that appendFile accepts buffers (callback API).
{
  const filename = join(tmpdir.path, 'append-buffer.txt');
  fs.writeFileSync(filename, currentFileData);

  const buf = Buffer.from(s, 'utf8');

  fs.appendFile(filename, buf, common.mustSucceed(() => {
    fs.readFile(filename, common.mustSucceed((buffer) => {
      assert.strictEqual(buf.length + currentFileData.length, buffer.length);
    }));
  }));
}

// Test that appendFile accepts buffers (promises API).
{
  const filename = join(tmpdir.path, 'append-buffer-promises.txt');
  fs.writeFileSync(filename, currentFileData);

  const buf = Buffer.from(s, 'utf8');

  fs.promises.appendFile(filename, buf)
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then((buffer) => {
      assert.strictEqual(buf.length + currentFileData.length, buffer.length);
    })
    .catch(throwNextTick);
}

// Test that appendFile does not accept invalid data type (callback API).
[false, 5, {}, null, undefined].forEach(async (data) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /""data""|""buffer""/
  };
  const filename = join(tmpdir.path, 'append-invalid-data.txt');

  assert.throws(
    () => fs.appendFile(filename, data, common.mustNotCall()),
    errObj
  );

  assert.throws(
    () => fs.appendFileSync(filename, data),
    errObj
  );

  await assert.rejects(
    fs.promises.appendFile(filename, data),
    errObj
  );
  // The filename shouldn't exist if throwing error.
  assert.throws(
    () => fs.statSync(filename),
    {
      code: 'ENOENT',
      message: /no such file or directory/
    }
  );
});

// Test that appendFile accepts file descriptors (callback API).
{
  const filename = join(tmpdir.path, 'append-descriptors.txt');
  fs.writeFileSync(filename, currentFileData);

  fs.open(filename, 'a+', common.mustSucceed((fd) => {
    fs.appendFile(fd, s, common.mustSucceed(() => {
      fs.close(fd, common.mustSucceed(() => {
        fs.readFile(filename, common.mustSucceed((buffer) => {
          assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                             buffer.length);
        }));
      }));
    }));
  }));
}

// Test that appendFile accepts file descriptors (promises API).
{
  const filename = join(tmpdir.path, 'append-descriptors-promises.txt');
  fs.writeFileSync(filename, currentFileData);

  let fd;
  fs.promises.open(filename, 'a+')
    .then(common.mustCall((fileDescriptor) => {
      fd = fileDescriptor;
      return fs.promises.appendFile(fd, s);
    }))
    .then(common.mustCall(() => fd.close()))
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then(common.mustCall((buffer) => {
      assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                         buffer.length);
    }))
    .catch(throwNextTick);
}

assert.throws(
  () => fs.appendFile(join(tmpdir.path, 'append6.txt'), console.log),
  { code: 'ERR_INVALID_ARG_TYPE' });


```"
"```javascript:test\crypto\test-crypto-pbkdf2.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

function runPBKDF2(password, salt, iterations, keylen, hash) {
  const syncResult =
    crypto.pbkdf2Sync(password, salt, iterations, keylen, hash);

  crypto.pbkdf2(password, salt, iterations, keylen, hash,
                common.mustSucceed((asyncResult) => {
                  assert.deepStrictEqual(asyncResult, syncResult);
                }));

  return syncResult;
}

function testPBKDF2(password, salt, iterations, keylen, expected, encoding) {
  const actual = runPBKDF2(password, salt, iterations, keylen, 'sha256');
  assert.strictEqual(actual.toString(encoding || 'latin1'), expected);
}

//
// Test PBKDF2 with RFC 6070 test vectors (except #4)
//

testPBKDF2('password', 'salt', 1, 20,
           '\x12\x0f\xb6\xcf\xfc\xf8\xb3\x2c\x43\xe7\x22\x52' +
           '\x56\xc4\xf8\x37\xa8\x65\x48\xc9');

testPBKDF2('password', 'salt', 2, 20,
           '\xae\x4d\x0c\x95\xaf\x6b\x46\xd3\x2d\x0a\xdf\xf9' +
           '\x28\xf0\x6d\xd0\x2a\x30\x3f\x8e');

testPBKDF2('password', 'salt', 4096, 20,
           '\xc5\xe4\x78\xd5\x92\x88\xc8\x41\xaa\x53\x0d\xb6' +
           '\x84\x5c\x4c\x8d\x96\x28\x93\xa0');

testPBKDF2('passwordPASSWORDpassword',
           'saltSALTsaltSALTsaltSALTsaltSALTsalt',
           4096,
           25,
           '\x34\x8c\x89\xdb\xcb\xd3\x2b\x2f\x32\xd8\x14\xb8\x11' +
           '\x6e\x84\xcf\x2b\x17\x34\x7e\xbc\x18\x00\x18\x1c');

testPBKDF2('pass\0word', 'sa\0lt', 4096, 16,
           '\x89\xb6\x9d\x05\x16\xf8\x29\x89\x3c\x69\x62\x26\x65' +
           '\x0a\x86\x87');

testPBKDF2('password', 'salt', 32, 32,
           '64c486c55d30d4c5a079b8823b7d7cb37ff0556f537da8410233bcec330ed956',
           'hex');

// Error path should not leak memory (check with valgrind).
assert.throws(
  () => crypto.pbkdf2('password', 'salt', 1, 20, 'sha1'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  }
);

for (const iterations of [-1, 0]) {
  assert.throws(
    () => crypto.pbkdf2Sync('password', 'salt', iterations, 20, 'sha1'),
    {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
    }
  );
}

['str', null, undefined, [], {}].forEach((notNumber) => {
  assert.throws(
    () => {
      crypto.pbkdf2Sync('password', 'salt', 1, notNumber, 'sha256');
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""keylen"" argument must be of type number.' +
               `${common.invalidArgTypeHelper(notNumber)}`
    });
});

[Infinity, -Infinity, NaN].forEach((input) => {
  assert.throws(
    () => {
      crypto.pbkdf2('password', 'salt', 1, input, 'sha256',
                    common.mustNotCall());
    }, {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""keylen"" is out of range. It ' +
               `must be an integer. Received ${input}`
    });
});

[-1, 4294967297].forEach((input) => {
  assert.throws(
    () => {
      crypto.pbkdf2('password', 'salt', 1, input, 'sha256',
                    common.mustNotCall());
    }, {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
    });
});

// Should not get FATAL ERROR with empty password and salt
// https://github.com/nodejs/node/issues/8571
crypto.pbkdf2('', '', 1, 32, 'sha256', common.mustSucceed());

assert.throws(
  () => crypto.pbkdf2('password', 'salt', 8, 8, common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""digest"" argument must be of type string. ' +
             'Received undefined'
  });

assert.throws(
  () => crypto.pbkdf2Sync('password', 'salt', 8, 8),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""digest"" argument must be of type string. ' +
             'Received undefined'
  });

assert.throws(
  () => crypto.pbkdf2Sync('password', 'salt', 8, 8, null),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""digest"" argument must be of type string. ' +
             'Received null'
  });
[1, {}, [], true, undefined, null].forEach((input) => {
  assert.throws(
    () => crypto.pbkdf2(input, 'salt', 8, 8, 'sha256', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );

  assert.throws(
    () => crypto.pbkdf2('pass', input, 8, 8, 'sha256', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );

  assert.throws(
    () => crypto.pbkdf2Sync(input, 'salt', 8, 8, 'sha256'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );

  assert.throws(
    () => crypto.pbkdf2Sync('pass', input, 8, 8, 'sha256'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );
});

['test', {}, [], true, undefined, null].forEach((i) => {
  const received = common.invalidArgTypeHelper(i);
  assert.throws(
    () => crypto.pbkdf2('pass', 'salt', i, 8, 'sha256', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""iterations"" argument must be of type number.${received}`
    }
  );

  assert.throws(
    () => crypto.pbkdf2Sync('pass', 'salt', i, 8, 'sha256'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""iterations"" argument must be of type number.${received}`
    }
  );
});

// Any TypedArray should work for password and salt.
for (const SomeArray of [Uint8Array, Uint16Array, Uint32Array, Float32Array,
                         Float64Array, ArrayBuffer, SharedArrayBuffer]) {
  runPBKDF2(new SomeArray(10), 'salt', 8, 8, 'sha256');
  runPBKDF2('pass', new SomeArray(10), 8, 8, 'sha256');
}

assert.throws(
  () => crypto.pbkdf2('pass', 'salt', 8, 8, 'md55', common.mustNotCall()),
  {
    code: 'ERR_CRYPTO_INVALID_DIGEST',
    name: 'TypeError',
    message: 'Invalid digest: md55'
  }
);

assert.throws(
  () => crypto.pbkdf2Sync('pass', 'salt', 8, 8, 'md55'),
  {
    code: 'ERR_CRYPTO_INVALID_DIGEST',
    name: 'TypeError',
    message: 'Invalid digest: md55'
  }
);

/*if (!common.hasOpenSSL3) {
  const kNotPBKDF2Supported = ['shake128', 'shake256'];
  crypto.getHashes()
    .filter((hash) => !kNotPBKDF2Supported.includes(hash))
    .forEach((hash) => {
      runPBKDF2(new Uint8Array(10), 'salt', 8, 8, hash);
    });
}*/

{
  // This should not crash.
  assert.throws(
    () => crypto.pbkdf2Sync('1', '2', 1, 1, '%'),
    {
      code: 'ERR_CRYPTO_INVALID_DIGEST',
      name: 'TypeError',
      message: 'Invalid digest: %'
    }
  );
}

```"
"```javascript:modules\internal_binding\util.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// This module ports:
// - https://github.com/nodejs/node/blob/master/src/util-inl.h
// - https://github.com/nodejs/node/blob/master/src/util.cc
// - https://github.com/nodejs/node/blob/master/src/util.h

/**
 * 
 * @param {string} msg 
 * @return {never}
 */
export function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : ""Not implemented"";
    throw new Error(message);
}

/**
 * 
 * @param {number} _fd 
 * @return {string}
 */
export function guessHandleType(_fd) {
    notImplemented(""util.guessHandleType"");
}

export const ALL_PROPERTIES = 0;
export const ONLY_WRITABLE = 1;
export const ONLY_ENUMERABLE = 2;
export const ONLY_CONFIGURABLE = 4;
export const ONLY_ENUM_WRITABLE = 6;
export const SKIP_STRINGS = 8;
export const SKIP_SYMBOLS = 16;

/**
 * Efficiently determine whether the provided property key is numeric
 * (and thus could be an array indexer) or not.
 *
 * Always returns true for values of type `'number'`.
 *
 * Otherwise, only returns true for strings that consist only of positive integers.
 *
 * Results are cached.
 * 
 * @type {Record<string, boolean>}
 */
const isNumericLookup = {};

/**
 * 
 * @param {unknown} value 
 * @returns {boolean}
 */
export function isArrayIndex(value) {
    switch (typeof value) {
        case ""number"":
            return value >= 0 && (value | 0) === value;
        case ""string"": {
            const result = isNumericLookup[value];
            if (result !== void 0) {
                return result;
            }
            const length = value.length;
            if (length === 0) {
                return isNumericLookup[value] = false;
            }
            let ch = 0;
            let i = 0;
            for (; i < length; ++i) {
                ch = value.charCodeAt(i);
                if (
                    i === 0 && ch === 0x30 && length > 1 /* must not start with 0 */ ||
                    ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */
                ) {
                    return isNumericLookup[value] = false;
                }
            }
            return isNumericLookup[value] = true;
        }
        default:
            return false;
    }
}

/**
 * 
 * @param {object} obj 
 * @param {number} filter 
 * @returns {(string | symbol)[]}
 */
export function getOwnNonIndexProperties(
    // deno-lint-ignore ban-types
    obj,
    filter,
) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj),
    ];

    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k) => !isArrayIndex(k));
    }

    if (filter === ALL_PROPERTIES) {
        return allProperties;
    }

    /**
     * @type {(string | symbol)[]}
     */
    const result = [];
    for (const key of allProperties) {
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & ONLY_WRITABLE && !desc.writable) {
            continue;
        }
        if (filter & ONLY_ENUMERABLE && !desc.enumerable) {
            continue;
        }
        if (filter & ONLY_CONFIGURABLE && !desc.configurable) {
            continue;
        }
        if (filter & SKIP_STRINGS && typeof key === ""string"") {
            continue;
        }
        if (filter & SKIP_SYMBOLS && typeof key === ""symbol"") {
            continue;
        }
        result.push(key);
    }
    return result;
}

```"
"```javascript:test\fs\test-fs-stat.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

fs.stat('.', common.mustSucceed(function(stats) {
  assert.ok(stats.mtime instanceof Date);
  assert.ok(Object.prototype.hasOwnProperty.call(stats, 'blksize'));
  assert.ok(Object.prototype.hasOwnProperty.call(stats, 'blocks'));
  // Confirm that we are not running in the context of the internal binding
  // layer.
  // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
  assert.strictEqual(this, undefined);
}));

fs.lstat('.', common.mustSucceed(function(stats) {
  assert.ok(stats.mtime instanceof Date);
  // Confirm that we are not running in the context of the internal binding
  // layer.
  // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
  assert.strictEqual(this, undefined);
}));

// fstat
fs.open('.', 'r', undefined, common.mustSucceed(function(fd) {
  assert.ok(fd);

  fs.fstat(-0, common.mustSucceed());

  fs.fstat(fd, common.mustSucceed(function(stats) {
    assert.ok(stats.mtime instanceof Date);
    fs.close(fd, assert.ifError);
    // Confirm that we are not running in the context of the internal binding
    // layer.
    // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
    assert.strictEqual(this, undefined);
  }));

  // Confirm that we are not running in the context of the internal binding
  // layer.
  // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
  assert.strictEqual(this, undefined);
}));

// fstatSync
fs.open('.', 'r', undefined, common.mustCall(function(err, fd) {
  const stats = fs.fstatSync(fd);
  assert.ok(stats.mtime instanceof Date);
  fs.close(fd, common.mustSucceed());
}));

fs.stat(__filename, common.mustSucceed((s) => {
  assert.strictEqual(s.isDirectory(), false);
  assert.strictEqual(s.isFile(), true);
  assert.strictEqual(s.isSocket(), false);
  assert.strictEqual(s.isBlockDevice(), false);
  assert.strictEqual(s.isCharacterDevice(), false);
  assert.strictEqual(s.isFIFO(), false);
  assert.strictEqual(s.isSymbolicLink(), false);

  const jsonString = JSON.stringify(s);
  const parsed = JSON.parse(jsonString);
  [
    'dev', 'mode', 'nlink', 'uid',
    'gid', 'rdev', 'blksize', 'ino', 'size', 'blocks',
    'atime', 'mtime', 'ctime', 'birthtime',
    'atimeMs', 'mtimeMs', 'ctimeMs', 'birthtimeMs',
  ].forEach(function(k) {
    assert.ok(k in s, `${k} should be in Stats`);
    assert.notStrictEqual(s[k], undefined, `${k} should not be undefined`);
    assert.notStrictEqual(s[k], null, `${k} should not be null`);
    assert.notStrictEqual(parsed[k], undefined, `${k} should not be undefined`);
    assert.notStrictEqual(parsed[k], null, `${k} should not be null`);
  });
  [
    'dev', 'mode', 'nlink', 'uid', 'gid', 'rdev', 'blksize', 'ino', 'size',
    'blocks', 'atimeMs', 'mtimeMs', 'ctimeMs', 'birthtimeMs',
  ].forEach((k) => {
    assert.strictEqual(typeof s[k], 'number', `${k} should be a number`);
    assert.strictEqual(typeof parsed[k], 'number', `${k} should be a number`);
  });
  ['atime', 'mtime', 'ctime', 'birthtime'].forEach((k) => {
    assert.ok(s[k] instanceof Date, `${k} should be a Date`);
    assert.strictEqual(typeof parsed[k], 'string', `${k} should be a string`);
  });
}));

['', false, null, undefined, {}, []].forEach((input) => {
  ['fstat', 'fstatSync'].forEach((fnName) => {
    assert.throws(
      () => fs[fnName](input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });
});

[false, 1, {}, [], null, undefined].forEach((input) => {
  assert.throws(
    () => fs.lstat(input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.lstatSync(input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.stat(input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.statSync(input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Should not throw an error
fs.stat(__filename, undefined, common.mustCall(() => {}));

fs.open(__filename, 'r', undefined, common.mustCall((err, fd) => {
  // Should not throw an error
  fs.fstat(fd, undefined, common.mustCall(() => {}));
}));

// Should not throw an error
fs.lstat(__filename, undefined, common.mustCall(() => {}));

```"
"```javascript:test\crypto\test-crypto-dh.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
const dh1 = crypto.createDiffieHellman(size);
const p1 = dh1.getPrime('buffer');
const dh2 = crypto.createDiffieHellman(p1, 'buffer');
const key1 = dh1.generateKeys();
const key2 = dh2.generateKeys('hex');
const secret1 = dh1.computeSecret(key2, 'hex', 'base64');
const secret2 = dh2.computeSecret(key1, 'latin1', 'buffer');

// Test Diffie-Hellman with two parties sharing a secret,
// using various encodings as we go along
assert.strictEqual(secret2.toString('base64'), secret1);
assert.strictEqual(dh1.verifyError, 0);
assert.strictEqual(dh2.verifyError, 0);

// https://github.com/nodejs/node/issues/32738
// XXX(bnoordhuis) validateInt32() throwing ERR_OUT_OF_RANGE and RangeError
// instead of ERR_INVALID_ARG_TYPE and TypeError is questionable, IMO.
assert.throws(() => crypto.createDiffieHellman(13.37), {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""sizeOrKey"" is out of range. ' +
           'It must be an integer. Received 13.37',
});

assert.throws(() => crypto.createDiffieHellman('abcdef', 13.37), {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""generator"" is out of range. ' +
           'It must be an integer. Received 13.37',
});

for (const bits of [-1, 0, 1]) {
  if (common.hasOpenSSL3) {
    assert.throws(() => crypto.createDiffieHellman(bits), {
      code: 'ERR_OSSL_DH_MODULUS_TOO_SMALL',
      name: 'Error',
      message: /modulus too small/,
    });
  } else {
    assert.throws(() => crypto.createDiffieHellman(bits), {
      code: 'ERR_OSSL_BN_BITS_TOO_SMALL',
      name: 'Error',
      message: /bits too small/,
    });
  }
}

// Through a fluke of history, g=0 defaults to DH_GENERATOR (2).
{
  const g = 0;
  crypto.createDiffieHellman('abcdef', g);
  crypto.createDiffieHellman('abcdef', 'hex', g);
}

for (const g of [-1, 1]) {
  const ex = {
    code: 'ERR_OSSL_DH_BAD_GENERATOR',
    name: 'Error',
    message: /bad generator/,
  };
  assert.throws(() => crypto.createDiffieHellman('abcdef', g), ex);
  assert.throws(() => crypto.createDiffieHellman('abcdef', 'hex', g), ex);
}

crypto.createDiffieHellman('abcdef', Buffer.from([2]));  // OK

for (const g of [Buffer.from([]),
                 Buffer.from([0]),
                 Buffer.from([1])]) {
  const ex = {
    code: 'ERR_OSSL_DH_BAD_GENERATOR',
    name: 'Error',
    message: /bad generator/,
  };
  assert.throws(() => crypto.createDiffieHellman('abcdef', g), ex);
  assert.throws(() => crypto.createDiffieHellman('abcdef', 'hex', g), ex);
}

[
  [0x1, 0x2],
  () => { },
  /abc/,
  {},
].forEach((input) => {
  assert.throws(
    () => crypto.createDiffieHellman(input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );
});

// Create ""another dh1"" using generated keys from dh1,
// and compute secret again
const dh3 = crypto.createDiffieHellman(p1, 'buffer');
const privkey1 = dh1.getPrivateKey();
dh3.setPublicKey(key1);
dh3.setPrivateKey(privkey1);

assert.deepStrictEqual(dh1.getPrime(), dh3.getPrime());
assert.deepStrictEqual(dh1.getGenerator(), dh3.getGenerator());
assert.deepStrictEqual(dh1.getPublicKey(), dh3.getPublicKey());
assert.deepStrictEqual(dh1.getPrivateKey(), dh3.getPrivateKey());
assert.strictEqual(dh3.verifyError, 0);

const secret3 = dh3.computeSecret(key2, 'hex', 'base64');

assert.strictEqual(secret1, secret3);

// computeSecret works without a public key set at all.
const dh4 = crypto.createDiffieHellman(p1, 'buffer');
dh4.setPrivateKey(privkey1);

assert.deepStrictEqual(dh1.getPrime(), dh4.getPrime());
assert.deepStrictEqual(dh1.getGenerator(), dh4.getGenerator());
assert.deepStrictEqual(dh1.getPrivateKey(), dh4.getPrivateKey());
assert.strictEqual(dh4.verifyError, 0);

const secret4 = dh4.computeSecret(key2, 'hex', 'base64');

assert.strictEqual(secret1, secret4);

let wrongBlockLength;
if (common.hasOpenSSL3) {
  wrongBlockLength = {
    message: 'error:1C80006B:Provider routines::wrong final block length',
    code: 'ERR_OSSL_WRONG_FINAL_BLOCK_LENGTH',
    library: 'Provider routines',
    reason: 'wrong final block length'
  };
} else {
  wrongBlockLength = {
    message: 'error:0606506D:digital envelope' +
      ' routines:EVP_DecryptFinal_ex:wrong final block length',
    code: 'ERR_OSSL_EVP_WRONG_FINAL_BLOCK_LENGTH',
    library: 'digital envelope routines',
    reason: 'wrong final block length'
  };
}

// Run this one twice to make sure that the dh3 clears its error properly
{
  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
  assert.throws(() => {
    c.final('utf8');
  }, wrongBlockLength);
}

{
  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
  assert.throws(() => {
    c.final('utf8');
  }, wrongBlockLength);
}

assert.throws(() => {
  dh3.computeSecret('');
}, { message: common.hasOpenSSL3 ?
  'error:02800080:Diffie-Hellman routines::invalid secret' :
  'Supplied key is too small' });

// Invalid test: curve argument is undefined
assert.throws(
  () => crypto.createECDH(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""curve"" argument must be of type string. ' +
            'Received undefined'
  });

assert.throws(
  function() {
    crypto.getDiffieHellman('unknown-group');
  },
  {
    name: 'Error',
    code: 'ERR_CRYPTO_UNKNOWN_DH_GROUP',
    message: 'Unknown DH group'
  },
  'crypto.getDiffieHellman(\'unknown-group\') ' +
  'failed to throw the expected error.'
);

assert.throws(
  () => crypto.createDiffieHellman('', true),
  {
    code: 'ERR_INVALID_ARG_TYPE'
  }
);
[true, Symbol(), {}, () => {}, []].forEach((generator) => assert.throws(
  () => crypto.createDiffieHellman('', 'base64', generator),
  { code: 'ERR_INVALID_ARG_TYPE' }
));

```"
"```javascript:test\fs\test-fs-write-buffer.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
const expected = Buffer.from('hello');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// fs.write with all parameters provided:
{
  const filename = path.join(tmpdir.path, 'write1.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    fs.write(fd, expected, 0, expected.length, null, cb);
  }));
}

// fs.write with a buffer, without the length parameter:
{
  const filename = path.join(tmpdir.path, 'write2.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, 2);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, 'lo');
    });

    fs.write(fd, Buffer.from('hello'), 3, cb);
  }));
}

// fs.write with a buffer, without the offset and length parameters:
{
  const filename = path.join(tmpdir.path, 'write3.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.deepStrictEqual(expected.toString(), found);
    });

    fs.write(fd, expected, cb);
  }));
}

// fs.write with the offset passed as undefined followed by the callback:
{
  const filename = path.join(tmpdir.path, 'write4.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.deepStrictEqual(expected.toString(), found);
    });

    fs.write(fd, expected, undefined, cb);
  }));
}

// fs.write with offset and length passed as undefined followed by the callback:
{
  const filename = path.join(tmpdir.path, 'write5.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    fs.write(fd, expected, undefined, undefined, cb);
  }));
}

// fs.write with a Uint8Array, without the offset and length parameters:
{
  const filename = path.join(tmpdir.path, 'write6.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    fs.write(fd, Uint8Array.from(expected), cb);
  }));
}

// fs.write with invalid offset type
{
  const filename = path.join(tmpdir.path, 'write7.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    assert.throws(() => {
      fs.write(fd,
               Buffer.from('abcd'),
               NaN,
               expected.length,
               0,
               common.mustNotCall());
    }, {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""offset"" is out of range. ' +
               'It must be an integer. Received NaN'
    });

    fs.closeSync(fd);
  }));
}

// fs.write with a DataView, without the offset and length parameters:
{
  const filename = path.join(tmpdir.path, 'write8.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    const uint8 = Uint8Array.from(expected);
    fs.write(fd, new DataView(uint8.buffer), cb);
  }));
}

```"
"```javascript:modules\util.js
import { promisify, deprecate } from ""./internal/util.js"";
import { debuglog } from ""./internal/util/debuglog.js"";
import types from ""util/types"";
import { Buffer } from ""buffer"";
import { ERR_INVALID_ARG_TYPE } from ""./internal/errors.js"";
import * as encoding from 'encoding';

export const debuglog = debuglog
export const promisify = promisify;
export const deprecate = deprecate;

class NodeFalsyValueRejectionError extends Error {
    reason;
    code = ""ERR_FALSY_VALUE_REJECTION"";
    constructor(reason) {
        super(""Promise was rejected with falsy value"");
        this.reason = reason;
    }
}

class NodeInvalidArgTypeError extends TypeError {
    code = ""ERR_INVALID_ARG_TYPE"";
    constructor(argumentName) {
        super(`The ${argumentName} argument must be of type function.`);
    }
}

function callbackify(original) {
    if (typeof original !== ""function"") {
        throw new NodeInvalidArgTypeError('""original""');
    }

    const callbackified = function (_this, ...args) {
        const maybeCb = args.pop();
        if (typeof maybeCb !== ""function"") {
            throw new NodeInvalidArgTypeError(""last"");
        }
        const cb = (...args) => {
            maybeCb.apply(_this, args);
        };
        original.apply(_this, args).then(
            (ret) => {
                nextTick(cb.bind(_this, null, ret));
            },
            (rej) => {
                rej = rej || new NodeFalsyValueRejectionError(rej);
                nextTick(cb.bind(_this, rej));
            },
        );
    };

    const descriptors = Object.getOwnPropertyDescriptors(original);
    // It is possible to manipulate a functions `length` or `name` property. This
    // guards against the manipulation.
    if (typeof descriptors.length.value === ""number"") {
        descriptors.length.value++;
    }
    if (typeof descriptors.name.value === ""string"") {
        descriptors.name.value += ""Callbackified"";
    }
    Object.defineProperties(callbackified, descriptors);
    return callbackified;
}

export function isArray(value) {
    return Array.isArray(value);
}

export function isBoolean(value) {
    return typeof value === ""boolean"" || value instanceof Boolean;
}

export function isNull(value) {
    return value === null;
}

export function isNullOrUndefined(value) {
    return value === null || value === undefined;
}

export function isNumber(value) {
    return typeof value === ""number"" || value instanceof Number;
}

export function isString(value) {
    return typeof value === ""string"" || value instanceof String;
}

export function isSymbol(value) {
    return typeof value === ""symbol"";
}

export function isUndefined(value) {
    return value === undefined;
}

export function isObject(value) {
    return value !== null && typeof value === ""object"";
}

export function isError(e) {
    return e instanceof Error;
}

export function isFunction(value) {
    return typeof value === ""function"";
}

export function isRegExp(value) {
    return types.isRegExp(value);
}

export function isDate(value) {
    return types.isDate(value);
}

export function isPrimitive(value) {
    return (
        value === null || (typeof value !== ""object"" && typeof value !== ""function"")
    );
}

export function isBuffer(value) {
    return Buffer.isBuffer(value);
}

export function _extend(target, source) {
    // Don't do anything if source isn't an object
    if (source === null || typeof source !== ""object"") return target;

    const keys = Object.keys(source);
    let i = keys.length;
    while (i--) {
        target[keys[i]] = source[keys[i]];
    }
    return target;
}

export function inherits(ctor, superCtor) {
    if (ctor === undefined || ctor === null) {
        throw new ERR_INVALID_ARG_TYPE(""ctor"", ""Function"", ctor);
    }

    if (superCtor === undefined || superCtor === null) {
        throw new ERR_INVALID_ARG_TYPE(""superCtor"", ""Function"", superCtor);
    }

    if (superCtor.prototype === undefined) {
        throw new ERR_INVALID_ARG_TYPE(
            ""superCtor.prototype"",
            ""Object"",
            superCtor.prototype,
        );
    }
    Object.defineProperty(ctor, ""super_"", {
        value: superCtor,
        writable: true,
        configurable: true,
    });
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}

export const TextDecoder = encoding.TextDecoder;
export const TextEncoder = encoding.TextEncoder;

function pad(n) {
    return n.toString().padStart(2, ""0"");
}

const months = [
    ""Jan"",
    ""Feb"",
    ""Mar"",
    ""Apr"",
    ""May"",
    ""Jun"",
    ""Jul"",
    ""Aug"",
    ""Sep"",
    ""Oct"",
    ""Nov"",
    ""Dec"",
];

function timestamp() {
    const d = new Date();
    const t = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds()),
    ].join("":"");
    return `${(d.getDate())} ${months[(d).getMonth()]} ${t}`;
}

export function log(...args) {
    console.log(timestamp(), '-', ...args);
}

export default {
    isArray,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isSymbol,
    isUndefined,
    isObject,
    isError,
    isFunction,
    isRegExp,
    isDate,
    isPrimitive,
    isBuffer,
    _extend,
    deprecate,
    callbackify,
    promisify,
    inherits,
    types,
    TextDecoder,
    TextEncoder,
    log,
    debuglog,
};

```"
"```javascript:test\fs\test-fs-promises-file-handle-writeFile.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.writeFile method.

import fs from 'fs';
const { open, writeFile } = fs.promises;
import path from 'path';
import { Readable } from 'stream';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateWriteFile() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-write-file2.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  try {
    const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

    await fileHandle.writeFile(buffer);
    const readFileData = fs.readFileSync(filePathForHandle);
    assert.deepStrictEqual(buffer, readFileData);
  } finally {
    await fileHandle.close();
  }
}

// Signal aborted while writing file
async function doWriteAndCancel() {
  const filePathForHandle = path.resolve(tmpDir, 'dogs-running.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  try {
    const buffer = Buffer.from('dogs running'.repeat(512 * 1024), 'utf8');
    const controller = new AbortController();
    const { signal } = controller;
    process.nextTick(() => controller.abort());
    await assert.rejects(writeFile(fileHandle, buffer, { signal }), {
      name: 'AbortError'
    });
  } finally {
    await fileHandle.close();
  }
}

const dest = path.resolve(tmpDir, 'tmp.txt');
const otherDest = path.resolve(tmpDir, 'tmp-2.txt');
const stream = Readable.from(['a', 'b', 'c']);
const stream2 = Readable.from(['��mlaut', ' ', 'sechzig']);
const iterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};
function iterableWith(value) {
  return {
    *[Symbol.iterator]() {
      yield value;
    }
  };
}
const bufferIterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield Buffer.from('a');
    yield Buffer.from('b');
    yield Buffer.from('c');
  }
};
const asyncIterable = {
  expected: 'abc',
  async* [Symbol.asyncIterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};

async function doWriteStream() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(stream);
    const expected = 'abc';
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteStreamWithCancel() {
  const controller = new AbortController();
  const { signal } = controller;
  process.nextTick(() => controller.abort());
  const fileHandle = await open(otherDest, 'w+');
  try {
    await assert.rejects(
      fileHandle.writeFile(stream, { signal }),
      { name: 'AbortError' }
    );
  } finally {
    await fileHandle.close();
  }
}

async function doWriteIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(iterable);
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, iterable.expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteInvalidIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await Promise.all(
      [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
        assert.rejects(
          fileHandle.writeFile(iterableWith(value)),
          { code: 'ERR_INVALID_ARG_TYPE' }
        )
      )
    );
  } finally {
    await fileHandle.close();
  }
}

async function doWriteIterableWithEncoding() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(stream2, 'latin1');
    const expected = '��mlaut sechzig';
    const data = fs.readFileSync(dest, 'latin1');
    assert.deepStrictEqual(data, expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteBufferIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(bufferIterable);
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, bufferIterable.expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteAsyncIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(asyncIterable);
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, asyncIterable.expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteInvalidValues() {
  const fileHandle = await open(dest, 'w+');
  try {
    await Promise.all(
      [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
        assert.rejects(
          fileHandle.writeFile(value),
          { code: 'ERR_INVALID_ARG_TYPE' }
        )
      )
    );
  } finally {
    await fileHandle.close();
  }
}

(async () => {
  await validateWriteFile();
  //await doWriteAndCancel();
  await doWriteStream();
  //await doWriteStreamWithCancel();
  await doWriteIterable();
  await doWriteInvalidIterable();
  await doWriteIterableWithEncoding();
  await doWriteBufferIterable();
  await doWriteAsyncIterable();
  await doWriteInvalidValues();
})().then(common.mustCall());

```"
"```javascript:test\crypto\test-crypto-x509.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const {
  X509Certificate,
  createPrivateKey,
} = require('crypto');

const {
  isX509Certificate
} = require('internal/crypto/x509');

const assert = require('assert');
const fixtures = require('../common/fixtures');
const { readFileSync } = require('fs');

const cert = readFileSync(fixtures.path('keys', 'agent1-cert.pem'));
const key = readFileSync(fixtures.path('keys', 'agent1-key.pem'));
const ca = readFileSync(fixtures.path('keys', 'ca1-cert.pem'));

const privateKey = createPrivateKey(key);

[1, {}, false, null].forEach((i) => {
  assert.throws(() => new X509Certificate(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

const subjectCheck = `C=US
ST=CA
L=SF
O=Joyent
OU=Node.js
CN=agent1
emailAddress=ry@tinyclouds.org`;

const issuerCheck = `C=US
ST=CA
L=SF
O=Joyent
OU=Node.js
CN=ca1
emailAddress=ry@tinyclouds.org`;

let infoAccessCheck = `OCSP - URI:http://ocsp.nodejs.org/
CA Issuers - URI:http://ca.nodejs.org/ca.cert`;
if (!common.hasOpenSSL3)
  infoAccessCheck += '\n';

const der = Buffer.from(
  '308202d830820241a003020102020900ecc9b856270da9a830' +
  '0d06092a864886f70d01010b0500307a310b30090603550406' +
  '13025553310b300906035504080c024341310b300906035504' +
  '070c025346310f300d060355040a0c064a6f79656e74311030' +
  '0e060355040b0c074e6f64652e6a73310c300a06035504030c' +
  '036361313120301e06092a864886f70d010901161172794074' +
  '696e79636c6f7564732e6f72673020170d3138313131363138' +
  '343232315a180f32323932303833303138343232315a307d31' +
  '0b3009060355040613025553310b300906035504080c024341' +
  '310b300906035504070c025346310f300d060355040a0c064a' +
  '6f79656e743110300e060355040b0c074e6f64652e6a73310f' +
  '300d06035504030c066167656e74313120301e06092a864886' +
  'f70d010901161172794074696e79636c6f7564732e6f726730' +
  '819f300d06092a864886f70d010101050003818d0030818902' +
  '818100ef5440701637e28abb038e5641f828d834c342a9d25e' +
  'dbb86a2bf6fbd809cb8e037a98b71708e001242e4deb54c616' +
  '4885f599dd87a23215745955be20417e33c4d0d1b80c9da3de' +
  '419a2607195d2fb75657b0bbfb5eb7d0bba5122d1b6964c7b5' +
  '70d50b8ec001eeb68dfb584437508f3129928d673b30a3e0bf' +
  '4f50609e63710203010001a361305f305d06082b0601050507' +
  '01010451304f302306082b060105050730018617687474703a' +
  '2f2f6f6373702e6e6f64656a732e6f72672f302806082b0601' +
  '0505073002861c687474703a2f2f63612e6e6f64656a732e6f' +
  '72672f63612e63657274300d06092a864886f70d01010b0500' +
  '038181007acabf1d99e1fb05edbdd54608886dd6c509fc5820' +
  '2be8274f8139b60f8ea219666f7eff9737e92a732b318ef423' +
  '7da94123dcac4f9a28e76fe663b26d42482ac6d66d380bbdfe' +
  '0230083e743e7966671752b82f692e1034e9bfc9d0cd829888' +
  '6c6c996e7c3d231e02ad5399a170b525b74f11d7ed13a7a815' +
  'f4b974253a8d66', 'hex');

{
  const x509 = new X509Certificate(cert);

  assert(isX509Certificate(x509));

  assert(!x509.ca);
  assert.strictEqual(x509.subject, subjectCheck);
  assert.strictEqual(x509.subjectAltName, undefined);
  assert.strictEqual(x509.issuer, issuerCheck);
  assert.strictEqual(x509.infoAccess, infoAccessCheck);
  assert.strictEqual(x509.validFrom, 'Nov 16 18:42:21 2018 GMT');
  assert.strictEqual(x509.validTo, 'Aug 30 18:42:21 2292 GMT');
  assert.strictEqual(
    x509.fingerprint,
    'D7:FD:F6:42:92:A8:83:51:8E:80:48:62:66:DA:85:C2:EE:A6:A1:CD');
  assert.strictEqual(
    x509.fingerprint256,
    'B0:BE:46:49:B8:29:63:E0:6F:63:C8:8A:57:9C:3F:9B:72:C6:F5:89:E3:0D:' +
    '84:AC:5B:08:9A:20:89:B6:8F:D6'
  );
  assert.strictEqual(
    x509.fingerprint512,
    'D0:05:01:82:2C:D8:09:BE:27:94:E7:83:F1:88:BC:7A:8B:D0:39:97:54:B6:' +
    'D0:B4:46:5B:DE:13:5B:68:86:B6:F2:A8:95:22:D5:6E:8B:35:DA:89:29:CA:' +
    'A3:06:C5:CE:43:C1:7F:2D:7E:5F:44:A5:EE:A3:CB:97:05:A3:E3:68'
  );
  assert.strictEqual(x509.keyUsage, undefined);
  assert.strictEqual(x509.serialNumber, 'ECC9B856270DA9A8');

  assert.deepStrictEqual(x509.raw, der);

  assert(x509.publicKey);
  assert.strictEqual(x509.publicKey.type, 'public');

  assert.strictEqual(x509.toString().replaceAll('\r\n', '\n'),
                     cert.toString().replaceAll('\r\n', '\n'));
  assert.strictEqual(x509.toJSON(), x509.toString());

  assert(x509.checkPrivateKey(privateKey));
  assert.throws(() => x509.checkPrivateKey(x509.publicKey), {
    code: 'ERR_INVALID_ARG_VALUE'
  });

  assert.strictEqual(x509.checkIP('127.0.0.1'), undefined);
  assert.strictEqual(x509.checkIP('::'), undefined);
  assert.strictEqual(x509.checkHost('agent1'), 'agent1');
  assert.strictEqual(x509.checkHost('agent2'), undefined);
  assert.strictEqual(x509.checkEmail('ry@tinyclouds.org'), 'ry@tinyclouds.org');
  assert.strictEqual(x509.checkEmail('sally@example.com'), undefined);
  assert.throws(() => x509.checkHost('agent\x001'), {
    code: 'ERR_INVALID_ARG_VALUE'
  });
  assert.throws(() => x509.checkIP('[::]'), {
    code: 'ERR_INVALID_ARG_VALUE'
  });
  assert.throws(() => x509.checkEmail('not\x00hing'), {
    code: 'ERR_INVALID_ARG_VALUE'
  });

  [1, false, null].forEach((i) => {
    assert.throws(() => x509.checkHost('agent1', i), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
    assert.throws(() => x509.checkHost('agent1', { subject: i }), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  });

  [
    'wildcards',
    'partialWildcards',
    'multiLabelWildcards',
    'singleLabelSubdomains',
  ].forEach((key) => {
    [1, '', null, {}].forEach((i) => {
      assert.throws(() => x509.checkHost('agent1', { [key]: i }), {
        code: 'ERR_INVALID_ARG_TYPE'
      });
    });
  });

  const ca_cert = new X509Certificate(ca);

  assert(x509.checkIssued(ca_cert));
  assert(!x509.checkIssued(x509));
  assert(x509.verify(ca_cert.publicKey));
  assert(!x509.verify(x509.publicKey));

  assert.throws(() => x509.checkIssued({}), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.checkIssued(''), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.verify({}), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.verify(''), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.verify(privateKey), {
    code: 'ERR_INVALID_ARG_VALUE'
  });

  // X509Certificate can be cloned via MessageChannel/MessagePort
  const mc = new MessageChannel();
  mc.port1.onmessage = common.mustCall(({ data }) => {
    assert(isX509Certificate(data));
    assert.deepStrictEqual(data.raw, x509.raw);
    mc.port1.close();
  });
  mc.port2.postMessage(x509);

  // Verify that legacy encoding works
  const legacyObjectCheck = {
    subject: Object.assign(Object.create(null), {
      C: 'US',
      ST: 'CA',
      L: 'SF',
      O: 'Joyent',
      OU: 'Node.js',
      CN: 'agent1',
      emailAddress: 'ry@tinyclouds.org',
    }),
    issuer: Object.assign(Object.create(null), {
      C: 'US',
      ST: 'CA',
      L: 'SF',
      O: 'Joyent',
      OU: 'Node.js',
      CN: 'ca1',
      emailAddress: 'ry@tinyclouds.org',
    }),
    infoAccess: Object.assign(Object.create(null), {
      'OCSP - URI': ['http://ocsp.nodejs.org/'],
      'CA Issuers - URI': ['http://ca.nodejs.org/ca.cert']
    }),
    modulus: 'EF5440701637E28ABB038E5641F828D834C342A9D25EDBB86A2BF' +
             '6FBD809CB8E037A98B71708E001242E4DEB54C6164885F599DD87' +
             'A23215745955BE20417E33C4D0D1B80C9DA3DE419A2607195D2FB' +
             '75657B0BBFB5EB7D0BBA5122D1B6964C7B570D50B8EC001EEB68D' +
             'FB584437508F3129928D673B30A3E0BF4F50609E6371',
    bits: 1024,
    exponent: '0x10001',
    valid_from: 'Nov 16 18:42:21 2018 GMT',
    valid_to: 'Aug 30 18:42:21 2292 GMT',
    fingerprint: 'D7:FD:F6:42:92:A8:83:51:8E:80:48:62:66:DA:85:C2:EE:A6:A1:CD',
    fingerprint256:
      'B0:BE:46:49:B8:29:63:E0:6F:63:C8:8A:57:9C:3F:9B:72:' +
      'C6:F5:89:E3:0D:84:AC:5B:08:9A:20:89:B6:8F:D6',
    fingerprint512:
      'D0:05:01:82:2C:D8:09:BE:27:94:E7:83:F1:88:BC:7A:8B:' +
      'D0:39:97:54:B6:D0:B4:46:5B:DE:13:5B:68:86:B6:F2:A8:' +
      '95:22:D5:6E:8B:35:DA:89:29:CA:A3:06:C5:CE:43:C1:7F:' +
      '2D:7E:5F:44:A5:EE:A3:CB:97:05:A3:E3:68',
    serialNumber: 'ECC9B856270DA9A8'
  };

  const legacyObject = x509.toLegacyObject();

  assert.deepStrictEqual(legacyObject.raw, x509.raw);
  assert.deepStrictEqual(legacyObject.subject, legacyObjectCheck.subject);
  assert.deepStrictEqual(legacyObject.issuer, legacyObjectCheck.issuer);
  assert.deepStrictEqual(legacyObject.infoAccess, legacyObjectCheck.infoAccess);
  assert.strictEqual(legacyObject.modulus, legacyObjectCheck.modulus);
  assert.strictEqual(legacyObject.bits, legacyObjectCheck.bits);
  assert.strictEqual(legacyObject.exponent, legacyObjectCheck.exponent);
  assert.strictEqual(legacyObject.valid_from, legacyObjectCheck.valid_from);
  assert.strictEqual(legacyObject.valid_to, legacyObjectCheck.valid_to);
  assert.strictEqual(legacyObject.fingerprint, legacyObjectCheck.fingerprint);
  assert.strictEqual(
    legacyObject.fingerprint256,
    legacyObjectCheck.fingerprint256);
  assert.strictEqual(
    legacyObject.serialNumber,
    legacyObjectCheck.serialNumber);
}

```"
"```javascript:test\fs\test-fs-read-type.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');
const expected = 'xyz\n';

/* Undocumented api call way
// Error must be thrown with string
assert.throws(
  () => fs.read(fd, expected.length, 0, 'utf-8', common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""buffer"" argument must be an instance of Buffer, ' +
             'TypedArray, or DataView. Received type number (4)'
  }
);
*/
[true, null, undefined, () => {}, {}].forEach((value) => {
  assert.throws(() => {
    fs.read(value,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            0,
            common.mustNotCall());
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

assert.throws(() => {
  fs.read(fd,
          Buffer.allocUnsafe(expected.length),
          -1,
          expected.length,
          0,
          common.mustNotCall());
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
});

assert.throws(() => {
  fs.read(fd,
          Buffer.allocUnsafe(expected.length),
          NaN,
          expected.length,
          0,
          common.mustNotCall());
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""offset"" is out of range. It must be an integer. ' +
           'Received NaN'
});

assert.throws(() => {
  fs.read(fd,
          Buffer.allocUnsafe(expected.length),
          0,
          -1,
          0,
          common.mustNotCall());
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: /""length"".*-1/
});

[true, () => {}, {}, ''].forEach((value) => {
  assert.throws(() => {
    fs.read(fd,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            value,
            common.mustNotCall());
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

[0.5, 2 ** 53, 2n ** 63n].forEach((value) => {
  assert.throws(() => {
    fs.read(fd,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            value,
            common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError'
  });
});

fs.read(fd,
        Buffer.allocUnsafe(expected.length),
        0,
        expected.length,
        0n,
        common.mustSucceed());

fs.read(fd,
        Buffer.allocUnsafe(expected.length),
        0,
        expected.length,
        2n ** 53n - 1n,
        common.mustCall((err) => {
          if (err) {
            if (common.isIBMi)
              assert.strictEqual(err.code, 'EOVERFLOW');
            else
              assert.strictEqual(err.code, 'EFBIG');
          }
        }));
/* Undocumented api call way
assert.throws(
  () => fs.readSync(fd, expected.length, 0, 'utf-8'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""buffer"" argument must be an instance of Buffer, ' +
             'TypedArray, or DataView. Received type number (4)'
  }
);
*/
[true, null, undefined, () => {}, {}].forEach((value) => {
  assert.throws(() => {
    fs.readSync(value,
                Buffer.allocUnsafe(expected.length),
                0,
                expected.length,
                0);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              -1,
              expected.length,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              NaN,
              expected.length,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""offset"" is out of range. It must be an integer. ' +
           'Received NaN'
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              0,
              -1,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: /""length"".*-1/
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              0,
              expected.length + 1,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: /""length"".*5/
});

[true, () => {}, {}, ''].forEach((value) => {
  assert.throws(() => {
    fs.readSync(fd,
                Buffer.allocUnsafe(expected.length),
                0,
                expected.length,
                value);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

[0.5, 2 ** 53, 2n ** 63n].forEach((value) => {
  assert.throws(() => {
    fs.readSync(fd,
                Buffer.allocUnsafe(expected.length),
                0,
                expected.length,
                value);
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError'
  });
});

fs.readSync(fd,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            0n);

try {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              0,
              expected.length,
              2n ** 53n - 1n);
} catch (err) {
  // On systems where max file size is below 2^53-1, we'd expect a EFBIG error.
  // This is not using `assert.throws` because the above call should not raise
  // any error on systems that allows file of that size.
  if (err.code !== 'EFBIG' && !(common.isIBMi && err.code === 'EOVERFLOW'))
    throw err;
}
```"
"```javascript:modules\crypto.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

import { ERR_CRYPTO_FIPS_FORCED, ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH, ERR_INVALID_ARG_TYPE } from ""./internal/errors"";
import { crypto as constants } from ""./internal_binding/constants"";
import { getOptionValue } from ""./internal/options"";
import { isAnyArrayBuffer, isArrayBufferView } from ""./internal/util/types"";
import {
  timing_safe_equal,
} from ""_node:crypto"";
function timingSafeEqual(a, b) {
  if (!isAnyArrayBuffer(a) && !isArrayBufferView(a)) {
    throw new ERR_INVALID_ARG_TYPE(""buf1"", [""ArrayBuffer"", ""Buffer"", ""TypedArray"", ""DataView""], a);
  }
  if (!isAnyArrayBuffer(b) && !isArrayBufferView(b)) {
    throw new ERR_INVALID_ARG_TYPE(""buf2"", [""ArrayBuffer"", ""Buffer"", ""TypedArray"", ""DataView""], b);
  }
  if (a.byteLength != b.byteLength) {
    throw new ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH();
  }
  return timing_safe_equal(a.buffer, b.buffer);
}

import {
  checkPrime,
  checkPrimeSync,
  generatePrime,
  generatePrimeSync,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
} from ""./internal/crypto/random"";
import { pbkdf2, pbkdf2Sync } from ""./internal/crypto/pbkdf2"";
import { scrypt, scryptSync } from ""./internal/crypto/scrypt"";
import { hkdf, hkdfSync } from ""./internal/crypto/hkdf"";
/*import {
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,
} from ""./internal/crypto/keygen"";*/
import {
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  KeyObject,
} from ""./internal/crypto/keys"";/*
import {
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
} from ""./internal/crypto/diffiehellman"";*/
import {
  Cipheriv,
  Decipheriv,
  getCipherInfo,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
} from ""./internal/crypto/cipher"";
/*
import {
  Sign,
  signOneShot,
  Verify,
  verifyOneShot,
} from ""./internal/crypto/sig"";*/
import { Hash, Hmac } from ""./internal/crypto/hash"";/*
import { X509Certificate } from ""./internal/crypto/x509"";
*/import {
  getCiphers,
  getCurves,
  getHashes,
  secureHeapUsed,
  setEngine,
} from ""./internal/crypto/util"";/*
import Certificate from ""./internal/crypto/certificate"";
*/
const webcrypto = undefined;
const fipsForced = getOptionValue(""--force-fips"");

function createCipheriv(cipher, key, iv, options) {
  return new Cipheriv(cipher, key, iv, options);
}

function createDecipheriv(algorithm, key, iv, options) {
  return new Decipheriv(algorithm, key, iv, options);
}
/*
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
  return new DiffieHellman(
    sizeOrKey,
    keyEncoding,
    generator,
    generatorEncoding,
  );
}

function createDiffieHellmanGroup(name) {
  return new DiffieHellmanGroup(name);
}

function createECDH(curve) {
  return new ECDH(curve);
}
*/
function createHash(hash, options) {
  return new Hash(hash, options);
}

function createHmac(hmac, key, options) {
  return new Hmac(hmac, key, options);
}
/*
function createSign(algorithm, options) {
  return new Sign(algorithm, options);
}

function createVerify(algorithm, options) {
  return new Verify(algorithm, options);
}
*/
function setFipsForced(val) {
  if (val) {
    return;
  }

  throw new ERR_CRYPTO_FIPS_FORCED();
}

function getFipsForced() {
  return 1;
}

Object.defineProperty(constants, ""defaultCipherList"", {
  value: getOptionValue(""--tls-cipher-list""),
});
/*
const getDiffieHellman = createDiffieHellmanGroup;
*/
function getFipsCrypto() {
  throw new Error(""crypto.getFipsCrypto is unimplemented"")
}
function setFipsCrypto(_val) {
  throw new Error(""crypto.setFipsCrypto is unimplemented"")
}
const getFips = fipsForced ? getFipsForced : getFipsCrypto;
const setFips = fipsForced ? setFipsForced : setFipsCrypto;
/*
const sign = signOneShot;
const verify = verifyOneShot;
*/
export default {
  /*Certificate,*/
  checkPrime,
  checkPrimeSync,
  Cipheriv,
  constants,
  createCipheriv,
  createDecipheriv,/*
  createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,*/
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,/*
  createSign,
  createVerify,*/
  Decipheriv,/*
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,*/
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,/*
  getDiffieHellman,*/
  getFips,
  getHashes,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,/*
  KeyObject,*/
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,/*
  Sign,
  sign,*/
  timingSafeEqual,
  /*Verify,
  verify,
  webcrypto,
  X509Certificate,*/
};

export {
  /*Certificate,*/
  checkPrime,
  checkPrimeSync,
  Cipheriv,
  constants,
  createCipheriv,
  createDecipheriv,
  /*createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,*/
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,/*
  createSign,
  createVerify,*/
  Decipheriv,/*
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,*/
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,/*
  getDiffieHellman,*/
  getFips,
  getHashes,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,/*
  KeyObject,*/
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,
  /*Sign,
  sign,*/
  timingSafeEqual,
  /*Verify,
  verify,*/
  webcrypto,
  /*X509Certificate,*/
};

```"
"```javascript:test\fs\test-fs-write-file-sync.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

if (!common.isMainThread)
  common.skip('Setting process.umask is not supported in Workers');

import assert from 'assert';
import path from 'path';
import fs from 'fs';
import process from 'process';

// On Windows chmod is only able to manipulate read-only bit. Test if creating
// the file in read-only mode works.
const mode = common.isWindows ? 0o444 : 0o755;

// Reset the umask for testing
process.umask(0o000);

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test writeFileSync
{
  const file = path.join(tmpdir.path, 'testWriteFileSync.txt');

  fs.writeFileSync(file, '123', { mode });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, '123');
  // assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
}

// Test appendFileSync
{
  const file = path.join(tmpdir.path, 'testAppendFileSync.txt');

  fs.appendFileSync(file, 'abc', { mode });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, 'abc');
  // assert.strictEqual(fs.statSync(file).mode & mode, mode);
}

// Test writeFileSync with file descriptor
{
  // Need to hijack fs.open/close to make sure that things
  // get closed once they're opened.
  const _openSync = fs.openSync;
  const _closeSync = fs.closeSync;
  let openCount = 0;

  fs.openSync = (...args) => {
    openCount++;
    return _openSync(...args);
  };

  fs.closeSync = (...args) => {
    openCount--;
    return _closeSync(...args);
  };

  const file = path.join(tmpdir.path, 'testWriteFileSyncFd.txt');
  const fd = fs.openSync(file, 'w+', mode);

  fs.writeFileSync(fd, '123');
  fs.closeSync(fd);
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, '123');
  // assert.strictEqual(fs.statSync(file).mode & 0o777, mode);

  // Verify that all opened files were closed.
  assert.strictEqual(openCount, 0);
  fs.openSync = _openSync;
  fs.closeSync = _closeSync;
}

// Test writeFileSync with flags
{
  const file = path.join(tmpdir.path, 'testWriteFileSyncFlags.txt');

  fs.writeFileSync(file, 'hello ', { encoding: 'utf8', flag: 'a' });
  fs.writeFileSync(file, 'world!', { encoding: 'utf8', flag: 'a' });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, 'hello world!');
}

// Test writeFileSync with an object with an own toString function
{
  // Runtime deprecated by DEP0162
  common.expectWarning('DeprecationWarning',
                       'Implicit coercion of objects with own toString property is deprecated.',
                       'DEP0162');
  const file = path.join(tmpdir.path, 'testWriteFileSyncStringify.txt');
  const data = {
    toString() {
      return 'hello world!';
    }
  };

  fs.writeFileSync(file, data, { encoding: 'utf8', flag: 'a' });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, String(data));
}

```"
"```javascript:modules\internal\streams\buffer_list.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { Buffer } from ""buffer"";

class BufferList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }

    push(v) {
        const entry = { data: v, next: null };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }

    unshift(v) {
        const entry = { data: v, next: this.head };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }

    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }

    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }

    join(s) {
        if (this.length === 0) {
            return """";
        }
        let p = this.head;
        let ret = """" + p.data;
        while (p = p.next) {
            ret += s + p.data;
        }
        return ret;
    }

    concat(n) {
        if (this.length === 0) {
            return Buffer.alloc(0);
        }
        const ret = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
            ret.set(p.data, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
    consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
            // `slice` is the same for buffers and strings.
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
        }
        if (n === data.length) {
            // First chunk is a perfect match.
            return this.shift();
        }
        // Result spans more than one buffer.
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    first() {
        return this.head.data;
    }

    *[Symbol.iterator]() {
        for (let p = this.head; p; p = p.next) {
            yield p.data;
        }
    }

    // Consumes a specified amount of characters from the buffered data.
    _getString(n) {
        let ret = """";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        } while (p = p.next);
        this.length -= c;
        return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
    _getBuffer(n) {
        const ret = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(
                        new Uint8Array(buf.buffer, buf.byteOffset, n),
                        retLen - n,
                    );
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        } while (p = p.next);
        this.length -= c;
        return ret;
    }
}

export default BufferList;
```"
"```javascript:test\fs\test-fs-chmod.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

let mode_async;
let mode_sync;

// Need to hijack fs.open/close to make sure that things
// get closed once they're opened.
fs._open = fs.open;
fs._openSync = fs.openSync;
fs.open = open;
fs.openSync = openSync;
fs._close = fs.close;
fs._closeSync = fs.closeSync;
fs.close = close;
fs.closeSync = closeSync;

let openCount = 0;

function open() {
  openCount++;
  return fs._open.apply(fs, arguments);
}

function openSync() {
  openCount++;
  return fs._openSync.apply(fs, arguments);
}

function close() {
  openCount--;
  return fs._close.apply(fs, arguments);
}

function closeSync() {
  openCount--;
  return fs._closeSync.apply(fs, arguments);
}


// On Windows chmod is only able to manipulate write permission
if (common.isWindows) {
  mode_async = 0o400;   // read-only
  mode_sync = 0o600;    // read-write
} else {
  mode_async = 0o777;
  mode_sync = 0o644;
}

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const file1 = path.join(tmpdir.path, 'a.js');
const file2 = path.join(tmpdir.path, 'a1.js');

// Create file1.
fs.closeSync(fs.openSync(file1, 'w'));

fs.chmod(file1, mode_async.toString(8), common.mustSucceed(() => {
  if (common.isWindows) {
    assert.ok((fs.statSync(file1).mode & 0o777) & mode_async);
  } else {
    assert.strictEqual(fs.statSync(file1).mode & 0o777, mode_async);
  }

  fs.chmodSync(file1, mode_sync);
  if (common.isWindows) {
    assert.ok((fs.statSync(file1).mode & 0o777) & mode_sync);
  } else {
    assert.strictEqual(fs.statSync(file1).mode & 0o777, mode_sync);
  }
}));

fs.open(file2, 'w', common.mustSucceed((fd) => {
  fs.fchmod(fd, mode_async.toString(8), common.mustSucceed(() => {
    if (common.isWindows) {
      assert.ok((fs.fstatSync(fd).mode & 0o777) & mode_async);
    } else {
      assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode_async);
    }

    assert.throws(
      () => fs.fchmod(fd, {}),
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    fs.fchmodSync(fd, mode_sync);
    if (common.isWindows) {
      assert.ok((fs.fstatSync(fd).mode & 0o777) & mode_sync);
    } else {
      assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode_sync);
    }

    fs.close(fd, assert.ifError);
  }));
}));

// lchmod
if (fs.lchmod) {
  const link = path.join(tmpdir.path, 'symbolic-link');

  fs.symlinkSync(file2, link);

  fs.lchmod(link, mode_async, common.mustSucceed(() => {
    assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode_async);

    fs.lchmodSync(link, mode_sync);
    assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode_sync);

  }));
}

[false, 1, {}, [], null, undefined].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""path"" argument must be of type string or an instance ' +
             'of Buffer or URL.' +
             common.invalidArgTypeHelper(input)
  };
  assert.throws(() => fs.chmod(input, 1, common.mustNotCall()), errObj);
  assert.throws(() => fs.chmodSync(input, 1), errObj);
});

process.on('exit', function() {
  assert.strictEqual(openCount, 0);
});

```"
"```javascript:test\path\test-path-join.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import path from 'path';

const failures = [];
const backslashRE = /\\/g;

const joinTests = [
  [ [path.posix.join, /*path.win32.join*/],
    // Arguments                     result
    [[['.', 'x/b', '..', '/b/c.js'], 'x/b/c.js'],
     [[], '.'],
     [['/.', 'x/b', '..', '/b/c.js'], '/x/b/c.js'],
     [['/foo', '../../../bar'], '/bar'],
     [['foo', '../../../bar'], '../../bar'],
     [['foo/', '../../../bar'], '../../bar'],
     [['foo/x', '../../../bar'], '../bar'],
     [['foo/x', './bar'], 'foo/x/bar'],
     [['foo/x/', './bar'], 'foo/x/bar'],
     [['foo/x/', '.', 'bar'], 'foo/x/bar'],
     [['./'], './'],
     [['.', './'], './'],
     [['.', '.', '.'], '.'],
     [['.', './', '.'], '.'],
     [['.', '/./', '.'], '.'],
     [['.', '/////./', '.'], '.'],
     [['.'], '.'],
     [['', '.'], '.'],
     [['', 'foo'], 'foo'],
     [['foo', '/bar'], 'foo/bar'],
     [['', '/foo'], '/foo'],
     [['', '', '/foo'], '/foo'],
     [['', '', 'foo'], 'foo'],
     [['foo', ''], 'foo'],
     [['foo/', ''], 'foo/'],
     [['foo', '', '/bar'], 'foo/bar'],
     [['./', '..', '/foo'], '../foo'],
     [['./', '..', '..', '/foo'], '../../foo'],
     [['.', '..', '..', '/foo'], '../../foo'],
     [['', '..', '..', '/foo'], '../../foo'],
     [['/'], '/'],
     [['/', '.'], '/'],
     [['/', '..'], '/'],
     [['/', '..', '..'], '/'],
     [[''], '.'],
     [['', ''], '.'],
     [[' /foo'], ' /foo'],
     [[' ', 'foo'], ' /foo'],
     [[' ', '.'], ' '],
     [[' ', '/'], ' /'],
     [[' ', ''], ' '],
     [['/', 'foo'], '/foo'],
     [['/', '/foo'], '/foo'],
     [['/', '//foo'], '/foo'],
     [['/', '', '/foo'], '/foo'],
     [['', '/', 'foo'], '/foo'],
     [['', '/', '/foo'], '/foo'],
    ],
  ],
];
/*
// Windows-specific join tests
joinTests.push([
  path.win32.join,
  joinTests[0][1].slice(0).concat(
    [// Arguments                     result
      // UNC path expected
      [['//foo/bar'], '\\\\foo\\bar\\'],
      [['\\/foo/bar'], '\\\\foo\\bar\\'],
      [['\\\\foo/bar'], '\\\\foo\\bar\\'],
      // UNC path expected - server and share separate
      [['//foo', 'bar'], '\\\\foo\\bar\\'],
      [['//foo/', 'bar'], '\\\\foo\\bar\\'],
      [['//foo', '/bar'], '\\\\foo\\bar\\'],
      // UNC path expected - questionable
      [['//foo', '', 'bar'], '\\\\foo\\bar\\'],
      [['//foo/', '', 'bar'], '\\\\foo\\bar\\'],
      [['//foo/', '', '/bar'], '\\\\foo\\bar\\'],
      // UNC path expected - even more questionable
      [['', '//foo', 'bar'], '\\\\foo\\bar\\'],
      [['', '//foo/', 'bar'], '\\\\foo\\bar\\'],
      [['', '//foo/', '/bar'], '\\\\foo\\bar\\'],
      // No UNC path expected (no double slash in first component)
      [['\\', 'foo/bar'], '\\foo\\bar'],
      [['\\', '/foo/bar'], '\\foo\\bar'],
      [['', '/', '/foo/bar'], '\\foo\\bar'],
      // No UNC path expected (no non-slashes in first component -
      // questionable)
      [['//', 'foo/bar'], '\\foo\\bar'],
      [['//', '/foo/bar'], '\\foo\\bar'],
      [['\\\\', '/', '/foo/bar'], '\\foo\\bar'],
      [['//'], '\\'],
      // No UNC path expected (share name missing - questionable).
      [['//foo'], '\\foo'],
      [['//foo/'], '\\foo\\'],
      [['//foo', '/'], '\\foo\\'],
      [['//foo', '', '/'], '\\foo\\'],
      // No UNC path expected (too many leading slashes - questionable)
      [['///foo/bar'], '\\foo\\bar'],
      [['////foo', 'bar'], '\\foo\\bar'],
      [['\\\\\\/foo/bar'], '\\foo\\bar'],
      // Drive-relative vs drive-absolute paths. This merely describes the
      // status quo, rather than being obviously right
      [['c:'], 'c:.'],
      [['c:.'], 'c:.'],
      [['c:', ''], 'c:.'],
      [['', 'c:'], 'c:.'],
      [['c:.', '/'], 'c:.\\'],
      [['c:.', 'file'], 'c:file'],
      [['c:', '/'], 'c:\\'],
      [['c:', 'file'], 'c:\\file'],
    ]
  ),
]);
*/
joinTests.forEach((test) => {
  if (!Array.isArray(test[0]))
    test[0] = [test[0]];
  test[0].forEach((join) => {
    test[1].forEach((test) => {
      const actual = join.apply(null, test[0]);
      const expected = test[1];
      // For non-Windows specific tests with the Windows join(), we need to try
      // replacing the slashes since the non-Windows specific tests' `expected`
      // use forward slashes
      let actualAlt;
      let os;
      if (false /*join === path.win32.join*/) {
        actualAlt = actual.replace(backslashRE, '/');
        os = 'win32';
      } else {
        os = 'posix';
      }
      if (actual !== expected && actualAlt !== expected) {
        const delimiter = test[0].map(JSON.stringify).join(',');
        const message = `path.${os}.join(${delimiter})\n  expect=${
          JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
        failures.push(`\n${message}`);
      }
    });
  });
});

assert.strictEqual(failures.length, 0, failures.join(''));

```"
"```javascript:test\crypto\test-crypto-padding.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

// Input data.
const ODD_LENGTH_PLAIN = 'Hello node world!';
const EVEN_LENGTH_PLAIN = 'Hello node world!AbC09876dDeFgHi';

const KEY_PLAIN = 'S3c.r.e.t.K.e.Y!';
const IV_PLAIN = 'blahFizz2011Buzz';

const CIPHER_NAME = 'aes-128-cbc';

// Expected result data.

// echo -n 'Hello node world!' | \
// openssl enc -aes-128-cbc -e -K 5333632e722e652e742e4b2e652e5921 \
// -iv 626c616846697a7a3230313142757a7a | xxd -p -c256
const ODD_LENGTH_ENCRYPTED =
    '7f57859550d4d2fdb9806da2a750461a9fe77253cd1cbd4b07beee4e070d561f';

// echo -n 'Hello node world!AbC09876dDeFgHi' | \
// openssl enc -aes-128-cbc -e -K 5333632e722e652e742e4b2e652e5921 \
// -iv 626c616846697a7a3230313142757a7a | xxd -p -c256
const EVEN_LENGTH_ENCRYPTED =
    '7f57859550d4d2fdb9806da2a750461ab46e71b3d78ebe2d9684dfc87f7575b988' +
    '6119866912cb8c7bcaf76c5ebc2378';

// echo -n 'Hello node world!AbC09876dDeFgHi' | \
// openssl enc -aes-128-cbc -e -K 5333632e722e652e742e4b2e652e5921 \
// -iv 626c616846697a7a3230313142757a7a -nopad | xxd -p -c256
const EVEN_LENGTH_ENCRYPTED_NOPAD =
    '7f57859550d4d2fdb9806da2a750461ab46e71b3d78ebe2d9684dfc87f7575b9';


// Helper wrappers.
function enc(plain, pad) {
  const encrypt = crypto.createCipheriv(CIPHER_NAME, KEY_PLAIN, IV_PLAIN);
  encrypt.setAutoPadding(pad);
  let hex = encrypt.update(plain, 'ascii', 'hex');
  hex += encrypt.final('hex');
  return hex;
}

function dec(encd, pad) {
  const decrypt = crypto.createDecipheriv(CIPHER_NAME, KEY_PLAIN, IV_PLAIN);
  decrypt.setAutoPadding(pad);
  let plain = decrypt.update(encd, 'hex');
  plain += decrypt.final('latin1');
  return plain;
}

// Test encryption
assert.strictEqual(enc(ODD_LENGTH_PLAIN, true), ODD_LENGTH_ENCRYPTED);
assert.strictEqual(enc(EVEN_LENGTH_PLAIN, true), EVEN_LENGTH_ENCRYPTED);

assert.throws(function() {
  // Input must have block length %.
  enc(ODD_LENGTH_PLAIN, false);
}, common.hasOpenSSL3 ? {
  message: 'error:1C80006B:Provider routines::wrong final block length',
  code: 'ERR_OSSL_WRONG_FINAL_BLOCK_LENGTH',
  reason: 'wrong final block length',
} : {
  message: 'error:0607F08A:digital envelope routines:EVP_EncryptFinal_ex:' +
    'data not multiple of block length',
  code: 'ERR_OSSL_EVP_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH',
  reason: 'data not multiple of block length',
}
);

assert.strictEqual(
  enc(EVEN_LENGTH_PLAIN, false), EVEN_LENGTH_ENCRYPTED_NOPAD
);

// Test decryption.
assert.strictEqual(dec(ODD_LENGTH_ENCRYPTED, true), ODD_LENGTH_PLAIN);
assert.strictEqual(dec(EVEN_LENGTH_ENCRYPTED, true), EVEN_LENGTH_PLAIN);

// Returns including original padding.
assert.strictEqual(dec(ODD_LENGTH_ENCRYPTED, false).length, 32);
assert.strictEqual(dec(EVEN_LENGTH_ENCRYPTED, false).length, 48);

assert.throws(function() {
  // Must have at least 1 byte of padding (PKCS):
  assert.strictEqual(dec(EVEN_LENGTH_ENCRYPTED_NOPAD, true), EVEN_LENGTH_PLAIN);
}, common.hasOpenSSL3 ? {
  message: 'error:1C800064:Provider routines::bad decrypt',
  reason: 'bad decrypt',
  code: 'ERR_OSSL_BAD_DECRYPT',
} : {
  message: 'error:06065064:digital envelope routines:EVP_DecryptFinal_ex:' +
    'bad decrypt',
  reason: 'bad decrypt',
  code: 'ERR_OSSL_EVP_BAD_DECRYPT',
});

// No-pad encrypted string should return the same:
assert.strictEqual(
  dec(EVEN_LENGTH_ENCRYPTED_NOPAD, false), EVEN_LENGTH_PLAIN
);

```"
"```javascript:modules\internal\streams\transform.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { ERR_METHOD_NOT_IMPLEMENTED } from ""../errors.js"";
import Duplex from ""./duplex.js"";

const kCallback = Symbol(""kCallback"");

function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }

    Duplex.call(this, options);

    // We have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;

    this[kCallback] = null;

    if (options) {
        if (typeof options.transform === ""function"") {
            this._transform = options.transform;
        }

        if (typeof options.flush === ""function"") {
            this._flush = options.flush;
        }
    }

    // When the writable side finishes, then flush out anything remaining.
    // Backwards compat. Some Transform streams incorrectly implement _final
    // instead of or in addition to _flush. By using 'prefinish' instead of
    // implementing _final we continue supporting this unfortunate use case.
    this.on(""prefinish"", prefinish);
}

Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);

function final(cb) {
    let called = false;
    if (typeof this._flush === ""function"" && !this.destroyed) {
        const result = this._flush((er, data) => {
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }

            if (data != null) {
                this.push(data);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === ""function"") {
                    then.call(
                        result,
                        (data) => {
                            if (called) {
                                return;
                            }
                            if (data != null) {
                                this.push(data);
                            }
                            this.push(null);
                            if (cb) {
                                nextTick(cb);
                            }
                        },
                        (err) => {
                            if (cb) {
                                nextTick(cb, err);
                            } else {
                                nextTick(() => this.destroy(err));
                            }
                        },
                    );
                }
            } catch (err) {
                nextTick(() => this.destroy(err));
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}

function prefinish() {
    if (this._final !== final) {
        final.call(this);
    }
}

Transform.prototype._final = final;

Transform.prototype._transform = function (chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED(""_transform()"");
};

Transform.prototype._write = function (chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;

    let called = false;
    const result = this._transform(chunk, encoding, (err, val) => {
        called = true;
        if (err) {
            callback(err);
            return;
        }

        if (val != null) {
            this.push(val);
        }

        if (
            wState.ended || // Backwards compat.
            length === rState.length || // Backwards compat.
            rState.length < rState.highWaterMark ||
            rState.length === 0
        ) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    (val) => {
                        if (called) {
                            return;
                        }

                        if (val != null) {
                            this.push(val);
                        }

                        if (
                            wState.ended ||
                            length === rState.length ||
                            rState.length < rState.highWaterMark ||
                            rState.length === 0
                        ) {
                            nextTick(callback);
                        } else {
                            this[kCallback] = callback;
                        }
                    },
                    (err) => {
                        nextTick(callback, err);
                    },
                );
            }
        } catch (err) {
            nextTick(callback, err);
        }
    }
};

Transform.prototype._read = function () {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};

export default Transform;
```"
"```javascript:modules\internal_binding\uv.js
export const UV_EOF = (-4095);
export const UV_UNKNOWN = (-4094);
export const UV_EAI_ADDRFAMILY = (-3000);
export const UV_EAI_AGAIN = (-3001);
export const UV_EAI_BADFLAGS = (-3002);
export const UV_EAI_CANCELED = (-3003);
export const UV_EAI_FAIL = (-3004);
export const UV_EAI_FAMILY = (-3005);
export const UV_EAI_MEMORY = (-3006);
export const UV_EAI_NODATA = (-3007);
export const UV_EAI_NONAME = (-3008);
export const UV_EAI_OVERFLOW = (-3009);
export const UV_EAI_SERVICE = (-3010);
export const UV_EAI_SOCKTYPE = (-3011);
export const UV_EAI_BADHINTS = (-3013);
export const UV_EAI_PROTOCOL = (-3014);
export const UV_E2BIG = (-4093);
export const UV_EACCES = (-4092);
export const UV_EADDRINUSE = (-4091);
export const UV_EADDRNOTAVAIL = (-4090);
export const UV_EAFNOSUPPORT = (-4089);
export const UV_EAGAIN = (-4088);
export const UV_EALREADY = (-4084);
export const UV_EBADF = (-4083);
export const UV_EBUSY = (-4082);
export const UV_ECANCELED = (-4081);
export const UV_ECHARSET = (-4080);
export const UV_ECONNABORTED = (-4079);
export const UV_ECONNREFUSED = (-4078);
export const UV_ECONNRESET = (-4077);
export const UV_EDESTADDRREQ = (-4076);
export const UV_EEXIST = (-4075);
export const UV_EFAULT = (-4074);
export const UV_EHOSTUNREACH = (-4073);
export const UV_EINTR = (-4072);
export const UV_EINVAL = (-4071);
export const UV_EIO = (-4070);
export const UV_EISCONN = (-4069);
export const UV_EISDIR = (-4068);
export const UV_ELOOP = (-4067);
export const UV_EMFILE = (-4066);
export const UV_EMSGSIZE = (-4065);
export const UV_ENAMETOOLONG = (-4064);
export const UV_ENETDOWN = (-4063);
export const UV_ENETUNREACH = (-4062);
export const UV_ENFILE = (-4061);
export const UV_ENOBUFS = (-4060);
export const UV_ENODEV = (-4059);
export const UV_ENOENT = (-4058);
export const UV_ENOMEM = (-4057);
export const UV_ENONET = (-4056);
export const UV_ENOSPC = (-4055);
export const UV_ENOSYS = (-4054);
export const UV_ENOTCONN = (-4053);
export const UV_ENOTDIR = (-4052);
export const UV_ENOTEMPTY = (-4051);
export const UV_ENOTSOCK = (-4050);
export const UV_ENOTSUP = (-4049);
export const UV_EPERM = (-4048);
export const UV_EPIPE = (-4047);
export const UV_EPROTO = (-4046);
export const UV_EPROTONOSUPPORT = (-4045);
export const UV_EPROTOTYPE = (-4044);
export const UV_EROFS = (-4043);
export const UV_ESHUTDOWN = (-4042);
export const UV_ESPIPE = (-4041);
export const UV_ESRCH = (-4040);
export const UV_ETIMEDOUT = (-4039);
export const UV_ETXTBSY = (-4038);
export const UV_EXDEV = (-4037);
export const UV_EFBIG = (-4036);
export const UV_ENOPROTOOPT = (-4035);
export const UV_ERANGE = (-4034);
export const UV_ENXIO = (-4033);
export const UV_EMLINK = (-4032);
export const UV_EHOSTDOWN = (-4031);
export const UV_EREMOTEIO = (-4030);
export const UV_ENOTTY = (-4029);
export const UV_EFTYPE = (-4028);
export const UV_EILSEQ = (-4027);
export const UV_EOVERFLOW = (-4026);
export const UV_ESOCKTNOSUPPORT = (-4025);

export default {
    UV_EOF,
    UV_UNKNOWN,
    UV_EAI_ADDRFAMILY,
    UV_EAI_AGAIN,
    UV_EAI_BADFLAGS,
    UV_EAI_CANCELED,
    UV_EAI_FAIL,
    UV_EAI_FAMILY,
    UV_EAI_MEMORY,
    UV_EAI_NODATA,
    UV_EAI_NONAME,
    UV_EAI_OVERFLOW,
    UV_EAI_SERVICE,
    UV_EAI_SOCKTYPE,
    UV_EAI_BADHINTS,
    UV_EAI_PROTOCOL,
    UV_E2BIG,
    UV_EACCES,
    UV_EADDRINUSE,
    UV_EADDRNOTAVAIL,
    UV_EAFNOSUPPORT,
    UV_EAGAIN,
    UV_EALREADY,
    UV_EBADF,
    UV_EBUSY,
    UV_ECANCELED,
    UV_ECHARSET,
    UV_ECONNABORTED,
    UV_ECONNREFUSED,
    UV_ECONNRESET,
    UV_EDESTADDRREQ,
    UV_EEXIST,
    UV_EFAULT,
    UV_EHOSTUNREACH,
    UV_EINTR,
    UV_EINVAL,
    UV_EIO,
    UV_EISCONN,
    UV_EISDIR,
    UV_ELOOP,
    UV_EMFILE,
    UV_EMSGSIZE,
    UV_ENAMETOOLONG,
    UV_ENETDOWN,
    UV_ENETUNREACH,
    UV_ENFILE,
    UV_ENOBUFS,
    UV_ENODEV,
    UV_ENOENT,
    UV_ENOMEM,
    UV_ENONET,
    UV_ENOSPC,
    UV_ENOSYS,
    UV_ENOTCONN,
    UV_ENOTDIR,
    UV_ENOTEMPTY,
    UV_ENOTSOCK,
    UV_ENOTSUP,
    UV_EPERM,
    UV_EPIPE,
    UV_EPROTO,
    UV_EPROTONOSUPPORT,
    UV_EPROTOTYPE,
    UV_EROFS,
    UV_ESHUTDOWN,
    UV_ESPIPE,
    UV_ESRCH,
    UV_ETIMEDOUT,
    UV_ETXTBSY,
    UV_EXDEV,
    UV_EFBIG,
    UV_ENOPROTOOPT,
    UV_ERANGE,
    UV_ENXIO,
    UV_EMLINK,
    UV_EHOSTDOWN,
    UV_EREMOTEIO,
    UV_ENOTTY,
    UV_EFTYPE,
    UV_EILSEQ,
    UV_EOVERFLOW,
    UV_ESOCKTNOSUPPORT,
}
```"
"```javascript:test\fs\test-fs-read-stream-inherit.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const fn = fixtures.path('elipses.txt');
const rangeFile = fixtures.path('x.txt');

{
  let paused = false;

  const file = fs.ReadStream(fn);

  file.on('open', common.mustCall(function(fd) {
    file.length = 0;
    assert.strictEqual(typeof fd, 'number');
    assert.ok(file.readable);

    // GH-535
    file.pause();
    file.resume();
    file.pause();
    file.resume();
  }));

  file.on('data', common.mustCallAtLeast(function(data) {
    assert.ok(data instanceof Buffer);
    assert.ok(!paused);
    file.length += data.length;

    paused = true;
    file.pause();

    setTimeout(function() {
      paused = false;
      file.resume();
    }, 10);
  }));


  file.on('end', common.mustCall());


  file.on('close', common.mustCall(function() {
    assert.strictEqual(file.length, 30000);
  }));
}

{
  const file = fs.createReadStream(fn, Object.create({ encoding: 'utf8' }));
  file.length = 0;
  file.on('data', function(data) {
    assert.strictEqual(typeof data, 'string');
    file.length += data.length;

    for (let i = 0; i < data.length; i++) {
      // http://www.fileformat.info/info/unicode/char/2026/index.htm
      assert.strictEqual(data[i], '\u2026');
    }
  });

  file.on('close', common.mustCall(function() {
    assert.strictEqual(file.length, 10000);
  }));
}

{
  const options = Object.create({ bufferSize: 1, start: 1, end: 2 });
  const file = fs.createReadStream(rangeFile, options);
  assert.strictEqual(file.start, 1);
  assert.strictEqual(file.end, 2);
  let contentRead = '';
  file.on('data', function(data) {
    contentRead += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(contentRead, 'yz');
  }));
}

{
  const options = Object.create({ bufferSize: 1, start: 1 });
  const file = fs.createReadStream(rangeFile, options);
  assert.strictEqual(file.start, 1);
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

// https://github.com/joyent/node/issues/2320
{
  const options = Object.create({ bufferSize: 1.23, start: 1 });
  const file = fs.createReadStream(rangeFile, options);
  assert.strictEqual(file.start, 1);
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

{
  const message =
    'The value of ""start"" is out of range. It must be <= ""end"" (here: 2).' +
    ' Received 10';

  assert.throws(
    () => {
      fs.createReadStream(rangeFile, Object.create({ start: 10, end: 2 }));
    },
    {
      code: 'ERR_OUT_OF_RANGE',
      message,
      name: 'RangeError'
    });
}

{
  const options = Object.create({ start: 0, end: 0 });
  const stream = fs.createReadStream(rangeFile, options);
  assert.strictEqual(stream.start, 0);
  assert.strictEqual(stream.end, 0);
  stream.data = '';

  stream.on('data', function(chunk) {
    stream.data += chunk;
  });

  stream.on('end', common.mustCall(function() {
    assert.strictEqual(stream.data, 'x');
  }));
}

// Pause and then resume immediately.
{
  const pauseRes = fs.createReadStream(rangeFile);
  pauseRes.pause();
  pauseRes.resume();
}

{
  let data = '';
  let file =
    fs.createReadStream(rangeFile, Object.create({ autoClose: false }));
  assert.strictEqual(file.autoClose, false);
  file.on('data', (chunk) => { data += chunk; });
  file.on('end', common.mustCall(function() {
    process.nextTick(common.mustCall(function() {
      assert(!file.closed);
      assert(!file.destroyed);
      assert.strictEqual(data, 'xyz\n');
      fileNext();
    }));
  }));

  function fileNext() {
    // This will tell us if the fd is usable again or not.
    file = fs.createReadStream(null, Object.create({ fd: file.fd, start: 0 }));
    file.data = '';
    file.on('data', function(data) {
      file.data += data;
    });
    file.on('end', common.mustCall(function() {
      assert.strictEqual(file.data, 'xyz\n');
    }));
  }
  process.on('exit', function() {
    assert(file.closed);
    assert(file.destroyed);
  });
}

// Just to make sure autoClose won't close the stream because of error.
{
  const options = Object.create({ fd: 13337, autoClose: false });
  const file = fs.createReadStream(null, options);
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());
  process.on('exit', function() {
    assert(!file.closed);
    assert(!file.destroyed);
    assert(file.fd);
  });
}

// Make sure stream is destroyed when file does not exist.
{
  const file = fs.createReadStream('/path/to/file/that/does/not/exist');
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());

  process.on('exit', function() {
    assert(file.closed);
    assert(file.destroyed);
  });
}

```"
"```javascript:test\fs\test-fs-promises-writefile.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
const fsPromises = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;
import { Readable } from 'stream';

tmpdir.refresh();

const dest = path.resolve(tmpDir, 'tmp.txt');
const otherDest = path.resolve(tmpDir, 'tmp-2.txt');
const buffer = Buffer.from('abc'.repeat(1000));
const buffer2 = Buffer.from('xyz'.repeat(1000));
const stream = Readable.from(['a', 'b', 'c']);
const stream2 = Readable.from(['��mlaut', ' ', 'sechzig']);
const iterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};

const veryLargeBuffer = {
  expected: 'dogs running'.repeat(512 * 1024),
  *[Symbol.iterator]() {
    yield Buffer.from('dogs running'.repeat(512 * 1024), 'utf8');
  }
};

function iterableWith(value) {
  return {
    *[Symbol.iterator]() {
      yield value;
    }
  };
}
const bufferIterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield Buffer.from('a');
    yield Buffer.from('b');
    yield Buffer.from('c');
  }
};
const asyncIterable = {
  expected: 'abc',
  async* [Symbol.asyncIterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};

async function doWrite() {
  await fsPromises.writeFile(dest, buffer);
  const data = fs.readFileSync(dest);
  assert.deepStrictEqual(data, buffer);
}

async function doWriteStream() {
  await fsPromises.writeFile(dest, stream);
  const expected = 'abc';
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, expected);
}

async function doWriteStreamWithCancel() {
  const controller = new AbortController();
  const { signal } = controller;
  process.nextTick(() => controller.abort());
  await assert.rejects(
    fsPromises.writeFile(otherDest, stream, { signal }),
    { name: 'AbortError' }
  );
}

async function doWriteIterable() {
  await fsPromises.writeFile(dest, iterable);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, iterable.expected);
}

async function doWriteInvalidIterable() {
  await Promise.all(
    [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
      assert.rejects(fsPromises.writeFile(dest, iterableWith(value)), {
        code: 'ERR_INVALID_ARG_TYPE',
      })
    )
  );
}

async function doWriteIterableWithEncoding() {
  await fsPromises.writeFile(dest, stream2, 'latin1');
  const expected = '��mlaut sechzig';
  const data = fs.readFileSync(dest, 'latin1');
  assert.deepStrictEqual(data, expected);
}

async function doWriteBufferIterable() {
  await fsPromises.writeFile(dest, bufferIterable);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, bufferIterable.expected);
}

async function doWriteAsyncIterable() {
  await fsPromises.writeFile(dest, asyncIterable);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, asyncIterable.expected);
}

async function doWriteAsyncLargeIterable() {
  await fsPromises.writeFile(dest, veryLargeBuffer);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, veryLargeBuffer.expected);
}

async function doWriteInvalidValues() {
  await Promise.all(
    [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
      assert.rejects(fsPromises.writeFile(dest, value), {
        code: 'ERR_INVALID_ARG_TYPE',
      })
    )
  );
}

async function doWriteWithCancel() {
  const controller = new AbortController();
  const { signal } = controller;
  process.nextTick(() => controller.abort());
  await assert.rejects(
    fsPromises.writeFile(otherDest, buffer, { signal }),
    { name: 'AbortError' }
  );
}

async function doAppend() {
  await fsPromises.appendFile(dest, buffer2, { flag: null });
  const data = fs.readFileSync(dest);
  const buf = Buffer.concat([buffer, buffer2]);
  assert.deepStrictEqual(buf, data);
}

async function doRead() {
  const data = await fsPromises.readFile(dest);
  const buf = fs.readFileSync(dest);
  assert.deepStrictEqual(buf, data);
}

async function doReadWithEncoding() {
  const data = await fsPromises.readFile(dest, 'utf-8');
  const syncData = fs.readFileSync(dest, 'utf-8');
  assert.strictEqual(typeof data, 'string');
  assert.deepStrictEqual(data, syncData);
}

(async () => {
  await doWrite();
  // await doWriteWithCancel();
  await doAppend();
  await doRead();
  await doReadWithEncoding();
  await doWriteStream();
  // await doWriteStreamWithCancel(); signal is unsupported
  await doWriteIterable();
  await doWriteInvalidIterable();
  await doWriteIterableWithEncoding();
  await doWriteBufferIterable();
  await doWriteAsyncIterable();
  // await doWriteAsyncLargeIterable(); cost to much time
  await doWriteInvalidValues();
})().then(common.mustCall());

```"
"```javascript:modules\internal\streams\compose.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { destroyer } from ""./destroy.js"";
import { isNodeStream, isReadable, isWritable } from ""./utils.js"";
import { pipeline } from ""./pipeline.js"";
import {
    AbortError,
    ERR_INVALID_ARG_VALUE,
    ERR_MISSING_ARGS,
} from ""../errors.js"";
import Duplex from ""./duplex.js"";

// This is needed for pre node 17.
class ComposeDuplex extends Duplex {
    constructor(options) {
        super(options);

        // https://github.com/nodejs/node/pull/34385

        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }

        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}

function compose(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS(""streams"");
    }

    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }

    const orgStreams = [...streams];

    if (typeof streams[0] === ""function"") {
        streams[0] = Duplex.from(streams[0]);
    }

    if (typeof streams[streams.length - 1] === ""function"") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }

    for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n])) {
            // TODO(ronag): Add checks for non streams.
            continue;
        }
        if (n < streams.length - 1 && !isReadable(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(
                `streams[${n}]`,
                orgStreams[n],
                ""must be readable"",
            );
        }
        if (n > 0 && !isWritable(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(
                `streams[${n}]`,
                orgStreams[n],
                ""must be writable"",
            );
        }
    }

    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;

    function onfinished(err) {
        const cb = onclose;
        onclose = null;

        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }

    const head = streams[0];
    const tail = pipeline(streams, onfinished);

    const writable = !!isWritable(head);
    const readable = !!isReadable(tail);

    // TODO(ronag): Avoid double buffering.
    // Implement Writable/Readable/Duplex traits.
    // See, https://github.com/nodejs/node/pull/33515.
    d = new ComposeDuplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable,
    });

    if (writable) {
        d._write = function (chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };

        d._final = function (callback) {
            head.end();
            onfinish = callback;
        };

        head.on(""drain"", function () {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });

        tail.on(""finish"", function () {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }

    if (readable) {
        tail.on(""readable"", function () {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });

        tail.on(""end"", function () {
            d.push(null);
        });

        d._read = function () {
            while (true) {
                const buf = tail.read();

                if (buf === null) {
                    onreadable = d._read;
                    return;
                }

                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }

    d._destroy = function (err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }

        onreadable = null;
        ondrain = null;
        onfinish = null;

        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(tail, err);
        }
    };

    return d;
}

export default compose;
```"
"```javascript:modules\internal\crypto\scrypt.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import { Buffer } from 'buffer';

import {
  validateFunction,
  validateInteger,
  validateInt32,
  validateUint32,
} from '../validators';

import {
  ERR_CRYPTO_SCRYPT_INVALID_PARAMETER,
  ERR_CRYPTO_SCRYPT_NOT_SUPPORTED,
} from '../errors';

import {
  getArrayBufferOrView,
  getDefaultEncoding,
} from './util';

import { scrypt_sync } from ""_node:crypto"";

const defaults = {
  N: 16384,
  r: 8,
  p: 1,
  maxmem: 32 << 20,  // 32 MiB, matches SCRYPT_MAX_MEM.
};

function scrypt(password, salt, keylen, options, callback = defaults) {
  if (callback === defaults) {
    callback = options;
    options = defaults;
  }

  options = check(password, salt, keylen, options);
  const { N, r, p, maxmem } = options;
  ({ password, salt, keylen } = options);

  validateFunction(callback, 'callback');
  const encoding = getDefaultEncoding();
  setTimeout(() => {
    let result = scrypt_sync(password.buffer ?? password, salt.buffer ?? salt, N, r, p, keylen);
    const buf = Buffer.from(result);
    if (encoding === 'buffer') {
      callback(null, buf);
    } else {
      callback(null, buf.toString(encoding));
    }
  }, 0);
}

function scryptSync(password, salt, keylen, options = defaults) {
  options = check(password, salt, keylen, options);
  const { N, r, p, maxmem } = options;
  ({ password, salt, keylen } = options);

  let result = scrypt_sync(password.buffer ?? password, salt.buffer ?? salt, N, r, p, keylen);

  const buf = Buffer.from(result);
  const encoding = getDefaultEncoding();
  return encoding === 'buffer' ? buf : buf.toString(encoding);
}

function check(password, salt, keylen, options) {
  /*if (ScryptJob === undefined)
    throw new ERR_CRYPTO_SCRYPT_NOT_SUPPORTED();*/

  password = getArrayBufferOrView(password, 'password');
  salt = getArrayBufferOrView(salt, 'salt');
  validateInt32(keylen, 'keylen', 0);

  let { N, r, p, maxmem } = defaults;
  if (options && options !== defaults) {
    const has_N = options.N !== undefined;
    if (has_N) {
      N = options.N;
      validateUint32(N, 'N');
    }
    if (options.cost !== undefined) {
      if (has_N) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
      N = options.cost;
      validateUint32(N, 'cost');
    }
    const has_r = (options.r !== undefined);
    if (has_r) {
      r = options.r;
      validateUint32(r, 'r');
    }
    if (options.blockSize !== undefined) {
      if (has_r) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
      r = options.blockSize;
      validateUint32(r, 'blockSize');
    }
    const has_p = options.p !== undefined;
    if (has_p) {
      p = options.p;
      validateUint32(p, 'p');
    }
    if (options.parallelization !== undefined) {
      if (has_p) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
      p = options.parallelization;
      validateUint32(p, 'parallelization');
    }
    if (options.maxmem !== undefined) {
      maxmem = options.maxmem;
      validateInteger(maxmem, 'maxmem', 0);
    }
    if (N === 0) N = defaults.N;
    if (r === 0) r = defaults.r;
    if (p === 0) p = defaults.p;
    if (maxmem === 0) maxmem = defaults.maxmem;
  }

  if (Math.log2(N) % 1 !== 0 || N <= 1) {
    throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
  }

  let blen = p * 128 * r
  let vlen = 32 * r * (N + 2) * 4
  if (vlen + blen > maxmem || 128 * N * r > maxmem || N >= 2 ** (r * 16) || p > (2 ** 30 - 1) / r) {
    throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
  }

  return { password, salt, keylen, N, r, p, maxmem };
}

export {
  scrypt,
  scryptSync,
};

```"
"```javascript:test\fs\test-fs-copyfile.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import { internalBinding } from 'internal/test/binding';
const {
  UV_ENOENT,
  UV_EEXIST
} = internalBinding('uv');
import path from 'path';
const src = fixtures.path('a.js');
const dest = path.join(tmpdir.path, 'copyfile.out');
const {
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
  UV_FS_COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE
} = fs.constants;

function verify(src, dest) {
  const srcData = fs.readFileSync(src, 'utf8');
  const srcStat = fs.statSync(src);
  const destData = fs.readFileSync(dest, 'utf8');
  const destStat = fs.statSync(dest);

  assert.strictEqual(srcData, destData);
  assert.strictEqual(srcStat.mode, destStat.mode);
  assert.strictEqual(srcStat.size, destStat.size);
}

tmpdir.refresh();

// Verify that flags are defined.
assert.strictEqual(typeof COPYFILE_EXCL, 'number');
assert.strictEqual(typeof COPYFILE_FICLONE, 'number');
assert.strictEqual(typeof COPYFILE_FICLONE_FORCE, 'number');
assert.strictEqual(typeof UV_FS_COPYFILE_EXCL, 'number');
assert.strictEqual(typeof UV_FS_COPYFILE_FICLONE, 'number');
assert.strictEqual(typeof UV_FS_COPYFILE_FICLONE_FORCE, 'number');
assert.strictEqual(COPYFILE_EXCL, UV_FS_COPYFILE_EXCL);
assert.strictEqual(COPYFILE_FICLONE, UV_FS_COPYFILE_FICLONE);
assert.strictEqual(COPYFILE_FICLONE_FORCE, UV_FS_COPYFILE_FICLONE_FORCE);

// Verify that files are overwritten when no flags are provided.
fs.writeFileSync(dest, '', 'utf8');
const result = fs.copyFileSync(src, dest);
assert.strictEqual(result, undefined);
verify(src, dest);

// Verify that files are overwritten with default flags.
fs.copyFileSync(src, dest, 0);
verify(src, dest);

// Verify that UV_FS_COPYFILE_FICLONE can be used.
fs.unlinkSync(dest);
fs.copyFileSync(src, dest, UV_FS_COPYFILE_FICLONE);
verify(src, dest);

// Verify that COPYFILE_FICLONE_FORCE can be used.
try {
  fs.unlinkSync(dest);
  fs.copyFileSync(src, dest, COPYFILE_FICLONE_FORCE);
  verify(src, dest);
} catch (err) {
  assert.strictEqual(err.syscall, 'copyfile');
  assert(err.code === 'ENOTSUP' || err.code === 'ENOTTY' ||
    err.code === 'ENOSYS' || err.code === 'EXDEV');
  assert.strictEqual(err.path, src);
  assert.strictEqual(err.dest, dest);
}

// Copies asynchronously.
tmpdir.refresh(); // Don't use unlinkSync() since the last test may fail.
fs.copyFile(src, dest, common.mustSucceed(() => {
  verify(src, dest);

  // Copy asynchronously with flags.
  fs.copyFile(src, dest, COPYFILE_EXCL, common.mustCall((err) => {
    if (err.code === 'ENOENT') {  // Could be ENOENT or EEXIST
      assert.strictEqual(err.message,
                         'ENOENT: no such file or directory, copyfile ' +
                         `'${src}' -> '${dest}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
      assert.strictEqual(err.syscall, 'copyfile');
    } else {
      assert.strictEqual(err.message,
                         'EEXIST: file already exists, copyfile ' +
                         `'${src}' -> '${dest}'`);
      assert.strictEqual(err.errno, UV_EEXIST);
      assert.strictEqual(err.code, 'EEXIST');
      assert.strictEqual(err.syscall, 'copyfile');
    }
  }));
}));

// Throws if callback is not a function.
assert.throws(() => {
  fs.copyFile(src, dest, 0, 0);
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
});

// Throws if the source path is not a string.
[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.copyFile(i, dest, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /src/
    }
  );
  assert.throws(
    () => fs.copyFile(src, i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /dest/
    }
  );
  assert.throws(
    () => fs.copyFileSync(i, dest),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /src/
    }
  );
  assert.throws(
    () => fs.copyFileSync(src, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /dest/
    }
  );
});

assert.throws(() => {
  fs.copyFileSync(src, dest, 'r');
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: /mode/
});

assert.throws(() => {
  fs.copyFileSync(src, dest, 8);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""mode"" is out of range. It must be an integer ' +
           '>= 0 && <= 7. Received 8'
});

assert.throws(() => {
  fs.copyFile(src, dest, 'r', common.mustNotCall());
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: /mode/
});

```"
"```javascript:test\fs\test-fs-open-flags.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Flags: --expose-internals
'use strict';
import common from '../common';

import fixtures from '../common/fixtures';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

// 0 if not found in fs.constants
const { O_APPEND = 0,
        O_CREAT = 0,
        O_EXCL = 0,
        O_RDONLY = 0,
        O_RDWR = 0,
        O_SYNC = 0,
        O_DSYNC = 0,
        O_TRUNC = 0,
        O_WRONLY = 0 } = fs.constants;

import { stringToFlags } from 'internal/fs/utils';

assert.strictEqual(stringToFlags('r'), O_RDONLY);
assert.strictEqual(stringToFlags('r+'), O_RDWR);
assert.strictEqual(stringToFlags('rs+'), O_RDWR | O_SYNC);
assert.strictEqual(stringToFlags('sr+'), O_RDWR | O_SYNC);
assert.strictEqual(stringToFlags('w'), O_TRUNC | O_CREAT | O_WRONLY);
assert.strictEqual(stringToFlags('w+'), O_TRUNC | O_CREAT | O_RDWR);
assert.strictEqual(stringToFlags('a'), O_APPEND | O_CREAT | O_WRONLY);
assert.strictEqual(stringToFlags('a+'), O_APPEND | O_CREAT | O_RDWR);

assert.strictEqual(stringToFlags('wx'), O_TRUNC | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('xw'), O_TRUNC | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('wx+'), O_TRUNC | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('xw+'), O_TRUNC | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('ax'), O_APPEND | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('xa'), O_APPEND | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('as'), O_APPEND | O_CREAT | O_WRONLY | O_SYNC);
assert.strictEqual(stringToFlags('sa'), O_APPEND | O_CREAT | O_WRONLY | O_SYNC);
assert.strictEqual(stringToFlags('ax+'), O_APPEND | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('xa+'), O_APPEND | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('as+'), O_APPEND | O_CREAT | O_RDWR | O_SYNC);
assert.strictEqual(stringToFlags('sa+'), O_APPEND | O_CREAT | O_RDWR | O_SYNC);

('+ +a +r +w rw wa war raw r++ a++ w++ x +x x+ rx rx+ wxx wax xwx xxx')
  .split(' ')
  .forEach(function(flags) {
    assert.throws(
      () => stringToFlags(flags),
      { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
    );
  });

assert.throws(
  () => stringToFlags({}),
  { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
);

assert.throws(
  () => stringToFlags(true),
  { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
);

import tmpdir from '../common/tmpdir';

if (common.isLinux || common.isOSX) {
  tmpdir.refresh();
  const file = path.join(tmpdir.path, 'a.js');
  fs.copyFileSync(fixtures.path('a.js'), file);
  fs.open(file, O_DSYNC, common.mustSucceed((fd) => {
    fs.closeSync(fd);
  }));
}

```"
"```javascript:test\fs\test-fs-promises-file-handle-read.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.read method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

async function read(fileHandle, buffer, offset, length, position, options) {
  return options.useConf ?
    fileHandle.read({ buffer, offset, length, position }) :
    fileHandle.read(buffer, offset, length, position);
}

async function validateRead(data, file, options) {
  const filePath = path.resolve(tmpDir, file);
  const buffer = Buffer.from(data, 'utf8');

  const fd = fs.openSync(filePath, 'w+');
  const fileHandle = await open(filePath, 'w+');
  const streamFileHandle = await open(filePath, 'w+');

  fs.writeSync(fd, buffer, 0, buffer.length);
  fs.closeSync(fd);

  fileHandle.on('close', common.mustCall());
  const readAsyncHandle =
    await read(fileHandle, Buffer.alloc(11), 0, 11, 0, options);
  assert.deepStrictEqual(data.length, readAsyncHandle.bytesRead);
  if (data.length)
    assert.deepStrictEqual(buffer, readAsyncHandle.buffer);
  await fileHandle.close();

  const stream = fs.createReadStream(null, { fd: streamFileHandle });
  let streamData = Buffer.alloc(0);
  for await (const chunk of stream)
    streamData = Buffer.from(chunk);
  assert.deepStrictEqual(buffer, streamData);
  if (data.length)
    assert.deepStrictEqual(streamData, readAsyncHandle.buffer);
  await streamFileHandle.close();
}

async function validateLargeRead(options) {
  // Reading beyond file length (3 in this case) should return no data.
  // This is a test for a bug where reads > uint32 would return data
  // from the current position in the file.
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  const pos = 0xffffffff + 1; // max-uint32 + 1
  const readHandle =
    await read(fileHandle, Buffer.alloc(1), 0, 1, pos, options);

  assert.strictEqual(readHandle.bytesRead, 0);
}

async function validateReadNoParams() {
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  // Should not throw
  await fileHandle.read();
}

// Validates that the zero position is respected after the position has been
// moved. The test iterates over the xyz chars twice making sure that the values
// are read from the correct position.
async function validateReadWithPositionZero() {
  const opts = { useConf: true };
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  const expectedSequence = ['x', 'y', 'z'];

  for (let i = 0; i < expectedSequence.length * 2; i++) {
    const len = 1;
    const pos = i % 3;
    const buf = Buffer.alloc(len);
    const { bytesRead } = await read(fileHandle, buf, 0, len, pos, opts);
    assert.strictEqual(bytesRead, len);
    assert.strictEqual(buf.toString(), expectedSequence[pos]);
  }
}

async function validateReadLength(len) {
  const buf = Buffer.alloc(4);
  const opts = { useConf: true };
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  const { bytesRead } = await read(fileHandle, buf, 0, len, 0, opts);
  assert.strictEqual(bytesRead, len);
}


(async function () {
  tmpdir.refresh();
  await validateRead('Hello world', 'read-file', { useConf: false });
  await validateRead('', 'read-empty-file', { useConf: false });
  await validateRead('Hello world', 'read-file-conf', { useConf: true });
  await validateRead('', 'read-empty-file-conf', { useConf: true });
  await validateLargeRead({ useConf: false });
  await validateLargeRead({ useConf: true });
  await validateReadNoParams();
  await validateReadWithPositionZero();
  await validateReadLength(0);
  await validateReadLength(1);
})().then(common.mustCall());

```"
"```javascript:test\crypto\test-crypto-secret-keygen.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const {
  generateKey,
  generateKeySync
} = require('crypto');

[1, true, [], {}, Infinity, null, undefined].forEach((i) => {
  assert.throws(() => generateKey(i, 1, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""type"" argument must be /
  });
  assert.throws(() => generateKeySync(i, 1), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""type"" argument must be /
  });
});

['', true, [], null, undefined].forEach((i) => {
  assert.throws(() => generateKey('aes', i, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options"" argument must be /
  });
  assert.throws(() => generateKeySync('aes', i), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options"" argument must be /
  });
});

['', true, {}, [], null, undefined].forEach((length) => {
  assert.throws(() => generateKey('hmac', { length }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options\.length"" property must be /
  });
  assert.throws(() => generateKeySync('hmac', { length }), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options\.length"" property must be /
  });
});

assert.throws(() => generateKey('aes', { length: 256 }), {
  code: 'ERR_INVALID_ARG_TYPE'
});

assert.throws(() => generateKey('hmac', { length: -1 }, common.mustNotCall()), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKey('hmac', { length: 4 }, common.mustNotCall()), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKey('hmac', { length: 7 }, common.mustNotCall()), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(
  () => generateKey('hmac', { length: 2 ** 31 }, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE'
  });

assert.throws(() => generateKeySync('hmac', { length: -1 }), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKeySync('hmac', { length: 4 }), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKeySync('hmac', { length: 7 }), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(
  () => generateKeySync('hmac', { length: 2 ** 31 }), {
    code: 'ERR_OUT_OF_RANGE'
  });

assert.throws(() => generateKeySync('aes', { length: 123 }), {
  code: 'ERR_INVALID_ARG_VALUE',
  message: /The property 'options\.length' must be one of: 128, 192, 256/
});

{
  const key = generateKeySync('aes', { length: 128 });
  assert(key);
  const keybuf = key.export();
  assert.strictEqual(keybuf.byteLength, 128 / 8);

  generateKey('aes', { length: 128 }, common.mustSucceed((key) => {
    assert(key);
    const keybuf = key.export();
    assert.strictEqual(keybuf.byteLength, 128 / 8);
  }));
}

{
  const key = generateKeySync('aes', { length: 256 });
  assert(key);
  const keybuf = key.export();
  assert.strictEqual(keybuf.byteLength, 256 / 8);

  generateKey('aes', { length: 256 }, common.mustSucceed((key) => {
    assert(key);
    const keybuf = key.export();
    assert.strictEqual(keybuf.byteLength, 256 / 8);
  }));
}

{
  const key = generateKeySync('hmac', { length: 123 });
  assert(key);
  const keybuf = key.export();
  assert.strictEqual(keybuf.byteLength, Math.floor(123 / 8));

  generateKey('hmac', { length: 123 }, common.mustSucceed((key) => {
    assert(key);
    const keybuf = key.export();
    assert.strictEqual(keybuf.byteLength, Math.floor(123 / 8));
  }));
}

assert.throws(
  () => generateKey('unknown', { length: 123 }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_VALUE',
    message: /The argument 'type' must be a supported key type/
  });

assert.throws(() => generateKeySync('unknown', { length: 123 }), {
  code: 'ERR_INVALID_ARG_VALUE',
  message: /The argument 'type' must be a supported key type/
});

```"
"```javascript:test\fs\test-fs-promises-watch.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import { watch } from 'fs/promises';
import fs from 'fs';
import assert from 'assert';
import { join } from 'path';
import tmpdir from '../common/tmpdir';

class WatchTestCase {
  constructor(shouldInclude, dirName, fileName, field) {
    this.dirName = dirName;
    this.fileName = fileName;
    this.field = field;
    this.shouldSkip = !shouldInclude;
  }
  get dirPath() { return join(tmpdir.path, this.dirName); }
  get filePath() { return join(this.dirPath, this.fileName); }
}

const kCases = [
  // Watch on a directory should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows || common.isAIX,
    'watch1',
    'foo',
    'filePath'
  ),
  // Watch on a file should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows,
    'watch2',
    'bar',
    'dirPath'
  ),
];

tmpdir.refresh();

for (const testCase of kCases) {
  if (testCase.shouldSkip) continue;
  fs.mkdirSync(testCase.dirPath);
  // Long content so it's actually flushed.
  const content1 = Date.now() + testCase.fileName.toLowerCase().repeat(1e4);
  fs.writeFileSync(testCase.filePath, content1);

  let interval;
  async function test() {
    const watcher = watch(testCase[testCase.field]);
    for await (const { eventType, filename } of watcher) {
      clearInterval(interval);
      assert.strictEqual(['rename', 'change'].includes(eventType), true);
      assert.strictEqual(filename, testCase.fileName);
      break;
    }

    // Waiting on it again is a non-op
    // eslint-disable-next-line no-unused-vars
    for await (const p of watcher) {
      assert.fail('should not run');
    }
  }

  // Long content so it's actually flushed. toUpperCase so there's real change.
  const content2 = Date.now() + testCase.fileName.toUpperCase().repeat(1e4);
  interval = setInterval(() => {
    fs.writeFileSync(testCase.filePath, '');
    fs.writeFileSync(testCase.filePath, content2);
  }, 100);

  test().then(common.mustCall());
}

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch(1)) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch(__filename, 1)) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { persistent: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { recursive: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { encoding: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_VALUE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { signal: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

(async () => {
  const ac = new AbortController();
  const { signal } = ac;
  setImmediate(() => ac.abort());
  try {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch(__filename, { signal })) { }
  } catch (err) {
    assert.strictEqual(err.name, 'AbortError');
  }
})().then(common.mustCall());

```"
"```javascript:test\crypto\test-crypto-certificate.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { Certificate } = crypto;
const fixtures = require('../common/fixtures');

// Test Certificates
const spkacValid = fixtures.readKey('rsa_spkac.spkac');
const spkacChallenge = 'this-is-a-challenge';
const spkacFail = fixtures.readKey('rsa_spkac_invalid.spkac');
const spkacPublicPem = fixtures.readKey('rsa_public.pem');

function copyArrayBuffer(buf) {
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

function checkMethods(certificate) {

  assert.strictEqual(certificate.verifySpkac(spkacValid), true);
  assert.strictEqual(certificate.verifySpkac(spkacFail), false);

  assert.strictEqual(
    stripLineEndings(certificate.exportPublicKey(spkacValid).toString('utf8')),
    stripLineEndings(spkacPublicPem.toString('utf8'))
  );
  assert.strictEqual(certificate.exportPublicKey(spkacFail), '');

  assert.strictEqual(
    certificate.exportChallenge(spkacValid).toString('utf8'),
    spkacChallenge
  );
  assert.strictEqual(certificate.exportChallenge(spkacFail), '');

  const ab = copyArrayBuffer(spkacValid);
  assert.strictEqual(certificate.verifySpkac(ab), true);
  assert.strictEqual(certificate.verifySpkac(new Uint8Array(ab)), true);
  assert.strictEqual(certificate.verifySpkac(new DataView(ab)), true);
}

{
  // Test maximum size of input buffer
  let buf;
  let skip = false;
  try {
    buf = Buffer.alloc(2 ** 31);
  } catch {
    // The allocation may fail on some systems. That is expected due
    // to architecture and memory constraints. If it does, go ahead
    // and skip this test.
    skip = true;
  }
  if (!skip) {
    assert.throws(
      () => Certificate.verifySpkac(buf), {
        code: 'ERR_OUT_OF_RANGE'
      });
    assert.throws(
      () => Certificate.exportChallenge(buf), {
        code: 'ERR_OUT_OF_RANGE'
      });
    assert.throws(
      () => Certificate.exportPublicKey(buf), {
        code: 'ERR_OUT_OF_RANGE'
      });
  }
}

{
  // Test instance methods
  checkMethods(new Certificate());
}

{
  // Test static methods
  checkMethods(Certificate);
}

function stripLineEndings(obj) {
  return obj.replace(/\n/g, '');
}

// Direct call Certificate() should return instance
assert(Certificate() instanceof Certificate);

[1, {}, [], Infinity, true, undefined, null].forEach((val) => {
  assert.throws(
    () => Certificate.verifySpkac(val),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
});

[1, {}, [], Infinity, true, undefined, null].forEach((val) => {
  const errObj = { code: 'ERR_INVALID_ARG_TYPE' };
  assert.throws(() => Certificate.exportPublicKey(val), errObj);
  assert.throws(() => Certificate.exportChallenge(val), errObj);
});

```"
"```javascript:modules\internal\crypto\hash.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import {
  getArrayBufferOrView,
  getDefaultEncoding,
  getStringOption,
  jobPromise,
  normalizeAlgorithm,
  normalizeHashName,
  validateMaxBufferLength,
  kHandle,
  getHashes,
} from '../crypto/util';

import {
  prepareSecretKey,
} from '../crypto/keys';

import {
  lazyDOMException,
} from '../util';

import {
  Buffer,
} from '../../buffer';

import {
  ERR_CRYPTO_HASH_FINALIZED,
  ERR_CRYPTO_HASH_UPDATE_FAILED,
  ERR_INVALID_ARG_TYPE,
} from '../errors';

import {
  validateEncoding,
  validateString,
  validateUint32,
} from '../validators';

import {
  isArrayBufferView,
} from '../util/types';

import { LazyTransform } from '../streams/lazy_transform';

const kState = Symbol('kState');
const kFinalized = Symbol('kFinalized');

import {
  JsHash as _Hash,
  JsHmac as _Hmac,
} from ""_node:crypto"";

function Hash(algorithm, options) {
  if (!(this instanceof Hash))
    return new Hash(algorithm, options);
  if (!(algorithm instanceof _Hash)) {
    validateString(algorithm, 'algorithm');
    if (!getHashes().includes(algorithm.toLowerCase())) {
      throw new Error(""Digest method not supported"");
    }
  }
  const xofLen = typeof options === 'object' && options !== null ?
    options.outputLength : undefined;
  if (xofLen !== undefined)
    validateUint32(xofLen, 'options.outputLength');
  this[kHandle] = new _Hash(algorithm, xofLen);
  this[kState] = {
    [kFinalized]: false
  };
  Reflect.apply(LazyTransform, this, [options]);
}

Object.setPrototypeOf(Hash.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Hash, LazyTransform);

Hash.prototype.copy = function copy(options) {
  const state = this[kState];
  if (state[kFinalized])
    throw new ERR_CRYPTO_HASH_FINALIZED();

  return new Hash(this[kHandle], options);
};

Hash.prototype._transform = function _transform(chunk, encoding, callback) {
  this.update(chunk, encoding);
  callback();
};

Hash.prototype._flush = function _flush(callback) {
  this.push(this.digest());
  callback();
};

Hash.prototype.update = function update(data, encoding) {
  encoding = encoding || getDefaultEncoding();

  const state = this[kState];
  if (state[kFinalized])
    throw new ERR_CRYPTO_HASH_FINALIZED();

  if (typeof data === 'string') {
    validateEncoding(data, encoding);
  } else if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data', ['string', 'Buffer', 'TypedArray', 'DataView'], data);
  }
  let buffer = getArrayBufferOrView(data, ""data"", encoding);
  if (!this[kHandle].update(buffer.buffer ?? buffer))
    throw new ERR_CRYPTO_HASH_UPDATE_FAILED();
  return this;
};


Hash.prototype.digest = function digest(outputEncoding) {
  const state = this[kState];
  if (state[kFinalized])
    throw new ERR_CRYPTO_HASH_FINALIZED();
  outputEncoding = outputEncoding || getDefaultEncoding();

  // Explicit conversion for backward compatibility.
  const ret = Buffer.from(this[kHandle].digest());
  state[kFinalized] = true;
  return outputEncoding === 'buffer' ? ret : ret.toString(outputEncoding);
};

function Hmac(hmac, key, options) {
  if (!(this instanceof Hmac))
    return new Hmac(hmac, key, options);
  validateString(hmac, 'hmac');
  if (!getHashes().includes(hmac.toLowerCase())) {
    throw new Error(""Digest method not supported"");
  }
  const encoding = getStringOption(options, 'encoding');
  key = prepareSecretKey(key, encoding);
  if (key.export !== undefined) {
    key = key.export();
  }
  this[kHandle] = new _Hmac(hmac, key.buffer ?? key);
  this[kState] = {
    [kFinalized]: false
  };
  Reflect.apply(LazyTransform, this, [options]);
}

Object.setPrototypeOf(Hmac.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Hmac, LazyTransform);

Hmac.prototype.update = Hash.prototype.update;

Hmac.prototype.digest = function digest(outputEncoding) {
  const state = this[kState];
  outputEncoding = outputEncoding || getDefaultEncoding();

  if (state[kFinalized]) {
    const buf = Buffer.from('');
    return outputEncoding === 'buffer' ? buf : buf.toString(outputEncoding);
  }

  // Explicit conversion for backward compatibility.
  const ret = Buffer.from(this[kHandle].digest());
  state[kFinalized] = true;
  return outputEncoding === 'buffer' ? ret : ret.toString(outputEncoding);;
};

Hmac.prototype._flush = Hash.prototype._flush;
Hmac.prototype._transform = Hash.prototype._transform;

// Implementation for WebCrypto subtle.digest()

export {
  Hash,
  Hmac,
};

```"
"```javascript:test\fs\test-fs-write-optional-params.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// This test ensures that fs.write accepts ""named parameters"" object
// and doesn't interpret objects as strings

import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';
import util from 'util';

tmpdir.refresh();

const destInvalid = path.resolve(tmpdir.path, 'rwopt_invalid');
const buffer = Buffer.from('zyx');

function testInvalidCb(fd, expectedCode, buffer, options, callback) {
  assert.throws(
    () => fs.write(fd, buffer, common.mustNotMutateObjectDeep(options), common.mustNotCall()),
    { code: expectedCode }
  );
  callback(0);
}

function testValidCb(buffer, options, index, callback) {
  options = common.mustNotMutateObjectDeep(options);
  const length = options?.length;
  const offset = options?.offset;
  const dest = path.resolve(tmpdir.path, `rwopt_valid_${index}`);
  fs.open(dest, 'w+', common.mustSucceed((fd) => {
    fs.write(fd, buffer, options, common.mustSucceed((bytesWritten, bufferWritten) => {
      bufferWritten = new Uint8Array(bufferWritten);
      const writeBufCopy = Uint8Array.prototype.slice.call(bufferWritten);

      fs.read(fd, buffer, options, common.mustSucceed((bytesRead, bufferRead) => {
        bufferRead = new Uint8Array(bufferRead);
        const readBufCopy = Uint8Array.prototype.slice.call(bufferRead);

        assert.ok(bytesWritten >= bytesRead);
        if (length !== undefined && length !== null) {
          assert.strictEqual(bytesWritten, length);
        }
        if (offset === undefined || offset === 0) {
          assert.deepStrictEqual(writeBufCopy, readBufCopy);
        }
        assert.deepStrictEqual(bufferWritten, bufferRead);
        fs.close(fd, common.mustSucceed(callback));
      }));
    }));
  }));
}

// Promisify to reduce flakiness
const testInvalid = util.promisify(testInvalidCb);
const testValid = util.promisify(testValidCb);

async function runTests(fd) {
  // Test if first argument is not wrongly interpreted as ArrayBufferView|string
  for (const badBuffer of [
    undefined, null, true, 42, 42n, Symbol('42'), NaN, [], () => { },
    Promise.resolve(new Uint8Array(1)),
    common.mustNotCall(),
    common.mustNotMutateObjectDeep({}),
    {},
    { buffer: 'amNotParam' },
    { string: 'amNotParam' },
    { buffer: new Uint8Array(1).buffer },
    new Date(),
    new String('notPrimitive'),
    { [Symbol.toPrimitive]: (hint) => 'amObject' },

    // TODO(LiviaMedeiros): add the following after DEP0162 EOL
    // { toString() { return 'amObject'; } },
  ]) {
    await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', badBuffer, {});
  }

  // First argument (buffer or string) is mandatory
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', undefined, undefined);

  // Various invalid options
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { length: 5 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { offset: 5 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { length: 1, offset: 3 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { length: -1 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { offset: -1 });
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, { offset: false });
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, { offset: true });
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, true);
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, '42');
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, Symbol('42'));

  // Test compatibility with fs.read counterpart
  for (const [index, options] of [
    null,
    {},
    { length: 1 },
    { position: 5 },
    { length: 1, position: 5 },
    { length: 1, position: -1, offset: 2 },
    { length: null },
    { position: null },
    { offset: 1 },
  ].entries()) {
    await testValid(buffer, options, index);
  }
}

fs.open(destInvalid, 'w+', common.mustSucceed(async (fd) => {
  runTests(fd).then(common.mustCall(() => fs.close(fd, common.mustSucceed())));
}));

```"
"```javascript:test\fs\test-fs-append-file-sync.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import { join } from 'path';
import fs from 'fs';

const currentFileData = 'ABCD';
const m = 0o600;
const num = 220;
const data = '���������������203���������111���������������������������������������������������������������������������������������������������' +
             '������������������������������������������������������������������������������������������������������������������' +
             '���������������������������������������������������������203���������������������������������������������' +
             '���196���������179������������������������������������������������������������������������������������������112������' +
             '������������������������������������������������������������������������111������������������������������93������' +
             '���������������������������������������������������������������������������������������������������������������������������������' +
             '���������������������������������������������������������������������������������������������������������������������##������������\n';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test that empty file will be created and have content added.
const filename = join(tmpdir.path, 'append-sync.txt');

fs.appendFileSync(filename, data);

const fileData = fs.readFileSync(filename);

assert.strictEqual(Buffer.byteLength(data), fileData.length);

// Test that appends data to a non empty file.
const filename2 = join(tmpdir.path, 'append-sync2.txt');
fs.writeFileSync(filename2, currentFileData);

fs.appendFileSync(filename2, data);

const fileData2 = fs.readFileSync(filename2);

assert.strictEqual(Buffer.byteLength(data) + currentFileData.length,
                   fileData2.length);

// Test that appendFileSync accepts buffers.
const filename3 = join(tmpdir.path, 'append-sync3.txt');
fs.writeFileSync(filename3, currentFileData);

const buf = Buffer.from(data, 'utf8');
fs.appendFileSync(filename3, buf);

const fileData3 = fs.readFileSync(filename3);

assert.strictEqual(buf.length + currentFileData.length, fileData3.length);

const filename4 = join(tmpdir.path, 'append-sync4.txt');
fs.writeFileSync(filename4, currentFileData, common.mustNotMutateObjectDeep({ mode: m }));

[
  true, false, 0, 1, Infinity, () => {}, {}, [], undefined, null,
].forEach((value) => {
  assert.throws(
    () => fs.appendFileSync(filename4, value, common.mustNotMutateObjectDeep({ mode: m })),
    { message: /data/, code: 'ERR_INVALID_ARG_TYPE' }
  );
});
fs.appendFileSync(filename4, `${num}`, common.mustNotMutateObjectDeep({ mode: m }));

// Windows permissions aren't Unix.
if (!common.isWindows) {
  const st = fs.statSync(filename4);
  assert.strictEqual(st.mode & 0o700, m);
}

const fileData4 = fs.readFileSync(filename4);

assert.strictEqual(Buffer.byteLength(String(num)) + currentFileData.length,
                   fileData4.length);

// Test that appendFile accepts file descriptors.
const filename5 = join(tmpdir.path, 'append-sync5.txt');
fs.writeFileSync(filename5, currentFileData);

const filename5fd = fs.openSync(filename5, 'a+', 0o600);
fs.appendFileSync(filename5fd, data);
fs.closeSync(filename5fd);

const fileData5 = fs.readFileSync(filename5);

assert.strictEqual(Buffer.byteLength(data) + currentFileData.length,
                   fileData5.length);

```"
"```javascript:test\fs\test-fs-write-file.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = join(tmpdir.path, 'test.txt');

const s = '���������������203���������111���������������������������������������������������������������������������������������������������' +
          '������������������������������������������������������������������������������������������������������������������' +
          '���������������������������������������������������������203���������������������������������������������' +
          '���196���������179������������������������������������������������������������������������������������������112������' +
          '������������������������������������������������������������������������111������������������������������93������' +
          '���������������������������������������������������������������������������������������������������������������������������������' +
          '���������������������������������������������������������������������������������������������������������������������##������������\n';

fs.writeFile(filename, s, common.mustSucceed(() => {
  fs.readFile(filename, common.mustSucceed((buffer) => {
    assert.strictEqual(Buffer.byteLength(s), buffer.length);
  }));
}));

// Test that writeFile accepts buffers.
const filename2 = join(tmpdir.path, 'test2.txt');
const buf = Buffer.from(s, 'utf8');

fs.writeFile(filename2, buf, common.mustSucceed(() => {
  fs.readFile(filename2, common.mustSucceed((buffer) => {
    assert.strictEqual(buf.length, buffer.length);
  }));
}));

// Test that writeFile accepts file descriptors.
const filename4 = join(tmpdir.path, 'test4.txt');

fs.open(filename4, 'w+', common.mustSucceed((fd) => {
  fs.writeFile(fd, s, common.mustSucceed(() => {
    fs.close(fd, common.mustSucceed(() => {
      fs.readFile(filename4, common.mustSucceed((buffer) => {
        assert.strictEqual(Buffer.byteLength(s), buffer.length);
      }));
    }));
  }));
}));

/* unsupport AbortController
{
  // Test that writeFile is cancellable with an AbortSignal.
  // Before the operation has started
  const controller = new AbortController();
  const signal = controller.signal;
  const filename3 = join(tmpdir.path, 'test3.txt');

  fs.writeFile(filename3, s, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));

  controller.abort();
}

{
  // Test that writeFile is cancellable with an AbortSignal.
  // After the operation has started
  const controller = new AbortController();
  const signal = controller.signal;
  const filename4 = join(tmpdir.path, 'test5.txt');

  fs.writeFile(filename4, s, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));

  process.nextTick(() => controller.abort());
}

{
  // Test read-only mode
  const filename = join(tmpdir.path, 'test6.txt');
  fs.writeFileSync(filename, '');
  fs.writeFile(filename, s, { flag: 'r' }, common.expectsError(/EBADF/));
}
*/
```"
"```javascript:test\crypto\test-crypto-authenticated-stream.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
// Refs: https://github.com/nodejs/node/issues/31733
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const stream = require('stream');
const tmpdir = require('../common/tmpdir');

class Sink extends stream.Writable {
  constructor() {
    super();
    this.chunks = [];
  }

  _write(chunk, encoding, cb) {
    this.chunks.push(chunk);
    cb();
  }
}

function direct(config) {
  const { cipher, key, iv, aad, authTagLength, plaintextLength } = config;
  const expected = Buffer.alloc(plaintextLength);

  const c = crypto.createCipheriv(cipher, key, iv, { authTagLength });
  c.setAAD(aad, { plaintextLength });
  const ciphertext = Buffer.concat([c.update(expected), c.final()]);

  const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
  d.setAAD(aad, { plaintextLength });
  d.setAuthTag(c.getAuthTag());
  const actual = Buffer.concat([d.update(ciphertext), d.final()]);

  assert.deepStrictEqual(expected, actual);
}

function mstream(config) {
  const { cipher, key, iv, aad, authTagLength, plaintextLength } = config;
  const expected = Buffer.alloc(plaintextLength);

  const c = crypto.createCipheriv(cipher, key, iv, { authTagLength });
  c.setAAD(aad, { plaintextLength });

  const plain = new stream.PassThrough();
  const crypt = new Sink();
  const chunks = crypt.chunks;
  plain.pipe(c).pipe(crypt);
  plain.end(expected);

  crypt.on('close', common.mustCall(() => {
    const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
    d.setAAD(aad, { plaintextLength });
    d.setAuthTag(c.getAuthTag());

    const crypt = new stream.PassThrough();
    const plain = new Sink();
    crypt.pipe(d).pipe(plain);
    for (const chunk of chunks) crypt.write(chunk);
    crypt.end();

    plain.on('close', common.mustCall(() => {
      const actual = Buffer.concat(plain.chunks);
      assert.deepStrictEqual(expected, actual);
    }));
  }));
}

function fstream(config) {
  const count = fstream.count++;
  const filename = (name) => path.join(tmpdir.path, `${name}${count}`);

  const { cipher, key, iv, aad, authTagLength, plaintextLength } = config;
  const expected = Buffer.alloc(plaintextLength);
  fs.writeFileSync(filename('a'), expected);

  const c = crypto.createCipheriv(cipher, key, iv, { authTagLength });
  c.setAAD(aad, { plaintextLength });

  const plain = fs.createReadStream(filename('a'));
  const crypt = fs.createWriteStream(filename('b'));
  plain.pipe(c).pipe(crypt);

  // Observation: 'close' comes before 'end' on |c|, which definitely feels
  // wrong. Switching to `c.on('end', ...)` doesn't fix the test though.
  crypt.on('close', common.mustCall(() => {
    // Just to drive home the point that decryption does actually work:
    // reading the file synchronously, then decrypting it, works.
    {
      const ciphertext = fs.readFileSync(filename('b'));
      const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
      d.setAAD(aad, { plaintextLength });
      d.setAuthTag(c.getAuthTag());
      const actual = Buffer.concat([d.update(ciphertext), d.final()]);
      assert.deepStrictEqual(expected, actual);
    }

    const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
    d.setAAD(aad, { plaintextLength });
    d.setAuthTag(c.getAuthTag());

    const crypt = fs.createReadStream(filename('b'));
    const plain = fs.createWriteStream(filename('c'));
    crypt.pipe(d).pipe(plain);

    plain.on('close', common.mustCall(() => {
      const actual = fs.readFileSync(filename('c'));
      assert.deepStrictEqual(expected, actual);
    }));
  }));
}
fstream.count = 0;

function test(config) {
  direct(config);
  mstream(config);
  fstream(config);
}

tmpdir.refresh();

test({
  cipher: 'aes-128-ccm',
  aad: Buffer.alloc(1),
  iv: Buffer.alloc(8),
  key: Buffer.alloc(16),
  authTagLength: 16,
  plaintextLength: 32768,
});

test({
  cipher: 'aes-128-ccm',
  aad: Buffer.alloc(1),
  iv: Buffer.alloc(8),
  key: Buffer.alloc(16),
  authTagLength: 16,
  plaintextLength: 32769,
});

```"
"```javascript:test\fs\test-fs-watchfile.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

// Basic usage tests.
assert.throws(
  () => {
    fs.watchFile('./some-file');
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.watchFile('./another-file', {}, 'bad listener');
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(() => {
  fs.watchFile(new Object(), common.mustNotCall());
}, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });

const enoentFile = path.join(tmpdir.path, 'non-existent-file');
const expectedStatObject = new fs.Stats(
  0,                                        // dev
  0,                                        // mode
  0,                                        // nlink
  0,                                        // uid
  0,                                        // gid
  0,                                        // rdev
  0,                                        // blksize
  0,                                        // ino
  0,                                        // size
  0,                                        // blocks
  Date.UTC(1970, 0, 1, 0, 0, 0),            // atime
  Date.UTC(1970, 0, 1, 0, 0, 0),            // mtime
  Date.UTC(1970, 0, 1, 0, 0, 0),            // ctime
  Date.UTC(1970, 0, 1, 0, 0, 0)             // birthtime
);

tmpdir.refresh();

// If the file initially didn't exist, and gets created at a later point of
// time, the callback should be invoked again with proper values in stat object
let fileExists = false;

const watcher =
  fs.watchFile(enoentFile, { interval: 0 }, common.mustCall((curr, prev) => {
    if (!fileExists) {
      // If the file does not exist, all the fields should be zero and the date
      // fields should be UNIX EPOCH time
      assert.deepStrictEqual(curr, expectedStatObject);
      assert.deepStrictEqual(prev, expectedStatObject);
      // Create the file now, so that the callback will be called back once the
      // event loop notices it.
      fs.closeSync(fs.openSync(enoentFile, 'w'));
      fileExists = true;
    } else {
      // If the ino (inode) value is greater than zero, it means that the file
      // is present in the filesystem and it has a valid inode number.
      assert(curr.ino > 0);
      // As the file just got created, previous ino value should be lesser than
      // or equal to zero (non-existent file).
      assert(prev.ino <= 0);
      // Stop watching the file
      fs.unwatchFile(enoentFile);
      watcher.stop();  // Stopping a stopped watcher should be a noop
    }
  }, 2));

// 'stop' should only be emitted once - stopping a stopped watcher should
// not trigger a 'stop' event.
watcher.on('stop', common.mustCall(function onStop() {}));

// Watch events should callback with a filename on supported systems.
// Omitting AIX. It works but not reliably.
if (common.isLinux || common.isOSX || common.isWindows) {
  const dir = path.join(tmpdir.path, 'watch');

  fs.mkdir(dir, common.mustCall(function(err) {
    if (err) assert.fail(err);

    fs.watch(dir, common.mustCall(function(eventType, filename) {
      clearInterval(interval);
      this._handle.close();
      assert.strictEqual(filename, 'foo.txt');
    }));

    const interval = setInterval(() => {
      fs.writeFile(path.join(dir, 'foo.txt'), 'foo', common.mustCall((err) => {
        if (err) assert.fail(err);
      }));
    }, 1);
  }));
}

```"
"```javascript:test\crypto\test-crypto-dh-padding.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('node compiled without OpenSSL.');

const assert = require('assert');
const crypto = require('crypto');

// This test verifies padding with leading zeroes for shared
// secrets that are strictly smaller than the modulus (prime).
// See:
//  RFC 4346: https://www.ietf.org/rfc/rfc4346.txt
//  https://github.com/nodejs/node-v0.x-archive/issues/7906
//  https://github.com/nodejs/node-v0.x-archive/issues/5239
//
// In FIPS mode OPENSSL_DH_FIPS_MIN_MODULUS_BITS = 1024, meaning we need
// a FIPS-friendly >= 1024 bit prime, we can use MODP 14 from RFC 3526:
// https://www.ietf.org/rfc/rfc3526.txt
//
// We can generate appropriate values with this code:
//
// crypto = require('crypto');
//
// for (;;) {
//   var a = crypto.getDiffieHellman('modp14'),
//   var b = crypto.getDiffieHellman('modp14');
//
//   a.generateKeys();
//   b.generateKeys();
//
//   var aSecret = a.computeSecret(b.getPublicKey()).toString('hex');
//   console.log(""A public: "" + a.getPublicKey().toString('hex'));
//   console.log(""A private: "" + a.getPrivateKey().toString('hex'));
//   console.log(""B public: "" + b.getPublicKey().toString('hex'));
//   console.log(""B private: "" + b.getPrivateKey().toString('hex'));
//   console.log(""A secret: "" + aSecret);
//   console.log('-------------------------------------------------');
//   if(aSecret.substring(0,2) === ""00"") {
//     console.log(""found short key!"");
//     return;
//   }
// }

const apub =
'5484455905d3eff34c70980e871f27f05448e66f5a6efbb97cbcba4e927196c2bd9ea272cded91\
10a4977afa8d9b16c9139a444ed2d954a794650e5d7cb525204f385e1af81530518563822ecd0f9\
524a958d02b3c269e79d6d69850f0968ad567a4404fbb0b19efc8bc73e267b6136b88cafb33299f\
f7c7cace3ffab1a88c2c9ee841f88b4c3679b4efc465f5c93cca11d487be57373e4c5926f634c4e\
efee6721d01db91cd66321615b2522f96368dbc818875d422140d0edf30bdb97d9721feddcb9ff6\
453741a4f687ee46fc54bf1198801f1210ac789879a5ee123f79e2d2ce1209df2445d32166bc9e4\
8f89e944ec9c3b2e16c8066cd8eebd4e33eb941';
const bpub =
'3fca64510e36bc7da8a3a901c7b74c2eabfa25deaf7cbe1d0c50235866136ad677317279e1fb0\
06e9c0a07f63e14a3363c8e016fbbde2b2c7e79fed1cc3e08e95f7459f547a8cd0523ee9dc744d\
e5a956d92b937db4448917e1f6829437f05e408ee7aea70c0362b37370c7c75d14449d8b2d2133\
04ac972302d349975e2265ca7103cfebd019d9e91234d638611abd049014f7abf706c1c5da6c88\
788a1fdc6cdf17f5fffaf024ce8711a2ebde0b52e9f1cb56224483826d6e5ac6ecfaae07b75d20\
6e8ac97f5be1a5b68f20382f2a7dac189cf169325c4cf845b26a0cd616c31fec905c5d9035e5f7\
8e9880c812374ac0f3ca3d365f06e4be526b5affd4b79';
const apriv =
'62411e34704637d99c6c958a7db32ac22fcafafbe1c33d2cfdb76e12ded41f38fc16b792b9041\
2e4c82755a3815ba52f780f0ee296ad46e348fc4d1dcd6b64f4eea1b231b2b7d95c5b1c2e26d34\
83520558b9860a6eb668f01422a54e6604aa7702b4e67511397ef3ecb912bff1a83899c5a5bfb2\
0ee29249a91b8a698e62486f7009a0e9eaebda69d77ecfa2ca6ba2db6c8aa81759c8c90c675979\
08c3b3e6fc60668f7be81cce6784482af228dd7f489005253a165e292802cfd0399924f6c56827\
7012f68255207722355634290acc7fddeefbba75650a85ece95b6a12de67eac016ba78960108dd\
5dbadfaa43cc9fed515a1f307b7d90ae0623bc7b8cefb';
const secret =
'00c37b1e06a436d6717816a40e6d72907a6f255638b93032267dcb9a5f0b4a9aa0236f3dce63b\
1c418c60978a00acd1617dfeecf1661d8a3fafb4d0d8824386750f4853313400e7e4afd22847e4\
fa56bc9713872021265111906673b38db83d10cbfa1dea3b6b4c97c8655f4ae82125281af7f234\
8916a15c6f95649367d169d587697480df4d10b381479e86d5518b520d9d8fb764084eab518224\
dc8fe984ddaf532fc1531ce43155fa0ab32532bf1ece5356b8a3447b5267798a904f16f3f4e635\
597adc0179d011132dcffc0bbcb0dd2c8700872f8663ec7ddd897c659cc2efebccc73f38f0ec96\
8612314311231f905f91c63a1aea52e0b60cead8b57df';

/* FIPS-friendly 2048 bit prime */
const p = crypto.createDiffieHellman(
  crypto.getDiffieHellman('modp14').getPrime());

p.setPublicKey(apub, 'hex');
p.setPrivateKey(apriv, 'hex');

assert.strictEqual(
  p.computeSecret(bpub, 'hex', 'hex').toString('hex'),
  secret
);

```"
"```javascript:test\fs\test-fs-read.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');

const expected = Buffer.from('xyz\n');

function test(bufferAsync, bufferSync, expected) {
  fs.read(fd,
          bufferAsync,
          0,
          expected.length,
          0,
          common.mustSucceed((bytesRead) => {
            assert.strictEqual(bytesRead, expected.length);
            assert.deepStrictEqual(bufferAsync, expected);
          }));

  const r = fs.readSync(fd, bufferSync, 0, expected.length, 0);
  assert.deepStrictEqual(bufferSync, expected);
  assert.strictEqual(r, expected.length);
}

test(Buffer.allocUnsafe(expected.length),
     Buffer.allocUnsafe(expected.length),
     expected);

test(new Uint8Array(expected.length),
     new Uint8Array(expected.length),
     Uint8Array.from(expected));

{
  // Reading beyond file length (3 in this case) should return no data.
  // This is a test for a bug where reads > uint32 would return data
  // from the current position in the file.
  const pos = 0xffffffff + 1; // max-uint32 + 1
  const nRead = fs.readSync(fd, Buffer.alloc(1), 0, 1, pos);
  assert.strictEqual(nRead, 0);

  fs.read(fd, Buffer.alloc(1), 0, 1, pos, common.mustSucceed((nRead) => {
    assert.strictEqual(nRead, 0);
  }));
}
/* non-public in api doc
assert.throws(() => new fs.Dir(), {
  code: 'ERR_MISSING_ARGS',
});
*/
assert.throws(
  () => fs.read(fd, Buffer.alloc(1), 0, 1, 0),
  {
    code: 'ERR_INVALID_ARG_TYPE',
  }
);

assert.throws(
  () => fs.read(fd, { buffer: null }, common.mustNotCall()),
  /TypeError: cannot read property 'byteLength' of null/,
  'throws when options.buffer is null'
);

assert.throws(
  () => fs.readSync(fd, { buffer: null }),
  /TypeError/,
  'throws when options.buffer is null'
);

assert.throws(
  () => fs.read(null, Buffer.alloc(1), 0, 1, 0),
  {
    message: 'The ""fd"" argument must be of type number. Received null',
    code: 'ERR_INVALID_ARG_TYPE',
  }
);

```"
"```javascript:test\crypto\test-crypto-async-sign-verify.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const util = require('util');
const crypto = require('crypto');
const fixtures = require('../common/fixtures');

function test(
  publicFixture,
  privateFixture,
  algorithm,
  deterministic,
  options
) {
  let publicPem = fixtures.readKey(publicFixture);
  let privatePem = fixtures.readKey(privateFixture);
  let privateKey = crypto.createPrivateKey(privatePem);
  let publicKey = crypto.createPublicKey(publicPem);
  const privateDer = {
    key: privateKey.export({ format: 'der', type: 'pkcs8' }),
    format: 'der',
    type: 'pkcs8',
    ...options
  };
  const publicDer = {
    key: publicKey.export({ format: 'der', type: 'spki' }),
    format: 'der',
    type: 'spki',
    ...options
  };

  if (options) {
    publicPem = { ...options, key: publicPem };
    privatePem = { ...options, key: privatePem };
    privateKey = { ...options, key: privateKey };
    publicKey = { ...options, key: publicKey };
  }

  const data = Buffer.from('Hello world');
  const expected = crypto.sign(algorithm, data, privateKey);

  for (const key of [privatePem, privateKey, privateDer]) {
    crypto.sign(algorithm, data, key, common.mustSucceed((actual) => {
      if (deterministic) {
        assert.deepStrictEqual(actual, expected);
      }

      assert.strictEqual(
        crypto.verify(algorithm, data, key, actual), true);
    }));
  }

  const verifyInputs = [
    publicPem, publicKey, publicDer, privatePem, privateKey, privateDer];
  for (const key of verifyInputs) {
    crypto.verify(algorithm, data, key, expected, common.mustSucceed(
      (verified) => assert.strictEqual(verified, true)));

    crypto.verify(algorithm, data, key, Buffer.from(''), common.mustSucceed(
      (verified) => assert.strictEqual(verified, false)));
  }
}

// RSA w/ default padding
test('rsa_public.pem', 'rsa_private.pem', 'sha256', true);
test('rsa_public.pem', 'rsa_private.pem', 'sha256', true,
     { padding: crypto.constants.RSA_PKCS1_PADDING });

// RSA w/ PSS_PADDING and default saltLength
test('rsa_public.pem', 'rsa_private.pem', 'sha256', false,
     { padding: crypto.constants.RSA_PKCS1_PSS_PADDING });
test('rsa_public.pem', 'rsa_private.pem', 'sha256', false,
     {
       padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
       saltLength: crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN
     });

// RSA w/ PSS_PADDING and PSS_SALTLEN_DIGEST
test('rsa_public.pem', 'rsa_private.pem', 'sha256', false,
     {
       padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
       saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
     });

// ED25519
test('ed25519_public.pem', 'ed25519_private.pem', undefined, true);
// ED448
test('ed448_public.pem', 'ed448_private.pem', undefined, true);

// ECDSA w/ der signature encoding
test('ec_secp256k1_public.pem', 'ec_secp256k1_private.pem', 'sha384',
     false);
test('ec_secp256k1_public.pem', 'ec_secp256k1_private.pem', 'sha384',
     false, { dsaEncoding: 'der' });

// ECDSA w/ ieee-p1363 signature encoding
test('ec_secp256k1_public.pem', 'ec_secp256k1_private.pem', 'sha384', false,
     { dsaEncoding: 'ieee-p1363' });

// DSA w/ der signature encoding
test('dsa_public.pem', 'dsa_private.pem', 'sha256',
     false);
test('dsa_public.pem', 'dsa_private.pem', 'sha256',
     false, { dsaEncoding: 'der' });

// DSA w/ ieee-p1363 signature encoding
test('dsa_public.pem', 'dsa_private.pem', 'sha256', false,
     { dsaEncoding: 'ieee-p1363' });

// Test Parallel Execution w/ KeyObject is threadsafe in openssl3
{
  const publicKey = {
    key: crypto.createPublicKey(
      fixtures.readKey('ec_p256_public.pem')),
    dsaEncoding: 'ieee-p1363',
  };
  const privateKey = {
    key: crypto.createPrivateKey(
      fixtures.readKey('ec_p256_private.pem')),
    dsaEncoding: 'ieee-p1363',
  };

  const sign = util.promisify(crypto.sign);
  const verify = util.promisify(crypto.verify);

  const data = Buffer.from('hello world');

  Promise.all([
    sign('sha256', data, privateKey),
    sign('sha256', data, privateKey),
    sign('sha256', data, privateKey),
  ]).then(([signature]) => {
    return Promise.all([
      verify('sha256', data, publicKey, signature),
      verify('sha256', data, publicKey, signature),
      verify('sha256', data, publicKey, signature),
    ]).then(common.mustCall());
  })
  .catch(common.mustNotCall());
}

```"
"```javascript:modules\internal\crypto\hkdf.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import {
  validateFunction,
  validateInteger,
  validateString,
  validateUint32,
} from '../validators';

import { kMaxLength } from '../../buffer';

import {
  getArrayBufferOrView,
  normalizeHashName,
  toBuf,
  validateByteSource,
  kKeyObject,
  getHashes,
} from '../crypto/util';

import {
  createSecretKey,
  isKeyObject,
} from './keys';

import {
  lazyDOMException,
} from '../util';

import {
  isAnyArrayBuffer,
  isArrayBufferView,
} from '../util/types';

import {
  ERR_INVALID_ARG_TYPE,
  ERR_OUT_OF_RANGE,
  ERR_MISSING_OPTION,
  hideStackFrames,
  ERR_CRYPTO_INVALID_DIGEST,
  ERR_CRYPTO_INVALID_KEYLEN,
} from '../errors';

import { hkdf_sync } from ""_node:crypto"";

const validateParameters = hideStackFrames((hash, key, salt, info, length) => {
  validateString(hash, 'digest');

  key = prepareKey(key).export();
  salt = validateByteSource(salt, 'salt');
  info = validateByteSource(info, 'info');

  validateInteger(length, 'length', 0, kMaxLength);
  if (info.byteLength > 1024) {
    throw new ERR_OUT_OF_RANGE(
      'info',
      'must not contain more than 1024 bytes',
      info.byteLength);
  }

  if (!getHashes().includes(hash)) {
    throw new ERR_CRYPTO_INVALID_DIGEST(hash);
  }

  if (hash === ""sha256"" && length > 255 * 32) {
    throw new ERR_CRYPTO_INVALID_KEYLEN()
  } else if (hash === ""sha512"" && length > 255 * 64) {
    throw new ERR_CRYPTO_INVALID_KEYLEN()
  }

  return {
    hash,
    key,
    salt,
    info,
    length,
  };
});

function prepareKey(key) {
  if (isKeyObject(key))
    return key;

  if (isAnyArrayBuffer(key))
    return createSecretKey(key);

  key = toBuf(key);

  if (!isArrayBufferView(key)) {
    throw new ERR_INVALID_ARG_TYPE(
      'ikm',
      [
        'string',
        'SecretKeyObject',
        'ArrayBuffer',
        'TypedArray',
        'DataView',
        'Buffer',
      ],
      key);
  }

  return createSecretKey(key);
}

function hkdf(hash, key, salt, info, length, callback) {
  ({
    hash,
    key,
    salt,
    info,
    length,
  } = validateParameters(hash, key, salt, info, length));

  validateFunction(callback, 'callback');

  setTimeout(() => {
    let result = hkdf_sync(key.buffer ?? key, salt.buffer ?? salt, info.buffer ?? info, length, hash.toUpperCase());
    callback(null, result);
  }, 0);
}

function hkdfSync(hash, key, salt, info, length) {
  ({
    hash,
    key,
    salt,
    info,
    length,
  } = validateParameters(hash, key, salt, info, length));
  let result = hkdf_sync(key.buffer ?? key, salt.buffer ?? salt, info.buffer ?? info, length, hash.toUpperCase());
  return result;
}

async function hkdfDeriveBits(algorithm, baseKey, length) {
  const { hash } = algorithm;
  const salt = getArrayBufferOrView(algorithm.salt, 'algorithm.salt');
  const info = getArrayBufferOrView(algorithm.info, 'algorithm.info');
  if (hash === undefined)
    throw new ERR_MISSING_OPTION('algorithm.hash');

  let byteLength = 512 / 8;
  if (length !== undefined) {
    if (length === 0)
      throw lazyDOMException('length cannot be zero', 'OperationError');
    if (length === null)
      throw lazyDOMException('length cannot be null', 'OperationError');
    validateUint32(length, 'length');
    if (length % 8) {
      throw lazyDOMException(
        'length must be a multiple of 8',
        'OperationError');
    }
    byteLength = length / 8;
  }

  return new Promise((resolve, reject) => {
    hkdf(
      normalizeHashName(hash.name),
      baseKey[kKeyObject],
      salt,
      info,
      byteLength,
      (err, bits) => {
        if (err) return reject(err);
        resolve(bits);
      });
  });
}

export {
  hkdf,
  hkdfSync,
  hkdfDeriveBits,
};

```"
"```javascript:test\fs\test-fs-open.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

let caughtException = false;

try {
  // Should throw ENOENT, not EBADF
  // see https://github.com/joyent/node/pull/1228
  fs.openSync('/8hvftyuncxrt/path/to/file/that/does/not/exist', 'r');
} catch (e) {
  assert.strictEqual(e.code, 'ENOENT');
  caughtException = true;
}
assert.strictEqual(caughtException, true);

fs.openSync(__filename);

fs.open(__filename, common.mustSucceed());

fs.open(__filename, 'r', common.mustSucceed());

fs.open(__filename, 'rs', common.mustSucceed());

fs.open(__filename, 'r', 0, common.mustSucceed());

fs.open(__filename, 'r', null, common.mustSucceed());

async function promise() {
  await fs.promises.open(__filename);
  await fs.promises.open(__filename, 'r');
}

promise().then(common.mustCall()).catch(common.mustNotCall());

assert.throws(
  () => fs.open(__filename, 'r', 'boom', common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    name: 'TypeError'
  }
);

for (const extra of [[], ['r'], ['r', 0], ['r', 0, 'bad callback']]) {
  assert.throws(
    () => fs.open(__filename, ...extra),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
}

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.open(i, 'r', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.openSync(i, 'r', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.rejects(
    fs.promises.open(i, 'r'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Check invalid modes.
[false, [], {}].forEach((mode) => {
  assert.throws(
    () => fs.open(__filename, 'r', mode, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    }
  );
  assert.throws(
    () => fs.openSync(__filename, 'r', mode, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    }
  );
  assert.rejects(
    fs.promises.open(__filename, 'r', mode),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    }
  );
});

```"
"```javascript:test\fs\test-fs-stat-date.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import * as common from '../common';

// Test timestamps returned by fsPromises.stat and fs.statSync

import fs from 'fs';
import fsPromises from 'fs/promises';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir.js';

(async () => {

  // On some platforms (for example, ppc64) boundaries are tighter
  // than usual. If we catch these errors, skip corresponding test.
  const ignoredErrors = new Set(['EINVAL', 'EOVERFLOW']);

  tmpdir.refresh();
  const filepath = path.resolve(tmpdir.path, 'timestamp');

  await (await fsPromises.open(filepath, 'w')).close();

  // Perform a trivial check to determine if filesystem supports setting
  // and retrieving atime and mtime. If it doesn't, skip the test.
  await fsPromises.utimes(filepath, 2, 2);
  const { atimeMs, mtimeMs } = await fsPromises.stat(filepath);
  if (atimeMs !== 2000 || mtimeMs !== 2000) {
    common.skip(`Unsupported filesystem (atime=${atimeMs}, mtime=${mtimeMs})`);
  }

  // Date might round down timestamp
  function closeEnough(actual, expected, margin) {
    // On ppc64, value is rounded to seconds
    if (process.arch === 'ppc64') {
      margin += 1000;
    }
    assert.ok(Math.abs(Number(actual - expected)) < margin,
      `expected ${expected} �� ${margin}, got ${actual}`);
  }

  async function runTest(atime, mtime, margin = 0) {
    margin += Number.EPSILON;
    try {
      await fsPromises.utimes(filepath, new Date(atime), new Date(mtime));
    } catch (e) {
      if (ignoredErrors.has(e.code)) return;
      throw e;
    }

    const stats = await fsPromises.stat(filepath);
    closeEnough(stats.atimeMs, atime, margin);
    closeEnough(stats.mtimeMs, mtime, margin);
    closeEnough(stats.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(stats.mtime.getTime(), new Date(mtime).getTime(), margin);

    const statsBigint = await fsPromises.stat(filepath, { bigint: true });
    closeEnough(statsBigint.atimeMs, BigInt(atime), margin);
    closeEnough(statsBigint.mtimeMs, BigInt(mtime), margin);
    closeEnough(statsBigint.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(statsBigint.mtime.getTime(), new Date(mtime).getTime(), margin);

    const statsSync = fs.statSync(filepath);
    closeEnough(statsSync.atimeMs, atime, margin);
    closeEnough(statsSync.mtimeMs, mtime, margin);
    closeEnough(statsSync.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(statsSync.mtime.getTime(), new Date(mtime).getTime(), margin);

    const statsSyncBigint = fs.statSync(filepath, { bigint: true });
    closeEnough(statsSyncBigint.atimeMs, BigInt(atime), margin);
    closeEnough(statsSyncBigint.mtimeMs, BigInt(mtime), margin);
    closeEnough(statsSyncBigint.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(statsSyncBigint.mtime.getTime(), new Date(mtime).getTime(), margin);
  }

  // Too high/low numbers produce too different results on different platforms
  {
    // TODO(LiviaMedeiros): investigate outdated stat time on FreeBSD.
    // On Windows, filetime is stored and handled differently. Supporting dates
    // after Y2038 is preferred over supporting dates before 1970-01-01.
    if (!common.isFreeBSD && !common.isWindows) {
      await runTest(-40691, -355, 1); // Potential precision loss on 32bit
      await runTest(-355, -40691, 1);  // Potential precision loss on 32bit
      await runTest(-1, -1);
    }
    await runTest(0, 0);
    await runTest(1, 1);
    await runTest(355, 40691, 1); // Precision loss on 32bit
    await runTest(40691, 355, 1); // Precision loss on 32bit
    await runTest(1713037251360, 1713037251360, 1); // Precision loss
  }

})();
```"
"```javascript:test\fs\test-fs-promises-write-optional-params.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// This test ensures that filehandle.write accepts ""named parameters"" object
// and doesn't interpret objects as strings

import assert from 'assert';
import fsPromises from 'fs/promises';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const dest = path.resolve(tmpdir.path, 'tmp.txt');
const buffer = Buffer.from('zyx');

async function testInvalid(dest, expectedCode, ...params) {
  if (params.length >= 2) {
    params[1] = common.mustNotMutateObjectDeep(params[1]);
  }
  let fh;
  try {
    fh = await fsPromises.open(dest, 'w+');
    await assert.rejects(
      fh.write(...params),
      { code: expectedCode });
  } finally {
    await fh?.close();
  }
}

async function testValid(dest, buffer, options) {
  const length = options?.length;
  const offset = options?.offset;
  let fh;
  try {
    fh = await fsPromises.open(dest, 'w+');
    const writeResult = await fh.write(buffer, options);
    writeResult.buffer = new Uint8Array(writeResult.buffer);
    const writeBufCopy = Uint8Array.prototype.slice.call(writeResult.buffer);

    const readResult = await fh.read(buffer, options);
    readResult.buffer = new Uint8Array(readResult.buffer);
    const readBufCopy = Uint8Array.prototype.slice.call(readResult.buffer);

    assert.ok(writeResult.bytesWritten >= readResult.bytesRead);
    if (length !== undefined && length !== null) {
      assert.strictEqual(writeResult.bytesWritten, length);
    }
    if (offset === undefined || offset === 0) {
      assert.deepStrictEqual(writeBufCopy, readBufCopy);
    }
    assert.deepStrictEqual(writeResult.buffer, readResult.buffer);
  } finally {
    await fh?.close();
  }
}

(async () => {
  // Test if first argument is not wrongly interpreted as ArrayBufferView|string
  for (const badBuffer of [
    undefined, null, true, 42, 42n, Symbol('42'), NaN, [], () => {},
    common.mustNotCall(),
    common.mustNotMutateObjectDeep({}),
    Promise.resolve(new Uint8Array(1)),
    {},
    { buffer: 'amNotParam' },
    { string: 'amNotParam' },
    { buffer: new Uint8Array(1).buffer },
    new Date(),
    new String('notPrimitive'),
    { toString() { return 'amObject'; } },
    { [Symbol.toPrimitive]: (hint) => 'amObject' },
  ]) {
    await testInvalid(dest, 'ERR_INVALID_ARG_TYPE', common.mustNotMutateObjectDeep(badBuffer), {});
  }

  // First argument (buffer or string) is mandatory
  await testInvalid(dest, 'ERR_INVALID_ARG_TYPE');

  // Various invalid options
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 5 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: 5 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 1, offset: 3 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: -1 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: -1 });
  await testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: false });
  await testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: true });

  // Test compatibility with filehandle.read counterpart
  for (const options of [
    undefined,
    null,
    {},
    { length: 1 },
    { position: 5 },
    { length: 1, position: 5 },
    { length: 1, position: -1, offset: 2 },
    { length: null },
    { position: null },
    { offset: 1 },
  ]) {
    await testValid(dest, buffer, common.mustNotMutateObjectDeep(options));
  }
})().then(common.mustCall());

```"
"```javascript:test\fs\test-fs-promises-file-handle-readFile.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.readFile method.

import fs from 'fs';
const {
  open,
  readFile,
  writeFile,
  truncate,
} = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
// import tick from '../common/tick';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateReadFile() {
  const filePath = path.resolve(tmpDir, 'tmp-read-file.txt');
  const fileHandle = await open(filePath, 'w+');
  const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

  const fd = fs.openSync(filePath, 'w+');
  fs.writeSync(fd, buffer, 0, buffer.length);
  fs.closeSync(fd);

  const readFileData = await fileHandle.readFile();
  assert.deepStrictEqual(buffer, readFileData);

  await fileHandle.close();
}

async function validateReadFileProc() {
  // Test to make sure reading a file under the /proc directory works. Adapted
  // from test-fs-read-file-sync-hostname.js.
  // Refs:
  // - https://groups.google.com/forum/#!topic/nodejs-dev/rxZ_RoH1Gn0
  // - https://github.com/nodejs/node/issues/21331

  // Test is Linux-specific.
  if (!common.isLinux)
    return;

  const fileHandle = await open('/proc/sys/kernel/hostname', 'r');
  const hostname = await fileHandle.readFile();
  assert.ok(hostname.length > 0);
}

async function doReadAndCancel() {
  // unsupport AbortController
  /*
  // Signal aborted from the start
  {
    const filePathForHandle = path.resolve(tmpDir, 'dogs-running.txt');
    const fileHandle = await open(filePathForHandle, 'w+');
    try {
      const buffer = Buffer.from('Dogs running'.repeat(10000), 'utf8');
      fs.writeFileSync(filePathForHandle, buffer);
      const signal = AbortSignal.abort();
      await assert.rejects(readFile(fileHandle, common.mustNotMutateObjectDeep({ signal })), {
        name: 'AbortError'
      });
    } finally {
      await fileHandle.close();
    }
  }

  // Signal aborted on first tick
  {
    const filePathForHandle = path.resolve(tmpDir, 'dogs-running1.txt');
    const fileHandle = await open(filePathForHandle, 'w+');
    const buffer = Buffer.from('Dogs running'.repeat(10000), 'utf8');
    fs.writeFileSync(filePathForHandle, buffer);
    const controller = new AbortController();
    const { signal } = controller;
    process.nextTick(() => controller.abort());
    await assert.rejects(readFile(fileHandle, common.mustNotMutateObjectDeep({ signal })), {
      name: 'AbortError'
    }, 'tick-0');
    await fileHandle.close();
  }

  // Signal aborted right before buffer read
  {
    const newFile = path.resolve(tmpDir, 'dogs-running2.txt');
    const buffer = Buffer.from('Dogs running'.repeat(1000), 'utf8');
    fs.writeFileSync(newFile, buffer);

    const fileHandle = await open(newFile, 'r');

    const controller = new AbortController();
    const { signal } = controller;
    tick(1, () => controller.abort());
    await assert.rejects(fileHandle.readFile(common.mustNotMutateObjectDeep({ signal, encoding: 'utf8' })), {
      name: 'AbortError'
    }, 'tick-1');

    await fileHandle.close();
  }*/

  // Validate file size is within range for reading
  {
    // Variable taken from https://github.com/nodejs/node/blob/1377163f3351/lib/internal/fs/promises.js#L5
    const kIoMaxLength = 2 ** 31 - 1;

    const newFile = path.resolve(tmpDir, 'dogs-running3.txt');
    await writeFile(newFile, Buffer.from('0'));
    await truncate(newFile, kIoMaxLength + 1);

    const fileHandle = await open(newFile, 'r');

    await assert.rejects(fileHandle.readFile(), {
      name: 'RangeError',
      code: 'ERR_FS_FILE_TOO_LARGE'
    });
    await fileHandle.close();
  }
}

validateReadFile()
  .then(validateReadFileProc)
  .then(doReadAndCancel)
  .then(common.mustCall());

```"
"```javascript:test\fs\test-fs-symlink.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
if (!common.canCreateSymLink())
  common.skip('insufficient privileges');

import assert from 'assert';
import path from 'path';
import fs from 'fs';

let linkTime;
let fileTime;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test creating and reading symbolic link
const linkData = fixtures.path('/cycles/root.js');
const linkPath = path.join(tmpdir.path, 'symlink1.js');

fs.symlink(linkData, linkPath, common.mustSucceed(() => {
  fs.lstat(linkPath, common.mustSucceed((stats) => {
    linkTime = stats.mtime.getTime();
  }));

  fs.stat(linkPath, common.mustSucceed((stats) => {
    fileTime = stats.mtime.getTime();
  }));

  /*fs.readlink(linkPath, common.mustSucceed((destination) => {
    assert.strictEqual(destination, linkData);
  }));*/
}));

// Test invalid symlink
{
  const linkData = fixtures.path('/not/exists/file');
  const linkPath = path.join(tmpdir.path, 'symlink2.js');

  fs.symlink(linkData, linkPath, common.mustSucceed(() => {
    assert(!fs.existsSync(linkPath));
  }));
}

[false, 1, {}, [], null, undefined].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: /target|path/
  };
  assert.throws(() => fs.symlink(input, '', common.mustNotCall()), errObj);
  assert.throws(() => fs.symlinkSync(input, ''), errObj);

  assert.throws(() => fs.symlink('', input, common.mustNotCall()), errObj);
  assert.throws(() => fs.symlinkSync('', input), errObj);
});

const errObj = {
  code: 'ERR_FS_INVALID_SYMLINK_TYPE',
  name: 'Error',
  message:
    'Symlink type must be one of ""dir"", ""file"", or ""junction"". Received ""����""'
};
assert.throws(() => fs.symlink('', '', '����', common.mustNotCall()), errObj);
assert.throws(() => fs.symlinkSync('', '', '����'), errObj);

globalThis.commonExitCheck = () => {
  assert.notStrictEqual(linkTime, fileTime);
};

```"
"```javascript:modules\os.js
import process from 'process';
import { Buffer } from 'buffer';
import { text_encode } from '_encoding';
import { _memorySize } from '_node:os';

export * from 'qjs:os';

function unimplemented(name) {
  throw new Error('Node.js os ' + name + ' is not supported');
}

var EOL = '\n';

function arch() {
  return process.arch;
}

var constants = [];

function cpus() {
  unimplemented('cpus');
}

var devNull = '/dev/null';

function endianness() {
  return 'LE';
}

function freemem() {
  // memory.size instruction will return the current 
  // memory size in units of pages. 
  // A page size is 65536 bytes.
  return totalmem() - _memorySize() * 65536;
}

function getPriority(pid) {
  if (pid === undefined) {
    pid = 0;
  }
  return 0;
}

function homedir() {
  return process.env['HOME'] || '.';
}

function hostname() {
  return process.title;
}

function loadavg() {
  return [0, 0, 0];
}

function networkInterfaces() {
  return [];
}

function platform() {
  return process.platform;
}

function release() {
  return process.version;
}

function setPriority(pid, priority) {
  if (priority === undefined) {
    priority = pid;
    pid = 0;
  }
}

function tmpdir() {
  let path = process.env['TMPDIR'] || process.env['TMP'] || process.env['TEMP'] || '/tmp';
  if (path.length > 1 && path.endsWith('/')) {
    path = path.slice(0, -1);
  }
  return path;
}

function totalmem() {
  return 2 ** 32;
}

function type() {
  return 'wasmedge';
}

function uptime() {
  return process.uptime();
}

function userInfo(options) {
  const encoding = (options && options.encoding) || 'utf8';
  let username = 'wasmedge';
  let _homedir = homedir();
  if (encoding === 'Buffer' || encoding === 'buffer') {
    username = Buffer.from(username, 'utf8');
    _homedir = Buffer.from(_homedir, 'utf8');
  } else if (encoding !== 'utf-8' && encoding !== 'utf8') {
    let exist = [
      'utf8', 'utf-8', 'gbk', 'gb18030', 'hz-gb-2312', 'big5', 'euc-jp', 'iso-2022-jp',
      'utf-16be', 'utf-16le', 'x-user-defined', 'ibm866',
      'iso-8859-2', 'iso-8859-3', 'iso-8859-4', 'iso-8859-5', 'iso-8859-6', 'iso-8859-7', 'iso-8859-8',
      'iso-8859-8i', 'iso-8859-10', 'iso-8859-13', 'iso-8859-14', 'iso-8859-15', 'iso-8859-16',
      'windows-874', 'windows-1250', 'windows-1251', 'windows-1252', 'windows-1253', 'windows-1254',
      'windows-1255', 'windows-1256', 'windows-1257', 'windows-1258', ''
    ].indexOf(encoding);
    if (exist >= 0) {
      const decoder = new TextDecoder();
      username = text_encode(encoding, decoder.decode(username));
      _homedir = text_encode(encoding, decoder.decode(_homedir));
    }
  }
  return {
    uid: -1,
    pid: -1,
    username,
    homedir: _homedir,
    shell: null
  }
}

function version() {
  return process.version;
}

export {
  EOL,
  arch,
  constants,
  cpus,
  devNull,
  endianness,
  freemem,
  getPriority,
  homedir,
  hostname,
  loadavg,
  networkInterfaces,
  platform,
  release,
  setPriority,
  tmpdir,
  totalmem,
  type,
  uptime,
  userInfo,
  version
}
```"
"```javascript:test\fs\test-fs-readfile.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// This test ensures that fs.readFile correctly returns the
// contents of varying-sized files.

import tmpdir from '../../test/common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import process from 'process';

const prefix = `.removeme-fs-readfile-${process.pid}`;

tmpdir.refresh();

const fileInfo = [
  { name: path.join(tmpdir.path, `${prefix}-1K.txt`),
    len: 1024 },
  { name: path.join(tmpdir.path, `${prefix}-64K.txt`),
    len: 64 * 1024 },
  { name: path.join(tmpdir.path, `${prefix}-64KLessOne.txt`),
    len: (64 * 1024) - 1 },
  /*{ name: path.join(tmpdir.path, `${prefix}-1M.txt`),
    len: 1 * 1024 * 1024 },
  { name: path.join(tmpdir.path, `${prefix}-1MPlusOne.txt`),
    len: (1 * 1024 * 1024) + 1 },*/
];

// Populate each fileInfo (and file) with unique fill.
const sectorSize = 512;
for (const e of fileInfo) {
  e.contents = Buffer.allocUnsafe(e.len);

  // This accounts for anything unusual in Node's implementation of readFile.
  // Using e.g. 'aa...aa' would miss bugs like Node re-reading
  // the same section twice instead of two separate sections.
  for (let offset = 0; offset < e.len; offset += sectorSize) {
    const fillByte = 256 * Math.random();
    const nBytesToFill = Math.min(sectorSize, e.len - offset);
    e.contents.fill(fillByte, offset, offset + nBytesToFill);
  }

  fs.writeFileSync(e.name, e.contents);
}
// All files are now populated.

// Test readFile on each size.
for (const e of fileInfo) {
  fs.readFile(e.name, common.mustCall((err, buf) => {
    console.log(`Validating readFile on file ${e.name} of length ${e.len}`);
    assert.ifError(err);
    assert.deepStrictEqual(buf, e.contents);
  }));
}
// Test readFile size too large
{
  const kIoMaxLength = 2 ** 31 - 1;

  const file = path.join(tmpdir.path, `${prefix}-too-large.txt`);
  fs.writeFileSync(file, Buffer.from('0'));
  fs.truncateSync(file, kIoMaxLength + 1);

  fs.readFile(file, common.expectsError({
    code: 'ERR_FS_FILE_TOO_LARGE',
    name: 'RangeError',
  }));
  assert.throws(() => {
    fs.readFileSync(file);
  }, { code: 'ERR_FS_FILE_TOO_LARGE', name: 'RangeError' });
}
/*
{
  // Test cancellation, before
  const signal = AbortSignal.abort();
  fs.readFile(fileInfo[0].name, { signal }, common.mustCall((err, buf) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
}
{
  // Test cancellation, during read
  const controller = new AbortController();
  const signal = controller.signal;
  fs.readFile(fileInfo[0].name, { signal }, common.mustCall((err, buf) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
  process.nextTick(() => controller.abort());
}
{
  // Verify that if something different than Abortcontroller.signal
  // is passed, ERR_INVALID_ARG_TYPE is thrown
  assert.throws(() => {
    const callback = common.mustNotCall(() => {});
    fs.readFile(fileInfo[0].name, { signal: 'hello' }, callback);
  }, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });
}
*/
```"
"```javascript:modules\internal\crypto\pbkdf2.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';


import { Buffer } from 'buffer';

import { validateFunction, validateInteger, validateString, validateUint32 } from '../validators';

import { ERR_CRYPTO_INVALID_DIGEST, ERR_MISSING_OPTION } from '../errors';

import { getArrayBufferOrView, getDefaultEncoding, normalizeHashName, kKeyObject } from './util';

import { lazyDOMException } from '../util';

import { pbkdf2_sync } from ""_node:crypto"";

export function pbkdf2(password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest;
    digest = undefined;
  }

  ({ password, salt, iterations, keylen, digest } =
    check(password, salt, iterations, keylen, digest));

  validateFunction(callback, 'callback');

  if (![""SHA256"", ""SHA512""].includes(digest.toUpperCase())) {
    throw new ERR_CRYPTO_INVALID_DIGEST(digest);
  }

  const encoding = getDefaultEncoding();

  setTimeout(() => {
    let result = pbkdf2_sync(password.buffer ?? password, salt.buffer ?? salt, iterations, keylen, digest.toUpperCase());
    const buf = Buffer.from(result);
    if (encoding === 'buffer') {
      callback(null, buf);
    } else {
      callback(null, buf.toString(encoding));
    }
  }, 0);
}

export function pbkdf2Sync(password, salt, iterations, keylen, digest) {
  ({ password, salt, iterations, keylen, digest } =
    check(password, salt, iterations, keylen, digest));

  if (![""SHA256"", ""SHA512""].includes(digest.toUpperCase())) {
    throw new ERR_CRYPTO_INVALID_DIGEST(digest);
  }

  let result = pbkdf2_sync(password.buffer ?? password, salt.buffer ?? salt, iterations, keylen, digest.toUpperCase());

  const buf = Buffer.from(result);
  const encoding = getDefaultEncoding();
  return encoding === 'buffer' ? buf : buf.toString(encoding);
}

function check(password, salt, iterations, keylen, digest) {
  validateString(digest, 'digest');

  password = getArrayBufferOrView(password, 'password');
  salt = getArrayBufferOrView(salt, 'salt');
  validateUint32(iterations, 'iterations', true);
  validateUint32(keylen, 'keylen');

  return { password, salt, iterations, keylen, digest };
}

export async function pbkdf2DeriveBits(algorithm, baseKey, length) {
  const { iterations } = algorithm;
  let { hash } = algorithm;
  const salt = getArrayBufferOrView(algorithm.salt, 'algorithm.salt');
  if (hash === undefined)
    throw new ERR_MISSING_OPTION('algorithm.hash');
  validateInteger(iterations, 'algorithm.iterations');
  if (iterations === 0)
    throw lazyDOMException(
      'iterations cannot be zero',
      'OperationError');

  hash = normalizeHashName(hash.name);

  const raw = baseKey[kKeyObject].export();

  let byteLength = 64;  // the default
  if (length !== undefined) {
    if (length === 0)
      throw lazyDOMException('length cannot be zero', 'OperationError');
    if (length === null)
      throw lazyDOMException('length cannot be null', 'OperationError');
    validateUint32(length, 'length');
    if (length % 8) {
      throw lazyDOMException(
        'length must be a multiple of 8',
        'OperationError');
    }
    byteLength = length / 8;
  }

  return new Promise((resolve, reject) => {
    pbkdf2(raw, salt, iterations, byteLength, hash, (err, result) => {
      if (err) return reject(err);
      resolve(result.buffer);
    });
  });
}

export default {
  pbkdf2,
  pbkdf2Sync,
  pbkdf2DeriveBits,
};

```"
"```javascript:test\fs\test-fs-sir-writes-alot.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import fs from 'fs';
import assert from 'assert';
import { join } from 'path';

import tmpdir from '../common/tmpdir';

const filename = join(tmpdir.path, 'out.txt');

tmpdir.refresh();

const fd = fs.openSync(filename, 'w');

const line = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa\n';

const N = 10240;
let complete = 0;

for (let i = 0; i < N; i++) {
  // Create a new buffer for each write. Before the write is actually
  // executed by the thread pool, the buffer will be collected.
  const buffer = Buffer.from(line);
  fs.write(fd, buffer, 0, buffer.length, null, function(er, written) {
    complete++;
    if (complete === N) {
      fs.closeSync(fd);
      const s = fs.createReadStream(filename);
      s.on('data', testBuffer);
    }
  });
}

let bytesChecked = 0;

function testBuffer(b) {
  for (let i = 0; i < b.length; i++) {
    bytesChecked++;
    if (b[i] !== 'a'.charCodeAt(0) && b[i] !== '\n'.charCodeAt(0)) {
      throw new Error(`invalid char ${i},${b[i]}`);
    }
  }
}

process.on('exit', function() {
  // Probably some of the writes are going to overlap, so we can't assume
  // that we get (N * line.length). Let's just make sure we've checked a
  // few...
  assert.ok(bytesChecked > 1000);
});

```"
"```javascript:test\crypto\test-crypto-stream.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const stream = require('stream');
const crypto = require('crypto');

if (!common.hasFipsCrypto) {
  // Small stream to buffer converter
  class Stream2buffer extends stream.Writable {
    constructor(callback) {
      super();

      this._buffers = [];
      this.once('finish', function() {
        callback(null, Buffer.concat(this._buffers));
      });
    }

    _write(data, encoding, done) {
      this._buffers.push(data);
      return done(null);
    }
  }

  // Create an md5 hash of ""Hallo world""
  const hasher1 = crypto.createHash('md5');
  hasher1.pipe(new Stream2buffer(common.mustCall(function end(err, hash) {
    assert.strictEqual(err, null);
    assert.strictEqual(
      hash.toString('hex'), '06460dadb35d3d503047ce750ceb2d07'
    );
  })));
  hasher1.end('Hallo world');

  // Simpler check for unpipe, setEncoding, pause and resume
  crypto.createHash('md5').unpipe({});
  crypto.createHash('md5').setEncoding('utf8');
  crypto.createHash('md5').pause();
  crypto.createHash('md5').resume();
}

// Decipher._flush() should emit an error event, not an exception.
const key = Buffer.from('48fb56eb10ffeb13fc0ef551bbca3b1b', 'hex');
const badkey = Buffer.from('12341234123412341234123412341234', 'hex');
const iv = Buffer.from('6d358219d1f488f5f4eb12820a66d146', 'hex');
const cipher = crypto.createCipheriv('aes-128-cbc', key, iv);
const decipher = crypto.createDecipheriv('aes-128-cbc', badkey, iv);

cipher.pipe(decipher)
  .on('error', common.expectsError(common.hasOpenSSL3 ? {
    message: /bad decrypt/,
    library: 'Provider routines',
    reason: 'bad decrypt',
  } : {
    message: /bad decrypt/,
    function: 'EVP_DecryptFinal_ex',
    library: 'digital envelope routines',
    reason: 'bad decrypt',
  }));

cipher.end('Papaya!');  // Should not cause an unhandled exception.

```"
"```javascript:test\fs\test-fs-readdir-types.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

// import { internalBinding } from 'internal/test/binding';
// const binding = internalBinding('fs');

const __filename = args[0];

const readdirDir = tmpdir.path;
const files = ['empty', 'files', 'for', 'just', 'testing'];
import { constants } from 'fs';
const types = {
  isDirectory: constants.UV_DIRENT_DIR,
  isFile: constants.UV_DIRENT_FILE,
  isBlockDevice: constants.UV_DIRENT_BLOCK,
  isCharacterDevice: constants.UV_DIRENT_CHAR,
  isSymbolicLink: constants.UV_DIRENT_LINK,
  isFIFO: constants.UV_DIRENT_FIFO,
  isSocket: constants.UV_DIRENT_SOCKET
};
const typeMethods = Object.keys(types);

// Make sure tmp directory is clean
tmpdir.refresh();

// Create the necessary files
files.forEach(function(currentFile) {
  fs.closeSync(fs.openSync(`${readdirDir}/${currentFile}`, 'w'));
});


function assertDirents(dirents) {
  assert.strictEqual(files.length, dirents.length);
  // dirent is not order by name in this platform
  dirents.sort((a, b) => a.name > b.name);
  for (const [i, dirent] of dirents.entries()) {
    assert(dirent instanceof fs.Dirent);
    assert.strictEqual(dirent.name, files[i]);
    assert.strictEqual(dirent.isFile(), true);
    assert.strictEqual(dirent.isDirectory(), false);
    assert.strictEqual(dirent.isSocket(), false);
    assert.strictEqual(dirent.isBlockDevice(), false);
    assert.strictEqual(dirent.isCharacterDevice(), false);
    assert.strictEqual(dirent.isFIFO(), false);
    assert.strictEqual(dirent.isSymbolicLink(), false);
  }
}

// Check the readdir Sync version
assertDirents(fs.readdirSync(readdirDir, { withFileTypes: true }));

fs.readdir(__filename, {
  withFileTypes: true
}, common.mustCall((err) => {
  assert.throws(
    () => { throw err; },
    {
      code: 'ENOTDIR',
      name: 'Error',
      message: `ENOTDIR: not a directory, scandir '${__filename}'`
    }
  );
}));

// Check the readdir async version
fs.readdir(readdirDir, {
  withFileTypes: true
}, common.mustSucceed((dirents) => {
  assertDirents(dirents);
}));

(async () => {
  const dirents = await fs.promises.readdir(readdirDir, {
    withFileTypes: true
  });
  assertDirents(dirents);
})().then(common.mustCall());

/* nodejs implement specific
// Check for correct types when the binding returns unknowns
const UNKNOWN = constants.UV_DIRENT_UNKNOWN;
const oldReaddir = binding.readdir;
process.on('beforeExit', () => { binding.readdir = oldReaddir; });
binding.readdir = common.mustCall((path, encoding, types, req, ctx) => {
  if (req) {
    const oldCb = req.oncomplete;
    req.oncomplete = (err, results) => {
      if (err) {
        oldCb(err);
        return;
      }
      results[1] = results[1].map(() => UNKNOWN);
      oldCb(null, results);
    };
    oldReaddir(path, encoding, types, req);
  } else {
    const results = oldReaddir(path, encoding, types, req, ctx);
    results[1] = results[1].map(() => UNKNOWN);
    return results;
  }
}, 2);
assertDirents(fs.readdirSync(readdirDir, { withFileTypes: true }));
fs.readdir(readdirDir, {
  withFileTypes: true
}, common.mustSucceed((dirents) => {
  assertDirents(dirents);
}));

// Dirent types
for (const method of typeMethods) {
  const dirent = new fs.Dirent('foo', types[method]);
  for (const testMethod of typeMethods) {
    assert.strictEqual(dirent[testMethod](), testMethod === method);
  }
}
*/

```"
"```javascript:modules\internal\assert\calltracker.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const {
  ArrayPrototypePush,
  ArrayPrototypeSlice,
  FunctionPrototype,
  ObjectFreeze,
  ReflectApply,
  SafeSet,
  SafeWeakMap,
} = {
  ArrayPrototypePush: Array.prototype.push,
  ArrayPrototypeSlice: Array.prototype.slice,
  FunctionPrototype: Function.prototype,
  ObjectFreeze: Object.freeze,
  ReflectApply: Reflect.apply,
  SafeSet: Set,
  SafeWeakMap: WeakMap,
};

import { ERR_UNAVAILABLE_DURING_EXIT, ERR_INVALID_ARG_VALUE } from 'internal/errors';

import AssertionError from 'internal/assert/assertion_error';
import { validateUint32 } from 'internal/validators';

const noop = FunctionPrototype;

class CallTrackerContext {
  #expected;
  #calls;
  #name;
  #stackTrace;
  constructor({ expected, stackTrace, name }) {
    this.#calls = [];
    this.#expected = expected;
    this.#stackTrace = stackTrace;
    this.#name = name;
  }

  track(thisArg, args) {
    const argsClone = ObjectFreeze(ArrayPrototypeSlice(args));
    ArrayPrototypePush(this.#calls, ObjectFreeze({ thisArg, arguments: argsClone }));
  }

  get delta() {
    return this.#calls.length - this.#expected;
  }

  reset() {
    this.#calls = [];
  }
  getCalls() {
    return ObjectFreeze(ArrayPrototypeSlice(this.#calls));
  }

  report() {
    if (this.delta !== 0) {
      const message = `Expected the ${this.#name} function to be ` +
        `executed ${this.#expected} time(s) but was ` +
        `executed ${this.#calls.length} time(s).`;
      return {
        message,
        actual: this.#calls.length,
        expected: this.#expected,
        operator: this.#name,
        stack: this.#stackTrace
      };
    }
  }
}

class CallTracker {

  #callChecks = new SafeSet();
  #trackedFunctions = new SafeWeakMap();

  #getTrackedFunction(tracked) {
    if (!this.#trackedFunctions.has(tracked)) {
      throw new ERR_INVALID_ARG_VALUE('tracked', tracked, 'is not a tracked function');
    }
    return this.#trackedFunctions.get(tracked);
  }

  reset(tracked) {
    if (tracked === undefined) {
      this.#callChecks.forEach((check) => check.reset());
      return;
    }

    this.#getTrackedFunction(tracked).reset();
  }

  getCalls(tracked) {
    return this.#getTrackedFunction(tracked).getCalls();
  }

  calls(fn, expected = 1) {
    if (process._exiting)
      throw new ERR_UNAVAILABLE_DURING_EXIT();
    if (typeof fn === 'number') {
      expected = fn;
      fn = noop;
    } else if (fn === undefined) {
      fn = noop;
    }

    validateUint32(expected, 'expected', true);

    const context = new CallTrackerContext({
      expected,
      // eslint-disable-next-line no-restricted-syntax
      stackTrace: new Error(),
      name: fn.name || 'calls'
    });
    const tracked = new Proxy(fn, {
      __proto__: null,
      apply(fn, thisArg, argList) {
        context.track(thisArg, argList);
        return ReflectApply(fn, thisArg, argList);
      },
    });
    this.#callChecks.add(context);
    this.#trackedFunctions.set(tracked, context);
    return tracked;
  }

  report() {
    const errors = [];
    for (const context of this.#callChecks) {
      const message = context.report();
      if (message !== undefined) {
        ArrayPrototypePush(errors, message);
      }
    }
    return errors;
  }

  verify() {
    const errors = this.report();
    if (errors.length === 0) {
      return;
    }
    const message = errors.length === 1 ?
      errors[0].message :
      'Functions were not called the expected number of times';
    throw new AssertionError({
      message,
      details: errors,
    });
  }
}

export default CallTracker;

```"
"```javascript:modules\internal\util\debuglog.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import { sprintf } from ""fmt/printf"";

// `debugImpls` and `testEnabled` are deliberately not initialized so any call
// to `debuglog()` before `initializeDebugEnv()` is called will throw.
let debugImpls;
let testEnabled;

// `debugEnv` is initial value of process.env.NODE_DEBUG
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        // This is run before any user code, it's OK not to use primordials.
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, ""\\$&"")
            .replaceAll(""*"", "".*"")
            .replaceAll("","", ""$|^"");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, ""i"");
        testEnabled = (str) => debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled = () => false;
    }
}

// Emits warning when user sets
// NODE_DEBUG=http or NODE_DEBUG=http2.
function emitWarningIfNeeded(set) {
    if (""HTTP"" === set || ""HTTP2"" === set) {
        console.warn(
            ""Setting the NODE_DEBUG environment variable "" +
            ""to '"" + set.toLowerCase() + ""' can expose sensitive "" +
            ""data (such as passwords, tokens and authentication headers) "" +
            ""in the resulting log."",
        );
    }
}

const noop = () => { };

function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg) => JSON.stringify(arg)).join("" "");
                console.error(sprintf(""%s %s: %s"", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }

    return debugImpls[set];
}

// debuglogImpl depends on process.pid and process.env.NODE_DEBUG,
// so it needs to be called lazily in top scopes of internal modules
// that may be loaded before these run time states are allowed to
// be accessed.
export function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }

    let debug = (...args) => {
        init();
        // Only invokes debuglogImpl() when the debug function is
        // called for the first time.
        debug = debuglogImpl(enabled, set);

        if (typeof cb === ""function"") {
            cb(debug);
        }

        return debug(...args);
    };

    let enabled;
    let test = () => {
        init();
        test = () => enabled;
        return enabled;
    };

    const logger = (...args) => debug(...args);

    Object.defineProperty(logger, ""enabled"", {
        get() {
            return test();
        },
        configurable: true,
        enumerable: true,
    });

    return logger;
}

let debugEnv = env[""NODE_DEBUG""] ?? """";

initializeDebugEnv(debugEnv);

export default { debuglog };
```"
"```javascript:test\fs\test-fs-write-sync-optional-params.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

// This test ensures that fs.writeSync accepts ""named parameters"" object
// and doesn't interpret objects as strings

import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const dest = path.resolve(tmpdir.path, 'tmp.txt');
const buffer = Buffer.from('zyx');

function testInvalid(dest, expectedCode, ...bufferAndOptions) {
  if (bufferAndOptions.length >= 2) {
    bufferAndOptions[1] = common.mustNotMutateObjectDeep(bufferAndOptions[1]);
  }
  let fd;
  try {
    fd = fs.openSync(dest, 'w+');
    assert.throws(
      () => fs.writeSync(fd, ...bufferAndOptions),
      { code: expectedCode });
  } finally {
    if (fd != null) fs.closeSync(fd);
  }
}

function testValid(dest, buffer, options) {
  const length = options?.length;
  let fd;
  try {
    fd = fs.openSync(dest, 'w+');
    const bytesWritten = fs.writeSync(fd, buffer, options);
    const bytesRead = fs.readSync(fd, buffer, options);

    assert.ok(bytesWritten >= bytesRead);
    if (length !== undefined && length !== null) {
      assert.strictEqual(bytesWritten, length);
    }
  } finally {
    if (fd != null) fs.closeSync(fd);
  }
}

{
  // Test if second argument is not wrongly interpreted as string or options
  for (const badBuffer of [
    undefined, null, true, 42, 42n, Symbol('42'), NaN, [], () => {},
    common.mustNotCall(),
    common.mustNotMutateObjectDeep({}),
    {},
    { buffer: 'amNotParam' },
    { string: 'amNotParam' },
    { buffer: new Uint8Array(1) },
    { buffer: new Uint8Array(1).buffer },
    Promise.resolve(new Uint8Array(1)),
    new Date(),
    new String('notPrimitive'),
    { toString() { return 'amObject'; } },
    { [Symbol.toPrimitive]: (hint) => 'amObject' },
  ]) {
    testInvalid(dest, 'ERR_INVALID_ARG_TYPE', common.mustNotMutateObjectDeep(badBuffer));
  }

  // First argument (buffer or string) is mandatory
  testInvalid(dest, 'ERR_INVALID_ARG_TYPE');

  // Various invalid options
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 5 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: 5 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 1, offset: 3 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: -1 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: -1 });
  testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: false });
  testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: true });

  // Test compatibility with fs.readSync counterpart with reused options
  for (const options of [
    undefined,
    null,
    {},
    { length: 1 },
    { position: 5 },
    { length: 1, position: 5 },
    { length: 1, position: -1, offset: 2 },
    { length: null },
    { position: null },
    { offset: 1 },
  ]) {
    testValid(dest, buffer, common.mustNotMutateObjectDeep(options));
  }
}

```"
"```javascript:test\fs\test-fs-readfile-error.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fs from 'fs';

// Test that fs.readFile fails correctly on a non-existent file.

// `fs.readFile('/')` does not fail on AIX and FreeBSD because you can open
// and read the directory there.
if (common.isAIX || common.isFreeBSD)
  common.skip('platform not supported.');

import assert from 'assert';
import { exec } from 'child_process';
import fixtures from '../common/fixtures';

function test(env, cb) {
  const filename = fixtures.path('test-fs-readfile-error.js');
  const execPath = `""${process.execPath}"" ""${filename}""`;
  const options = { env: { ...process.env, ...env } };
  exec(execPath, options, (err, stdout, stderr) => {
    assert(err);
    assert.strictEqual(stdout, '');
    assert.notStrictEqual(stderr, '');
    cb(String(stderr));
  });
}

test({ NODE_DEBUG: '' }, common.mustCall((data) => {
  assert.match(data, /EISDIR/);
  assert.match(data, /test-fs-readfile-error/);
}));

test({ NODE_DEBUG: 'fs' }, common.mustCall((data) => {
  assert.match(data, /EISDIR/);
  assert.match(data, /test-fs-readfile-error/);
}));

assert.throws(
  () => { fs.readFile(() => {}, common.mustNotCall()); },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The ""path"" argument must be of type string or an instance of ' +
             'Buffer or URL. Received type function ([Function (anonymous)])',
    name: 'TypeError'
  }
);

```"
"```javascript:test\crypto\test-crypto-padding-aes256.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const iv = Buffer.from('00000000000000000000000000000000', 'hex');
const key = Buffer.from('0123456789abcdef0123456789abcdef' +
                        '0123456789abcdef0123456789abcdef', 'hex');

function encrypt(val, pad) {
  const c = crypto.createCipheriv('aes256', key, iv);
  c.setAutoPadding(pad);
  return c.update(val, 'utf8', 'latin1') + c.final('latin1');
}

function decrypt(val, pad) {
  const c = crypto.createDecipheriv('aes256', key, iv);
  c.setAutoPadding(pad);
  return c.update(val, 'latin1', 'utf8') + c.final('utf8');
}

// echo 0123456789abcdef0123456789abcdef \
// | openssl enc -e -aes256 -nopad -K <key> -iv <iv> \
// | openssl enc -d -aes256 -nopad -K <key> -iv <iv>
let plaintext = '0123456789abcdef0123456789abcdef'; // Multiple of block size
let encrypted = encrypt(plaintext, false);
let decrypted = decrypt(encrypted, false);
assert.strictEqual(decrypted, plaintext);

// echo 0123456789abcdef0123456789abcde \
// | openssl enc -e -aes256 -K <key> -iv <iv> \
// | openssl enc -d -aes256 -K <key> -iv <iv>
plaintext = '0123456789abcdef0123456789abcde'; // not a multiple
encrypted = encrypt(plaintext, true);
decrypted = decrypt(encrypted, true);
assert.strictEqual(decrypted, plaintext);

```"
"```javascript:test\fs\test-fs-read-stream-throw-type-error.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';

// This test ensures that appropriate TypeError is thrown by createReadStream
// when an argument with invalid type is passed

const example = fixtures.path('x.txt');
// Should not throw.
fs.createReadStream(example, undefined);
fs.createReadStream(example, null);
fs.createReadStream(example, 'utf8');
fs.createReadStream(example, { encoding: 'utf8' });

const createReadStreamErr = (path, opt, error) => {
  assert.throws(() => {
    fs.createReadStream(path, opt);
  }, error);
};

const typeError = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
};

const rangeError = {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError'
};

[123, 0, true, false].forEach((opts) =>
  createReadStreamErr(example, opts, typeError)
);

// Case 0: Should not throw if either start or end is undefined
[{}, { start: 0 }, { end: Infinity }].forEach((opts) =>
  fs.createReadStream(example, opts)
);

// Case 1: Should throw TypeError if either start or end is not of type 'number'
[
  { start: 'invalid' },
  { end: 'invalid' },
  { start: 'invalid', end: 'invalid' },
].forEach((opts) => createReadStreamErr(example, opts, typeError));

// Case 2: Should throw RangeError if either start or end is NaN
[{ start: NaN }, { end: NaN }, { start: NaN, end: NaN }].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);

// Case 3: Should throw RangeError if either start or end is negative
[{ start: -1 }, { end: -1 }, { start: -1, end: -1 }].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);

// Case 4: Should throw RangeError if either start or end is fractional
[{ start: 0.1 }, { end: 0.1 }, { start: 0.1, end: 0.1 }].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);

// Case 5: Should not throw if both start and end are whole numbers
fs.createReadStream(example, { start: 1, end: 5 });

// Case 6: Should throw RangeError if start is greater than end
createReadStreamErr(example, { start: 5, end: 1 }, rangeError);

// Case 7: Should throw RangeError if start or end is not safe integer
const NOT_SAFE_INTEGER = 2 ** 53;
[
  { start: NOT_SAFE_INTEGER, end: Infinity },
  { start: 0, end: NOT_SAFE_INTEGER },
].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);

```"
"```javascript:modules\internal\streams\legacy.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import EE from ""events"";

function Stream(opts) {
    EE.call(this, opts);
}

Object.setPrototypeOf(Stream.prototype, EE.prototype);
Object.setPrototypeOf(Stream, EE);

Stream.prototype.pipe = function (dest, options) {
    // deno-lint-ignore no-this-alias
    const source = this;

    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }

    source.on(""data"", ondata);

    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }

    dest.on(""drain"", ondrain);

    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on(""end"", onend);
        source.on(""close"", onclose);
    }

    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;

        dest.end();
    }

    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;

        if (typeof dest.destroy === ""function"") dest.destroy();
    }

    // Don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, ""error"") === 0) {
            this.emit(""error"", er);
        }
    }

    prependListener(source, ""error"", onerror);
    prependListener(dest, ""error"", onerror);

    // Remove all the event listeners that were added.
    function cleanup() {
        source.removeListener(""data"", ondata);
        dest.removeListener(""drain"", ondrain);

        source.removeListener(""end"", onend);
        source.removeListener(""close"", onclose);

        source.removeListener(""error"", onerror);
        dest.removeListener(""error"", onerror);

        source.removeListener(""end"", cleanup);
        source.removeListener(""close"", cleanup);

        dest.removeListener(""close"", cleanup);
    }

    source.on(""end"", cleanup);
    source.on(""close"", cleanup);

    dest.on(""close"", cleanup);
    dest.emit(""pipe"", source);

    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === ""function"") {
        return emitter.prependListener(event, fn);
    }

    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [fn, emitter._events[event]];
    }
}

export { prependListener, Stream };
```"
"```javascript:test\crypto\test-crypto-ecdh-convert-key.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const { ECDH, createSign, getCurves } = require('crypto');

// A valid private key for the secp256k1 curve.
const cafebabeKey = 'cafebabe'.repeat(8);
// Associated compressed and uncompressed public keys (points).
const cafebabePubPtComp =
    '03672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3';
const cafebabePubPtUnComp =
    '04672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3' +
    '2e02c7f93d13dc2732b760ca377a5897b9dd41a1c1b29dc0442fdce6d0a04d1d';

// Invalid test: key argument is undefined.
assert.throws(
  () => ECDH.convertKey(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });

// Invalid test: curve argument is undefined.
assert.throws(
  () => ECDH.convertKey(cafebabePubPtComp),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });

// Invalid test: curve argument is invalid.
assert.throws(
  () => ECDH.convertKey(cafebabePubPtComp, 'badcurve'),
  {
    name: 'TypeError',
    message: 'Invalid EC curve name'
  });

if (getCurves().includes('secp256k1')) {
  // Invalid test: format argument is undefined.
  assert.throws(
    () => ECDH.convertKey(cafebabePubPtComp, 'secp256k1', 'hex', 'hex', 10),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_FORMAT',
      name: 'TypeError',
      message: 'Invalid ECDH format: 10'
    });

  // Point formats.
  let uncompressed = ECDH.convertKey(cafebabePubPtComp,
                                     'secp256k1',
                                     'hex',
                                     'buffer',
                                     'uncompressed');
  let compressed = ECDH.convertKey(cafebabePubPtComp,
                                   'secp256k1',
                                   'hex',
                                   'buffer',
                                   'compressed');
  let hybrid = ECDH.convertKey(cafebabePubPtComp,
                               'secp256k1',
                               'hex',
                               'buffer',
                               'hybrid');
  assert.strictEqual(uncompressed[0], 4);
  let firstByte = compressed[0];
  assert(firstByte === 2 || firstByte === 3);
  firstByte = hybrid[0];
  assert(firstByte === 6 || firstByte === 7);

  // Format conversion from hex to hex
  uncompressed = ECDH.convertKey(cafebabePubPtComp,
                                 'secp256k1',
                                 'hex',
                                 'hex',
                                 'uncompressed');
  compressed = ECDH.convertKey(cafebabePubPtComp,
                               'secp256k1',
                               'hex',
                               'hex',
                               'compressed');
  hybrid = ECDH.convertKey(cafebabePubPtComp,
                           'secp256k1',
                           'hex',
                           'hex',
                           'hybrid');
  assert.strictEqual(uncompressed, cafebabePubPtUnComp);
  assert.strictEqual(compressed, cafebabePubPtComp);

  // Compare to getPublicKey.
  const ecdh1 = ECDH('secp256k1');
  ecdh1.generateKeys();
  ecdh1.setPrivateKey(cafebabeKey, 'hex');
  assert.strictEqual(ecdh1.getPublicKey('hex', 'uncompressed'), uncompressed);
  assert.strictEqual(ecdh1.getPublicKey('hex', 'compressed'), compressed);
  assert.strictEqual(ecdh1.getPublicKey('hex', 'hybrid'), hybrid);
}

// See https://github.com/nodejs/node/issues/26133, failed ConvertKey
// operations should not leave errors on OpenSSL's error stack because
// that's observable by subsequent operations.
{
  const privateKey =
    '-----BEGIN EC PRIVATE KEY-----\n' +
    'MHcCAQEEIF+jnWY1D5kbVYDNvxxo/Y+ku2uJPDwS0r/VuPZQrjjVoAoGCCqGSM49\n' +
    'AwEHoUQDQgAEurOxfSxmqIRYzJVagdZfMMSjRNNhB8i3mXyIMq704m2m52FdfKZ2\n' +
    'pQhByd5eyj3lgZ7m7jbchtdgyOF8Io/1ng==\n' +
    '-----END EC PRIVATE KEY-----';

  const sign = createSign('sha256').update('plaintext');

  // TODO(bnoordhuis) This should really bubble up the specific OpenSSL error
  // rather than Node's generic error message.
  const badKey = 'f'.repeat(128);
  assert.throws(
    () => ECDH.convertKey(badKey, 'secp521r1', 'hex', 'hex', 'compressed'),
    /Failed to convert Buffer to EC_POINT/);

  // Next statement should not throw an exception.
  sign.sign(privateKey);
}

```"
"```javascript:test\fs\test-fs-watch-encoding.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This test is a bit more complicated than it ideally needs to be to work
// around issues on OS X and SmartOS.
//
// On OS X, watch events are subject to peculiar timing oddities such that an
// event might fire out of order. The synchronous refreshing of the tmp
// directory might trigger an event on the watchers that are instantiated after
// it!
//
// On SmartOS, the watch events fire but the filename is null.

import common from '../common';

// fs-watch on folders have limited capability in AIX.
// The testcase makes use of folder watching, and causes
// hang. This behavior is documented. Skip this for AIX.

if (common.isAIX)
  common.skip('folder watch capability is limited in AIX.');

import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = '���������������.txt';
const a = path.join(tmpdir.path, fn);

const watchers = new Set();

function registerWatcher(watcher) {
  watchers.add(watcher);
}

function unregisterWatcher(watcher) {
  watcher.close();
  watchers.delete(watcher);
  if (watchers.size === 0) {
    clearInterval(interval);
  }
}

{
  // Test that using the `encoding` option has the expected result.
  const watcher = fs.watch(
    tmpdir.path,
    { encoding: 'hex' },
    (event, filename) => {
      if (['e696b0e5bbbae69687e5a4b9e4bbb62e747874', null].includes(filename))
        done(watcher);
    }
  );
  registerWatcher(watcher);
}

{
  // Test that in absence of `encoding` option has the expected result.
  const watcher = fs.watch(
    tmpdir.path,
    (event, filename) => {
      if ([fn, null].includes(filename))
        done(watcher);
    }
  );
  registerWatcher(watcher);
}

{
  // Test that using the `encoding` option has the expected result.
  const watcher = fs.watch(
    tmpdir.path,
    { encoding: 'buffer' },
    (event, filename) => {
      if (filename instanceof Buffer && filename.toString('utf8') === fn)
        done(watcher);
      else if (filename === null)
        done(watcher);
    }
  );
  registerWatcher(watcher);
}

const done = common.mustCall(unregisterWatcher, watchers.size);

// OS X and perhaps other systems can have surprising race conditions with
// file events. So repeat the operation in case it is missed the first time.
const interval = setInterval(() => {
  const fd = fs.openSync(a, 'w+');
  fs.closeSync(fd);
  fs.unlinkSync(a);
}, common.platformTimeout(100));

```"
"```javascript:test\fs\test-fs-read-position-validation.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import * as common from '../common';
import * as fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';

// This test ensures that ""position"" argument is correctly validated

const filepath = fixtures.path('x.txt');

const buffer = Buffer.from('xyz\n');
const offset = 0;
const length = buffer.byteLength;

// allowedErrors is an array of acceptable internal errors
// For example, on some platforms read syscall might return -EFBIG or -EOVERFLOW
async function testValid(position, allowedErrors = []) {
  return new Promise((resolve, reject) => {
    fs.open(filepath, 'r', common.mustSucceed((fd) => {
      let callCount = 3;
      const handler = common.mustCall((err) => {
        callCount--;
        if (err && !allowedErrors.includes(err.code)) {
          fs.close(fd, common.mustSucceed());
          reject(err);
        } else if (callCount === 0) {
          fs.close(fd, common.mustSucceed(resolve));
        }
      }, callCount);
      fs.read(fd, buffer, offset, length, position, handler);
      fs.read(fd, { buffer, offset, length, position }, handler);
      fs.read(fd, buffer, common.mustNotMutateObjectDeep({ offset, length, position }), handler);
    }));
  });
}

async function testInvalid(code, position) {
  return new Promise((resolve, reject) => {
    fs.open(filepath, 'r', common.mustSucceed((fd) => {
      try {
        assert.throws(
          () => fs.read(fd, buffer, offset, length, position, common.mustNotCall()),
          { code }
        );
        assert.throws(
          () => fs.read(fd, { buffer, offset, length, position }, common.mustNotCall()),
          { code }
        );
        assert.throws(
          () => fs.read(fd, buffer, common.mustNotMutateObjectDeep({ offset, length, position }), common.mustNotCall()),
          { code }
        );
        resolve();
      } catch (err) {
        reject(err);
      } finally {
        fs.close(fd, common.mustSucceed());
      }
    }));
  });
}

(async () => {
  await testValid(undefined);
  await testValid(null);
  await testValid(-1);
  await testValid(-1n);

  await testValid(0);
  await testValid(0n);
  await testValid(1);
  await testValid(1n);
  await testValid(9);
  await testValid(9n);
  await testValid(Number.MAX_SAFE_INTEGER, ['EFBIG', 'EOVERFLOW']);

  await testValid(2n ** 63n - 1n - BigInt(length), ['EFBIG', 'EOVERFLOW']);
  await testInvalid('ERR_OUT_OF_RANGE', 2n ** 63n);

  // TODO(LiviaMedeiros): test `2n ** 63n - BigInt(length)`

  await testInvalid('ERR_OUT_OF_RANGE', NaN);
  await testInvalid('ERR_OUT_OF_RANGE', -Infinity);
  await testInvalid('ERR_OUT_OF_RANGE', Infinity);
  await testInvalid('ERR_OUT_OF_RANGE', -0.999);
  await testInvalid('ERR_OUT_OF_RANGE', -(2n ** 64n));
  await testInvalid('ERR_OUT_OF_RANGE', Number.MAX_SAFE_INTEGER + 1);
  await testInvalid('ERR_OUT_OF_RANGE', Number.MAX_VALUE);

  for (const badTypeValue of [
    false, true, '1', Symbol(1), {}, [], () => { }, Promise.resolve(1),
  ]) {
    await testInvalid('ERR_INVALID_ARG_TYPE', badTypeValue);
  }
})();

```"
"```javascript:modules\fs.js
import promises from ""./fs/promises""

import {
    stat,
    statSync,
    lstat,
    lstatSync,
    fstat,
    fstatSync,
    access,
    accessSync,
    exists,
    existsSync,
    mkdir,
    mkdirSync,
    fchown,
    fchownSync,
    chown,
    chownSync,
    lchown,
    lchownSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    fchmod,
    fchmodSync,
    lchmod,
    lchmodSync,
    chmod,
    chmodSync,
    futimes,
    futimesSync,
    lutimes,
    lutimesSync,
    utimes,
    utimesSync,
    rename,
    renameSync,
    unlink,
    unlinkSync,
    truncate,
    truncateSync,
    ftruncate,
    ftruncateSync,
    realpath,
    realpathSync,
    mkdtemp,
    mkdtempSync,
    copyFile,
    copyFileSync,
    link,
    linkSync,
    symlink,
    symlinkSync,
    close,
    closeSync,
    fdatasync,
    fdatasyncSync,
    fsync,
    fsyncSync,
    read,
    readSync,
    open,
    openSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    readv,
    readvSync,
    write,
    writeSync,
    writeFile,
    writeFileSync,
    appendFile,
    appendFileSync,
    writev,
    writevSync,
    opendir,
    opendirSync,
    Dir,
    Dirent,
    readdir,
    readdirSync,
    watch,
    watchFile,
    unwatch,
    cp,
    cpSync,
    createWriteStream,
    WriteStream,
    createReadStream,
    ReadStream,
    FileHandle,
    constants
} from ""./internal/fs"";

export default {
    F_OK: constants.F_OK,
    R_OK: constants.R_OK,
    W_OK: constants.W_OK,
    X_OK: constants.X_OK,
    promises,
    stat,
    statSync,
    lstat,
    lstatSync,
    fstat,
    fstatSync,
    access,
    accessSync,
    exists,
    existsSync,
    mkdir,
    mkdirSync,
    fchown,
    fchownSync,
    chown,
    chownSync,
    lchown,
    lchownSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    fchmod,
    fchmodSync,
    lchmod,
    lchmodSync,
    chmod,
    chmodSync,
    futimes,
    futimesSync,
    lutimes,
    lutimesSync,
    utimes,
    utimesSync,
    rename,
    renameSync,
    unlink,
    unlinkSync,
    truncate,
    truncateSync,
    ftruncate,
    ftruncateSync,
    realpath,
    realpathSync,
    mkdtemp,
    mkdtempSync,
    copyFile,
    copyFileSync,
    link,
    linkSync,
    symlink,
    symlinkSync,
    close,
    closeSync,
    fdatasync,
    fdatasyncSync,
    fsync,
    fsyncSync,
    read,
    readSync,
    open,
    openSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    readv,
    readvSync,
    write,
    writeSync,
    writeFile,
    writeFileSync,
    appendFile,
    appendFileSync,
    writev,
    writevSync,
    opendir,
    opendirSync,
    Dir,
    Dirent,
    readdir,
    readdirSync,
    watch,
    watchFile,
    unwatch,
    cp,
    cpSync,
    createWriteStream,
    WriteStream,
    createReadStream,
    ReadStream,
    FileHandle,
    constants
}

const F_OK = constants.F_OK;
const R_OK = constants.R_OK;
const W_OK = constants.W_OK;
const X_OK = constants.X_OK;

export {
    F_OK,
    R_OK,
    W_OK,
    X_OK,
    promises,
    stat,
    statSync,
    lstat,
    lstatSync,
    fstat,
    fstatSync,
    access,
    accessSync,
    exists,
    existsSync,
    mkdir,
    mkdirSync,
    fchown,
    fchownSync,
    chown,
    chownSync,
    lchown,
    lchownSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    fchmod,
    fchmodSync,
    lchmod,
    lchmodSync,
    chmod,
    chmodSync,
    futimes,
    futimesSync,
    lutimes,
    lutimesSync,
    utimes,
    utimesSync,
    rename,
    renameSync,
    unlink,
    unlinkSync,
    truncate,
    truncateSync,
    ftruncate,
    ftruncateSync,
    realpath,
    realpathSync,
    mkdtemp,
    mkdtempSync,
    copyFile,
    copyFileSync,
    link,
    linkSync,
    symlink,
    symlinkSync,
    close,
    closeSync,
    fdatasync,
    fdatasyncSync,
    fsync,
    fsyncSync,
    read,
    readSync,
    open,
    openSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    readv,
    readvSync,
    write,
    writeSync,
    writeFile,
    writeFileSync,
    appendFile,
    appendFileSync,
    writev,
    writevSync,
    opendir,
    opendirSync,
    Dir,
    Dirent,
    readdir,
    readdirSync,
    watch,
    watchFile,
    unwatch,
    cp,
    cpSync,
    createWriteStream,
    WriteStream,
    createReadStream,
    ReadStream,
    FileHandle,
    constants
}
```"
"```javascript:test\fs\test-fs-utimes-y2K38.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

import assert from 'assert';
import fs from 'fs';

import { spawnSync } from 'child_process';

// Check for Y2K38 support. For Windows, assume it's there. Windows
// doesn't have `touch` and `date -r` which are used in the check for support.
if (!common.isWindows) {
  const testFilePath = `${tmpdir.path}/y2k38-test`;
  const testFileDate = '204001020304';
  
  const touchResult = spawnSync('touch',
                                ['-t', testFileDate, testFilePath],
                                { encoding: 'utf8' });
  if (touchResult.status !== 0) {
    common.skip('File system appears to lack Y2K38 support (touch failed)');
  }

  // On some file systems that lack Y2K38 support, `touch` will succeed but
  // the time will be incorrect.
  const dateResult = spawnSync('date',
                               ['-r', testFilePath, '+%Y%m%d%H%M'],
                               { encoding: 'utf8' });
  if (dateResult.status === 0) {
    if (dateResult.stdout.trim() !== testFileDate) {
      common.skip('File system appears to lack Y2k38 support (date failed)');
    }
  } else {
    // On some platforms `date` may not support the `-r` option. Usually
    // this will result in a non-zero status and usage information printed.
    // In this case optimistically proceed -- the earlier `touch` succeeded
    // but validation that the file has the correct time is not easily possible.
    assert.match(dateResult.stderr, /[Uu]sage:/);
  }
}

// Ref: https://github.com/nodejs/node/issues/13255
const path = `${tmpdir.path}/test-utimes-precision`;
fs.writeFileSync(path, '');

const Y2K38_mtime = 2 ** 31;
fs.utimesSync(path, Y2K38_mtime, Y2K38_mtime);
const Y2K38_stats = fs.statSync(path);
assert.strictEqual(Y2K38_stats.mtime.getTime() / 1000, Y2K38_mtime);

if (common.isWindows) {
  // This value would get converted to (double)1713037251359.9998
  const truncate_mtime = 1713037251360;
  fs.utimesSync(path, truncate_mtime / 1000, truncate_mtime / 1000);
  const truncate_stats = fs.statSync(path);
  assert.strictEqual(truncate_stats.mtime.getTime(), truncate_mtime);

  // test Y2K38 for windows
  // This value if treaded as a `signed long` gets converted to -2135622133469.
  // POSIX systems stores timestamps in {long t_sec, long t_usec}.
  // NTFS stores times in nanoseconds in a single `uint64_t`, so when libuv
  // calculates (long)`uv_timespec_t.tv_sec` we get 2's complement.
  const overflow_mtime = 2159345162531;
  fs.utimesSync(path, overflow_mtime / 1000, overflow_mtime / 1000);
  const overflow_stats = fs.statSync(path);
  assert.strictEqual(overflow_stats.mtime.getTime(), overflow_mtime);
}

```"
"```javascript:test\path\test-path-makelong.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';

if (common.isWindows) {
  const file = fixtures.path('a.js');
  const resolvedFile = path.resolve(file);

  assert.strictEqual(path.toNamespacedPath(file),
                     `\\\\?\\${resolvedFile}`);
  assert.strictEqual(path.toNamespacedPath(`\\\\?\\${file}`),
                     `\\\\?\\${resolvedFile}`);
  assert.strictEqual(path.toNamespacedPath(
    '\\\\someserver\\someshare\\somefile'),
                     '\\\\?\\UNC\\someserver\\someshare\\somefile');
  assert.strictEqual(path.toNamespacedPath(
    '\\\\?\\UNC\\someserver\\someshare\\somefile'),
                     '\\\\?\\UNC\\someserver\\someshare\\somefile');
  assert.strictEqual(path.toNamespacedPath('\\\\.\\pipe\\somepipe'),
                     '\\\\.\\pipe\\somepipe');
}

assert.strictEqual(path.toNamespacedPath(''), '');
assert.strictEqual(path.toNamespacedPath(null), null);
assert.strictEqual(path.toNamespacedPath(100), 100);
assert.strictEqual(path.toNamespacedPath(path), path);
assert.strictEqual(path.toNamespacedPath(false), false);
assert.strictEqual(path.toNamespacedPath(true), true);

const emptyObj = {};
assert.strictEqual(path.posix.toNamespacedPath('/foo/bar'), '/foo/bar');
assert.strictEqual(path.posix.toNamespacedPath('foo/bar'), 'foo/bar');
assert.strictEqual(path.posix.toNamespacedPath(null), null);
assert.strictEqual(path.posix.toNamespacedPath(true), true);
assert.strictEqual(path.posix.toNamespacedPath(1), 1);
assert.strictEqual(path.posix.toNamespacedPath(), undefined);
assert.strictEqual(path.posix.toNamespacedPath(emptyObj), emptyObj);
if (common.isWindows) {
  // These tests cause resolve() to insert the cwd, so we cannot test them from
  // non-Windows platforms (easily)
  assert.strictEqual(path.toNamespacedPath(''), '');
  assert.strictEqual(path.win32.toNamespacedPath('foo\\bar').toLowerCase(),
                     `\\\\?\\${process.cwd().toLowerCase()}\\foo\\bar`);
  assert.strictEqual(path.win32.toNamespacedPath('foo/bar').toLowerCase(),
                     `\\\\?\\${process.cwd().toLowerCase()}\\foo\\bar`);
  const currentDeviceLetter = path.parse(process.cwd()).root.substring(0, 2);
  assert.strictEqual(
    path.win32.toNamespacedPath(currentDeviceLetter).toLowerCase(),
    `\\\\?\\${process.cwd().toLowerCase()}`);
  assert.strictEqual(path.win32.toNamespacedPath('C').toLowerCase(),
                     `\\\\?\\${process.cwd().toLowerCase()}\\c`);
}
/*
assert.strictEqual(path.win32.toNamespacedPath('C:\\foo'), '\\\\?\\C:\\foo');
assert.strictEqual(path.win32.toNamespacedPath('C:/foo'), '\\\\?\\C:\\foo');
assert.strictEqual(path.win32.toNamespacedPath('\\\\foo\\bar'),
                   '\\\\?\\UNC\\foo\\bar\\');
assert.strictEqual(path.win32.toNamespacedPath('//foo//bar'),
                   '\\\\?\\UNC\\foo\\bar\\');
assert.strictEqual(path.win32.toNamespacedPath('\\\\?\\foo'), '\\\\?\\foo');
assert.strictEqual(path.win32.toNamespacedPath(null), null);
assert.strictEqual(path.win32.toNamespacedPath(true), true);
assert.strictEqual(path.win32.toNamespacedPath(1), 1);
assert.strictEqual(path.win32.toNamespacedPath(), undefined);
assert.strictEqual(path.win32.toNamespacedPath(emptyObj), emptyObj);
*/
```"
"```javascript:test\fs\test-fs-sync-fd-leak.js
// Flags: --expose-internals
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import fs from 'fs';
import { internalBinding } from 'internal/test/binding';
const { UV_EBADF } = internalBinding('uv');

// Ensure that (read|write|append)FileSync() closes the file descriptor
fs.openSync = function() {
  return 42;
};
fs.closeSync = function(fd) {
  assert.strictEqual(fd, 42);
  close_called++;
};
fs.readSync = function() {
  throw new Error('BAM');
};
fs.writeSync = function() {
  throw new Error('BAM');
};

internalBinding('fs').fstat = function(fd, bigint, _, ctx) {
  ctx.errno = UV_EBADF;
  ctx.syscall = 'fstat';
};

let close_called = 0;
ensureThrows(function() {
  fs.readFileSync('dummy');
}, 'EBADF: bad file descriptor, fstat');
ensureThrows(function() {
  fs.writeFileSync('dummy', 'xxx');
}, 'BAM');
ensureThrows(function() {
  fs.appendFileSync('dummy', 'xxx');
}, 'BAM');

function ensureThrows(cb, message) {
  let got_exception = false;

  close_called = 0;
  try {
    cb();
  } catch (e) {
    assert.strictEqual(e.message, message);
    got_exception = true;
  }

  assert.strictEqual(close_called, 1);
  assert.strictEqual(got_exception, true);
}

```"
"```javascript:test\path\test-path.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';

// Test thrown TypeErrors
const typeErrorTests = [true, false, 7, null, {}, undefined, [], NaN];

function fail(fn) {
  const args = Array.from(arguments).slice(1);

  assert.throws(() => {
    fn.apply(null, args);
  }, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });
}

typeErrorTests.forEach((test) => {
  [path.posix, /*path.win32*/].forEach((namespace) => {
    fail(namespace.join, test);
    fail(namespace.resolve, test);
    fail(namespace.normalize, test);
    fail(namespace.isAbsolute, test);
    fail(namespace.relative, test, 'foo');
    fail(namespace.relative, 'foo', test);
    fail(namespace.parse, test);
    fail(namespace.dirname, test);
    fail(namespace.basename, test);
    fail(namespace.extname, test);

    // Undefined is a valid value as the second argument to basename
    if (test !== undefined) {
      fail(namespace.basename, 'foo', test);
    }
  });
});

// path.sep tests
// windows
// assert.strictEqual(path.win32.sep, '\\');
// posix
assert.strictEqual(path.posix.sep, '/');

// path.delimiter tests
// windows
// assert.strictEqual(path.win32.delimiter, ';');
// posix
assert.strictEqual(path.posix.delimiter, ':');

if (common.isWindows)
  assert.strictEqual(path, path.win32);
else
  assert.strictEqual(path, path.posix);

```"
"```javascript:modules\internal\streams\from.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { Buffer } from ""buffer"";
import { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } from ""../errors.js"";

function _from(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === ""string"" || iterable instanceof Buffer) {
        return new Readable({
            objectMode: true,
            ...opts,
            read() {
                this.push(iterable);
                this.push(null);
            },
        });
    }

    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE(""iterable"", [""Iterable""], iterable);
    }

    const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts,
    });

    // Flag to protect against _read
    // being called before last iteration completion.
    let reading = false;

    readable._read = function () {
        if (!reading) {
            reading = true;
            next();
        }
    };

    readable._destroy = function (error, cb) {
        close(error).then(
            () => nextTick(cb, error), // nextTick is here in case cb throws
            (e) => nextTick(cb, e || error),
        );
    };

    async function close(error) {
        const hadError = (error !== undefined) && (error !== null);
        const hasThrow = typeof iterator.throw === ""function"";
        if (hadError && hasThrow) {
            const { value, done } = await iterator.throw(error);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === ""function"") {
            const { value } = await iterator.return();
            await value;
        }
    }

    async function next() {
        for (; ;) {
            try {
                const { value, done } = isAsync
                    ? await iterator.next()
                    : iterator.next();

                if (done) {
                    readable.push(null);
                } else {
                    const res = (value &&
                        typeof value.then === ""function"")
                        ? await value
                        : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}

export default _from;
```"
"```javascript:test\fs\test-fs-write-stream-err.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const stream = fs.createWriteStream(`${tmpdir.path}/out`, {
  highWaterMark: 10
});
const err = new Error('BAM');

const write = fs.write;
let writeCalls = 0;
fs.write = function() {
  switch (writeCalls++) {
    case 0:
      console.error('first write');
      // First time is ok.
      return write.apply(fs, arguments);
    case 1: {
      // Then it breaks.
      console.error('second write');
      const cb = arguments[arguments.length - 1];
      return process.nextTick(function() {
        cb(err);
      });
    }
    default:
      // It should not be called again!
      throw new Error('BOOM!');
  }
};

fs.close = common.mustCall(function(fd_, cb) {
  console.error('fs.close', fd_, stream.fd);
  assert.strictEqual(fd_, stream.fd);
  fs.closeSync(fd_);
  process.nextTick(cb);
});

stream.on('error', common.mustCall(function(err_) {
  console.error('error handler');
  assert.strictEqual(stream.fd, null);
  assert.strictEqual(err_, err);
}));


stream.write(Buffer.allocUnsafe(256), function() {
  console.error('first cb');
  stream.write(Buffer.allocUnsafe(256), common.mustCall(function(err_) {
    console.error('second cb');
    assert.strictEqual(err_, err);
  }));
});

```"
"```javascript:test\fs\test-fs-watch.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

// Tests if `filename` is provided to watcher on supported platforms

import fs from 'fs';
import assert from 'assert';
import { join } from 'path';

class WatchTestCase {
  constructor(shouldInclude, dirName, fileName, field) {
    this.dirName = dirName;
    this.fileName = fileName;
    this.field = field;
    this.shouldSkip = !shouldInclude;
  }
  get dirPath() { return join(tmpdir.path, this.dirName); }
  get filePath() { return join(this.dirPath, this.fileName); }
}

const cases = [
  // Watch on a file should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows || common.isAIX,
    'watch1',
    'foo',
    'filePath'
  ),
  // Watch on a directory should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows,
    'watch2',
    'bar',
    'dirPath'
  ),
];

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

for (const testCase of cases) {
  if (testCase.shouldSkip) continue;
  fs.mkdirSync(testCase.dirPath);
  // Long content so it's actually flushed.
  const content1 = Date.now() + testCase.fileName.toLowerCase().repeat(1e4);
  fs.writeFileSync(testCase.filePath, content1);

  let interval;
  const pathToWatch = testCase[testCase.field];
  const watcher = fs.watch(pathToWatch);
  watcher.on('error', (err) => {
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
    assert.fail(err);
  });
  watcher.on('close', common.mustCall(() => {
    watcher.close(); // Closing a closed watcher should be a noop
  }));
  watcher.on('change', common.mustCall(function(eventType, argFilename) {
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
    if (common.isOSX)
      assert.strictEqual(['rename', 'change'].includes(eventType), true);
    else
      assert.strictEqual(eventType, 'change');
    assert.strictEqual(argFilename, testCase.fileName);

    watcher.close();

    // We document that watchers cannot be used anymore when it's closed,
    // here we turn the methods into noops instead of throwing
    watcher.close(); // Closing a closed watcher should be a noop
  }));

  // Long content so it's actually flushed. toUpperCase so there's real change.
  const content2 = Date.now() + testCase.fileName.toUpperCase().repeat(1e4);
  interval = setInterval(() => {
    fs.writeFileSync(testCase.filePath, '');
    fs.writeFileSync(testCase.filePath, content2);
  }, 100);
}

[false, 1, {}, [], null, undefined].forEach((input) => {
  assert.throws(
    () => fs.watch(input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-whatwg-url.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import os from 'os';

function pathToFileURL(p) {
  if (!path.isAbsolute(p))
    throw new Error('Path must be absolute');
  if (common.isWindows && p.startsWith('\\\\'))
    p = p.slice(2);
  return new URL(`file://${p}`);
}

const p = path.resolve(fixtures.fixturesDir, 'a.js');
const url = pathToFileURL(p);

assert(url instanceof URL);

// Check that we can pass in a URL object successfully
fs.readFile(url, common.mustSucceed((data) => {
  assert(Buffer.isBuffer(data));
}));

// Check that using a non file:// URL reports an error
const httpUrl = new URL('http://example.org');

assert.throws(
  () => {
    fs.readFile(httpUrl, common.mustNotCall());
  },
  {
    code: 'ERR_INVALID_URL_SCHEME',
    name: 'TypeError',
    message: 'The URL must be of scheme file'
  });

// pct-encoded characters in the path will be decoded and checked
if (common.isWindows) {
  // Encoded back and forward slashes are not permitted on windows
  ['%2f', '%2F', '%5c', '%5C'].forEach((i) => {
    assert.throws(
      () => {
        fs.readFile(new URL(`file:///c:/tmp/${i}`), common.mustNotCall());
      },
      {
        code: 'ERR_INVALID_FILE_URL_PATH',
        name: 'TypeError',
        message: 'File URL path must not include encoded \\ or / characters'
      }
    );
  });
  assert.throws(
    () => {
      fs.readFile(new URL('file:///c:/tmp/%00test'), common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_ARG_VALUE',
      name: 'TypeError',
      message: 'The argument \'path\' must be a string or Uint8Array without ' +
               ""null bytes. Received 'c:\\\\tmp\\\\\\x00test'""
    }
  );
} else {
  // Encoded forward slashes are not permitted on other platforms
  ['%2f', '%2F'].forEach((i) => {
    assert.throws(
      () => {
        fs.readFile(new URL(`file:///c:/tmp/${i}`), common.mustNotCall());
      },
      {
        code: 'ERR_INVALID_FILE_URL_PATH',
        name: 'TypeError',
        message: 'File URL path must not include encoded / characters'
      });
  });
  assert.throws(
    () => {
      fs.readFile(new URL('file://hostname/a/b/c'), common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_FILE_URL_HOST',
      name: 'TypeError',
      message: `File URL host must be ""localhost"" or empty on ${os.platform()}`
    }
  );
  assert.throws(
    () => {
      fs.readFile(new URL('file:///tmp/%00test'), common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_ARG_VALUE',
      name: 'TypeError',
      message: ""The argument 'path' must be a string or Uint8Array without "" +
               ""null bytes. Received '/tmp/\\x00test'""
    }
  );
}

```"
"```javascript:test\fs\test-fs-fchmod.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

// This test ensures that input for fchmod is valid, testing for valid
// inputs for fd and mode

// Check input type
[false, null, undefined, {}, [], ''].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""fd"" argument must be of type number.' +
             common.invalidArgTypeHelper(input)
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
});


[false, null, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
  };
  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});

assert.throws(() => fs.fchmod(1, '123x'), {
  code: 'ERR_INVALID_ARG_VALUE'
});

[-1, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be >= 0 && <= ' +
             `2147483647. Received ${input}`
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
});

[-1, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""mode"" is out of range. It must be >= 0 && <= ' +
             `4294967295. Received ${input}`
  };

  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});

[NaN, Infinity].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be an integer. ' +
             `Received ${input}`
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
  errObj.message = errObj.message.replace('fd', 'mode');
  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});

[1.5].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be an integer. ' +
             `Received ${input}`
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
  errObj.message = errObj.message.replace('fd', 'mode');
  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});

```"
"```javascript:test\crypto\test-crypto-from-binary.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// This is the same as test/simple/test-crypto, but from before the shift
// to use buffers by default.


const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const EXTERN_APEX = 0xFBEE9;

// Manually controlled string for checking binary output
let ucs2_control = 'a\u0000';

// Grow the strings to proper length
while (ucs2_control.length <= EXTERN_APEX) {
  ucs2_control = ucs2_control.repeat(2);
}


// Check resultant buffer and output string
const b = Buffer.from(ucs2_control + ucs2_control, 'ucs2');

//
// Test updating from birant data
//
{
  const datum1 = b.slice(700000);
  const hash1_converted = crypto.createHash('sha1')
    .update(datum1.toString('base64'), 'base64')
    .digest('hex');
  const hash1_direct = crypto.createHash('sha1').update(datum1).digest('hex');
  assert.strictEqual(hash1_direct, hash1_converted);

  const datum2 = b;
  const hash2_converted = crypto.createHash('sha1')
    .update(datum2.toString('base64'), 'base64')
    .digest('hex');
  const hash2_direct = crypto.createHash('sha1').update(datum2).digest('hex');
  assert.strictEqual(hash2_direct, hash2_converted);
}

```"
"```javascript:test\fs\test-fs-watchfile-bigint.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Flags: --expose-internals

import common from '../common';

import assert from 'assert';
import { BigIntStats } from 'internal/fs/utils';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const enoentFile = path.join(tmpdir.path, 'non-existent-file');
const expectedStatObject = new BigIntStats(
  0n,                                        // dev
  0n,                                        // mode
  0n,                                        // nlink
  0n,                                        // uid
  0n,                                        // gid
  0n,                                        // rdev
  0n,                                        // blksize
  0n,                                        // ino
  0n,                                        // size
  0n,                                        // blocks
  0n,                                        // atimeMs
  0n,                                        // mtimeMs
  0n,                                        // ctimeMs
  0n,                                        // birthtimeMs
  0n,                                        // atimeNs
  0n,                                        // mtimeNs
  0n,                                        // ctimeNs
  0n                                         // birthtimeNs
);

tmpdir.refresh();

// If the file initially didn't exist, and gets created at a later point of
// time, the callback should be invoked again with proper values in stat object
let fileExists = false;
const options = { interval: 0, bigint: true };

const watcher =
  fs.watchFile(enoentFile, options, common.mustCall((curr, prev) => {
    if (!fileExists) {
      // If the file does not exist, all the fields should be zero and the date
      // fields should be UNIX EPOCH time
      assert.deepStrictEqual(curr, expectedStatObject);
      assert.deepStrictEqual(prev, expectedStatObject);
      // Create the file now, so that the callback will be called back once the
      // event loop notices it.
      fs.closeSync(fs.openSync(enoentFile, 'w'));
      fileExists = true;
    } else {
      // If the ino (inode) value is greater than zero, it means that the file
      // is present in the filesystem and it has a valid inode number.
      assert(curr.ino > 0n);
      // As the file just got created, previous ino value should be lesser than
      // or equal to zero (non-existent file).
      assert(prev.ino <= 0n);
      // Stop watching the file
      fs.unwatchFile(enoentFile);
      watcher.stop();  // Stopping a stopped watcher should be a noop
    }
  }, 2));

// 'stop' should only be emitted once - stopping a stopped watcher should
// not trigger a 'stop' event.
watcher.on('stop', common.mustCall(function onStop() {}));

```"
"```javascript:example_js\create-react-app-ssr\server\index.js
import * as React from 'react';
import ReactDOMServer from 'react-dom/server';
import * as std from 'std';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import App from '../src/App.js';

async function handle_client(cs) {
    print('open:', cs.peer());
    let buffer = new http.Buffer();

    while (true) {
        try {
            let d = await cs.read();
            if (d == undefined || d.byteLength <= 0) {
                return;
            }
            buffer.append(d);
            let req = buffer.parseRequest();
            if (req instanceof http.WasiRequest) {
                handle_req(cs, req);
                break;
            }
        } catch (e) {
            print(e);
        }
    }
    print('end:', cs.peer());
}

function enlargeArray(oldArr, newLength) {
    let newArr = new Uint8Array(newLength);
    oldArr && newArr.set(oldArr, 0);
    return newArr;
}

async function handle_req(s, req) {
    print('uri:', req.uri)

    let resp = new http.WasiResponse();
    let content = '';
    if (req.uri == '/') {
        const app = ReactDOMServer.renderToString(<App />);
        content = std.loadFile('./build/index.html');
        content = content.replace('<div id=""root""></div>', `<div id=""root"">${app}</div>`);
    } else {
        let chunk = 1000; // Chunk size of each reading
        let length = 0; // The whole length of the file
        let byteArray = null; // File content as Uint8Array
        
        // Read file into byteArray by chunk
        let file = std.open('./build' + req.uri, 'r');
        while (true) {
            byteArray = enlargeArray(byteArray, length + chunk);
            let readLen = file.read(byteArray.buffer, length, chunk);
            length += readLen;
            if (readLen < chunk) {
                break;
            }
        }
        content = byteArray.slice(0, length).buffer;
        file.close();
    }
    let contentType = 'text/html; charset=utf-8';
    if (req.uri.endsWith('.css')) {
        contentType = 'text/css; charset=utf-8';
    } else if (req.uri.endsWith('.js')) {
        contentType = 'text/javascript; charset=utf-8';
    } else if (req.uri.endsWith('.json')) {
        contentType = 'text/json; charset=utf-8';
    } else if (req.uri.endsWith('.ico')) {
        contentType = 'image/vnd.microsoft.icon';
    } else if (req.uri.endsWith('.png')) {
        contentType = 'image/png';
    }
    resp.headers = {
        'Content-Type': contentType
    };

    let r = resp.encode(content);
    s.write(r);
}

async function server_start() {
    print('listen 8003...');
    try {
        let s = new net.WasiTcpServer(8003);
        for (var i = 0; ; i++) {
            let cs = await s.accept();
            handle_client(cs);
        }
    } catch (e) {
        print(e);
    }
}

server_start();

```"
"```javascript:test\fs\test-fs-write-sync.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const filename = path.join(tmpdir.path, 'write.txt');

tmpdir.refresh();

{
  const parameters = [Buffer.from('b��r'), 0, Buffer.byteLength('b��r')];

  // The first time fs.writeSync is called with all parameters provided.
  // After that, each pop in the cycle removes the final parameter. So:
  // - The 2nd time fs.writeSync with a buffer, without the length parameter.
  // - The 3rd time fs.writeSync with a buffer, without the offset and length
  //   parameters.
  while (parameters.length > 0) {
    const fd = fs.openSync(filename, 'w');

    let written = fs.writeSync(fd, '');
    assert.strictEqual(written, 0);

    fs.writeSync(fd, 'foo');

    written = fs.writeSync(fd, ...parameters);
    assert.ok(written > 3);
    fs.closeSync(fd);

    assert.strictEqual(fs.readFileSync(filename, 'utf-8'), 'foob��r');

    parameters.pop();
  }
}

```"
"```javascript:test\fs\test-fs-read-stream-err.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const stream = fs.createReadStream(__filename, {
  bufferSize: 64
});
const err = new Error('BAM');

stream.on('error', common.mustCall((err_) => {
  process.nextTick(common.mustCall(() => {
    assert.strictEqual(stream.fd, null);
    assert.strictEqual(err_, err);
  }));
}));

fs.close = common.mustCall((fd_, cb) => {
  assert.strictEqual(fd_, stream.fd);
  process.nextTick(cb);
});

const read = fs.read;
fs.read = function() {
  // First time is ok.
  read.apply(fs, arguments);
  // Then it breaks.
  fs.read = common.mustCall(function() {
    const cb = arguments[arguments.length - 1];
    process.nextTick(() => {
      cb(err);
    });
    // It should not be called again!
    fs.read = () => {
      throw new Error('BOOM!');
    };
  });
};

stream.on('data', (buf) => {
  stream.on('data', common.mustNotCall(""no more 'data' events should follow""));
});

```"
"```javascript:test\fs\test-fs-write-stream.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const file = path.join(tmpdir.path, 'write.txt');

tmpdir.refresh();

{
  const stream = fs.WriteStream(file);
  const _fs_close = fs.close;

  fs.close = function(fd) {
    assert.ok(fd, 'fs.close must not be called without an undefined fd.');
    fs.close = _fs_close;
    fs.closeSync(fd);
  };
  stream.destroy();
}

{
  const stream = fs.createWriteStream(file);

  stream.on('drain', function() {
    assert.fail('\'drain\' event must not be emitted before ' +
                'stream.write() has been called at least once.');
  });
  stream.destroy();
}

// Throws if data is not of type Buffer.
{
  const stream = fs.createWriteStream(file);
  stream.on('error', common.mustNotCall());
  assert.throws(() => {
    stream.write(42);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
  stream.destroy();
}

```"
"```javascript:modules\fs\promises.js
import * as fs from ""../internal/fs"";
import { promisify } from ""../internal/util""

export const access = promisify(fs.access);
export const appendFile = (file, data, opts) => {
    if (file instanceof fs.FileHandle) {
        return file.appendFile(data, opts);
    } else {
        return promisify(fs.appendFile)(file, data, opts);
    }
};
export const chmod = promisify(fs.chmod);
export const chown = promisify(fs.chown);
export const copyFile = promisify(fs.copyFile);
export const cp = promisify(fs.cp);
export const lchmod = promisify(fs.lchmod);
export const lchown = promisify(fs.lchown);
export const lutimes = promisify(fs.lutimes);
export const link = promisify(fs.link);
export const lstat = promisify(fs.lstat);
export const mkdir = promisify(fs.mkdir);
export const mkdtemp = promisify(fs.mkdtemp);
export const open = (path, flag, mode) => {
    return new Promise((res, rej) => {
        fs.open(path, flag, mode, (err, fd) => {
            if (err !== null) {
                return rej(err);
            }
            res(new fs.FileHandle(fd, path));
        })
    })
};
export const opendir = promisify(fs.opendir);
export const readdir = promisify(fs.readdir);
export const readFile = async (path, ...args) => {
    let file = await open(path, ""r"");
    let res = await file.readFile(...args);
    await file.close();
    return res;
}

export const readlink = promisify(fs.readlink);
export const realpath = promisify(fs.realpath);
export const rename = promisify(fs.rename);
export const rmdir = promisify(fs.rmdir);
export const rm = promisify(fs.rm);
export const stat = promisify(fs.stat);
export const symlink = promisify(fs.symlink);
export const truncate = async (path, len) => {
    let file = await open(path, ""r+"");
    await file.truncate(len);
    await file.close();
};

export const unlink = promisify(fs.unlink);
export const utimes = promisify(fs.utimes);
export const watch = promisify(fs.watch);
export const writeFile = async (path, ...args) => {
    let file = await open(path, ""w"");
    await file.writeFile(...args);
    await file.close();
};

export const constants = fs.constants;

const promises = {
    access,
    appendFile,
    chmod,
    chown,
    copyFile,
    cp,
    lchmod,
    lchown,
    lutimes,
    link,
    lstat,
    mkdir,
    mkdtemp,
    open,
    opendir,
    readdir,
    readFile,
    readlink,
    realpath,
    rename,
    rmdir,
    rm,
    stat,
    symlink,
    truncate,
    unlink,
    utimes,
    watch,
    writeFile,
    constants
}

export default promises;

```"
"```javascript:test\fs\test-fs-writefile-with-fd.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// This test makes sure that `writeFile()` always writes from the current
// position of the file, instead of truncating the file, when used with file
// descriptors.

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  /* writeFileSync() test. */
  const filename = join(tmpdir.path, 'test.txt');

  /* Open the file descriptor. */
  const fd = fs.openSync(filename, 'w');
  try {
    /* Write only five characters, so that the position moves to five. */
    assert.strictEqual(fs.writeSync(fd, 'Hello'), 5);
    assert.strictEqual(fs.readFileSync(filename).toString(), 'Hello');

    /* Write some more with writeFileSync(). */
    fs.writeFileSync(fd, 'World');

    /* New content should be written at position five, instead of zero. */
    assert.strictEqual(fs.readFileSync(filename).toString(), 'HelloWorld');
  } finally {
    fs.closeSync(fd);
  }
}

const fdsToCloseOnExit = [];
globalThis.commonExitCheck = common.mustCall(() => {
  for (const fd of fdsToCloseOnExit) {
    try {
      fs.closeSync(fd);
    } catch {
      // Failed to close, ignore
    }
  }
});

{
  /* writeFile() test. */
  const file = join(tmpdir.path, 'test1.txt');

  /* Open the file descriptor. */
  fs.open(file, 'w', common.mustSucceed((fd) => {
    fdsToCloseOnExit.push(fd);
    /* Write only five characters, so that the position moves to five. */
    fs.write(fd, 'Hello', common.mustSucceed((bytes) => {
      assert.strictEqual(bytes, 5);
      assert.strictEqual(fs.readFileSync(file).toString(), 'Hello');

      /* Write some more with writeFile(). */
      fs.writeFile(fd, 'World', common.mustSucceed(() => {
        /* New content should be written at position five, instead of zero. */
        assert.strictEqual(fs.readFileSync(file).toString(), 'HelloWorld');
      }));
    }));
  }));
}


// Test read-only file descriptor
{
  const file = join(tmpdir.path, 'test.txt');

  fs.open(file, 'r', common.mustSucceed((fd) => {
    fdsToCloseOnExit.push(fd);
    fs.writeFile(fd, 'World', common.expectsError(/EBADF/));
  }));
}
/*
// Test with an AbortSignal
{
  const controller = new AbortController();
  const signal = controller.signal;
  const file = join(tmpdir.path, 'test.txt');

  fs.open(file, 'w', common.mustSucceed((fd) => {
    fdsToCloseOnExit.push(fd);
    fs.writeFile(fd, 'World', { signal }, common.expectsError({
      name: 'AbortError'
    }));
  }));

  controller.abort();
}
*/
```"
"```javascript:modules\querystring.js
function e(e, n) { return Object.prototype.hasOwnProperty.call(e, n) } var n = function (n, r, t, o) { r = r || ""&"", t = t || ""=""; var a = {}; if (""string"" != typeof n || 0 === n.length) { return a; } var u = /\+/g; n = n.split(r); var c = 1e3; o && ""number"" == typeof o.maxKeys && (c = o.maxKeys); var i = n.length; c > 0 && i > c && (i = c); for (var s = 0; s < i; ++s) { var p, f, d, y, m = n[s].replace(u, ""%20""), l = m.indexOf(t); l >= 0 ? (p = m.substr(0, l), f = m.substr(l + 1)) : (p = m, f = """"), d = decodeURIComponent(p), y = decodeURIComponent(f), e(a, d) ? Array.isArray(a[d]) ? a[d].push(y) : a[d] = [a[d], y] : a[d] = y; } return a }, r = function (e) { switch (typeof e) { case ""string"": return e; case ""boolean"": return e ? ""true"" : ""false""; case ""number"": return isFinite(e) ? e : """"; default: return """" } }, t = function (e, n, t, o) { return n = n || ""&"", t = t || ""="", null === e && (e = void 0), ""object"" == typeof e ? Object.keys(e).map((function (o) { var a = encodeURIComponent(r(o)) + t; return Array.isArray(e[o]) ? e[o].map((function (e) { return a + encodeURIComponent(r(e)) })).join(n) : a + encodeURIComponent(r(e[o])) })).join(n) : o ? encodeURIComponent(r(o)) + t + encodeURIComponent(r(e)) : """" }, o = {}; o.decode = o.parse = n, o.encode = o.stringify = t; o.decode; o.encode; o.parse; o.stringify;

o.decode;
o.encode;
o.parse;
o.stringify;

var decode = o.decode;
var encode = o.encode;
var parse = o.parse;
var stringify = o.stringify;

export { decode, o as default, encode, parse, stringify };

```"
"```javascript:test\fs\test-fs-readfile-pipe.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Simulate `cat readfile.js | node readfile.js`

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';
import fs from 'fs';

if (process.argv[2] === 'child') {
  fs.readFile('/dev/stdin', common.mustSucceed((data) => {
    process.stdout.write(data);
  }));
  return;
}

import fixtures from '../common/fixtures';

const filename = fixtures.path('readfile_pipe_test.txt');
const dataExpected = fs.readFileSync(filename).toString();

import { exec } from 'child_process';
const f = JSON.stringify(__filename);
const node = JSON.stringify(process.execPath);
const cmd = `cat ${filename} | ${node} ${f} child`;
exec(cmd, common.mustSucceed((stdout, stderr) => {
  assert.strictEqual(
    stdout,
    dataExpected,
    `expected to read: '${dataExpected}' but got: '${stdout}'`);
  assert.strictEqual(
    stderr,
    '',
    `expected not to read anything from stderr but got: '${stderr}'`);
  console.log('ok');
}));

```"
"```javascript:test\fs\test-fs-write-stream-change-open.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const file = path.join(tmpdir.path, 'write.txt');

tmpdir.refresh();

const stream = fs.WriteStream(file);
const _fs_close = fs.close;
const _fs_open = fs.open;

// Change the fs.open with an identical function after the WriteStream
// has pushed it onto its internal action queue, but before it's
// returned.  This simulates AOP-style extension of the fs lib.
fs.open = function() {
  return _fs_open.apply(fs, arguments);
};

fs.close = function(fd) {
  assert.ok(fd, 'fs.close must not be called with an undefined fd.');
  fs.close = _fs_close;
  fs.open = _fs_open;
  fs.closeSync(fd);
};

stream.write('foo');
stream.end();

process.on('exit', function() {
  assert.strictEqual(fs.open, _fs_open);
});

```"
"```javascript:test\fs\test-fs-exists.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { URL } from ""url""

let __filename = args[0];

const f = __filename;

assert.throws(() => fs.exists(f), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.exists(), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.exists(f, {}), { code: 'ERR_INVALID_ARG_TYPE' });

fs.exists(f, common.mustCall(function(y) {
  assert.strictEqual(y, true);
}));

fs.exists(`${f}-NO`, common.mustCall(function(y) {
  assert.strictEqual(y, false);
}));

// If the path is invalid, fs.exists will still invoke the callback with false
// instead of throwing errors
fs.exists(new URL('https://foo'), common.mustCall(function(y) {
  assert.strictEqual(y, false);
}));

fs.exists({}, common.mustCall(function(y) {
  assert.strictEqual(y, false);
}));

assert(fs.existsSync(f));
assert(!fs.existsSync(`${f}-NO`));

// fs.existsSync() never throws
assert(!fs.existsSync());
assert(!fs.existsSync({}));
assert(!fs.existsSync(new URL('https://foo')));

```"
"```javascript:modules\encoding.js
import { text_encode, text_decode, text_encode_into } from '_encoding'

function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
    return arg === void 0;
}

export class TextEncoder {

    get encoding() {
        return 'utf-8'
    }

    encode(input) {
        let arr = text_encode(input, 'utf-8');
        if (isUndefined(arr)) {
            return new Uint8Array()
        } else {
            return new Uint8Array(arr)
        }
    }

    encodeInto(src, dest) {
        if (dest instanceof Uint8Array) {
            return text_encode_into(src, 'utf8', dest.buffer, dest.byteOffset)
        } else {
            throw new TypeError('The ""dest"" argument must be an instance of Uint8Array.')
        }
    }
}

export class TextDecoder {
    #encoding = 'utf-8';
    #fatal = undefined;
    #ignoreBOM = undefined;

    constructor(encoding, options) {
        let { fatal, ignoreBOM } = options || {};
        this.#fatal = fatal ? true : false;
        this.#ignoreBOM = ignoreBOM;
        encoding = encoding || 'utf-8';

        let exist = [
            'utf8', 'utf-8', 'gbk', 'gb18030', 'hz-gb-2312', 'big5', 'euc-jp', 'iso-2022-jp',
            'utf-16be', 'utf-16le', 'x-user-defined', 'ibm866',
            'iso-8859-2', 'iso-8859-3', 'iso-8859-4', 'iso-8859-5', 'iso-8859-6', 'iso-8859-7', 'iso-8859-8',
            'iso-8859-8i', 'iso-8859-10', 'iso-8859-13', 'iso-8859-14', 'iso-8859-15', 'iso-8859-16',
            'windows-874', 'windows-1250', 'windows-1251', 'windows-1252', 'windows-1253', 'windows-1254',
            'windows-1255', 'windows-1256', 'windows-1257', 'windows-1258', ''
        ].indexOf(encoding);

        if (exist < 0) {
            throw new RangeError(`The ""${encoding}"" encoding is not supported`);
        } else {
            this.#encoding = encoding
        }
    }

    get encoding() {
        return this.#encoding
    }

    get fatal() {
        return this.#fatal
    }

    decode(input) {
        if (typeof input != 'undefined') {
            let ret;
            if (input.buffer instanceof ArrayBuffer) {
                ret = text_decode(input.buffer, this.encoding, this.fatal)
            } else if (input instanceof ArrayBuffer) {
                ret = text_decode(input, this.encoding, this.fatal)
            }
            if (isError(ret)) {
                throw new TypeError(`The encoded data was not valid for encoding ${this.encoding}`)
            }
            return ret
        }
        throw new TypeError('The ""input"" argument must be an instance of ArrayBuffer or ArrayBufferView.')

    }
}

globalThis.TextDecoder = TextDecoder;
globalThis.TextEncoder = TextEncoder;
```"
"```javascript:test\fs\test-fs-readfile-zero-byte-liar.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Test that readFile works even when stat returns size 0.

import assert from 'assert';
import fs from 'fs';

const __filename = args[0];

const dataExpected = fs.readFileSync(__filename, 'utf8');

// Sometimes stat returns size=0, but it's a lie.
fs._fstat = fs.fstat;
fs._fstatSync = fs.fstatSync;

fs.fstat = (fd, cb) => {
  fs._fstat(fd, (er, st) => {
    if (er) return cb(er);
    st.size = 0;
    return cb(er, st);
  });
};

fs.fstatSync = (fd) => {
  const st = fs._fstatSync(fd);
  st.size = 0;
  return st;
};

const d = fs.readFileSync(__filename, 'utf8');
assert.strictEqual(d, dataExpected);

fs.readFile(__filename, 'utf8', common.mustCall((er, d) => {
  assert.strictEqual(d, dataExpected);
}));

```"
"```javascript:test\fs\test-fs-util-validateoffsetlength.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

import common from '../common';

import assert from 'assert';
const {
  validateOffsetLengthRead,
  validateOffsetLengthWrite,
} = require('internal/fs/utils');

{
  const offset = -1;
  assert.throws(
    () => validateOffsetLengthRead(offset, 0, 0),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""offset"" is out of range. ' +
                 `It must be >= 0. Received ${offset}`
    })
  );
}

{
  const length = -1;
  assert.throws(
    () => validateOffsetLengthRead(0, length, 0),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""length"" is out of range. ' +
                 `It must be >= 0. Received ${length}`
    })
  );
}

{
  const offset = 1;
  const length = 1;
  const byteLength = offset + length - 1;
  assert.throws(
    () => validateOffsetLengthRead(offset, length, byteLength),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""length"" is out of range. ' +
                 `It must be <= ${byteLength - offset}. Received ${length}`
    })
  );
}

// Most platforms don't allow reads or writes >= 2 GiB.
// See https://github.com/libuv/libuv/pull/1501.
const kIoMaxLength = 2 ** 31 - 1;

// RangeError when offset > byteLength
{
  const offset = 100;
  const length = 100;
  const byteLength = 50;
  assert.throws(
    () => validateOffsetLengthWrite(offset, length, byteLength),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""offset"" is out of range. ' +
               `It must be <= ${byteLength}. Received ${offset}`
    })
  );
}

// RangeError when byteLength < kIoMaxLength, and length > byteLength - offset.
{
  const offset = kIoMaxLength - 150;
  const length = 200;
  const byteLength = kIoMaxLength - 100;
  assert.throws(
    () => validateOffsetLengthWrite(offset, length, byteLength),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""length"" is out of range. ' +
               `It must be <= ${byteLength - offset}. Received ${length}`
    })
  );
}

```"
"```javascript:test\fs\test-fs-symlink-dir-junction.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

// Test creating and reading symbolic link
const linkData = fixtures.path('cycles/');
const linkPath = path.join(tmpdir.path, 'cycles_link');

tmpdir.refresh();

fs.symlink(linkData, linkPath, 'junction', common.mustSucceed(() => {
  fs.lstat(linkPath, common.mustSucceed((stats) => {
    assert.ok(stats.isSymbolicLink());

    // fs.readlink(linkPath, common.mustSucceed((destination) => {
    //   assert.strictEqual(destination, linkData);

      fs.unlink(linkPath, common.mustSucceed(() => {
        assert(!fs.existsSync(linkPath));
        assert(fs.existsSync(linkData));
      }));
    // }));
  }));
}));

// Test invalid symlink
{
  const linkData = fixtures.path('/not/exists/dir');
  const linkPath = path.join(tmpdir.path, 'invalid_junction_link');

  fs.symlink(linkData, linkPath, 'junction', common.mustSucceed(() => {
    assert(!fs.existsSync(linkPath));

    fs.unlink(linkPath, common.mustSucceed(() => {
      assert(!fs.existsSync(linkPath));
    }));
  }));
}

```"
"```javascript:test\fs\test-fs-watch-file-enoent-after-deletion.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Make sure the deletion event gets reported in the following scenario:
// 1. Watch a file.
// 2. The initial stat() goes okay.
// 3. Something deletes the watched file.
// 4. The second stat() fails with ENOENT.

// The second stat() translates into the first 'change' event but a logic error
// stopped it from getting emitted.
// https://github.com/nodejs/node-v0.x-archive/issues/4027

import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = path.join(tmpdir.path, 'watched');
fs.writeFileSync(filename, 'quis custodiet ipsos custodes');

fs.watchFile(filename, { interval: 50 }, common.mustCall(function(curr, prev) {
  fs.unwatchFile(filename);
}));

fs.unlinkSync(filename);

```"
"```javascript:test\path\test-path-resolve.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
// import child from 'child_process';
import path from 'path';
import process from 'process';

const failures = [];
const slashRE = /\//g;
const backslashRE = /\\/g;

const posixyCwd = common.isWindows ?
  (() => {
    const _ = process.cwd()
      .replaceAll(path.sep, path.posix.sep);
    return _.slice(_.indexOf(path.posix.sep));
  })() :
  "".""; //process.cwd();

const resolveTests = [
  /*[ path.win32.resolve,
    // Arguments                               result
    [[['c:/blah\\blah', 'd:/games', 'c:../a'], 'c:\\blah\\a'],
     [['c:/ignore', 'd:\\a/b\\c/d', '\\e.exe'], 'd:\\e.exe'],
     [['c:/ignore', 'c:/some/file'], 'c:\\some\\file'],
     [['d:/ignore', 'd:some/dir//'], 'd:\\ignore\\some\\dir'],
     [['.'], process.cwd()],
     [['//server/share', '..', 'relative\\'], '\\\\server\\share\\relative'],
     [['c:/', '//'], 'c:\\'],
     [['c:/', '//dir'], 'c:\\dir'],
     [['c:/', '//server/share'], '\\\\server\\share\\'],
     [['c:/', '//server//share'], '\\\\server\\share\\'],
     [['c:/', '///some//dir'], 'c:\\some\\dir'],
     [['C:\\foo\\tmp.3\\', '..\\tmp.3\\cycles\\root.js'],
      'C:\\foo\\tmp.3\\cycles\\root.js'],
    ],
  ],*/
  [ path.posix.resolve,
    // Arguments                    result
    [[['/var/lib', '../', 'file/'], '/var/file'],
     [['/var/lib', '/../', 'file/'], '/file'],
     [['a/b/c/', '../../..'], posixyCwd],
     [['.'], posixyCwd],
     [['/some/dir', '.', '/absolute/'], '/absolute'],
     [['/foo/tmp.3/', '../tmp.3/cycles/root.js'], '/foo/tmp.3/cycles/root.js'],
    ],
  ],
];
resolveTests.forEach(([resolve, tests]) => {
  tests.forEach(([test, expected]) => {
    const actual = resolve.apply(null, test);
    let actualAlt;
    const os = /*resolve === path.win32.resolve ? 'win32' : */'posix';
    if (false /*resolve === path.win32.resolve*/ && !common.isWindows)
      actualAlt = actual.replace(backslashRE, '/');
    else if (true /*resolve !== path.win32.resolve*/ && common.isWindows)
      actualAlt = actual.replace(slashRE, '\\');

    const message =
      `path.${os}.resolve(${test.map(JSON.stringify).join(',')})\n  expect=${
        JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    if (actual !== expected && actualAlt !== expected)
      failures.push(message);
  });
});
assert.strictEqual(failures.length, 0, failures.join('\n'));

if (common.isWindows) {
  // Test resolving the current Windows drive letter from a spawned process.
  // See https://github.com/nodejs/node/issues/7215
  const currentDriveLetter = path.parse(process.cwd()).root.substring(0, 2);
  const resolveFixture = fixtures.path('path-resolve.js');
  const spawnResult = child.spawnSync(
    process.argv[0], [resolveFixture, currentDriveLetter]);
  const resolvedPath = spawnResult.stdout.toString().trim();
  assert.strictEqual(resolvedPath.toLowerCase(), process.cwd().toLowerCase());
}

if (!common.isWindows) {
  // Test handling relative paths to be safe when process.cwd() fails.
  process.cwd = () => '';
  assert.strictEqual(process.cwd(), '');
  const resolved = path.resolve();
  const expected = '.';
  assert.strictEqual(resolved, expected);
}

```"
"```javascript:example_js\fs.js
import { mkdirSync, statSync, lstatSync, rmdirSync, accessSync, existsSync, rmSync, renameSync, openSync, read, readFile, readFileSync } from ""fs"";


print(""\nfs.statSync\nExisted File:"");

try {
    let s = statSync(""README.md"");
    print(JSON.stringify(s));
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nExisted File with BigInt:"");

try {
    let s = statSync(""README.md"", { bigint: true });
    for (const [key, val] of Object.entries(s)) {
        print(key, "": "", typeof (val) === ""function"" ? val() : val);
    }
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nNon-existed File"");

try {
    let s = statSync(""non-exist.file"");
    print(JSON.stringify(s));
} catch (err) {
    print(err.name);
    print(err.stack);
    print(err.message);
}

print(""\nNon-existed File No Throw"");

{
    let s = statSync(""non-exist.file"", { throwIfNoEntry: false });
    print(s);
}

import { constants } from ""fs"";

print(""\nfs.constants:"");

const { F_OK, O_WRONLY } = constants;
print(""F_OK: "", F_OK);
print(""O_WRONLY: "", O_WRONLY);

print(""\nfs.lstatSync\nExisted File:"");

try {
    let s = lstatSync(""README.md"");
    print(JSON.stringify(s));
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nExisted File with BigInt:"");

try {
    let s = lstatSync(""README.md"", { bigint: true });
    for (const [key, val] of Object.entries(s)) {
        print(key, "": "", typeof (val) === ""function"" ? val() : val);
    }
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nNon-existed File:"");

try {
    let s = lstatSync(""non-exist.file"");
    print(JSON.stringify(s));
} catch (err) {
    print(err.name);
    print(err.stack);
    print(err.message);
}

print(""\nNon-existed File with No Throw:"");

{
    let s = lstatSync(""non-exist.file"", { throwIfNoEntry: false });
    print(s);
}

function assert(fn) {
    if (!fn) {
        throw new Error();
    }
}

print(""\nmkdir: ./tmpdir"");
mkdirSync(""./tmpdir"");
print(""access: ./tmpdir"");
accessSync(""./tmpdir"");
print(""rmdir: ./tmpdir"");
rmdirSync(""./tmpdir"");
print(""exist: ./tmpdir"");
print(existsSync(""./tmpdir""));

print(""\nmkdir recursive: ./tmpdir/subdir"");
mkdirSync(""./tmpdir/subdir"", { recursive: true });
print(""access: ./tmpdir/subdir"");
accessSync(""./tmpdir/subdir"");
print(""rm recursive: ./tmpdir"");
rmSync(""./tmpdir"", { recursive: true });
print(""exist: ./tmpdir"");
print(existsSync(""./tmpdir""));

print(""\nrename README.md to test.md"")
renameSync(""./README.md"", ""./test.md"");
print(""exist: ./test.md"");
print(existsSync(""./test.md""));
renameSync(""./test.md"", ""./README.md"");

let fd = openSync(""./README.md"");
print(fd);
read(fd, { length: 20 }, (err, len, buf) => {
    print(err);
    print(len);
    print(buf.toString())
});

print(readFileSync(""./Cargo.toml"", ""utf-8""))

```"
"```javascript:test\fs\test-fs-symlink-dir-junction-relative.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Test creating and resolving relative junction or symbolic link

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const linkPath1 = path.join(tmpdir.path, 'junction1');
const linkPath2 = path.join(tmpdir.path, 'junction2');
const linkTarget = fixtures.fixturesDir;
const linkData = fixtures.fixturesDir;

tmpdir.refresh();

// Test fs.symlink()
fs.symlink(linkData, linkPath1, 'junction', common.mustSucceed(() => {
  verifyLink(linkPath1);
}));

// Test fs.symlinkSync()
fs.symlinkSync(linkData, linkPath2, 'junction');
verifyLink(linkPath2);

function verifyLink(linkPath) {
  const stats = fs.lstatSync(linkPath);
  assert.ok(stats.isSymbolicLink());

  const data1 = fs.readFileSync(`${linkPath}/x.txt`, 'ascii');
  const data2 = fs.readFileSync(`${linkTarget}/x.txt`, 'ascii');
  assert.strictEqual(data1, data2);

  // Clean up.
  fs.unlinkSync(linkPath);
}

```"
"```javascript:test\crypto\test-crypto-key-objects-messageport.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { createSecretKey, generateKeyPairSync, randomBytes } = require('crypto');
const { createContext } = require('vm');
const {
  MessageChannel,
  Worker,
  moveMessagePortToContext,
  parentPort
} = require('worker_threads');

function keyToString(key) {
  let ret;
  if (key.type === 'secret') {
    ret = key.export().toString('hex');
  } else {
    ret = key.export({ type: 'pkcs1', format: 'pem' });
  }
  return ret;
}

// Worker threads simply reply with their representation of the received key.
if (process.env.HAS_STARTED_WORKER) {
  return parentPort.once('message', ({ key }) => {
    parentPort.postMessage(keyToString(key));
  });
}

// Don't use isMainThread to allow running this test inside a worker.
process.env.HAS_STARTED_WORKER = 1;

// The main thread generates keys and passes them to worker threads.
const secretKey = createSecretKey(randomBytes(32));
const { publicKey, privateKey } = generateKeyPairSync('rsa', {
  modulusLength: 1024
});

// Get immutable representations of all keys.
const keys = [secretKey, publicKey, privateKey]
             .map((key) => [key, keyToString(key)]);

for (const [key, repr] of keys) {
  {
    // Test 1: No context change.
    const { port1, port2 } = new MessageChannel();

    port1.postMessage({ key });
    assert.strictEqual(keyToString(key), repr);

    port2.once('message', common.mustCall(({ key }) => {
      assert.strictEqual(keyToString(key), repr);
    }));
  }

  {
    // Test 2: Across threads.
    const worker = new Worker(__filename);
    worker.once('message', common.mustCall((receivedRepresentation) => {
      assert.strictEqual(receivedRepresentation, repr);
    }));
    worker.on('disconnect', () => console.log('disconnect'));
    worker.postMessage({ key });
  }

  {
    // Test 3: Across contexts (should not work).
    const { port1, port2 } = new MessageChannel();
    const context = createContext();
    const port2moved = moveMessagePortToContext(port2, context);
    assert(!(port2moved instanceof Object));

    // TODO(addaleax): Switch this to a 'messageerror' event once MessagePort
    // implements EventTarget fully and in a cross-context manner.
    port2moved.onmessageerror = common.mustCall((event) => {
      assert.strictEqual(event.data.code,
                         'ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE');
    });

    port2moved.start();
    port1.postMessage({ key });
    port1.close();
  }
}

```"
"```javascript:test\fs\test-fs-fsync.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';

import fs from 'fs';
import path from 'path';

const fileFixture = fixtures.path('a.js');
const fileTemp = path.join(tmpdir.path, 'a.js');

// Copy fixtures to temp.
tmpdir.refresh();
fs.copyFileSync(fileFixture, fileTemp);

fs.open(fileTemp, 'a', 0o777, common.mustSucceed((fd) => {
  fs.fdatasyncSync(fd);

  fs.fsyncSync(fd);

  fs.fdatasync(fd, common.mustSucceed(() => {
    fs.fsync(fd, common.mustSucceed(() => {
      fs.closeSync(fd);
    }));
  }));
}));

['', false, null, undefined, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  };
  assert.throws(() => fs.fdatasync(input), errObj);
  assert.throws(() => fs.fdatasyncSync(input), errObj);
  assert.throws(() => fs.fsync(input), errObj);
  assert.throws(() => fs.fsyncSync(input), errObj);
});

```"
"```javascript:test\fs\test-fs-writev.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = '��mlaut. ���������� ��������������������� ������������ ������������ ��������������� ������������������ ������';

const getFileName = (i) => path.join(tmpdir.path, `writev_${i}.txt`);

/**
 * Testing with a array of buffers input
 */

// fs.writev with array of buffers with all parameters
{
  const filename = getFileName(1);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer];

  const done = common.mustSucceed((written, buffers) => {
    assert.deepStrictEqual(bufferArr, buffers);
    const expectedLength = bufferArr.length * buffer.byteLength;
    assert.deepStrictEqual(written, expectedLength);
    fs.closeSync(fd);

    assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
  });

  fs.writev(fd, bufferArr, null, done);
}

// fs.writev with array of buffers without position
{
  const filename = getFileName(2);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer];

  const done = common.mustSucceed((written, buffers) => {
    assert.deepStrictEqual(bufferArr, buffers);

    const expectedLength = bufferArr.length * buffer.byteLength;
    assert.deepStrictEqual(written, expectedLength);
    fs.closeSync(fd);

    assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
  });

  fs.writev(fd, bufferArr, done);
}


// fs.writev with empty array of buffers
{
  const filename = getFileName(3);
  const fd = fs.openSync(filename, 'w');
  const bufferArr = [];
  let afterSyncCall = false;

  const done = common.mustSucceed((written, buffers) => {
    assert.strictEqual(buffers.length, 0);
    assert.strictEqual(written, 0);
    assert(afterSyncCall);
    fs.closeSync(fd);
  });

  fs.writev(fd, bufferArr, done);
  afterSyncCall = true;
}

/**
 * Testing with wrong input types
 */
{
  const filename = getFileName(4);
  const fd = fs.openSync(filename, 'w');

  [false, 'test', {}, [{}], ['sdf'], null, undefined].forEach((i) => {
    assert.throws(
      () => fs.writev(fd, i, null, common.mustNotCall()), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

// fs.writev with wrong fd types
[false, 'test', {}, [{}], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.writev(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-write-stream-end.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');
  const stream = fs.createWriteStream(file);
  stream.end();
  stream.on('close', common.mustCall());
}

{
  const file = path.join(tmpdir.path, 'write-end-test1.txt');
  const stream = fs.createWriteStream(file);
  stream.end('a\n', 'utf8');
  stream.on('close', common.mustCall(function() {
    const content = fs.readFileSync(file, 'utf8');
    assert.strictEqual(content, 'a\n');
  }));
}

{
  const file = path.join(tmpdir.path, 'write-end-test2.txt');
  const stream = fs.createWriteStream(file);
  stream.end();

  let calledOpen = false;
  stream.on('open', () => {
    calledOpen = true;
  });
  stream.on('finish', common.mustCall(() => {
    assert.strictEqual(calledOpen, true);
  }));
}

```"
"```javascript:test\crypto\test-crypto-ecb.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

if (common.hasFipsCrypto)
  common.skip('BF-ECB is not FIPS 140-2 compatible');

if (common.hasOpenSSL3)
  common.skip('Blowfish is only available with the legacy provider in ' +
    'OpenSSl 3.x');

const assert = require('assert');
const crypto = require('crypto');

// Testing whether EVP_CipherInit_ex is functioning correctly.
// Reference: bug#1997

{
  const encrypt =
    crypto.createCipheriv('BF-ECB', 'SomeRandomBlahz0c5GZVnR', '');
  let hex = encrypt.update('Hello World!', 'ascii', 'hex');
  hex += encrypt.final('hex');
  assert.strictEqual(hex.toUpperCase(), '6D385F424AAB0CFBF0BB86E07FFB7D71');
}

{
  const decrypt =
    crypto.createDecipheriv('BF-ECB', 'SomeRandomBlahz0c5GZVnR', '');
  let msg = decrypt.update('6D385F424AAB0CFBF0BB86E07FFB7D71', 'hex', 'ascii');
  msg += decrypt.final('ascii');
  assert.strictEqual(msg, 'Hello World!');
}

```"
"```javascript:test\fs\test-fs-symlink-buffer-path.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
if (!common.canCreateSymLink())
  common.skip('insufficient privileges');

import fixtures from '../common/fixtures';

import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test creating and reading symbolic link
const linkData = fixtures.path('/cycles/root.js');
const linkPath = path.join(tmpdir.path, 'symlink1.js');

let linkTime;
let fileTime;

// Refs: https://github.com/nodejs/node/issues/34514
fs.symlinkSync(Buffer.from(linkData), linkPath);

fs.lstat(linkPath, common.mustSucceed((stats) => {
  linkTime = stats.mtime.getTime();
}));

fs.stat(linkPath, common.mustSucceed((stats) => {
  fileTime = stats.mtime.getTime();
}));
/*
fs.readlink(linkPath, common.mustSucceed((destination) => {
  assert.strictEqual(destination, linkData);
}));
*/
globalThis.commonExitCheck = () => {
  assert.notStrictEqual(linkTime, fileTime);
};

```"
"```javascript:test\crypto\test-crypto-timing-safe-equal.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

// 'should consider equal strings to be equal'
assert.strictEqual(
  crypto.timingSafeEqual(Buffer.from('foo'), Buffer.from('foo')),
  true
);

// 'should consider unequal strings to be unequal'
assert.strictEqual(
  crypto.timingSafeEqual(Buffer.from('foo'), Buffer.from('bar')),
  false
);

{
  // Test TypedArrays with different lengths but equal byteLengths.
  const buf = crypto.randomBytes(16).buffer;
  const a1 = new Uint8Array(buf);
  const a2 = new Uint16Array(buf);
  const a3 = new Uint32Array(buf);

  for (const left of [a1, a2, a3]) {
    for (const right of [a1, a2, a3]) {
      assert.strictEqual(crypto.timingSafeEqual(left, right), true);
    }
  }
}

{
  // When the inputs are floating-point numbers, timingSafeEqual neither has
  // equality nor SameValue semantics. It just compares the underlying bytes,
  // ignoring the TypedArray type completely.

  const cmp = (fn) => (a, b) => a.every((x, i) => fn(x, b[i]));
  const eq = cmp((a, b) => a === b);
  const is = cmp(Object.is);

  function test(a, b, { equal, sameValue, timingSafeEqual }) {
    assert.strictEqual(eq(a, b), equal);
    assert.strictEqual(is(a, b), sameValue);
    assert.strictEqual(crypto.timingSafeEqual(a, b), timingSafeEqual);
  }

  test(new Float32Array([NaN]), new Float32Array([NaN]), {
    equal: false,
    sameValue: true,
    timingSafeEqual: true
  });

  test(new Float64Array([0]), new Float64Array([-0]), {
    equal: true,
    sameValue: false,
    timingSafeEqual: false
  });

  const x = new BigInt64Array([0x7ff0000000000001n, 0xfff0000000000001n]);
  test(new Float64Array(x.buffer), new Float64Array([NaN, NaN]), {
    equal: false,
    sameValue: true,
    timingSafeEqual: false
  });
}

assert.throws(
  () => crypto.timingSafeEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 2])),
  {
    code: 'ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH',
    name: 'RangeError',
    message: 'Input buffers must have the same byte length'
  }
);

assert.throws(
  () => crypto.timingSafeEqual('not a buffer', Buffer.from([1, 2])),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  }
);

assert.throws(
  () => crypto.timingSafeEqual(Buffer.from([1, 2]), 'not a buffer'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  }
);

```"
"```javascript:test\crypto\test-crypto-verify-failure.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const crypto = require('crypto');
const tls = require('tls');
const fixtures = require('../common/fixtures');

const certPem = fixtures.readKey('rsa_cert.crt');

const options = {
  key: fixtures.readKey('agent1-key.pem'),
  cert: fixtures.readKey('agent1-cert.pem')
};

const server = tls.Server(options, (socket) => {
  setImmediate(() => {
    verify();
    setImmediate(() => {
      socket.destroy();
    });
  });
});

function verify() {
  crypto.createVerify('SHA1')
    .update('Test')
    .verify(certPem, 'asdfasdfas', 'base64');
}

server.listen(0, common.mustCall(() => {
  tls.connect({
    port: server.address().port,
    rejectUnauthorized: false
  }, common.mustCall(() => {
    verify();
  }))
    .on('error', common.mustNotCall())
    .on('close', common.mustCall(() => {
      server.close();
    })).resume();
}));

server.unref();

```"
"```javascript:modules\internal\normalize_encoding.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.

export function normalizeEncoding(enc) {
    if (enc == null || enc === ""utf8"" || enc === ""utf-8"") return ""utf8"";
    return slowCases(enc);
}

export function slowCases(enc) {
    switch (enc.length) {
        case 4:
            if (enc === ""UTF8"") return ""utf8"";
            if (enc === ""ucs2"" || enc === ""UCS2"") return ""utf16le"";
            enc = `${enc}`.toLowerCase();
            if (enc === ""utf8"") return ""utf8"";
            if (enc === ""ucs2"") return ""utf16le"";
            break;
        case 3:
            if (
                enc === ""hex"" || enc === ""HEX"" ||
                `${enc}`.toLowerCase() === ""hex""
            ) {
                return ""hex"";
            }
            break;
        case 5:
            if (enc === ""ascii"") return ""ascii"";
            if (enc === ""ucs-2"") return ""utf16le"";
            if (enc === ""UTF-8"") return ""utf8"";
            if (enc === ""ASCII"") return ""ascii"";
            if (enc === ""UCS-2"") return ""utf16le"";
            enc = `${enc}`.toLowerCase();
            if (enc === ""utf-8"") return ""utf8"";
            if (enc === ""ascii"") return ""ascii"";
            if (enc === ""ucs-2"") return ""utf16le"";
            break;
        case 6:
            if (enc === ""base64"") return ""base64"";
            if (enc === ""latin1"" || enc === ""binary"") return ""latin1"";
            if (enc === ""BASE64"") return ""base64"";
            if (enc === ""LATIN1"" || enc === ""BINARY"") return ""latin1"";
            enc = `${enc}`.toLowerCase();
            if (enc === ""base64"") return ""base64"";
            if (enc === ""latin1"" || enc === ""binary"") return ""latin1"";
            break;
        case 7:
            if (
                enc === ""utf16le"" || enc === ""UTF16LE"" ||
                `${enc}`.toLowerCase() === ""utf16le""
            ) {
                return ""utf16le"";
            }
            break;
        case 8:
            if (
                enc === ""utf-16le"" || enc === ""UTF-16LE"" ||
                `${enc}`.toLowerCase() === ""utf-16le""
            ) {
                return ""utf16le"";
            }
            break;
        case 9:
            if (
                enc === ""base64url"" || enc === ""BASE64URL"" ||
                `${enc}`.toLowerCase() === ""base64url""
            ) {
                return ""base64url"";
            }
            break;
        default:
            if (enc === """") return ""utf8"";
    }
}
```"
"```javascript:test\fs\test-fs-truncate-clear-file-zero.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

// This test ensures that `fs.truncate` opens the file with `r+` and not `w`,
// which had earlier resulted in the target file's content getting zeroed out.
// https://github.com/nodejs/node-v0.x-archive/issues/6233

import assert from 'assert';
import fs from 'fs';

const filename = `${tmpdir.path}/truncate-file.txt`;

tmpdir.refresh();

// Synchronous test.
{
  fs.writeFileSync(filename, '0123456789');
  assert.strictEqual(fs.readFileSync(filename).toString(), '0123456789');
  fs.truncateSync(filename, 5);
  assert.strictEqual(fs.readFileSync(filename).toString(), '01234');
}

// Asynchronous test.
{
  fs.writeFileSync(filename, '0123456789');
  assert.strictEqual(fs.readFileSync(filename).toString(), '0123456789');
  fs.truncate(
    filename,
    5,
    common.mustSucceed(() => {
      assert.strictEqual(fs.readFileSync(filename).toString(), '01234');
    })
  );
}

```"
"```javascript:test\fs\test-fs-utils-get-dirents.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

import common from '../common';
import { getDirents, getDirent } from 'internal/fs/utils';
import assert from 'assert';
import { internalBinding } from 'internal/test/binding';
const { UV_DIRENT_UNKNOWN } = internalBinding('constants').fs;
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
const filename = 'foo';

{
  // setup
  tmpdir.refresh();
  fs.writeFileSync(path.join(tmpdir.path, filename), '');
}
// getDirents
{
  // string + string
  getDirents(
    tmpdir.path,
    [[filename], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err, names) => {
      assert.strictEqual(err, null);
      assert.strictEqual(names.length, 1);
    },
    ));
}
{
  // string + Buffer
  getDirents(
    tmpdir.path,
    [[Buffer.from(filename)], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err, names) => {
      assert.strictEqual(err, null);
      assert.strictEqual(names.length, 1);
    },
    ));
}
{
  // Buffer + Buffer
  getDirents(
    Buffer.from(tmpdir.path),
    [[Buffer.from(filename)], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err, names) => {
      assert.strictEqual(err, null);
      assert.strictEqual(names.length, 1);
    },
    ));
}
{
  // wrong combination
  getDirents(
    42,
    [[Buffer.from(filename)], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err) => {
      assert.strictEqual(
        err.message,
        [
          'The ""path"" argument must be of type string or an ' +
          'instance of Buffer. Received type number (42)',
        ].join(''));
    },
    ));
}
// getDirent
{
  // string + string
  getDirent(
    tmpdir.path,
    filename,
    UV_DIRENT_UNKNOWN,
    common.mustCall((err, dirent) => {
      assert.strictEqual(err, null);
      assert.strictEqual(dirent.name, filename);
    },
    ));
}
{
  // string + Buffer
  const filenameBuffer = Buffer.from(filename);
  getDirent(
    tmpdir.path,
    filenameBuffer,
    UV_DIRENT_UNKNOWN,
    common.mustCall((err, dirent) => {
      assert.strictEqual(err, null);
      assert.strictEqual(dirent.name, filenameBuffer);
    },
    ));
}
{
  // Buffer + Buffer
  const filenameBuffer = Buffer.from(filename);
  getDirent(
    Buffer.from(tmpdir.path),
    filenameBuffer,
    UV_DIRENT_UNKNOWN,
    common.mustCall((err, dirent) => {
      assert.strictEqual(err, null);
      assert.strictEqual(dirent.name, filenameBuffer);
    },
    ));
}
{
  // wrong combination
  getDirent(
    42,
    Buffer.from(filename),
    UV_DIRENT_UNKNOWN,
    common.mustCall((err) => {
      assert.strictEqual(
        err.message,
        [
          'The ""path"" argument must be of type string or an ' +
          'instance of Buffer. Received type number (42)',
        ].join(''));
    },
    ));
}

```"
"```javascript:test\crypto\test-crypto-domains.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const domain = require('domain');
const assert = require('assert');
const crypto = require('crypto');

const d = domain.create();
const expect = ['pbkdf2', 'randomBytes', 'pseudoRandomBytes'];

d.on('error', common.mustCall(function(e) {
  assert.strictEqual(e.message, expect.shift());
}, 3));

d.run(function() {
  one();

  function one() {
    crypto.pbkdf2('a', 'b', 1, 8, 'sha1', function() {
      two();
      throw new Error('pbkdf2');
    });
  }

  function two() {
    crypto.randomBytes(4, function() {
      three();
      throw new Error('randomBytes');
    });
  }

  function three() {
    crypto.pseudoRandomBytes(4, function() {
      throw new Error('pseudoRandomBytes');
    });
  }
});

```"
"```javascript:test\fs\test-fs-readfile-unlink.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Test that unlink succeeds immediately after readFile completes.

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const fileName = path.resolve(tmpdir.path, 'test.bin');
const buf = Buffer.alloc(512 * 1024, 42);

tmpdir.refresh();

fs.writeFileSync(fileName, buf);

fs.readFile(fileName, common.mustSucceed((data) => {
  assert.strictEqual(data.length, buf.length);
  assert.strictEqual(buf[0], 42);

  // Unlink should not throw. This is part of the test. It used to throw on
  // Windows due to a bug.
  fs.unlinkSync(fileName);
}));

```"
"```javascript:test\fs\test-fs-readfile-fd.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Test fs.readFile using a file descriptor.

import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const fn = fixtures.path('empty.txt');
import { join } from 'path';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

tempFd(function(fd, close) {
  fs.readFile(fd, function(err, data) {
    assert.ok(data);
    close();
  });
});

tempFd(function(fd, close) {
  fs.readFile(fd, 'utf8', function(err, data) {
    assert.strictEqual(data, '');
    close();
  });
});

tempFdSync(function(fd) {
  assert.ok(fs.readFileSync(fd));
});

tempFdSync(function(fd) {
  assert.strictEqual(fs.readFileSync(fd, 'utf8'), '');
});

function tempFd(callback) {
  fs.open(fn, 'r', function(err, fd) {
    assert.ifError(err);
    callback(fd, function() {
      fs.close(fd, function(err) {
        assert.ifError(err);
      });
    });
  });
}

function tempFdSync(callback) {
  const fd = fs.openSync(fn, 'r');
  callback(fd);
  fs.closeSync(fd);
}

{
  // This test makes sure that `readFile()` always reads from the current
  // position of the file, instead of reading from the beginning of the file,
  // when used with file descriptors.

  const filename = join(tmpdir.path, 'test.txt');
  fs.writeFileSync(filename, 'Hello World');

  {
    // Tests the fs.readFileSync().
    const fd = fs.openSync(filename, 'r');

    // Read only five bytes, so that the position moves to five.
    const buf = Buffer.alloc(5);
    assert.strictEqual(fs.readSync(fd, buf, 0, 5), 5);
    assert.strictEqual(buf.toString(), 'Hello');

    // readFileSync() should read from position five, instead of zero.
    assert.strictEqual(fs.readFileSync(fd).toString(), ' World');

    fs.closeSync(fd);
  }

  {
    // Tests the fs.readFile().
    fs.open(filename, 'r', common.mustSucceed((fd) => {
      const buf = Buffer.alloc(5);

      // Read only five bytes, so that the position moves to five.
      fs.read(fd, buf, 0, 5, null, common.mustSucceed((bytes) => {
        assert.strictEqual(bytes, 5);
        assert.strictEqual(buf.toString(), 'Hello');

        fs.readFile(fd, common.mustSucceed((data) => {
          // readFile() should read from position five, instead of zero.
          assert.strictEqual(data.toString(), ' World');

          fs.closeSync(fd);
        }));
      }));
    }));
  }
}

```"
"```javascript:test\fs\test-fs-empty-readStream.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const emptyFile = fixtures.path('empty.txt');

fs.open(emptyFile, 'r', common.mustSucceed((fd) => {
  const read = fs.createReadStream(emptyFile, { fd });

  read.once('data', common.mustNotCall('data event should not emit'));

  read.once('end', common.mustCall());
}));

fs.open(emptyFile, 'r', common.mustSucceed((fd) => {
  const read = fs.createReadStream(emptyFile, { fd });

  read.pause();

  read.once('data', common.mustNotCall('data event should not emit'));

  read.once('end', common.mustNotCall('end event should not emit'));

  setTimeout(common.mustCall(() => {
    assert.strictEqual(read.isPaused(), true);
  }), common.platformTimeout(50));
}));

```"
"```javascript:test\fs\test-fs-read-stream-fd.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, '/read_stream_fd_test.txt');
const input = 'hello world';

let output = '';
tmpdir.refresh();
fs.writeFileSync(file, input);

const fd = fs.openSync(file, 'r');
const stream = fs.createReadStream(null, { fd: fd, encoding: 'utf8' });

assert.strictEqual(stream.path, undefined);

stream.on('data', common.mustCallAtLeast((data) => {
  output += data;
}));

process.on('exit', () => {
  assert.strictEqual(output, input);
});

```"
"```javascript:test\crypto\test-crypto-hash-stream-pipe.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

import stream from 'stream';
const s = new stream.PassThrough();
const h = crypto.createHash('sha3-512');
const expect = '36a38a2a35e698974d4e5791a3f05b05' +
               '198235381e864f91a0e8cd6a26b677ec' +
               'dcde8e2b069bd7355fabd68abd6fc801' +
               '19659f25e92f8efc961ee3a7c815c758';

s.pipe(h).on('data', common.mustCall(function(c) {
  assert.strictEqual(c, expect);
  // Calling digest() after piping into a stream with SHA3 should not cause
  // a segmentation fault, see https://github.com/nodejs/node/issues/28245.
  assert.strictEqual(h.digest('hex'), expect);
})).setEncoding('hex');

s.end('aoeu');

```"
"```javascript:test\fs\test-fs-long-path.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
if (!common.isWindows)
  common.skip('this test is Windows-specific.');

import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

// Make a path that will be at least 260 chars long.
const fileNameLen = Math.max(260 - tmpdir.path.length - 1, 1);
const fileName = path.join(tmpdir.path, 'x'.repeat(fileNameLen));
const fullPath = path.resolve(fileName);

tmpdir.refresh();

console.log({
  filenameLength: fileName.length,
  fullPathLength: fullPath.length
});

fs.writeFile(fullPath, 'ok', common.mustSucceed(() => {
  fs.stat(fullPath, common.mustSucceed());
}));

```"
"```javascript:test\fs\test-fs-readv.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = '��mlaut. ���������� ��������������������� ������������ ������������ ��������������� ������������������ ������';

let cnt = 0;
const getFileName = () => path.join(tmpdir.path, `readv_${++cnt}.txt`);
const exptectedBuff = Buffer.from(expected);

const allocateEmptyBuffers = (combinedLength) => {
  const bufferArr = [];
  // Allocate two buffers, each half the size of exptectedBuff
  bufferArr[0] = Buffer.alloc(Math.floor(combinedLength / 2));
  bufferArr[1] = Buffer.alloc(combinedLength - bufferArr[0].length);

  return bufferArr;
};

const getCallback = (fd, bufferArr) => {
  return common.mustSucceed((bytesRead, buffers) => {
    assert.deepStrictEqual(bufferArr, buffers);
    const expectedLength = exptectedBuff.length;
    assert.deepStrictEqual(bytesRead, expectedLength);
    fs.closeSync(fd);

    assert(Buffer.concat(bufferArr).equals(exptectedBuff));
  });
};

// fs.readv with array of buffers with all parameters
{
  const filename = getFileName();
  const fd = fs.openSync(filename, 'w+');
  fs.writeSync(fd, exptectedBuff);

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
  const callback = getCallback(fd, bufferArr);

  fs.readv(fd, bufferArr, 0, callback);
}

// fs.readv with array of buffers without position
{
  const filename = getFileName();
  fs.writeFileSync(filename, exptectedBuff);
  const fd = fs.openSync(filename, 'r');

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
  const callback = getCallback(fd, bufferArr);

  fs.readv(fd, bufferArr, callback);
}

/**
 * Testing with incorrect arguments
 */
const wrongInputs = [false, 'test', {}, [{}], ['sdf'], null, undefined];

{
  const filename = getFileName(2);
  fs.writeFileSync(filename, exptectedBuff);
  const fd = fs.openSync(filename, 'r');


  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readv(fd, wrongInput, null, common.mustNotCall()), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

{
  // fs.readv with wrong fd argument
  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readv(wrongInput, common.mustNotCall()),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });
}

```"
"```javascript:test\path\test-path-extname.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

const __filename = args[0];

const failures = [];
const slashRE = /\//g;

[
  [__filename, '.js'],
  ['', ''],
  ['/path/to/file', ''],
  ['/path/to/file.ext', '.ext'],
  ['/path.to/file.ext', '.ext'],
  ['/path.to/file', ''],
  ['/path.to/.file', ''],
  ['/path.to/.file.ext', '.ext'],
  ['/path/to/f.ext', '.ext'],
  ['/path/to/..ext', '.ext'],
  ['/path/to/..', ''],
  ['file', ''],
  ['file.ext', '.ext'],
  ['.file', ''],
  ['.file.ext', '.ext'],
  ['/file', ''],
  ['/file.ext', '.ext'],
  ['/.file', ''],
  ['/.file.ext', '.ext'],
  ['.path/file.ext', '.ext'],
  ['file.ext.ext', '.ext'],
  ['file.', '.'],
  ['.', ''],
  ['./', ''],
  ['.file.ext', '.ext'],
  ['.file', ''],
  ['.file.', '.'],
  ['.file..', '.'],
  ['..', ''],
  ['../', ''],
  ['..file.ext', '.ext'],
  ['..file', '.file'],
  ['..file.', '.'],
  ['..file..', '.'],
  ['...', '.'],
  ['...ext', '.ext'],
  ['....', '.'],
  ['file.ext/', '.ext'],
  ['file.ext//', '.ext'],
  ['file/', ''],
  ['file//', ''],
  ['file./', '.'],
  ['file.//', '.'],
].forEach((test) => {
  const expected = test[1];
  [path.posix.extname, /*path.win32.extname*/].forEach((extname) => {
    let input = test[0];
    let os;
    if (false /*extname === path.win32.extname*/) {
      input = input.replace(slashRE, '\\');
      os = 'win32';
    } else {
      os = 'posix';
    }
    const actual = extname(input);
    const message = `path.${os}.extname(${JSON.stringify(input)})\n  expect=${
      JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    if (actual !== expected)
      failures.push(`\n${message}`);
  });
  /*{
    const input = `C:${test[0].replace(slashRE, '\\')}`;
    const actual = path.win32.extname(input);
    const message = `path.win32.extname(${JSON.stringify(input)})\n  expect=${
      JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    if (actual !== expected)
      failures.push(`\n${message}`);
  }*/
});
assert.strictEqual(failures.length, 0, failures.join(''));

/*
// On Windows, backslash is a path separator.
assert.strictEqual(path.win32.extname('.\\'), '');
assert.strictEqual(path.win32.extname('..\\'), '');
assert.strictEqual(path.win32.extname('file.ext\\'), '.ext');
assert.strictEqual(path.win32.extname('file.ext\\\\'), '.ext');
assert.strictEqual(path.win32.extname('file\\'), '');
assert.strictEqual(path.win32.extname('file\\\\'), '');
assert.strictEqual(path.win32.extname('file.\\'), '.');
assert.strictEqual(path.win32.extname('file.\\\\'), '.');
*/

// On *nix, backslash is a valid name component like any other character.
assert.strictEqual(path.posix.extname('.\\'), '');
assert.strictEqual(path.posix.extname('..\\'), '.\\');
assert.strictEqual(path.posix.extname('file.ext\\'), '.ext\\');
assert.strictEqual(path.posix.extname('file.ext\\\\'), '.ext\\\\');
assert.strictEqual(path.posix.extname('file\\'), '');
assert.strictEqual(path.posix.extname('file\\\\'), '');
assert.strictEqual(path.posix.extname('file.\\'), '.\\');
assert.strictEqual(path.posix.extname('file.\\\\'), '.\\\\');

```"
"```javascript:test\crypto\test-crypto-domain.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const domain = require('domain');

const test = (fn) => {
  const ex = new Error('BAM');
  const d = domain.create();
  d.on('error', common.mustCall(function(err) {
    assert.strictEqual(err, ex);
  }));
  const cb = common.mustCall(function() {
    throw ex;
  });
  d.run(cb);
};

test(function(cb) {
  crypto.pbkdf2('password', 'salt', 1, 8, cb);
});

test(function(cb) {
  crypto.randomBytes(32, cb);
});

```"
"```javascript:test\fs\test-fs-writev-sync.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = '��mlaut. ���������� ��������������������� ������������ ������������ ��������������� ������������������ ������';

const getFileName = (i) => path.join(tmpdir.path, `writev_sync_${i}.txt`);

/**
 * Testing with a array of buffers input
 */

// fs.writevSync with array of buffers with all parameters
{
  const filename = getFileName(1);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer];
  const expectedLength = bufferArr.length * buffer.byteLength;

  let written = fs.writevSync(fd, [Buffer.from('')], null);
  assert.strictEqual(written, 0);

  written = fs.writevSync(fd, bufferArr, null);
  assert.strictEqual(written, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

// fs.writevSync with array of buffers without position
{
  const filename = getFileName(2);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer, buffer];
  const expectedLength = bufferArr.length * buffer.byteLength;

  let written = fs.writevSync(fd, [Buffer.from('')]);
  assert.strictEqual(written, 0);

  written = fs.writevSync(fd, bufferArr);
  assert.strictEqual(written, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

// fs.writevSync with empty array of buffers
{
  const filename = getFileName(3);
  const fd = fs.openSync(filename, 'w');
  const written = fs.writevSync(fd, []);
  assert.strictEqual(written, 0);
  fs.closeSync(fd);

}

/**
 * Testing with wrong input types
 */
{
  const filename = getFileName(4);
  const fd = fs.openSync(filename, 'w');

  [false, 'test', {}, [{}], ['sdf'], null, undefined].forEach((i) => {
    assert.throws(
      () => fs.writevSync(fd, i, null), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

// fs.writevSync with wrong fd types
[false, 'test', {}, [{}], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.writevSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-read-stream-resume.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';

import fs from 'fs';

const file = fixtures.path('x.txt');
let data = '';
let first = true;

const stream = fs.createReadStream(file);
stream.setEncoding('utf8');
stream.on('data', common.mustCallAtLeast(function(chunk) {
  data += chunk;
  if (first) {
    first = false;
    stream.resume();
  }
}));

process.nextTick(function() {
  stream.pause();
  setTimeout(function() {
    stream.resume();
  }, 100);
});

process.on('exit', function() {
  assert.strictEqual(data, 'xyz\n');
});

```"
"```javascript:test\fs\test-fs-read-offset-null.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';


// Test to assert the desired functioning of fs.read
// when {offset:null} is passed as options parameter

import common from '../common';
import assert from 'assert';
import fs from 'fs';
const fsPromises = fs.promises;
import fixtures from '../common/fixtures';
const filepath = fixtures.path('x.txt');

const buf = Buffer.alloc(1);
// Reading only one character, hence buffer of one byte is enough.

// Tests are done by making sure the first letter in buffer is
// same as first letter in file.
// 120 is the ascii code of letter x.

// Tests for callback API.
fs.open(filepath, 'r', common.mustSucceed((fd) => {
  fs.read(fd, { offset: null, buffer: buf },
    common.mustSucceed((bytesRead, buffer) => {
      assert.strictEqual(buffer[0], 120);
      fs.close(fd, common.mustSucceed(() => { }));
    }));
}));

fs.open(filepath, 'r', common.mustSucceed((fd) => {
  fs.read(fd, buf, { offset: null },
    common.mustSucceed((bytesRead, buffer) => {
      assert.strictEqual(buffer[0], 120);
      fs.close(fd, common.mustSucceed(() => { }));
    }));
}));

let filehandle = null;
(async () => {
  // Tests for promises api
  await (async () => {
    filehandle = await fsPromises.open(filepath, 'r');
    const readObject = await filehandle.read(buf, { offset: null });
    assert.strictEqual(readObject.buffer[0], 120);
  })()
    .finally(() => filehandle?.close())
    .then(common.mustCall());

  // Undocumented: omitted position works the same as position === null
  await (async () => {
    filehandle = await fsPromises.open(filepath, 'r');
    const readObject = await filehandle.read(buf, null, buf.length);
    assert.strictEqual(readObject.buffer[0], 120);
  })()
    .finally(() => filehandle?.close())
    .then(common.mustCall());

  await (async () => {
    filehandle = await fsPromises.open(filepath, 'r');
    const readObject = await filehandle.read(buf, null, buf.length, 0);
    assert.strictEqual(readObject.buffer[0], 120);
  })()
    .finally(() => filehandle?.close())
    .then(common.mustCall());
})();
```"
"```javascript:test\fs\test-fs-chmod-mask.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that the lower bits of mode > 0o777 still works in fs APIs.

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

let mode;
// On Windows chmod is only able to manipulate write permission
if (common.isWindows) {
  mode = 0o444;  // read-only
} else {
  mode = 0o777;
}

const maskToIgnore = 0o10000;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function test(mode, asString) {
  const suffix = asString ? 'str' : 'num';
  const input = asString ?
    (mode | maskToIgnore).toString(8) : (mode | maskToIgnore);

  {
    const file = path.join(tmpdir.path, `chmod-async-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');

    fs.chmod(file, input, common.mustSucceed(() => {
      assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
    }));
  }

  {
    const file = path.join(tmpdir.path, `chmodSync-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');

    fs.chmodSync(file, input);
    assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
  }

  {
    const file = path.join(tmpdir.path, `fchmod-async-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');
    fs.open(file, 'w', common.mustSucceed((fd) => {
      fs.fchmod(fd, input, common.mustSucceed(() => {
        assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);
        fs.close(fd, assert.ifError);
      }));
    }));
  }

  {
    const file = path.join(tmpdir.path, `fchmodSync-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');
    const fd = fs.openSync(file, 'w');

    fs.fchmodSync(fd, input);
    assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);

    fs.close(fd, assert.ifError);
  }

  if (fs.lchmod) {
    const link = path.join(tmpdir.path, `lchmod-src-${suffix}`);
    const file = path.join(tmpdir.path, `lchmod-dest-${suffix}`);
    fs.writeFileSync(file, 'test', 'utf-8');
    fs.symlinkSync(file, link);

    fs.lchmod(link, input, common.mustSucceed(() => {
      assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode);
    }));
  }

  if (fs.lchmodSync) {
    const link = path.join(tmpdir.path, `lchmodSync-src-${suffix}`);
    const file = path.join(tmpdir.path, `lchmodSync-dest-${suffix}`);
    fs.writeFileSync(file, 'test', 'utf-8');
    fs.symlinkSync(file, link);

    fs.lchmodSync(link, input);
    assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode);
  }
}

test(mode, true);
test(mode, false);

```"
"```javascript:test\fs\test-fs-readfile-empty.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// Trivial test of fs.readFile on an empty file.
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

const fn = fixtures.path('empty.txt');

fs.readFile(fn, common.mustCall((err, data) => {
  assert.ok(data);
}));

fs.readFile(fn, 'utf8', common.mustCall((err, data) => {
  assert.strictEqual(data, '');
}));

fs.readFile(fn, { encoding: 'utf8' }, common.mustCall((err, data) => {
  assert.strictEqual(data, '');
}));

assert.ok(fs.readFileSync(fn));
assert.strictEqual(fs.readFileSync(fn, 'utf8'), '');

```"
"```javascript:test\crypto\test-crypto-dh-odd-key.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

function test() {
  const odd = Buffer.alloc(39, 'A');

  const c = crypto.createDiffieHellman(common.hasOpenSSL3 ? 1024 : 32);
  c.setPrivateKey(odd);
  c.generateKeys();
}

// FIPS requires a length of at least 1024
if (!common.hasFipsCrypto) {
  test();
} else {
  assert.throws(function() { test(); }, /key size too small/);
}

```"
"```javascript:test\fs\test-fs-promises-readfile.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import assert from 'assert';
import path from 'path';
import { writeFile, readFile } from 'fs/promises';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = path.join(tmpdir.path, 'large-file');

// Creating large buffer with random content
const largeBuffer = Buffer.from(
  Array.apply(null, { length: 16834 * 2 })
    .map(Math.random)
    .map((number) => (number * (1 << 8)))
);

async function createLargeFile() {
  // Writing buffer to a file then try to read it
  await writeFile(fn, largeBuffer);
}

async function validateReadFile() {
  const readBuffer = await readFile(fn);
  assert.strictEqual(readBuffer.equals(largeBuffer), true);
}

async function validateReadFileProc() {
  // Test to make sure reading a file under the /proc directory works. Adapted
  // from test-fs-read-file-sync-hostname.js.
  // Refs:
  // - https://groups.google.com/forum/#!topic/nodejs-dev/rxZ_RoH1Gn0
  // - https://github.com/nodejs/node/issues/21331

  // Test is Linux-specific.
  if (!common.isLinux)
    return;

  const hostname = await readFile('/proc/sys/kernel/hostname');
  assert.ok(hostname.length > 0);
}

function validateReadFileAbortLogicBefore() {
  const signal = AbortSignal.abort();
  assert.rejects(readFile(fn, { signal }), {
    name: 'AbortError'
  });
}

function validateReadFileAbortLogicDuring() {
  const controller = new AbortController();
  const signal = controller.signal;
  process.nextTick(() => controller.abort());
  assert.rejects(readFile(fn, { signal }), {
    name: 'AbortError'
  });
}

async function validateWrongSignalParam() {
  // Verify that if something different than Abortcontroller.signal
  // is passed, ERR_INVALID_ARG_TYPE is thrown

  await assert.rejects(async () => {
    const callback = common.mustNotCall(() => {});
    await readFile(fn, { signal: 'hello' }, callback);
  }, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });

}

(async () => {
  await createLargeFile();
  await validateReadFile();
  await validateReadFileProc();
  //await validateReadFileAbortLogicBefore();
  //await validateReadFileAbortLogicDuring();
  //await validateWrongSignalParam();
})().then(common.mustCall());

```"
"```javascript:test\fs\test-fs-readSync-position-validation.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';

// This test ensures that ""position"" argument is correctly validated

const filepath = fixtures.path('x.txt');

const buffer = Buffer.from('xyz\n');
const offset = 0;
const length = buffer.byteLength;

// allowedErrors is an array of acceptable internal errors
// For example, on some platforms read syscall might return -EFBIG or -EOVERFLOW
function testValid(position, allowedErrors = []) {
  let fdSync;
  try {
    fdSync = fs.openSync(filepath, 'r');
    fs.readSync(fdSync, buffer, offset, length, position);
    fs.readSync(fdSync, buffer, common.mustNotMutateObjectDeep({ offset, length, position }));
  } catch (err) {
    if (!allowedErrors.includes(err.code)) {
      assert.fail(err);
    }
  } finally {
    if (fdSync) fs.closeSync(fdSync);
  }
}

function testInvalid(code, position, internalCatch = false) {
  let fdSync;
  try {
    fdSync = fs.openSync(filepath, 'r');
    assert.throws(
      () => fs.readSync(fdSync, buffer, offset, length, position),
      { code }
    );
    assert.throws(
      () => fs.readSync(fdSync, buffer, common.mustNotMutateObjectDeep({ offset, length, position })),
      { code }
    );
  } finally {
    if (fdSync) fs.closeSync(fdSync);
  }
}

{
  testValid(undefined);
  testValid(null);
  testValid(-1);
  testValid(-1n);

  testValid(0);
  testValid(0n);
  testValid(1);
  testValid(1n);
  testValid(9);
  testValid(9n);
  testValid(Number.MAX_SAFE_INTEGER, [ 'EFBIG', 'EOVERFLOW' ]);
  testValid(2n ** 63n - 1n - BigInt(length), [ 'EFBIG', 'EOVERFLOW' ]);
  testInvalid('ERR_OUT_OF_RANGE', 2n ** 63n);

  // TODO(LiviaMedeiros): test `2n ** 63n - BigInt(length)`

  testInvalid('ERR_OUT_OF_RANGE', NaN);
  testInvalid('ERR_OUT_OF_RANGE', -Infinity);
  testInvalid('ERR_OUT_OF_RANGE', Infinity);
  testInvalid('ERR_OUT_OF_RANGE', -0.999);
  testInvalid('ERR_OUT_OF_RANGE', -(2n ** 64n));
  testInvalid('ERR_OUT_OF_RANGE', Number.MAX_SAFE_INTEGER + 1);
  testInvalid('ERR_OUT_OF_RANGE', Number.MAX_VALUE);

  for (const badTypeValue of [
    false, true, '1', Symbol(1), {}, [], () => {}, Promise.resolve(1),
  ]) {
    testInvalid('ERR_INVALID_ARG_TYPE', badTypeValue);
  }
}

```"
"```javascript:test\fs\test-fs-stream-fs-options.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

require('../common');
import fixtures from '../common/fixtures';
import path from 'path';
import fs from 'fs';
import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const streamOpts = ['open', 'close'];
const writeStreamOptions = [...streamOpts, 'write'];
const readStreamOptions = [...streamOpts, 'read'];
const originalFs = { fs };

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');

  writeStreamOptions.forEach((fn) => {
    const overrideFs = Object.assign({}, originalFs.fs, { [fn]: null });
    if (fn === 'write') overrideFs.writev = null;

    const opts = {
      fs: overrideFs
    };
    assert.throws(
      () => fs.createWriteStream(file, opts), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""options.fs.${fn}"" property must be of type function. ` +
        'Received null'
      },
      `createWriteStream options.fs.${fn} should throw if isn't a function`
    );
  });
}

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');
  const overrideFs = Object.assign({}, originalFs.fs, { writev: 'not a fn' });
  const opts = {
    fs: overrideFs
  };
  assert.throws(
    () => fs.createWriteStream(file, opts), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""options.fs.writev"" property must be of type function. ' +
        'Received type string (\'not a fn\')'
    },
    'createWriteStream options.fs.writev should throw if isn\'t a function'
  );
}

{
  const file = fixtures.path('x.txt');
  readStreamOptions.forEach((fn) => {
    const overrideFs = Object.assign({}, originalFs.fs, { [fn]: null });
    const opts = {
      fs: overrideFs
    };
    assert.throws(
      () => fs.createReadStream(file, opts), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""options.fs.${fn}"" property must be of type function. ` +
        'Received null'
      },
      `createReadStream options.fs.${fn} should throw if isn't a function`
    );
  });
}

```"
"```javascript:test\fs\test-fs-write-file-buffer.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import util from 'util';
import fs from 'fs';
import { join } from 'path';

let data = [
  '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcH',
  'Bw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/',
  '2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4e',
  'Hh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAAQABADASIAAhEBAxEB/8QA',
  'HwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUF',
  'BAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkK',
  'FhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1',
  'dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG',
  'x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEB',
  'AQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAEC',
  'AxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRom',
  'JygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOE',
  'hYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU',
  '1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDhfBUFl/wk',
  'OmPqKJJZw3aiZFBw4z93jnkkc9u9dj8XLfSI/EBt7DTo7ea2Ox5YXVo5FC7g',
  'Tjq24nJPXNVtO0KATRvNHCIg3zoWJWQHqp+o4pun+EtJ0zxBq8mnLJa2d1L5',
  '0NvnKRjJBUE5PAx3NYxxUY0pRtvYHSc5Ka2X9d7H/9k='];

data = data.join('\n');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const buf = Buffer.from(data, 'base64');
fs.writeFileSync(join(tmpdir.path, 'test.jpg'), buf);

util.log('Done!');

```"
"```javascript:modules\internal\crypto\hashnames.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

const kHashContextNode = 1;
const kHashContextWebCrypto = 2;
const kHashContextJwkRsa = 3;
const kHashContextJwkRsaPss = 4;
const kHashContextJwkRsaOaep = 5;
const kHashContextJwkHmac = 6;

// WebCrypto and JWK use a bunch of different names for the
// standard set of SHA-* digest algorithms... which is ... fun.
// Here we provide a utility for mapping between them in order
// make it easier in the code.

const kHashNames = {
  sha1: {
    [kHashContextNode]: 'sha1',
    [kHashContextWebCrypto]: 'SHA-1',
    [kHashContextJwkRsa]: 'RS1',
    [kHashContextJwkRsaPss]: 'PS1',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP',
    [kHashContextJwkHmac]: 'HS1',
  },
  sha256: {
    [kHashContextNode]: 'sha256',
    [kHashContextWebCrypto]: 'SHA-256',
    [kHashContextJwkRsa]: 'RS256',
    [kHashContextJwkRsaPss]: 'PS256',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP-256',
    [kHashContextJwkHmac]: 'HS256',
  },
  sha384: {
    [kHashContextNode]: 'sha384',
    [kHashContextWebCrypto]: 'SHA-384',
    [kHashContextJwkRsa]: 'RS384',
    [kHashContextJwkRsaPss]: 'PS384',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP-384',
    [kHashContextJwkHmac]: 'HS384',
  },
  sha512: {
    [kHashContextNode]: 'sha512',
    [kHashContextWebCrypto]: 'SHA-512',
    [kHashContextJwkRsa]: 'RS512',
    [kHashContextJwkRsaPss]: 'PS512',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP-512',
    [kHashContextJwkHmac]: 'HS512',
  }
};

{
  // Index the aliases
  const keys = Object.keys(kHashNames);
  for (let n = 0; n < keys.length; n++) {
    const contexts = Object.keys(kHashNames[keys[n]]);
    for (let i = 0; i < contexts.length; i++) {
      const alias =
        String.prototype.toLowerCase.call(kHashNames[keys[n]][contexts[i]]);
      if (kHashNames[alias] === undefined)
        kHashNames[alias] = kHashNames[keys[n]];
    }
  }
}

function normalizeHashName(name, context = kHashContextNode) {
  if (typeof name !== 'string')
    return name;
  name = String.prototype.toLowerCase.call(name);
  const alias = kHashNames[name] && kHashNames[name][context];
  return alias || name;
}

normalizeHashName.kContextNode = kHashContextNode;
normalizeHashName.kContextWebCrypto = kHashContextWebCrypto;
normalizeHashName.kContextJwkRsa = kHashContextJwkRsa;
normalizeHashName.kContextJwkRsaPss = kHashContextJwkRsaPss;
normalizeHashName.kContextJwkRsaOaep = kHashContextJwkRsaOaep;
normalizeHashName.kContextJwkHmac = kHashContextJwkHmac;

export default normalizeHashName;

```"
"```javascript:modules\internal\options.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

function getCLIOptions() {
  let options = new Map();
  let aliases = new Map();
  return { options, aliases };
}
function getEmbedderOptionsFromBinding() {
  return new Map();
}

let warnOnAllowUnauthorized = true;

let optionsMap;
let aliasesMap;
let embedderOptions;

// getCLIOptions() would serialize the option values from C++ land.
// It would error if the values are queried before bootstrap is
// complete so that we don't accidentally include runtime-dependent
// states into a runtime-independent snapshot.
function getCLIOptionsFromBinding() {
  if (!optionsMap) {
    ({ options: optionsMap } = getCLIOptions());
  }
  return optionsMap;
}

function getAliasesFromBinding() {
  if (!aliasesMap) {
    ({ aliases: aliasesMap } = getCLIOptions());
  }
  return aliasesMap;
}

function getEmbedderOptions() {
  if (!embedderOptions) {
    embedderOptions = getEmbedderOptionsFromBinding();
  }
  return embedderOptions;
}

function refreshOptions() {
  optionsMap = undefined;
  aliasesMap = undefined;
}

function getOptionValue(optionName) {
  const options = getCLIOptionsFromBinding();
  if (optionName.startsWith('--no-')) {
    const option = options.get('--' + optionName.slice(5));
    return option && !option.value;
  }
  return options.get(optionName)?.value;
}

function getAllowUnauthorized() {
  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';

  if (allowUnauthorized && warnOnAllowUnauthorized) {
    warnOnAllowUnauthorized = false;
    process.emitWarning(
      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +
      'environment variable to \'0\' makes TLS connections ' +
      'and HTTPS requests insecure by disabling ' +
      'certificate verification.');
  }
  return allowUnauthorized;
}

export default {
  get options() {
    return getCLIOptionsFromBinding();
  },
  get aliases() {
    return getAliasesFromBinding();
  },
  getOptionValue,
  getAllowUnauthorized,
  getEmbedderOptions,
  refreshOptions
};

export {
  getOptionValue,
  getAllowUnauthorized,
  getEmbedderOptions,
  refreshOptions
}

```"
"```javascript:test\fs\test-fs-promises-file-handle-write.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.write method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

  await fileHandle.write(buffer, 0, buffer.length);
  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(buffer, readFileData);

  await fileHandle.close();
}

async function validateEmptyWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-empty-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const buffer = Buffer.from(''); // empty buffer

  await fileHandle.write(buffer, 0, buffer.length);
  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(buffer, readFileData);

  await fileHandle.close();
}

async function validateNonUint8ArrayWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-data-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const buffer = Buffer.from('Hello world', 'utf8').toString('base64');

  await fileHandle.write(buffer, 0, buffer.length);
  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(Buffer.from(buffer, 'utf8'), readFileData);

  await fileHandle.close();
}

async function validateNonStringValuesWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-non-string-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const nonStringValues = [
    123, {}, new Map(), null, undefined, 0n, () => {}, Symbol(), true,
    new String('notPrimitive'),
    { toString() { return 'amObject'; } },
    { [Symbol.toPrimitive]: (hint) => 'amObject' },
  ];
  for (const nonStringValue of nonStringValues) {
    await assert.rejects(
      fileHandle.write(nonStringValue),
      { message: /""buffer""/, code: 'ERR_INVALID_ARG_TYPE' }
    );
  }

  await fileHandle.close();
}

Promise.all([
  validateWrite(),
  validateEmptyWrite(),
  validateNonUint8ArrayWrite(),
  validateNonStringValuesWrite(),
]).then(common.mustCall()).catch(err => print(err, err.stack));

```"
"```javascript:test\fs\test-fs-stream-construct-compat-old-node.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat with old node.

  function ReadStream(...args) {
    fs.ReadStream.call(this, ...args);
  }
  Object.setPrototypeOf(ReadStream.prototype, fs.ReadStream.prototype);
  Object.setPrototypeOf(ReadStream, fs.ReadStream);

  ReadStream.prototype.open = common.mustCall(function() {
    fs.open(this.path, this.flags, this.mode, (er, fd) => {
      if (er) {
        if (this.autoClose) {
          this.destroy();
        }
        this.emit('error', er);
        return;
      }

      this.fd = fd;
      this.emit('open', fd);
      this.emit('ready');
    });
  });

  let readyCalled = false;
  let ticked = false;
  const r = new ReadStream(fixtures.path('x.txt'))
    .on('ready', common.mustCall(() => {
      readyCalled = true;
      // Make sure 'ready' is emitted in same tick as 'open'.
      assert.strictEqual(ticked, false);
    }))
    .on('error', common.mustNotCall())
    .on('open', common.mustCall((fd) => {
      process.nextTick(() => {
        ticked = true;
        r.destroy();
      });
      assert.strictEqual(readyCalled, false);
      assert.strictEqual(fd, r.fd);
    }));
}

{
  // Compat with old node.

  function WriteStream(...args) {
    fs.WriteStream.call(this, ...args);
  }
  Object.setPrototypeOf(WriteStream.prototype, fs.WriteStream.prototype);
  Object.setPrototypeOf(WriteStream, fs.WriteStream);

  WriteStream.prototype.open = common.mustCall(function() {
    fs.open(this.path, this.flags, this.mode, (er, fd) => {
      if (er) {
        if (this.autoClose) {
          this.destroy();
        }
        this.emit('error', er);
        return;
      }

      this.fd = fd;
      this.emit('open', fd);
      this.emit('ready');
    });
  });

  let readyCalled = false;
  let ticked = false;
  const w = new WriteStream(`${tmpdir.path}/dummy`)
    .on('ready', common.mustCall(() => {
      readyCalled = true;
      // Make sure 'ready' is emitted in same tick as 'open'.
      assert.strictEqual(ticked, false);
    }))
    .on('error', common.mustNotCall())
    .on('open', common.mustCall((fd) => {
      process.nextTick(() => {
        ticked = true;
        w.destroy();
      });
      assert.strictEqual(readyCalled, false);
      assert.strictEqual(fd, w.fd);
    }));
}

```"
"```javascript:test\fs\test-fs-stream-double-close.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

test1(fs.createReadStream(__filename));
test2(fs.createReadStream(__filename));
test3(fs.createReadStream(__filename));

test1(fs.createWriteStream(`${tmpdir.path}/dummy1`));
test2(fs.createWriteStream(`${tmpdir.path}/dummy2`));
test3(fs.createWriteStream(`${tmpdir.path}/dummy3`));

function test1(stream) {
  stream.destroy();
  stream.destroy();
}

function test2(stream) {
  stream.destroy();
  stream.on('open', common.mustCall(function(fd) {
    stream.destroy();
  }));
}

function test3(stream) {
  stream.on('open', common.mustCall(function(fd) {
    stream.destroy();
    stream.destroy();
  }));
}

```"
"```javascript:test\fixtures\a.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const c = require('./b/c');

console.error('load fixtures/a.js');

var string = 'A';

exports.SomeClass = c.SomeClass;

exports.A = function() {
  return string;
};

exports.C = function() {
  return c.C();
};

exports.D = function() {
  return c.D();
};

exports.number = 42;

process.on('exit', function() {
  string = 'A done';
});

```"
"```javascript:test\fs\test-fs-read-file-sync-hostname.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
if (!common.isLinux)
  common.skip('Test is linux specific.');

import assert from 'assert';
import fs from 'fs';

// Test to make sure reading a file under the /proc directory works. See:
// https://groups.google.com/forum/#!topic/nodejs-dev/rxZ_RoH1Gn0
const hostname = fs.readFileSync('/proc/sys/kernel/hostname');
assert.ok(hostname.length > 0);

```"
"```javascript:modules\internal\constants.js
'use strict';

const isWindows = false;

export const CHAR_UPPERCASE_A = 65;
export const CHAR_LOWERCASE_A = 97;
export const CHAR_UPPERCASE_Z = 90;
export const CHAR_LOWERCASE_Z = 122;
export const CHAR_UPPERCASE_C = 67;
export const CHAR_LOWERCASE_B = 98;
export const CHAR_LOWERCASE_E = 101;
export const CHAR_LOWERCASE_N = 110;
export const CHAR_DOT = 46;
export const CHAR_FORWARD_SLASH = 47;
export const CHAR_BACKWARD_SLASH = 92;
export const CHAR_VERTICAL_LINE = 124;
export const CHAR_COLON = 58;
export const CHAR_QUESTION_MARK = 63;
export const CHAR_UNDERSCORE = 95;
export const CHAR_LINE_FEED = 10;
export const CHAR_CARRIAGE_RETURN = 13;
export const CHAR_TAB = 9;
export const CHAR_FORM_FEED = 12;
export const CHAR_EXCLAMATION_MARK = 33;
export const CHAR_HASH = 35;
export const CHAR_SPACE = 32;
export const CHAR_NO_BREAK_SPACE = 160;
export const CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279;
export const CHAR_LEFT_SQUARE_BRACKET = 91;
export const CHAR_RIGHT_SQUARE_BRACKET = 93;
export const CHAR_LEFT_ANGLE_BRACKET = 60;
export const CHAR_RIGHT_ANGLE_BRACKET = 62;
export const CHAR_LEFT_CURLY_BRACKET = 123;
export const CHAR_RIGHT_CURLY_BRACKET = 125;
export const CHAR_HYPHEN_MINUS = 45;
export const CHAR_PLUS = 43;
export const CHAR_DOUBLE_QUOTE = 34;
export const CHAR_SINGLE_QUOTE = 39;
export const CHAR_PERCENT = 37;
export const CHAR_SEMICOLON = 59;
export const CHAR_CIRCUMFLEX_ACCENT = 94;
export const CHAR_GRAVE_ACCENT = 96;
export const CHAR_AT = 64;
export const CHAR_AMPERSAND = 38;
export const CHAR_EQUAL = 61;
export const CHAR_0 = 48;
export const CHAR_9 = 57;
export const EOL = isWindows ? '\r\n' : '\n';

```"
"```javascript:test\fs\test-fs-realpath-buffer-encoding.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';

const string_dir = fs.realpathSync(fixtures.fixturesDir);
const buffer_dir = Buffer.from(string_dir);

const encodings = ['ascii', 'utf8', 'utf16le', 'ucs2',
                   'base64', 'binary', 'hex'];
const expected = {};
encodings.forEach((encoding) => {
  expected[encoding] = buffer_dir.toString(encoding);
});


// test sync version
let encoding;
for (encoding in expected) {
  const expected_value = expected[encoding];
  let result;

  result = fs.realpathSync(string_dir, { encoding });
  assert.strictEqual(result, expected_value);

  result = fs.realpathSync(string_dir, encoding);
  assert.strictEqual(result, expected_value);

  result = fs.realpathSync(buffer_dir, { encoding });
  assert.strictEqual(result, expected_value);

  result = fs.realpathSync(buffer_dir, encoding);
  assert.strictEqual(result, expected_value);
}

let buffer_result;
buffer_result = fs.realpathSync(string_dir, { encoding: 'buffer' });
assert.deepStrictEqual(buffer_result, buffer_dir);

buffer_result = fs.realpathSync(string_dir, 'buffer');
assert.deepStrictEqual(buffer_result, buffer_dir);

buffer_result = fs.realpathSync(buffer_dir, { encoding: 'buffer' });
assert.deepStrictEqual(buffer_result, buffer_dir);

buffer_result = fs.realpathSync(buffer_dir, 'buffer');
assert.deepStrictEqual(buffer_result, buffer_dir);

// test async version
for (encoding in expected) {
  const expected_value = expected[encoding];

  fs.realpath(
    string_dir,
    { encoding },
    common.mustSucceed((res) => {
      assert.strictEqual(res, expected_value);
    })
  );
  fs.realpath(string_dir, encoding, common.mustSucceed((res) => {
    assert.strictEqual(res, expected_value);
  }));
  fs.realpath(
    buffer_dir,
    { encoding },
    common.mustSucceed((res) => {
      assert.strictEqual(res, expected_value);
    })
  );
  fs.realpath(buffer_dir, encoding, common.mustSucceed((res) => {
    assert.strictEqual(res, expected_value);
  }));
}

fs.realpath(string_dir, { encoding: 'buffer' }, common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));

fs.realpath(string_dir, 'buffer', common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));

fs.realpath(buffer_dir, { encoding: 'buffer' }, common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));

fs.realpath(buffer_dir, 'buffer', common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));

```"
"```javascript:modules\stream.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import { addAbortSignal } from ""./internal/streams/add-abort-signal.js"";
import { destroyer } from ""./internal/streams/destroy.js"";
import { isDisturbed } from ""./internal/streams/utils.js"";
import { isUint8Array } from ""./internal/util/types.js"";
import { pipeline } from ""./internal/streams/pipeline.js"";
import { promisify } from ""./internal/util.js"";
import { Stream } from ""./internal/streams/legacy.js"";
import compose from ""./internal/streams/compose.js"";
import Duplex from ""./internal/streams/duplex.js"";
import eos from ""./internal/streams/end-of-stream.js"";
import PassThrough from ""./internal/streams/passthrough.js"";
import promises from ""./stream/promises.js"";
import Readable from ""./internal/streams/readable.js"";
import Transform from ""./internal/streams/transform.js"";
import Writable from ""./internal/streams/writable.js"";
import { Buffer } from ""buffer"";

const { custom: customPromisify } = promisify;

function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(
        chunk.buffer,
        chunk.byteOffset,
        chunk.byteLength,
    );
}

Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;

Object.defineProperty(Stream, ""promises"", {
    configurable: true,
    enumerable: true,
    get() {
        return promises;
    },
});

Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get() {
        return promises.pipeline;
    },
});

Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get() {
        return promises.finished;
    },
});

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;

export default Stream;
export {
    _uint8ArrayToBuffer,
    addAbortSignal,
    compose,
    destroyer as destroy,
    Duplex,
    eos as finished,
    isDisturbed,
    isUint8Array as _isUint8Array,
    PassThrough,
    pipeline,
    Readable,
    Stream,
    Transform,
    Writable,
};
```"
"```javascript:test\fs\test-fs-read-file-sync.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const fn = fixtures.path('elipses.txt');

const s = fs.readFileSync(fn, 'utf8');
for (let i = 0; i < s.length; i++) {
  assert.strictEqual(s[i], '\u2026');
}
assert.strictEqual(s.length, 10000);

```"
"```javascript:test\fs\test-fs-read-stream-file-handle.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'read_stream_filehandle_test.txt');
const input = 'hello world';

tmpdir.refresh();
fs.writeFileSync(file, input);

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });

  let output = '';
  stream.on('data', common.mustCallAtLeast((data) => {
    output += data;
  }));

  stream.on('end', common.mustCall(() => {
    assert.strictEqual(output, input);
  }));

  stream.on('close', common.mustCall());
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });
  stream.on('data', common.mustNotCall());
  stream.on('close', common.mustCall());

  return handle.close();
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });
  stream.on('close', common.mustCall());

  stream.on('data', common.mustCall(() => {
    handle.close();
  }));
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });
  stream.on('close', common.mustCall());

  stream.close();
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  assert.throws(() => {
    fs.createReadStream(null, { fd: handle, fs });
  }, {
    code: 'ERR_METHOD_NOT_IMPLEMENTED',
    name: 'Error',
    message: 'The FileHandle with fs method is not implemented'
  });
  return handle.close();
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  const { read: originalReadFunction } = handle;
  handle.read = common.mustCallAtLeast(function read() {
    return Reflect.apply(originalReadFunction, this, arguments);
  });

  const stream = fs.createReadStream(null, { fd: handle });

  let output = '';
  stream.on('data', common.mustCallAtLeast((data) => {
    output += data;
  }));

  stream.on('end', common.mustCall(() => {
    assert.strictEqual(output, input);
  }));
}).then(common.mustCall());

```"
"```javascript:test\fs\test-fs-readv-sync.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = '��mlaut. ���������� ��������������������� ������������ ������������ ��������������� ������������������ ������';

const exptectedBuff = Buffer.from(expected);
const expectedLength = exptectedBuff.length;

const filename = path.join(tmpdir.path, 'readv_sync.txt');
fs.writeFileSync(filename, exptectedBuff);

const allocateEmptyBuffers = (combinedLength) => {
  const bufferArr = [];
  // Allocate two buffers, each half the size of exptectedBuff
  bufferArr[0] = Buffer.alloc(Math.floor(combinedLength / 2));
  bufferArr[1] = Buffer.alloc(combinedLength - bufferArr[0].length);

  return bufferArr;
};

// fs.readvSync with array of buffers with all parameters
{
  const fd = fs.openSync(filename, 'r');

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);

  let read = fs.readvSync(fd, [Buffer.from('')], 0);
  assert.strictEqual(read, 0);

  read = fs.readvSync(fd, bufferArr, 0);
  assert.strictEqual(read, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

// fs.readvSync with array of buffers without position
{
  const fd = fs.openSync(filename, 'r');

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);

  let read = fs.readvSync(fd, [Buffer.from('')]);
  assert.strictEqual(read, 0);

  read = fs.readvSync(fd, bufferArr);
  assert.strictEqual(read, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

/**
 * Testing with incorrect arguments
 */
const wrongInputs = [false, 'test', {}, [{}], ['sdf'], null, undefined];

{
  const fd = fs.openSync(filename, 'r');

  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readvSync(fd, wrongInput, null), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

{
  // fs.readv with wrong fd argument
  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readvSync(wrongInput),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });
}

```"
"```javascript:test\fs\test-fs-mkdir-recursive-eaccess.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Test that mkdir with recursive option returns appropriate error
// when executed on folder it does not have permission to access.
// Ref: https://github.com/nodejs/node/issues/31481

import common from '../common';
import process from 'process';

if (!common.isWindows && process.getuid() === 0)
  common.skip('as this test should not be run as `root`');

if (common.isIBMi)
  common.skip('IBMi has a different access permission mechanism');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

import assert from 'assert';
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

let n = 0;

function makeDirectoryReadOnly(dir) {
  let accessErrorCode = 'EACCES';
  if (common.isWindows) {
    accessErrorCode = 'EPERM';
    execSync(`icacls ${dir} /deny ""everyone:(OI)(CI)(DE,DC,AD,WD)""`);
  } else {
    fs.chmodSync(dir, '444');
  }
  return accessErrorCode;
}

function makeDirectoryWritable(dir) {
  if (common.isWindows) {
    execSync(`icacls ${dir} /remove:d ""everyone""`);
  }
}

// Synchronous API should return an EACCESS error with path populated.
{
  const dir = path.join(tmpdir.path, `mkdirp_${n++}`);
  fs.mkdirSync(dir);
  const codeExpected = makeDirectoryReadOnly(dir);
  let err = null;
  try {
    fs.mkdirSync(path.join(dir, '/foo'), { recursive: true });
  } catch (_err) {
    err = _err;
  }
  makeDirectoryWritable(dir);
  assert(err);
  assert.strictEqual(err.code, codeExpected);
  assert(err.path);
}

// Asynchronous API should return an EACCESS error with path populated.
{
  const dir = path.join(tmpdir.path, `mkdirp_${n++}`);
  fs.mkdirSync(dir);
  const codeExpected = makeDirectoryReadOnly(dir);
  fs.mkdir(path.join(dir, '/bar'), { recursive: true }, (err) => {
    makeDirectoryWritable(dir);
    assert(err);
    assert.strictEqual(err.code, codeExpected);
    assert(err.path);
  });
}

```"
"```javascript:test\fs\test-fs-read-stream-pos.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Refs: https://github.com/nodejs/node/issues/33940

import common from '../common';
import tmpdir from '../common/tmpdir';
import fs from 'fs';
import assert from 'assert';
import path from 'path';

tmpdir.refresh();

const file = path.join(tmpdir.path, '/read_stream_pos_test.txt');

fs.writeFileSync(file, '');

let counter = 0;

const writeInterval = setInterval(() => {
  counter = counter + 1;
  const line = `hello at ${counter}\n`;
  fs.writeFileSync(file, line, { flag: 'a' });
}, 1);

const hwm = 10;
let bufs = [];
let isLow = false;
let cur = 0;
let stream;

const readInterval = setInterval(() => {
  if (stream) return;

  stream = fs.createReadStream(file, {
    highWaterMark: hwm,
    start: cur
  });
  stream.on('data', common.mustCallAtLeast((chunk) => {
    cur += chunk.length;
    bufs.push(chunk);
    if (isLow) {
      const brokenLines = Buffer.concat(bufs).toString()
        .split('\n')
        .filter((line) => {
          const s = 'hello at'.slice(0, line.length);
          if (line && !line.startsWith(s)) {
            return true;
          }
          return false;
        });
      assert.strictEqual(brokenLines.length, 0);
      exitTest();
      return;
    }
    if (chunk.length !== hwm) {
      isLow = true;
    }
  }));
  stream.on('end', () => {
    stream = null;
    isLow = false;
    bufs = [];
  });
}, 10);

// Time longer than 90 seconds to exit safely
const endTimer = setTimeout(() => {
  exitTest();
}, 90000);

const exitTest = () => {
  clearInterval(readInterval);
  clearInterval(writeInterval);
  clearTimeout(endTimer);
  if (stream && !stream.destroyed) {
    stream.on('close', () => {
      process.exit();
    });
    stream.destroy();
  } else {
    process.exit();
  }
};

```"
"```javascript:test\crypto\test-crypto-psychic-signatures.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const crypto = require('crypto');

// Tests for CVE-2022-21449
// https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/
// Dubbed ""Psychic Signatures"", these signatures bypassed the ECDSA signature
// verification implementation in Java in 15, 16, 17, and 18. OpenSSL is not
// (and was not) vulnerable so these are a precaution.

const vectors = {
  'ieee-p1363': [
    Buffer.from('0000000000000000000000000000000000000000000000000000000000000000' +
      '0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
    Buffer.from('ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551' +
      'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551', 'hex'),
  ],
  'der': [
    Buffer.from('3046022100' +
      '0000000000000000000000000000000000000000000000000000000000000000' +
      '022100' +
      '0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
    Buffer.from('3046022100' +
      'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551' +
      '022100' +
      'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551', 'hex'),
  ],
};

const keyPair = crypto.generateKeyPairSync('ec', {
  namedCurve: 'P-256',
  publicKeyEncoding: {
    format: 'der',
    type: 'spki'
  },
});

const data = Buffer.from('Hello!');

for (const [encoding, signatures] of Object.entries(vectors)) {
  for (const signature of signatures) {
    const key = {
      key: keyPair.publicKey,
      format: 'der',
      type: 'spki',
      dsaEncoding: encoding,
    };

    // one-shot sync
    assert.strictEqual(
      crypto.verify(
        'sha256',
        data,
        key,
        signature,
      ),
      false,
    );

    // one-shot async
    crypto.verify(
      'sha256',
      data,
      key,
      signature,
      common.mustSucceed((verified) => assert.strictEqual(verified, false)),
    );

    // stream
    assert.strictEqual(
      crypto.createVerify('sha256')
        .update(data)
        .verify(key, signature),
      false,
    );

    // webcrypto
    crypto.webcrypto.subtle.importKey(
      'spki',
      keyPair.publicKey,
      { name: 'ECDSA', namedCurve: 'P-256' },
      false,
      ['verify'],
    ).then((publicKey) => {
      return crypto.webcrypto.subtle.verify(
        { name: 'ECDSA', hash: 'SHA-256' },
        publicKey,
        signature,
        data,
      );
    }).then(common.mustCall((verified) => {
      assert.strictEqual(verified, false);
    }));
  }
}

```"
"```javascript:test\fs\test-fs-lchmod.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
const { promises } = fs;
const f = __filename;

// This test ensures that input for lchmod is valid, testing for valid
// inputs for path, mode and callback

if (!common.isOSX) {
  common.skip('lchmod is only available on macOS');
}

// Check callback
assert.throws(() => fs.lchmod(f), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.lchmod(), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.lchmod(f, {}), { code: 'ERR_INVALID_ARG_TYPE' });

// Check path
[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.lchmod(i, 0o777, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.lchmodSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Check mode
[false, null, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
  };

  assert.rejects(promises.lchmod(f, input, () => {}), errObj);
  assert.throws(() => fs.lchmodSync(f, input), errObj);
});

assert.throws(() => fs.lchmod(f, '123x', common.mustNotCall()), {
  code: 'ERR_INVALID_ARG_VALUE'
});
assert.throws(() => fs.lchmodSync(f, '123x'), {
  code: 'ERR_INVALID_ARG_VALUE'
});

[-1, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""mode"" is out of range. It must be >= 0 && <= ' +
             `4294967295. Received ${input}`
  };

  assert.rejects(promises.lchmod(f, input, () => {}), errObj);
  assert.throws(() => fs.lchmodSync(f, input), errObj);
});

```"
"The following document is located at example_js\create-react-app-ssr\public\index.html
------
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""utf-8"" />
    <link rel=""icon"" href=""%PUBLIC_URL%/favicon.ico"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1"" />
    <meta name=""theme-color"" content=""#000000"" />
    <meta
      name=""description""
      content=""Web site created using create-react-app""
    />
    <link rel=""apple-touch-icon"" href=""%PUBLIC_URL%/logo192.png"" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel=""manifest"" href=""%PUBLIC_URL%/manifest.json"" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike ""/favicon.ico"" or ""favicon.ico"", ""%PUBLIC_URL%/favicon.ico"" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id=""root""></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

------"
"```javascript:test\fs\test-fs-promises-file-handle-aggregate-errors.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
// Flags: --expose-internals

import common from '../common';
import tmpdir from '../common/tmpdir';

// The following tests validate aggregate errors are thrown correctly
// when both an operation and close throw.

import path from 'path';
import {
  readFile,
  writeFile,
  truncate,
  lchmod,
} from 'fs/promises';
import {
  FileHandle,
} from 'fs';

import assert from 'assert';
const originalFd = Object.getOwnPropertyDescriptor(FileHandle.prototype, 'fd');

let count = 0;
async function createFile() {
  const filePath = path.join(tmpdir.path, `aggregate_errors_${++count}.txt`);
  await writeFile(filePath, 'content');
  return filePath;
}

async function checkAggregateError(op) {
  try {
    const filePath = await createFile();
    Object.defineProperty(FileHandle.prototype, 'fd', {
      get: function() {
        // Close is set by using a setter,
        // so it needs to be set on the instance.
        const originalClose = this.close;
        this.close = async () => {
          // close the file
          await originalClose.call(this);
          const closeError = new Error('CLOSE_ERROR');
          closeError.code = 456;
          throw closeError;
        };
        const opError = new Error('INTERNAL_ERROR');
        opError.code = 123;
        throw opError;
      }
    });

    await assert.rejects(op(filePath), common.mustCall((err) => {
      assert.strictEqual(err.name, 'AggregateError');
      assert.strictEqual(err.code, 123);
      assert.strictEqual(err.errors.length, 2);
      assert.strictEqual(err.errors[0].message, 'INTERNAL_ERROR');
      assert.strictEqual(err.errors[1].message, 'CLOSE_ERROR');
      return true;
    }));
  } finally {
    Object.defineProperty(FileHandle.prototype, 'fd', originalFd);
  }
}
(async function() {
  tmpdir.refresh();
  await checkAggregateError((filePath) => truncate(filePath));
  await checkAggregateError((filePath) => readFile(filePath));
  await checkAggregateError((filePath) => writeFile(filePath, '123'));
  if (common.isOSX) {
    await checkAggregateError((filePath) => lchmod(filePath, 0o777));
  }
})().then(common.mustCall());

```"
"```javascript:test\crypto\test-crypto-secure-heap.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

if (common.isWindows)
  common.skip('Not supported on Windows');

if (process.config.variables.asan)
  common.skip('ASAN does not play well with secure heap allocations');

const assert = require('assert');
const { fork } = require('child_process');
const fixtures = require('../common/fixtures');
const {
  secureHeapUsed,
  createDiffieHellman,
} = require('crypto');

if (process.argv[2] === 'child') {

  const a = secureHeapUsed();

  assert(a);
  assert.strictEqual(typeof a, 'object');
  assert.strictEqual(a.total, 65536);
  assert.strictEqual(a.min, 4);
  assert.strictEqual(a.used, 0);

  {
    const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
    const dh1 = createDiffieHellman(size);
    const p1 = dh1.getPrime('buffer');
    const dh2 = createDiffieHellman(p1, 'buffer');
    const key1 = dh1.generateKeys();
    const key2 = dh2.generateKeys('hex');
    dh1.computeSecret(key2, 'hex', 'base64');
    dh2.computeSecret(key1, 'latin1', 'buffer');

    const b = secureHeapUsed();
    assert(b);
    assert.strictEqual(typeof b, 'object');
    assert.strictEqual(b.total, 65536);
    assert.strictEqual(b.min, 4);
    // The amount used can vary on a number of factors
    assert(b.used > 0);
    assert(b.utilization > 0.0);
  }

  return;
}

const child = fork(
  process.argv[1],
  ['child'],
  { execArgv: ['--secure-heap=65536', '--secure-heap-min=4'] });

child.on('exit', common.mustCall((code) => {
  assert.strictEqual(code, 0);
}));

{
  const child = fork(fixtures.path('a.js'), {
    execArgv: ['--secure-heap=3', '--secure-heap-min=3'],
    stdio: 'pipe'
  });
  let res = '';
  child.on('exit', common.mustCall((code) => {
    assert.notStrictEqual(code, 0);
    assert.match(res, /--secure-heap must be a power of 2/);
    assert.match(res, /--secure-heap-min must be a power of 2/);
  }));
  child.stderr.setEncoding('utf8');
  child.stderr.on('data', (chunk) => res += chunk);
}

```"
"```javascript:test\common\tmpdir.js
'use strict';

import { rmSync as _rmSync, realpathSync, mkdirSync, readdirSync } from 'fs';
import { resolve, join } from 'path';
const isMainThread = undefined;

function rmSync(pathname) {
  _rmSync(pathname, { maxRetries: 3, recursive: true, force: true });
}

import process from 'process';

const testRoot = process.env.NODE_TEST_DIR ?
  realpathSync(process.env.NODE_TEST_DIR) : resolve(__dirname, '..');

// Using a `.` prefixed name, which is the convention for ""hidden"" on POSIX,
// gets tools to ignore it by default or by simple rules, especially eslint.
const tmpdirName = '.tmp.' +
  (process.env.TEST_SERIAL_ID || process.env.TEST_THREAD_ID || '0');
const tmpPath = join(testRoot, tmpdirName);

let firstRefresh = true;
function refresh() {
  rmSync(tmpPath);
  mkdirSync(tmpPath);

  if (firstRefresh) {
    firstRefresh = false;
    // Clean only when a test uses refresh. This allows for child processes to
    // use the tmpdir and only the parent will clean on exit.
    process.on('exit', onexit);
  }
}

function onexit() {
  // Change directory to avoid possible EBUSY
  if (isMainThread)
    process.chdir(testRoot);

  try {
    rmSync(tmpPath);
  } catch (e) {
    console.error('Can\'t clean tmpdir:', tmpPath);

    const files = readdirSync(tmpPath);
    console.error('Files blocking:', files);

    if (files.some((f) => f.startsWith('.nfs'))) {
      // Warn about NFS ""silly rename""
      console.error('Note: "".nfs*"" might be files that were open and ' +
                    'unlinked but not closed.');
      console.error('See http://nfs.sourceforge.net/#faq_d2 for details.');
    }

    console.error();
    throw e;
  }
}

export default {
  path: tmpPath,
  refresh
};

```"
"```javascript:test\fixtures\cycles\root.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const foo = exports.foo = require('./folder/foo');

exports.hello = 'hello';
exports.sayHello = function() {
  return foo.hello();
};
exports.calledFromFoo = function() {
  return exports.hello;
};

```"
"```javascript:test\fs\test-fs-readv-promises.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs/promises';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = '��mlaut. ���������� ��������������������� ������������ ������������ ��������������� ������������������ ������';
const exptectedBuff = Buffer.from(expected);

let cnt = 0;
function getFileName() {
  return path.join(tmpdir.path, `readv_promises_${++cnt}.txt`);
}

const allocateEmptyBuffers = (combinedLength) => {
  const bufferArr = [];
  // Allocate two buffers, each half the size of exptectedBuff
  bufferArr[0] = Buffer.alloc(Math.floor(combinedLength / 2));
  bufferArr[1] = Buffer.alloc(combinedLength - bufferArr[0].length);

  return bufferArr;
};

(async () => {
  {
    const filename = getFileName();
    await fs.writeFile(filename, exptectedBuff);
    const handle = await fs.open(filename, 'r');
    // const buffer = Buffer.from(expected);
    const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
    const expectedLength = exptectedBuff.length;

    let { bytesRead, buffers } = await handle.readv([Buffer.from('')],
                                                    null);
    assert.strictEqual(bytesRead, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);

    ({ bytesRead, buffers } = await handle.readv(bufferArr, null));
    assert.strictEqual(bytesRead, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }

  {
    const filename = getFileName();
    await fs.writeFile(filename, exptectedBuff);
    const handle = await fs.open(filename, 'r');
    // const buffer = Buffer.from(expected);
    const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
    const expectedLength = exptectedBuff.length;

    let { bytesRead, buffers } = await handle.readv([Buffer.from('')]);
    assert.strictEqual(bytesRead, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);

    ({ bytesRead, buffers } = await handle.readv(bufferArr));
    assert.strictEqual(bytesRead, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }
})().then(common.mustCall());

```"
"```javascript:test\fs\test-fs-fchown.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';

function testFd(input, errObj) {
  assert.throws(() => fs.fchown(input), errObj);
  assert.throws(() => fs.fchownSync(input), errObj);
}

function testUid(input, errObj) {
  assert.throws(() => fs.fchown(1, input), errObj);
  assert.throws(() => fs.fchownSync(1, input), errObj);
}

function testGid(input, errObj) {
  assert.throws(() => fs.fchown(1, 1, input), errObj);
  assert.throws(() => fs.fchownSync(1, 1, input), errObj);
}

['', false, null, undefined, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: /fd|uid|gid/
  };
  testFd(input, errObj);
  testUid(input, errObj);
  testGid(input, errObj);
});

[Infinity, NaN].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be an integer. ' +
             `Received ${input}`
  };
  testFd(input, errObj);
  errObj.message = errObj.message.replace('fd', 'uid');
  testUid(input, errObj);
  errObj.message = errObj.message.replace('uid', 'gid');
  testGid(input, errObj);
});

[-2, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be ' +
             `>= 0 && <= 2147483647. Received ${input}`
  };
  testFd(input, errObj);
  errObj.message = 'The value of ""uid"" is out of range. It must be >= -1 && ' +
    `<= 4294967295. Received ${input}`;
  testUid(input, errObj);
  errObj.message = errObj.message.replace('uid', 'gid');
  testGid(input, errObj);
});

```"
"```javascript:test\fs\test-fs-lchown.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
const { promises } = fs;

// Validate the path argument.
[false, 1, {}, [], null, undefined].forEach((i) => {
  const err = { name: 'TypeError', code: 'ERR_INVALID_ARG_TYPE' };

  assert.throws(() => fs.lchown(i, 1, 1, common.mustNotCall()), err);
  assert.throws(() => fs.lchownSync(i, 1, 1), err);
  promises.lchown(false, 1, 1)
    .then(common.mustNotCall())
    .catch(common.expectsError(err));
});

// Validate the uid and gid arguments.
[false, 'test', {}, [], null, undefined].forEach((i) => {
  const err = { name: 'TypeError', code: 'ERR_INVALID_ARG_TYPE' };

  assert.throws(
    () => fs.lchown('not_a_file_that_exists', i, 1, common.mustNotCall()),
    err
  );
  assert.throws(
    () => fs.lchown('not_a_file_that_exists', 1, i, common.mustNotCall()),
    err
  );
  assert.throws(() => fs.lchownSync('not_a_file_that_exists', i, 1), err);
  assert.throws(() => fs.lchownSync('not_a_file_that_exists', 1, i), err);

  promises.lchown('not_a_file_that_exists', i, 1)
    .then(common.mustNotCall())
    .catch(common.expectsError(err));

  promises.lchown('not_a_file_that_exists', 1, i)
    .then(common.mustNotCall())
    .catch(common.expectsError(err));
});

// Validate the callback argument.
[false, 1, 'test', {}, [], null, undefined].forEach((i) => {
  assert.throws(() => fs.lchown('not_a_file_that_exists', 1, 1, i), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

if (!common.isWindows) {
  const testFile = path.join(tmpdir.path, path.basename(__filename));
  const uid = process.geteuid();
  const gid = process.getegid();

  tmpdir.refresh();
  fs.copyFileSync(__filename, testFile);
  fs.lchownSync(testFile, uid, gid);
  fs.lchown(testFile, uid, gid, common.mustSucceed(async (err) => {
    await promises.lchown(testFile, uid, gid);
  }));
}

```"
"```javascript:test\path\test-path-relative.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

const failures = [];

const relativeTests = [
  /*[ path.win32.relative,
    // Arguments                     result
    [['c:/blah\\blah', 'd:/games', 'd:\\games'],
     ['c:/aaaa/bbbb', 'c:/aaaa', '..'],
     ['c:/aaaa/bbbb', 'c:/cccc', '..\\..\\cccc'],
     ['c:/aaaa/bbbb', 'c:/aaaa/bbbb', ''],
     ['c:/aaaa/bbbb', 'c:/aaaa/cccc', '..\\cccc'],
     ['c:/aaaa/', 'c:/aaaa/cccc', 'cccc'],
     ['c:/', 'c:\\aaaa\\bbbb', 'aaaa\\bbbb'],
     ['c:/aaaa/bbbb', 'd:\\', 'd:\\'],
     ['c:/AaAa/bbbb', 'c:/aaaa/bbbb', ''],
     ['c:/aaaaa/', 'c:/aaaa/cccc', '..\\aaaa\\cccc'],
     ['C:\\foo\\bar\\baz\\quux', 'C:\\', '..\\..\\..\\..'],
     ['C:\\foo\\test', 'C:\\foo\\test\\bar\\package.json', 'bar\\package.json'],
     ['C:\\foo\\bar\\baz-quux', 'C:\\foo\\bar\\baz', '..\\baz'],
     ['C:\\foo\\bar\\baz', 'C:\\foo\\bar\\baz-quux', '..\\baz-quux'],
     ['\\\\foo\\bar', '\\\\foo\\bar\\baz', 'baz'],
     ['\\\\foo\\bar\\baz', '\\\\foo\\bar', '..'],
     ['\\\\foo\\bar\\baz-quux', '\\\\foo\\bar\\baz', '..\\baz'],
     ['\\\\foo\\bar\\baz', '\\\\foo\\bar\\baz-quux', '..\\baz-quux'],
     ['C:\\baz-quux', 'C:\\baz', '..\\baz'],
     ['C:\\baz', 'C:\\baz-quux', '..\\baz-quux'],
     ['\\\\foo\\baz-quux', '\\\\foo\\baz', '..\\baz'],
     ['\\\\foo\\baz', '\\\\foo\\baz-quux', '..\\baz-quux'],
     ['C:\\baz', '\\\\foo\\bar\\baz', '\\\\foo\\bar\\baz'],
     ['\\\\foo\\bar\\baz', 'C:\\baz', 'C:\\baz'],
    ],
  ],*/
  [ path.posix.relative,
    // Arguments          result
    [['/var/lib', '/var', '..'],
     ['/var/lib', '/bin', '../../bin'],
     ['/var/lib', '/var/lib', ''],
     ['/var/lib', '/var/apache', '../apache'],
     ['/var/', '/var/lib', 'lib'],
     ['/', '/var/lib', 'var/lib'],
     ['/foo/test', '/foo/test/bar/package.json', 'bar/package.json'],
     ['/Users/a/web/b/test/mails', '/Users/a/web/b', '../..'],
     ['/foo/bar/baz-quux', '/foo/bar/baz', '../baz'],
     ['/foo/bar/baz', '/foo/bar/baz-quux', '../baz-quux'],
     ['/baz-quux', '/baz', '../baz'],
     ['/baz', '/baz-quux', '../baz-quux'],
     ['/page1/page2/foo', '/', '../../..'],
    ],
  ],
];
relativeTests.forEach((test) => {
  const relative = test[0];
  test[1].forEach((test) => {
    const actual = relative(test[0], test[1]);
    const expected = test[2];
    if (actual !== expected) {
      const os = /*relative === path.win32.relative ? 'win32' : */'posix';
      const message = `path.${os}.relative(${
        test.slice(0, 2).map(JSON.stringify).join(',')})\n  expect=${
        JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
      failures.push(`\n${message}`);
    }
  });
});
assert.strictEqual(failures.length, 0, failures.join(''));

```"
"```javascript:test\fs\test-fs-writev-promises.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs/promises';
import tmpdir from '../common/tmpdir';
const expected = '��mlaut. ���������� ��������������������� ������������ ������������ ��������������� ������������������ ������';
let cnt = 0;

function getFileName() {
  return path.join(tmpdir.path, `writev_promises_${++cnt}.txt`);
}

tmpdir.refresh();

(async () => {
  {
    const filename = getFileName();
    const handle = await fs.open(filename, 'w');
    const buffer = Buffer.from(expected);
    const bufferArr = [buffer, buffer];
    const expectedLength = bufferArr.length * buffer.byteLength;
    let { bytesWritten, buffers } = await handle.writev([Buffer.from('')],
                                                        null);
    assert.strictEqual(bytesWritten, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);
    ({ bytesWritten, buffers } = await handle.writev(bufferArr, null));
    assert.deepStrictEqual(bytesWritten, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }

  // fs.promises.writev() with an array of buffers without position.
  {
    const filename = getFileName();
    const handle = await fs.open(filename, 'w');
    const buffer = Buffer.from(expected);
    const bufferArr = [buffer, buffer, buffer];
    const expectedLength = bufferArr.length * buffer.byteLength;
    let { bytesWritten, buffers } = await handle.writev([Buffer.from('')]);
    assert.strictEqual(bytesWritten, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);
    ({ bytesWritten, buffers } = await handle.writev(bufferArr));
    assert.deepStrictEqual(bytesWritten, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }

  {
    // Writev with empty array behavior
    const handle = await fs.open(getFileName(), 'w');
    const result = await handle.writev([]);
    assert.strictEqual(result.bytesWritten, 0);
    assert.strictEqual(result.buffers.length, 0);
    handle.close();
  }
})().then(common.mustCall());

```"
"```javascript:test\crypto\test-crypto-getcipherinfo.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const {
  getCiphers,
  getCipherInfo
} = require('crypto');

const assert = require('assert');

const ciphers = getCiphers();

assert.strictEqual(getCipherInfo(-1), undefined);
assert.strictEqual(getCipherInfo('cipher that does not exist'), undefined);

ciphers.forEach((cipher) => {
  const info = getCipherInfo(cipher);
  assert(info);
  const info2 = getCipherInfo(info.nid);
  assert.deepStrictEqual(info, info2);
});

const info = getCipherInfo('aes-128-cbc');
assert.strictEqual(info.name, 'aes-128-cbc');
assert.strictEqual(info.nid, 419);
assert.strictEqual(info.blockSize, 16);
assert.strictEqual(info.ivLength, 16);
assert.strictEqual(info.keyLength, 16);
assert.strictEqual(info.mode, 'cbc');

[null, undefined, [], {}].forEach((arg) => {
  assert.throws(() => getCipherInfo(arg), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

[null, '', 1, true].forEach((options) => {
  assert.throws(
    () => getCipherInfo('aes-192-cbc', options), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
});

[null, '', {}, [], true].forEach((len) => {
  assert.throws(
    () => getCipherInfo('aes-192-cbc', { keyLength: len }), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  assert.throws(
    () => getCipherInfo('aes-192-cbc', { ivLength: len }), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
});

assert(!getCipherInfo('aes-128-cbc', { keyLength: 12 }));
assert(getCipherInfo('aes-128-cbc', { keyLength: 16 }));
assert(!getCipherInfo('aes-128-cbc', { ivLength: 12 }));
assert(getCipherInfo('aes-128-cbc', { ivLength: 16 }));

assert(!getCipherInfo('aes-128-ccm', { ivLength: 1 }));
assert(!getCipherInfo('aes-128-ccm', { ivLength: 14 }));
for (let n = 7; n <= 13; n++)
  assert(getCipherInfo('aes-128-ccm', { ivLength: n }));

assert(!getCipherInfo('aes-128-ocb', { ivLength: 16 }));
for (let n = 1; n < 16; n++)
  assert(getCipherInfo('aes-128-ocb', { ivLength: n }));

```"
"```javascript:test\fs\test-fs-promises-file-handle-close-errors.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
// Flags: --expose-internals

import common from '../common';
import tmpdir from '../common/tmpdir';

// The following tests validate aggregate errors are thrown correctly
// when both an operation and close throw.

import path from 'path';
import {
  readFile,
  writeFile,
  truncate,
  lchmod,
} from 'fs/promises';

import { FileHandle } from 'fs';

import assert from 'assert';
const originalFd = Object.getOwnPropertyDescriptor(FileHandle.prototype, 'fd');

let count = 0;
async function createFile() {
  const filePath = path.join(tmpdir.path, `close_errors_${++count}.txt`);
  await writeFile(filePath, 'content');
  return filePath;
}

async function checkCloseError(op) {
  try {
    const filePath = await createFile();
    Object.defineProperty(FileHandle.prototype, 'fd', {
      get: function() {
        // Close is set by using a setter,
        // so it needs to be set on the instance.
        const originalClose = this.close;
        this.close = async () => {
          // close the file
          await originalClose.call(this);
          const closeError = new Error('CLOSE_ERROR');
          closeError.code = 456;
          throw closeError;
        };
        return originalFd.get.call(this);
      }
    });

    await assert.rejects(op(filePath), {
      name: 'Error',
      message: 'CLOSE_ERROR',
      code: 456,
    });
  } finally {
    Object.defineProperty(FileHandle.prototype, 'fd', originalFd);
  }
}
(async function() {
  tmpdir.refresh();
  await checkCloseError((filePath) => truncate(filePath));
  await checkCloseError((filePath) => readFile(filePath));
  await checkCloseError((filePath) => writeFile(filePath, '123'));
  if (common.isOSX) {
    await checkCloseError((filePath) => lchmod(filePath, 0o777));
  }
})().then(common.mustCall());

```"
"```javascript:test\path\test-path-basename.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

const __filename = args[0];

assert.strictEqual(path.basename(__filename), 'test-path-basename.js');
assert.strictEqual(path.basename(__filename, '.js'), 'test-path-basename');
assert.strictEqual(path.basename('.js', '.js'), '');
assert.strictEqual(path.basename(''), '');
assert.strictEqual(path.basename('/dir/basename.ext'), 'basename.ext');
assert.strictEqual(path.basename('/basename.ext'), 'basename.ext');
assert.strictEqual(path.basename('basename.ext'), 'basename.ext');
assert.strictEqual(path.basename('basename.ext/'), 'basename.ext');
assert.strictEqual(path.basename('basename.ext//'), 'basename.ext');
assert.strictEqual(path.basename('aaa/bbb', '/bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb', 'a/bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb', 'bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb//', 'bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb', 'bb'), 'b');
assert.strictEqual(path.basename('aaa/bbb', 'b'), 'bb');
assert.strictEqual(path.basename('/aaa/bbb', '/bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb', 'a/bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb', 'bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb//', 'bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb', 'bb'), 'b');
assert.strictEqual(path.basename('/aaa/bbb', 'b'), 'bb');
assert.strictEqual(path.basename('/aaa/bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/'), 'aaa');
assert.strictEqual(path.basename('/aaa/b'), 'b');
assert.strictEqual(path.basename('/a/b'), 'b');
assert.strictEqual(path.basename('//a'), 'a');
assert.strictEqual(path.basename('a', 'a'), '');

// On Windows a backslash acts as a path separator.
/*
assert.strictEqual(path.win32.basename('\\dir\\basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('\\basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('basename.ext\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('basename.ext\\\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('foo'), 'foo');
assert.strictEqual(path.win32.basename('aaa\\bbb', '\\bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'a\\bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb\\\\\\\\', 'bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'bb'), 'b');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'b'), 'bb');
assert.strictEqual(path.win32.basename('C:'), '');
assert.strictEqual(path.win32.basename('C:.'), '.');
assert.strictEqual(path.win32.basename('C:\\'), '');
assert.strictEqual(path.win32.basename('C:\\dir\\base.ext'), 'base.ext');
assert.strictEqual(path.win32.basename('C:\\basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:basename.ext\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:basename.ext\\\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:foo'), 'foo');
assert.strictEqual(path.win32.basename('file:stream'), 'file:stream');
assert.strictEqual(path.win32.basename('a', 'a'), '');
*/
// On unix a backslash is just treated as any other character.
assert.strictEqual(path.posix.basename('\\dir\\basename.ext'),
                   '\\dir\\basename.ext');
assert.strictEqual(path.posix.basename('\\basename.ext'), '\\basename.ext');
assert.strictEqual(path.posix.basename('basename.ext'), 'basename.ext');
assert.strictEqual(path.posix.basename('basename.ext\\'), 'basename.ext\\');
assert.strictEqual(path.posix.basename('basename.ext\\\\'), 'basename.ext\\\\');
assert.strictEqual(path.posix.basename('foo'), 'foo');

// POSIX filenames may include control characters
// c.f. http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html
const controlCharFilename = `Icon${String.fromCharCode(13)}`;
assert.strictEqual(path.posix.basename(`/a/b/${controlCharFilename}`),
                   controlCharFilename);

```"
"```javascript:test\fs\test-fs-read-stream-concurrent-reads.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';

// Test that concurrent file read streams don���t interfere with each other���s
// contents, and that the chunks generated by the reads only retain a
// 'reasonable' amount of memory.

// Refs: https://github.com/nodejs/node/issues/21967

const filename = fixtures.path('loop.js');  // Some small non-homogeneous file.
const content = fs.readFileSync(filename);

const N = 2000;
let started = 0;
let done = 0;

const arrayBuffers = new Set();

function startRead() {
  ++started;
  const chunks = [];
  fs.createReadStream(filename)
    .on('data', (chunk) => {
      chunks.push(chunk);
      arrayBuffers.add(chunk.buffer);
    })
    .on('end', common.mustCall(() => {
      if (started < N)
        startRead();
      assert.deepStrictEqual(Buffer.concat(chunks), content);
      if (++done === N) {
        const retainedMemory =
          [...arrayBuffers].map((ab) => ab.byteLength).reduce((a, b) => a + b);
        assert(retainedMemory / (N * content.length) <= 3,
               `Retaining ${retainedMemory} bytes in ABs for ${N} ` +
               `chunks of size ${content.length}`);
      }
    }));
}

// Don���t start the reads all at once ��� that way we would have to allocate
// a large amount of memory upfront.
for (let i = 0; i < 6; ++i)
  startRead();

```"
"```javascript:example_js\react18_ssr\component\data.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import React,{createContext, useContext} from 'react';

// Note: this file does not demonstrate a real data fetching strategy.
// We only use this to simulate data fetching happening on the server
// while the cache is populated on the client. In a real app, you would
// instead use a data fetching library or Server Components for this.

const DataContext = createContext(null);

export function DataProvider({children, data}) {
  return <DataContext.Provider value={data}>{children}</DataContext.Provider>;
}

// In a real implementation the data would be streamed with the HTML.
// We haven't integrated this part yet, so we'll just use fake data.
const fakeData = [
  ""Wait, it doesn't wait for React to load?"",
  'How does this even work?',
  'I like marshmallows',
];

export function useData() {
  const ctx = useContext(DataContext);
  if (ctx !== null) {
    // This context is only provided on the server.
    // It is here to simulate a suspending data fetch.
    ctx.read();
  }
  return fakeData;
}

```"
"```javascript:test\path\test-path-zero-length-strings.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// These testcases are specific to one uncommon behavior in path module. Few
// of the functions in path module, treat '' strings as current working
// directory. This test makes sure that the behavior is intact between commits.
// See: https://github.com/nodejs/node/pull/2106

import assert from 'assert';
import path from 'path';
const pwd = "".""; // process.cwd();

// Join will internally ignore all the zero-length strings and it will return
// '.' if the joined string is a zero-length string.
assert.strictEqual(path.posix.join(''), '.');
assert.strictEqual(path.posix.join('', ''), '.');
// assert.strictEqual(path.win32.join(''), '.');
// assert.strictEqual(path.win32.join('', ''), '.');
assert.strictEqual(path.join(pwd), pwd);
assert.strictEqual(path.join(pwd, ''), pwd);

// Normalize will return '.' if the input is a zero-length string
assert.strictEqual(path.posix.normalize(''), '.');
// assert.strictEqual(path.win32.normalize(''), '.');
assert.strictEqual(path.normalize(pwd), pwd);

// Since '' is not a valid path in any of the common environments, return false
assert.strictEqual(path.posix.isAbsolute(''), false);
// assert.strictEqual(path.win32.isAbsolute(''), false);

// Resolve, internally ignores all the zero-length strings and returns the
// current working directory
assert.strictEqual(path.resolve(''), pwd);
assert.strictEqual(path.resolve('', ''), pwd);

// Relative, internally calls resolve. So, '' is actually the current directory
assert.strictEqual(path.relative('', pwd), '');
assert.strictEqual(path.relative(pwd, ''), '');
assert.strictEqual(path.relative(pwd, pwd), '');

```"
"```javascript:modules\stream\consumers.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import { Buffer } from ""buffer"";

/**
 * @typedef {import('../_global.d.ts').ReadableStream
 * } ReadableStream
 * @typedef {import('../_stream.d.ts')} Readable
 */


/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<ArrayBuffer>}
 */
async function arrayBuffer(stream) {
    const ret = await blob(stream);
    return ret.arrayBuffer();
}

/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<Buffer>}
 */
async function buffer(stream) {
    return Buffer.from(await arrayBuffer(stream));
}

/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<string>}
 */
async function text(stream) {
    const dec = new TextDecoder();
    let str = """";
    for await (const chunk of stream) {
        if (typeof chunk === ""string"") {
            str += chunk;
        } else {
            str += dec.decode(chunk, { stream: true });
        }
    }
    // Flush the streaming TextDecoder so that any pending
    // incomplete multibyte characters are handled.
    str += dec.decode(undefined, { stream: false });
    return str;
}

/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<any>}
 */
async function json(stream) {
    const str = await text(stream);
    return JSON.parse(str);
}

export default {
    arrayBuffer,
    buffer,
    json,
    text,
};
export { arrayBuffer, buffer, json, text };
```"
"```javascript:test\fs\test-fs-watch-enoent.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

// This verifies the error thrown by fs.watch.

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import assert from 'assert';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
import path from 'path';
const nonexistentFile = path.join(tmpdir.path, 'non-existent');
import { internalBinding } from 'internal/test/binding';
const {
  UV_ENODEV,
  UV_ENOENT
} = internalBinding('uv');

tmpdir.refresh();

{
  const validateError = (err) => {
    assert.strictEqual(err.path, nonexistentFile);
    assert.strictEqual(err.filename, nonexistentFile);
    assert.strictEqual(err.syscall, 'watch');
    if (err.code === 'ENOENT') {
      assert.strictEqual(
        err.message,
        `ENOENT: no such file or directory, watch '${nonexistentFile}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
    } else {  // AIX
      assert.strictEqual(
        err.message,
        `ENODEV: no such device, watch '${nonexistentFile}'`);
      assert.strictEqual(err.errno, UV_ENODEV);
      assert.strictEqual(err.code, 'ENODEV');
    }
    return true;
  };

  assert.throws(
    () => fs.watch(nonexistentFile, common.mustNotCall()),
    validateError
  );
}

{
  const file = path.join(tmpdir.path, 'file-to-watch');
  fs.writeFileSync(file, 'test');
  const watcher = fs.watch(file, common.mustNotCall());

  const validateError = (err) => {
    assert.strictEqual(err.path, nonexistentFile);
    assert.strictEqual(err.filename, nonexistentFile);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, watch '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'watch');
    fs.unlinkSync(file);
    return true;
  };

  watcher.on('error', common.mustCall(validateError));

  // Simulate the invocation from the binding
  watcher._handle.onchange(UV_ENOENT, 'ENOENT', nonexistentFile);
}

```"
"```javascript:test\fs\test-fs-promises-file-handle-close.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-gc --no-warnings
'use strict';

// Test that a runtime warning is emitted when a FileHandle object
// is allowed to close on garbage collection. In the future, this
// test should verify that closing on garbage collection throws a
// process fatal exception.

import common from '../common';
import assert from 'assert';
import fs from 'fs/promises';

const warning =
  'Closing a FileHandle object on garbage collection is deprecated. ' +
  'Please close FileHandle objects explicitly using ' +
  'FileHandle.prototype.close(). In the future, an error will be ' +
  'thrown if a file descriptor is closed during garbage collection.';

async function doOpen() {
  const fh = await fs.open(__filename);

  common.expectWarning({
    Warning: [[`Closing file descriptor ${fh.fd} on garbage collection`]],
    DeprecationWarning: [[warning, 'DEP0137']]
  });

  return fh;
}

doOpen().then(common.mustCall((fd) => {
  assert.strictEqual(typeof fd, 'object');
})).then(common.mustCall(() => {
  setImmediate(() => {
    // The FileHandle should be out-of-scope and no longer accessed now.
    global.gc();

    // Wait an extra event loop turn, as the warning is emitted from the
    // native layer in an unref()'ed setImmediate() callback.
    setImmediate(common.mustCall());
  });
}));

```"
"```javascript:test\fs\test-fs-copyfile-respect-permissions.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Test that fs.copyFile() respects file permissions.
// Ref: https://github.com/nodejs/node/issues/26936

import common from '../common';

if (!common.isWindows && process.getuid() === 0)
  common.skip('as this test should not be run as `root`');

if (common.isIBMi)
  common.skip('IBMi has a different access permission mechanism');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

import assert from 'assert';
import fs from 'fs';
import path from 'path';

let n = 0;

function beforeEach() {
  n++;
  const source = path.join(tmpdir.path, `source${n}`);
  const dest = path.join(tmpdir.path, `dest${n}`);
  fs.writeFileSync(source, 'source');
  fs.writeFileSync(dest, 'dest');
  fs.chmodSync(dest, '444');

  const check = (err) => {
    const expected = ['EACCES', 'EPERM'];
    assert(expected.includes(err.code), `${err.code} not in ${expected}`);
    assert.strictEqual(fs.readFileSync(dest, 'utf8'), 'dest');
    return true;
  };

  return { source, dest, check };
}

// Test synchronous API.
{
  const { source, dest, check } = beforeEach();
  assert.throws(() => { fs.copyFileSync(source, dest); }, check);
}

// Test promises API.
{
  const { source, dest, check } = beforeEach();
  (async () => {
    await assert.rejects(fs.promises.copyFile(source, dest), check);
  })().then(common.mustCall());
}

// Test callback API.
{
  const { source, dest, check } = beforeEach();
  fs.copyFile(source, dest, common.mustCall(check));
}

```"
"```javascript:example_js\react18_ssr\component\App.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import React,{ Suspense, lazy } from ""react"";
import { ErrorBoundary } from ""react-error-boundary"";
import Html from ""./Html.js"";
import Spinner from ""./Spinner.js"";
import Layout from ""./Layout.js"";
import NavBar from ""./NavBar.js"";

const Comments = lazy(() => import(""./Comments.js"" /* webpackPrefetch: true */));
const Sidebar = lazy(() => import(""./Sidebar.js"" /* webpackPrefetch: true */));
const Post = lazy(() => import(""./Post.js"" /* webpackPrefetch: true */));

export default function App({ assets }) {
  return (
    <Html assets={assets} title=""Hello"">
      <Suspense fallback={<Spinner />}>
        <ErrorBoundary FallbackComponent={Error}>
          <Content />
        </ErrorBoundary>
      </Suspense>
    </Html>
  );
}

function Content() {
  return (
    <Layout>
      <NavBar />
      <aside className=""sidebar"">
        <Suspense fallback={<Spinner />}>
          <Sidebar />
        </Suspense>
      </aside>
      <article className=""post"">
        <Suspense fallback={<Spinner />}>
          <Post />
        </Suspense>
        <section className=""comments"">
          <h2>Comments</h2>
          <Suspense fallback={<Spinner />}>
            <Comments />
          </Suspense>
        </section>
        <h2>Thanks for reading!</h2>
      </article>
    </Layout>
  );
}

function Error({ error }) {
  return (
    <div>
      <h1>Application Error</h1>
      <pre style={{ whiteSpace: ""pre-wrap"" }}>{error.stack}</pre>
    </div>
  );
}

```"
"```javascript:test\fs\test-fs-options-immutable.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// These tests make sure that the `options` object passed to these functions are
// never altered.
//
// Refer: https://github.com/nodejs/node/issues/7655

import fs from 'fs';
import path from 'path';

const options = common.mustNotMutateObjectDeep({});
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const __filename = args[0];

fs.readFile(__filename, options, common.mustSucceed());
fs.readFileSync(__filename, options);

fs.readdir(""./"", options, common.mustSucceed());
fs.readdirSync(""./"", options);

if (false /*common.canCreateSymLink()*/) {
  const sourceFile = path.resolve(tmpdir.path, 'test-readlink');
  const linkFile = path.resolve(tmpdir.path, 'test-readlink-link');

  fs.writeFileSync(sourceFile, '');
  fs.symlinkSync(sourceFile, linkFile);

  fs.readlink(linkFile, options, common.mustSucceed());
  fs.readlinkSync(linkFile, options);
}

{
  const fileName = path.resolve(tmpdir.path, 'writeFile');
  fs.writeFileSync(fileName, 'ABCD', options);
  fs.writeFile(fileName, 'ABCD', options, common.mustSucceed());
}

{
  const fileName = path.resolve(tmpdir.path, 'appendFile');
  fs.appendFileSync(fileName, 'ABCD', options);
  fs.appendFile(fileName, 'ABCD', options, common.mustSucceed());
}

/*if (!common.isIBMi) { // IBMi does not support fs.watch()
  const watch = fs.watch(__filename, options, common.mustNotCall());
  watch.close();
}*/

/*{
  fs.watchFile(__filename, options, common.mustNotCall());
  fs.unwatchFile(__filename);
}*/

/*{
  fs.realpathSync(__filename, options);
  fs.realpath(__filename, options, common.mustSucceed());
}*/

{
  const tempFileName = path.resolve(tmpdir.path, 'mkdtemp-');
  fs.mkdtempSync(tempFileName, options);
  fs.mkdtemp(tempFileName, options, common.mustSucceed());
}

{
  const fileName = path.resolve(tmpdir.path, 'streams');
  fs.WriteStream(fileName, options).once('open', common.mustCall(() => {
    fs.ReadStream(fileName, options).destroy();
  })).end();
}

```"
"```javascript:test\fs\test-fs-promises-file-handle-op-errors.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
// Flags: --expose-internals

import common from '../common';
import tmpdir from '../common/tmpdir';

// The following tests validate aggregate errors are thrown correctly
// when both an operation and close throw.

import path from 'path';
import {
  readFile,
  writeFile,
  truncate,
  lchmod,
} from 'fs/promises';
import {
  FileHandle,
} from 'fs';

import assert from 'assert';
const originalFd = Object.getOwnPropertyDescriptor(FileHandle.prototype, 'fd');

let count = 0;
async function createFile() {
  const filePath = path.join(tmpdir.path, `op_errors_${++count}.txt`);
  await writeFile(filePath, 'content');
  return filePath;
}

async function checkOperationError(op) {
  try {
    const filePath = await createFile();
    Object.defineProperty(FileHandle.prototype, 'fd', {
      get: function() {
        // Verify that close is called when an error is thrown
        this.close = common.mustCall(this.close);
        const opError = new Error('INTERNAL_ERROR');
        opError.code = 123;
        throw opError;
      }
    });

    await assert.rejects(op(filePath), {
      name: 'Error',
      message: 'INTERNAL_ERROR',
      code: 123,
    });
  } finally {
    Object.defineProperty(FileHandle.prototype, 'fd', originalFd);
  }
}
(async function() {
  tmpdir.refresh();
  await checkOperationError((filePath) => truncate(filePath));
  await checkOperationError((filePath) => readFile(filePath));
  await checkOperationError((filePath) => writeFile(filePath, '123'));
  if (common.isOSX) {
    await checkOperationError((filePath) => lchmod(filePath, 0o777));
  }
})().then(common.mustCall());

```"
"```javascript:test\fs\test-fs-readSync-optional-params.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import { mustNotMutateObjectDeep } from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';
const filepath = fixtures.path('x.txt');

const expected = Buffer.from('xyz\n');

function runTest(defaultBuffer, options) {
  let fd;
  try {
    fd = fs.openSync(filepath, 'r');
    const result = fs.readSync(fd, defaultBuffer, options);
    assert.strictEqual(result, expected.length);
    assert.deepStrictEqual(defaultBuffer, expected);
  } finally {
    if (fd != null) fs.closeSync(fd);
  }
}

for (const options of [

  // Test options object
  { offset: 0 },
  { length: expected.length },
  { position: 0 },
  { offset: 0, length: expected.length },
  { offset: 0, position: 0 },
  { length: expected.length, position: 0 },
  { offset: 0, length: expected.length, position: 0 },

  { offset: null },
  { position: null },
  { position: -1 },
  { position: 0n },

  // Test default params
  {},
  null,
  undefined,

  // Test if bad params are interpreted as default (not mandatory)
  false,
  true,
  Infinity,
  42n,
  Symbol(),

  // Test even more malicious corner cases
  '4'.repeat(expected.length),
  new String('4444'),
  [4, 4, 4, 4],
]) {
  runTest(Buffer.allocUnsafe(expected.length), mustNotMutateObjectDeep(options));
}

```"
"```javascript:test\fs\test-fs-assert-encoding-error.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const options = 'test';
const expectedError = {
  code: 'ERR_INVALID_ARG_VALUE',
  name: 'TypeError',
};

assert.throws(() => {
  fs.readFile('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.readFileSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.readdir('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.readdirSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.readlink('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.readlinkSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.writeFile('path', 'data', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.writeFileSync('path', 'data', options);
}, expectedError);

assert.throws(() => {
  fs.appendFile('path', 'data', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.appendFileSync('path', 'data', options);
}, expectedError);

// unsupport watch
/*
assert.throws(() => {
  fs.watch('path', options, common.mustNotCall());
}, expectedError);
*/

assert.throws(() => {
  fs.realpath('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.realpathSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.mkdtemp('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.mkdtempSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.createReadStream('path', options);
}, expectedError);

assert.throws(() => {
  fs.createWriteStream('path', options);
}, expectedError);

```"
"```javascript:test\fs\test-fs-readfile-flags.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Test of fs.readFile with different flags.
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

{
  const emptyFile = path.join(tmpdir.path, 'empty.txt');
  fs.closeSync(fs.openSync(emptyFile, 'w'));

  fs.readFile(
    emptyFile,
    // With `a+` the file is created if it does not exist
    common.mustNotMutateObjectDeep({ encoding: 'utf8', flag: 'a+' }),
    common.mustCall((err, data) => { assert.strictEqual(data, ''); })
  );

  fs.readFile(
    emptyFile,
    // Like `a+` but fails if the path exists.
    common.mustNotMutateObjectDeep({ encoding: 'utf8', flag: 'ax+' }),
    common.mustCall((err, data) => { assert.strictEqual(err.code, 'EEXIST'); })
  );
}

{
  const willBeCreated = path.join(tmpdir.path, 'will-be-created');

  fs.readFile(
    willBeCreated,
    // With `a+` the file is created if it does not exist
    common.mustNotMutateObjectDeep({ encoding: 'utf8', flag: 'a+' }),
    common.mustCall((err, data) => { assert.strictEqual(data, ''); })
  );
}

{
  const willNotBeCreated = path.join(tmpdir.path, 'will-not-be-created');

  fs.readFile(
    willNotBeCreated,
    // Default flag is `r`. An exception occurs if the file does not exist.
    common.mustNotMutateObjectDeep({ encoding: 'utf8' }),
    common.mustCall((err, data) => { assert.strictEqual(err.code, 'ENOENT'); })
  );
}

```"
"```javascript:test\fs\test-fs-write-stream-autoclose-option.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const file = path.join(tmpdir.path, 'write-autoclose-opt1.txt');
tmpdir.refresh();
let stream = fs.createWriteStream(file, { flags: 'w+', autoClose: false });
stream.write('Test1');
stream.end();
stream.on('finish', common.mustCall(function() {
  stream.on('close', common.mustNotCall());
  process.nextTick(common.mustCall(function() {
    assert.strictEqual(stream.closed, false);
    assert.notStrictEqual(stream.fd, null);
    next();
  }));
}));

function next() {
  // This will tell us if the fd is usable again or not
  stream = fs.createWriteStream(null, { fd: stream.fd, start: 0 });
  stream.write('Test2');
  stream.end();
  stream.on('finish', common.mustCall(function() {
    assert.strictEqual(stream.closed, false);
    stream.on('close', common.mustCall(function() {
      assert.strictEqual(stream.fd, null);
      assert.strictEqual(stream.closed, true);
      process.nextTick(next2);
    }));
  }));
}

function next2() {
  // This will test if after reusing the fd data is written properly
  fs.readFile(file, function(err, data) {
    assert.ifError(err);
    assert.strictEqual(data.toString(), 'Test2');
    process.nextTick(common.mustCall(next3));
  });
}

function next3() {
  // This is to test success scenario where autoClose is true
  const stream = fs.createWriteStream(file, { autoClose: true });
  stream.write('Test3');
  stream.end();
  stream.on('finish', common.mustCall(function() {
    assert.strictEqual(stream.closed, false);
    stream.on('close', common.mustCall(function() {
      assert.strictEqual(stream.fd, null);
      assert.strictEqual(stream.closed, true);
    }));
  }));
}

```"
"```javascript:modules\internal\streams\add-abort-signal.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { AbortError, ERR_INVALID_ARG_TYPE } from ""../errors.js"";
import eos from ""./end-of-stream.js"";

// This method is inlined here for readable-stream
// It also does not allow for signal to not exist on the stream
// https://github.com/nodejs/node/pull/36061#discussion_r533718029
const validateAbortSignal = (signal, name) => {
    if (
        typeof signal !== ""object"" ||
        !(""aborted"" in signal)
    ) {
        throw new ERR_INVALID_ARG_TYPE(name, ""AbortSignal"", signal);
    }
};

function isStream(obj) {
    return !!(obj && typeof obj.pipe === ""function"");
}

function addAbortSignal(signal, stream) {
    validateAbortSignal(signal, ""signal"");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE(""stream"", ""stream.Stream"", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== ""object"" || !(""aborted"" in signal)) {
        return stream;
    }
    const onAbort = () => {
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener(""abort"", onAbort);
        eos(stream, () => signal.removeEventListener(""abort"", onAbort));
    }
    return stream;
}

export default { addAbortSignal, addAbortSignalNoValidate };
export { addAbortSignal, addAbortSignalNoValidate };
```"
"```javascript:test\crypto\test-crypto-randomuuid.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import {
  randomUUID,
} from 'crypto';

const last = new Set([
  '00000000-0000-0000-0000-000000000000',
]);

function testMatch(uuid) {
  assert.match(
    uuid,
    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/);
}

// Generate a number of UUID's to make sure we're
// not just generating the same value over and over
// and to make sure the batching changes the random
// bytes.
for (let n = 0; n < 130; n++) {
  const uuid = randomUUID();
  assert(!last.has(uuid));
  last.add(uuid);
  assert.strictEqual(typeof uuid, 'string');
  assert.strictEqual(uuid.length, 36);
  testMatch(uuid);

  // Check that version 4 identifier was populated.
  assert.strictEqual(
    Buffer.from(uuid.substr(14, 2), 'hex')[0] & 0x40, 0x40);

  // Check that clock_seq_hi_and_reserved was populated with reserved bits.
  assert.strictEqual(
    Buffer.from(uuid.substr(19, 2), 'hex')[0] & 0b1100_0000, 0b1000_0000);
}

// Test non-buffered UUID's
{
  testMatch(randomUUID({ disableEntropyCache: true }));
  testMatch(randomUUID({ disableEntropyCache: true }));
  testMatch(randomUUID({ disableEntropyCache: true }));
  testMatch(randomUUID({ disableEntropyCache: true }));

  assert.throws(() => randomUUID(1), {
    code: 'ERR_INVALID_ARG_TYPE'
  });

  assert.throws(() => randomUUID({ disableEntropyCache: '' }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
}

```"
"```javascript:modules\internal\crypto\certificate.js
'use strict';

const {
  certExportChallenge,
  certExportPublicKey,
  certVerifySpkac,
} = internalBinding('crypto');

const {
  getArrayBufferOrView,
} = require('internal/crypto/util');

// The functions contained in this file cover the SPKAC format
// (also referred to as Netscape SPKI). A general description of
// the format can be found at https://en.wikipedia.org/wiki/SPKAC

function verifySpkac(spkac, encoding) {
  return certVerifySpkac(
    getArrayBufferOrView(spkac, 'spkac', encoding));
}

function exportPublicKey(spkac, encoding) {
  return certExportPublicKey(
    getArrayBufferOrView(spkac, 'spkac', encoding));
}

function exportChallenge(spkac, encoding) {
  return certExportChallenge(
    getArrayBufferOrView(spkac, 'spkac', encoding));
}

// The legacy implementation of this exposed the Certificate
// object and required that users create an instance before
// calling the member methods. This API pattern has been
// deprecated, however, as the method implementations do not
// rely on any object state.

// For backwards compatibility reasons, this cannot be converted into a
// ES6 Class.
function Certificate() {
  if (!(this instanceof Certificate))
    return new Certificate();
}

Certificate.prototype.verifySpkac = verifySpkac;
Certificate.prototype.exportPublicKey = exportPublicKey;
Certificate.prototype.exportChallenge = exportChallenge;

Certificate.exportChallenge = exportChallenge;
Certificate.exportPublicKey = exportPublicKey;
Certificate.verifySpkac = verifySpkac;

module.exports = Certificate;

```"
"```javascript:test\fs\test-fs-symlink-dir.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Test creating a symbolic link pointing to a directory.
// Ref: https://github.com/nodejs/node/pull/23724
// Ref: https://github.com/nodejs/node/issues/23596


if (!common.canCreateSymLink())
  common.skip('insufficient privileges');

import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const linkTargets = [
  'relative-target',
  // path.join(tmpdir.path, 'absolute-target'),
];
const linkPaths = [
  // path.relative(""./"", path.join(tmpdir.path, 'relative-path')),
  path.join(tmpdir.path, 'relative-path')
  // path.join(tmpdir.path, 'absolute-path'),
];

function testSync(target, path) {
  fs.symlinkSync(target, path);
  fs.readdirSync(path);
}

function testAsync(target, path) {
  fs.symlink(target, path, common.mustSucceed(() => {
    fs.readdirSync(path);
  }));
}

for (const linkTarget of linkTargets) {
  fs.mkdirSync(path.resolve(tmpdir.path, linkTarget));
  for (const linkPath of linkPaths) {
    testSync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-sync`);
    testAsync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-async`);
  }
}

// Test invalid symlink
{
  function testSync(target, path) {
    fs.symlinkSync(target, path);
    assert(!fs.existsSync(path));
  }

  function testAsync(target, path) {
    fs.symlink(target, path, common.mustSucceed(() => {
      assert(!fs.existsSync(path));
    }));
  }

  for (const linkTarget of linkTargets.map((p) => p + '-broken')) {
    for (const linkPath of linkPaths) {
      testSync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-sync`);
      testAsync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-async`);
    }
  }
}

```"
"```javascript:modules\internal\url.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
import { fileURLToPath } from ""../url"";
import { Buffer } from ""../buffer"";
import { URL } from ""../url"";

const searchParams = Symbol(""query"");

/**
 * @param {string | Buffer | URL} fileURLOrPath
 * @return {string | Buffer}
 */
export function toPathIfFileURL(
    fileURLOrPath,
) {
    if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
    }
    return fileURLToPath(fileURLOrPath);
}

// Utility function that converts a URL object into an ordinary
// options object as expected by the http.request and https.request
// APIs.
// deno-lint-ignore no-explicit-any
export function urlToHttpOptions(url) {
    // deno-lint-ignore no-explicit-any
    const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === ""string"" &&
            url.hostname.startsWith(""["")
            ? url.hostname.slice(1, -1)
            : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname || """"}${url.search || """"}`,
        href: url.href,
    };
    if (url.port !== """") {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)
            }`;
    }
    return options;
}

export { searchParams as searchParamsSymbol };

export default {
    toPathIfFileURL,
};
```"
"```javascript:test\fs\test-fs-filehandle.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-gc --no-warnings --expose-internals
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import { internalBinding } from 'internal/test/binding';
const fs = internalBinding('fs');
import { stringToFlags } from 'internal/fs/utils';

// Verifies that the FileHandle object is garbage collected and that a
// warning is emitted if it is not closed.

let fdnum;
{
  const ctx = {};
  fdnum = fs.openFileHandle(path.toNamespacedPath(__filename),
                            stringToFlags('r'), 0o666, undefined, ctx).fd;
  assert.strictEqual(ctx.errno, undefined);
}

const deprecationWarning =
  'Closing a FileHandle object on garbage collection is deprecated. ' +
  'Please close FileHandle objects explicitly using ' +
  'FileHandle.prototype.close(). In the future, an error will be ' +
  'thrown if a file descriptor is closed during garbage collection.';

common.expectWarning({
  'internal/test/binding': [
    'These APIs are for internal testing only. Do not use them.',
  ],
  'Warning': [
    `Closing file descriptor ${fdnum} on garbage collection`,
  ],
  'DeprecationWarning': [[deprecationWarning, 'DEP0137']]
});

global.gc();

setTimeout(() => {}, 10);

```"
"```javascript:test\fs\test-fs-stream-construct-compat-graceful-fs.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat with graceful-fs.

  function ReadStream(...args) {
    fs.ReadStream.call(this, ...args);
  }
  Object.setPrototypeOf(ReadStream.prototype, fs.ReadStream.prototype);
  Object.setPrototypeOf(ReadStream, fs.ReadStream);

  ReadStream.prototype.open = common.mustCall(function ReadStream$open() {
    const that = this;
    fs.open(that.path, that.flags, that.mode, (err, fd) => {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  });

  const r = new ReadStream(fixtures.path('x.txt'))
    .on('open', common.mustCall((fd) => {
      assert.strictEqual(fd, r.fd);
      r.destroy();
    }));
}

{
  // Compat with graceful-fs.

  function WriteStream(...args) {
    fs.WriteStream.call(this, ...args);
  }
  Object.setPrototypeOf(WriteStream.prototype, fs.WriteStream.prototype);
  Object.setPrototypeOf(WriteStream, fs.WriteStream);

  WriteStream.prototype.open = common.mustCall(function WriteStream$open() {
    const that = this;
    fs.open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  });

  const w = new WriteStream(`${tmpdir.path}/dummy`)
    .on('open', common.mustCall((fd) => {
      assert.strictEqual(fd, w.fd);
      w.destroy();
    }));
}

```"
"```javascript:test\fs\test-fs-promises-file-handle-chmod.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.chmod method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateFilePermission() {
  const filePath = path.resolve(tmpDir, 'tmp-chmod.txt');
  const fileHandle = await open(filePath, 'w+', 0o444);
  // File created with r--r--r-- 444
  const statsBeforeMod = fs.statSync(filePath);
  assert.strictEqual(statsBeforeMod.mode & 0o444, 0o444);

  let expectedAccess;
  const newPermissions = 0o765;

  if (common.isWindows) {
    // Chmod in Windows will only toggle read only/write access. The
    // fs.Stats.mode in Windows is computed using read/write
    // bits (not exec). Read-only at best returns 444; r/w 666.
    // Refer: /deps/uv/src/win/fs.cfs;
    expectedAccess = 0o664;
  } else {
    expectedAccess = newPermissions;
  }

  // Change the permissions to rwxr--r-x
  await fileHandle.chmod(newPermissions);
  const statsAfterMod = fs.statSync(filePath);
  assert.deepStrictEqual(statsAfterMod.mode & expectedAccess, expectedAccess);

  await fileHandle.close();
}

validateFilePermission().then(common.mustCall());

```"
"```javascript:example_js\wasi_net_echo.js
import * as net from 'wasi_net';
import { TextDecoder } from 'util'
import { nextTick, exit } from 'process';

async function handle_client(cs) {
  print('server accept:', cs.peer());
  try {
    while (true) {
      let d = await cs.read();
      if (d == undefined || d.byteLength <= 0) {
        break;
      }
      let s = new TextDecoder().decode(d);
      print('server recv:', s);
      cs.write('echo:' + s);
    }
  } catch (e) {
    print('server handle_client error:', e);
  }
  print('server: conn close');
}

async function server_start() {
  print('listen 8000 ...');
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i < 100; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print('server accept error:', e)
  }
}

server_start();

async function connect_test() {
  try {
    let ss = await net.WasiTcpConn.connect('127.0.0.1', 8000)
    ss.write('hello');
    let msg = await ss.read() || """";
    print('client recv:', new TextDecoder().decode(msg));
  } catch (e) {
    print('client catch:', e);
  } finally {
    nextTick(() => {
      exit(0)
    })
  }
}

connect_test();

```"
"```javascript:test\fs\test-fs-promises-file-handle-read-worker.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'read_stream_filehandle_worker.txt');
const input = 'hello world';
import { Worker, isMainThread, workerData } from 'worker_threads';

if (isMainThread || !workerData) {
  tmpdir.refresh();
  fs.writeFileSync(file, input);

  fs.promises.open(file, 'r').then((handle) => {
    handle.on('close', common.mustNotCall());
    new Worker(__filename, {
      workerData: { handle },
      transferList: [handle]
    });
  });
  fs.promises.open(file, 'r').then(async (handle) => {
    try {
      fs.createReadStream(null, { fd: handle });
      assert.throws(() => {
        new Worker(__filename, {
          workerData: { handle },
          transferList: [handle]
        });
      }, {
        code: 25,
        name: 'DataCloneError',
      });
    } finally {
      await handle.close();
    }
  });
} else {
  let output = '';

  const handle = workerData.handle;
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });

  stream.on('data', common.mustCallAtLeast((data) => {
    output += data;
  }));

  stream.on('end', common.mustCall(() => {
    handle.close();
    assert.strictEqual(output, input);
  }));

  stream.on('close', common.mustCall());
}

```"
"```javascript:test\fs\test-fs-watch-recursive.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';


import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const testDir = tmpdir.path;
const filenameOne = 'watch.txt';

tmpdir.refresh();

const testsubdir = fs.mkdtempSync(testDir + path.sep);
const relativePathOne = path.join(path.basename(testsubdir), filenameOne);
const filepathOne = path.join(testsubdir, filenameOne);

if (!common.isOSX && !common.isWindows) {
  assert.throws(() => { fs.watch(testDir, { recursive: true }); },
                { code: 'ERR_FEATURE_UNAVAILABLE_ON_PLATFORM' });
  return;
}
const watcher = fs.watch(testDir, { recursive: true });

let watcherClosed = false;
watcher.on('change', function(event, filename) {
  assert.ok(event === 'change' || event === 'rename');

  // Ignore stale events generated by mkdir and other tests
  if (filename !== relativePathOne)
    return;

  if (common.isOSX) {
    clearInterval(interval);
  }
  watcher.close();
  watcherClosed = true;
});

let interval;
if (common.isOSX) {
  interval = setInterval(function() {
    fs.writeFileSync(filepathOne, 'world');
  }, 10);
} else {
  fs.writeFileSync(filepathOne, 'world');
}

process.on('exit', function() {
  assert(watcherClosed, 'watcher Object was not closed');
});

```"
"```javascript:example_js\ggml_chat.js
import { GGMLChatCompletionRequest, GGMLChatPrompt } from '_wasi_nn_ggml_template'
import { build_graph_from_cache } from '_wasi_nn_ggml'
function main() {
    let opt = {
        ""enable-log"": true,
        ""ctx_size"": 512,
        ""n-predict"": 1024,
        ""n-gpu-layers"": 100,
        ""batch-size"": 512,
        ""temp"": 0.8,
        ""repeat-penalty"": 1.1
    }

    let graph = build_graph_from_cache(3, JSON.stringify(opt), ""default"")
    let context = graph.init_execution_context()

    let template = new GGMLChatPrompt('llama-2-chat')

    let req = new GGMLChatCompletionRequest()

    let messages = ['hello', 'who are you?']

    for (var i in messages) {
        print(""[YOU]:"", messages[i])
        req.push_message(""user"", messages[i])
        let p = template.build(req)
        context.set_input(0, p, [1], 3)
        var ss = '';

        while (1) {
            try {
                context.compute_single()
                let s = context.get_output_single(0, 1)
                ss += s;
                print('BOT:', s)
            } catch (e) {
                if (e['type'] == ""BackendError"" && e['message'] == ""EndOfSequence"") {
                    print('[log] EndOfSequence!')
                    break
                } else if (e['type'] == ""BackendError"" && e['message'] == ""ContextFull"") {
                    print('[log] ContextFull!')
                    break
                } else {
                    return
                }
            }
        }
        req.push_message(""assistant"", ss)
        print(""[BOT]:"", ss);
    }

    let p = template.build(req);
    print()
    print(p)
}

main()
```"
"```javascript:test\fs\test-fs-read-stream-fd-leak.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

require('../common');
import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

let openCount = 0;
const _fsopen = fs.open;
const _fsclose = fs.close;

const loopCount = 50;
const totalCheck = 50;
const emptyTxt = fixtures.path('empty.txt');

fs.open = function() {
  openCount++;
  return _fsopen.apply(null, arguments);
};

fs.close = function() {
  openCount--;
  return _fsclose.apply(null, arguments);
};

function testLeak(endFn, callback) {
  console.log(`testing for leaks from fs.createReadStream().${endFn}()...`);

  let i = 0;
  let check = 0;

  function checkFunction() {
    if (openCount !== 0 && check < totalCheck) {
      check++;
      setTimeout(checkFunction, 100);
      return;
    }

    assert.strictEqual(
      openCount,
      0,
      `no leaked file descriptors using ${endFn}() (got ${openCount})`
    );

    openCount = 0;
    callback && setTimeout(callback, 100);
  }

  setInterval(function() {
    const s = fs.createReadStream(emptyTxt);
    s[endFn]();

    if (++i === loopCount) {
      clearTimeout(this);
      setTimeout(checkFunction, 100);
    }
  }, 2);
}

testLeak('close', function() {
  testLeak('destroy');
});

```"
"```javascript:modules\stream\promises.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import { isIterable, isNodeStream } from ""../internal/streams/utils.js"";
import { pipelineImpl as pl } from ""../internal/streams/pipeline.js"";
import eos from ""../internal/streams/end-of-stream.js"";

function pipeline(...streams) {
    return new Promise((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (
            lastArg && typeof lastArg === ""object"" &&
            !isNodeStream(lastArg) && !isIterable(lastArg)
        ) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }

        pl(streams, (err, value) => {
            if (err) {
                reject(err);
            } else {
                resolve(value);
            }
        }, { signal, end });
    });
}

function finished(stream, opts) {
    return new Promise((resolve, reject) => {
        eos(stream, opts, (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

export default {
    finished,
    pipeline,
};
export { finished, pipeline };
```"
"```javascript:test\fs\test-fs-syncwritestream.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import { spawn } from 'child_process';
import stream from 'stream';
import fs from 'fs';
import path from 'path';

// require('internal/fs/utils').SyncWriteStream is used as a stdio
// implementation when stdout/stderr point to files.

if (process.argv[2] === 'child') {
  // Note: Calling console.log() is part of this test as it exercises the
  // SyncWriteStream#_write() code path.
  console.log(JSON.stringify([process.stdout, process.stderr].map((stdio) => ({
    instance: stdio instanceof stream.Writable,
    readable: stdio.readable,
    writable: stdio.writable,
  }))));

  return;
}

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = path.join(tmpdir.path, 'stdout');
const stdoutFd = fs.openSync(filename, 'w');

const proc = spawn(process.execPath, [__filename, 'child'], {
  stdio: ['inherit', stdoutFd, stdoutFd ]
});

proc.on('close', common.mustCall(() => {
  fs.closeSync(stdoutFd);

  assert.deepStrictEqual(JSON.parse(fs.readFileSync(filename, 'utf8')), [
    { instance: true, readable: false, writable: true },
    { instance: true, readable: false, writable: true },
  ]);
}));

```"
"```javascript:test\fs\test-fs-readfile-pipe-large.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Simulate `cat readfile.js | node readfile.js`

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';
import path from 'path';
import fs from 'fs';

if (process.argv[2] === 'child') {
  fs.readFile('/dev/stdin', function(er, data) {
    assert.ifError(er);
    process.stdout.write(data);
  });
  return;
}

import tmpdir from '../common/tmpdir';

const filename = path.join(tmpdir.path, '/readfile_pipe_large_test.txt');
const dataExpected = 'a'.repeat(999999);
tmpdir.refresh();
fs.writeFileSync(filename, dataExpected);

import { exec } from 'child_process';
const f = JSON.stringify(__filename);
const node = JSON.stringify(process.execPath);
const cmd = `cat ${filename} | ${node} ${f} child`;
exec(cmd, { maxBuffer: 1000000 }, common.mustSucceed((stdout, stderr) => {
  assert.strictEqual(
    stdout,
    dataExpected,
    `expect it reads the file and outputs 999999 'a' but got : ${stdout}`
  );
  assert.strictEqual(
    stderr,
    '',
    `expect that it does not write to stderr, but got : ${stderr}`
  );
  console.log('ok');
}));

```"
"```javascript:test\fs\test-fs-promises-writefile-with-fd.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This test makes sure that `writeFile()` always writes from the current
// position of the file, instead of truncating the file.

import common from '../common';
import assert from 'assert';
import path from 'path';
import { readFileSync } from 'fs';
import { open } from 'fs/promises';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = path.join(tmpdir.path, 'test.txt');

async function writeFileTest() {
  const handle = await open(fn, 'w');

  /* Write only five bytes, so that the position moves to five. */
  const buf = Buffer.from('Hello');
  const { bytesWritten } = await handle.write(buf, 0, 5, null);
  assert.strictEqual(bytesWritten, 5);

  /* Write some more with writeFile(). */
  await handle.writeFile('World');

  /* New content should be written at position five, instead of zero. */
  assert.strictEqual(readFileSync(fn).toString(), 'HelloWorld');

  await handle.close();
}


writeFileTest()
  .then(common.mustCall()).catch(err => print(err, err.stack));

```"
"```javascript:test\fs\test-fs-readdir.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const __filename = args[0];

const readdirDir = tmpdir.path;
const files = ['empty', 'files', 'for', 'just', 'testing'];

// Make sure tmp directory is clean
tmpdir.refresh();

// Create the necessary files
files.forEach(function(currentFile) {
  fs.closeSync(fs.openSync(`${readdirDir}/${currentFile}`, 'w'));
});

// Check the readdir Sync version
assert.deepStrictEqual(files, fs.readdirSync(readdirDir).sort());

// Check the readdir async version
fs.readdir(readdirDir, common.mustSucceed((f) => {
  assert.deepStrictEqual(files, f.sort());
}));

// readdir() on file should throw ENOTDIR
// https://github.com/joyent/node/issues/1869
assert.throws(function() {
  fs.readdirSync(__filename);
}, /Error: ENOTDIR: not a directory/);

fs.readdir(__filename, common.mustCall(function(e) {
  assert.strictEqual(e.code, 'ENOTDIR');
}));

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.readdir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.readdirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-realpath-on-substed-drive.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
if (!common.isWindows)
  common.skip('Test for Windows only');

import fixtures from '../common/fixtures';

import assert from 'assert';
import fs from 'fs';
import { spawnSync } from 'child_process';

let result;

// Create a subst drive
const driveLetters = 'ABCDEFGHIJKLMNOPQRSTUWXYZ';
let drive;
let i;
for (i = 0; i < driveLetters.length; ++i) {
  drive = `${driveLetters[i]}:`;
  result = spawnSync('subst', [drive, fixtures.fixturesDir]);
  if (result.status === 0)
    break;
}
if (i === driveLetters.length)
  common.skip('Cannot create subst drive');

// Schedule cleanup (and check if all callbacks where called)
process.on('exit', function() {
  spawnSync('subst', ['/d', drive]);
});

// test:
const filename = `${drive}\\empty.js`;
const filenameBuffer = Buffer.from(filename);

result = fs.realpathSync(filename);
assert.strictEqual(result, filename);

result = fs.realpathSync(filename, 'buffer');
assert(Buffer.isBuffer(result));
assert(result.equals(filenameBuffer));

fs.realpath(filename, common.mustSucceed((result) => {
  assert.strictEqual(result, filename);
}));

fs.realpath(filename, 'buffer', common.mustSucceed((result) => {
  assert(Buffer.isBuffer(result));
  assert(result.equals(filenameBuffer));
}));

```"
"```javascript:test\fs\test-fs-promises-file-handle-stream.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.write method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import { finished } from 'stream/promises';
import { buffer } from 'stream/consumers';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-write.txt');
  const fileHandle = await open(filePathForHandle, 'w');
  const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

  const stream = fileHandle.createWriteStream();
  stream.end(buffer);
  await finished(stream);

  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(buffer, readFileData);
}

async function validateRead() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-read.txt');
  const buf = Buffer.from('Hello world'.repeat(100), 'utf8');

  fs.writeFileSync(filePathForHandle, buf);

  const fileHandle = await open(filePathForHandle);
  assert.deepStrictEqual(
    await buffer(fileHandle.createReadStream()),
    buf
  );
}

Promise.all([
  validateWrite(),
  validateRead(),
]).then(common.mustCall()).catch(err => print(err, err.stack));

```"
"```javascript:example_js\react18_ssr\component\css.js
const css = `
body {
    font-family: system-ui, sans-serif;
  }
  
  * {
    box-sizing: border-box;
  }
  
  nav {
    padding: 20px;
  }
  
  .sidebar {
    padding: 10px;
    height: 500px;
    float: left;
    width: 30%;
  }
  
  .post {
    padding: 20px;
    float: left;
    width: 60%;
  }
  
  h1, h2 {
    padding: 0;
  }
  
  ul, li {
    margin: 0;
  }
  
  .post p {
    font-size: larger;
    font-family: Georgia, serif;
  }
  
  .comments {
    margin-top: 40px;
  }
  
  .comment {
    border: 2px solid #aaa;
    border-radius: 4px;
    padding: 20px;
  }
  
  /* https://codepen.io/mandelid/pen/vwKoe */
  .spinner {
    display: inline-block;
    transition: opacity linear 0.1s;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(80, 80, 80, 0.5);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
    opacity: 0;
  }
  .spinner--active {
    opacity: 1;
  }
  
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
  `
export default css
```"
"The following document is located at example_js\react18_ssr\public\main.css
------
body {
    font-family: system-ui, sans-serif;
  }
  
  * {
    box-sizing: border-box;
  }
  
  nav {
    padding: 20px;
  }
  
  .sidebar {
    padding: 10px;
    height: 500px;
    float: left;
    width: 30%;
  }
  
  .post {
    padding: 20px;
    float: left;
    width: 60%;
  }
  
  h1, h2 {
    padding: 0;
  }
  
  ul, li {
    margin: 0;
  }
  
  .post p {
    font-size: larger;
    font-family: Georgia, serif;
  }
  
  .comments {
    margin-top: 40px;
  }
  
  .comment {
    border: 2px solid #aaa;
    border-radius: 4px;
    padding: 20px;
  }
  
  /* https://codepen.io/mandelid/pen/vwKoe */
  .spinner {
    display: inline-block;
    transition: opacity linear 0.1s;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(80, 80, 80, 0.5);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
    opacity: 0;
  }
  .spinner--active {
    opacity: 1;
  }
  
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
------"
"```javascript:test\fs\test-fs-promises-readfile-with-fd.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This test makes sure that `readFile()` always reads from the current
// position of the file, instead of reading from the beginning of the file.

import common from '../common';
import assert from 'assert';
import path from 'path';
import { writeFileSync } from 'fs';
import { open } from 'fs/promises';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = path.join(tmpdir.path, 'test.txt');
writeFileSync(fn, 'Hello World');

async function readFileTest() {
  const handle = await open(fn, 'r');

  /* Read only five bytes, so that the position moves to five. */
  const buf = Buffer.alloc(5);
  const { bytesRead } = await handle.read(buf, 0, 5, null);
  assert.strictEqual(bytesRead, 5);
  assert.strictEqual(buf.toString(), 'Hello');

  /* readFile() should read from position five, instead of zero. */
  assert.strictEqual((await handle.readFile()).toString(), ' World');

  await handle.close();
}


readFileTest()
  .then(common.mustCall());

```"
"```javascript:test\fs\test-fs-stream-construct-compat-error-write.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';

const debuglog = (arg) => {
  console.log(new Date().toLocaleString(), arg);
};

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat error.
  debuglog('start test');

  function WriteStream(...args) {
    debuglog('WriteStream constructor');
    fs.WriteStream.call(this, ...args);
  }
  Object.setPrototypeOf(WriteStream.prototype, fs.WriteStream.prototype);
  Object.setPrototypeOf(WriteStream, fs.WriteStream);

  WriteStream.prototype.open = common.mustCall(function WriteStream$open() {
    debuglog('WriteStream open() callback');
    const that = this;
    fs.open(that.path, that.flags, that.mode, (err, fd) => {
      debuglog('inner fs open() callback');
      that.emit('error', err);
    });
  });

  fs.open(`${tmpdir.path}/dummy`, 'wx+', common.mustCall((err, fd) => {
    debuglog('fs open() callback');
    assert.ifError(err);
    fs.close(fd, () => { debuglog(`closed ${fd}`); });
    const w = new WriteStream(`${tmpdir.path}/dummy`,
                              { flags: 'wx+', emitClose: true })
      .on('error', common.mustCall((err) => {
        debuglog('error event callback');
        assert.strictEqual(err.code, 'EEXIST');
        w.destroy();
        w.on('close', common.mustCall(() => {
          debuglog('close event callback');
        }));
      }));
  }));
  debuglog('waiting for callbacks');
}

```"
"```javascript:test\fs\test-fs-mkdir-mode-mask.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that the lower bits of mode > 0o777 still works in fs.mkdir().

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

// mode is unsupported in wasi now
if (common.isWindows) {
  common.skip('mode is not supported in mkdir on Windows');
}

const mode = 0o644;
const maskToIgnore = 0o10000;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function test(mode, asString) {
  const suffix = asString ? 'str' : 'num';
  const input = asString ?
    (mode | maskToIgnore).toString(8) : (mode | maskToIgnore);

  {
    const dir = path.join(tmpdir.path, `mkdirSync-${suffix}`);
    fs.mkdirSync(dir, input);
    assert.strictEqual(fs.statSync(dir).mode & 0o777, mode);
  }

  {
    const dir = path.join(tmpdir.path, `mkdir-${suffix}`);
    fs.mkdir(dir, input, common.mustSucceed(() => {
      assert.strictEqual(fs.statSync(dir).mode & 0o777, mode);
    }));
  }
}

test(mode, true);
test(mode, false);

```"
"```javascript:test\fs\test-fs-open-mode-mask.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that the lower bits of mode > 0o777 still works in fs.open().

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

const mode = common.isWindows ? 0o444 : 0o644;

const maskToIgnore = 0o10000;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function test(mode, asString) {
  const suffix = asString ? 'str' : 'num';
  const input = asString ?
    (mode | maskToIgnore).toString(8) : (mode | maskToIgnore);

  {
    const file = path.join(tmpdir.path, `openSync-${suffix}.txt`);
    const fd = fs.openSync(file, 'w+', input);
    assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);
    fs.closeSync(fd);
    assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
  }

  {
    const file = path.join(tmpdir.path, `open-${suffix}.txt`);
    fs.open(file, 'w+', input, common.mustSucceed((fd) => {
      assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);
      fs.closeSync(fd);
      assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
    }));
  }
}

test(mode, true);
test(mode, false);

```"
"```javascript:modules\internal\streams\lazy_transform.js
// LazyTransform is a special type of Transform stream that is lazily loaded.
// This is used for performance with bi-API-ship: when two APIs are available
// for the stream, one conventional and one non-conventional.
'use strict';

import Transform from './transform';

import {
  getDefaultEncoding
} from '../crypto/util';

export function LazyTransform(options) {
  this._options = options;
}
Object.setPrototypeOf(LazyTransform.prototype, Transform.prototype);
Object.setPrototypeOf(LazyTransform, Transform);

function makeGetter(name) {
  return function() {
    Transform.call(this, this._options);
    this._writableState.decodeStrings = false;

    if (!this._options || !this._options.defaultEncoding) {
      this._writableState.defaultEncoding = getDefaultEncoding();
    }

    return this[name];
  };
}

function makeSetter(name) {
  return function(val) {
    Object.defineProperty(this, name, {
      __proto__: null,
      value: val,
      enumerable: true,
      configurable: true,
      writable: true
    });
  };
}

Object.defineProperties(LazyTransform.prototype, {
  _readableState: {
    __proto__: null,
    get: makeGetter('_readableState'),
    set: makeSetter('_readableState'),
    configurable: true,
    enumerable: true
  },
  _writableState: {
    __proto__: null,
    get: makeGetter('_writableState'),
    set: makeSetter('_writableState'),
    configurable: true,
    enumerable: true
  }
});

```"
"```javascript:test\fs\test-fs-watch-close-when-destroyed.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that closing a watcher when the underlying handle is
// already destroyed will result in a noop instead of a crash.

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import tmpdir from '../common/tmpdir';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();
const root = path.join(tmpdir.path, 'watched-directory');
fs.mkdirSync(root);

const watcher = fs.watch(root, { persistent: false, recursive: false });

// The following listeners may or may not be invoked.

watcher.addListener('error', () => {
  setTimeout(
    () => { watcher.close(); },  // Should not crash if it's invoked
    common.platformTimeout(10)
  );
});

watcher.addListener('change', () => {
  setTimeout(
    () => { watcher.close(); },
    common.platformTimeout(10)
  );
});

fs.rmdirSync(root);
// Wait for the listener to hit
setTimeout(
  common.mustCall(() => {}),
  common.platformTimeout(100)
);

```"
"```javascript:test\fs\test-fs-write-buffer-large.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// fs.write with length > INT32_MAX

common.skipIf32Bits();

let buf;
try {
  buf = Buffer.allocUnsafe(0x7FFFFFFF + 1);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip('skipped due to memory requirements');
}

const filename = path.join(tmpdir.path, 'write9.txt');
fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
  assert.throws(() => {
    fs.write(fd,
             buf,
             0,
             0x7FFFFFFF + 1,
             0,
             common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""length"" is out of range. ' +
      'It must be >= 0 && <= 2147483647. Received 2147483648'
  });

  fs.closeSync(fd);
}));

```"
"```javascript:test\fs\test-fs-write-negativeoffset.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Tests that passing a negative offset does not crash the process

import common from '../common';

import {
  join,
} from 'path';

import {
  closeSync,
  open,
  write,
  writeSync,
} from 'fs';

import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = join(tmpdir.path, 'test.txt');

open(filename, 'w+', common.mustSucceed((fd) => {
  assert.throws(() => {
    write(fd, Buffer.alloc(0), -1, common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  assert.throws(() => {
    writeSync(fd, Buffer.alloc(0), -1);
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  closeSync(fd);
}));

const filename2 = join(tmpdir.path, 'test2.txt');

// Make sure negative length's don't cause aborts either

open(filename2, 'w+', common.mustSucceed((fd) => {
  assert.throws(() => {
    write(fd, Buffer.alloc(0), 0, -1, common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  assert.throws(() => {
    writeSync(fd, Buffer.alloc(0), 0, -1);
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  closeSync(fd);
}));

```"
"```javascript:test\crypto\test-crypto-aes-wrap.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const test = [
  {
    algorithm: 'aes128-wrap',
    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
    iv: '3fd838af4093d749',
    text: '12345678123456781234567812345678'
  },
  {
    algorithm: 'id-aes128-wrap-pad',
    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
    iv: '3fd838af',
    text: '12345678123456781234567812345678123'
  },
  {
    algorithm: 'aes192-wrap',
    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
    iv: '3fd838af4093d749',
    text: '12345678123456781234567812345678'
  },
  {
    algorithm: 'id-aes192-wrap-pad',
    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
    iv: '3fd838af',
    text: '12345678123456781234567812345678123'
  },
  {
    algorithm: 'aes256-wrap',
    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
    iv: '3fd838af4093d749',
    text: '12345678123456781234567812345678'
  },
  {
    algorithm: 'id-aes256-wrap-pad',
    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
    iv: '3fd838af',
    text: '12345678123456781234567812345678123'
  },
];

test.forEach((data) => {
  const cipher = crypto.createCipheriv(
    data.algorithm,
    Buffer.from(data.key, 'hex'),
    Buffer.from(data.iv, 'hex'));
  const ciphertext = cipher.update(data.text, 'utf8');

  const decipher = crypto.createDecipheriv(
    data.algorithm,
    Buffer.from(data.key, 'hex'),
    Buffer.from(data.iv, 'hex'));
  const msg = decipher.update(ciphertext, 'buffer', 'utf8');

  assert.strictEqual(msg, data.text, `${data.algorithm} test case failed`);
});

```"
"```javascript:test\crypto\test-crypto-op-during-process-exit.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto) { common.skip('missing crypto'); }
const assert = require('assert');
const { generateKeyPair } = require('crypto');

if (common.isWindows) {
  // Remove this conditional once the libuv change is in Node.js.
  common.skip('crashing due to https://github.com/libuv/libuv/pull/2983');
}

// Regression test for a race condition: process.exit() might lead to OpenSSL
// cleaning up state from the exit() call via calling its destructor, but
// running OpenSSL operations on another thread might lead to them attempting
// to initialize OpenSSL, leading to a crash.
// This test crashed consistently on x64 Linux on Node v14.9.0.

generateKeyPair('rsa', {
  modulusLength: 2048,
  privateKeyEncoding: {
    type: 'pkcs1',
    format: 'pem'
  }
}, (err/* , publicKey, privateKey */) => {
  assert.ifError(err);
});

setTimeout(() => process.exit(), common.platformTimeout(10));

```"
"```javascript:test\fs\test-fs-link.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test creating and reading hard link
const srcPath = path.join(tmpdir.path, 'hardlink-target.txt');
const dstPath = path.join(tmpdir.path, 'link1.js');
fs.writeFileSync(srcPath, 'hello world');

function callback(err) {
  assert.ifError(err);
  const dstContent = fs.readFileSync(dstPath, 'utf8');
  assert.strictEqual(dstContent, 'hello world');
}

fs.link(srcPath, dstPath, common.mustCall(callback));

// test error outputs

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.link(i, '', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.link('', i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.linkSync(i, ''),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.linkSync('', i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-write-reuse-callback.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-gc
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import path from 'path';

// Regression test for https://github.com/nodejs/node-v0.x-archive/issues/814:
// Make sure that Buffers passed to fs.write() are not garbage-collected
// even when the callback is being reused.

import fs from 'fs';

tmpdir.refresh();
const filename = path.join(tmpdir.path, 'test.txt');
const fd = fs.openSync(filename, 'w');

const size = 16 * 1024;
const writes = 1000;
let done = 0;

const ondone = common.mustSucceed(() => {
  if (++done < writes) {
    if (done % 25 === 0) global.gc();
    setImmediate(write);
  } else {
    assert.strictEqual(
      fs.readFileSync(filename, 'utf8'),
      'x'.repeat(writes * size));
    fs.closeSync(fd);
  }
}, writes);

write();
function write() {
  const buf = Buffer.alloc(size, 'x');
  fs.write(fd, buf, 0, buf.length, -1, ondone);
}

```"
"```javascript:test\fs\test-fs-write-sigxfsz.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Check that exceeding RLIMIT_FSIZE fails with EFBIG
// rather than terminating the process with SIGXFSZ.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

import assert from 'assert';
import child_process from 'child_process';
import fs from 'fs';
import path from 'path';

if (common.isWindows)
  common.skip('no RLIMIT_FSIZE on Windows');

if (process.config.variables.node_shared)
  common.skip('SIGXFSZ signal handler not installed in shared library mode');

if (process.argv[2] === 'child') {
  const filename = path.join(tmpdir.path, 'efbig.txt');
  tmpdir.refresh();
  fs.writeFileSync(filename, '.'.repeat(1 << 16));  // Exceeds RLIMIT_FSIZE.
} else {
  const cmd = `ulimit -f 1 && '${process.execPath}' '${__filename}' child`;
  const result = child_process.spawnSync('/bin/sh', ['-c', cmd]);
  const haystack = result.stderr.toString();
  const needle = 'Error: EFBIG: file too large, write';
  const ok = haystack.includes(needle);
  if (!ok) console.error(haystack);
  assert(ok);
  assert.strictEqual(result.status, 1);
  assert.strictEqual(result.stdout.toString(), '');
}

```"
"```javascript:test\crypto\test-crypto-dh-constructor.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
const dh1 = crypto.createDiffieHellman(size);
const p1 = dh1.getPrime('buffer');

{
  const DiffieHellman = crypto.DiffieHellman;

  const dh = DiffieHellman(p1, 'buffer');
  assert(dh instanceof DiffieHellman, 'DiffieHellman is expected to return a ' +
                                      'new instance when called without `new`');
}

{
  const DiffieHellmanGroup = crypto.DiffieHellmanGroup;
  const dhg = DiffieHellmanGroup('modp5');
  assert(dhg instanceof DiffieHellmanGroup, 'DiffieHellmanGroup is expected ' +
                                            'to return a new instance when ' +
                                            'called without `new`');
}

{
  const ECDH = crypto.ECDH;
  const ecdh = ECDH('prime256v1');
  assert(ecdh instanceof ECDH, 'ECDH is expected to return a new instance ' +
                              'when called without `new`');
}

```"
"```javascript:test\fs\test-fs-write-file-invalid-path.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

if (!common.isWindows)
  common.skip('This test is for Windows only.');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const DATA_VALUE = 'hello';

// Refs: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx
// Ignore '/', '\\' and ':'
const RESERVED_CHARACTERS = '<>""|?*';

[...RESERVED_CHARACTERS].forEach((ch) => {
  const pathname = path.join(tmpdir.path, `somefile_${ch}`);
  assert.throws(
    () => {
      fs.writeFileSync(pathname, DATA_VALUE);
    },
    /^Error: ENOENT: no such file or directory, open '.*'$/,
    `failed with '${ch}'`);
});

// Test for ':' (NTFS data streams).
// Refs: https://msdn.microsoft.com/en-us/library/windows/desktop/bb540537.aspx
const pathname = path.join(tmpdir.path, 'foo:bar');
fs.writeFileSync(pathname, DATA_VALUE);

let content = '';
const fileDataStream = fs.createReadStream(pathname, {
  encoding: 'utf8'
});

fileDataStream.on('data', (data) => {
  content += data;
});

fileDataStream.on('end', common.mustCall(() => {
  assert.strictEqual(content, DATA_VALUE);
}));

```"
"```javascript:test\path\test-path-dirname.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';

const __filename = args[0];

assert.strictEqual(path.dirname(__filename).substr(-13),
                   common.isWindows ? 'test\\path' : 'test/path');

assert.strictEqual(path.posix.dirname('/a/b/'), '/a');
assert.strictEqual(path.posix.dirname('/a/b'), '/a');
assert.strictEqual(path.posix.dirname('/a'), '/');
assert.strictEqual(path.posix.dirname(''), '.');
assert.strictEqual(path.posix.dirname('/'), '/');
assert.strictEqual(path.posix.dirname('////'), '/');
assert.strictEqual(path.posix.dirname('//a'), '//');
assert.strictEqual(path.posix.dirname('foo'), '.');
/*
assert.strictEqual(path.win32.dirname('c:\\'), 'c:\\');
assert.strictEqual(path.win32.dirname('c:\\foo'), 'c:\\');
assert.strictEqual(path.win32.dirname('c:\\foo\\'), 'c:\\');
assert.strictEqual(path.win32.dirname('c:\\foo\\bar'), 'c:\\foo');
assert.strictEqual(path.win32.dirname('c:\\foo\\bar\\'), 'c:\\foo');
assert.strictEqual(path.win32.dirname('c:\\foo\\bar\\baz'), 'c:\\foo\\bar');
assert.strictEqual(path.win32.dirname('c:\\foo bar\\baz'), 'c:\\foo bar');
assert.strictEqual(path.win32.dirname('\\'), '\\');
assert.strictEqual(path.win32.dirname('\\foo'), '\\');
assert.strictEqual(path.win32.dirname('\\foo\\'), '\\');
assert.strictEqual(path.win32.dirname('\\foo\\bar'), '\\foo');
assert.strictEqual(path.win32.dirname('\\foo\\bar\\'), '\\foo');
assert.strictEqual(path.win32.dirname('\\foo\\bar\\baz'), '\\foo\\bar');
assert.strictEqual(path.win32.dirname('\\foo bar\\baz'), '\\foo bar');
assert.strictEqual(path.win32.dirname('c:'), 'c:');
assert.strictEqual(path.win32.dirname('c:foo'), 'c:');
assert.strictEqual(path.win32.dirname('c:foo\\'), 'c:');
assert.strictEqual(path.win32.dirname('c:foo\\bar'), 'c:foo');
assert.strictEqual(path.win32.dirname('c:foo\\bar\\'), 'c:foo');
assert.strictEqual(path.win32.dirname('c:foo\\bar\\baz'), 'c:foo\\bar');
assert.strictEqual(path.win32.dirname('c:foo bar\\baz'), 'c:foo bar');
assert.strictEqual(path.win32.dirname('file:stream'), '.');
assert.strictEqual(path.win32.dirname('dir\\file:stream'), 'dir');
assert.strictEqual(path.win32.dirname('\\\\unc\\share'),
                   '\\\\unc\\share');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo'),
                   '\\\\unc\\share\\');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\'),
                   '\\\\unc\\share\\');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\bar'),
                   '\\\\unc\\share\\foo');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\bar\\'),
                   '\\\\unc\\share\\foo');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\bar\\baz'),
                   '\\\\unc\\share\\foo\\bar');
assert.strictEqual(path.win32.dirname('/a/b/'), '/a');
assert.strictEqual(path.win32.dirname('/a/b'), '/a');
assert.strictEqual(path.win32.dirname('/a'), '/');
assert.strictEqual(path.win32.dirname(''), '.');
assert.strictEqual(path.win32.dirname('/'), '/');
assert.strictEqual(path.win32.dirname('////'), '/');
assert.strictEqual(path.win32.dirname('foo'), '.');
*/
```"
"```javascript:test\crypto\test-crypto-private-decrypt-gh32240.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// Verify that privateDecrypt() does not leave an error on the
// openssl error stack that is visible to subsequent operations.

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const {
  generateKeyPairSync,
  publicEncrypt,
  privateDecrypt,
} = require('crypto');

const pair = generateKeyPairSync('rsa', { modulusLength: 512 });

const expected = Buffer.from('shibboleth');
const encrypted = publicEncrypt(pair.publicKey, expected);

const pkey = pair.privateKey.export({ type: 'pkcs1', format: 'pem' });
const pkeyEncrypted =
  pair.privateKey.export({
    type: 'pkcs1',
    format: 'pem',
    cipher: 'aes128',
    passphrase: 'secret',
  });

function decrypt(key) {
  const decrypted = privateDecrypt(key, encrypted);
  assert.deepStrictEqual(decrypted, expected);
}

decrypt(pkey);
assert.throws(() => decrypt(pkeyEncrypted), common.hasOpenSSL3 ?
  { message: 'error:07880109:common libcrypto routines::interrupted or ' +
             'cancelled' } :
  { code: 'ERR_MISSING_PASSPHRASE' });
decrypt(pkey);  // Should not throw.

```"
"```javascript:test\fs\test-fs-non-number-arguments-throw.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';
const tempFile = path.join(tmpdir.path, 'fs-non-number-arguments-throw');

tmpdir.refresh();
fs.writeFileSync(tempFile, 'abc\ndef');

// A sanity check when using numbers instead of strings
const sanity = 'def';
const saneEmitter = fs.createReadStream(tempFile, { start: 4, end: 6 });

assert.throws(
  () => {
    fs.createReadStream(tempFile, { start: '4', end: 6 });
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.createReadStream(tempFile, { start: 4, end: '6' });
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.createWriteStream(tempFile, { start: '4' });
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

saneEmitter.on('data', common.mustCall(function(data) {
  assert.strictEqual(
    sanity, data.toString('utf8'),
    `read ${data.toString('utf8')} instead of ${sanity}`);
}));

```"
"```javascript:test\fs\test-fs-read-optional-params.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';
const filepath = fixtures.path('x.txt');

const expected = Buffer.from('xyz\n');
const defaultBufferAsync = Buffer.alloc(16384);
const bufferAsOption = Buffer.allocUnsafe(expected.byteLength);

function testValid(message, ...options) {
  const paramsMsg = `${message} (as params)`;
  const paramsFilehandle = fs.openSync(filepath, 'r');
  fs.read(paramsFilehandle, ...options, common.mustSucceed((bytesRead, buffer) => {
    assert.strictEqual(bytesRead, expected.byteLength, paramsMsg);
    assert.deepStrictEqual(defaultBufferAsync.byteLength, buffer.byteLength, paramsMsg);
    fs.closeSync(paramsFilehandle);
  }));

  const optionsMsg = `${message} (as options)`;
  const optionsFilehandle = fs.openSync(filepath, 'r');
  fs.read(optionsFilehandle, bufferAsOption, ...options, common.mustSucceed((bytesRead, buffer) => {
    assert.strictEqual(bytesRead, expected.byteLength, optionsMsg);
    assert.deepStrictEqual(bufferAsOption.byteLength, buffer.byteLength, optionsMsg);
    fs.closeSync(optionsFilehandle);
  }));
}

testValid('Not passing in any object');
testValid('Passing in a null', null);
testValid('Passing in an empty object', common.mustNotMutateObjectDeep({}));
testValid('Passing in an object', common.mustNotMutateObjectDeep({
  offset: 0,
  length: bufferAsOption.byteLength,
  position: 0,
}));

```"
"```javascript:test\fs\test-fs-write-file-typedarrays.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = join(tmpdir.path, 'test.txt');

const s = '���������������203���������111���������������������������������������������������������������������������������������������������' +
          '������������������������������������������������������������������������������������������������������������������' +
          '���������������������������������������������������������203���������������������������������������������' +
          '���196���������179������������������������������������������������������������������������������������������112������' +
          '������������������������������������������������������������������������111������������������������������93������' +
          '���������������������������������������������������������������������������������������������������������������������������������' +
          '���������������������������������������������������������������������������������������������������������������������##������������\n';

// The length of the buffer should be a multiple of 8
// as required by common.getArrayBufferViews()
const inputBuffer = Buffer.from(s.repeat(8), 'utf8');

for (const expectView of common.getArrayBufferViews(inputBuffer)) {
  console.log('Sync test for ', expectView[Symbol.toStringTag]);
  fs.writeFileSync(filename, expectView);
  assert.strictEqual(
    fs.readFileSync(filename, 'utf8'),
    inputBuffer.toString('utf8')
  );
}

for (const expectView of common.getArrayBufferViews(inputBuffer)) {
  console.log('Async test for ', expectView[Symbol.toStringTag]);
  const file = `${filename}-${expectView[Symbol.toStringTag]}`;
  fs.writeFile(file, expectView, common.mustSucceed(() => {
    fs.readFile(file, 'utf8', common.mustSucceed((data) => {
      assert.strictEqual(data, inputBuffer.toString('utf8'));
    }));
  }));
}

```"
"```javascript:test\fs\test-fs-rename-type-check.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, [], {}, null, undefined].forEach((input) => {
  const type = 'of type string or an instance of Buffer or URL.' +
               common.invalidArgTypeHelper(input);
  assert.throws(
    () => fs.rename(input, 'does-not-exist', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""oldPath"" argument must be ${type}`
    }
  );
  assert.throws(
    () => fs.rename('does-not-exist', input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""newPath"" argument must be ${type}`
    }
  );
  assert.throws(
    () => fs.renameSync(input, 'does-not-exist'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""oldPath"" argument must be ${type}`
    }
  );
  assert.throws(
    () => fs.renameSync('does-not-exist', input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""newPath"" argument must be ${type}`
    }
  );
});

```"
"```javascript:test\crypto\test-crypto-dh-modp2.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { modp2buf } = require('../common/crypto');
const modp2 = crypto.createDiffieHellmanGroup('modp2');

{
  // Ensure specific generator (buffer) works as expected.
  const exmodp2 = crypto.createDiffieHellman(modp2buf, Buffer.from([2]));
  modp2.generateKeys();
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}

{
  // Ensure specific generator (string without encoding) works as expected.
  const exmodp2 = crypto.createDiffieHellman(modp2buf, '\x02');
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}

{
  // Ensure specific generator (numeric) works as expected.
  const exmodp2 = crypto.createDiffieHellman(modp2buf, 2);
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}

```"
"```javascript:test\fs\test-fs-buffer.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

fs.access(Buffer.from(tmpdir.path), common.mustSucceed());

const buf = Buffer.from(path.join(tmpdir.path, 'a.txt'));
fs.open(buf, 'w+', common.mustSucceed((fd) => {
  assert(fd);
  fs.close(fd, common.mustSucceed());
}));

assert.throws(
  () => {
    fs.accessSync(true);
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""path"" argument must be of type string or an instance of ' +
             'Buffer or URL. Received type boolean (true)'
  }
);

const dir = Buffer.from(fixtures.fixturesDir);
fs.readdir(dir, 'hex', common.mustSucceed((hexList) => {
  fs.readdir(dir, common.mustSucceed((stringList) => {
    stringList.forEach((val, idx) => {
      const fromHexList = Buffer.from(hexList[idx], 'hex').toString();
      assert.strictEqual(
        fromHexList,
        val,
        `expected ${val}, got ${fromHexList} by hex decoding ${hexList[idx]}`
      );
    });
  }));
}));

```"
"```javascript:test\fs\test-fs-promises-file-handle-append-file.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.appendFile method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateAppendBuffer() {
  const filePath = path.resolve(tmpDir, 'tmp-append-file-buffer.txt');
  const fileHandle = await open(filePath, 'a');
  const buffer = Buffer.from('a&Dp'.repeat(100), 'utf8');

  await fileHandle.appendFile(buffer);
  const appendedFileData = fs.readFileSync(filePath);
  assert.deepStrictEqual(appendedFileData, buffer);

  await fileHandle.close();
}

async function validateAppendString() {
  const filePath = path.resolve(tmpDir, 'tmp-append-file-string.txt');
  const fileHandle = await open(filePath, 'a');
  const string = 'x~yz'.repeat(100);

  await fileHandle.appendFile(string);
  const stringAsBuffer = Buffer.from(string, 'utf8');
  const appendedFileData = fs.readFileSync(filePath);
  assert.deepStrictEqual(appendedFileData, stringAsBuffer);

  await fileHandle.close();
}

validateAppendBuffer()
  .then(validateAppendString)
  .then(common.mustCall());

```"
"```javascript:test\fs\test-fs-existssync-false.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

// This test ensures that fs.existsSync doesn't incorrectly return false.
// (especially on Windows)
// https://github.com/nodejs/node-v0.x-archive/issues/3739

import assert from 'assert';
import fs from 'fs';
import path from 'path';

let dir = path.resolve(tmpdir.path);

// Make sure that the tmp directory is clean
tmpdir.refresh();

// wasmedge no support so long path
// Make a long path.
for (let i = 0; i < 50; i++) {
  dir = `${dir}/1234567890`;
  try {
    fs.mkdirSync(dir, '0777');
  } catch (e) {
    if (e.code !== 'EEXIST') {
      throw e;
    }
  }
}

// Test if file exists synchronously
assert(fs.existsSync(dir), 'Directory is not accessible');

// Test if file exists asynchronously
fs.access(dir, common.mustSucceed());

```"
"```javascript:test\fs\test-fs-mkdir-rmdir.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const d = path.join(tmpdir.path, 'dir');

tmpdir.refresh();

// Make sure the directory does not exist
assert(!fs.existsSync(d));
// Create the directory now
fs.mkdirSync(d);
// Make sure the directory exists
assert(fs.existsSync(d));
// Try creating again, it should fail with EEXIST
assert.throws(function() {
  fs.mkdirSync(d);
}, /EEXIST: file already exists, mkdir/);
// Remove the directory now
fs.rmdirSync(d);
// Make sure the directory does not exist
assert(!fs.existsSync(d));

// Similarly test the Async version
fs.mkdir(d, 0o666, common.mustSucceed(() => {
  fs.mkdir(d, 0o666, common.mustCall(function(err) {
    assert.strictEqual(this, undefined);
    assert.ok(err, 'got no error');
    assert.match(err.message, /^EEXIST/);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.path, d);

    fs.rmdir(d, assert.ifError);
  }));
}));

```"
"```javascript:example_js\hello.js
import * as os from 'os';
import * as std from 'std';
import * as process from 'process'

args = args.slice(1);
print('Hello', ...args);

let id = setTimeout(() => {
    print('setTimeout 2s cancel');
}, 2000);

print(id);
clearTimeout(id);

setTimeout(() => {
    print('setTimeout 2s');
}, 2000);

let env = process.env
for (var k in env) {
    print(k, '=', env[k])
}

let thenable = {
    data: 1,
    then(onFulfilled, onRejected) {
        print(""then:"")
        onFulfilled(2)
    }
}



async function xx() {
    let p = new Promise((r) => {
        nextTick(() => {
            print(""nextTick"")
            r(1)
        })
    })

    let a = sleep(() => {
        print('timeout 1s');
    }, 1000).then((v) => {
        return thenable;
    });
    let x = await p;
    print(""end await p"", x);
    let v = await a;
    print(""end xx"", v);
}

xx()

print('end main')


```"
"```javascript:test\fs\test-fs-chown-type-check.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.chown(i, 1, 1, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chownSync(i, 1, 1),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

[false, 'test', {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.chown('not_a_file_that_exists', i, 1, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chown('not_a_file_that_exists', 1, i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chownSync('not_a_file_that_exists', i, 1),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chownSync('not_a_file_that_exists', 1, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:example_js\tensorflow_lite_demo\wasi_nn_main.js
import { Image } from 'image';
import * as fs from 'fs';
import { NnGraph, NnContext, TENSOR_TYPE_U8 } from 'wasi_nn';

let img = new Image(__dirname + '/food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let data = fs.readFileSync(__dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite')
let graph = new NnGraph([data.buffer], ""tensorflowlite"", ""cpu"");
let context = new NnContext(graph);
context.setInput(0, rgb_pix, [1, 192, 192, 3], TENSOR_TYPE_U8);
context.compute();

let output_view = new Uint8Array(2024);
context.getOutput(0, output_view.buffer)

let max = 0;
let max_idx = 0;
for (var i in output_view) {
    let v = output_view[i];
    if (v > max) {
        max = v;
        max_idx = i;
    }
}

let label_file = fs.readFileSync(__dirname + '/aiy_food_V1_labelmap.txt', 'utf-8');
let lables = label_file.split(/\r?\n/);

let label = lables[max_idx]

print('label:');
print(label);
print('confidence:');
print(max / 255);
```"
"```javascript:test\fs\test-fs-close-errors.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// This tests that the errors thrown from fs.close and fs.closeSync
// include the desired properties

import common from '../common';
import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

['', false, null, undefined, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""fd"" argument must be of type number.' +
             common.invalidArgTypeHelper(input)
  };
  assert.throws(() => fs.close(input), errObj);
  assert.throws(() => fs.closeSync(input), errObj);
});

{
  // Test error when cb is not a function
  const fd = fs.openSync(__filename, 'r');

  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  };

  ['', false, null, {}, []].forEach((input) => {
    assert.throws(() => fs.close(fd, input), errObj);
  });

  fs.closeSync(fd);
}

```"
"```javascript:test\fs\test-fs-fmap.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

const {
  O_CREAT = 0,
  O_RDONLY = 0,
  O_TRUNC = 0,
  O_WRONLY = 0,
  UV_FS_O_FILEMAP = 0
} = fs.constants;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Run this test on all platforms. While UV_FS_O_FILEMAP is only available on
// Windows, it should be silently ignored on other platforms.

const filename = join(tmpdir.path, 'fmap.txt');
const text = 'Memory File Mapping Test';

const mw = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
const mr = UV_FS_O_FILEMAP | O_RDONLY;

fs.writeFileSync(filename, text, { flag: mw });
const r1 = fs.readFileSync(filename, { encoding: 'utf8', flag: mr });
assert.strictEqual(r1, text);
```"
"```javascript:test\crypto\test-crypto-keygen-deprecation.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --pending-deprecation

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const DeprecationWarning = [];
DeprecationWarning.push([
  '""options.hash"" is deprecated, use ""options.hashAlgorithm"" instead.',
  'DEP0154']);
DeprecationWarning.push([
  '""options.mgf1Hash"" is deprecated, use ""options.mgf1HashAlgorithm"" instead.',
  'DEP0154']);

common.expectWarning({ DeprecationWarning });

const assert = require('assert');
const { generateKeyPair } = require('crypto');

{
  // This test makes sure deprecated options still work as intended

  generateKeyPair('rsa-pss', {
    modulusLength: 512,
    saltLength: 16,
    hash: 'sha256',
    mgf1Hash: 'sha256'
  }, common.mustSucceed((publicKey, privateKey) => {
    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, {
      modulusLength: 512,
      publicExponent: 65537n,
      hashAlgorithm: 'sha256',
      mgf1HashAlgorithm: 'sha256',
      saltLength: 16
    });

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, {
      modulusLength: 512,
      publicExponent: 65537n,
      hashAlgorithm: 'sha256',
      mgf1HashAlgorithm: 'sha256',
      saltLength: 16
    });
  }));
}

```"
"```javascript:example_js\wasi_http_echo.js
import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  print(""server: req.httpVersion="", req.httpVersion);
  print(""server: req.url="", req.url);
  print(""server: req.method="", req.method);
  print(""server: req.headers="", Object.keys(req.headers));

  req.on('data', (body) => {
    print(""server: req.body="", body);
    print()

    resp.write('echo:')
    resp.end(body)
  })
}).listen(8001, () => {
  print('listen 8001 ...\n');
})

async function test_request() {
  let client = request({ href: ""http://127.0.0.1:8001/request"", method: 'POST' }, (resp) => {
    var data = '';
    resp.on('data', (chunk) => {
      data += chunk;
    })
    resp.on('end', () => {
      print('request client recv:', data)
      print()
    })
  })

  client.end('hello server')
}

async function test_fetch() {
  let resp = await fetch('http://127.0.0.1:8001/fetch', { method: 'POST', body: 'hello server' })
  print('fetch client recv:', await resp.text())
  print()
}

async function run_test() {
  await test_request()
  await test_fetch()
  exit(0)
}

run_test()

```"
"```javascript:test\fs\test-fs-read-empty-buffer.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');
const fsPromises = fs.promises;

const buffer = new Uint8Array();

assert.throws(
  () => fs.readSync(fd, buffer, 0, 10, 0),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    message: /is empty and cannot be written/
  }
);

assert.throws(
  () => fs.read(fd, buffer, 0, 1, 0, common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    message: /is empty and cannot be written/
  }
);

(async () => {
  const filehandle = await fsPromises.open(filepath, 'r');
  assert.rejects(
    () => filehandle.read(buffer, 0, 1, 0),
    {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /is empty and cannot be written/
    }
  );
})().then(common.mustCall());

```"
"```javascript:example_js\react18_ssr\component\Post.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Post() {
  return (
    <>
      <h1>Hello world</h1>
      <p>
        This demo is <b>artificially slowed down</b>. Open{' '}
        <code>server/delays.js</code> to adjust how much different things are
        slowed down.
      </p>
      <p>
        Notice how HTML for comments ""streams in"" before the JS (or React) has
        loaded on the page.
      </p>
      <p>
        Also notice that the JS for comments and sidebar has been code-split,
        but HTML for it is still included in the server output.
      </p>
    </>
  );
}

```"
"```javascript:modules\internal\streams\state.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { ERR_INVALID_ARG_VALUE } from ""../errors.js"";

function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null
        ? options.highWaterMark
        : isDuplex
            ? options[duplexKey]
            : null;
}

function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name = isDuplex ? `options.${duplexKey}` : ""options.highWaterMark"";
            throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }

    // Default value
    return getDefaultHighWaterMark(state.objectMode);
}

export default {
    getHighWaterMark,
    getDefaultHighWaterMark,
};
export { getDefaultHighWaterMark, getHighWaterMark };
```"
"```javascript:test\crypto\test-crypto-dh-leak.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-gc --noconcurrent_recompilation
'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');
if (process.config.variables.asan)
  common.skip('ASAN messes with memory measurements');

const assert = require('assert');
const crypto = require('crypto');

const before = process.memoryUsage.rss();
{
  const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
  const dh = crypto.createDiffieHellman(size);
  const publicKey = dh.generateKeys();
  const privateKey = dh.getPrivateKey();
  for (let i = 0; i < 5e4; i += 1) {
    dh.setPublicKey(publicKey);
    dh.setPrivateKey(privateKey);
  }
}
global.gc();
const after = process.memoryUsage.rss();

// RSS should stay the same, ceteris paribus, but allow for
// some slop because V8 mallocs memory during execution.
assert(after - before < 10 << 20, `before=${before} after=${after}`);

```"
"```javascript:test\path\test-path-normalize.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

/*
assert.strictEqual(path.win32.normalize('./fixtures///b/../b/c.js'),
                   'fixtures\\b\\c.js');
assert.strictEqual(path.win32.normalize('/foo/../../../bar'), '\\bar');
assert.strictEqual(path.win32.normalize('a//b//../b'), 'a\\b');
assert.strictEqual(path.win32.normalize('a//b//./c'), 'a\\b\\c');
assert.strictEqual(path.win32.normalize('a//b//.'), 'a\\b');
assert.strictEqual(path.win32.normalize('//server/share/dir/file.ext'),
                   '\\\\server\\share\\dir\\file.ext');
assert.strictEqual(path.win32.normalize('/a/b/c/../../../x/y/z'), '\\x\\y\\z');
assert.strictEqual(path.win32.normalize('C:'), 'C:.');
assert.strictEqual(path.win32.normalize('C:..\\abc'), 'C:..\\abc');
assert.strictEqual(path.win32.normalize('C:..\\..\\abc\\..\\def'),
                   'C:..\\..\\def');
assert.strictEqual(path.win32.normalize('C:\\.'), 'C:\\');
assert.strictEqual(path.win32.normalize('file:stream'), 'file:stream');
assert.strictEqual(path.win32.normalize('bar\\foo..\\..\\'), 'bar\\');
assert.strictEqual(path.win32.normalize('bar\\foo..\\..'), 'bar');
assert.strictEqual(path.win32.normalize('bar\\foo..\\..\\baz'), 'bar\\baz');
assert.strictEqual(path.win32.normalize('bar\\foo..\\'), 'bar\\foo..\\');
assert.strictEqual(path.win32.normalize('bar\\foo..'), 'bar\\foo..');
assert.strictEqual(path.win32.normalize('..\\foo..\\..\\..\\bar'),
                   '..\\..\\bar');
assert.strictEqual(path.win32.normalize('..\\...\\..\\.\\...\\..\\..\\bar'),
                   '..\\..\\bar');
assert.strictEqual(path.win32.normalize('../../../foo/../../../bar'),
                   '..\\..\\..\\..\\..\\bar');
assert.strictEqual(path.win32.normalize('../../../foo/../../../bar/../../'),
                   '..\\..\\..\\..\\..\\..\\');
assert.strictEqual(
  path.win32.normalize('../foobar/barfoo/foo/../../../bar/../../'),
  '..\\..\\'
);
assert.strictEqual(
  path.win32.normalize('../.../../foobar/../../../bar/../../baz'),
  '..\\..\\..\\..\\baz'
);
assert.strictEqual(path.win32.normalize('foo/bar\\baz'), 'foo\\bar\\baz');
*/
assert.strictEqual(path.posix.normalize('./fixtures///b/../b/c.js'),
                   'fixtures/b/c.js');
assert.strictEqual(path.posix.normalize('/foo/../../../bar'), '/bar');
assert.strictEqual(path.posix.normalize('a//b//../b'), 'a/b');
assert.strictEqual(path.posix.normalize('a//b//./c'), 'a/b/c');
assert.strictEqual(path.posix.normalize('a//b//.'), 'a/b');
assert.strictEqual(path.posix.normalize('/a/b/c/../../../x/y/z'), '/x/y/z');
assert.strictEqual(path.posix.normalize('///..//./foo/.//bar'), '/foo/bar');
assert.strictEqual(path.posix.normalize('bar/foo../../'), 'bar/');
assert.strictEqual(path.posix.normalize('bar/foo../..'), 'bar');
assert.strictEqual(path.posix.normalize('bar/foo../../baz'), 'bar/baz');
assert.strictEqual(path.posix.normalize('bar/foo../'), 'bar/foo../');
assert.strictEqual(path.posix.normalize('bar/foo..'), 'bar/foo..');
assert.strictEqual(path.posix.normalize('../foo../../../bar'), '../../bar');
assert.strictEqual(path.posix.normalize('../.../.././.../../../bar'),
                   '../../bar');
assert.strictEqual(path.posix.normalize('../../../foo/../../../bar'),
                   '../../../../../bar');
assert.strictEqual(path.posix.normalize('../../../foo/../../../bar/../../'),
                   '../../../../../../');
assert.strictEqual(
  path.posix.normalize('../foobar/barfoo/foo/../../../bar/../../'),
  '../../'
);
assert.strictEqual(
  path.posix.normalize('../.../../foobar/../../../bar/../../baz'),
  '../../../../baz'
);
assert.strictEqual(path.posix.normalize('foo/bar\\baz'), 'foo/bar\\baz');

```"
"```javascript:test\fs\test-fs-write-stream-file-handle-2.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'write_stream_filehandle_test.txt');
const input = 'hello world';

tmpdir.refresh();

fs.promises.open(file, 'w+').then((handle) => {
  let calls = 0;
  const {
    write: originalWriteFunction,
    writev: originalWritevFunction
  } = handle;
  handle.write = function write() {
    calls++;
    return Reflect.apply(originalWriteFunction, this, arguments);
  };
  handle.writev = function writev() {
    calls++;
    return Reflect.apply(originalWritevFunction, this, arguments);
  };
  const stream = fs.createWriteStream(null, { fd: handle });

  stream.end(input);
  stream.on('close', common.mustCall(() => {
    assert(calls > 0, 'expected at least one call to fileHandle.write or ' +
    'fileHandle.writev, got 0');
  }));
}).then(common.mustCall());

```"
"```javascript:example_js\tensorflow_lite_demo\main.js
import {Image} from 'image';
import * as std from 'std';
import {TensorflowLiteSession} from 'tensorflow_lite';

let img = new Image(__dirname + '/food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let session = new TensorflowLiteSession(
    __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite');
session.add_input('input', rgb_pix);
session.run();
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v > max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open(__dirname + '/aiy_food_V1_labelmap.txt', 'r');
let label = '';
for (var i = 0; i <= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max / 255);

```"
"```javascript:test\crypto\test-crypto-subtle-zero-length.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto').webcrypto;

(async () => {
  const k = await crypto.subtle.importKey(
    'raw',
    new Uint8Array(32),
    { name: 'AES-GCM' },
    false,
    [ 'encrypt', 'decrypt' ]);
  assert(k instanceof crypto.CryptoKey);

  const e = await crypto.subtle.encrypt({
    name: 'AES-GCM',
    iv: new Uint8Array(12),
  }, k, new Uint8Array(0));
  assert(e instanceof ArrayBuffer);
  assert.deepStrictEqual(
    Buffer.from(e),
    Buffer.from([
      0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9,
      0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b ]));

  const v = await crypto.subtle.decrypt({
    name: 'AES-GCM',
    iv: new Uint8Array(12),
  }, k, e);
  assert(v instanceof ArrayBuffer);
  assert.strictEqual(v.byteLength, 0);
})().then(common.mustCall()).catch((e) => {
  assert.ifError(e);
});

```"
"```javascript:test\fs\test-fs-mkdtemp.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const tmpFolder = fs.mkdtempSync(path.join(tmpdir.path, 'foo.'));

assert.strictEqual(path.basename(tmpFolder).length, 'foo.XXXXXX'.length);
assert(fs.existsSync(tmpFolder));

const utf8 = fs.mkdtempSync(path.join(tmpdir.path, '\u0222abc.'));
assert.strictEqual(Buffer.byteLength(path.basename(utf8)),
                   Buffer.byteLength('\u0222abc.XXXXXX'));
assert(fs.existsSync(utf8));

function handler(err, folder) {
  assert.ifError(err);
  assert(fs.existsSync(folder));
  assert.strictEqual(this, undefined);
}

fs.mkdtemp(path.join(tmpdir.path, 'bar.'), common.mustCall(handler));

// Same test as above, but making sure that passing an options object doesn't
// affect the way the callback function is handled.
fs.mkdtemp(path.join(tmpdir.path, 'bar.'), {}, common.mustCall(handler));

const warningMsg = 'mkdtemp() templates ending with X are not portable. ' +
                   'For details see: https://nodejs.org/api/fs.html';
common.expectWarning('Warning', warningMsg);
fs.mkdtemp(path.join(tmpdir.path, 'bar.X'), common.mustCall(handler));

```"
"```javascript:example_js\tensorflow_demo\main.js
import {Image} from 'image';
import * as std from 'std';
import {TensorflowSession} from 'tensorflow';

let img = new Image('bird.png');
let img_rgb = img.to_rgb().resize(224, 224);
let rgb_pix = img_rgb.pixels_32f();

let session = new TensorflowSession('mobilenet_v2_1.4_224_frozen.pb');
session.add_input_32f('input', rgb_pix, [1, 224, 224, 3]);
session.add_output('MobilenetV2/Predictions/Softmax');
session.run();
let output = session.get_output('MobilenetV2/Predictions/Softmax');
let output_view = new Float32Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v > max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open('imagenet_slim_labels.txt', 'r');
let label = '';
for (var i = 0; i <= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max);

```"
"```javascript:test\fs\test-fs-promisified.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';

const read = promisify(fs.read);
const write = promisify(fs.write);
const exists = promisify(fs.exists);

const __filename = args[0];

{
  const fd = fs.openSync(__filename, 'r');
  read(fd, Buffer.alloc(1024), 0, 1024, null).then(common.mustCall((obj) => {
    assert.strictEqual(typeof obj.bytesRead, 'number');
    assert(obj.buffer instanceof Buffer);
    fs.closeSync(fd);
  }));
}

import tmpdir from '../common/tmpdir';
tmpdir.refresh();
{
  const filename = path.join(tmpdir.path, 'write-promise.txt');
  const fd = fs.openSync(filename, 'w');
  write(fd, Buffer.from('foobar')).then(common.mustCall((obj) => {
    assert.strictEqual(typeof obj.bytesWritten, 'number');
    assert.strictEqual(obj.buffer.toString(), 'foobar');
    fs.closeSync(fd);
  }));
}

{
  exists(__filename).then(common.mustCall((x) => {
    assert.strictEqual(x, true);
  }));
}

```"
"```javascript:test\fs\test-fs-readfilesync-pipe-large.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Simulate `cat readfile.js | node readfile.js`

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';
import path from 'path';
import fs from 'fs';

if (process.argv[2] === 'child') {
  process.stdout.write(fs.readFileSync('/dev/stdin', 'utf8'));
  return;
}

import tmpdir from '../common/tmpdir';

const filename = path.join(tmpdir.path, '/readfilesync_pipe_large_test.txt');
const dataExpected = 'a'.repeat(999999);
tmpdir.refresh();
fs.writeFileSync(filename, dataExpected);

import { exec } from 'child_process';
const f = JSON.stringify(__filename);
const node = JSON.stringify(process.execPath);
const cmd = `cat ${filename} | ${node} ${f} child`;
exec(
  cmd,
  { maxBuffer: 1000000 },
  common.mustSucceed((stdout, stderr) => {
    assert.strictEqual(stdout, dataExpected);
    assert.strictEqual(stderr, '');
    console.log('ok');
  })
);

```"
"```javascript:test\fs\test-fs-promises-file-handle-sync.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';

import { access, copyFile, open } from 'fs/promises';
import path from 'path';

async function validate() {
  tmpdir.refresh();
  const dest = path.resolve(tmpdir.path, 'baz.js');
  await assert.rejects(
    copyFile(fixtures.path('baz.js'), dest, 'r'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /mode.*number.*string/
    }
  );
  await copyFile(fixtures.path('baz.js'), dest);
  await assert.rejects(
    access(dest, 'r'),
    { code: 'ERR_INVALID_ARG_TYPE', message: /mode/ }
  );
  await access(dest);
  const handle = await open(dest, 'r+');
  await handle.datasync();
  await handle.sync();
  const buf = Buffer.from('hello world');
  await handle.write(buf);
  const ret = await handle.read(Buffer.alloc(11), 0, 11, 0);
  assert.strictEqual(ret.bytesRead, 11);
  assert.deepStrictEqual(ret.buffer, buf);
  await handle.close();
}

validate();

```"
"```javascript:test\common\fixtures.js
'use strict';

import path from 'path';
import fs from 'fs';
import { pathToFileURL } from 'url';

const __dirname = path.join(args[0], '..');

const fixturesDir = path.join(__dirname, '..', 'fixtures');

function fixturesPath(...args) {
  return path.join(fixturesDir, ...args);
}

function fixturesFileURL(...args) {
  return pathToFileURL(fixturesPath(...args));
}

function readFixtureSync(args, enc) {
  if (Array.isArray(args))
    return fs.readFileSync(fixturesPath(...args), enc);
  return fs.readFileSync(fixturesPath(args), enc);
}

function readFixtureKey(name, enc) {
  return fs.readFileSync(fixturesPath('keys', name), enc);
}

function readFixtureKeys(enc, ...names) {
  return names.map((name) => readFixtureKey(name, enc));
}

export {
  fixturesDir,
  fixturesPath as path,
  fixturesFileURL as fileURL,
  readFixtureSync as readSync,
  readFixtureKey as readKey,
  readFixtureKeys as readKeys,
};

export default {
  fixturesDir,
  path: fixturesPath,
  fileURL: fixturesFileURL,
  readSync: readFixtureSync,
  readKey: readFixtureKey,
  readKeys: readFixtureKeys,
}

```"
"```javascript:test\fs\test-fs-write-stream-patch-open.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

import assert from 'assert';
import { fork } from 'child_process';

// Run in a child process because 'out' is opened twice, blocking the tmpdir
// and preventing cleanup.
if (process.argv[2] !== 'child') {
  // Parent

  tmpdir.refresh();

  // Run test
  const child = fork(__filename, ['child'], { stdio: 'inherit' });
  child.on('exit', common.mustCall(function(code) {
    assert.strictEqual(code, 0);
  }));

  return;
}

// Child

common.expectWarning(
  'DeprecationWarning',
  'WriteStream.prototype.open() is deprecated', 'DEP0135');
const s = fs.createWriteStream(`${tmpdir.path}/out`);
s.open();

process.nextTick(() => {
  // Allow overriding open().
  fs.WriteStream.prototype.open = common.mustCall();
  fs.createWriteStream('asd');
});

```"
"```javascript:example_js\wasi_net_timeout_echo.js
import * as net from 'wasi_net';
import { TextDecoder } from 'util'


async function handle_client(cs) {
  print(cs.peer());
  let timeout_millis = 5000;
  while (true) {
    try {
      let d = await cs.read(timeout_millis);
      if (d.byteLength <= 0) {
        break;
      }
      let s = new TextDecoder().decode(d)
      print('recv:', s);
      cs.write('echo:' + s);
    } catch (e) {
      print('handle_client err:', e);
      break;
    }
  }
  print('close');
}

async function server_start() {
  print('listen 8000 ...');
  let s = new net.WasiTcpServer(8000);
  let timeout_millis = 5000;
  for (var i = 0; i < 10; i++) {
    try {
      let cs = await s.accept(timeout_millis);
      handle_client(cs);
    } catch (e) {
      print('accept err:', e);
    }
  }
}


server_start();

```"
"```javascript:modules\internal\util\colors.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import process from ""process"";

let blue = '';
let green = '';
let white = '';
let red = '';
let clear = '';
let hasColors = false;
export function refresh() {
  if (true || process.stderr.isTTY) {
    hasColors = true || process.stderr.hasColors();
    blue = hasColors ? '\u001b[34m' : '';
    green = hasColors ? '\u001b[32m' : '';
    white = hasColors ? '\u001b[39m' : '';
    red = hasColors ? '\u001b[31m' : '';
    clear = hasColors ? '\u001bc' : '';
    hasColors = hasColors;
  }
}

export {
  blue,
  green,
  white,
  red,
  clear,
  hasColors
}

refresh();

```"
"```javascript:test\fs\test-fs-watch-abort-signal.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

// Verify that AbortSignal integration works for fs.watch

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import fs from 'fs';
import fixtures from '../common/fixtures';


{
  // Signal aborted after creating the watcher
  const file = fixtures.path('empty.js');
  const ac = new AbortController();
  const { signal } = ac;
  const watcher = fs.watch(file, { signal });
  watcher.once('close', common.mustCall());
  setImmediate(() => ac.abort());
}
{
  // Signal aborted before creating the watcher
  const file = fixtures.path('empty.js');
  const signal = AbortSignal.abort();
  const watcher = fs.watch(file, { signal });
  watcher.once('close', common.mustCall());
}

```"
"```javascript:test\fs\test-fs-filehandle-use-after-close.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs/promises';

const __filename = args[0];

(async () => {
  const filehandle = await fs.open(__filename);

  assert.notStrictEqual(filehandle.fd, -1);
  await filehandle.close();
  assert.strictEqual(filehandle.fd, -1);

  // Open another file handle first. This would typically receive the fd
  // that `filehandle` previously used. In earlier versions of Node.js, the
  // .stat() call would then succeed because it still used the original fd;
  // See https://github.com/nodejs/node/issues/31361 for more details.
  const otherFilehandle = await fs.open(""test/fixtures/x.txt"");

  assert.rejects(() => filehandle.stat(), {
    code: 'EBADF',
    syscall: 'fstat'
  });

  await otherFilehandle.close();
})().then(common.mustCall());

```"
"```javascript:test\crypto\test-crypto-update-encoding.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const crypto = require('crypto');

const zeros = Buffer.alloc;
const key = zeros(16);
const iv = zeros(16);

const cipher = () => crypto.createCipheriv('aes-128-cbc', key, iv);
const decipher = () => crypto.createDecipheriv('aes-128-cbc', key, iv);
const hash = () => crypto.createSign('sha256');
const hmac = () => crypto.createHmac('sha256', key);
const sign = () => crypto.createSign('sha256');
const verify = () => crypto.createVerify('sha256');

for (const f of [cipher, decipher, hash, hmac, sign, verify])
  for (const n of [15, 16])
    f().update(zeros(n), 'hex');  // Should ignore inputEncoding.

```"
"```javascript:test\fs\test-fs-rmdir-recursive-throws-on-file.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

const code = common.isWindows ? 'ENOENT' : 'ENOTDIR';

{
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  assert.throws(() => fs.rmdirSync(filePath, { recursive: true }), { code });
}
{
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  fs.rmdir(filePath, { recursive: true }, common.mustCall((err) => {
    assert.strictEqual(err.code, code);
  }));
}
{
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  assert.rejects(() => fs.promises.rmdir(filePath, { recursive: true }),
                 { code }).then(common.mustCall());
}

```"
"```javascript:test\fs\test-fs-symlink-longpath.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();
const tmpDir = tmpdir.path;
const longPath = path.join(...[tmpDir].concat(Array(30).fill('1234567890')));
fs.mkdirSync(longPath, { recursive: true });

// Test if we can have symlinks to files and folders with long filenames
const targetDirectory = path.join(longPath, 'target-directory');
fs.mkdirSync(targetDirectory);
const pathDirectory = path.join(tmpDir, 'new-directory');
fs.symlink(targetDirectory, pathDirectory, 'dir', common.mustSucceed(() => {
  assert(fs.existsSync(pathDirectory));
}));

const targetFile = path.join(longPath, 'target-file');
fs.writeFileSync(targetFile, 'data');
const pathFile = path.join(tmpDir, 'new-file');
fs.symlink(targetFile, pathFile, common.mustSucceed(() => {
  assert(fs.existsSync(pathFile));
}));

```"
"```javascript:example_js\wasi_https_fetch.js
import { fetch } from 'http'

async function test_fetch() {
    try {
        print('test_fetch start')
        let r = await fetch('https://httpbin.org/get?id=1')
        print('test_fetch\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch()

async function test_fetch_post() {
    try {
        print('test_fetch_post start')
        let r = await fetch(""https://httpbin.org/post"", { method: 'post', 'body': 'post_body' })
        print('test_fetch_post\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_post()

async function test_fetch_put() {
    try {
        print('test_fetch_put start')
        let r = await fetch(""https://httpbin.org/put"",
            {
                method: ""put"",
                body: JSON.stringify({ a: 1 }),
                headers: { 'Context-type': 'application/json' }
            })
        print('test_fetch_put\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_put()
```"
"```javascript:test\fs\test-fs-watch-stop-sync.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// This test checks that the `stop` event is emitted asynchronously.
//
// If it isn't asynchronous, then the listener will be called during the
// execution of `watch.stop()`. That would be a bug.
//
// If it is asynchronous, then the listener will be removed before the event is
// emitted.

import fs from 'fs';

const listener = common.mustNotCall(
  'listener should have been removed before the event was emitted'
);

const watch = fs.watchFile(__filename, common.mustNotCall());
watch.once('stop', listener);
watch.stop();
watch.removeListener('stop', listener);

```"
"```javascript:test\fs\test-fs-write-stream-encoding.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import fixtures from '../common/fixtures';
import fs from 'fs';
import path from 'path';
import stream from 'stream';
import tmpdir from '../common/tmpdir';
const firstEncoding = 'base64';
const secondEncoding = 'latin1';

const examplePath = fixtures.path('x.txt');
const dummyPath = path.join(tmpdir.path, 'x.txt');

tmpdir.refresh();

const exampleReadStream = fs.createReadStream(examplePath, {
  encoding: firstEncoding
});

const dummyWriteStream = fs.createWriteStream(dummyPath, {
  encoding: firstEncoding
});

exampleReadStream.pipe(dummyWriteStream).on('finish', function() {
  const assertWriteStream = new stream.Writable({
    write: function(chunk, enc, next) {
      const expected = Buffer.from('xyz\n');
      assert(chunk.equals(expected));
    }
  });
  assertWriteStream.setDefaultEncoding(secondEncoding);
  fs.createReadStream(dummyPath, {
    encoding: secondEncoding
  }).pipe(assertWriteStream);
});

```"
"```javascript:test\crypto\test-crypto-classes.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
const assert = require('assert');

if (!common.hasCrypto) {
  common.skip('missing crypto');
  return;
}
const crypto = require('crypto');

// 'ClassName' : ['args', 'for', 'constructor']
const TEST_CASES = {
  'Hash': ['sha1'],
  'Hmac': ['sha1', 'Node'],
  'Cipheriv': ['des-ede3-cbc', '0123456789abcd0123456789', '12345678'],
  'Decipheriv': ['des-ede3-cbc', '0123456789abcd0123456789', '12345678'],
  'Sign': ['RSA-SHA1'],
  'Verify': ['RSA-SHA1'],
  'DiffieHellman': [1024],
  'DiffieHellmanGroup': ['modp5'],
  'ECDH': ['prime256v1'],
};

if (!common.hasFipsCrypto) {
  TEST_CASES.Cipher = ['aes192', 'secret'];
  TEST_CASES.Decipher = ['aes192', 'secret'];
  TEST_CASES.DiffieHellman = [common.hasOpenSSL3 ? 1024 : 256];
}

for (const [clazz, args] of Object.entries(TEST_CASES)) {
  assert(crypto[`create${clazz}`](...args) instanceof crypto[clazz]);
}

```"
"```javascript:test\fs\test-fs-open-no-close.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Refs: https://github.com/nodejs/node/issues/34266
// Failing to close a file should not keep the event loop open.

import common from '../common';
import assert from 'assert';

import fs from 'fs';

import process from 'process';

const debuglog = (arg) => {
  console.log(new Date().toLocaleString(), arg);
};

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

let openFd;

fs.open(`${tmpdir.path}/dummy`, 'wx+', common.mustCall((err, fd) => {
  debuglog('fs open() callback');
  assert.ifError(err);
  openFd = fd;
}));
debuglog('waiting for callback');

// test_fs's runner will invoke this
globalThis._onExit = common.mustCall(() => {
  if (openFd) {
    fs.closeSync(openFd);
  }
});

```"
"```javascript:test\fs\test-fs-readdir-ucs2.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
if (!common.isLinux)
  common.skip('Test is linux specific.');

import path from 'path';
import fs from 'fs';
import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();
const filename = '\uD83D\uDC04';
const root = Buffer.from(`${tmpdir.path}${path.sep}`);
const filebuff = Buffer.from(filename, 'ucs2');
const fullpath = Buffer.concat([root, filebuff]);

try {
  fs.closeSync(fs.openSync(fullpath, 'w+'));
} catch (e) {
  if (e.code === 'EINVAL')
    common.skip('test requires filesystem that supports UCS2');
  throw e;
}

fs.readdir(tmpdir.path, 'ucs2', common.mustSucceed((list) => {
  assert.strictEqual(list.length, 1);
  const fn = list[0];
  assert.deepStrictEqual(Buffer.from(fn, 'ucs2'), filebuff);
  assert.strictEqual(fn, filename);
}));

```"
"```javascript:test\fs\test-fs-write-stream-double-close.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  const s = fs.createWriteStream(path.join(tmpdir.path, 'rw'));

  s.close(common.mustCall());
  s.close(common.mustCall());
}

{
  const s = fs.createWriteStream(path.join(tmpdir.path, 'rw2'));

  let emits = 0;
  s.on('close', () => {
    emits++;
  });

  s.close(common.mustCall(() => {
    assert.strictEqual(emits, 1);
    s.close(common.mustCall(() => {
      assert.strictEqual(emits, 1);
    }));
    process.nextTick(() => {
      s.close(common.mustCall(() => {
        assert.strictEqual(emits, 1);
      }));
    });
  }));
}

{
  const s = fs.createWriteStream(path.join(tmpdir.path, 'rw'), {
    autoClose: false
  });

  s.close(common.mustCall());
  s.close(common.mustCall());
}

```"
"```javascript:test\fs\test-fs-promises-writefile-typedarray.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
const fsPromises = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

const dest = path.resolve(tmpDir, 'tmp.txt');
const buffer = Buffer.from('012'.repeat(2 ** 10));

(async () => {
  for (const Constructor of [Uint8Array, Uint16Array, Uint32Array]) {
    const { BYTES_PER_ELEMENT = 1 } = Constructor;
    const array = new Constructor(buffer.buffer, buffer.byteOffset, buffer.byteLength / BYTES_PER_ELEMENT);
    await fsPromises.writeFile(dest, array);
    const data = await fsPromises.readFile(dest);
    assert.deepStrictEqual(data, buffer);
  }
})().then(common.mustCall());

```"
"```javascript:test\fs\test-fs-realpath-pipe.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';

import { spawnSync } from 'child_process';

for (const code of [
  `require('fs').realpath('/dev/stdin', (err, resolvedPath) => {
    if (err) {
      console.error(err);
      process.exit(1);
    }
    if (resolvedPath) {
      process.exit(2);
    }
  });`,
  `try {
    if (require('fs').realpathSync('/dev/stdin')) {
      process.exit(2);
    }
  } catch (e) {
    console.error(e);
    process.exit(1);
  }`,
]) {
  const child = spawnSync(process.execPath, ['-e', code], {
    stdio: 'pipe'
  });
  if (child.status !== 2) {
    console.log(code);
    console.log(child.stderr.toString());
  }
  assert.strictEqual(child.status, 2);
}

```"
"```javascript:test\fs\test-fs-stream-destroy-emit-error.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  const stream = fs.createReadStream(__filename);
  stream.on('close', common.mustCall());
  test(stream);
}

{
  const stream = fs.createWriteStream(`${tmpdir.path}/dummy`);
  stream.on('close', common.mustCall());
  test(stream);
}

{
  const stream = fs.createReadStream(__filename, { emitClose: true });
  stream.on('close', common.mustCall());
  test(stream);
}

{
  const stream = fs.createWriteStream(`${tmpdir.path}/dummy2`,
                                      { emitClose: true });
  stream.on('close', common.mustCall());
  test(stream);
}


function test(stream) {
  const err = new Error('DESTROYED');
  stream.on('open', function() {
    stream.destroy(err);
  });
  stream.on('error', common.mustCall(function(err_) {
    assert.strictEqual(err_, err);
  }));
}

```"
"```javascript:test\fs\test-fs-truncate-fd.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const tmp = tmpdir.path;
tmpdir.refresh();
const filename = path.resolve(tmp, 'truncate-file.txt');

fs.writeFileSync(filename, 'hello world', 'utf8');
const fd = fs.openSync(filename, 'r+');

const msg = 'Using fs.truncate with a file descriptor is deprecated.' +
  ' Please use fs.ftruncate with a file descriptor instead.';


common.expectWarning('DeprecationWarning', msg, 'DEP0081');
fs.truncate(fd, 5, common.mustSucceed(() => {
  assert.strictEqual(fs.readFileSync(filename, 'utf8'), 'hello');
}));

globalThis.commonExitCheck = () => {
  fs.closeSync(fd);
  fs.unlinkSync(filename);
  console.log('ok');
};

```"
"```javascript:example_js\react18_ssr\component\Html.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'

export default function Html({ assets, children, title }) {

  return (
    <html lang=""en"">
      <head>
        <meta charSet=""utf-8"" />
        <meta name=""viewport"" content=""width=device-width, initial-scale=1"" />
        <link rel=""stylesheet"" href={assets['main.css']} />
        <title>{title}</title>
      </head>
      <body>
        <noscript
          dangerouslySetInnerHTML={{
            __html: `<b>Enable JavaScript to run this app.</b>`,
          }}
        />
        {children}
        <script
          dangerouslySetInnerHTML={{
            __html: `assetManifest = ${JSON.stringify(assets)};`,
          }}
        />
      </body>
    </html>
  );
}

```"
"```javascript:test\fs\test-fs-stream-options.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import { mustNotMutateObjectDeep } from '../common';

import assert from 'assert';
import fs from 'fs';

{
  const fd = 'k';

  assert.throws(
    () => {
      fs.createReadStream(null, mustNotMutateObjectDeep({ fd }));
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => {
      fs.createWriteStream(null, mustNotMutateObjectDeep({ fd }));
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

{
  const path = 46;

  assert.throws(
    () => {
      fs.createReadStream(path);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => {
      fs.createWriteStream(path);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

```"
"```javascript:example_js\wasi_http_fetch.js
import { fetch } from 'http'

async function test_fetch() {
    try {
        let r = await fetch('http://httpbin.org/get?id=1')
        print('test_fetch\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch()

async function test_fetch_post() {
    try {
        let r = await fetch(""http://httpbin.org/post"", { method: 'post', 'body': 'post_body' })
        print('test_fetch_post\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_post()

async function test_fetch_put() {
    try {
        let r = await fetch(""http://httpbin.org/put"",
            {
                method: ""put"",
                body: JSON.stringify({ a: 1 }),
                headers: { 'Context-type': 'application/json' }
            })
        print('test_fetch_put\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_put()
```"
"```javascript:test\fs\test-fs-readfilesync-enoent.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// This test is only relevant on Windows.
if (!common.isWindows)
  common.skip('Windows specific test.');

// This test ensures fs.realpathSync works on properly on Windows without
// throwing ENOENT when the path involves a fileserver.
// https://github.com/nodejs/node-v0.x-archive/issues/3542

import assert from 'assert';
import fs from 'fs';
import os from 'os';
import path from 'path';

function test(p) {
  const result = fs.realpathSync(p);
  assert.strictEqual(result.toLowerCase(), path.resolve(p).toLowerCase());

  fs.realpath(p, common.mustSucceed((result) => {
    assert.strictEqual(result.toLowerCase(), path.resolve(p).toLowerCase());
  }));
}

test(`//${os.hostname()}/c$/Windows/System32`);
test(`//${os.hostname()}/c$/Windows`);
test(`//${os.hostname()}/c$/`);
test(`\\\\${os.hostname()}\\c$\\`);
test('C:\\');
test('C:');
test(process.env.windir);

```"
"The following document is located at example_js\react_ssr_stream\component\LazyHome.jsx
------
import React, { Suspense } from 'react';
import * as LazyPage from './LazyPage.jsx';

async function sleep(ms) {
    return new Promise((r, _) => {
        setTimeout(() => r(), ms)
    });
}

async function loadLazyPage() {
    await sleep(2000);
    return LazyPage
}

class LazyHome extends React.Component {
    render() {
        let LazyPage1 = React.lazy(() => loadLazyPage());
        return (
            <html lang=""en"">
                <head>
                    <meta charSet=""utf-8"" />
                    <title>Title</title>
                </head>
                <body>
                    <div>
                        <div> This is LazyHome </div>
                        <Suspense fallback={<div> loading... </div>}>
                            <LazyPage1 />
                        </Suspense>
                    </div>
                </body>
            </html>
        );
    }
}

export default LazyHome;

------"
"```javascript:test\crypto\test-crypto-dh-modp2-views.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { modp2buf } = require('../common/crypto');

const modp2 = crypto.createDiffieHellmanGroup('modp2');

const views = common.getArrayBufferViews(modp2buf);
for (const buf of [modp2buf, ...views]) {
  // Ensure specific generator (string with encoding) works as expected with
  // any ArrayBufferViews as the first argument to createDiffieHellman().
  const exmodp2 = crypto.createDiffieHellman(buf, '02', 'hex');
  modp2.generateKeys();
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}

```"
"```javascript:example_js\create-react-app-ssr\rollup.server.js
const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');
const css = require(""rollup-plugin-import-css"");
const svg = require('rollup-plugin-svg');

const babelOptions = {
  babelrc: false,
  presets: [
    '@babel/preset-react'
  ],
  babelHelpers: 'bundled'
};

module.exports = [
  {
    input: './server/index.js',
    output: {
      file: 'server-build/index.js',
      format: 'esm',
    },
    external: [ 'std', 'wasi_net','wasi_http'],
    plugins: [
      plugin_async(),
      babel(babelOptions),
      nodeResolve({preferBuiltins: true}),
      commonjs({ignoreDynamicRequires: false}),
      css(),
      svg({base64: true}),
      globals(),
      builtins(),
      replace({
        preventAssignment: true,	
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];

```"
"```javascript:test\fs\test-fs-read-promises-optional-params.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import { promisify } from 'util';
const read = promisify(fs.read);
import assert from 'assert';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');

const expected = Buffer.from('xyz\n');
const defaultBufferAsync = Buffer.alloc(16384);
const bufferAsOption = Buffer.allocUnsafe(expected.byteLength);

read(fd, common.mustNotMutateObjectDeep({}))
  .then(function({ bytesRead, buffer }) {
    assert.strictEqual(bytesRead, expected.byteLength);
    assert.deepStrictEqual(defaultBufferAsync.byteLength, buffer.byteLength);
  })
  .then(common.mustCall());

read(fd, bufferAsOption, common.mustNotMutateObjectDeep({ position: 0 }))
  .then(function({ bytesRead, buffer }) {
    assert.strictEqual(bytesRead, expected.byteLength);
    assert.deepStrictEqual(bufferAsOption.byteLength, buffer.byteLength);
  })
  .then(common.mustCall());

```"
"```javascript:test\crypto\test-crypto-des3-wrap.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

// Test case for des-ede3 wrap/unwrap. des3-wrap needs extra 2x blocksize
// then plaintext to store ciphertext.
const test = {
  key: Buffer.from('3c08e25be22352910671cfe4ba3652b1220a8a7769b490ba', 'hex'),
  iv: Buffer.alloc(0),
  plaintext: '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBG' +
    'WWELweCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZU' +
    'JjAfaFg**'
};

const cipher = crypto.createCipheriv('des3-wrap', test.key, test.iv);
const ciphertext = cipher.update(test.plaintext, 'utf8');

const decipher = crypto.createDecipheriv('des3-wrap', test.key, test.iv);
const msg = decipher.update(ciphertext, 'buffer', 'utf8');

assert.strictEqual(msg, test.plaintext);

```"
"```javascript:test\crypto\test-crypto-lazy-transform-writable.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const Stream = require('stream');

const hasher1 = crypto.createHash('sha256');
const hasher2 = crypto.createHash('sha256');

// Calculate the expected result.
hasher1.write(Buffer.from('hello world'));
hasher1.end();

const expected = hasher1.read().toString('hex');

class OldStream extends Stream {
  constructor() {
    super();
    this.readable = true;
  }
}

const stream = new OldStream();

stream.pipe(hasher2).on('finish', common.mustCall(function() {
  const hash = hasher2.read().toString('hex');
  assert.strictEqual(hash, expected);
}));

stream.emit('data', Buffer.from('hello'));
stream.emit('data', Buffer.from(' world'));
stream.emit('end');

```"
"```javascript:test\fs\test-fs-write-stream-fs.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

tmpdir.refresh();

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');
  const stream = fs.createWriteStream(file, {
    fs: {
      open: common.mustCall(fs.open),
      write: common.mustCallAtLeast(fs.write, 1),
      close: common.mustCall(fs.close),
    }
  });
  stream.end('asd');
  stream.on('close', common.mustCall());
}


{
  const file = path.join(tmpdir.path, 'write-end-test1.txt');
  const stream = fs.createWriteStream(file, {
    fs: {
      open: common.mustCall(fs.open),
      write: fs.write,
      writev: common.mustCallAtLeast(fs.writev, 1),
      close: common.mustCall(fs.close),
    }
  });
  stream.write('asd');
  stream.write('asd');
  stream.write('asd');
  stream.end();
  stream.on('close', common.mustCall());
}

```"
"```javascript:test\fs\test-fs-makeStatsCallback.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
const callbackThrowValues = [null, true, false, 0, 1, 'foo', /foo/, [], {}];

const __filename = args[0];

function testMakeStatsCallback(cb) {
  return function() {
    // fs.stat() calls makeStatsCallback() on its second argument
    fs.stat(__filename, cb);
  };
}

// Verify the case where a callback function is provided
testMakeStatsCallback(common.mustCall())();

function invalidCallbackThrowsTests() {
  callbackThrowValues.forEach((value) => {
    assert.throws(testMakeStatsCallback(value), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  });
}

invalidCallbackThrowsTests();

```"
"```javascript:test\fs\test-fs-rmdir-recursive-sync-warns-not-found.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  // Should warn when trying to delete a nonexistent path
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  assert.throws(
    () => fs.rmdirSync(path.join(tmpdir.path, 'noexist.txt'),
                       { recursive: true }),
    { code: 'ENOENT' }
  );
}

```"
"```javascript:test\fs\test-fs-rmdir-recursive-sync-warns-on-file.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  assert.throws(
    () => fs.rmdirSync(filePath, { recursive: true }),
    { code: common.isWindows ? 'ENOENT' : 'ENOTDIR' }
  );
}

```"
"```javascript:test\fs\test-fs-stream-construct-compat-error-read.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat error.

  function ReadStream(...args) {
    fs.ReadStream.call(this, ...args);
  }
  Object.setPrototypeOf(ReadStream.prototype, fs.ReadStream.prototype);
  Object.setPrototypeOf(ReadStream, fs.ReadStream);

  ReadStream.prototype.open = common.mustCall(function ReadStream$open() {
    const that = this;
    fs.open(that.path, that.flags, that.mode, (err, fd) => {
      that.emit('error', err);
    });
  });

  const r = new ReadStream('/doesnotexist', { emitClose: true })
    .on('error', common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
      assert.strictEqual(r.destroyed, true);
      r.on('close', common.mustCall());
    }));
}

```"
"```javascript:test\fs\test-fs-rmdir-recursive-warns-on-file.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  fs.rmdir(filePath, { recursive: true }, common.mustCall((err) => {
    assert.strictEqual(err.code, common.isWindows ? 'ENOENT' : 'ENOTDIR');
  }));
}

```"
"```javascript:test\fs\test-fs-rmdir-recursive-throws-not-found.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  assert.throws(
    () =>
      fs.rmdirSync(path.join(tmpdir.path, 'noexist.txt'), { recursive: true }),
    {
      code: 'ENOENT',
    }
  );
}
{
  fs.rmdir(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true },
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
    })
  );
}
{
  assert.rejects(
    () => fs.promises.rmdir(path.join(tmpdir.path, 'noexist.txt'),
                            { recursive: true }),
    {
      code: 'ENOENT',
    }
  ).then(common.mustCall());
}

```"
"```javascript:test\fs\test-fs-make-callback.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
const callbackThrowValues = [null, true, false, 0, 1, 'foo', /foo/, [], {}];

import { sep } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function testMakeCallback(cb) {
  return function() {
    // fs.mkdtemp() calls makeCallback() on its third argument
    fs.mkdtemp(`${tmpdir.path}${sep}`, {}, cb);
  };
}

function invalidCallbackThrowsTests() {
  callbackThrowValues.forEach((value) => {
    assert.throws(testMakeCallback(value), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  });
}

invalidCallbackThrowsTests();

```"
"```javascript:test\fs\test-fs-write-stream-throw-type-error.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const example = path.join(tmpdir.path, 'dummy');

tmpdir.refresh();
// Should not throw.
fs.createWriteStream(example, undefined).end();
fs.createWriteStream(example, null).end();
fs.createWriteStream(example, 'utf8').end();
fs.createWriteStream(example, { encoding: 'utf8' }).end();

const createWriteStreamErr = (path, opt) => {
  assert.throws(
    () => {
      fs.createWriteStream(path, opt);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
};

createWriteStreamErr(example, 123);
createWriteStreamErr(example, 0);
createWriteStreamErr(example, true);
createWriteStreamErr(example, false);

```"
"```javascript:test\fs\test-fs-promises-file-handle-truncate.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import { open, readFile } from 'fs/promises';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

async function validateTruncate() {
  const text = 'Hello world';
  const filename = path.resolve(tmpdir.path, 'truncate-file.txt');
  const fileHandle = await open(filename, 'w+');

  const buffer = Buffer.from(text, 'utf8');
  await fileHandle.write(buffer, 0, buffer.length);

  assert.strictEqual((await readFile(filename)).toString(), text);

  await fileHandle.truncate(5);
  assert.strictEqual((await readFile(filename)).toString(), 'Hello');

  await fileHandle.close();
}

validateTruncate().then(common.mustCall());

```"
"```javascript:test\fs\test-fs-watchfile-ref-unref.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import fs from 'fs';
import assert from 'assert';

const uncalledListener = common.mustNotCall();
const uncalledListener2 = common.mustNotCall();
const watcher = fs.watchFile(__filename, uncalledListener);

watcher.unref();
watcher.unref();
watcher.ref();
watcher.unref();
watcher.ref();
watcher.ref();
watcher.unref();

fs.unwatchFile(__filename, uncalledListener);

// Watch the file with two different listeners.
fs.watchFile(__filename, uncalledListener);
const watcher2 = fs.watchFile(__filename, uncalledListener2);

setTimeout(
  common.mustCall(() => {
    fs.unwatchFile(__filename, common.mustNotCall());
    assert.strictEqual(watcher2.listenerCount('change'), 2);
    fs.unwatchFile(__filename, uncalledListener);
    assert.strictEqual(watcher2.listenerCount('change'), 1);
    watcher2.unref();
  }),
  common.platformTimeout(100)
);

```"
"```javascript:test\crypto\test-crypto-modp1-error.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

assert.throws(
  function() {
    crypto.getDiffieHellman('modp1').setPrivateKey('');
  },
  new RegExp('^TypeError: crypto\\.getDiffieHellman\\(\\.\\.\\.\\)\\.' +
  'setPrivateKey is not a function$'),
  'crypto.getDiffieHellman(\'modp1\').setPrivateKey(\'\') ' +
  'failed to throw the expected error.'
);
assert.throws(
  function() {
    crypto.getDiffieHellman('modp1').setPublicKey('');
  },
  new RegExp('^TypeError: crypto\\.getDiffieHellman\\(\\.\\.\\.\\)\\.' +
  'setPublicKey is not a function$'),
  'crypto.getDiffieHellman(\'modp1\').setPublicKey(\'\') ' +
  'failed to throw the expected error.'
);

```"
"```javascript:test\fs\test-fs-promises-file-handle-stat.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.stat method.

import { open } from 'fs/promises';
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';

tmpdir.refresh();

async function validateStat() {
  const filePath = path.resolve(tmpdir.path, 'tmp-read-file.txt');
  const fileHandle = await open(filePath, 'w+');
  const stats = await fileHandle.stat();
  assert.ok(stats.mtime instanceof Date);
  await fileHandle.close();
}

validateStat()
  .then(common.mustCall());

```"
"```javascript:test\fs\test-fs-rmdir-recursive-warns-not-found.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  // Should warn when trying to delete a nonexistent path
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  fs.rmdir(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true },
    common.mustCall()
  );
}

```"
"```javascript:test\fs\test-fs-mkdtemp-prefix-check.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const prefixValues = [undefined, null, 0, true, false, 1];

function fail(value) {
  assert.throws(
    () => {
      fs.mkdtempSync(value, {});
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
}

function failAsync(value) {
  assert.throws(
    () => {
      fs.mkdtemp(value, common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
}

prefixValues.forEach((prefixValue) => {
  fail(prefixValue);
  failAsync(prefixValue);
});

```"
"```javascript:test\fs\test-fs-ready-event-stream.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';

const __filename = args[0];

const readStream = fs.createReadStream(__filename);
assert.strictEqual(readStream.pending, true);
readStream.on('ready', common.mustCall(() => {
  assert.strictEqual(readStream.pending, false);
}));

const writeFile = path.join(tmpdir.path, 'write-fsreadyevent.txt');
tmpdir.refresh();
const writeStream = fs.createWriteStream(writeFile, { autoClose: true });
assert.strictEqual(writeStream.pending, true);
writeStream.on('ready', common.mustCall(() => {
  assert.strictEqual(writeStream.pending, false);
  writeStream.end();
}));

```"
"The following document is located at example_js\create-react-app-ssr\src\App.css
------
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

------"
"```javascript:example_js\react18_ssr\component\Sidebar.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Sidebar() {
  return (
    <>
      <h1>Archive</h1>
      <ul>
        <li>May 2021</li>
        <li>April 2021</li>
        <li>March 2021</li>
        <li>February 2021</li>
        <li>January 2021</li>
        <li>December 2020</li>
        <li>November 2020</li>
        <li>October 2020</li>
        <li>September 2020</li>
      </ul>
    </>
  );
}

```"
"```javascript:test\crypto\test-crypto-webcrypto-aes-decrypt-tag-too-small.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto').webcrypto;

crypto.subtle.importKey(
  'raw',
  new Uint8Array(32),
  {
    name: 'AES-GCM'
  },
  false,
  [ 'encrypt', 'decrypt' ])
  .then((k) => {
    assert.rejects(() => {
      return crypto.subtle.decrypt({
        name: 'AES-GCM',
        iv: new Uint8Array(12),
      }, k, new Uint8Array(0));
    }, {
      name: 'OperationError',
      message: /The provided data is too small/,
    });
  });

```"
"```javascript:test\fs\test-fs-read-zero-length.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');
const bufferAsync = Buffer.alloc(0);
const bufferSync = Buffer.alloc(0);

fs.read(fd, bufferAsync, 0, 0, 0, common.mustCall((err, bytesRead) => {
  assert.strictEqual(bytesRead, 0);
  assert.deepStrictEqual(bufferAsync, Buffer.alloc(0));
}));

const r = fs.readSync(fd, bufferSync, 0, 0, 0);
assert.deepStrictEqual(bufferSync, Buffer.alloc(0));
assert.strictEqual(r, 0);

```"
"```javascript:test\fs\test-fs-write-stream-file-handle.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'write_stream_filehandle_test.txt');
const input = 'hello world';

tmpdir.refresh();

fs.promises.open(file, 'w+').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createWriteStream(null, { fd: handle });

  stream.end(input);
  stream.on('close', common.mustCall(() => {
    const output = fs.readFileSync(file, 'utf-8');
    assert.strictEqual(output, input);
  }));
}).then(common.mustCall());

```"
"```javascript:example_js\react18_ssr\component\Comments.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
import { useData } from './data';

export default function Comments() {
  const comments = useData();
  return (
    <>
      {comments.map((comment, i) => (
        <p className=""comment"" key={i}>
          {comment}
        </p>
      ))}
    </>
  );
}

```"
"```javascript:example_js\simple_common_js_demo\rollup.config.js
const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');


const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net','std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ignoreDynamicRequires: false}),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```"
"```javascript:test\crypto\test-crypto-worker-thread.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

// Issue https://github.com/nodejs/node/issues/35263
// Description: Test that passing keyobject to worker thread does not crash.
const { createSecretKey } = require('crypto');

const { Worker, isMainThread, workerData } = require('worker_threads');

if (isMainThread) {
  const key = createSecretKey(Buffer.from('hello'));
  new Worker(__filename, { workerData: key });
} else {
  console.log(workerData);
}

```"
"```javascript:example_js\react_ssr_stream\rollup.config.js
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const plugin_async = require('rollup-plugin-async');


const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './main.mjs',
    output: {
      inlineDynamicImports: true,
      file: 'dist/main.mjs',
      format: 'esm',
    },
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ ignoreDynamicRequires: false }),
      babel(babelOptions),
      globals(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```"
"```javascript:modules\timers\promises.js
import { promisify } from 'util.js';
import exports from 'timers.js';

function promisifySetTimeout(delay, value, _option) {
    return new Promise((resolve, _reject) => {
        exports.setTimeout(resolve(value), delay)
    })
}

function promisifySetImmediate(delay, value, _option) {
    return new Promise((resolve, _reject) => {
        exports.setImmediate(resolve(value), delay)
    })
}

const setTimeout = promisifySetTimeout,
    setImmediate = promisifySetImmediate,
    setInterval = promisify(exports.setInterval);

var promises = {
    setTimeout,
    setImmediate,
    setInterval
};

export { promises as default, setImmediate, setInterval, setTimeout };

```"
"```javascript:test\path\test-path-isabsolute.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import path from 'path';
/*
assert.strictEqual(path.win32.isAbsolute('/'), true);
assert.strictEqual(path.win32.isAbsolute('//'), true);
assert.strictEqual(path.win32.isAbsolute('//server'), true);
assert.strictEqual(path.win32.isAbsolute('//server/file'), true);
assert.strictEqual(path.win32.isAbsolute('\\\\server\\file'), true);
assert.strictEqual(path.win32.isAbsolute('\\\\server'), true);
assert.strictEqual(path.win32.isAbsolute('\\\\'), true);
assert.strictEqual(path.win32.isAbsolute('c'), false);
assert.strictEqual(path.win32.isAbsolute('c:'), false);
assert.strictEqual(path.win32.isAbsolute('c:\\'), true);
assert.strictEqual(path.win32.isAbsolute('c:/'), true);
assert.strictEqual(path.win32.isAbsolute('c://'), true);
assert.strictEqual(path.win32.isAbsolute('C:/Users/'), true);
assert.strictEqual(path.win32.isAbsolute('C:\\Users\\'), true);
assert.strictEqual(path.win32.isAbsolute('C:cwd/another'), false);
assert.strictEqual(path.win32.isAbsolute('C:cwd\\another'), false);
assert.strictEqual(path.win32.isAbsolute('directory/directory'), false);
assert.strictEqual(path.win32.isAbsolute('directory\\directory'), false);
*/
assert.strictEqual(path.posix.isAbsolute('/home/foo'), true);
assert.strictEqual(path.posix.isAbsolute('/home/foo/..'), true);
assert.strictEqual(path.posix.isAbsolute('bar/'), false);
assert.strictEqual(path.posix.isAbsolute('./baz'), false);

```"
"```javascript:example_js\react_ssr\rollup.config.js
const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals =  require('rollup-plugin-node-globals');
const builtins =  require('rollup-plugin-node-builtins');


const babelOptions = {
  ""presets"": [
    '@babel/preset-env',
    '@babel/preset-react'
  ]
}

module.exports = [
  {
    input: './main.js',
    output: {
      file: 'dist/main.js',
      format: 'umd',
    }, 
    plugins: [
      nodeResolve(),
      commonjs(),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify( 'production' )
      })
    ],
  },
]
```"
"```javascript:test\fs\test-fs-readv-promisify.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import { promisify } from 'util';
let readv = promisify(fs.readv);
import assert from 'assert';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');

const expected = [Buffer.from('xyz\n')];

readv(fd, expected)
  .then(function({ bytesRead, buffers }) {
    assert.deepStrictEqual(bytesRead, expected[0].length);
    assert.deepStrictEqual(buffers, expected);
  })
  .then(common.mustCall());

```"
"```javascript:example_js\react18_ssr\component\Spinner.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Spinner({active = true}) {
  return (
    <div
      className={['spinner', active && 'spinner--active'].join(' ')}
      role=""progressbar""
      aria-busy={active ? 'true' : 'false'}
    />
  );
}

```"
"```javascript:test\fs\test-fs-timestamp-parsing-error.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';

[Infinity, -Infinity, NaN].forEach((input) => {
  assert.throws(
    () => {
      fs._toUnixTimestamp(input);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
});

assert.throws(
  () => {
    fs._toUnixTimestamp({});
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

const okInputs = [1, -1, '1', '-1', Date.now()];
okInputs.forEach((input) => {
  fs._toUnixTimestamp(input);
});

```"
"```javascript:example_js\react18_ssr\rollup.config.js
const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const plugin_async = require('rollup-plugin-async');


const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './main.mjs',
    output: {
      inlineDynamicImports: true,
      file: 'dist/main.mjs',
      format: 'esm',
    },
    plugins: [
      babel(babelOptions),
      plugin_async(),
      nodeResolve(),
      commonjs({ignoreDynamicRequires: false}),
      globals(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
```"
"```javascript:example_js\create-react-app-ssr\webpack.server.js
const path = require('path');
module.exports = {
  entry: './server/index.js',
  externals: [
    {""wasi_http"": ""wasi_http""},
    {""wasi_net"": ""wasi_net""},
    {""std"": ""std""}
  ],
  output: {
    path: path.resolve('server-build'),
    filename: 'index.js',
    chunkFormat: ""module"",
    library: {
      type: ""module""
    },
  },
  experiments: {
    outputModule: true
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [""css-loader""]
      },
      {
        test: /\.svg$/,
        use: [""svg-url-loader""]
      }
    ]
  }
};

```"
"```javascript:test\fs\test-fs-buffertype-writesync.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// This test ensures that writeSync throws for invalid data input.

import assert from 'assert';
import fs from 'fs';

[
  true, false, 0, 1, Infinity, () => {}, {}, [], undefined, null,
].forEach((value) => {
  assert.throws(
    () => fs.writeSync(1, value),
    { message: /""buffer""/, code: 'ERR_INVALID_ARG_TYPE' }
  );
});

```"
"```javascript:test\fs\test-fs-watch-stop-async.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

import assert from 'assert';
import fs from 'fs';

const watch = fs.watchFile(__filename, common.mustNotCall());
let triggered;
const listener = common.mustCall(() => {
  triggered = true;
});

triggered = false;
watch.once('stop', listener);  // Should trigger.
watch.stop();
assert.strictEqual(triggered, false);
setImmediate(() => {
  assert.strictEqual(triggered, true);
  watch.removeListener('stop', listener);
});

```"
"```javascript:modules\internal\streams\passthrough.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import Transform from ""./transform.js"";

function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }

    Transform.call(this, options);
}

Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);

PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
};

export default PassThrough;
```"
"```javascript:test\fs\test-fs-read-stream-encoding.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import fs from 'fs';
import stream from 'stream';
import fixtures from '../common/fixtures';
const encoding = 'base64';

const example = fixtures.path('x.txt');
const assertStream = new stream.Writable({
  write: function(chunk, enc, next) {
    const expected = Buffer.from('xyz');
    assert(chunk.equals(expected));
  }
});
assertStream.setDefaultEncoding(encoding);
fs.createReadStream(example, encoding).pipe(assertStream);

```"
"```javascript:test\fs\test-fs-read-stream-patch-open.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';

common.expectWarning(
  'DeprecationWarning',
  'ReadStream.prototype.open() is deprecated', 'DEP0135');
const s = fs.createReadStream('asd')
  // We don't care about errors in this test.
  .on('error', () => {});
s.open();

process.nextTick(() => {
  // Allow overriding open().
  fs.ReadStream.prototype.open = common.mustCall();
  fs.createReadStream('asd');
});

```"
"```javascript:test\fs\test-fs-readlink-type-check.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.readlink(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.readlinkSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-rmdir-type-check.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.rmdir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.rmdirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-unlink-type-check.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.unlink(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.unlinkSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

```"
"```javascript:test\fs\test-fs-read-stream-autoClose.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
const writeFile = path.join(tmpdir.path, 'write-autoClose.txt');
tmpdir.refresh();

const file = fs.createWriteStream(writeFile, { autoClose: true });

file.on('finish', common.mustCall(() => {
  assert.strictEqual(file.destroyed, false);
}));
file.end('asd');

```"
"```javascript:test\fs\test-fs-open-numeric-flags.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// O_WRONLY without O_CREAT shall fail with ENOENT
const pathNE = path.join(tmpdir.path, 'file-should-not-exist');
assert.throws(
  () => fs.openSync(pathNE, fs.constants.O_WRONLY),
  (e) => e.code === 'ENOENT'
);

```"
"```javascript:example_js\react18_ssr\component\NavBar.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function NavBar() {
  return (
    <nav>
      <a href=""/"">Home</a>
    </nav>
  );
}

```"
"```javascript:test\fs\test-fs-read-stream-double-close.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';

{
  const s = fs.createReadStream(__filename);

  s.close(common.mustCall());
  s.close(common.mustCall());
}

{
  const s = fs.createReadStream(__filename);

  // This is a private API, but it is worth testing. close calls this
  s.destroy(null, common.mustCall());
  s.destroy(null, common.mustCall());
}

```"
"```javascript:test\fs\test-fs-truncate-sync.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const tmp = tmpdir.path;

tmpdir.refresh();

const filename = path.resolve(tmp, 'truncate-sync-file.txt');

fs.writeFileSync(filename, 'hello world', 'utf8');

const fd = fs.openSync(filename, 'r+');

fs.truncateSync(fd, 5);
assert(fs.readFileSync(fd).equals(Buffer.from('hello')));

fs.closeSync(fd);
fs.unlinkSync(filename);

```"
"```javascript:example_js\react18_ssr\component\index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
import {hydrateRoot} from 'react-dom';
import App from './App';

hydrateRoot(document, <App assets={window.assetManifest} />);

```"
"```javascript:test\crypto\test-crypto-randomfillsync-regression.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import { randomFillSync } from 'crypto';
import assert from 'assert';

const ab = new ArrayBuffer(20);
const buf = Buffer.from(ab, 10);

const before = buf.toString('hex');

randomFillSync(buf);

const after = buf.toString('hex');

assert.notStrictEqual(before, after);

```"
"```javascript:test\fs\test-fs-readdir-buffer.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';

if (!common.isOSX) {
  common.skip('this tests works only on MacOS');
}

import assert from 'assert';

fs.readdir(
  Buffer.from('/dev'),
  { withFileTypes: true, encoding: 'buffer' },
  common.mustCall((e, d) => {
    assert.strictEqual(e, null);
  })
);

```"
"```javascript:example_js\create-react-app-ssr\src\App.js
import React from 'react';
import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className=""App"">
      <header className=""App-header"">
        <img src={logo} className=""App-logo"" alt=""logo"" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className=""App-link""
          href=""https://reactjs.org""
          target=""_blank""
          rel=""noopener noreferrer""
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;

```"
"```javascript:test\crypto\test-crypto-dh-shared.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const alice = crypto.createDiffieHellmanGroup('modp5');
const bob = crypto.createDiffieHellmanGroup('modp5');
alice.generateKeys();
bob.generateKeys();
const aSecret = alice.computeSecret(bob.getPublicKey()).toString('hex');
const bSecret = bob.computeSecret(alice.getPublicKey()).toString('hex');
assert.strictEqual(aSecret, bSecret);

```"
"```javascript:example_js\react18_ssr\component\Layout.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Layout({children}) {
  return <main>{children}</main>;
}

```"
"```javascript:test\fs\test-fs-read-file-assert-encoding.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

const encoding = 'foo-8';
const filename = 'bar.txt';
assert.throws(
  () => fs.readFile(filename, { encoding }, common.mustNotCall()),
  { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
);

```"
"The following document is located at example_js\react_ssr\component\Home.jsx
------
import React from 'react';
import Page from './Page.jsx';

class Home extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      <div>
        <div>This is home</div>
        <Page></Page>
      </div>
    );
  }
}

export default Home;

------"
"```javascript:example_js\wasi_http_server.js
import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  print(""server: req.httpVersion="", req.httpVersion);
  print(""server: req.url="", req.url);
  print(""server: req.method="", req.method);
  print(""server: req.headers="", Object.keys(req.headers));

  req.on('data', (body) => {
    print(""server: req.body="", body);
    print()

    resp.write('echo:')
    resp.end(body)
  })
}).listen(8001, () => {
  print('listen 8001 ...\n');
})

```"
"The following document is located at example_js\create-react-app-ssr\src\index.css
------
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

------"
"```javascript:test\fs\test-fs-watch-ref-unref.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import fs from 'fs';

const watcher = fs.watch(__filename, common.mustNotCall());

watcher.unref();

setTimeout(
  common.mustCall(() => {
    watcher.ref();
    watcher.unref();
  }),
  common.platformTimeout(100)
);

```"
"```javascript:test\fs\test-fs-write-no-fd.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';

assert.throws(function() {
  fs.write(null, Buffer.allocUnsafe(1), 0, 1, common.mustNotCall());
}, /TypeError/);

assert.throws(function() {
  fs.write(null, '1', 0, 1, common.mustNotCall());
}, /TypeError/);

```"
"```javascript:test\fs\test-fs-promises-readfile-empty.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs/promises';
import fixtures from '../common/fixtures';

const fn = fixtures.path('empty.txt');

fs.readFile(fn)
  .then(assert.ok);

fs.readFile(fn, 'utf8')
  .then(assert.strictEqual.bind(this, ''));

fs.readFile(fn, { encoding: 'utf8' })
  .then(assert.strictEqual.bind(this, ''));

```"
"```javascript:test\fs\test-fs-readdir-stack-overflow.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';

function recurse() {
  fs.readdirSync('.');
  recurse();
}

assert.throws(
  () => recurse(),
  {
    name: 'RangeError',
    message: 'Maximum call stack size exceeded'
  }
);

```"
"```javascript:test\fs\test-fs-realpath-native.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const filename = __filename.toLowerCase();

assert.strictEqual(
  fs.realpathSync.native('./test/parallel/test-fs-realpath-native.js')
    .toLowerCase(),
  filename);

fs.realpath.native(
  './test/parallel/test-fs-realpath-native.js',
  common.mustSucceed(function(res) {
    assert.strictEqual(res.toLowerCase(), filename);
    assert.strictEqual(this, undefined);
  }));

```"
"```javascript:example_js\docker_wasm\server\server.js
import { createServer } from 'http';

createServer((req, resp) => {
  print(""server: req.httpVersion="", req.httpVersion);
  print(""server: req.url="", req.url);
  print(""server: req.method="", req.method);
  print(""server: req.headers="", Object.keys(req.headers));

  req.on('data', (body) => {
    print(""server: req.body="", body);
    print()

    resp.end(body)
  })
}).listen(8080, () => {
  print('listen 8080 ...\n');
})

```"
"```javascript:test\fs\test-fs-close.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

const fd = fs.openSync(__filename, 'r');

fs.close(fd, common.mustCall(function(...args) {
  assert.deepStrictEqual(args, [null]);
}));

```"
"The following document is located at example_js\react_ssr\component\Page.jsx
------
import React from 'react';

class Page extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      <div>
        <div>This is page</div>
      </div>
    );
  }
}

export default Page;
------"
"```javascript:test\fs\test-fs-constants.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import fs from 'fs';
import assert from 'assert';

// Check if the two constants accepted by chmod() on Windows are defined.
assert.notStrictEqual(fs.constants.S_IRUSR, undefined);
assert.notStrictEqual(fs.constants.S_IWUSR, undefined);

```"
"The following document is located at example_js\react_ssr_stream\component\LazyPage.jsx
------
import React from 'react';

class LazyPage extends React.Component {
    render() {
        return (
            <div>
                <div>
                    This is lazy page
                </div>
            </div>
        );
    }
}

export default LazyPage;

------"
"```javascript:test\fs\test-fs-write-stream-close-without-callback.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const s = fs.createWriteStream(path.join(tmpdir.path, 'nocallback'));

s.end('hello world');
s.close();

```"
"```javascript:test\path\test-path-posix-relative-on-windows.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

// Refs: https://github.com/nodejs/node/issues/13683

const relativePath = path.posix.relative('a/b/c', '../../x');
assert.match(relativePath, /^(\.\.\/){3,5}x$/);

```"
"```javascript:example_js\es6_module_demo\demo.js
import {hello as module_def_hello} from './module_def.js';

module_def_hello();

var f = async () => {
  let {hello, something} = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();

```"
"```javascript:test\fs\test-fs-promises-exists.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import fsPromises from 'fs/promises';

assert.strictEqual(fsPromises, fs.promises);
assert.strictEqual(fsPromises.constants, fs.constants);

```"
"```javascript:examples\embed_js_module\async_demo.js
import * as std from 'std'

async function simple_val (){
    return ""abc""
}

export async function wait_simple_val (a){
    let x = await simple_val()
    print(""wait_simple_val:"",a,':',x)
    return 12345
}

```"
"```javascript:example_js\create-react-app-ssr\src\App.test.js
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

```"
"```javascript:example_js\create-react-app-ssr\src\setupTests.js
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

```"
"```javascript:modules\internal\assert.js
/**
 * 
 * @param {unknown} expr 
 * @param {string} msg 
 */
export function assert(expr, msg = """") {
    if (!expr) {
        throw new Error(msg);
    }
}

```"
"```javascript:modules\util\types.js
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
import * as types from ""../internal/util/types.js"";
export * from ""../internal/util/types.js"";

export default { ...types };
```"
"```javascript:example_js\simple_common_js_demo\es6_code_module.js
import * as std from 'std';

export function run() {
    print('write file');
    let f = std.open('hello.txt', 'w');
    let x = f.puts('hello wasm');
    f.flush();
    f.close();
}
```"
"```javascript:example_js\es6_module_demo\module_def_async.js
export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';

```"
"```javascript:example_js\create-react-app-ssr\src\index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
ReactDOM.hydrate(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
```"
"```javascript:test\path\test-path-posix-exists.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';

assert.strictEqual(require('path/posix'), require('path').posix);

```"
"```javascript:test\path\test-path-win32-exists.js
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';

assert.strictEqual(require('path/win32'), require('path').win32);

```"
"```javascript:examples\embed_use_es6_module\es6_module_demo.js
import * as std from 'std';

export function do_something(a) {
  print('[es6_module_demo.js]=> do_something: a =', a);
  return a;
}

```"
"```javascript:example_js\image.js
import {Image} from 'image';
let img = new Image(__dirname + '/bird.png');
let img_luma = img.to_luma();
img_luma.save_to_file(__dirname + '/bird_luma.png')

```"
"```javascript:example_js\simple_common_js_demo\npm_main.js
const md5 = require('md5');
console.log(__dirname);
console.log('md5(message)=', md5('message'));
const {sqrt} = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
const {run} = require('./es6_code_module.js')
run()
```"
"```javascript:example_js\react_ssr\main.js
import React from 'react';
import {renderToString} from 'react-dom/server';

import Home from './component/Home.jsx';

const content = renderToString(React.createElement(Home));
console.log(content);

```"
"```javascript:modules\internal\test\binding.js
import uv from ""../../internal_binding/uv"";

export function internalBinding(mod) {
    if (mod === ""uv"") {
        return uv;
    }
}
```"
"```javascript:example_js\add.js
// add.js
function add(a, b) {
  return a + b;
}

print('haha');

export default add;

```"
"```javascript:example_js\module_demo\demo.js
import { hello_mod_1 } from 'my_mod_1'
import { hello_mod_2 } from 'my_mod_2'

hello_mod_1()
hello_mod_2()
```"
"```javascript:example_js\es6_module_demo\module_def.js
function hello() {
  console.log('hello from module_def.js');
}

export {hello};

```"
"```javascript:example_js\module_demo\modules\my_mod_1.js
export function hello_mod_1(){
    console.log('hello from ""my_mod_1.js""')
}
```"
"```javascript:example_js\module_demo\modules\my_mod_2.js
export function hello_mod_2(){
    console.log('hello from ""my_mod_2.js""')
}
```"
"```javascript:test\fixtures\copy\kitchen-sink\index.js
module.exports = {
  purpose: 'testing copy'
};

```"
"```javascript:test\fixtures\copy\kitchen-sink\a\index.js
module.exports = {
  purpose: 'testing copy'
};

```"
"```javascript:test\fixtures\copy\kitchen-sink\a\b\index.js
module.exports = {
  purpose: 'testing copy'
};

```"
"```javascript:test\fixtures\copy\kitchen-sink\a\c\index.js
module.exports = {
  purpose: 'testing copy'
};

```"
"```javascript:test\fixtures\copy\kitchen-sink\a\c\d\index.js
module.exports = {
  purpose: 'testing copy'
};

```"
"```javascript:test\fixtures\baz.js
module.exports = 'perhaps I work';

```"