Path,Content
modules/internal/util/inspect.js,
modules/internal/fs.js,
src/event_loop/wasi_fs.rs,
modules/whatwg_url.js,
modules/url.js,"import * as p$1 from 'punycode';
import * as o$1 from 'querystring';
import process from 'process';
import * as exports$1 from 'path';
import { URL } from 'whatwg_url'

var h = {}
var e = p$1
var a = {
  isString: function (t) { return ""string"" == typeof t },
  isObject: function (t) { return ""object"" == typeof t && null !== t },
  isNull: function (t) { return null === t },
  isNullOrUndefined: function (t) { return null == t }
};
function r() {
  this.protocol = null
  this.slashes = null
  this.auth = null
  this.host = null
  this.port = null
  this.hostname = null
  this.hash = null
  this.search = null
  this.query = null
  this.pathname = null
  this.path = null
  this.href = null
}
h.parse = O
h.resolve = function (t, s) {
  return O(t, !1, !0).resolve(s)
}
h.resolveObject = function (t, s) {
  return t ? O(t, !1, !0).resolveObject(s) : s
}
h.format = function (t) {
  a.isString(t) && (t = O(t))
  return t instanceof r ? t.format() : r.prototype.format.call(t)
}
h.Url = r
var o = /^([a-z0-9.+-]+:)/i, n = /:[0-9]*$/, i = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, l = [""{"", ""}"", ""|"", ""\\"", ""^"", ""`""].concat([""<"", "">"", '""', ""`"", "" "", ""\r"", ""\n"", ""\t""]), p = [""'""].concat(l), c = [""%"", ""/"", ""?"", "";"", ""#""].concat(p), u = [""/"", ""?"", ""#""], f = /^[+a-z0-9A-Z_-]{0,63}$/, m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, v = { javascript: !0, ""javascript:"": !0 }, g = { javascript: !0, ""javascript:"": !0 }, y = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, ""http:"": !0, ""https:"": !0, ""ftp:"": !0, ""gopher:"": !0, ""file:"": !0 }, b = o$1;
function O(t, s, h) {
  if (t && a.isObject(t) && t instanceof r) {
    return t;
  }
  var e = new r;
  return e.parse(t, s, h), e
}
r.prototype.parse = function (t, s, h) {
  if (!a.isString(t)) {
    throw new TypeError(""Parameter 'url' must be a string, not "" + typeof t);
  }
  var r = t.indexOf(""?"")
  var n = -1 !== r && r < t.indexOf(""#"") ? ""?"" : ""#""
  var l = t.split(n);
  l[0] = l[0].replace(/\\/g, ""/"");
  var O = t = l.join(n);
  if (O = O.trim(), !h && 1 === t.split(""#"").length) {
    var d = i.exec(O);
    if (d) {
      return this.path = O, this.href = O, this.pathname = d[1], d[2] ? (this.search = d[2], this.query = s ? b.parse(this.search.substr(1)) : this.search.substr(1)) : s && (this.search = """", this.query = {}), this
    }
  }
  var j = o.exec(O);
  if (j) {
    var q = (j = j[0]).toLowerCase();
    this.protocol = q
    O = O.substr(j.length);
  }
  if (h || j || O.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var x = ""//"" === O.substr(0, 2);
    !x || j && g[j] || (O = O.substr(2), this.slashes = !0);
  }
  if (!g[j] && (x || j && !y[j])) {
    for (var A, C, I = -1, w = 0; w < u.length; w++) {
      -1 !== (N = O.indexOf(u[w])) && (-1 === I || N < I) && (I = N);
    }
    -1 !== (C = -1 === I ? O.lastIndexOf(""@"") : O.lastIndexOf(""@"", I)) && (A = O.slice(0, C), O = O.slice(C + 1), this.auth = decodeURIComponent(A))
    I = -1;
    for (w = 0; w < c.length; w++) {
      var N; -1 !== (N = O.indexOf(c[w])) && (-1 === I || N < I) && (I = N);
    }
    -1 === I && (I = O.length), this.host = O.slice(0, I), O = O.slice(I)
    this.parseHost()
    this.hostname = this.hostname || """"
    var U = ""["" === this.hostname[0] && ""]"" === this.hostname[this.hostname.length - 1];
    if (!U) {
      for (var k = this.hostname.split(/\./), S = (w = 0, k.length); w < S; w++) {
        var R = k[w];
        if (R && !R.match(f)) {
          for (var $ = """", z = 0, H = R.length; z < H; z++) {
            R.charCodeAt(z) > 127 ? $ += ""x"" : $ += R[z];
          }
          if (!$.match(f)) {
            var L = k.slice(0, w), Z = k.slice(w + 1), _ = R.match(m); _ && (L.push(_[1]), Z.unshift(_[2])), Z.length && (O = ""/"" + Z.join(""."") + O)
            this.hostname = L.join(""."");
            break
          }
        }
      }
    }
    this.hostname.length > 255 ? this.hostname = """" : this.hostname = this.hostname.toLowerCase()
    U || (this.hostname = e.toASCII(this.hostname));
    var E = this.port ? "":"" + this.port : """"
    P = this.hostname || """";
    this.host = P + E, this.href += this.host
    U && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), ""/"" !== O[0] && (O = ""/"" + O));
  }
  if (!v[q]) {
    for (w = 0, S = p.length; w < S; w++) {
      var T = p[w];
      if (-1 !== O.indexOf(T)) {
        var B = encodeURIComponent(T); B === T && (B = escape(T)), O = O.split(T).join(B);
      }
    }
  }
  var D = O.indexOf(""#""); -1 !== D && (this.hash = O.substr(D), O = O.slice(0, D));
  var F = O.indexOf(""?"");
  if (-1 !== F ? (this.search = O.substr(F), this.query = O.substr(F + 1), s && (this.query = b.parse(this.query)), O = O.slice(0, F)) : s && (this.search = """", this.query = {}), O && (this.pathname = O), y[q] && this.hostname && !this.pathname && (this.pathname = ""/""), this.pathname || this.search) {
    E = this.pathname || """"; var G = this.search || """"; this.path = E + G;
  }
  return this.href = this.format(), this
}
r.prototype.format = function () {
  var t = this.auth || """";
  t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, "":""), t += ""@"");
  var s = this.protocol || """", h = this.pathname || """", e = this.hash || """", r = !1, o = """";
  this.host ? r = t + this.host : this.hostname && (r = t + (-1 === this.hostname.indexOf("":"") ? this.hostname : ""["" + this.hostname + ""]""), this.port && (r += "":"" + this.port)), this.query && a.isObject(this.query) && Object.keys(this.query).length && (o = b.stringify(this.query));
  var n = this.search || o && ""?"" + o || """";
  return s && "":"" !== s.substr(-1) && (s += "":""), this.slashes || (!s || y[s]) && !1 !== r ? (r = ""//"" + (r || """"), h && ""/"" !== h.charAt(0) && (h = ""/"" + h)) : r || (r = """"), e && ""#"" !== e.charAt(0) && (e = ""#"" + e), n && ""?"" !== n.charAt(0) && (n = ""?"" + n), s + r + (h = h.replace(/[?#]/g, (function (t) { return encodeURIComponent(t) }))) + (n = n.replace(""#"", ""%23"")) + e
}
r.prototype.resolve = function (t) {
  return this.resolveObject(O(t, !1, !0)).format()
}
r.prototype.resolveObject = function (t) {
  if (a.isString(t)) {
    var s = new r; s.parse(t, !1, !0), t = s;
  }
  for (var h = new r, e = Object.keys(this), o = 0; o < e.length; o++) {
    var n = e[o]; h[n] = this[n];
  }
  if (h.hash = t.hash, """" === t.href) {
    return h.href = h.format(), h;
  }
  if (t.slashes && !t.protocol) {
    for (var i = Object.keys(t), l = 0; l < i.length; l++) {
      var p = i[l];
      ""protocol"" !== p && (h[p] = t[p]);
    }
    return y[h.protocol] && h.hostname && !h.pathname && (h.path = h.pathname = ""/""), h.href = h.format(), h
  }
  if (t.protocol && t.protocol !== h.protocol) {
    if (!y[t.protocol]) {
      for (var c = Object.keys(t), u = 0; u < c.length; u++) {
        var f = c[u]; h[f] = t[f];
      }
      return h.href = h.format(), h
    }
    if (h.protocol = t.protocol, t.host || g[t.protocol]) {
      h.pathname = t.pathname;
    } else {
      for (var m = (t.pathname || """").split(""/""); m.length && !(t.host = m.shift());) { }
      t.host || (t.host = """")
      t.hostname || (t.hostname = """")
      """" !== m[0] && m.unshift("""")
      m.length < 2 && m.unshift("""")
      h.pathname = m.join(""/"");
    }
    if (h.search = t.search, h.query = t.query, h.host = t.host || """", h.auth = t.auth, h.hostname = t.hostname || t.host, h.port = t.port, h.pathname || h.search) {
      var v = h.pathname || """", b = h.search || """"; h.path = v + b;
    }
    return h.slashes = h.slashes || t.slashes, h.href = h.format(), h
  }
  var O = h.pathname && ""/"" === h.pathname.charAt(0), d = t.host || t.pathname && ""/"" === t.pathname.charAt(0), j = d || O || h.host && t.pathname, q = j, x = h.pathname && h.pathname.split(""/"") || [], A = (m = t.pathname && t.pathname.split(""/"") || [], h.protocol && !y[h.protocol]);
  if (A && (h.hostname = """", h.port = null, h.host && ("""" === x[0] ? x[0] = h.host : x.unshift(h.host)), h.host = """", t.protocol && (t.hostname = null, t.port = null, t.host && ("""" === m[0] ? m[0] = t.host : m.unshift(t.host)), t.host = null), j = j && ("""" === m[0] || """" === x[0])), d) {
    h.host = t.host || """" === t.host ? t.host : h.host, h.hostname = t.hostname || """" === t.hostname ? t.hostname : h.hostname, h.search = t.search, h.query = t.query, x = m;
  } else if (m.length) {
    x || (x = []), x.pop(), x = x.concat(m), h.search = t.search, h.query = t.query;
  } else if (!a.isNullOrUndefined(t.search)) {
    if (A) {
      h.hostname = h.host = x.shift(), (U = !!(h.host && h.host.indexOf(""@"") > 0) && h.host.split(""@"")) && (h.auth = U.shift(), h.host = h.hostname = U.shift());
    }
    return h.search = t.search, h.query = t.query, a.isNull(h.pathname) && a.isNull(h.search) || (h.path = (h.pathname ? h.pathname : """") + (h.search ? h.search : """")), h.href = h.format(), h
  }
  if (!x.length) {
    return h.pathname = null, h.search ? h.path = ""/"" + h.search : h.path = null, h.href = h.format(), h;
  }
  for (var C = x.slice(-1)[0], I = (h.host || t.host || x.length > 1) && (""."" === C || "".."" === C) || """" === C, w = 0, N = x.length; N >= 0; N--) {
    ""."" === (C = x[N]) ? x.splice(N, 1) : "".."" === C ? (x.splice(N, 1), w++) : w && (x.splice(N, 1), w--);
  } if (!j && !q) {
    for (; w--; w) { x.unshift(""..""); }
  }
  !j || """" === x[0] || x[0] && ""/"" === x[0].charAt(0) || x.unshift(""""), I && ""/"" !== x.join(""/"").substr(-1) && x.push("""");
  var U, k = """" === x[0] || x[0] && ""/"" === x[0].charAt(0);
  A && (h.hostname = h.host = k ? """" : x.length ? x.shift() : """", (U = !!(h.host && h.host.indexOf(""@"") > 0) && h.host.split(""@"")) && (h.auth = U.shift(), h.host = h.hostname = U.shift()));
  return (j = j || h.host && x.length) && !k && x.unshift(""""), x.length ? h.pathname = x.join(""/"") : (h.pathname = null, h.path = null), a.isNull(h.pathname) && a.isNull(h.search) || (h.path = (h.pathname ? h.pathname : """") + (h.search ? h.search : """")), h.auth = t.auth || h.auth, h.slashes = h.slashes || t.slashes, h.href = h.format(), h
}
r.prototype.parseHost = function () {
  var t = this.host, s = n.exec(t); s && ("":"" !== (s = s[0]) && (this.port = s.substr(1)), t = t.substr(0, t.length - s.length)), t && (this.hostname = t);
};

h.Url; h.format; h.resolve; h.resolveObject;

var exports = {},
  _dewExec = false;
function dew() {
  if (_dewExec) { return exports; }
  _dewExec = true;

  function assertPath(path) {
    if (typeof path !== ""string"") {
      throw new TypeError(""Path must be a string. Received "" + JSON.stringify(path));
    }
  } // Resolves . and .. elements in a path with directory names


  function normalizeStringPosix(path, allowAboveRoot) {
    var res = """";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;

    for (var i = 0; i <= path.length; ++i) {
      if (i < path.length) { code = path.charCodeAt(i); } else if (code === 47
        /*/*/
      ) { break; } else {
        code = 47
          /*/*/
          ;
      }

      if (code === 47
        /*/*/
      ) {
        if (lastSlash === i - 1 || dots === 1); else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46
            /*.*/
            || res.charCodeAt(res.length - 2) !== 46
            /*.*/
          ) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf(""/"");

              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = """";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf(""/"");
                }

                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = """";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }

          if (allowAboveRoot) {
            if (res.length > 0) { res += ""/..""; } else { res = ""..""; }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) { res += ""/"" + path.slice(lastSlash + 1, i); } else { res = path.slice(lastSlash + 1, i); }
          lastSegmentLength = i - lastSlash - 1;
        }

        lastSlash = i;
        dots = 0;
      } else if (code === 46
        /*.*/
        && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }

    return res;
  }

  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || """") + (pathObject.ext || """");

    if (!dir) {
      return base;
    }

    if (dir === pathObject.root) {
      return dir + base;
    }

    return dir + sep + base;
  }

  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
      var arguments$1 = arguments;

      var resolvedPath = """";
      var resolvedAbsolute = false;
      var cwd;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path;
        if (i >= 0) { path = arguments$1[i]; } else {
          if (cwd === undefined) { cwd = process.cwd(); }
          path = cwd;
        }
        assertPath(path); // Skip empty entries

        if (path.length === 0) {
          continue;
        }

        resolvedPath = path + ""/"" + resolvedPath;
        resolvedAbsolute = path.charCodeAt(0) === 47
          /*/*/
          ;
      } // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path


      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) { return ""/"" + resolvedPath; } else { return ""/""; }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ""."";
      }
    },
    normalize: function normalize(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var isAbsolute = path.charCodeAt(0) === 47
        /*/*/
        ;
      var trailingSeparator = path.charCodeAt(path.length - 1) === 47
        /*/*/
        ; // Normalize the path

      path = normalizeStringPosix(path, !isAbsolute);
      if (path.length === 0 && !isAbsolute) { path = "".""; }
      if (path.length > 0 && trailingSeparator) { path += ""/""; }
      if (isAbsolute) { return ""/"" + path; }
      return path;
    },
    isAbsolute: function isAbsolute(path) {
      assertPath(path);
      return path.length > 0 && path.charCodeAt(0) === 47
        /*/*/
        ;
    },
    join: function join() {
      var arguments$1 = arguments;

      if (arguments.length === 0) { return "".""; }
      var joined;

      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments$1[i];
        assertPath(arg);

        if (arg.length > 0) {
          if (joined === undefined) { joined = arg; } else { joined += ""/"" + arg; }
        }
      }

      if (joined === undefined) { return "".""; }
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) { return """"; }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) { return """"; } // Trim any leading backslashes

      var fromStart = 1;

      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47
          /*/*/
        ) { break; }
      }

      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart; // Trim any leading backslashes

      var toStart = 1;

      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47
          /*/*/
        ) { break; }
      }

      var toEnd = to.length;
      var toLen = toEnd - toStart; // Compare paths to find the longest common path from root

      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;

      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47
              /*/*/
            ) {
              // We get here if `from` is the exact base path for `to`.
              // For example: from='/foo/bar'; to='/foo/bar/baz'
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              // We get here if `from` is the root
              // For example: from='/'; to='/foo'
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47
              /*/*/
            ) {
              // We get here if `to` is the exact base path for `from`.
              // For example: from='/foo/bar/baz'; to='/foo/bar'
              lastCommonSep = i;
            } else if (i === 0) {
              // We get here if `to` is the root.
              // For example: from='/foo'; to='/'
              lastCommonSep = 0;
            }
          }

          break;
        }

        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) { break; } else if (fromCode === 47
          /*/*/
        ) { lastCommonSep = i; }
      }

      var out = """"; // Generate the relative path based on the path difference between `to`
      // and `from`

      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47
          /*/*/
        ) {
          if (out.length === 0) { out += ""..""; } else { out += ""/..""; }
        }
      } // Lastly, append the rest of the destination (`to`) path that comes after
      // the common path parts


      if (out.length > 0) { return out + to.slice(toStart + lastCommonSep); } else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47
          /*/*/
        ) { ++toStart; }
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path) {
      return path;
    },
    dirname: function dirname(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var code = path.charCodeAt(0);
      var hasRoot = code === 47
        /*/*/
        ;
      var end = -1;
      var matchedSlash = true;

      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);

        if (code === 47
          /*/*/
        ) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }

      if (end === -1) { return hasRoot ? ""/"" : "".""; }
      if (hasRoot && end === 1) { return ""//""; }
      return path.slice(0, end);
    },
    basename: function basename(path, ext) {
      if (ext !== undefined && typeof ext !== ""string"") { throw new TypeError(""\""ext\"" argument must be a string""); }
      assertPath(path);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;

      if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) { return """"; }
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;

        for (i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);

          if (code === 47
            /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              // We saw the first non-path separator, remember this index in case
              // we need it if the extension ends up not matching
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }

            if (extIdx >= 0) {
              // Try to match the explicit extension
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  // We matched the extension, so mark this as the end of our path
                  // component
                  end = i;
                }
              } else {
                // Extension does not match, so our result is the entire path
                // component
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }

        if (start === end) { end = firstNonSlashEnd; } else if (end === -1) { end = path.length; }
        return path.slice(start, end);
      } else {
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === 47
            /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // path component
            matchedSlash = false;
            end = i + 1;
          }
        }

        if (end === -1) { return """"; }
        return path.slice(start, end);
      }
    },
    extname: function extname(path) {
      assertPath(path);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0;

      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);

        if (code === 47
          /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
          /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; } else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return """";
      }

      return path.slice(startDot, end);
    },
    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== ""object"") {
        throw new TypeError(""The \""pathObject\"" argument must be of type Object. Received type "" + typeof pathObject);
      }

      return _format(""/"", pathObject);
    },
    parse: function parse(path) {
      assertPath(path);
      var ret = {
        root: """",
        dir: """",
        base: """",
        ext: """",
        name: """"
      };
      if (path.length === 0) { return ret; }
      var code = path.charCodeAt(0);
      var isAbsolute = code === 47
        /*/*/
        ;
      var start;

      if (isAbsolute) {
        ret.root = ""/"";
        start = 1;
      } else {
        start = 0;
      }

      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0; // Get non-dir info

      for (; i >= start; --i) {
        code = path.charCodeAt(i);

        if (code === 47
          /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
          /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; } else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute) { ret.base = ret.name = path.slice(1, end); } else { ret.base = ret.name = path.slice(startPart, end); }
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
        }

        ret.ext = path.slice(startDot, end);
      }

      if (startPart > 0) { ret.dir = path.slice(0, startPart - 1); } else if (isAbsolute) { ret.dir = ""/""; }
      return ret;
    },
    sep: ""/"",
    delimiter: "":"",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports = posix;
  return exports;
}

var path = dew();

// Copyright Joyent, Inc. and other Node contributors.

var processPlatform$1 = ""wasi"";

h.URL = typeof URL !== 'undefined' ? URL : null;
h.pathToFileURL = pathToFileURL$1;
h.fileURLToPath = fileURLToPath$1;

h.Url;
h.format;
h.resolve;
h.resolveObject;

h.URL;

var CHAR_FORWARD_SLASH$1 = 47;
var CHAR_LOWERCASE_A$1 = 97;
var CHAR_LOWERCASE_Z$1 = 122;

var isWindows$1 = processPlatform$1 === 'win32';

var forwardSlashRegEx$1 = /\//g;
var percentRegEx$1 = /%/g;
var backslashRegEx$1 = /\\/g;
var newlineRegEx$1 = /\n/g;
var carriageReturnRegEx$1 = /\r/g;
var tabRegEx$1 = /\t/g;

/**
 * Get fully resolved platform-specific file path from the given URL string/ object
 * @param path The file URL string or URL object to convert to a path
 */
function fileURLToPath$1(path) {
  if (typeof path === ""string"") { path = new URL(path); }
  else if (!(path instanceof URL)) {
    throw new TypeError(
      ""invalid argument path , must be a string or URL""
    );
  }
  if (path.protocol !== ""file:"") {
    throw new TypeError(""invalid url scheme"");
  }
  return isWindows$1 ? getPathFromURLWin$1(path) : getPathFromURLPosix$1(path);
}

function getPathFromURLWin$1(url) {
  var hostname = url.hostname;
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (
        (pathname[n + 1] === ""2"" && third === 102) || // 2f 2F /
        (pathname[n + 1] === ""5"" && third === 99)
      ) {
        // 5c 5C \
        throw new TypeError(
          ""must not include encoded \\ or / characters""
        );
      }
    }
  }

  pathname = pathname.replace(forwardSlashRegEx$1, ""\\"");
  pathname = decodeURIComponent(pathname);
  if (hostname !== """") {
    //TODO add support for punycode encodings
    return (""\\\\"" + hostname + pathname);
  } else {
    // Otherwise, it's a local path that requires a drive letter
    var letter = pathname.codePointAt(1) | 0x20;
    var sep = pathname[2];
    if (
      letter < CHAR_LOWERCASE_A$1 ||
      letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
      sep !== "":""
    ) {
      throw new TypeError(""file url path must be absolute"");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== """") {
    throw new TypeError(""invalid file url hostname"");
  }
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (pathname[n + 1] === ""2"" && third === 102) {
        throw new TypeError(
          ""must not include encoded / characters""
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}

/** Get fully resolved platform-specific File URL from the given file path */
function pathToFileURL$1(filepath) {
  var resolved = path.resolve(filepath);
  // path.resolve strips trailing slashes so we must add them back
  var filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (
    (filePathLast === CHAR_FORWARD_SLASH$1 ||
      (isWindows$1)) &&
    resolved[resolved.length - 1] !== path.sep
  ) {
    resolved += ""/"";
  }
  var outURL = new URL(""file://"");
  if (resolved.includes(""%"")) { resolved = resolved.replace(percentRegEx$1, ""%25""); }
  // In posix, ""/"" is a valid character in paths
  if (resolved.includes(""\\"")) {
    resolved = resolved.replace(backslashRegEx$1, ""%5C"");
  }
  if (resolved.includes(""\n"")) { resolved = resolved.replace(newlineRegEx$1, ""%0A""); }
  if (resolved.includes(""\r"")) {
    resolved = resolved.replace(carriageReturnRegEx$1, ""%0D"");
  }
  if (resolved.includes(""\t"")) { resolved = resolved.replace(tabRegEx$1, ""%09""); }
  outURL.pathname = resolved;
  return outURL;
}

// Copyright Joyent, Inc. and other Node contributors.

var processPlatform = ""wasi"";

h.URL = typeof URL !== 'undefined' ? URL : null;
h.pathToFileURL = pathToFileURL;
h.fileURLToPath = fileURLToPath;

var Url = h.Url;
var format = h.format;
var resolve = h.resolve;
var resolveObject = h.resolveObject;
var parse = h.parse;

var _URL = h.URL;
var CHAR_FORWARD_SLASH = 47;
var CHAR_LOWERCASE_A = 97;
var CHAR_LOWERCASE_Z = 122;

var isWindows = processPlatform === 'win32';

var forwardSlashRegEx = /\//g;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;

/**
 * Get fully resolved platform-specific file path from the given URL string/ object
 * @param path The file URL string or URL object to convert to a path
 */
function fileURLToPath(path) {
  if (typeof path === ""string"") { path = new URL(path); }
  else if (!(path instanceof URL)) {
    throw new TypeError(
      ""invalid argument path , must be a string or URL""
    );
  }
  if (path.protocol !== ""file:"") {
    throw new TypeError(""invalid url scheme"");
  }
  return isWindows ? getPathFromURLWin(path) : getPathFromURLPosix(path);
}

function getPathFromURLWin(url) {
  var hostname = url.hostname;
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (
        (pathname[n + 1] === ""2"" && third === 102) || // 2f 2F /
        (pathname[n + 1] === ""5"" && third === 99)
      ) {
        // 5c 5C \
        throw new TypeError(
          ""must not include encoded \\ or / characters""
        );
      }
    }
  }

  pathname = pathname.replace(forwardSlashRegEx, ""\\"");
  pathname = decodeURIComponent(pathname);
  if (hostname !== """") {
    //TODO add support for punycode encodings
    return (""\\\\"" + hostname + pathname);
  } else {
    // Otherwise, it's a local path that requires a drive letter
    var letter = pathname.codePointAt(1) | 0x20;
    var sep = pathname[2];
    if (
      letter < CHAR_LOWERCASE_A ||
      letter > CHAR_LOWERCASE_Z || // a..z A..Z
      sep !== "":""
    ) {
      throw new TypeError(""file url path must be absolute"");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== """") {
    throw new TypeError(""invalid file url hostname"");
  }
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === ""%"") {
      var third = pathname.codePointAt(n + 2) || 0x20;
      if (pathname[n + 1] === ""2"" && third === 102) {
        throw new TypeError(
          ""must not include encoded / characters""
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}

/** Get fully resolved platform-specific File URL from the given file path */
function pathToFileURL(filepath) {
  var resolved = exports$1.resolve(filepath);
  // path.resolve strips trailing slashes so we must add them back
  var filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (
    (filePathLast === CHAR_FORWARD_SLASH ||
      (isWindows)) &&
    resolved[resolved.length - 1] !== exports$1.sep
  ) {
    resolved += ""/"";
  }
  var outURL = new URL(""file://"");
  if (resolved.includes(""%"")) { resolved = resolved.replace(percentRegEx, ""%25""); }
  // In posix, ""/"" is a valid character in paths
  if (resolved.includes(""\\"")) {
    resolved = resolved.replace(backslashRegEx, ""%5C"");
  }
  if (resolved.includes(""\n"")) { resolved = resolved.replace(newlineRegEx, ""%0A""); }
  if (resolved.includes(""\r"")) {
    resolved = resolved.replace(carriageReturnRegEx, ""%0D"");
  }
  if (resolved.includes(""\t"")) { resolved = resolved.replace(tabRegEx, ""%09""); }
  outURL.pathname = resolved;
  return outURL;
}

export { _URL as URL, Url, h as default, fileURLToPath, format, parse, pathToFileURL, resolve, resolveObject };
"
example_js/repl.js,"/*
 * QuickJS Read Eval Print Loop
 *
 * Copyright (c) 2017-2020 Fabrice Bellard
 * Copyright (c) 2017-2020 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
""use strip"";

import * as std from ""std"";
import * as os from ""os"";
//import * as http from ""http"";

(function(g) {
    /* add 'os' and 'std' bindings */
    g.os = os;
    g.std = std;
//    g.http = http;

    /* close global objects */
    var Object = g.Object;
    var String = g.String;
    var Array = g.Array;
    var Date = g.Date;
    var Math = g.Math;
    var isFinite = g.isFinite;
    var parseFloat = g.parseFloat;

    /* XXX: use preprocessor ? */
    var config_numcalc = (typeof os.open === ""undefined"");
    var has_jscalc = (typeof Fraction === ""function"");
    var has_bignum = (typeof BigFloat === ""function"");

    var colors = {
        none:    ""\x1b[0m"",
        black:   ""\x1b[30m"",
        red:     ""\x1b[31m"",
        green:   ""\x1b[32m"",
        yellow:  ""\x1b[33m"",
        blue:    ""\x1b[34m"",
        magenta: ""\x1b[35m"",
        cyan:    ""\x1b[36m"",
        white:   ""\x1b[37m"",
        gray:    ""\x1b[30;1m"",
        grey:    ""\x1b[30;1m"",
        bright_red:     ""\x1b[31;1m"",
        bright_green:   ""\x1b[32;1m"",
        bright_yellow:  ""\x1b[33;1m"",
        bright_blue:    ""\x1b[34;1m"",
        bright_magenta: ""\x1b[35;1m"",
        bright_cyan:    ""\x1b[36;1m"",
        bright_white:   ""\x1b[37;1m"",
    };

    var styles;
    if (config_numcalc) {
        styles = {
            'default':    'black',
            'comment':    'white',
            'string':     'green',
            'regex':      'cyan',
            'number':     'green',
            'keyword':    'blue',
            'function':   'gray',
            'type':       'bright_magenta',
            'identifier': 'yellow',
            'error':      'bright_red',
            'result':     'black',
            'error_msg':  'bright_red',
        };
    } else {
        styles = {
            'default':    'bright_green',
            'comment':    'white',
            'string':     'bright_cyan',
            'regex':      'cyan',
            'number':     'green',
            'keyword':    'bright_white',
            'function':   'bright_yellow',
            'type':       'bright_magenta',
            'identifier': 'bright_green',
            'error':      'red',
            'result':     'bright_white',
            'error_msg':  'bright_red',
        };
    }

    var history = [];
    var clip_board = """";
    var prec;
    var expBits;
    var log2_10;

    var pstate = """";
    var prompt = """";
    var plen = 0;
    var ps1;
    if (config_numcalc)
        ps1 = ""> "";
    else
        ps1 = ""qjs > "";
    var ps2 = ""  ... "";
    var utf8 = true;
    var show_time = false;
    var show_colors = true;
    var eval_time = 0;

    var mexpr = """";
    var level = 0;
    var cmd = """";
    var cursor_pos = 0;
    var last_cmd = """";
    var last_cursor_pos = 0;
    var history_index;
    var this_fun, last_fun;
    var quote_flag = false;

    var utf8_state = 0;
    var utf8_val = 0;

    var term_fd;
    var term_read_buf;
    var term_width;
    /* current X position of the cursor in the terminal */
    var term_cursor_x = 0;

    function termInit() {
        var tab;
        term_fd = std.in.fileno();

        /* get the terminal size */
        term_width = 80;
        if (os.isatty(term_fd)) {
            if (os.ttyGetWinSize) {
                tab = os.ttyGetWinSize(term_fd);
                if (tab)
                    term_width = tab[0];
            }
            if (os.ttySetRaw) {
                /* set the TTY to raw mode */
                os.ttySetRaw(term_fd);
            }
        }

        /* install a Ctrl-C signal handler */
        os.signal(os.SIGINT, sigint_handler);

        /* install a handler to read stdin */
        term_read_buf = new Uint8Array(64);
        os.setReadHandler(term_fd, term_read_handler);
    }

    function sigint_handler() {
        /* send Ctrl-C to readline */
        handle_byte(3);
    }

    function term_read_handler() {
        var l, i;
        l = os.read(term_fd, term_read_buf.buffer, 0, term_read_buf.length);
        for(i = 0; i < l; i++)
            handle_byte(term_read_buf[i]);
    }

    function handle_byte(c) {
        if (!utf8) {
            handle_char(c);
        } else if (utf8_state !== 0 && (c >= 0x80 && c < 0xc0)) {
            utf8_val = (utf8_val << 6) | (c & 0x3F);
            utf8_state--;
            if (utf8_state === 0) {
                handle_char(utf8_val);
            }
        } else if (c >= 0xc0 && c < 0xf8) {
            utf8_state = 1 + (c >= 0xe0) + (c >= 0xf0);
            utf8_val = c & ((1 << (6 - utf8_state)) - 1);
        } else {
            utf8_state = 0;
            handle_char(c);
        }
    }

    function is_alpha(c) {
        return typeof c === ""string"" &&
            ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
    }

    function is_digit(c) {
        return typeof c === ""string"" && (c >= '0' && c <= '9');
    }

    function is_word(c) {
        return typeof c === ""string"" &&
            (is_alpha(c) || is_digit(c) || c == '_' || c == '$');
    }

    function ucs_length(str) {
        var len, c, i, str_len = str.length;
        len = 0;
        /* we never count the trailing surrogate to have the
         following property: ucs_length(str) =
         ucs_length(str.substring(0, a)) + ucs_length(str.substring(a,
         str.length)) for 0 <= a <= str.length */
        for(i = 0; i < str_len; i++) {
            c = str.charCodeAt(i);
            if (c < 0xdc00 || c >= 0xe000)
                len++;
        }
        return len;
    }

    function is_trailing_surrogate(c)  {
        var d;
        if (typeof c !== ""string"")
            return false;
        d = c.codePointAt(0); /* can be NaN if empty string */
        return d >= 0xdc00 && d < 0xe000;
    }

    function is_balanced(a, b) {
        switch (a + b) {
        case ""()"":
        case ""[]"":
        case ""{}"":
            return true;
        }
        return false;
    }

    function print_color_text(str, start, style_names) {
        var i, j;
        for (j = start; j < str.length;) {
            var style = style_names[i = j];
            while (++j < str.length && style_names[j] == style)
                continue;
            std.puts(colors[styles[style] || 'default']);
            std.puts(str.substring(i, j));
            std.puts(colors['none']);
        }
    }

    function print_csi(n, code) {
        std.puts(""\x1b["" + ((n != 1) ? n : """") + code);
    }

    /* XXX: handle double-width characters */
    function move_cursor(delta) {
        var i, l;
        if (delta > 0) {
            while (delta != 0) {
                if (term_cursor_x == (term_width - 1)) {
                    std.puts(""\n""); /* translated to CRLF */
                    term_cursor_x = 0;
                    delta--;
                } else {
                    l = Math.min(term_width - 1 - term_cursor_x, delta);
                    print_csi(l, ""C""); /* right */
                    delta -= l;
                    term_cursor_x += l;
                }
            }
        } else {
            delta = -delta;
            while (delta != 0) {
                if (term_cursor_x == 0) {
                    print_csi(1, ""A""); /* up */
                    print_csi(term_width - 1, ""C""); /* right */
                    delta--;
                    term_cursor_x = term_width - 1;
                } else {
                    l = Math.min(delta, term_cursor_x);
                    print_csi(l, ""D""); /* left */
                    delta -= l;
                    term_cursor_x -= l;
                }
            }
        }
    }

    function update() {
        var i, cmd_len;
        /* cursor_pos is the position in 16 bit characters inside the
           UTF-16 string 'cmd' */
        if (cmd != last_cmd) {
            if (!show_colors && last_cmd.substring(0, last_cursor_pos) == cmd.substring(0, last_cursor_pos)) {
                /* optimize common case */
                std.puts(cmd.substring(last_cursor_pos));
            } else {
                /* goto the start of the line */
                move_cursor(-ucs_length(last_cmd.substring(0, last_cursor_pos)));
                if (show_colors) {
                    var str = mexpr ? mexpr + '\n' + cmd : cmd;
                    var start = str.length - cmd.length;
                    var colorstate = colorize_js(str);
                    print_color_text(str, start, colorstate[2]);
                } else {
                    std.puts(cmd);
                }
            }
            term_cursor_x = (term_cursor_x + ucs_length(cmd)) % term_width;
            if (term_cursor_x == 0) {
                /* show the cursor on the next line */
                std.puts("" \x08"");
            }
            /* remove the trailing characters */
            std.puts(""\x1b[J"");
            last_cmd = cmd;
            last_cursor_pos = cmd.length;
        }
        if (cursor_pos > last_cursor_pos) {
            move_cursor(ucs_length(cmd.substring(last_cursor_pos, cursor_pos)));
        } else if (cursor_pos < last_cursor_pos) {
            move_cursor(-ucs_length(cmd.substring(cursor_pos, last_cursor_pos)));
        }
        last_cursor_pos = cursor_pos;
        std.out.flush();
    }

    /* editing commands */
    function insert(str) {
        if (str) {
            cmd = cmd.substring(0, cursor_pos) + str + cmd.substring(cursor_pos);
            cursor_pos += str.length;
        }
    }

    function quoted_insert() {
        quote_flag = true;
    }

    function abort() {
        cmd = """";
        cursor_pos = 0;
        return -2;
    }

    function alert() {
    }

    function beginning_of_line() {
        cursor_pos = 0;
    }

    function end_of_line() {
        cursor_pos = cmd.length;
    }

    function forward_char() {
        if (cursor_pos < cmd.length) {
            cursor_pos++;
            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))
                cursor_pos++;
        }
    }

    function backward_char() {
        if (cursor_pos > 0) {
            cursor_pos--;
            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))
                cursor_pos--;
        }
    }

    function skip_word_forward(pos) {
        while (pos < cmd.length && !is_word(cmd.charAt(pos)))
            pos++;
        while (pos < cmd.length && is_word(cmd.charAt(pos)))
            pos++;
        return pos;
    }

    function skip_word_backward(pos) {
        while (pos > 0 && !is_word(cmd.charAt(pos - 1)))
            pos--;
        while (pos > 0 && is_word(cmd.charAt(pos - 1)))
            pos--;
        return pos;
    }

    function forward_word() {
        cursor_pos = skip_word_forward(cursor_pos);
    }

    function backward_word() {
        cursor_pos = skip_word_backward(cursor_pos);
    }

    function accept_line() {
        std.puts(""\n"");
        history_add(cmd);
        return -1;
    }

    function history_add(str) {
        if (str) {
            history.push(str);
        }
        history_index = history.length;
    }

    function previous_history() {
        if (history_index > 0) {
            if (history_index == history.length) {
                history.push(cmd);
            }
            history_index--;
            cmd = history[history_index];
            cursor_pos = cmd.length;
        }
    }

    function next_history() {
        if (history_index < history.length - 1) {
            history_index++;
            cmd = history[history_index];
            cursor_pos = cmd.length;
        }
    }

    function history_search(dir) {
        var pos = cursor_pos;
        for (var i = 1; i <= history.length; i++) {
            var index = (history.length + i * dir + history_index) % history.length;
            if (history[index].substring(0, pos) == cmd.substring(0, pos)) {
                history_index = index;
                cmd = history[index];
                return;
            }
        }
    }

    function history_search_backward() {
        return history_search(-1);
    }

    function history_search_forward() {
        return history_search(1);
    }

    function delete_char_dir(dir) {
        var start, end;

        start = cursor_pos;
        if (dir < 0) {
            start--;
            while (is_trailing_surrogate(cmd.charAt(start)))
                start--;
        }
        end = start + 1;
        while (is_trailing_surrogate(cmd.charAt(end)))
            end++;

        if (start >= 0 && start < cmd.length) {
            if (last_fun === kill_region) {
                kill_region(start, end, dir);
            } else {
                cmd = cmd.substring(0, start) + cmd.substring(end);
                cursor_pos = start;
            }
        }
    }

    function delete_char() {
        delete_char_dir(1);
    }

    function control_d() {
        if (cmd.length == 0) {
            std.puts(""\n"");
            return -3; /* exit read eval print loop */
        } else {
            delete_char_dir(1);
        }
    }

    function backward_delete_char() {
        delete_char_dir(-1);
    }

    function transpose_chars() {
        var pos = cursor_pos;
        if (cmd.length > 1 && pos > 0) {
            if (pos == cmd.length)
                pos--;
            cmd = cmd.substring(0, pos - 1) + cmd.substring(pos, pos + 1) +
                cmd.substring(pos - 1, pos) + cmd.substring(pos + 1);
            cursor_pos = pos + 1;
        }
    }

    function transpose_words() {
        var p1 = skip_word_backward(cursor_pos);
        var p2 = skip_word_forward(p1);
        var p4 = skip_word_forward(cursor_pos);
        var p3 = skip_word_backward(p4);

        if (p1 < p2 && p2 <= cursor_pos && cursor_pos <= p3 && p3 < p4) {
            cmd = cmd.substring(0, p1) + cmd.substring(p3, p4) +
            cmd.substring(p2, p3) + cmd.substring(p1, p2);
            cursor_pos = p4;
        }
    }

    function upcase_word() {
        var end = skip_word_forward(cursor_pos);
        cmd = cmd.substring(0, cursor_pos) +
            cmd.substring(cursor_pos, end).toUpperCase() +
            cmd.substring(end);
    }

    function downcase_word() {
        var end = skip_word_forward(cursor_pos);
        cmd = cmd.substring(0, cursor_pos) +
            cmd.substring(cursor_pos, end).toLowerCase() +
            cmd.substring(end);
    }

    function kill_region(start, end, dir) {
        var s = cmd.substring(start, end);
        if (last_fun !== kill_region)
            clip_board = s;
        else if (dir < 0)
            clip_board = s + clip_board;
        else
            clip_board = clip_board + s;

        cmd = cmd.substring(0, start) + cmd.substring(end);
        if (cursor_pos > end)
            cursor_pos -= end - start;
        else if (cursor_pos > start)
            cursor_pos = start;
        this_fun = kill_region;
    }

    function kill_line() {
        kill_region(cursor_pos, cmd.length, 1);
    }

    function backward_kill_line() {
        kill_region(0, cursor_pos, -1);
    }

    function kill_word() {
        kill_region(cursor_pos, skip_word_forward(cursor_pos), 1);
    }

    function backward_kill_word() {
        kill_region(skip_word_backward(cursor_pos), cursor_pos, -1);
    }

    function yank() {
        insert(clip_board);
    }

    function control_c() {
        if (last_fun === control_c) {
            std.puts(""\n"");
            std.exit(0);
        } else {
            std.puts(""\n(Press Ctrl-C again to quit)\n"");
            readline_print_prompt();
        }
    }

    function reset() {
        cmd = """";
        cursor_pos = 0;
    }

    function get_context_word(line, pos) {
        var s = """";
        while (pos > 0 && is_word(line[pos - 1])) {
            pos--;
            s = line[pos] + s;
        }
        return s;
    }
    function get_context_object(line, pos) {
        var obj, base, c;
        if (pos <= 0 || "" ~!%^&*(-+={[|:;,<>?/"".indexOf(line[pos - 1]) >= 0)
            return g;
        if (pos >= 2 && line[pos - 1] === ""."") {
            pos--;
            obj = {};
            switch (c = line[pos - 1]) {
            case '\'':
            case '\""':
                return ""a"";
            case ']':
                return [];
            case '}':
                return {};
            case '/':
                return / /;
            default:
                if (is_word(c)) {
                    base = get_context_word(line, pos);
                    if ([""true"", ""false"", ""null"", ""this""].includes(base) || !isNaN(+base))
                        return eval(base);
                    obj = get_context_object(line, pos - base.length);
                    if (obj === null || obj === void 0)
                        return obj;
                    if (obj === g && obj[base] === void 0)
                        return eval(base);
                    else
                        return obj[base];
                }
                return {};
            }
        }
        return void 0;
    }

    function get_completions(line, pos) {
        var s, obj, ctx_obj, r, i, j, paren;

        s = get_context_word(line, pos);
        ctx_obj = get_context_object(line, pos - s.length);
        r = [];
        /* enumerate properties from object and its prototype chain,
           add non-numeric regular properties with s as e prefix
         */
        for (i = 0, obj = ctx_obj; i < 10 && obj !== null && obj !== void 0; i++) {
            var props = Object.getOwnPropertyNames(obj);
            /* add non-numeric regular properties */
            for (j = 0; j < props.length; j++) {
                var prop = props[j];
                if (typeof prop == ""string"" && """"+(+prop) != prop && prop.startsWith(s))
                    r.push(prop);
            }
            obj = Object.getPrototypeOf(obj);
        }
        if (r.length > 1) {
            /* sort list with internal names last and remove duplicates */
            function symcmp(a, b) {
                if (a[0] != b[0]) {
                    if (a[0] == '_')
                        return 1;
                    if (b[0] == '_')
                        return -1;
                }
                if (a < b)
                    return -1;
                if (a > b)
                    return +1;
                return 0;
            }
            r.sort(symcmp);
            for(i = j = 1; i < r.length; i++) {
                if (r[i] != r[i - 1])
                    r[j++] = r[i];
            }
            r.length = j;
        }
        /* 'tab' = list of completions, 'pos' = cursor position inside
           the completions */
        return { tab: r, pos: s.length, ctx: ctx_obj };
    }

    function completion() {
        var tab, res, s, i, j, len, t, max_width, col, n_cols, row, n_rows;
        res = get_completions(cmd, cursor_pos);
        tab = res.tab;
        if (tab.length === 0)
            return;
        s = tab[0];
        len = s.length;
        /* add the chars which are identical in all the completions */
        for(i = 1; i < tab.length; i++) {
            t = tab[i];
            for(j = 0; j < len; j++) {
                if (t[j] !== s[j]) {
                    len = j;
                    break;
                }
            }
        }
        for(i = res.pos; i < len; i++) {
            insert(s[i]);
        }
        if (last_fun === completion && tab.length == 1) {
            /* append parentheses to function names */
            var m = res.ctx[tab[0]];
            if (typeof m == ""function"") {
                insert('(');
                if (m.length == 0)
                    insert(')');
            } else if (typeof m == ""object"") {
                insert('.');
            }
        }
        /* show the possible completions */
        if (last_fun === completion && tab.length >= 2) {
            max_width = 0;
            for(i = 0; i < tab.length; i++)
                max_width = Math.max(max_width, tab[i].length);
            max_width += 2;
            n_cols = Math.max(1, Math.floor((term_width + 1) / max_width));
            n_rows = Math.ceil(tab.length / n_cols);
            std.puts(""\n"");
            /* display the sorted list column-wise */
            for (row = 0; row < n_rows; row++) {
                for (col = 0; col < n_cols; col++) {
                    i = col * n_rows + row;
                    if (i >= tab.length)
                        break;
                    s = tab[i];
                    if (col != n_cols - 1)
                        s = s.padEnd(max_width);
                    std.puts(s);
                }
                std.puts(""\n"");
            }
            /* show a new prompt */
            readline_print_prompt();
        }
    }

    var commands = {        /* command table */
        ""\x01"":     beginning_of_line,      /* ^A - bol */
        ""\x02"":     backward_char,          /* ^B - backward-char */
        ""\x03"":     control_c,              /* ^C - abort */
        ""\x04"":     control_d,              /* ^D - delete-char or exit */
        ""\x05"":     end_of_line,            /* ^E - eol */
        ""\x06"":     forward_char,           /* ^F - forward-char */
        ""\x07"":     abort,                  /* ^G - bell */
        ""\x08"":     backward_delete_char,   /* ^H - backspace */
        ""\x09"":     completion,             /* ^I - history-search-backward */
        ""\x0a"":     accept_line,            /* ^J - newline */
        ""\x0b"":     kill_line,              /* ^K - delete to end of line */
        ""\x0d"":     accept_line,            /* ^M - enter */
        ""\x0e"":     next_history,           /* ^N - down */
        ""\x10"":     previous_history,       /* ^P - up */
        ""\x11"":     quoted_insert,          /* ^Q - quoted-insert */
        ""\x12"":     alert,                  /* ^R - reverse-search */
        ""\x13"":     alert,                  /* ^S - search */
        ""\x14"":     transpose_chars,        /* ^T - transpose */
        ""\x18"":     reset,                  /* ^X - cancel */
        ""\x19"":     yank,                   /* ^Y - yank */
        ""\x1bOA"":   previous_history,       /* ^[OA - up */
        ""\x1bOB"":   next_history,           /* ^[OB - down */
        ""\x1bOC"":   forward_char,           /* ^[OC - right */
        ""\x1bOD"":   backward_char,          /* ^[OD - left */
        ""\x1bOF"":   forward_word,           /* ^[OF - ctrl-right */
        ""\x1bOH"":   backward_word,          /* ^[OH - ctrl-left */
        ""\x1b[1;5C"": forward_word,          /* ^[[1;5C - ctrl-right */
        ""\x1b[1;5D"": backward_word,         /* ^[[1;5D - ctrl-left */
        ""\x1b[1~"":  beginning_of_line,      /* ^[[1~ - bol */
        ""\x1b[3~"":  delete_char,            /* ^[[3~ - delete */
        ""\x1b[4~"":  end_of_line,            /* ^[[4~ - eol */
        ""\x1b[5~"":  history_search_backward,/* ^[[5~ - page up */
        ""\x1b[6~"":  history_search_forward, /* ^[[5~ - page down */
        ""\x1b[A"":   previous_history,       /* ^[[A - up */
        ""\x1b[B"":   next_history,           /* ^[[B - down */
        ""\x1b[C"":   forward_char,           /* ^[[C - right */
        ""\x1b[D"":   backward_char,          /* ^[[D - left */
        ""\x1b[F"":   end_of_line,            /* ^[[F - end */
        ""\x1b[H"":   beginning_of_line,      /* ^[[H - home */
        ""\x1b\x7f"": backward_kill_word,     /* M-C-? - backward_kill_word */
        ""\x1bb"":    backward_word,          /* M-b - backward_word */
        ""\x1bd"":    kill_word,              /* M-d - kill_word */
        ""\x1bf"":    forward_word,           /* M-f - backward_word */
        ""\x1bk"":    backward_kill_line,     /* M-k - backward_kill_line */
        ""\x1bl"":    downcase_word,          /* M-l - downcase_word */
        ""\x1bt"":    transpose_words,        /* M-t - transpose_words */
        ""\x1bu"":    upcase_word,            /* M-u - upcase_word */
        ""\x7f"":     backward_delete_char,   /* ^? - delete */
    };

    function dupstr(str, count) {
        var res = """";
        while (count-- > 0)
            res += str;
        return res;
    }

    var readline_keys;
    var readline_state;
    var readline_cb;

    function readline_print_prompt()
    {
        std.puts(prompt);
        term_cursor_x = ucs_length(prompt) % term_width;
        last_cmd = """";
        last_cursor_pos = 0;
    }

    function readline_start(defstr, cb) {
        cmd = defstr || """";
        cursor_pos = cmd.length;
        history_index = history.length;
        readline_cb = cb;

        prompt = pstate;

        if (mexpr) {
            prompt += dupstr("" "", plen - prompt.length);
            prompt += ps2;
        } else {
            if (show_time) {
                var t = Math.round(eval_time) + "" "";
                eval_time = 0;
                t = dupstr(""0"", 5 - t.length) + t;
                prompt += t.substring(0, t.length - 4) + ""."" + t.substring(t.length - 4);
            }
            plen = prompt.length;
            prompt += ps1;
        }
        readline_print_prompt();
        update();
        readline_state = 0;
    }

    function handle_char(c1) {
        var c;
        c = String.fromCodePoint(c1);
        switch(readline_state) {
        case 0:
            if (c == '\x1b') {  /* '^[' - ESC */
                readline_keys = c;
                readline_state = 1;
            } else {
                handle_key(c);
            }
            break;
        case 1: /* '^[ */
            readline_keys += c;
            if (c == '[') {
                readline_state = 2;
            } else if (c == 'O') {
                readline_state = 3;
            } else {
                handle_key(readline_keys);
                readline_state = 0;
            }
            break;
        case 2: /* '^[[' - CSI */
            readline_keys += c;
            if (!(c == ';' || (c >= '0' && c <= '9'))) {
                handle_key(readline_keys);
                readline_state = 0;
            }
            break;
        case 3: /* '^[O' - ESC2 */
            readline_keys += c;
            handle_key(readline_keys);
            readline_state = 0;
            break;
        }
    }

    function handle_key(keys) {
        var fun;

        if (quote_flag) {
            if (ucs_length(keys) === 1)
                insert(keys);
            quote_flag = false;
        } else if (fun = commands[keys]) {
            this_fun = fun;
            switch (fun(keys)) {
            case -1:
                readline_cb(cmd);
                return;
            case -2:
                readline_cb(null);
                return;
            case -3:
                /* uninstall a Ctrl-C signal handler */
                os.signal(os.SIGINT, null);
                /* uninstall the stdin read handler */
                os.setReadHandler(term_fd, null);
                return;
            }
            last_fun = this_fun;
        } else if (ucs_length(keys) === 1 && keys >= ' ') {
            insert(keys);
            last_fun = insert;
        } else {
            alert(); /* beep! */
        }

        cursor_pos = (cursor_pos < 0) ? 0 :
            (cursor_pos > cmd.length) ? cmd.length : cursor_pos;
        update();
    }

    var hex_mode = false;
    var eval_mode = ""std"";

    function number_to_string(a, radix) {
        var s;
        if (!isFinite(a)) {
            /* NaN, Infinite */
            return a.toString();
        } else {
            if (a == 0) {
                if (1 / a < 0)
                    s = ""-0"";
                else
                    s = ""0"";
            } else {
                if (radix == 16 && a === Math.floor(a)) {
                    var s;
                    if (a < 0) {
                        a = -a;
                        s = ""-"";
                    } else {
                        s = """";
                    }
                    s += ""0x"" + a.toString(16);
                } else {
                    s = a.toString();
                }
            }
            return s;
        }
    }

    function bigfloat_to_string(a, radix) {
        var s;
        if (!BigFloat.isFinite(a)) {
            /* NaN, Infinite */
            if (eval_mode !== ""math"") {
                return ""BigFloat("" + a.toString() + "")"";
            } else {
                return a.toString();
            }
        } else {
            if (a == 0) {
                if (1 / a < 0)
                    s = ""-0"";
                else
                    s = ""0"";
            } else {
                if (radix == 16) {
                    var s;
                    if (a < 0) {
                        a = -a;
                        s = ""-"";
                    } else {
                        s = """";
                    }
                    s += ""0x"" + a.toString(16);
                } else {
                    s = a.toString();
                }
            }
            if (typeof a === ""bigfloat"" && eval_mode !== ""math"") {
                s += ""l"";
            } else if (eval_mode !== ""std"" && s.indexOf(""."") < 0 &&
                ((radix == 16 && s.indexOf(""p"") < 0) ||
                 (radix == 10 && s.indexOf(""e"") < 0))) {
                /* add a decimal point so that the floating point type
                   is visible */
                s += "".0"";
            }
            return s;
        }
    }

    function bigint_to_string(a, radix) {
        var s;
        if (radix == 16) {
            var s;
            if (a < 0) {
                a = -a;
                s = ""-"";
            } else {
                s = """";
            }
            s += ""0x"" + a.toString(16);
        } else {
            s = a.toString();
        }
        if (eval_mode === ""std"")
            s += ""n"";
        return s;
    }

    function print(a) {
        var stack = [];

        function print_rec(a) {
            var n, i, keys, key, type, s;

            type = typeof(a);
            if (type === ""object"") {
                if (a === null) {
                    std.puts(a);
                } else if (stack.indexOf(a) >= 0) {
                    std.puts(""[circular]"");
                } else if (has_jscalc && (a instanceof Fraction ||
                                        a instanceof Complex ||
                                        a instanceof Mod ||
                                        a instanceof Polynomial ||
                                        a instanceof PolyMod ||
                                        a instanceof RationalFunction ||
                                        a instanceof Series)) {
                    std.puts(a.toString());
                } else {
                    stack.push(a);
                    if (Array.isArray(a)) {
                        n = a.length;
                        std.puts(""[ "");
                        for(i = 0; i < n; i++) {
                            if (i !== 0)
                                std.puts("", "");
                            if (i in a) {
                                print_rec(a[i]);
                            } else {
                                std.puts(""<empty>"");
                            }
                            if (i > 20) {
                                std.puts(""..."");
                                break;
                            }
                        }
                        std.puts("" ]"");
                    } else if (Object.__getClass(a) === ""RegExp"") {
                        std.puts(a.toString());
                    } else {
                        keys = Object.keys(a);
                        n = keys.length;
                        std.puts(""{ "");
                        for(i = 0; i < n; i++) {
                            if (i !== 0)
                                std.puts("", "");
                            key = keys[i];
                            std.puts(key, "": "");
                            print_rec(a[key]);
                        }
                        std.puts("" }"");
                    }
                    stack.pop(a);
                }
            } else if (type === ""string"") {
                s = a.__quote();
                if (s.length > 79)
                    s = s.substring(0, 75) + ""...\"""";
                std.puts(s);
            } else if (type === ""number"") {
                std.puts(number_to_string(a, hex_mode ? 16 : 10));
            } else if (type === ""bigint"") {
                std.puts(bigint_to_string(a, hex_mode ? 16 : 10));
            } else if (type === ""bigfloat"") {
                std.puts(bigfloat_to_string(a, hex_mode ? 16 : 10));
            } else if (type === ""bigdecimal"") {
                std.puts(a.toString() + ""m"");
            } else if (type === ""symbol"") {
                std.puts(String(a));
            } else if (type === ""function"") {
                std.puts(""function "" + a.name + ""()"");
            } else {
                std.puts(a);
            }
        }
        print_rec(a);
    }

    function extract_directive(a) {
        var pos;
        if (a[0] !== '\\')
            return """";
        for (pos = 1; pos < a.length; pos++) {
            if (!is_alpha(a[pos]))
                break;
        }
        return a.substring(1, pos);
    }

    /* return true if the string after cmd can be evaluted as JS */
    function handle_directive(cmd, expr) {
        var param, prec1, expBits1;

        if (cmd === ""h"" || cmd === ""?"" || cmd == ""help"") {
            help();
        } else if (cmd === ""load"") {
            var filename = expr.substring(cmd.length + 1).trim();
            if (filename.lastIndexOf(""."") <= filename.lastIndexOf(""/""))
                filename += "".js"";
            std.loadScript(filename);
            return false;
        } else if (cmd === ""x"") {
            hex_mode = true;
        } else if (cmd === ""d"") {
            hex_mode = false;
        } else if (cmd === ""t"") {
            show_time = !show_time;
        } else if (has_bignum && cmd === ""p"") {
            param = expr.substring(cmd.length + 1).trim().split("" "");
            if (param.length === 1 && param[0] === """") {
                std.puts(""BigFloat precision="" + prec + "" bits (~"" +
                          Math.floor(prec / log2_10) +
                          "" digits), exponent size="" + expBits + "" bits\n"");
            } else if (param[0] === ""f16"") {
                prec = 11;
                expBits = 5;
            } else if (param[0] === ""f32"") {
                prec = 24;
                expBits = 8;
            } else if (param[0] === ""f64"") {
                prec = 53;
                expBits = 11;
            } else if (param[0] === ""f128"") {
                prec = 113;
                expBits = 15;
            } else {
                prec1 = parseInt(param[0]);
                if (param.length >= 2)
                    expBits1 = parseInt(param[1]);
                else
                    expBits1 = BigFloatEnv.expBitsMax;
                if (Number.isNaN(prec1) ||
                    prec1 < BigFloatEnv.precMin ||
                    prec1 > BigFloatEnv.precMax) {
                    std.puts(""Invalid precision\n"");
                    return false;
                }
                if (Number.isNaN(expBits1) ||
                    expBits1 < BigFloatEnv.expBitsMin ||
                    expBits1 > BigFloatEnv.expBitsMax) {
                    std.puts(""Invalid exponent bits\n"");
                    return false;
                }
                prec = prec1;
                expBits = expBits1;
            }
            return false;
        } else if (has_bignum && cmd === ""digits"") {
            param = expr.substring(cmd.length + 1).trim();
            prec1 = Math.ceil(parseFloat(param) * log2_10);
            if (prec1 < BigFloatEnv.precMin ||
                prec1 > BigFloatEnv.precMax) {
                std.puts(""Invalid precision\n"");
                return false;
            }
            prec = prec1;
            expBits = BigFloatEnv.expBitsMax;
            return false;
        } else if (has_bignum && cmd === ""mode"") {
            param = expr.substring(cmd.length + 1).trim();
            if (param === """") {
                std.puts(""Running mode="" + eval_mode + ""\n"");
            } else if (param === ""std"" || param === ""math"") {
                eval_mode = param;
            } else {
                std.puts(""Invalid mode\n"");
            }
            return false;
        } else if (cmd === ""clear"") {
            std.puts(""\x1b[H\x1b[J"");
        } else if (cmd === ""q"") {
            std.exit(0);
        } else if (has_jscalc && cmd === ""a"") {
            algebraicMode = true;
        } else if (has_jscalc && cmd === ""n"") {
            algebraicMode = false;
        } else {
            std.puts(""Unknown directive: "" + cmd + ""\n"");
            return false;
        }
        return true;
    }

    if (config_numcalc) {
        /* called by the GUI */
        g.execCmd = function (cmd) {
            switch(cmd) {
            case ""dec"":
                hex_mode = false;
                break;
            case ""hex"":
                hex_mode = true;
                break;
            case ""num"":
                algebraicMode = false;
                break;
            case ""alg"":
                algebraicMode = true;
                break;
            }
        }
    }

    function help() {
        function sel(n) {
            return n ? ""*"": "" "";
        }
        std.puts(""\\h          this help\n"" +
                 ""\\x         "" + sel(hex_mode) + ""hexadecimal number display\n"" +
                 ""\\d         "" + sel(!hex_mode) + ""decimal number display\n"" +
                 ""\\t         "" + sel(show_time) + ""toggle timing display\n"" +
                  ""\\clear      clear the terminal\n"");
        if (has_jscalc) {
            std.puts(""\\a         "" + sel(algebraicMode) + ""algebraic mode\n"" +
                     ""\\n         "" + sel(!algebraicMode) + ""numeric mode\n"");
        }
        if (has_bignum) {
            std.puts(""\\p [m [e]]  set the BigFloat precision to 'm' bits\n"" +
                     ""\\digits n   set the BigFloat precision to 'ceil(n*log2(10))' bits\n"");
            if (!has_jscalc) {
                std.puts(""\\mode [std|math] change the running mode (current = "" + eval_mode + "")\n"");
            }
        }
        if (!config_numcalc) {
            std.puts(""\\q          exit\n"");
        }
    }

    function eval_and_print(expr) {
        var result;

        try {
            if (eval_mode === ""math"")
                expr = '""use math""; void 0;' + expr;
            var now = (new Date).getTime();
            /* eval as a script */
            result = std.evalScript(expr, { backtrace_barrier: true });
            eval_time = (new Date).getTime() - now;
            std.puts(colors[styles.result]);
            print(result);
            std.puts(""\n"");
            std.puts(colors.none);
            /* set the last result */
            g._ = result;
        } catch (error) {
            std.puts(colors[styles.error_msg]);
            if (error instanceof Error) {
                console.log(error);
                if (error.stack) {
                    std.puts(error.stack);
                }
            } else {
                std.puts(""Throw: "");
                console.log(error);
            }
            std.puts(colors.none);
        }
    }

    function cmd_start() {
        if (!config_numcalc) {
            if (has_jscalc)
                std.puts('QJSCalc - Type ""\\h"" for help\n');
            else
                std.puts('QuickJS - Type ""\\h"" for help\n');
        }
        if (has_bignum) {
            log2_10 = Math.log(10) / Math.log(2);
            prec = 113;
            expBits = 15;
            if (has_jscalc) {
                eval_mode = ""math"";
                /* XXX: numeric mode should always be the default ? */
                g.algebraicMode = config_numcalc;
            }
        }

        cmd_readline_start();
    }

    function cmd_readline_start() {
        readline_start(dupstr(""    "", level), readline_handle_cmd);
    }

    function readline_handle_cmd(expr) {
        handle_cmd(expr);
        cmd_readline_start();
    }

    function handle_cmd(expr) {
        var colorstate, cmd;

        if (expr === null) {
            expr = """";
            return;
        }
        if (expr === ""?"") {
            help();
            return;
        }
        cmd = extract_directive(expr);
        if (cmd.length > 0) {
            if (!handle_directive(cmd, expr))
                return;
            expr = expr.substring(cmd.length + 1);
        }
        if (expr === """")
            return;

        if (mexpr)
            expr = mexpr + '\n' + expr;
        colorstate = colorize_js(expr);
        pstate = colorstate[0];
        level = colorstate[1];
        if (pstate) {
            mexpr = expr;
            return;
        }
        mexpr = """";

        if (has_bignum) {
            BigFloatEnv.setPrec(eval_and_print.bind(null, expr),
                                prec, expBits);
        } else {
            eval_and_print(expr);
        }
        level = 0;

        /* run the garbage collector after each command */
        std.gc();
    }

    function colorize_js(str) {
        var i, c, start, n = str.length;
        var style, state = """", level = 0;
        var primary, can_regex = 1;
        var r = [];

        function push_state(c) { state += c; }
        function last_state(c) { return state.substring(state.length - 1); }
        function pop_state(c) {
            var c = last_state();
            state = state.substring(0, state.length - 1);
            return c;
        }

        function parse_block_comment() {
            style = 'comment';
            push_state('/');
            for (i++; i < n - 1; i++) {
                if (str[i] == '*' && str[i + 1] == '/') {
                    i += 2;
                    pop_state('/');
                    break;
                }
            }
        }

        function parse_line_comment() {
            style = 'comment';
            for (i++; i < n; i++) {
                if (str[i] == '\n') {
                    break;
                }
            }
        }

        function parse_string(delim) {
            style = 'string';
            push_state(delim);
            while (i < n) {
                c = str[i++];
                if (c == '\n') {
                    style = 'error';
                    continue;
                }
                if (c == '\\') {
                    if (i >= n)
                        break;
                    i++;
                } else
                if (c == delim) {
                    pop_state();
                    break;
                }
            }
        }

        function parse_regex() {
            style = 'regex';
            push_state('/');
            while (i < n) {
                c = str[i++];
                if (c == '\n') {
                    style = 'error';
                    continue;
                }
                if (c == '\\') {
                    if (i < n) {
                        i++;
                    }
                    continue;
                }
                if (last_state() == '[') {
                    if (c == ']') {
                        pop_state()
                    }
                    // ECMA 5: ignore '/' inside char classes
                    continue;
                }
                if (c == '[') {
                    push_state('[');
                    if (str[i] == '[' || str[i] == ']')
                        i++;
                    continue;
                }
                if (c == '/') {
                    pop_state();
                    while (i < n && is_word(str[i]))
                        i++;
                    break;
                }
            }
        }

        function parse_number() {
            style = 'number';
            while (i < n && (is_word(str[i]) || (str[i] == '.' && (i == n - 1 || str[i + 1] != '.')))) {
                i++;
            }
        }

        var js_keywords = ""|"" +
            ""break|case|catch|continue|debugger|default|delete|do|"" +
            ""else|finally|for|function|if|in|instanceof|new|"" +
            ""return|switch|this|throw|try|typeof|while|with|"" +
            ""class|const|enum|import|export|extends|super|"" +
            ""implements|interface|let|package|private|protected|"" +
            ""public|static|yield|"" +
            ""undefined|null|true|false|Infinity|NaN|"" +
            ""eval|arguments|"" +
            ""await|"";

        var js_no_regex = ""|this|super|undefined|null|true|false|Infinity|NaN|arguments|"";
        var js_types = ""|void|var|"";

        function parse_identifier() {
            can_regex = 1;

            while (i < n && is_word(str[i]))
                i++;

            var w = '|' + str.substring(start, i) + '|';

            if (js_keywords.indexOf(w) >= 0) {
                style = 'keyword';
                if (js_no_regex.indexOf(w) >= 0)
                    can_regex = 0;
                return;
            }

            var i1 = i;
            while (i1 < n && str[i1] == ' ')
                i1++;

            if (i1 < n && str[i1] == '(') {
                style = 'function';
                return;
            }

            if (js_types.indexOf(w) >= 0) {
                style = 'type';
                return;
            }

            style = 'identifier';
            can_regex = 0;
        }

        function set_style(from, to) {
            while (r.length < from)
                r.push('default');
            while (r.length < to)
                r.push(style);
        }

        for (i = 0; i < n;) {
            style = null;
            start = i;
            switch (c = str[i++]) {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                continue;
            case '+':
            case '-':
                if (i < n && str[i] == c) {
                    i++;
                    continue;
                }
                can_regex = 1;
                continue;
            case '/':
                if (i < n && str[i] == '*') { // block comment
                    parse_block_comment();
                    break;
                }
                if (i < n && str[i] == '/') { // line comment
                    parse_line_comment();
                    break;
                }
                if (can_regex) {
                    parse_regex();
                    can_regex = 0;
                    break;
                }
                can_regex = 1;
                continue;
            case '\'':
            case '\""':
            case '`':
                parse_string(c);
                can_regex = 0;
                break;
            case '(':
            case '[':
            case '{':
                can_regex = 1;
                level++;
                push_state(c);
                continue;
            case ')':
            case ']':
            case '}':
                can_regex = 0;
                if (level > 0 && is_balanced(last_state(), c)) {
                    level--;
                    pop_state();
                    continue;
                }
                style = 'error';
                break;
            default:
                if (is_digit(c)) {
                    parse_number();
                    can_regex = 0;
                    break;
                }
                if (is_word(c) || c == '$') {
                    parse_identifier();
                    break;
                }
                can_regex = 1;
                continue;
            }
            if (style)
                set_style(start, i);
        }
        set_style(n, n);
        return [ state, level, r ];
    }

    termInit();

    cmd_start();

})(globalThis);"
modules/internal/streams/readable.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { addAbortSignalNoValidate } from ""./add-abort-signal.js"";
import { Buffer } from ""buffer"";
import { debuglog } from ""../util/debuglog.js"";
import { getDefaultHighWaterMark, getHighWaterMark } from ""./state.js"";
import { prependListener, Stream } from ""./legacy.js"";
import { StringDecoder } from ""string_decoder"";
import { validateObject } from ""../validators.js"";
import {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_PUSH_AFTER_EOF,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
} from ""../errors.js"";
import _from from ""./from.js"";
import BufferList from ""./buffer_list.js"";
import destroyImpl from ""./destroy.js"";
import EE from ""events"";

let debug = debuglog(""stream"", (fn) => {
    debug = fn;
});

const kPaused = Symbol(""kPaused"");

const nop = () => { };

const { errorOrDestroy } = destroyImpl;

function ReadableState(options, stream, isDuplex) {
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== ""boolean"") {
        isDuplex = stream instanceof Stream.Duplex;
    }

    // Object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away.
    this.objectMode = !!(options && options.objectMode);

    if (isDuplex) {
        this.objectMode = this.objectMode ||
            !!(options && options.readableObjectMode);
    }

    // The point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means ""don't call _read preemptively ever""
    this.highWaterMark = options
        ? getHighWaterMark(this, options, ""readableHighWaterMark"", isDuplex)
        : getDefaultHighWaterMark(false);

    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift().
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;

    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    this.constructed = true;

    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until ""later"" should generally also
    // not happen before the first read call.
    this.sync = true;

    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;

    // True if the error was already emitted and should not be thrown again.
    this.errorEmitted = false;

    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = !options || options.emitClose !== false;

    // Should .destroy() be called after 'end' (and potentially 'finish').
    this.autoDestroy = !options || options.autoDestroy !== false;

    // Has it been destroyed.
    this.destroyed = false;

    // Indicates whether the stream has errored. When true no further
    // _read calls, 'data' or 'readable' events should occur. This is needed
    // since when autoDestroy is disabled we need a way to tell whether the
    // stream has failed.
    this.errored = null;

    // Indicates whether the stream has finished destroying.
    this.closed = false;

    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    this.closeEmitted = false;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = (options && options.defaultEncoding) || ""utf8"";

    // Ref the piped dest which we need a drain event on it
    // type: null | Writable | Set<Writable>.
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;

    // If true, a maybeReadMore has been scheduled.
    this.readingMore = false;

    this.dataEmitted = false;

    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}


function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }

    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5.
    const isDuplex = this instanceof Stream.Duplex;

    this._readableState = new ReadableState(options, this, isDuplex);

    if (options) {
        if (typeof options.read === ""function"") {
            this._read = options.read;
        }

        if (typeof options.destroy === ""function"") {
            this._destroy = options.destroy;
        }

        if (typeof options.construct === ""function"") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }

    Stream.call(this, options);

    destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}

Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
    cb(err);
};

Readable.prototype[EE.captureRejectionSymbol] = function (err) {
    this.destroy(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read().
Readable.prototype.unshift = function (chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};

function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug(""readableAddChunk"", chunk);
    const state = stream._readableState;

    let err;
    if (!state.objectMode) {
        if (typeof chunk === ""string"") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
                if (addToFront && state.encoding) {
                    // When unshifting, if state.encoding is set, we have to save
                    // the string in the BufferList with the state encoding.
                    chunk = Buffer.from(chunk, encoding).toString(state.encoding);
                } else {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = """";
                }
            }
        } else if (chunk instanceof Buffer) {
            encoding = """";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = """";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE(
                ""chunk"",
                [""string"", ""Buffer"", ""Uint8Array""],
                chunk,
            );
        }
    }

    if (err) {
        errorOrDestroy(stream, err);
    } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else if (state.objectMode || (chunk && chunk.length > 0)) {
        if (addToFront) {
            if (state.endEmitted) {
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state, chunk, true);
            }
        } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
            return false;
        } else {
            state.reading = false;
            if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) {
                    addChunk(stream, state, chunk, false);
                } else {
                    maybeReadMore(stream, state);
                }
            } else {
                addChunk(stream, state, chunk, false);
            }
        }
    } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
    }

    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended &&
        (state.length < state.highWaterMark || state.length === 0);
}


function addChunk(stream, state, chunk, addToFront) {
    if (
        state.flowing && state.length === 0 && !state.sync &&
        stream.listenerCount(""data"") > 0
    ) {
        // Use the guard to avoid creating `Set()` repeatedly
        // when we have multiple pipes.
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit(""data"", chunk);
    } else {
        // Update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state.buffer.unshift(chunk);
        } else {
            state.buffer.push(chunk);
        }

        if (state.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state);
}

Readable.prototype.isPaused = function () {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
};

// Backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8.
    this._readableState.encoding = this._readableState.decoder.encoding;

    const buffer = this._readableState.buffer;
    // Iterate over current buffer to convert already stored Buffers:
    let content = """";
    for (const data of buffer) {
        content += decoder.write(data);
    }
    buffer.clear();
    if (content !== """") {
        buffer.push(content);
    }
    this._readableState.length = content.length;
    return this;
};

// Don't raise the hwm > 1GB.
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts.
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || (state.length === 0 && state.ended)) {
        return 0;
    }
    if (state.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        // Only flow one buffer at a time.
        if (state.flowing && state.length) {
            return state.buffer.first().length;
        }
        return state.length;
    }
    if (n <= state.length) {
        return n;
    }
    return state.ended ? state.length : 0;
}

// You can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
    debug(""read"", n);
    // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
    // in this scenario, so we are doing it manually.
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;

    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) {
        state.highWaterMark = computeNewHighWaterMark(n);
    }

    if (n !== 0) {
        state.emittedReadable = false;
    }

    // If we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (
        n === 0 &&
        state.needReadable &&
        ((state.highWaterMark !== 0
            ? state.length >= state.highWaterMark
            : state.length > 0) ||
            state.ended)
    ) {
        debug(""read: emitReadable"", state.length, state.ended);
        if (state.length === 0 && state.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }

    n = howMuchToRead(n, state);

    // If we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) {
            endReadable(this);
        }
        return null;
    }

    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.

    // if we need a readable event, then we need to do some reading.
    let doRead = state.needReadable;
    debug(""need readable"", doRead);

    // If we currently have less than the highWaterMark, then also read some.
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug(""length less than watermark"", doRead);
    }

    // However, if we've ended, then there's no point, if we're already
    // reading, then it's unnecessary, if we're constructing we have to wait,
    // and if we're destroyed or errored, then it's not allowed,
    if (
        state.ended || state.reading || state.destroyed || state.errored ||
        !state.constructed
    ) {
        doRead = false;
        debug(""reading, ended or constructing"", doRead);
    } else if (doRead) {
        debug(""do read"");
        state.reading = true;
        state.sync = true;
        // If the length is currently zero, then we *need* a readable event.
        if (state.length === 0) {
            state.needReadable = true;
        }

        // Call internal read method
        this._read(state.highWaterMark);

        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) {
            n = howMuchToRead(nOrig, state);
        }
    }

    let ret;
    if (n > 0) {
        ret = fromList(n, state);
    } else {
        ret = null;
    }

    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
    }

    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) {
            state.needReadable = true;
        }

        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) {
            endReadable(this);
        }
    }

    if (ret !== null) {
        state.dataEmitted = true;
        this.emit(""data"", ret);
    }

    return ret;
};

function onEofChunk(stream, state) {
    debug(""onEofChunk"");
    if (state.ended) return;
    if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;

    if (state.sync) {
        // If we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call.
        emitReadable(stream);
    } else {
        // Emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        state.emittedReadable = true;
        // We have to emit readable now that we are EOF. Modules
        // in the ecosystem (e.g. dicer) rely on this event being sync.
        emitReadable_(stream);
    }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    const state = stream._readableState;
    debug(""emitReadable"", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug(""emitReadable"", state.flowing);
        state.emittedReadable = true;
        nextTick(emitReadable_, stream);
    }
}

function emitReadable_(stream) {
    const state = stream._readableState;
    debug(""emitReadable_"", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit(""readable"");
        state.emittedReadable = false;
    }

    // The stream needs another readable event if:
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing &&
        !state.ended &&
        state.length <= state.highWaterMark;
    flow(stream);
}

// At this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
    }
}

function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (
        !state.reading && !state.ended &&
        (state.length < state.highWaterMark ||
            (state.flowing && state.length === 0))
    ) {
        const len = state.length;
        debug(""maybeReadMore read 0"");
        stream.read(0);
        if (len === state.length) {
            // Didn't get any data, stop spinning.
            break;
        }
    }
    state.readingMore = false;
}

// Abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, ""length"" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED(""_read()"");
};

Readable.prototype.pipe = function (dest, pipeOpts) {
    const src = this;
    const state = this._readableState;

    if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new Set(
                state.awaitDrainWriters ? [state.awaitDrainWriters] : [],
            );
        }
    }

    state.pipes.push(dest);
    debug(""pipe count=%d opts=%j"", state.pipes.length, pipeOpts);

    const doEnd = (!pipeOpts || pipeOpts.end !== false)
    // &&
    // dest !== stdio.stdout &&
    // dest !== stdio.stderr;

    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) {
        nextTick(endFn);
    } else {
        src.once(""end"", endFn);
    }

    dest.on(""unpipe"", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug(""onunpipe"");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }

    function onend() {
        debug(""onend"");
        dest.end();
    }

    let ondrain;

    let cleanedUp = false;
    function cleanup() {
        debug(""cleanup"");
        // Cleanup event handlers once the pipe is broken.
        dest.removeListener(""close"", onclose);
        dest.removeListener(""finish"", onfinish);
        if (ondrain) {
            dest.removeListener(""drain"", ondrain);
        }
        dest.removeListener(""error"", onerror);
        dest.removeListener(""unpipe"", onunpipe);
        src.removeListener(""end"", onend);
        src.removeListener(""end"", unpipe);
        src.removeListener(""data"", ondata);

        cleanedUp = true;

        // If the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (
            ondrain && state.awaitDrainWriters &&
            (!dest._writableState || dest._writableState.needDrain)
        ) {
            ondrain();
        }
    }

    function pause() {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
                debug(""false write response, pause"", 0);
                state.awaitDrainWriters = dest;
                state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
                debug(""false write response, pause"", state.awaitDrainWriters.size);
                state.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            // When the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            ondrain = pipeOnDrain(src, dest);
            dest.on(""drain"", ondrain);
        }
    }

    src.on(""data"", ondata);
    function ondata(chunk) {
        debug(""ondata"");
        const ret = dest.write(chunk);
        debug(""dest.write"", ret);
        if (ret === false) {
            pause();
        }
    }

    // If the dest has an error, then stop piping into it.
    // However, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug(""onerror"", er);
        unpipe();
        dest.removeListener(""error"", onerror);
        if (EE.listenerCount(dest, ""error"") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                // User incorrectly emitted 'error' directly on the stream.
                errorOrDestroy(dest, er);
            } else {
                dest.emit(""error"", er);
            }
        }
    }

    // Make sure our error handler is attached before userland ones.
    prependListener(dest, ""error"", onerror);

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener(""finish"", onfinish);
        unpipe();
    }
    dest.once(""close"", onclose);
    function onfinish() {
        debug(""onfinish"");
        dest.removeListener(""close"", onclose);
        unpipe();
    }
    dest.once(""finish"", onfinish);

    function unpipe() {
        debug(""unpipe"");
        src.unpipe(dest);
    }

    // Tell the dest that it's being piped to.
    dest.emit(""pipe"", src);

    // Start the flow if it hasn't been started already.

    if (dest.writableNeedDrain === true) {
        if (state.flowing) {
            pause();
        }
    } else if (!state.flowing) {
        debug(""pipe resume"");
        src.resume();
    }

    return dest;
};

function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state = src._readableState;

        // `ondrain` will call directly,
        // `this` maybe not a reference to dest,
        // so we use the real dest here.
        if (state.awaitDrainWriters === dest) {
            debug(""pipeOnDrain"", 1);
            state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
            debug(""pipeOnDrain"", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
        }

        if (
            (!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&
            EE.listenerCount(src, ""data"")
        ) {
            state.flowing = true;
            flow(src);
        }
    };
}


Readable.prototype.unpipe = function (dest) {
    const state = this._readableState;
    const unpipeInfo = { hasUnpiped: false };

    // If we're not piping anywhere, then do nothing.
    if (state.pipes.length === 0) {
        return this;
    }

    if (!dest) {
        // remove all.
        const dests = state.pipes;
        state.pipes = [];
        this.pause();

        for (let i = 0; i < dests.length; i++) {
            dests[i].emit(""unpipe"", this, { hasUnpiped: false });
        }
        return this;
    }

    // Try to find the right one.
    const index = state.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }

    state.pipes.splice(index, 1);
    if (state.pipes.length === 0) {
        this.pause();
    }

    dest.emit(""unpipe"", this, unpipeInfo);

    return this;
};

// Set up data events if they are asked for
// Ensure readable listeners eventually get something.
Readable.prototype.on = function (ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;

    if (ev === ""data"") {
        // Update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount(""readable"") > 0;

        // Try start flowing on next tick if stream isn't explicitly paused.
        if (state.flowing !== false) {
            this.resume();
        }
    } else if (ev === ""readable"") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug(""on readable"", state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                nextTick(nReadingNextTick, this);
            }
        }
    }

    return res;
};
Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);

    if (ev === ""readable"") {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        nextTick(updateReadableListening, this);
    }

    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;

Readable.prototype.removeAllListeners = function (ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);

    if (ev === ""readable"" || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        nextTick(updateReadableListening, this);
    }

    return res;
};

function updateReadableListening(self) {
    const state = self._readableState;
    state.readableListening = self.listenerCount(""readable"") > 0;

    if (state.resumeScheduled && state[kPaused] === false) {
        // Flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true;

        // Crude way to check if we should resume.
    } else if (self.listenerCount(""data"") > 0) {
        self.resume();
    } else if (!state.readableListening) {
        state.flowing = null;
    }
}

function nReadingNextTick(self) {
    debug(""readable nexttick read 0"");
    self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
    const state = this._readableState;
    if (!state.flowing) {
        debug(""resume"");
        // We flow only if there is no one listening
        // for readable, but we still have to call
        // resume().
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state[kPaused] = false;
    return this;
};

function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
    }
}

function resume_(stream, state) {
    debug(""resume"", state.reading);
    if (!state.reading) {
        stream.read(0);
    }

    state.resumeScheduled = false;
    stream.emit(""resume"");
    flow(stream);
    if (state.flowing && !state.reading) {
        stream.read(0);
    }
}

Readable.prototype.pause = function () {
    debug(""call pause flowing=%j"", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug(""pause"");
        this._readableState.flowing = false;
        this.emit(""pause"");
    }
    this._readableState[kPaused] = true;
    return this;
};

function flow(stream) {
    const state = stream._readableState;
    debug(""flow"", state.flowing);
    while (state.flowing && stream.read() !== null);
}

// Wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
    let paused = false;

    // TODO (ronag): Should this.destroy(err) emit
    // 'error' on the wrapped stream? Would require
    // a static factory method, e.g. Readable.wrap(stream).

    stream.on(""data"", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });

    stream.on(""end"", () => {
        this.push(null);
    });

    stream.on(""error"", (err) => {
        errorOrDestroy(this, err);
    });

    stream.on(""close"", () => {
        this.destroy();
    });

    stream.on(""destroy"", () => {
        this.destroy();
    });

    this._read = () => {
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };

    // Proxy all the other methods. Important when wrapping filters and duplexes.
    const streamKeys = Object.keys(stream);
    for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === undefined && typeof stream[i] === ""function"") {
            this[i] = stream[i].bind(stream);
        }
    }

    return this;
};

Readable.prototype[Symbol.asyncIterator] = function () {
    return streamToAsyncIterator(this);
};

Readable.prototype.iterator = function (options) {
    if (options !== undefined) {
        validateObject(options, ""options"");
    }
    return streamToAsyncIterator(this, options);
};

function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== ""function"") {
        stream = Readable.wrap(stream, { objectMode: true });
    }

    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}

async function* createAsyncIterator(stream, options) {
    let callback = nop;

    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options,
    };

    function next(resolve) {
        if (this === stream) {
            callback();
            callback = nop;
        } else {
            callback = resolve;
        }
    }

    const state = stream._readableState;

    let error = state.errored;
    let errorEmitted = state.errorEmitted;
    let endEmitted = state.endEmitted;
    let closeEmitted = state.closeEmitted;

    stream
        .on(""readable"", next)
        .on(""error"", function (err) {
            error = err;
            errorEmitted = true;
            next.call(this);
        })
        .on(""end"", function () {
            endEmitted = true;
            next.call(this);
        })
        .on(""close"", function () {
            closeEmitted = true;
            next.call(this);
        });

    let errorThrown = false;
    try {
        while (true) {
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            destroyImpl.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally {
        if (!errorThrown && opts.destroyOnReturn) {
            if (state.autoDestroy || !endEmitted) {
                // TODO(ronag): ERR_PREMATURE_CLOSE?
                destroyImpl.destroyer(stream, null);
            }
        }
    }
}

// Making it explicit these properties are not enumerable
// because otherwise some prototype manipulation in
// userland will fail.
Object.defineProperties(Readable.prototype, {
    readable: {
        get() {
            const r = this._readableState;
            // r.readable === false means that this is part of a Duplex stream
            // where the readable side was disabled upon construction.
            // Compat. The user might manually disable readable side through
            // deprecated setter.
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&
                !r.endEmitted;
        },
        set(val) {
            // Backwards compat.
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        },
    },

    readableDidRead: {
        enumerable: false,
        get: function () {
            return this._readableState.dataEmitted;
        },
    },

    readableAborted: {
        enumerable: false,
        get: function () {
            return !!(this._readableState.destroyed || this._readableState.errored) &&
                !this._readableState.endEmitted;
        },
    },

    readableHighWaterMark: {
        enumerable: false,
        get: function () {
            return this._readableState.highWaterMark;
        },
    },

    readableBuffer: {
        enumerable: false,
        get: function () {
            return this._readableState && this._readableState.buffer;
        },
    },

    readableFlowing: {
        enumerable: false,
        get: function () {
            return this._readableState.flowing;
        },
        set: function (state) {
            if (this._readableState) {
                this._readableState.flowing = state;
            }
        },
    },

    readableLength: {
        enumerable: false,
        get() {
            return this._readableState.length;
        },
    },

    readableObjectMode: {
        enumerable: false,
        get() {
            return this._readableState ? this._readableState.objectMode : false;
        },
    },

    readableEncoding: {
        enumerable: false,
        get() {
            return this._readableState ? this._readableState.encoding : null;
        },
    },

    destroyed: {
        enumerable: false,
        get() {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set(value) {
            // We ignore the value if the stream
            // has not been initialized yet.
            if (!this._readableState) {
                return;
            }

            // Backward compatibility, the user is explicitly
            // managing destroyed.
            this._readableState.destroyed = value;
        },
    },

    readableEnded: {
        enumerable: false,
        get() {
            return this._readableState ? this._readableState.endEmitted : false;
        },
    },
});

Object.defineProperties(ReadableState.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
        get() {
            return this.pipes.length;
        },
    },

    // Legacy property for `paused`.
    paused: {
        get() {
            return this[kPaused] !== false;
        },
        set(value) {
            this[kPaused] = !!value;
        },
    },
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered.
    if (state.length === 0) {
        return null;
    }

    let ret;
    if (state.objectMode) {
        ret = state.buffer.shift();
    } else if (!n || n >= state.length) {
        // Read it all, truncate the list.
        if (state.decoder) {
            ret = state.buffer.join("""");
        } else if (state.buffer.length === 1) {
            ret = state.buffer.first();
        } else {
            ret = state.buffer.concat(state.length);
        }
        state.buffer.clear();
    } else {
        // read part of list.
        ret = state.buffer.consume(n, state.decoder);
    }

    return ret;
}

function endReadable(stream) {
    const state = stream._readableState;

    debug(""endReadable"", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
    }
}

function endReadableNT(state, stream) {
    debug(""endReadableNT"", state.endEmitted, state.length);

    // Check that we didn't get one last unshift.
    if (
        !state.errorEmitted && !state.closeEmitted &&
        !state.endEmitted && state.length === 0
    ) {
        state.endEmitted = true;
        stream.emit(""end"");

        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well.
            const wState = stream._writableState;
            const autoDestroy = !wState || (
                wState.autoDestroy &&
                // We don't expect the writable to ever 'finish'
                // if writable is explicitly set to false.
                (wState.finished || wState.writable === false)
            );

            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}

function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded &&
        !stream.destroyed;
    if (writable) {
        stream.end();
    }
}

function readableFrom(iterable, opts) {
    return _from(Readable, iterable, opts);
}

function wrap(src, options) {
    return new Readable({
        objectMode: src.readableObjectMode ?? src.objectMode ?? true,
        ...options,
        destroy(err, callback) {
            destroyImpl.destroyer(src, err);
            callback(err);
        },
    }).wrap(src);
}

// Exposed for testing purposes only.
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;

export default Readable;
export { fromList as _fromList, readableFrom as from, ReadableState, wrap };"
test/crypto/test-crypto-keygen.js,
lib/binding.rs,"/* automatically generated by rust-bindgen 0.68.1 */

pub const JS_PROP_CONFIGURABLE: u32 = 1;
pub const JS_PROP_WRITABLE: u32 = 2;
pub const JS_PROP_ENUMERABLE: u32 = 4;
pub const JS_PROP_C_W_E: u32 = 7;
pub const JS_PROP_LENGTH: u32 = 8;
pub const JS_PROP_TMASK: u32 = 48;
pub const JS_PROP_NORMAL: u32 = 0;
pub const JS_PROP_GETSET: u32 = 16;
pub const JS_PROP_VARREF: u32 = 32;
pub const JS_PROP_AUTOINIT: u32 = 48;
pub const JS_PROP_HAS_SHIFT: u32 = 8;
pub const JS_PROP_HAS_CONFIGURABLE: u32 = 256;
pub const JS_PROP_HAS_WRITABLE: u32 = 512;
pub const JS_PROP_HAS_ENUMERABLE: u32 = 1024;
pub const JS_PROP_HAS_GET: u32 = 2048;
pub const JS_PROP_HAS_SET: u32 = 4096;
pub const JS_PROP_HAS_VALUE: u32 = 8192;
pub const JS_PROP_THROW: u32 = 16384;
pub const JS_PROP_THROW_STRICT: u32 = 32768;
pub const JS_PROP_NO_ADD: u32 = 65536;
pub const JS_PROP_NO_EXOTIC: u32 = 131072;
pub const JS_DEFAULT_STACK_SIZE: u32 = 262144;
pub const JS_EVAL_TYPE_GLOBAL: u32 = 0;
pub const JS_EVAL_TYPE_MODULE: u32 = 1;
pub const JS_EVAL_TYPE_DIRECT: u32 = 2;
pub const JS_EVAL_TYPE_INDIRECT: u32 = 3;
pub const JS_EVAL_TYPE_MASK: u32 = 3;
pub const JS_EVAL_FLAG_STRICT: u32 = 8;
pub const JS_EVAL_FLAG_STRIP: u32 = 16;
pub const JS_EVAL_FLAG_COMPILE_ONLY: u32 = 32;
pub const JS_EVAL_FLAG_BACKTRACE_BARRIER: u32 = 64;
pub const JS_EVAL_FLAG_ASYNC: u32 = 128;
pub const JS_ATOM_NULL: u32 = 0;
pub const JS_CALL_FLAG_CONSTRUCTOR: u32 = 1;
pub const JS_GPN_STRING_MASK: u32 = 1;
pub const JS_GPN_SYMBOL_MASK: u32 = 2;
pub const JS_GPN_PRIVATE_MASK: u32 = 4;
pub const JS_GPN_ENUM_ONLY: u32 = 16;
pub const JS_GPN_SET_ENUM: u32 = 32;
pub const JS_PARSE_JSON_EXT: u32 = 1;
pub const JS_WRITE_OBJ_BYTECODE: u32 = 1;
pub const JS_WRITE_OBJ_BSWAP: u32 = 2;
pub const JS_WRITE_OBJ_SAB: u32 = 4;
pub const JS_WRITE_OBJ_REFERENCE: u32 = 8;
pub const JS_READ_OBJ_BYTECODE: u32 = 1;
pub const JS_READ_OBJ_ROM_DATA: u32 = 2;
pub const JS_READ_OBJ_SAB: u32 = 4;
pub const JS_READ_OBJ_REFERENCE: u32 = 8;
pub const JS_DEF_CFUNC: u32 = 0;
pub const JS_DEF_CGETSET: u32 = 1;
pub const JS_DEF_CGETSET_MAGIC: u32 = 2;
pub const JS_DEF_PROP_STRING: u32 = 3;
pub const JS_DEF_PROP_INT32: u32 = 4;
pub const JS_DEF_PROP_INT64: u32 = 5;
pub const JS_DEF_PROP_DOUBLE: u32 = 6;
pub const JS_DEF_PROP_UNDEFINED: u32 = 7;
pub const JS_DEF_OBJECT: u32 = 8;
pub const JS_DEF_ALIAS: u32 = 9;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSRuntime {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClass {
    _unused: [u8; 0],
}
pub type JSClassID = u32;
pub type JSAtom = u32;
pub const JS_TAG_JS_TAG_FIRST: JS_TAG = -11;
pub const JS_TAG_JS_TAG_BIG_DECIMAL: JS_TAG = -11;
pub const JS_TAG_JS_TAG_BIG_INT: JS_TAG = -10;
pub const JS_TAG_JS_TAG_BIG_FLOAT: JS_TAG = -9;
pub const JS_TAG_JS_TAG_SYMBOL: JS_TAG = -8;
pub const JS_TAG_JS_TAG_STRING: JS_TAG = -7;
pub const JS_TAG_JS_TAG_MODULE: JS_TAG = -3;
pub const JS_TAG_JS_TAG_FUNCTION_BYTECODE: JS_TAG = -2;
pub const JS_TAG_JS_TAG_OBJECT: JS_TAG = -1;
pub const JS_TAG_JS_TAG_INT: JS_TAG = 0;
pub const JS_TAG_JS_TAG_BOOL: JS_TAG = 1;
pub const JS_TAG_JS_TAG_NULL: JS_TAG = 2;
pub const JS_TAG_JS_TAG_UNDEFINED: JS_TAG = 3;
pub const JS_TAG_JS_TAG_UNINITIALIZED: JS_TAG = 4;
pub const JS_TAG_JS_TAG_CATCH_OFFSET: JS_TAG = 5;
pub const JS_TAG_JS_TAG_EXCEPTION: JS_TAG = 6;
pub const JS_TAG_JS_TAG_FLOAT64: JS_TAG = 7;
pub type JS_TAG = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSRefCountHeader {
    pub ref_count: ::std::os::raw::c_int,
}
pub type JSValue = u64;
pub type JSCFunction = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue,
>;
pub type JSCFunctionMagic = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
        magic: ::std::os::raw::c_int,
    ) -> JSValue,
>;
pub type JSCFunctionData = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
        magic: ::std::os::raw::c_int,
        func_data: *mut JSValue,
    ) -> JSValue,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSMallocState {
    pub malloc_count: usize,
    pub malloc_size: usize,
    pub malloc_limit: usize,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSMallocFunctions {
    pub js_malloc: ::std::option::Option<
        unsafe extern ""C"" fn(s: *mut JSMallocState, size: usize) -> *mut ::std::os::raw::c_void,
    >,
    pub js_free: ::std::option::Option<
        unsafe extern ""C"" fn(s: *mut JSMallocState, ptr: *mut ::std::os::raw::c_void),
    >,
    pub js_realloc: ::std::option::Option<
        unsafe extern ""C"" fn(
            s: *mut JSMallocState,
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub js_malloc_usable_size:
        ::std::option::Option<unsafe extern ""C"" fn(ptr: *const ::std::os::raw::c_void) -> usize>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSGCObjectHeader {
    _unused: [u8; 0],
}
extern ""C"" {
    pub fn JS_NewRuntime() -> *mut JSRuntime;
}
extern ""C"" {
    pub fn JS_SetRuntimeInfo(rt: *mut JSRuntime, info: *const ::std::os::raw::c_char);
}
extern ""C"" {
    pub fn JS_SetMemoryLimit(rt: *mut JSRuntime, limit: usize);
}
extern ""C"" {
    pub fn JS_SetGCThreshold(rt: *mut JSRuntime, gc_threshold: usize);
}
extern ""C"" {
    pub fn JS_SetMaxStackSize(rt: *mut JSRuntime, stack_size: usize);
}
extern ""C"" {
    pub fn JS_UpdateStackTop(rt: *mut JSRuntime);
}
extern ""C"" {
    pub fn JS_NewRuntime2(
        mf: *const JSMallocFunctions,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut JSRuntime;
}
extern ""C"" {
    pub fn JS_FreeRuntime(rt: *mut JSRuntime);
}
extern ""C"" {
    pub fn JS_GetRuntimeOpaque(rt: *mut JSRuntime) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn JS_SetRuntimeOpaque(rt: *mut JSRuntime, opaque: *mut ::std::os::raw::c_void);
}
pub type JS_MarkFunc =
    ::std::option::Option<unsafe extern ""C"" fn(rt: *mut JSRuntime, gp: *mut JSGCObjectHeader)>;
extern ""C"" {
    pub fn JS_MarkValue(rt: *mut JSRuntime, val: JSValue, mark_func: JS_MarkFunc);
}
extern ""C"" {
    pub fn JS_RunGC(rt: *mut JSRuntime);
}
extern ""C"" {
    pub fn JS_IsLiveObject(rt: *mut JSRuntime, obj: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_NewContext(rt: *mut JSRuntime) -> *mut JSContext;
}
extern ""C"" {
    pub fn JS_FreeContext(s: *mut JSContext);
}
extern ""C"" {
    pub fn JS_DupContext(ctx: *mut JSContext) -> *mut JSContext;
}
extern ""C"" {
    pub fn JS_GetContextOpaque(ctx: *mut JSContext) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn JS_SetContextOpaque(ctx: *mut JSContext, opaque: *mut ::std::os::raw::c_void);
}
extern ""C"" {
    pub fn JS_GetRuntime(ctx: *mut JSContext) -> *mut JSRuntime;
}
extern ""C"" {
    pub fn JS_SetClassProto(ctx: *mut JSContext, class_id: JSClassID, obj: JSValue);
}
extern ""C"" {
    pub fn JS_GetClassProto(ctx: *mut JSContext, class_id: JSClassID) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewContextRaw(rt: *mut JSRuntime) -> *mut JSContext;
}
extern ""C"" {
    pub fn JS_AddIntrinsicBaseObjects(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicDate(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicEval(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicStringNormalize(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicRegExpCompiler(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicRegExp(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicJSON(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicProxy(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicMapSet(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicTypedArrays(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicPromise(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicBigInt(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicBigFloat(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicBigDecimal(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_AddIntrinsicOperators(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_EnableBignumExt(ctx: *mut JSContext, enable: ::std::os::raw::c_int);
}
extern ""C"" {
    pub fn js_string_codePointRange(
        ctx: *mut JSContext,
        this_val: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern ""C"" {
    pub fn js_malloc_rt(rt: *mut JSRuntime, size: usize) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn js_free_rt(rt: *mut JSRuntime, ptr: *mut ::std::os::raw::c_void);
}
extern ""C"" {
    pub fn js_realloc_rt(
        rt: *mut JSRuntime,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn js_malloc_usable_size_rt(
        rt: *mut JSRuntime,
        ptr: *const ::std::os::raw::c_void,
    ) -> usize;
}
extern ""C"" {
    pub fn js_mallocz_rt(rt: *mut JSRuntime, size: usize) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn js_malloc(ctx: *mut JSContext, size: usize) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn js_free(ctx: *mut JSContext, ptr: *mut ::std::os::raw::c_void);
}
extern ""C"" {
    pub fn js_realloc(
        ctx: *mut JSContext,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn js_malloc_usable_size(ctx: *mut JSContext, ptr: *const ::std::os::raw::c_void) -> usize;
}
extern ""C"" {
    pub fn js_realloc2(
        ctx: *mut JSContext,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        pslack: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn js_mallocz(ctx: *mut JSContext, size: usize) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn js_strdup(
        ctx: *mut JSContext,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern ""C"" {
    pub fn js_strndup(
        ctx: *mut JSContext,
        s: *const ::std::os::raw::c_char,
        n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSMemoryUsage {
    pub malloc_size: i64,
    pub malloc_limit: i64,
    pub memory_used_size: i64,
    pub malloc_count: i64,
    pub memory_used_count: i64,
    pub atom_count: i64,
    pub atom_size: i64,
    pub str_count: i64,
    pub str_size: i64,
    pub obj_count: i64,
    pub obj_size: i64,
    pub prop_count: i64,
    pub prop_size: i64,
    pub shape_count: i64,
    pub shape_size: i64,
    pub js_func_count: i64,
    pub js_func_size: i64,
    pub js_func_code_size: i64,
    pub js_func_pc2line_count: i64,
    pub js_func_pc2line_size: i64,
    pub c_func_count: i64,
    pub array_count: i64,
    pub fast_array_count: i64,
    pub fast_array_elements: i64,
    pub binary_object_count: i64,
    pub binary_object_size: i64,
}
extern ""C"" {
    pub fn JS_ComputeMemoryUsage(rt: *mut JSRuntime, s: *mut JSMemoryUsage);
}
extern ""C"" {
    pub fn JS_DumpMemoryUsage(
        fp: *mut ::std::os::raw::c_int,
        s: *const JSMemoryUsage,
        rt: *mut JSRuntime,
    );
}
extern ""C"" {
    pub fn JS_NewAtomLen(
        ctx: *mut JSContext,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> JSAtom;
}
extern ""C"" {
    pub fn JS_NewAtom(ctx: *mut JSContext, str_: *const ::std::os::raw::c_char) -> JSAtom;
}
extern ""C"" {
    pub fn JS_NewAtomUInt32(ctx: *mut JSContext, n: u32) -> JSAtom;
}
extern ""C"" {
    pub fn JS_DupAtom(ctx: *mut JSContext, v: JSAtom) -> JSAtom;
}
extern ""C"" {
    pub fn JS_FreeAtom(ctx: *mut JSContext, v: JSAtom);
}
extern ""C"" {
    pub fn JS_FreeAtomRT(rt: *mut JSRuntime, v: JSAtom);
}
extern ""C"" {
    pub fn JS_AtomToValue(ctx: *mut JSContext, atom: JSAtom) -> JSValue;
}
extern ""C"" {
    pub fn JS_AtomToString(ctx: *mut JSContext, atom: JSAtom) -> JSValue;
}
extern ""C"" {
    pub fn JS_AtomToCString(ctx: *mut JSContext, atom: JSAtom) -> *const ::std::os::raw::c_char;
}
extern ""C"" {
    pub fn JS_ValueToAtom(ctx: *mut JSContext, val: JSValue) -> JSAtom;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSPropertyEnum {
    pub is_enumerable: ::std::os::raw::c_int,
    pub atom: JSAtom,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSPropertyDescriptor {
    pub flags: ::std::os::raw::c_int,
    pub value: JSValue,
    pub getter: JSValue,
    pub setter: JSValue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClassExoticMethods {
    pub get_own_property: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            desc: *mut JSPropertyDescriptor,
            obj: JSValue,
            prop: JSAtom,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_own_property_names: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            ptab: *mut *mut JSPropertyEnum,
            plen: *mut u32,
            obj: JSValue,
        ) -> ::std::os::raw::c_int,
    >,
    pub delete_property: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            obj: JSValue,
            prop: JSAtom,
        ) -> ::std::os::raw::c_int,
    >,
    pub define_own_property: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            this_obj: JSValue,
            prop: JSAtom,
            val: JSValue,
            getter: JSValue,
            setter: JSValue,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub has_property: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            obj: JSValue,
            atom: JSAtom,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_property: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            obj: JSValue,
            atom: JSAtom,
            receiver: JSValue,
        ) -> JSValue,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            obj: JSValue,
            atom: JSAtom,
            value: JSValue,
            receiver: JSValue,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
pub type JSClassFinalizer =
    ::std::option::Option<unsafe extern ""C"" fn(rt: *mut JSRuntime, val: JSValue)>;
pub type JSClassGCMark = ::std::option::Option<
    unsafe extern ""C"" fn(rt: *mut JSRuntime, val: JSValue, mark_func: JS_MarkFunc),
>;
pub type JSClassCall = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        func_obj: JSValue,
        this_val: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
        flags: ::std::os::raw::c_int,
    ) -> JSValue,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClassDef {
    pub class_name: *const ::std::os::raw::c_char,
    pub finalizer: JSClassFinalizer,
    pub gc_mark: JSClassGCMark,
    pub call: JSClassCall,
    pub exotic: *mut JSClassExoticMethods,
}
extern ""C"" {
    pub fn JS_NewClassID(pclass_id: *mut JSClassID) -> JSClassID;
}
extern ""C"" {
    pub fn JS_NewClass(
        rt: *mut JSRuntime,
        class_id: JSClassID,
        class_def: *const JSClassDef,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsRegisteredClass(rt: *mut JSRuntime, class_id: JSClassID) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_NewBigInt64(ctx: *mut JSContext, v: i64) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewBigUint64(ctx: *mut JSContext, v: u64) -> JSValue;
}
extern ""C"" {
    pub fn JS_Throw(ctx: *mut JSContext, obj: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_GetException(ctx: *mut JSContext) -> JSValue;
}
extern ""C"" {
    pub fn JS_IsError(ctx: *mut JSContext, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ResetUncatchableError(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn JS_NewError(ctx: *mut JSContext) -> JSValue;
}
extern ""C"" {
    pub fn JS_ThrowSyntaxError(
        ctx: *mut JSContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_ThrowTypeError(
        ctx: *mut JSContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_ThrowReferenceError(
        ctx: *mut JSContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_ThrowRangeError(
        ctx: *mut JSContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_ThrowInternalError(
        ctx: *mut JSContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_ThrowOutOfMemory(ctx: *mut JSContext) -> JSValue;
}
extern ""C"" {
    pub fn JS_ToBool(ctx: *mut JSContext, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ToInt32(ctx: *mut JSContext, pres: *mut i32, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ToInt64(ctx: *mut JSContext, pres: *mut i64, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ToIndex(ctx: *mut JSContext, plen: *mut u64, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ToFloat64(ctx: *mut JSContext, pres: *mut f64, val: JSValue)
        -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ToBigInt64(
        ctx: *mut JSContext,
        pres: *mut i64,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ToInt64Ext(
        ctx: *mut JSContext,
        pres: *mut i64,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_NewStringLen(
        ctx: *mut JSContext,
        str1: *const ::std::os::raw::c_char,
        len1: usize,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewString(ctx: *mut JSContext, str_: *const ::std::os::raw::c_char) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewAtomString(ctx: *mut JSContext, str_: *const ::std::os::raw::c_char) -> JSValue;
}
extern ""C"" {
    pub fn JS_ToString(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_ToPropertyKey(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_ToCStringLen2(
        ctx: *mut JSContext,
        plen: *mut usize,
        val1: JSValue,
        cesu8: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern ""C"" {
    pub fn JS_FreeCString(ctx: *mut JSContext, ptr: *const ::std::os::raw::c_char);
}
extern ""C"" {
    pub fn JS_NewObjectProtoClass(
        ctx: *mut JSContext,
        proto: JSValue,
        class_id: JSClassID,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewObjectClass(ctx: *mut JSContext, class_id: ::std::os::raw::c_int) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewObjectProto(ctx: *mut JSContext, proto: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewObject(ctx: *mut JSContext) -> JSValue;
}
extern ""C"" {
    pub fn JS_IsFunction(ctx: *mut JSContext, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsConstructor(ctx: *mut JSContext, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetConstructorBit(
        ctx: *mut JSContext,
        func_obj: JSValue,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_NewArray(ctx: *mut JSContext) -> JSValue;
}
extern ""C"" {
    pub fn JS_IsArray(ctx: *mut JSContext, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsArrayBuffer(ctx: *mut JSContext, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_GetPropertyInternal(
        ctx: *mut JSContext,
        obj: JSValue,
        prop: JSAtom,
        receiver: JSValue,
        throw_ref_error: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_GetPropertyStr(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: *const ::std::os::raw::c_char,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_GetPropertyUint32(ctx: *mut JSContext, this_obj: JSValue, idx: u32) -> JSValue;
}
extern ""C"" {
    pub fn JS_SetPropertyInternal(
        ctx: *mut JSContext,
        obj: JSValue,
        prop: JSAtom,
        val: JSValue,
        this_obj: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetPropertyUint32(
        ctx: *mut JSContext,
        this_obj: JSValue,
        idx: u32,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetPropertyInt64(
        ctx: *mut JSContext,
        this_obj: JSValue,
        idx: i64,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetPropertyStr(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: *const ::std::os::raw::c_char,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_HasProperty(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsExtensible(ctx: *mut JSContext, obj: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_PreventExtensions(ctx: *mut JSContext, obj: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_DeleteProperty(
        ctx: *mut JSContext,
        obj: JSValue,
        prop: JSAtom,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetPrototype(
        ctx: *mut JSContext,
        obj: JSValue,
        proto_val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_GetPrototype(ctx: *mut JSContext, val: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_GetOwnPropertyNames(
        ctx: *mut JSContext,
        ptab: *mut *mut JSPropertyEnum,
        plen: *mut u32,
        obj: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_GetOwnProperty(
        ctx: *mut JSContext,
        desc: *mut JSPropertyDescriptor,
        obj: JSValue,
        prop: JSAtom,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_Call(
        ctx: *mut JSContext,
        func_obj: JSValue,
        this_obj: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_Invoke(
        ctx: *mut JSContext,
        this_val: JSValue,
        atom: JSAtom,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_CallConstructor(
        ctx: *mut JSContext,
        func_obj: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_CallConstructor2(
        ctx: *mut JSContext,
        func_obj: JSValue,
        new_target: JSValue,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_DetectModule(
        input: *const ::std::os::raw::c_char,
        input_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_Eval(
        ctx: *mut JSContext,
        input: *const ::std::os::raw::c_char,
        input_len: usize,
        filename: *const ::std::os::raw::c_char,
        eval_flags: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_EvalThis(
        ctx: *mut JSContext,
        this_obj: JSValue,
        input: *const ::std::os::raw::c_char,
        input_len: usize,
        filename: *const ::std::os::raw::c_char,
        eval_flags: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_GetGlobalObject(ctx: *mut JSContext) -> JSValue;
}
extern ""C"" {
    pub fn JS_IsInstanceOf(
        ctx: *mut JSContext,
        val: JSValue,
        obj: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_DefineProperty(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        val: JSValue,
        getter: JSValue,
        setter: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_DefinePropertyValue(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        val: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_DefinePropertyValueUint32(
        ctx: *mut JSContext,
        this_obj: JSValue,
        idx: u32,
        val: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_DefinePropertyValueStr(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: *const ::std::os::raw::c_char,
        val: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_DefinePropertyGetSet(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        getter: JSValue,
        setter: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetOpaque(obj: JSValue, opaque: *mut ::std::os::raw::c_void);
}
extern ""C"" {
    pub fn JS_GetOpaque(obj: JSValue, class_id: JSClassID) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn JS_GetOpaque2(
        ctx: *mut JSContext,
        obj: JSValue,
        class_id: JSClassID,
    ) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn JS_ParseJSON(
        ctx: *mut JSContext,
        buf: *const ::std::os::raw::c_char,
        buf_len: usize,
        filename: *const ::std::os::raw::c_char,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_ParseJSON2(
        ctx: *mut JSContext,
        buf: *const ::std::os::raw::c_char,
        buf_len: usize,
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_JSONStringify(
        ctx: *mut JSContext,
        obj: JSValue,
        replacer: JSValue,
        space0: JSValue,
    ) -> JSValue;
}
pub type JSFreeArrayBufferDataFunc = ::std::option::Option<
    unsafe extern ""C"" fn(
        rt: *mut JSRuntime,
        opaque: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
    ),
>;
extern ""C"" {
    pub fn JS_NewArrayBuffer(
        ctx: *mut JSContext,
        buf: *mut u8,
        len: usize,
        free_func: JSFreeArrayBufferDataFunc,
        opaque: *mut ::std::os::raw::c_void,
        is_shared: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewArrayBufferCopy(ctx: *mut JSContext, buf: *const u8, len: usize) -> JSValue;
}
extern ""C"" {
    pub fn JS_DetachArrayBuffer(ctx: *mut JSContext, obj: JSValue);
}
extern ""C"" {
    pub fn JS_GetArrayBuffer(ctx: *mut JSContext, psize: *mut usize, obj: JSValue) -> *mut u8;
}
extern ""C"" {
    pub fn JS_GetTypedArrayBuffer(
        ctx: *mut JSContext,
        obj: JSValue,
        pbyte_offset: *mut usize,
        pbyte_length: *mut usize,
        pbytes_per_element: *mut usize,
    ) -> JSValue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSSharedArrayBufferFunctions {
    pub sab_alloc: ::std::option::Option<
        unsafe extern ""C"" fn(
            opaque: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub sab_free: ::std::option::Option<
        unsafe extern ""C"" fn(opaque: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void),
    >,
    pub sab_dup: ::std::option::Option<
        unsafe extern ""C"" fn(opaque: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void),
    >,
    pub sab_opaque: *mut ::std::os::raw::c_void,
}
extern ""C"" {
    pub fn JS_SetSharedArrayBufferFunctions(
        rt: *mut JSRuntime,
        sf: *const JSSharedArrayBufferFunctions,
    );
}
pub const JSPromiseStateEnum_JS_PROMISE_PENDING: JSPromiseStateEnum = 0;
pub const JSPromiseStateEnum_JS_PROMISE_FULFILLED: JSPromiseStateEnum = 1;
pub const JSPromiseStateEnum_JS_PROMISE_REJECTED: JSPromiseStateEnum = 2;
pub type JSPromiseStateEnum = ::std::os::raw::c_uint;
extern ""C"" {
    pub fn JS_NewPromiseCapability(ctx: *mut JSContext, resolving_funcs: *mut JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_PromiseState(ctx: *mut JSContext, promise: JSValue) -> JSPromiseStateEnum;
}
extern ""C"" {
    pub fn JS_PromiseResult(ctx: *mut JSContext, promise: JSValue) -> JSValue;
}
pub type JSHostPromiseRejectionTracker = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        promise: JSValue,
        reason: JSValue,
        is_handled: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
    ),
>;
extern ""C"" {
    pub fn JS_SetHostPromiseRejectionTracker(
        rt: *mut JSRuntime,
        cb: JSHostPromiseRejectionTracker,
        opaque: *mut ::std::os::raw::c_void,
    );
}
pub type JSInterruptHandler = ::std::option::Option<
    unsafe extern ""C"" fn(
        rt: *mut JSRuntime,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern ""C"" {
    pub fn JS_SetInterruptHandler(
        rt: *mut JSRuntime,
        cb: JSInterruptHandler,
        opaque: *mut ::std::os::raw::c_void,
    );
}
extern ""C"" {
    pub fn JS_SetCanBlock(rt: *mut JSRuntime, can_block: ::std::os::raw::c_int);
}
extern ""C"" {
    pub fn JS_SetIsHTMLDDA(ctx: *mut JSContext, obj: JSValue);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSModuleDef {
    _unused: [u8; 0],
}
pub type JSModuleNormalizeFunc = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        module_base_name: *const ::std::os::raw::c_char,
        module_name: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
pub type JSModuleLoaderFunc = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        module_name: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut JSModuleDef,
>;
extern ""C"" {
    pub fn JS_SetModuleLoaderFunc(
        rt: *mut JSRuntime,
        module_normalize: JSModuleNormalizeFunc,
        module_loader: JSModuleLoaderFunc,
        opaque: *mut ::std::os::raw::c_void,
    );
}
extern ""C"" {
    pub fn JS_GetImportMeta(ctx: *mut JSContext, m: *mut JSModuleDef) -> JSValue;
}
extern ""C"" {
    pub fn JS_GetModuleName(ctx: *mut JSContext, m: *mut JSModuleDef) -> JSAtom;
}
extern ""C"" {
    pub fn JS_GetModuleNamespace(ctx: *mut JSContext, m: *mut JSModuleDef) -> JSValue;
}
pub type JSJobFunc = ::std::option::Option<
    unsafe extern ""C"" fn(
        ctx: *mut JSContext,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue,
>;
extern ""C"" {
    pub fn JS_EnqueueJob(
        ctx: *mut JSContext,
        job_func: JSJobFunc,
        argc: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsJobPending(rt: *mut JSRuntime) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_ExecutePendingJob(
        rt: *mut JSRuntime,
        pctx: *mut *mut JSContext,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_WriteObject(
        ctx: *mut JSContext,
        psize: *mut usize,
        obj: JSValue,
        flags: ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern ""C"" {
    pub fn JS_WriteObject2(
        ctx: *mut JSContext,
        psize: *mut usize,
        obj: JSValue,
        flags: ::std::os::raw::c_int,
        psab_tab: *mut *mut *mut u8,
        psab_tab_len: *mut usize,
    ) -> *mut u8;
}
extern ""C"" {
    pub fn JS_ReadObject(
        ctx: *mut JSContext,
        buf: *const u8,
        buf_len: usize,
        flags: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_EvalFunction(ctx: *mut JSContext, fun_obj: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_ResolveModule(ctx: *mut JSContext, obj: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_GetScriptOrModuleName(
        ctx: *mut JSContext,
        n_stack_levels: ::std::os::raw::c_int,
    ) -> JSAtom;
}
extern ""C"" {
    pub fn JS_LoadModule(
        ctx: *mut JSContext,
        basename: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> JSValue;
}
pub const JSCFunctionEnum_JS_CFUNC_generic: JSCFunctionEnum = 0;
pub const JSCFunctionEnum_JS_CFUNC_generic_magic: JSCFunctionEnum = 1;
pub const JSCFunctionEnum_JS_CFUNC_constructor: JSCFunctionEnum = 2;
pub const JSCFunctionEnum_JS_CFUNC_constructor_magic: JSCFunctionEnum = 3;
pub const JSCFunctionEnum_JS_CFUNC_constructor_or_func: JSCFunctionEnum = 4;
pub const JSCFunctionEnum_JS_CFUNC_constructor_or_func_magic: JSCFunctionEnum = 5;
pub const JSCFunctionEnum_JS_CFUNC_f_f: JSCFunctionEnum = 6;
pub const JSCFunctionEnum_JS_CFUNC_f_f_f: JSCFunctionEnum = 7;
pub const JSCFunctionEnum_JS_CFUNC_getter: JSCFunctionEnum = 8;
pub const JSCFunctionEnum_JS_CFUNC_setter: JSCFunctionEnum = 9;
pub const JSCFunctionEnum_JS_CFUNC_getter_magic: JSCFunctionEnum = 10;
pub const JSCFunctionEnum_JS_CFUNC_setter_magic: JSCFunctionEnum = 11;
pub const JSCFunctionEnum_JS_CFUNC_iterator_next: JSCFunctionEnum = 12;
pub type JSCFunctionEnum = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union JSCFunctionType {
    pub generic: JSCFunction,
    pub generic_magic: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            argc: ::std::os::raw::c_int,
            argv: *mut JSValue,
            magic: ::std::os::raw::c_int,
        ) -> JSValue,
    >,
    pub constructor: JSCFunction,
    pub constructor_magic: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            new_target: JSValue,
            argc: ::std::os::raw::c_int,
            argv: *mut JSValue,
            magic: ::std::os::raw::c_int,
        ) -> JSValue,
    >,
    pub constructor_or_func: JSCFunction,
    pub f_f: ::std::option::Option<unsafe extern ""C"" fn(arg1: f64) -> f64>,
    pub f_f_f: ::std::option::Option<unsafe extern ""C"" fn(arg1: f64, arg2: f64) -> f64>,
    pub getter: ::std::option::Option<
        unsafe extern ""C"" fn(ctx: *mut JSContext, this_val: JSValue) -> JSValue,
    >,
    pub setter: ::std::option::Option<
        unsafe extern ""C"" fn(ctx: *mut JSContext, this_val: JSValue, val: JSValue) -> JSValue,
    >,
    pub getter_magic: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            magic: ::std::os::raw::c_int,
        ) -> JSValue,
    >,
    pub setter_magic: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            val: JSValue,
            magic: ::std::os::raw::c_int,
        ) -> JSValue,
    >,
    pub iterator_next: ::std::option::Option<
        unsafe extern ""C"" fn(
            ctx: *mut JSContext,
            this_val: JSValue,
            argc: ::std::os::raw::c_int,
            argv: *mut JSValue,
            pdone: *mut ::std::os::raw::c_int,
            magic: ::std::os::raw::c_int,
        ) -> JSValue,
    >,
}
extern ""C"" {
    pub fn JS_NewCFunction2(
        ctx: *mut JSContext,
        func: JSCFunction,
        name: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        cproto: JSCFunctionEnum,
        magic: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewCFunctionData(
        ctx: *mut JSContext,
        func: JSCFunctionData,
        length: ::std::os::raw::c_int,
        magic: ::std::os::raw::c_int,
        data_len: ::std::os::raw::c_int,
        data: *mut JSValue,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_SetConstructor(ctx: *mut JSContext, func_obj: JSValue, proto: JSValue);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JSCFunctionListEntry {
    pub name: *const ::std::os::raw::c_char,
    pub prop_flags: u8,
    pub def_type: u8,
    pub magic: i16,
    pub u: JSCFunctionListEntry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JSCFunctionListEntry__bindgen_ty_1 {
    pub func: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1,
    pub getset: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2,
    pub alias: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3,
    pub prop_list: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4,
    pub str_: *const ::std::os::raw::c_char,
    pub i32_: i32,
    pub i64_: i64,
    pub f64_: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1 {
    pub length: u8,
    pub cproto: u8,
    pub cfunc: JSCFunctionType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2 {
    pub get: JSCFunctionType,
    pub set: JSCFunctionType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_3 {
    pub name: *const ::std::os::raw::c_char,
    pub base: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_4 {
    pub tab: *const JSCFunctionListEntry,
    pub len: ::std::os::raw::c_int,
}
extern ""C"" {
    pub fn JS_SetPropertyFunctionList(
        ctx: *mut JSContext,
        obj: JSValue,
        tab: *const JSCFunctionListEntry,
        len: ::std::os::raw::c_int,
    );
}
pub type JSModuleInitFunc = ::std::option::Option<
    unsafe extern ""C"" fn(ctx: *mut JSContext, m: *mut JSModuleDef) -> ::std::os::raw::c_int,
>;
extern ""C"" {
    pub fn JS_NewCModule(
        ctx: *mut JSContext,
        name_str: *const ::std::os::raw::c_char,
        func: JSModuleInitFunc,
    ) -> *mut JSModuleDef;
}
extern ""C"" {
    pub fn JS_AddModuleExport(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        name_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_AddModuleExportList(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        tab: *const JSCFunctionListEntry,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetModuleExport(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        export_name: *const ::std::os::raw::c_char,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetModuleExportList(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
        tab: *const JSCFunctionListEntry,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn js_init_module_std(
        ctx: *mut JSContext,
        module_name: *const ::std::os::raw::c_char,
    ) -> *mut JSModuleDef;
}
extern ""C"" {
    pub fn js_init_module_os(
        ctx: *mut JSContext,
        module_name: *const ::std::os::raw::c_char,
    ) -> *mut JSModuleDef;
}
extern ""C"" {
    pub fn js_std_add_console(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn js_std_loop(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn js_std_init_handlers(rt: *mut JSRuntime);
}
extern ""C"" {
    pub fn js_std_free_handlers(rt: *mut JSRuntime);
}
extern ""C"" {
    pub fn js_std_dump_error(ctx: *mut JSContext);
}
extern ""C"" {
    pub fn js_load_file(
        ctx: *mut JSContext,
        pbuf_len: *mut usize,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut u8;
}
extern ""C"" {
    pub fn js_module_set_import_meta(
        ctx: *mut JSContext,
        func_val: JSValue,
        use_realpath: ::std::os::raw::c_int,
        is_main: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn js_module_loader(
        ctx: *mut JSContext,
        module_name: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut JSModuleDef;
}
extern ""C"" {
    pub fn js_std_eval_binary(
        ctx: *mut JSContext,
        buf: *const u8,
        buf_len: usize,
        flags: ::std::os::raw::c_int,
    );
}
extern ""C"" {
    pub fn js_std_promise_rejection_tracker(
        ctx: *mut JSContext,
        promise: JSValue,
        reason: JSValue,
        is_handled: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
    );
}
extern ""C"" {
    pub fn JS_ValueGetTag_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_FreeValue_real(ctx: *mut JSContext, v: JSValue);
}
extern ""C"" {
    pub fn JS_FreeValueRT_real(rt: *mut JSRuntime, v: JSValue);
}
extern ""C"" {
    pub fn JS_DupValue_real(ctx: *mut JSContext, v: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_DupValueRT_real(rt: *mut JSRuntime, v: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewFloat64_real(ctx: *mut JSContext, d: f64) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewInt32_real(ctx: *mut JSContext, val: i32) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewInt64_real(ctx: *mut JSContext, val: i64) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewBool_real(ctx: *mut JSContext, val: ::std::os::raw::c_int) -> JSValue;
}
extern ""C"" {
    pub fn JS_VALUE_IS_NAN_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_VALUE_GET_FLOAT64_real(v: JSValue) -> f64;
}
extern ""C"" {
    pub fn JS_VALUE_GET_NORM_TAG_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_VALUE_GET_PTR_real(v: JSValue) -> *mut ::std::os::raw::c_void;
}
extern ""C"" {
    pub fn JS_IsNumber_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsBigInt_real(ctx: *mut JSContext, v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsBigFloat_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsBigDecimal_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsBool_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsNull_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsUndefined_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsException_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsUninitialized_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsString_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsSymbol_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsObject_real(v: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_IsPromise(ctx: *mut JSContext, val: JSValue) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_GetPromiseResult_real(ctx: *mut JSContext, this_val: JSValue) -> JSValue;
}
extern ""C"" {
    pub fn JS_ToUint32_real(
        ctx: *mut JSContext,
        pres: *mut u32,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_SetProperty_real(
        ctx: *mut JSContext,
        this_obj: JSValue,
        prop: JSAtom,
        val: JSValue,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn JS_NewCFunction_real(
        ctx: *mut JSContext,
        func: JSCFunction,
        name: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn JS_NewCFunctionMagic_real(
        ctx: *mut JSContext,
        func: JSCFunctionMagic,
        name: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        cproto: JSCFunctionEnum,
        magic: ::std::os::raw::c_int,
    ) -> JSValue;
}
extern ""C"" {
    pub fn js_eval_buf(
        ctx: *mut JSContext,
        buf: *const ::std::os::raw::c_void,
        buf_len: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        eval_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern ""C"" {
    pub fn js_undefined() -> JSValue;
}
extern ""C"" {
    pub fn js_exception() -> JSValue;
}
extern ""C"" {
    pub fn js_null() -> JSValue;
}
"
test/assert/test-assert.js,"// Flags: --expose-internals
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

const common = require('../common');
const assert = require('assert');
const { inspect } = require('util');
const vm = require('vm');
const { internalBinding } = require('internal/test/binding');
const a = assert;

// Disable colored output to prevent color codes from breaking assertion
// message comparisons. This should only be an issue when process.stdout
// is a TTY.
if (process.stdout.isTTY)
  process.env.NODE_DISABLE_COLORS = '1';

const strictEqualMessageStart = 'Expected values to be strictly equal:\n';
const start = 'Expected values to be strictly deep-equal:';
const actExp = '+ actual - expected';

assert.ok(a.AssertionError.prototype instanceof Error,
          'a.AssertionError instanceof Error');

assert.throws(() => a(false), a.AssertionError, 'ok(false)');
assert.throws(() => a.ok(false), a.AssertionError, 'ok(false)');

// Throw message if the message is instanceof Error.
{
  let threw = false;
  try {
    assert.ok(false, new Error('ok(false)'));
  } catch (e) {
    threw = true;
    assert.ok(e instanceof Error);
  }
  assert.ok(threw, 'Error: ok(false)');
}


a(true);
a('test', 'ok(\'test\')');
a.ok(true);
a.ok('test');

assert.throws(() => a.equal(true, false),
              a.AssertionError, 'equal(true, false)');

a.equal(null, null);
a.equal(undefined, undefined);
a.equal(null, undefined);
a.equal(true, true);
a.equal(2, '2');
a.notEqual(true, false);

assert.throws(() => a.notEqual(true, true),
              a.AssertionError, 'notEqual(true, true)');

assert.throws(() => a.strictEqual(2, '2'),
              a.AssertionError, 'strictEqual(2, \'2\')');

/* eslint-disable no-restricted-syntax */
assert.throws(() => a.strictEqual(null, undefined),
              a.AssertionError, 'strictEqual(null, undefined)');

assert.throws(
  () => a.notStrictEqual(2, 2),
  {
    message: 'Expected ""actual"" to be strictly unequal to: 2',
    name: 'AssertionError'
  }
);

assert.throws(
  () => a.notStrictEqual('a '.repeat(30), 'a '.repeat(30)),
  {
    message: 'Expected ""actual"" to be strictly unequal to:\n\n' +
             `'${'a '.repeat(30)}'`,
    name: 'AssertionError'
  }
);

assert.throws(
  () => a.notEqual(1, 1),
  {
    message: '1 != 1',
    operator: '!='
  }
);

a.notStrictEqual(2, '2');

// Testing the throwing.
function thrower(errorConstructor) {
  throw new errorConstructor({});
}

// The basic calls work.
assert.throws(() => thrower(a.AssertionError), a.AssertionError, 'message');
assert.throws(() => thrower(a.AssertionError), a.AssertionError);
assert.throws(() => thrower(a.AssertionError));

// If not passing an error, catch all.
assert.throws(() => thrower(TypeError));

// When passing a type, only catch errors of the appropriate type.
assert.throws(
  () => a.throws(() => thrower(TypeError), a.AssertionError),
  {
    generatedMessage: true,
    actual: new TypeError({}),
    expected: a.AssertionError,
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    operator: 'throws',
    message: 'The error is expected to be an instance of ""AssertionError"". ' +
             'Received ""TypeError""\n\nError message:\n\n[object Object]'
  }
);

// doesNotThrow should pass through all errors.
{
  let threw = false;
  try {
    a.doesNotThrow(() => thrower(TypeError), a.AssertionError);
  } catch (e) {
    threw = true;
    assert.ok(e instanceof TypeError);
  }
  assert(threw, 'a.doesNotThrow with an explicit error is eating extra errors');
}

// Key difference is that throwing our correct error makes an assertion error.
{
  let threw = false;
  try {
    a.doesNotThrow(() => thrower(TypeError), TypeError);
  } catch (e) {
    threw = true;
    assert.ok(e instanceof a.AssertionError);
    assert.ok(!e.stack.includes('at Function.doesNotThrow'));
  }
  assert.ok(threw, 'a.doesNotThrow is not catching type matching errors');
}

assert.throws(
  () => a.doesNotThrow(() => thrower(Error), 'user message'),
  {
    name: 'AssertionError',
    code: 'ERR_ASSERTION',
    operator: 'doesNotThrow',
    message: 'Got unwanted exception: user message\n' +
             'Actual message: ""[object Object]""'
  }
);

assert.throws(
  () => a.doesNotThrow(() => thrower(Error)),
  {
    code: 'ERR_ASSERTION',
    message: 'Got unwanted exception.\nActual message: ""[object Object]""'
  }
);

assert.throws(
  () => a.doesNotThrow(() => thrower(Error), /\[[a-z]{6}\s[A-z]{6}\]/g, 'user message'),
  {
    name: 'AssertionError',
    code: 'ERR_ASSERTION',
    operator: 'doesNotThrow',
    message: 'Got unwanted exception: user message\n' +
             'Actual message: ""[object Object]""'
  }
);

// Make sure that validating using constructor really works.
{
  let threw = false;
  try {
    assert.throws(
      () => {
        throw ({}); // eslint-disable-line no-throw-literal
      },
      Array
    );
  } catch {
    threw = true;
  }
  assert.ok(threw, 'wrong constructor validation');
}

// Use a RegExp to validate the error message.
{
  a.throws(() => thrower(TypeError), /\[object Object\]/);

  const symbol = Symbol('foo');
  a.throws(() => {
    throw symbol;
  }, /foo/);

  a.throws(() => {
    a.throws(() => {
      throw symbol;
    }, /abc/);
  }, {
    message: 'The input did not match the regular expression /abc/. ' +
             ""Input:\n\n'Symbol(foo)'\n"",
    code: 'ERR_ASSERTION',
    operator: 'throws',
    actual: symbol,
    expected: /abc/
  });
}

// Use a fn to validate the error object.
a.throws(() => thrower(TypeError), (err) => {
  if ((err instanceof TypeError) && /\[object Object\]/.test(err)) {
    return true;
  }
});

// https://github.com/nodejs/node/issues/3188
{
  let actual;
  assert.throws(
    () => {
      const ES6Error = class extends Error {};
      const AnotherErrorType = class extends Error {};

      assert.throws(() => {
        actual = new AnotherErrorType('foo');
        throw actual;
      }, ES6Error);
    },
    (err) => {
      assert.strictEqual(
        err.message,
        'The error is expected to be an instance of ""ES6Error"". ' +
          'Received ""AnotherErrorType""\n\nError message:\n\nfoo'
      );
      assert.strictEqual(err.actual, actual);
      return true;
    }
  );
}

// Check messages from assert.throws().
{
  const noop = () => {};
  assert.throws(
    () => { a.throws((noop)); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception.',
      operator: 'throws',
      actual: undefined,
      expected: undefined
    });

  assert.throws(
    () => { a.throws(noop, TypeError); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception (TypeError).',
      actual: undefined,
      expected: TypeError
    });

  assert.throws(
    () => { a.throws(noop, 'fhqwhgads'); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception: fhqwhgads',
      actual: undefined,
      expected: undefined
    });

  assert.throws(
    () => { a.throws(noop, TypeError, 'fhqwhgads'); },
    {
      code: 'ERR_ASSERTION',
      message: 'Missing expected exception (TypeError): fhqwhgads',
      actual: undefined,
      expected: TypeError
    });

  let threw = false;
  try {
    a.throws(noop);
  } catch (e) {
    threw = true;
    assert.ok(e instanceof a.AssertionError);
    assert.ok(!e.stack.includes('at Function.throws'));
  }
  assert.ok(threw);
}

const circular = { y: 1 };
circular.x = circular;

function testAssertionMessage(actual, expected, msg) {
  assert.throws(
    () => assert.strictEqual(actual, ''),
    {
      generatedMessage: true,
      message: msg || strictEqualMessageStart +
               `+ actual - expected\n\n+ ${expected}\n- ''`
    }
  );
}

function testShortAssertionMessage(actual, expected) {
  testAssertionMessage(actual, expected, strictEqualMessageStart +
                                         `\n${inspect(actual)} !== ''\n`);
}

testShortAssertionMessage(null, 'null');
testShortAssertionMessage(true, 'true');
testShortAssertionMessage(false, 'false');
testShortAssertionMessage(100, '100');
testShortAssertionMessage(NaN, 'NaN');
testShortAssertionMessage(Infinity, 'Infinity');
testShortAssertionMessage('a', '""a""');
testShortAssertionMessage('foo', '\'foo\'');
testShortAssertionMessage(0, '0');
testShortAssertionMessage(Symbol(), 'Symbol()');
testShortAssertionMessage(undefined, 'undefined');
testShortAssertionMessage(-Infinity, '-Infinity');
testAssertionMessage([], '[]');
testAssertionMessage(/a/, '/a/');
testAssertionMessage(/abc/gim, '/abc/gim');
testAssertionMessage({}, '{}');
testAssertionMessage([1, 2, 3], '[\n+   1,\n+   2,\n+   3\n+ ]');
testAssertionMessage(function f() {}, '[Function: f]');
testAssertionMessage(function() {}, '[Function (anonymous)]');
testAssertionMessage(circular,
                     '<ref *1> {\n+   x: [Circular *1],\n+   y: 1\n+ }');
testAssertionMessage({ a: undefined, b: null },
                     '{\n+   a: undefined,\n+   b: null\n+ }');
testAssertionMessage({ a: NaN, b: Infinity, c: -Infinity },
                     '{\n+   a: NaN,\n+   b: Infinity,\n+   c: -Infinity\n+ }');

// https://github.com/nodejs/node-v0.x-archive/issues/5292
assert.throws(
  () => assert.strictEqual(1, 2),
  {
    message: `${strictEqualMessageStart}\n1 !== 2\n`,
    generatedMessage: true
  }
);

assert.throws(
  () => assert.strictEqual(1, 2, 'oh no'),
  {
    message: 'oh no',
    generatedMessage: false
  }
);

{
  let threw = false;
  const rangeError = new RangeError('my range');

  // Verify custom errors.
  try {
    assert.strictEqual(1, 2, rangeError);
  } catch (e) {
    assert.strictEqual(e, rangeError);
    threw = true;
    assert.ok(e instanceof RangeError, 'Incorrect error type thrown');
  }
  assert.ok(threw);
  threw = false;

  // Verify AssertionError is the result from doesNotThrow with custom Error.
  try {
    a.doesNotThrow(() => {
      throw new TypeError('wrong type');
    }, TypeError, rangeError);
  } catch (e) {
    threw = true;
    assert.ok(e.message.includes(rangeError.message));
    assert.ok(e instanceof assert.AssertionError);
    assert.ok(!e.stack.includes('doesNotThrow'), e);
  }
  assert.ok(threw);
}

{
  // Verify that throws() and doesNotThrow() throw on non-functions.
  const testBlockTypeError = (method, fn) => {
    assert.throws(
      () => method(fn),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""fn"" argument must be of type function.' +
                 common.invalidArgTypeHelper(fn)
      }
    );
  };

  testBlockTypeError(assert.throws, 'string');
  testBlockTypeError(assert.doesNotThrow, 'string');
  testBlockTypeError(assert.throws, 1);
  testBlockTypeError(assert.doesNotThrow, 1);
  testBlockTypeError(assert.throws, true);
  testBlockTypeError(assert.doesNotThrow, true);
  testBlockTypeError(assert.throws, false);
  testBlockTypeError(assert.doesNotThrow, false);
  testBlockTypeError(assert.throws, []);
  testBlockTypeError(assert.doesNotThrow, []);
  testBlockTypeError(assert.throws, {});
  testBlockTypeError(assert.doesNotThrow, {});
  testBlockTypeError(assert.throws, /foo/);
  testBlockTypeError(assert.doesNotThrow, /foo/);
  testBlockTypeError(assert.throws, null);
  testBlockTypeError(assert.doesNotThrow, null);
  testBlockTypeError(assert.throws, undefined);
  testBlockTypeError(assert.doesNotThrow, undefined);
}

// https://github.com/nodejs/node/issues/3275
// eslint-disable-next-line no-throw-literal
assert.throws(() => { throw 'error'; }, (err) => err === 'error');
assert.throws(() => { throw new Error(); }, (err) => err instanceof Error);

// Long values should be truncated for display.
assert.throws(() => {
  assert.strictEqual('A'.repeat(1000), '');
}, (err) => {
  assert.strictEqual(err.code, 'ERR_ASSERTION');
  assert.strictEqual(err.message,
                     `${strictEqualMessageStart}+ actual - expected\n\n` +
                     `+ '${'A'.repeat(1000)}'\n- ''`);
  assert.strictEqual(err.actual.length, 1000);
  assert.ok(inspect(err).includes(`actual: '${'A'.repeat(488)}...'`));
  return true;
});

// Output that extends beyond 10 lines should also be truncated for display.
{
  const multilineString = 'fhqwhgads\n'.repeat(15);
  assert.throws(() => {
    assert.strictEqual(multilineString, '');
  }, (err) => {
    assert.strictEqual(err.code, 'ERR_ASSERTION');
    assert.strictEqual(err.message.split('\n').length, 19);
    assert.strictEqual(err.actual.split('\n').length, 16);
    assert.ok(inspect(err).includes(
      ""actual: 'fhqwhgads\\n' +\n"" +
      ""    'fhqwhgads\\n' +\n"".repeat(9) +
      ""    '...'""));
    return true;
  });
}

{
  // Bad args to AssertionError constructor should throw TypeError.
  const args = [1, true, false, '', null, Infinity, Symbol('test'), undefined];
  args.forEach((input) => {
    assert.throws(
      () => new assert.AssertionError(input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""options"" argument must be of type object.' +
                 common.invalidArgTypeHelper(input)
      });
  });
}

assert.throws(
  () => assert.strictEqual(new Error('foo'), new Error('foobar')),
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: 'Expected ""actual"" to be reference-equal to ""expected"":\n' +
             '+ actual - expected\n\n' +
             '+ [Error: foo]\n- [Error: foobar]'
  }
);

a.equal(NaN, NaN);
a.throws(
  () => a.notEqual(NaN, NaN),
  a.AssertionError
);

// Test strict assert.
{
  const a = require('assert');
  const assert = require('assert').strict;
  /* eslint-disable no-restricted-properties */
  assert.throws(() => assert.equal(1, true), assert.AssertionError);
  assert.notEqual(0, false);
  assert.throws(() => assert.deepEqual(1, true), assert.AssertionError);
  assert.notDeepEqual(0, false);
  assert.equal(assert.strict, assert.strict.strict);
  assert.equal(assert.equal, assert.strictEqual);
  assert.equal(assert.deepEqual, assert.deepStrictEqual);
  assert.equal(assert.notEqual, assert.notStrictEqual);
  assert.equal(assert.notDeepEqual, assert.notDeepStrictEqual);
  assert.equal(Object.keys(assert).length, Object.keys(a).length);
  assert(7);
  assert.throws(
    () => assert(...[]),
    {
      message: 'No value argument passed to `assert.ok()`',
      name: 'AssertionError',
      generatedMessage: true
    }
  );
  assert.throws(
    () => a(),
    {
      message: 'No value argument passed to `assert.ok()`',
      name: 'AssertionError'
    }
  );

  // Test setting the limit to zero and that assert.strict works properly.
  const tmpLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  assert.throws(
    () => {
      assert.ok(
        typeof 123 === 'string'
      );
    },
    {
      code: 'ERR_ASSERTION',
      constructor: assert.AssertionError,
      message: 'The expression evaluated to a falsy value:\n\n  ' +
               ""assert.ok(\n    typeof 123 === 'string'\n  )\n""
    }
  );
  Error.stackTraceLimit = tmpLimit;

  // Test error diffs.
  let message = [
    start,
    `${actExp} ... Lines skipped`,
    '',
    '  [',
    '    [',
    '      [',
    '        1,',
    '        2,',
    '+       3',
    ""-       '3'"",
    '      ]',
    '...',
    '    4,',
    '    5',
    '  ]'].join('\n');
  assert.throws(
    () => assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]),
    { message });

  message = [
    start,
    `${actExp} ... Lines skipped`,
    '',
    '  [',
    '    1,',
    '...',
    '    1,',
    '    0,',
    '-   1,',
    '    1,',
    '...',
    '    1,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual(
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1]),
    { message });

  message = [
    start,
    `${actExp} ... Lines skipped`,
    '',
    '  [',
    '    1,',
    '...',
    '    1,',
    '    0,',
    '+   1,',
    '    1,',
    '    1,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual(
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]),
    { message });

  message = [
    start,
    actExp,
    '',
    '  [',
    '    1,',
    '+   2,',
    '-   1,',
    '    1,',
    '    1,',
    '    0,',
    '+   1,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual(
      [1, 2, 1, 1, 0, 1, 1],
      [1, 1, 1, 1, 0, 1]),
    { message });

  message = [
    start,
    actExp,
    '',
    '+ [',
    '+   1,',
    '+   2,',
    '+   1',
    '+ ]',
    '- undefined',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual([1, 2, 1], undefined),
    { message });

  message = [
    start,
    actExp,
    '',
    '  [',
    '+   1,',
    '    2,',
    '    1',
    '  ]',
  ].join('\n');
  assert.throws(
    () => assert.deepEqual([1, 2, 1], [2, 1]),
    { message });

  message = `${start}\n` +
    `${actExp} ... Lines skipped\n` +
    '\n' +
    '  [\n' +
    '+   1,\n'.repeat(25) +
    '...\n' +
    '-   2,\n'.repeat(25) +
    '...';
  assert.throws(
    () => assert.deepEqual(Array(28).fill(1), Array(28).fill(2)),
    { message });

  const obj1 = {};
  const obj2 = { loop: 'forever' };
  obj2[inspect.custom] = () => '{}';
  // No infinite loop and no custom inspect.
  assert.throws(() => assert.deepEqual(obj1, obj2), {
    message: `${start}\n` +
    `${actExp}\n` +
    '\n' +
    '+ {}\n' +
    '- {\n' +
    '-   [Symbol(nodejs.util.inspect.custom)]: [Function (anonymous)],\n' +
    ""-   loop: 'forever'\n"" +
    '- }'
  });

  // notDeepEqual tests
  assert.throws(
    () => assert.notDeepEqual([1], [1]),
    {
      message: 'Expected ""actual"" not to be strictly deep-equal to:\n\n' +
               '[\n  1\n]\n'
    }
  );

  message = 'Expected ""actual"" not to be strictly deep-equal to:' +
            `\n\n[${'\n  1,'.repeat(45)}\n...\n`;
  const data = Array(51).fill(1);
  assert.throws(
    () => assert.notDeepEqual(data, data),
    { message });
  /* eslint-enable no-restricted-properties */
}

assert.throws(
  () => assert.ok(null),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    generatedMessage: true,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert.ok(null)\n'
  }
);
assert.throws(
  () => assert(typeof 123n === 'string'),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    generatedMessage: true,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             ""assert(typeof 123n === 'string')\n""
  }
);

assert.throws(
  () => assert(false, Symbol('foo')),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    generatedMessage: false,
    message: 'Symbol(foo)'
  }
);

{
  // Test caching.
  const fs = internalBinding('fs');
  const tmp = fs.close;
  fs.close = common.mustCall(tmp, 1);
  function throwErr() {
    assert(
      (Buffer.from('test') instanceof Error)
    );
  }
  assert.throws(
    () => throwErr(),
    {
      code: 'ERR_ASSERTION',
      constructor: assert.AssertionError,
      message: 'The expression evaluated to a falsy value:\n\n  ' +
               ""assert(\n    (Buffer.from('test') instanceof Error)\n  )\n""
    }
  );
  assert.throws(
    () => throwErr(),
    {
      code: 'ERR_ASSERTION',
      constructor: assert.AssertionError,
      message: 'The expression evaluated to a falsy value:\n\n  ' +
               ""assert(\n    (Buffer.from('test') instanceof Error)\n  )\n""
    }
  );
  fs.close = tmp;
}

assert.throws(
  () => {
    a(
      (() => 'string')()
      // eslint-disable-next-line operator-linebreak
      ===
      123 instanceof
          Buffer
    );
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n' +
             '  a(\n' +
             '    (() => \'string\')()\n' +
             '    // eslint-disable-next-line operator-linebreak\n' +
             '    ===\n' +
             '    123 instanceof\n' +
             '        Buffer\n' +
             '  )\n'
  }
);

assert.throws(
  () => {
    a(
      (() => 'string')()
      // eslint-disable-next-line operator-linebreak
      ===
  123 instanceof
          Buffer
    );
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n' +
             '  a(\n' +
             '    (() => \'string\')()\n' +
             '    // eslint-disable-next-line operator-linebreak\n' +
             '    ===\n' +
             '  123 instanceof\n' +
             '        Buffer\n' +
             '  )\n'
  }
);

/* eslint-disable indent */
assert.throws(() => {
a((
  () => 'string')() ===
123 instanceof
Buffer
);
}, {
  code: 'ERR_ASSERTION',
  constructor: assert.AssertionError,
  message: 'The expression evaluated to a falsy value:\n\n' +
           '  a((\n' +
           '    () => \'string\')() ===\n' +
           '  123 instanceof\n' +
           '  Buffer\n' +
           '  )\n'
  }
);
/* eslint-enable indent */

assert.throws(
  () => {
    assert(true); assert(null, undefined);
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert(null, undefined)\n'
  }
);

assert.throws(
  () => {
    assert
     .ok(null, undefined);
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'ok(null, undefined)\n'
  }
);

assert.throws(
  // eslint-disable-next-line dot-notation, quotes
  () => assert['ok'][""apply""](null, [0]),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert[\'ok\'][""apply""](null, [0])\n'
  }
);

assert.throws(
  () => {
    const wrapper = (fn, value) => fn(value);
    wrapper(assert, false);
  },
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  fn(value)\n'
  }
);

assert.throws(
  () => assert.ok.call(null, 0),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  ' +
             'assert.ok.call(null, 0)\n',
    generatedMessage: true
  }
);

assert.throws(
  () => assert.ok.call(null, 0, 'test'),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'test',
    generatedMessage: false
  }
);

// Works in eval.
assert.throws(
  () => new Function('assert', 'assert(1 === 2);')(assert),
  {
    code: 'ERR_ASSERTION',
    constructor: assert.AssertionError,
    message: 'The expression evaluated to a falsy value:\n\n  assert(1 === 2)\n'
  }
);
assert.throws(
  () => eval('console.log(""FOO"");\nassert.ok(1 === 2);'),
  {
    code: 'ERR_ASSERTION',
    message: 'false == true'
  }
);

assert.throws(
  () => assert.throws(() => {}, 'Error message', 'message'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""error"" argument must be of type function or ' +
             'an instance of Error, RegExp, or Object. Received type string ' +
             ""('Error message')""
  }
);

[
  1,
  false,
  Symbol(),
].forEach((input) => {
  assert.throws(
    () => assert.throws(() => {}, input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""error"" argument must be of type function or ' +
               'an instance of Error, RegExp, or Object.' +
               common.invalidArgTypeHelper(input)
    }
  );
});

{

  assert.throws(() => {
    assert.ok((() => Boolean('' === false))());
  }, {
    message: 'The expression evaluated to a falsy value:\n\n' +
             ""  assert.ok((() => Boolean('\\u0001' === false))())\n""
  });

  const errFn = () => {
    const err = new TypeError('Wrong value');
    err.code = 404;
    throw err;
  };
  const errObj = {
    name: 'TypeError',
    message: 'Wrong value'
  };
  assert.throws(errFn, errObj);

  errObj.code = 404;
  assert.throws(errFn, errObj);

  // Fail in case a expected property is undefined and not existent on the
  // error.
  errObj.foo = undefined;
  assert.throws(
    () => assert.throws(errFn, errObj),
    {
      code: 'ERR_ASSERTION',
      name: 'AssertionError',
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               '    code: 404,\n' +
               '-   foo: undefined,\n' +
               ""    message: 'Wrong value',\n"" +
               ""    name: 'TypeError'\n"" +
               '  }'
    }
  );

  // Show multiple wrong properties at the same time.
  errObj.code = '404';
  assert.throws(
    () => assert.throws(errFn, errObj),
    {
      code: 'ERR_ASSERTION',
      name: 'AssertionError',
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               '+   code: 404,\n' +
               ""-   code: '404',\n"" +
               '-   foo: undefined,\n' +
               ""    message: 'Wrong value',\n"" +
               ""    name: 'TypeError'\n"" +
               '  }'
    }
  );

  assert.throws(
    () => assert.throws(() => { throw new Error(); }, { foo: 'bar' }, 'foobar'),
    {
      constructor: assert.AssertionError,
      code: 'ERR_ASSERTION',
      message: 'foobar'
    }
  );

  assert.throws(
    () => a.doesNotThrow(() => { throw new Error(); }, { foo: 'bar' }),
    {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""expected"" argument must be of type function or an ' +
               'instance of RegExp. Received an instance of Object'
    }
  );

  assert.throws(() => { throw new Error('e'); }, new Error('e'));
  assert.throws(
    () => assert.throws(() => { throw new TypeError('e'); }, new Error('e')),
    {
      name: 'AssertionError',
      code: 'ERR_ASSERTION',
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               ""    message: 'e',\n"" +
               ""+   name: 'TypeError'\n"" +
               ""-   name: 'Error'\n"" +
               '  }'
    }
  );
  assert.throws(
    () => assert.throws(() => { throw new Error('foo'); }, new Error('')),
    {
      name: 'AssertionError',
      code: 'ERR_ASSERTION',
      generatedMessage: true,
      message: `${start}\n${actExp}\n\n` +
               '  Comparison {\n' +
               ""+   message: 'foo',\n"" +
               ""-   message: '',\n"" +
               ""    name: 'Error'\n"" +
               '  }'
    }
  );

  // eslint-disable-next-line no-throw-literal
  assert.throws(() => { throw undefined; }, /undefined/);
  assert.throws(
    // eslint-disable-next-line no-throw-literal
    () => a.doesNotThrow(() => { throw undefined; }),
    {
      name: 'AssertionError',
      code: 'ERR_ASSERTION',
      message: 'Got unwanted exception.\nActual message: ""undefined""'
    }
  );
}

assert.throws(
  () => assert.throws(() => { throw new Error(); }, {}),
  {
    message: ""The argument 'error' may not be an empty object. Received {}"",
    code: 'ERR_INVALID_ARG_VALUE'
  }
);

assert.throws(
  () => a.throws(
    // eslint-disable-next-line no-throw-literal
    () => { throw 'foo'; },
    'foo'
  ),
  {
    code: 'ERR_AMBIGUOUS_ARGUMENT',
    message: 'The ""error/message"" argument is ambiguous. ' +
             'The error ""foo"" is identical to the message.'
  }
);

assert.throws(
  () => a.throws(
    () => { throw new TypeError('foo'); },
    'foo'
  ),
  {
    code: 'ERR_AMBIGUOUS_ARGUMENT',
    message: 'The ""error/message"" argument is ambiguous. ' +
             'The error message ""foo"" is identical to the message.'
  }
);
/* eslint-enable no-restricted-syntax */

// Should not throw.
// eslint-disable-next-line no-restricted-syntax, no-throw-literal
assert.throws(() => { throw null; }, 'foo');

assert.throws(
  () => assert.strictEqual([], []),
  {
    message: 'Values have same structure but are not reference-equal:\n\n[]\n'
  }
);

{
  const args = (function() { return arguments; })('a');
  assert.throws(
    () => assert.strictEqual(args, { 0: 'a' }),
    {
      message: 'Expected ""actual"" to be reference-equal to ""expected"":\n' +
               '+ actual - expected\n\n' +
               ""+ [Arguments] {\n- {\n    '0': 'a'\n  }""
    }
  );
}

assert.throws(
  () => { throw new TypeError('foobar'); },
  {
    message: /foo/,
    name: /^TypeError$/
  }
);

assert.throws(
  () => assert.throws(
    () => { throw new TypeError('foobar'); },
    {
      message: /fooa/,
      name: /^TypeError$/
    }
  ),
  {
    message: `${start}\n${actExp}\n\n` +
             '  Comparison {\n' +
             ""+   message: 'foobar',\n"" +
             '-   message: /fooa/,\n' +
             ""    name: 'TypeError'\n"" +
             '  }'
  }
);

{
  let actual = null;
  const expected = { message: 'foo' };
  assert.throws(
    () => assert.throws(
      () => { throw actual; },
      expected
    ),
    {
      operator: 'throws',
      actual,
      expected,
      generatedMessage: true,
      message: `${start}\n${actExp}\n\n` +
              '+ null\n' +
              '- {\n' +
              ""-   message: 'foo'\n"" +
              '- }'
    }
  );

  actual = 'foobar';
  const message = 'message';
  assert.throws(
    () => assert.throws(
      () => { throw actual; },
      { message: 'foobar' },
      message
    ),
    {
      actual,
      message,
      operator: 'throws',
      generatedMessage: false
    }
  );
}

// Indicate where the strings diverge.
assert.throws(
  () => assert.strictEqual('test test', 'test foobar'),
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: strictEqualMessageStart +
             '+ actual - expected\n\n' +
             ""+ 'test test'\n"" +
             ""- 'test foobar'\n"" +
             '        ^'
  }
);

// Check for reference-equal objects in `notStrictEqual()`
assert.throws(
  () => {
    const obj = {};
    assert.notStrictEqual(obj, obj);
  },
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: 'Expected ""actual"" not to be reference-equal to ""expected"": {}'
  }
);

assert.throws(
  () => {
    const obj = { a: true };
    assert.notStrictEqual(obj, obj);
  },
  {
    code: 'ERR_ASSERTION',
    name: 'AssertionError',
    message: 'Expected ""actual"" not to be reference-equal to ""expected"":\n\n' +
             '{\n  a: true\n}\n'
  }
);

{
  let threw = false;
  try {
    // eslint-disable-next-line no-restricted-syntax
    assert.deepStrictEqual(Array(100).fill(1), 'foobar');
  } catch (err) {
    threw = true;
    assert.match(inspect(err), /actual: \[Array],\n {2}expected: 'foobar',/);
  }
  assert(threw);
}

assert.throws(
  () => a.equal(1),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.deepEqual(/a/),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notEqual(null),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notDeepEqual('test'),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.strictEqual({}),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.deepStrictEqual(Symbol()),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notStrictEqual(5n), // eslint-disable-line no-restricted-syntax
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.notDeepStrictEqual(undefined),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.strictEqual(),
  { code: 'ERR_MISSING_ARGS' }
);

assert.throws(
  () => a.deepStrictEqual(),
  { code: 'ERR_MISSING_ARGS' }
);

// Verify that `stackStartFunction` works as alternative to `stackStartFn`.
{
  (function hidden() {
    const err = new assert.AssertionError({
      actual: 'foo',
      operator: 'strictEqual',
      stackStartFunction: hidden
    });
    const err2 = new assert.AssertionError({
      actual: 'foo',
      operator: 'strictEqual',
      stackStartFn: hidden
    });
    assert(!err.stack.includes('hidden'));
    assert(!err2.stack.includes('hidden'));
  })();
}

assert.throws(
  () => assert.throws(() => { throw Symbol('foo'); }, RangeError),
  {
    message: 'The error is expected to be an instance of ""RangeError"". ' +
             'Received ""Symbol(foo)""'
  }
);

assert.throws(
  // eslint-disable-next-line no-throw-literal
  () => assert.throws(() => { throw [1, 2]; }, RangeError),
  {
    message: 'The error is expected to be an instance of ""RangeError"". ' +
             'Received ""[Array]""'
  }
);

{
  const err = new TypeError('foo');
  const validate = (() => () => ({ a: true, b: [ 1, 2, 3 ] }))();
  assert.throws(
    () => assert.throws(() => { throw err; }, validate),
    {
      message: 'The validation function is expected to ' +
              `return ""true"". Received ${inspect(validate())}\n\nCaught ` +
              `error:\n\n${err}`,
      code: 'ERR_ASSERTION',
      actual: err,
      expected: validate,
      name: 'AssertionError',
      operator: 'throws',
    }
  );
}

assert.throws(
  () => {
    const script = new vm.Script('new RangeError(""foobar"");');
    const context = vm.createContext();
    const err = script.runInContext(context);
    assert.throws(() => { throw err; }, RangeError);
  },
  {
    message: 'The error is expected to be an instance of ""RangeError"". ' +
             'Received an error with identical name but a different ' +
             'prototype.\n\nError message:\n\nfoobar'
  }
);

// Multiple assert.match() tests.
{
  assert.throws(
    () => assert.match(/abc/, 'string'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""regexp"" argument must be an instance of RegExp. ' +
               ""Received type string ('string')""
    }
  );
  assert.throws(
    () => assert.match('string', /abc/),
    {
      actual: 'string',
      expected: /abc/,
      operator: 'match',
      message: 'The input did not match the regular expression /abc/. ' +
               ""Input:\n\n'string'\n"",
      generatedMessage: true
    }
  );
  assert.throws(
    () => assert.match('string', /abc/, 'foobar'),
    {
      actual: 'string',
      expected: /abc/,
      operator: 'match',
      message: 'foobar',
      generatedMessage: false
    }
  );
  const errorMessage = new RangeError('foobar');
  assert.throws(
    () => assert.match('string', /abc/, errorMessage),
    errorMessage
  );
  assert.throws(
    () => assert.match({ abc: 123 }, /abc/),
    {
      actual: { abc: 123 },
      expected: /abc/,
      operator: 'match',
      message: 'The ""string"" argument must be of type string. ' +
               'Received type object ({ abc: 123 })',
      generatedMessage: true
    }
  );
  assert.match('I will pass', /pass$/);
}

// Multiple assert.doesNotMatch() tests.
{
  assert.throws(
    () => assert.doesNotMatch(/abc/, 'string'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: 'The ""regexp"" argument must be an instance of RegExp. ' +
               ""Received type string ('string')""
    }
  );
  assert.throws(
    () => assert.doesNotMatch('string', /string/),
    {
      actual: 'string',
      expected: /string/,
      operator: 'doesNotMatch',
      message: 'The input was expected to not match the regular expression ' +
               ""/string/. Input:\n\n'string'\n"",
      generatedMessage: true
    }
  );
  assert.throws(
    () => assert.doesNotMatch('string', /string/, 'foobar'),
    {
      actual: 'string',
      expected: /string/,
      operator: 'doesNotMatch',
      message: 'foobar',
      generatedMessage: false
    }
  );
  const errorMessage = new RangeError('foobar');
  assert.throws(
    () => assert.doesNotMatch('string', /string/, errorMessage),
    errorMessage
  );
  assert.throws(
    () => assert.doesNotMatch({ abc: 123 }, /abc/),
    {
      actual: { abc: 123 },
      expected: /abc/,
      operator: 'doesNotMatch',
      message: 'The ""string"" argument must be of type string. ' +
               'Received type object ({ abc: 123 })',
      generatedMessage: true
    }
  );
  assert.doesNotMatch('I will pass', /different$/);
}

{
  const tempColor = inspect.defaultOptions.colors;
  assert.throws(() => {
    inspect.defaultOptions.colors = true;
    // Guarantee the position indicator is placed correctly.
    assert.strictEqual(111554n, 11111115);
  }, (err) => {
    assert.strictEqual(inspect(err).split('\n')[5], '     ^');
    inspect.defaultOptions.colors = tempColor;
    return true;
  });
}
"
modules/assert.js,"// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import { Buffer } from 'buffer';
import {
  ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS,
  isErrorStackTraceLimitWritable,
} from 'internal/errors';

const overrideStackTrace = new WeakMap();

import AssertionError from 'internal/assert/assertion_error';
import { openSync, closeSync, readSync } from 'fs';
import { inspect } from 'internal/util/inspect';
import { isPromise, isRegExp } from 'internal/util/types';
import { EOL } from 'internal/constants';
// import { BuiltinModule } from 'internal/bootstrap/loaders';
import { isError } from 'internal/util';

const errorCache = new Map();
import CallTracker from 'internal/assert/calltracker';
import {
  validateFunction,
} from 'internal/validators';

import { isDeepEqual, isDeepStrictEqual } from 'internal/util/comparisons'

let parseExpressionAt;
let findNodeAround;
let decoder;

// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
const escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
const meta = [
  '\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004',
  '\\u0005', '\\u0006', '\\u0007', '\\b', '',
  '', '\\u000b', '\\f', '', '\\u000e',
  '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013',
  '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018',
  '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d',
  '\\u001e', '\\u001f',
];

const escapeFn = (str) => meta[String.prototype.charCodeAt.call(str, 0)];

let warned = false;

// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

const assert = function (obj) {
  if (!obj) {
    throw new AssertionError({ message: 'assert fail' });
  }
};

const NO_EXCEPTION_SENTINEL = {};

// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;

  throw new AssertionError(obj);
}

/**
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @param {string} [operator]
 * @param {Function} [stackStartFn]
 */
function fail(actual, expected, message, operator, stackStartFn) {
  const argsLen = arguments.length;

  let internalMessage = false;
  if (actual == null && argsLen <= 1) {
    internalMessage = true;
    message = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      process.emitWarning(
        'assert.fail() with more than one argument is deprecated. ' +
        'Please use assert.strictEqual() instead or only pass a message.',
        'DeprecationWarning',
        'DEP0094'
      );
    }
    if (argsLen === 2)
      operator = '!=';
  }

  if (message instanceof Error) throw message;

  const errArgs = {
    actual,
    expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail,
    message
  };
  const err = new AssertionError(errArgs);
  if (internalMessage) {
    err.generatedMessage = true;
  }
  throw err;
}

assert.fail = fail;

// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;

function findColumn(fd, column, code) {
  if (code.length > column + 100) {
    try {
      return parseCode(code, column);
    } catch {
      // End recursion in case no code could be parsed. The expression should
      // have been found after 2500 characters, so stop trying.
      if (code.length - column > 2500) {
        // eslint-disable-next-line no-throw-literal
        throw null;
      }
    }
  }
  // Read up to 2500 bytes more than necessary in columns. That way we address
  // multi byte characters and read enough data to parse the code.
  const bytesToRead = column - code.length + 2500;
  const buffer = Buffer.allocUnsafe(bytesToRead);
  const bytesRead = readSync(fd, buffer, 0, bytesToRead);
  code += decoder.write(buffer.slice(0, bytesRead));
  // EOF: fast path.
  if (bytesRead < bytesToRead) {
    return parseCode(code, column);
  }
  // Read potentially missing code.
  return findColumn(fd, column, code);
}

function getCode(fd, line, column) {
  let bytesRead = 0;
  if (line === 0) {
    // Special handle line number one. This is more efficient and simplifies the
    // rest of the algorithm. Read more than the regular column number in bytes
    // to prevent multiple reads in case multi byte characters are used.
    return findColumn(fd, column, '');
  }
  let lines = 0;
  // Prevent blocking the event loop by limiting the maximum amount of
  // data that may be read.
  let maxReads = 32; // bytesPerRead * maxReads = 512 KiB
  const bytesPerRead = 16384;
  // Use a single buffer up front that is reused until the call site is found.
  let buffer = Buffer.allocUnsafe(bytesPerRead);
  while (maxReads-- !== 0) {
    // Only allocate a new buffer in case the needed line is found. All data
    // before that can be discarded.
    buffer = lines < line ? buffer : Buffer.allocUnsafe(bytesPerRead);
    bytesRead = readSync(fd, buffer, 0, bytesPerRead);
    // Read the buffer until the required code line is found.
    for (let i = 0; i < bytesRead; i++) {
      if (buffer[i] === 10 && ++lines === line) {
        // If the end of file is reached, directly parse the code and return.
        if (bytesRead < bytesPerRead) {
          return parseCode(buffer.toString('utf8', i + 1, bytesRead), column);
        }
        // Check if the read code is sufficient or read more until the whole
        // expression is read. Make sure multi byte characters are preserved
        // properly by using the decoder.
        const code = decoder.write(buffer.slice(i + 1, bytesRead));
        return findColumn(fd, column, code);
      }
    }
  }
}

function parseCode(code, offset) {
  // Lazy load acorn.
  if (parseExpressionAt === undefined) {
    const Parser = import('internal/deps/acorn/acorn/dist/acorn').Parser;
    ({ findNodeAround } = import('internal/deps/acorn/acorn-walk/dist/walk'));

    parseExpressionAt = Function.prototype.bind.call(Parser.parseExpressionAt, Parser);
  }
  let node;
  let start = 0;
  // Parse the read code until the correct expression is found.
  do {
    try {
      node = parseExpressionAt(code, start, { ecmaVersion: 'latest' });
      start = node.end + 1 || start;
      // Find the CallExpression in the tree.
      node = findNodeAround(node, offset, 'CallExpression');
    } catch (err) {
      // Unexpected token error and the like.
      start += err.raisedAt || 1;
      if (start > offset) {
        // No matching expression found. This could happen if the assert
        // expression is bigger than the provided buffer.
        // eslint-disable-next-line no-throw-literal
        throw null;
      }
    }
  } while (node === undefined || node.node.end < offset);

  return [
    node.node.start,
    String.prototype.replace.call(String.prototype.slice.call(code,
      node.node.start, node.node.end),
      escapeSequencesRegExp, escapeFn),
  ];
}

function getErrMessage(message, fn) {
  return ""assert.getErrMessage unsupported"";
  const tmpLimit = Error.stackTraceLimit;
  const errorStackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  // Make sure the limit is set to 1. Otherwise it could fail (<= 0) or it
  // does to much work.
  if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = 1;
  // We only need the stack trace. To minimize the overhead use an object
  // instead of an error.
  const err = {};
  Error.captureStackTrace(err, fn);
  if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = tmpLimit;

  overrideStackTrace.set(err, (_, stack) => stack);
  const call = err.stack[0];

  const filename = call.getFileName();
  const line = call.getLineNumber() - 1;
  let column = call.getColumnNumber() - 1;
  let identifier;
  let code;

  if (filename) {
    identifier = `${filename}${line}${column}`;

    // Skip Node.js modules!
    if (String.prototype.startsWith.call(filename, 'node:') &&
      BuiltinModule.exists(String.prototype.slice.call(filename, 5))) {
      errorCache.set(identifier, undefined);
      return;
    }
  } else {
    const fn = call.getFunction();
    if (!fn) {
      return message;
    }
    code = String(fn);
    identifier = `${code}${line}${column}`;
  }

  if (errorCache.has(identifier)) {
    return errorCache.get(identifier);
  }

  let fd;
  try {
    // Set the stack trace limit to zero. This makes sure unexpected token
    // errors are handled faster.
    if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = 0;

    if (filename) {
      if (decoder === undefined) {
        const { StringDecoder } = import('string_decoder');
        decoder = new StringDecoder('utf8');
      }
      fd = openSync(filename, 'r', 0o666);
      // Reset column and message.
      ({ 0: column, 1: message } = getCode(fd, line, column));
      // Flush unfinished multi byte characters.
      decoder.end();
    } else {
      for (let i = 0; i < line; i++) {
        code = String.prototype.slice.call(code,
          String.prototype.indexOf.call(code, '\n') + 1);
      }
      ({ 0: column, 1: message } = parseCode(code, column));
    }
    // Always normalize indentation, otherwise the message could look weird.
    if (String.prototype.includes.call(message, '\n')) {
      if (EOL === '\r\n') {
        message = RegExp.prototype[Symbol.replace].call(/\r\n/g, message, '\n');
      }
      const frames = String.prototype.split.call(message, '\n');
      message = Array.prototype.shift.call(frames);
      for (const frame of frames) {
        let pos = 0;
        while (pos < column && (frame[pos] === ' ' || frame[pos] === '\t')) {
          pos++;
        }
        message += `\n  ${String.prototype.slice.call(frame, pos)}`;
      }
    }
    message = `The expression evaluated to a falsy value:\n\n  ${message}\n`;
    // Make sure to always set the cache! No matter if the message is
    // undefined or not
    errorCache.set(identifier, message);

    return message;
  } catch {
    // Invalidate cache to prevent trying to read this part again.
    errorCache.set(identifier, undefined);
  } finally {
    // Reset limit.
    if (errorStackTraceLimitIsWritable) Error.stackTraceLimit = tmpLimit;
    if (fd !== undefined)
      closeSync(fd);
  }
}

function innerOk(fn, argLen, value, message) {
  if (!value) {
    let generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message == null) {
      generatedMessage = true;
      message = getErrMessage(message, fn);
    } else if (message instanceof Error) {
      throw message;
    }

    const err = new AssertionError({
      actual: value,
      expected: true,
      message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

/**
 * Pure assertion tests whether a value is truthy, as determined
 * by !!value.
 * @param {...any} args
 * @returns {void}
 */
function ok(...args) {
  innerOk(ok, args.length, ...args);
}
assert.ok = ok;

/**
 * The equality assertion tests shallow, coercive equality with ==.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
/* eslint-disable no-restricted-properties */
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual != expected && (!Number.isNaN(actual) || !Number.isNaN(expected))) {
    innerFail({
      actual,
      expected,
      message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

/**
 * The non-equality assertion tests for whether two objects are not
 * equal with !=.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  // eslint-disable-next-line eqeqeq
  if (actual == expected || (Number.isNaN(actual) && Number.isNaN(expected))) {
    innerFail({
      actual,
      expected,
      message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

/**
 * The deep equivalence assertion tests a deep equality relation.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

/**
 * The deep non-equivalence assertion tests for any deep inequality.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

/**
 * The deep strict equivalence assertion tests a deep strict equality
 * relation.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

/**
 * The deep strict non-equivalence assertion tests for any deep strict
 * inequality.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

/**
 * The strict equivalence assertion tests a strict equality relation.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!Object.is(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

/**
 * The strict non-equivalence assertion tests for any strict inequality.
 * @param {any} actual
 * @param {any} expected
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (Object.is(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

class Comparison {
  constructor(obj, keys, actual) {
    for (const key of keys) {
      if (key in obj) {
        if (actual !== undefined &&
          typeof actual[key] === 'string' &&
          isRegExp(obj[key]) &&
          RegExp.prototype.exec.call(obj[key], actual[key]) !== null) {
          this[key] = actual[key];
        } else {
          this[key] = obj[key];
        }
      }
    }
  }
}

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      const a = new Comparison(actual, keys);
      const b = new Comparison(expected, keys, actual);

      const err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual,
      expected,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, message, fn) {
  let generatedMessage = false;
  let throwError = false;

  if (typeof expected !== 'function') {
    // Handle regular expressions.
    if (isRegExp(expected)) {
      const str = String(actual);
      if (RegExp.prototype.exec.call(expected, str) !== null)
        return;

      if (!message) {
        generatedMessage = true;
        message = 'The input did not match the regular expression ' +
          `${inspect(expected)}. Input:\n\n${inspect(str)}\n`;
      }
      throwError = true;
      // Handle primitives properly.
    } else if (typeof actual !== 'object' || actual === null) {
      const err = new AssertionError({
        actual,
        expected,
        message,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    } else {
      // Handle validation objects.
      const keys = Object.keys(expected);
      // Special handle errors to make sure the name and the message are
      // compared as well.
      if (expected instanceof Error) {
        Array.prototype.push.call(keys, 'name', 'message');
      } else if (keys.length === 0) {
        throw new ERR_INVALID_ARG_VALUE('error',
          expected, 'may not be an empty object');
      }
      for (const key of keys) {
        if (typeof actual[key] === 'string' &&
          isRegExp(expected[key]) &&
          RegExp.prototype.exec.call(expected[key], actual[key]) !== null) {
          continue;
        }
        compareExceptionKey(actual, expected, key, message, keys, fn);
      }
      return;
    }
    // Guard instanceof against arrow functions as they don't have a prototype.
    // Check for matching Error classes.
  } else if (expected.prototype !== undefined && actual instanceof expected) {
    return;
  } else if (Error.prototype.isPrototypeOf(expected)) {
    if (!message) {
      generatedMessage = true;
      message = 'The error is expected to be an instance of ' +
        `""${expected.name}"". Received `;
      if (isError(actual)) {
        const name = (actual.constructor && actual.constructor.name) ||
          actual.name;
        if (expected.name === name) {
          message += 'an error with identical name but a different prototype.';
        } else {
          message += `""${name}""`;
        }
        if (actual.message) {
          message += `\n\nError message:\n\n${actual.message}`;
        }
      } else {
        message += `""${inspect(actual, { depth: -1 })}""`;
      }
    }
    throwError = true;
  } else {
    // Check validation functions return value.
    const res = Reflect.apply(expected, {}, [actual]);
    if (res !== true) {
      if (!message) {
        generatedMessage = true;
        const name = expected.name ? `""${expected.name}"" ` : '';
        message = `The ${name}validation function is expected to return` +
          ` ""true"". Received ${inspect(res)}`;

        if (isError(actual)) {
          message += `\n\nCaught error:\n\n${actual}`;
        }
      }
      throwError = true;
    }
  }

  if (throwError) {
    const err = new AssertionError({
      actual,
      expected,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

function getActual(fn) {
  validateFunction(fn, 'fn');
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  return isPromise(obj) ||
    (obj !== null && typeof obj === 'object' &&
      typeof obj.then === 'function' &&
      typeof obj.catch === 'function');
}

async function waitForActual(promiseFn) {
  let resultPromise;
  if (typeof promiseFn === 'function') {
    // Return a rejected promise if `promiseFn` throws synchronously.
    resultPromise = promiseFn();
    // Fail in case no promise is returned.
    if (!checkIsPromise(resultPromise)) {
      throw new ERR_INVALID_RETURN_VALUE('instance of Promise',
        'promiseFn', resultPromise);
    }
  } else if (checkIsPromise(promiseFn)) {
    resultPromise = promiseFn;
  } else {
    throw new ERR_INVALID_ARG_TYPE(
      'promiseFn', ['Function', 'Promise'], promiseFn);
  }

  try {
    await resultPromise;
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error',
        ['Object', 'Error', 'Function', 'RegExp'],
        error);
    }
    if (typeof actual === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT(
          'error/message',
          `The error message ""${actual.message}"" is identical to the message.`
        );
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT(
        'error/message',
        `The error ""${actual}"" is identical to the message.`
      );
    }
    message = error;
    error = undefined;
  } else if (error != null &&
    typeof error !== 'object' &&
    typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error',
      ['Object', 'Error', 'Function', 'RegExp'],
      error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    let details = '';
    if (error && error.name) {
      details += ` (${error.name})`;
    }
    details += message ? `: ${message}` : '.';
    const fnType = stackStartFn === assert.rejects ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: `Missing expected ${fnType}${details}`,
      stackStartFn
    });
  }

  if (!error)
    return;

  expectedException(actual, error, message, stackStartFn);
}

function hasMatchingError(actual, expected) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) {
      const str = String(actual);
      return RegExp.prototype.exec.call(expected, str) !== null;
    }
    throw new ERR_INVALID_ARG_TYPE(
      'expected', ['Function', 'RegExp'], expected
    );
  }
  // Guard instanceof against arrow functions as they don't have a prototype.
  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Object.prototype.isPrototypeOf.call(Error, expected)) {
    return false;
  }
  return Reflect.apply(expected, {}, [actual]) === true;
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL)
    return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || hasMatchingError(actual, error)) {
    const details = message ? `: ${message}` : '.';
    const fnType = stackStartFn === assert.doesNotReject ?
      'rejection' : 'exception';
    innerFail({
      actual,
      expected: error,
      operator: stackStartFn.name,
      message: `Got unwanted ${fnType}${details}\n` +
        `Actual message: ""${actual && actual.message}""`,
      stackStartFn
    });
  }
  throw actual;
}

/**
 * Expects the function `promiseFn` to throw an error.
 * @param {() => any} promiseFn
 * @param {...any} [args]
 * @returns {void}
 */
assert.throws = function throws(promiseFn, ...args) {
  expectsError(throws, getActual(promiseFn), ...args);
};

/**
 * Expects `promiseFn` function or its value to reject.
 * @param {() => Promise<any>} promiseFn
 * @param {...any} [args]
 * @returns {Promise<void>}
 */
assert.rejects = async function rejects(promiseFn, ...args) {
  expectsError(rejects, await waitForActual(promiseFn), ...args);
};

/**
 * Asserts that the function `fn` does not throw an error.
 * @param {() => any} fn
 * @param {...any} [args]
 * @returns {void}
 */
assert.doesNotThrow = function doesNotThrow(fn, ...args) {
  expectsNoError(doesNotThrow, getActual(fn), ...args);
};

/**
 * Expects `fn` or its value to not reject.
 * @param {() => Promise<any>} fn
 * @param {...any} [args]
 * @returns {Promise<void>}
 */
assert.doesNotReject = async function doesNotReject(fn, ...args) {
  expectsNoError(doesNotReject, await waitForActual(fn), ...args);
};

/**
 * Throws `value` if the value is not `null` or `undefined`.
 * @param {any} err
 * @returns {void}
 */
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    let message = 'ifError got unwanted exception: ';
    if (typeof err === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    const newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message,
      stackStartFn: ifError
    });

    // Make sure we actually have a stack trace!
    const origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      const origStackStart = String.prototype.indexOf.call(origStack, '\n    at');
      if (origStackStart !== -1) {
        const originalFrames = String.prototype.split.call(
          String.prototype.slice.call(origStack, origStackStart + 1),
          '\n'
        );
        // Filter all frames existing in err.stack.
        let newFrames = String.prototype.split.call(newErr.stack, '\n');
        for (const errFrame of originalFrames) {
          // Find the first occurrence of the frame.
          const pos = Array.prototype.indexOf.call(newFrames, errFrame);
          if (pos !== -1) {
            // Only keep new frames.
            newFrames = Array.prototype.slice.call(newFrames, 0, pos);
            break;
          }
        }
        const stackStart = Array.prototype.join.call(newFrames, '\n');
        const stackEnd = Array.prototype.join.call(originalFrames, '\n');
        newErr.stack = `${stackStart}\n${stackEnd}`;
      }
    }

    throw newErr;
  }
};

function internalMatch(string, regexp, message, fn) {
  if (!isRegExp(regexp)) {
    throw new ERR_INVALID_ARG_TYPE(
      'regexp', 'RegExp', regexp
    );
  }
  const match = fn === assert.match;
  if (typeof string !== 'string' ||
    RegExp.prototype.exec.call(regexp, string) !== null !== match) {
    if (message instanceof Error) {
      throw message;
    }

    const generatedMessage = !message;

    // 'The input was expected to not match the regular expression ' +
    message = message || (typeof string !== 'string' ?
      'The ""string"" argument must be of type string. Received type ' +
      `${typeof string} (${inspect(string)})` :
      (match ?
        'The input did not match the regular expression ' :
        'The input was expected to not match the regular expression ') +
      `${inspect(regexp)}. Input:\n\n${inspect(string)}\n`);
    const err = new AssertionError({
      actual: string,
      expected: regexp,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
}

/**
 * Expects the `string` input to match the regular expression.
 * @param {string} string
 * @param {RegExp} regexp
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.match = function match(string, regexp, message) {
  internalMatch(string, regexp, message, match);
};

/**
 * Expects the `string` input not to match the regular expression.
 * @param {string} string
 * @param {RegExp} regexp
 * @param {string | Error} [message]
 * @returns {void}
 */
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  internalMatch(string, regexp, message, doesNotMatch);
};

assert.CallTracker = CallTracker;

// import snapshot from 'internal/assert/snapshot';
assert.snapshot = undefined;

/**
 * Expose a strict only variant of assert.
 * @param {...any} args
 * @returns {void}
 */
function strict(...args) {
  innerOk(strict, args.length, ...args);
}

assert.strict = Object.assign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});

assert.strict.strict = assert.strict;

export default assert;

export { AssertionError };"
src/quickjs_sys/mod.rs,"#[macro_use]
mod macros;
pub mod js_class;
pub mod js_module;
pub mod js_promise;

use std::collections::HashMap;

pub use js_class::*;
pub use js_module::{JsModuleDef, ModuleInit};

#[allow(warnings)]
mod qjs {
    include!(""../../lib/binding.rs"");
}

use qjs::*;
use std::fmt::{Debug, Formatter};
use std::marker::PhantomData;
use std::mem;
use std::mem::ManuallyDrop;
use std::ops::DerefMut;

struct DroppableValue<T, F>
where
    F: FnMut(&mut T),
{
    value: T,
    drop_fn: F,
}

impl<T, F> DroppableValue<T, F>
where
    F: FnMut(&mut T),
{
    pub fn new(value: T, drop_fn: F) -> Self {
        Self { value, drop_fn }
    }
}

impl<T, F> Drop for DroppableValue<T, F>
where
    F: FnMut(&mut T),
{
    fn drop(&mut self) {
        (self.drop_fn)(&mut self.value);
    }
}

impl<T, F> std::ops::Deref for DroppableValue<T, F>
where
    F: FnMut(&mut T),
{
    type Target = T;

    fn deref(&self) -> &T {
        &self.value
    }
}

impl<T, F> std::ops::DerefMut for DroppableValue<T, F>
where
    F: FnMut(&mut T),
{
    fn deref_mut(&mut self) -> &mut T {
        &mut self.value
    }
}

pub trait JsFn {
    fn call(ctx: &mut Context, this_val: JsValue, argv: &[JsValue]) -> JsValue;
}

unsafe extern ""C"" fn module_loader(
    ctx: *mut JSContext,
    module_name_: *const ::std::os::raw::c_char,
    _opaque: *mut ::std::os::raw::c_void,
) -> *mut JSModuleDef {
    let module_name = std::ffi::CStr::from_ptr(module_name_).to_str();
    if module_name.is_err() {
        return std::ptr::null_mut();
    }
    let module_name = module_name.unwrap();

    let mut path = std::path::PathBuf::from(module_name);
    let ext = path
        .extension()
        .unwrap_or_default()
        .to_str()
        .unwrap_or_default();
    match ext {
        """" => {
            path.set_extension(""js"");
        }
        ""js"" => {}
        _ => {
            JS_ThrowReferenceError(
                ctx,
                ""could not load module filename '%s'\0"".as_ptr().cast(),
                module_name_,
            );
            return std::ptr::null_mut();
        }
    }

    if !path.is_file() {
        let modules_dir = std::env::var(""QJS_LIB"").unwrap_or(""./modules"".to_string());
        path = std::path::PathBuf::from(modules_dir).join(path);
    }

    let code = std::fs::read(&path);
    if code.is_err() {
        JS_ThrowReferenceError(
            ctx,
            ""could not load module filename '%s'\0"".as_ptr().cast(),
            module_name_,
        );
        return std::ptr::null_mut();
    }

    let buf = code.unwrap();
    let buf_len = buf.len();
    let buf = make_c_string(buf);

    // compile the module
    let func_val = JS_Eval(
        ctx,
        buf.as_ptr(),
        buf_len,
        module_name_,
        (JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY) as i32,
    );

    if JS_IsException_real(func_val) != 0 {
        return std::ptr::null_mut();
    }

    js_module_set_import_meta(ctx, func_val, 0, 0);

    let m = JS_VALUE_GET_PTR_real(func_val);
    JS_FreeValue_real(ctx, func_val);

    m.cast()
}

struct InnerRuntime(*mut JSRuntime);
impl Drop for InnerRuntime {
    fn drop(&mut self) {
        unsafe { JS_FreeRuntime(self.0) };
    }
}
pub struct Runtime {
    ctx: Context,
    rt: InnerRuntime,
}

impl Runtime {
    pub fn new() -> Self {
        unsafe {
            let raw_rt = JS_NewRuntime();
            let ctx = Context::new_with_rt(raw_rt);
            JS_SetModuleLoaderFunc(raw_rt, None, Some(module_loader), std::ptr::null_mut());

            let mut rt = Runtime {
                ctx,
                rt: InnerRuntime(raw_rt),
            };
            rt.init_event_loop();
            rt
        }
    }

    fn init_event_loop(&mut self) {
        unsafe {
            let event_loop = Box::new(super::EventLoop::default());
            let event_loop_ptr: &'static mut super::EventLoop = Box::leak(event_loop);
            JS_SetRuntimeOpaque(self.rt.0, (event_loop_ptr as *mut super::EventLoop).cast());
        }
    }
    fn drop_event_loop(&mut self) {
        unsafe {
            let event_loop = JS_GetRuntimeOpaque(self.rt.0) as *mut super::EventLoop;
            if !event_loop.is_null() {
                Box::from_raw(event_loop); // drop
            }
        }
    }

    pub fn run_with_context<F: FnMut(&mut Context) -> R, R>(&mut self, mut f: F) -> R {
        f(&mut self.ctx)
    }

    unsafe fn run_loop_without_io(&mut self) -> i32 {
        log::trace!(""Runtime run loop without io"");
        use crate::EventLoop;
        use qjs::JS_ExecutePendingJob;

        let rt = self.rt.0;
        let event_loop = { (JS_GetRuntimeOpaque(rt) as *mut EventLoop).as_mut() }.unwrap();
        let mut pctx: *mut JSContext = 0 as *mut JSContext;

        loop {
            'pending: loop {
                log::trace!(""Runtime JS_ExecutePendingJob"");
                let err = JS_ExecutePendingJob(rt, (&mut pctx) as *mut *mut JSContext);
                if err <= 0 {
                    if err < 0 {
                        js_std_dump_error(pctx);
                        return err;
                    }
                    break 'pending;
                }
            }

            if event_loop.run_tick_task() == 0 {
                break;
            }
            log::trace!(""Runtime JS_ExecutePendingJob continue"");
        }
        0
    }

    pub fn async_run_with_context(
        &mut self,
        box_fn: Box<dyn FnOnce(&mut Context) -> JsValue>,
    ) -> RuntimeResult {
        let box_fn = Some(box_fn);
        RuntimeResult {
            box_fn,
            result: None,
            rt: self,
        }
    }
}

pub struct RuntimeResult<'rt> {
    box_fn: Option<Box<dyn FnOnce(&mut Context) -> JsValue>>,
    result: Option<JsValue>,
    rt: &'rt mut Runtime,
}

impl Drop for Runtime {
    fn drop(&mut self) {
        self.drop_event_loop();
    }
}

struct JsFunctionTrampoline;
impl JsFunctionTrampoline {
    // How i figured it out!
    unsafe extern ""C"" fn callback<T: JsFn>(
        ctx: *mut JSContext,
        this_obj: JSValue,
        len: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue {
        let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });
        let n_ctx = n_ctx.deref_mut();
        let this_obj = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, this_obj));
        let mut arg_vec = vec![];
        for i in 0..len {
            let arg = argv.offset(i as isize);
            let v = *arg;
            let v = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, v));
            arg_vec.push(v);
        }
        let r = T::call(n_ctx, this_obj, arg_vec.as_slice());
        r.into_qjs_value()
    }
}

#[derive(Default)]
struct JsFunction2Trampoline;
impl JsFunction2Trampoline {
    // How i figured it out!
    unsafe extern ""C"" fn callback<T: Fn(&mut Context, JsValue, &[JsValue]) -> JsValue>(
        ctx: *mut JSContext,
        this_obj: JSValue,
        len: ::std::os::raw::c_int,
        argv: *mut JSValue,
    ) -> JSValue {
        let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });
        let n_ctx = n_ctx.deref_mut();
        let this_obj = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, this_obj));
        let mut arg_vec = vec![];
        for i in 0..len {
            let arg = argv.offset(i as isize);
            let v = *arg;
            let v = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, v));
            arg_vec.push(v);
        }
        let f = mem::zeroed::<T>();
        let r = f(n_ctx, this_obj, arg_vec.as_slice());
        r.into_qjs_value()
    }
}

pub struct Context {
    ctx: *mut JSContext,
}

unsafe impl Send for Context {}

fn get_file_name(ctx: &mut Context, n_stack_levels: usize) -> JsValue {
    unsafe {
        let basename = JS_GetScriptOrModuleName(ctx.ctx, n_stack_levels as i32);
        if basename == JS_ATOM_NULL {
            JsValue::Null
        } else {
            let basename_val = JS_AtomToValue(ctx.ctx, basename);
            JsValue::from_qjs_value(ctx.ctx, basename_val)
        }
    }
}

fn js_init_dirname(ctx: &mut Context) {
    fn js_dir_name(ctx: &mut Context, _this_val: JsValue, _argv: &[JsValue]) -> JsValue {
        if let JsValue::String(file_name) = get_file_name(ctx, 1) {
            let file_name = file_name.as_str();
            let p = std::path::Path::new(file_name);
            if let Some(parent) = p.parent() {
                ctx.new_string(format!(""{}"", parent.display()).as_str())
                    .into()
            } else {
                JsValue::UnDefined
            }
        } else {
            JsValue::UnDefined
        }
    }

    let global = ctx.get_global();
    let get_dirname: JsValue = ctx.wrap_function(""get_dirname"", js_dir_name).into();

    unsafe {
        let ctx = ctx.ctx;
        JS_DefineProperty(
            ctx,
            global.0.v,
            JS_NewAtom(ctx, ""__dirname\0"".as_ptr().cast()),
            js_undefined(),
            get_dirname.get_qjs_value(),
            js_null(),
            (JS_PROP_THROW
                | JS_PROP_HAS_ENUMERABLE
                | JS_PROP_ENUMERABLE
                | JS_PROP_HAS_CONFIGURABLE
                | JS_PROP_CONFIGURABLE
                | JS_PROP_HAS_GET) as i32,
        )
    };
}

impl Context {
    pub fn event_loop(&mut self) -> Option<&mut super::EventLoop> {
        unsafe { (JS_GetRuntimeOpaque(self.rt()) as *mut super::EventLoop).as_mut() }
    }

    #[inline]
    unsafe fn rt(&mut self) -> *mut JSRuntime {
        JS_GetRuntime(self.ctx)
    }

    unsafe fn clone_(&mut self) -> std::mem::ManuallyDrop<Self> {
        std::mem::ManuallyDrop::new(Context { ctx: self.ctx })
    }

    unsafe fn new_with_rt(rt: *mut JSRuntime) -> Context {
        let ctx = JS_NewContext(rt);
        JS_AddIntrinsicBigFloat(ctx);
        JS_AddIntrinsicBigDecimal(ctx);
        JS_AddIntrinsicOperators(ctx);
        JS_EnableBignumExt(ctx, 1);
        js_std_add_console(ctx);
        js_init_module_std(ctx, ""std\0"".as_ptr() as *const i8);
        js_init_module_os(ctx, ""qjs:os\0"".as_ptr() as *const i8);
        let mut ctx = Context { ctx };

        #[cfg(feature = ""img"")]
        super::internal_module::img_module::init_module(&mut ctx);

        #[cfg(feature = ""tensorflow"")]
        {
            super::internal_module::tensorflow_module::init_module_tensorflow(&mut ctx);
            super::internal_module::tensorflow_module::init_module_tensorflow_lite(&mut ctx);
        }

        #[cfg(feature = ""wasi_nn"")]
        super::internal_module::wasi_nn::init_module(&mut ctx);

        js_init_dirname(&mut ctx);

        super::internal_module::core::init_global_function(&mut ctx);
        super::internal_module::core::init_ext_function(&mut ctx);
        super::internal_module::encoding::init_encoding_module(&mut ctx);
        super::internal_module::wasi_net_module::init_module(&mut ctx);
        super::internal_module::httpx::init_module(&mut ctx);
        super::internal_module::os::init_module(&mut ctx);
        super::internal_module::fs::init_module(&mut ctx);

        #[cfg(feature = ""nodejs_crypto"")]
        {
            super::internal_module::crypto::init_module(&mut ctx);
        }

        #[cfg(feature = ""ggml"")]
        {
            super::internal_module::ggml::init_wasi_nn_ggml_module(&mut ctx);
            super::internal_module::ggml::init_ggml_template_module(&mut ctx);
        }
        ctx
    }

    pub fn get_global(&mut self) -> JsObject {
        unsafe {
            let v = JS_GetGlobalObject(self.ctx);
            JsObject(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn put_args<T, I>(&mut self, args: T)
    where
        T: AsRef<[I]>,
        I: AsRef<str>,
    {
        let mut args_obj = self.new_array();
        let args = args.as_ref();
        let mut i = 0;
        for arg in args {
            let arg = arg.as_ref();
            let arg_js_string = self.new_string(arg);
            args_obj.put(i, arg_js_string.into());
            i += 1;
        }
        let mut global = self.get_global();
        global.set(""args"", args_obj.into());
    }

    pub fn eval_buf(&mut self, code: Vec<u8>, filename: &str, eval_flags: u32) -> JsValue {
        unsafe {
            let ctx = self.ctx;
            let len = code.len();
            let val = if (eval_flags & JS_EVAL_TYPE_MASK) == JS_EVAL_TYPE_MODULE {
                let val = JS_Eval(
                    ctx,
                    make_c_string(code).as_ptr(),
                    len,
                    make_c_string(filename).as_ptr(),
                    (eval_flags | JS_EVAL_FLAG_COMPILE_ONLY) as i32,
                );
                if JS_IsException_real(val) <= 0 {
                    JS_EvalFunction(ctx, val)
                } else {
                    val
                }
            } else {
                JS_Eval(
                    ctx,
                    make_c_string(code).as_ptr(),
                    len,
                    make_c_string(filename).as_ptr(),
                    eval_flags as i32,
                )
            };
            if JS_IsException_real(val) > 0 {
                js_std_dump_error(ctx);
            }
            JsValue::from_qjs_value(ctx, val)
        }
    }

    pub fn eval_global_str(&mut self, code: String) -> JsValue {
        self.eval_buf(code.into_bytes(), ""<evalScript>"", JS_EVAL_TYPE_GLOBAL)
    }

    pub fn eval_module_str(&mut self, code: String, filename: &str) {
        self.eval_buf(code.into_bytes(), filename, JS_EVAL_TYPE_MODULE);
    }

    pub fn new_function<F: JsFn>(&mut self, name: &str) -> JsFunction {
        unsafe {
            let name = make_c_string(name);
            let v = JS_NewCFunction_real(
                self.ctx,
                Some(JsFunctionTrampoline::callback::<F>),
                name.as_ptr(),
                1,
            );
            JsFunction(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn wrap_function<F>(&mut self, name: &str, _: F) -> JsFunction
    where
        F: Fn(&mut Context, JsValue, &[JsValue]) -> JsValue,
    {
        unsafe {
            assert_size_zero!(F);

            let name = make_c_string(name);
            let v = JS_NewCFunction_real(
                self.ctx,
                Some(JsFunction2Trampoline::callback::<F>),
                name.as_ptr(),
                1,
            );
            JsFunction(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn new_object(&mut self) -> JsObject {
        let v = unsafe { JS_NewObject(self.ctx) };
        JsObject(JsRef { ctx: self.ctx, v })
    }

    pub fn new_array(&mut self) -> JsArray {
        unsafe {
            let v = JS_NewArray(self.ctx);
            JsArray(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn new_array_buffer(&mut self, buff: &[u8]) -> JsArrayBuffer {
        unsafe {
            let v = JS_NewArrayBufferCopy(self.ctx, buff.as_ptr() as *const u8, buff.len());
            JsArrayBuffer(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn new_array_buffer_t<T: Sized>(&mut self, buff: &[T]) -> JsArrayBuffer {
        unsafe {
            let v = JS_NewArrayBufferCopy(
                self.ctx,
                buff.as_ptr() as *const u8,
                buff.len() * std::mem::size_of::<T>(),
            );
            JsArrayBuffer(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn new_string(&mut self, s: &str) -> JsString {
        unsafe {
            let v = JS_NewStringLen(self.ctx, s.as_ptr() as *const i8, s.len());
            JsString(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn value_to_string(&mut self, v: &JsValue) -> JsValue {
        unsafe {
            let v = JS_ToString(self.ctx, v.get_qjs_value());
            JsValue::from_qjs_value(self.ctx, v)
        }
    }

    pub fn new_error(&mut self, msg: &str) -> JsValue {
        let msg = self.new_string(msg);
        let error = unsafe { JS_NewError(self.ctx) };
        let mut error_obj = JsValue::from_qjs_value(self.ctx, error);
        if let JsValue::Object(o) = &mut error_obj {
            o.set(""message"", msg.into());
        };
        error_obj
    }

    pub fn throw_type_error(&mut self, msg: &str) -> JsException {
        unsafe {
            let v = JS_ThrowTypeError(self.ctx, make_c_string(msg).as_ptr());
            JsException(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn throw_error(&mut self, obj: JsValue) -> JsException {
        unsafe {
            let v = JS_Throw(self.ctx, obj.into_qjs_value());
            JsException(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn throw_internal_type_error(&mut self, msg: &str) -> JsException {
        unsafe {
            let v = JS_ThrowInternalError(self.ctx, make_c_string(msg).as_ptr());
            JsException(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn throw_reference_error(&mut self, msg: &str) -> JsException {
        unsafe {
            let v = JS_ThrowReferenceError(self.ctx, make_c_string(msg).as_ptr());
            JsException(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn throw_range_error(&mut self, msg: &str) -> JsException {
        unsafe {
            let v = JS_ThrowRangeError(self.ctx, make_c_string(msg).as_ptr());
            JsException(JsRef { ctx: self.ctx, v })
        }
    }

    pub fn new_promise(&mut self) -> (JsValue, JsValue, JsValue) {
        unsafe {
            let ctx = self.ctx;
            let mut resolving_funcs = [0, 0];

            let p = JS_NewPromiseCapability(ctx, resolving_funcs.as_mut_ptr());
            (
                JsValue::from_qjs_value(ctx, p),
                JsValue::from_qjs_value(ctx, resolving_funcs[0]),
                JsValue::from_qjs_value(ctx, resolving_funcs[1]),
            )
        }
    }

    pub fn promise_loop_poll(&mut self) {
        unsafe {
            let rt = self.rt();
            let mut pctx: *mut JSContext = 0 as *mut JSContext;

            loop {
                let err = JS_ExecutePendingJob(rt, (&mut pctx) as *mut *mut JSContext);
                if err <= 0 {
                    if err < 0 {
                        js_std_dump_error(pctx);
                    }
                    break;
                }
            }
        }
    }

    #[deprecated]
    pub fn js_loop(&mut self) -> std::io::Result<()> {
        todo!()
    }
}

impl Drop for Context {
    fn drop(&mut self) {
        unsafe {
            JS_FreeContext(self.ctx);
        }
    }
}

impl Clone for Context {
    fn clone(&self) -> Self {
        Context {
            ctx: unsafe { JS_DupContext(self.ctx) },
        }
    }
}

unsafe fn to_u32(ctx: *mut JSContext, v: JSValue) -> Result<u32, String> {
    if JS_VALUE_GET_NORM_TAG_real(v) == JS_TAG_JS_TAG_INT {
        let mut r = 0u32;
        JS_ToUint32_real(ctx, &mut r as *mut u32, v);
        Ok(r)
    } else {
        Err(""value is Not Int"".into())
    }
}

pub(crate) fn make_c_string<T: Into<Vec<u8>>>(s: T) -> std::ffi::CString {
    std::ffi::CString::new(s).unwrap_or(Default::default())
}

// unsafe impl Sync for JsRef {}
#[derive(PartialEq, Eq)]
pub struct JsRef {
    ctx: *mut JSContext,
    v: JSValue,
}

impl Debug for JsRef {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        unsafe {
            let ctx = self.ctx;
            let v = self.v;

            let ptr = JS_ToCStringLen2(ctx, std::ptr::null_mut(), v, 0);
            let s = if ptr.is_null() {
                String::new()
            } else {
                let cstr = std::ffi::CStr::from_ptr(ptr);
                let s = cstr.to_str().map(|s| s.to_string()).unwrap_or_default();
                JS_FreeCString(ctx, ptr);
                s
            };

            write!(f, ""{}"", s)
        }
    }
}

impl Clone for JsRef {
    fn clone(&self) -> Self {
        unsafe {
            Self {
                ctx: self.ctx,
                v: JS_DupValue_real(self.ctx, self.v),
            }
        }
    }
}

impl Drop for JsRef {
    fn drop(&mut self) {
        unsafe {
            let tag = JS_VALUE_GET_NORM_TAG_real(self.v);
            match tag {
                JS_TAG_JS_TAG_STRING
                | JS_TAG_JS_TAG_OBJECT
                | JS_TAG_JS_TAG_FUNCTION_BYTECODE
                | JS_TAG_JS_TAG_BIG_INT
                | JS_TAG_JS_TAG_BIG_FLOAT
                | JS_TAG_JS_TAG_BIG_DECIMAL
                | JS_TAG_JS_TAG_SYMBOL => JS_FreeValue_real(self.ctx, self.v),
                _ => {}
            }
        }
    }
}

unsafe impl Send for JsRef {}
pub trait AsObject {
    fn js_ref(&self) -> &JsRef;

    fn get(&self, key: &str) -> JsValue {
        unsafe {
            let js_ref = self.js_ref();
            let ctx = js_ref.ctx;
            let v = js_ref.v;
            let r = JS_GetPropertyStr(ctx, v, make_c_string(key).as_ptr().cast());
            JsValue::from_qjs_value(ctx, r)
        }
    }

    fn set(&mut self, key: &str, value: JsValue) -> JsValue {
        unsafe {
            let js_ref = self.js_ref();
            let ctx = js_ref.ctx;
            let this_obj = js_ref.v;
            let v = value.into_qjs_value();
            match JS_SetPropertyStr(ctx, this_obj, make_c_string(key).as_ptr().cast(), v) {
                1 => JsValue::Bool(true),
                0 => JsValue::Bool(false),
                _ => JsValue::Exception(JsException(JsRef {
                    ctx,
                    v: js_exception(),
                })),
            }
        }
    }

    fn invoke(&mut self, fn_name: &str, argv: &[JsValue]) -> JsValue {
        unsafe {
            let js_ref = self.js_ref();
            let ctx = js_ref.ctx;
            let this_obj = js_ref.v;
            let mut argv: Vec<JSValue> = argv.iter().map(|v| v.get_qjs_value()).collect();
            let fn_name = JS_NewAtom(ctx, make_c_string(fn_name).as_ptr());
            let v = JS_Invoke(ctx, this_obj, fn_name, argv.len() as i32, argv.as_mut_ptr());
            JS_FreeAtom(ctx, fn_name);
            JsValue::from_qjs_value(ctx, v)
        }
    }

    fn delete(&mut self, key: &str) {
        unsafe {
            let js_ref = self.js_ref();
            let ctx = js_ref.ctx;
            let this_obj = js_ref.v;
            let prop_name = JS_NewAtom(ctx, make_c_string(key).as_ptr());
            JS_DeleteProperty(ctx, this_obj, prop_name, 0);
            JS_FreeAtom(ctx, prop_name);
        }
    }

    fn to_map(&self) -> Result<HashMap<String, JsValue>, JsException> {
        unsafe {
            let js_ref = self.js_ref();
            let ctx = js_ref.ctx;
            let obj = js_ref.v;

            let mut properties: *mut JSPropertyEnum = std::ptr::null_mut();
            let mut count: u32 = 0;

            let flags = (JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK | JS_GPN_ENUM_ONLY) as i32;
            let ret = JS_GetOwnPropertyNames(ctx, &mut properties, &mut count, obj, flags);
            if ret != 0 {
                return Err(JsException(JsRef {
                    ctx,
                    v: js_exception(),
                }));
            }

            let properties = DroppableValue::new(properties, |&mut properties| {
                for index in 0..count {
                    let prop = properties.offset(index as isize);
                    JS_FreeAtom(ctx, (*prop).atom);
                }
                js_free(ctx, properties as *mut std::ffi::c_void);
            });

            let mut map = HashMap::new();
            for index in 0..count {
                let prop = (*properties).offset(index as isize);
                let raw_value = JS_GetPropertyInternal(ctx, obj, (*prop).atom, obj, 0);
                let value = JsValue::from_qjs_value(ctx, raw_value);
                if let JsValue::Exception(e) = value {
                    return Err(e);
                }

                let key_value = JsValue::from_qjs_value(ctx, JS_AtomToString(ctx, (*prop).atom));
                if let JsValue::Exception(e) = key_value {
                    return Err(e);
                }
                if let JsValue::String(key_res) = key_value {
                    let key = key_res.to_string();
                    map.insert(key, value);
                }
            }
            Ok(map)
        }
    }

    fn to_string(&self) -> String {
        format!(""{:?}"", self.js_ref())
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsObject(JsRef);

impl AsObject for JsObject {
    fn js_ref(&self) -> &JsRef {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsFunction(JsRef);

impl AsObject for JsFunction {
    fn js_ref(&self) -> &JsRef {
        &self.0
    }
}

impl JsFunction {
    pub fn call(&self, argv: &[JsValue]) -> JsValue {
        unsafe {
            let ctx = self.0.ctx;
            let mut argv: Vec<JSValue> = argv.iter().map(|v| v.get_qjs_value()).collect();
            let f = self.0.v;
            let v = JS_Call(ctx, f, js_undefined(), argv.len() as i32, argv.as_mut_ptr());
            JsValue::from_qjs_value(ctx, v)
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsPromise(JsRef);

impl JsPromise {
    pub fn get_result(&self) -> JsValue {
        unsafe {
            let ctx = self.0.ctx;
            let this_obj = self.0.v;
            let v = JS_GetPromiseResult_real(ctx, this_obj);
            JsValue::from_qjs_value(ctx, v)
        }
    }
}

impl AsObject for JsPromise {
    fn js_ref(&self) -> &JsRef {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsArray(JsRef);

impl JsArray {
    pub fn to_vec(&self) -> Result<Vec<JsValue>, JsException> {
        unsafe {
            let js_ref = &self.0;
            let ctx = js_ref.ctx;
            let v = js_ref.v;
            let len_raw = JS_GetPropertyStr(ctx, v, make_c_string(""length"").as_ptr());

            let len = to_u32(ctx, len_raw).unwrap_or(0);
            JS_FreeValue_real(ctx, len_raw);

            let mut values = Vec::new();
            for index in 0..(len as usize) {
                let value_raw = JS_GetPropertyUint32(ctx, v, index as u32);
                if JS_VALUE_GET_NORM_TAG_real(value_raw) == JS_TAG_JS_TAG_EXCEPTION {
                    return Err(JsException(JsRef { ctx, v: value_raw }));
                }
                let v = JsValue::from_qjs_value(ctx, value_raw);
                values.push(v);
            }
            Ok(values)
        }
    }
    pub fn set_length(&mut self, len: usize) -> bool {
        unsafe {
            let ctx = self.0.ctx;
            let v = self.0.v;
            let b = JS_SetPropertyStr(
                ctx,
                v,
                make_c_string(""length"").as_ptr().cast(),
                JS_NewInt64_real(ctx, len as i64),
            );
            b == 0
        }
    }
    pub fn get_length(&self) -> usize {
        unsafe {
            let ctx = self.0.ctx;
            let v = self.0.v;
            let len = JS_GetPropertyStr(ctx, v, make_c_string(""length"").as_ptr().cast());
            to_u32(ctx, len).unwrap_or(0) as usize
        }
    }
    pub fn take(&self, i: usize) -> JsValue {
        unsafe {
            let ctx = self.0.ctx;
            let this_obj = self.0.v;
            let v = JS_GetPropertyUint32(ctx, this_obj, i as u32);
            JsValue::from_qjs_value(ctx, v)
        }
    }
    pub fn put(&mut self, i: usize, v: JsValue) {
        unsafe {
            let ctx = self.0.ctx;
            let this_obj = self.0.v;
            let v = v.into_qjs_value();
            JS_SetPropertyUint32(ctx, this_obj, i as u32, v);
        }
    }
}

impl AsObject for JsArray {
    fn js_ref(&self) -> &JsRef {
        &self.0
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsArrayBuffer(JsRef);

impl JsArrayBuffer {
    pub fn to_vec(&self) -> Vec<u8> {
        let buf = self.as_ref();
        buf.to_vec()
    }
    pub fn get_mut_ptr(&self) -> (*mut u8, usize) {
        unsafe {
            let r = &self.0;
            let mut len = 0;
            let p = JS_GetArrayBuffer(r.ctx, &mut len, r.v);
            (p, len)
        }
    }
}

impl AsRef<[u8]> for JsArrayBuffer {
    fn as_ref(&self) -> &[u8] {
        unsafe {
            let (ptr, len) = self.get_mut_ptr();
            std::slice::from_raw_parts(ptr, len)
        }
    }
}

impl AsMut<[u8]> for JsArrayBuffer {
    fn as_mut(&mut self) -> &mut [u8] {
        unsafe {
            let (ptr, len) = self.get_mut_ptr();
            std::slice::from_raw_parts_mut(ptr, len)
        }
    }
}

#[derive(Debug, Clone, Eq)]
pub struct JsString(JsRef);

impl JsString {
    pub fn to_string(&self) -> String {
        unsafe {
            let r = &self.0;
            let ptr = JS_ToCStringLen2(r.ctx, std::ptr::null_mut(), r.v, 0);
            if ptr.is_null() {
                return String::new();
            }
            let cstr = std::ffi::CStr::from_ptr(ptr);
            let s = cstr.to_str().map(|s| s.to_string()).unwrap_or_default();
            JS_FreeCString(r.ctx, ptr);
            s
        }
    }

    pub fn as_str(&self) -> &str {
        unsafe {
            let r = &self.0;
            let ptr = JS_ToCStringLen2(r.ctx, std::ptr::null_mut(), r.v, 0);
            if ptr.is_null() {
                return """";
            }
            let cstr = std::ffi::CStr::from_ptr(ptr);
            cstr.to_str().unwrap_or_default()
        }
    }
}

impl PartialEq for JsString {
    fn eq(&self, other: &Self) -> bool {
        self.as_str() == other.as_str()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsModule(JsRef);

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsFunctionByteCode(JsRef);

#[derive(Debug, Clone, Eq)]
pub struct JsBigNum(JsRef);

impl JsBigNum {
    pub fn to_int64(&self) -> i64 {
        unsafe {
            let mut v = 0_i64;
            JS_ToBigInt64(self.0.ctx, (&mut v) as *mut i64, self.0.v);
            v
        }
    }
}

impl PartialEq for JsBigNum {
    fn eq(&self, other: &Self) -> bool {
        self.to_int64() == other.to_int64()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct JsException(JsRef);

impl JsException {
    pub fn dump_error(&self) {
        unsafe { js_std_dump_error(self.0.ctx) }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum JsValue {
    Int(i32),
    Float(f64),
    BigNum(JsBigNum),
    String(JsString),
    Module(JsModule),
    Object(JsObject),
    Array(JsArray),
    Promise(JsPromise),
    ArrayBuffer(JsArrayBuffer),
    Function(JsFunction),
    Symbol(JsRef),
    Bool(bool),
    Null,
    UnDefined,
    Exception(JsException),
    FunctionByteCode(JsFunctionByteCode),
    Other(JsRef),
}

impl JsValue {
    fn from_qjs_value(ctx: *mut JSContext, v: JSValue) -> Self {
        unsafe {
            let tag = JS_VALUE_GET_NORM_TAG_real(v);
            match tag {
                JS_TAG_JS_TAG_INT => {
                    let mut num = 0;
                    JS_ToInt32(ctx, (&mut num) as *mut i32, v);
                    JsValue::Int(num)
                }
                JS_TAG_JS_TAG_FLOAT64 => {
                    let mut num = 0_f64;
                    JS_ToFloat64(ctx, (&mut num) as *mut f64, v);
                    JsValue::Float(num)
                }
                JS_TAG_JS_TAG_BIG_DECIMAL | JS_TAG_JS_TAG_BIG_INT | JS_TAG_JS_TAG_BIG_FLOAT => {
                    JsValue::BigNum(JsBigNum(JsRef { ctx, v }))
                }
                JS_TAG_JS_TAG_STRING => JsValue::String(JsString(JsRef { ctx, v })),
                JS_TAG_JS_TAG_MODULE => JsValue::Module(JsModule(JsRef { ctx, v })),
                JS_TAG_JS_TAG_OBJECT => {
                    if JS_IsFunction(ctx, v) != 0 {
                        JsValue::Function(JsFunction(JsRef { ctx, v }))
                    } else if JS_IsArrayBuffer(ctx, v) != 0 {
                        JsValue::ArrayBuffer(JsArrayBuffer(JsRef { ctx, v }))
                    } else if JS_IsArray(ctx, v) != 0 {
                        JsValue::Array(JsArray(JsRef { ctx, v }))
                    } else if JS_IsPromise(ctx, v) != 0 {
                        JsValue::Promise(JsPromise(JsRef { ctx, v }))
                    } else {
                        JsValue::Object(JsObject(JsRef { ctx, v }))
                    }
                }
                JS_TAG_JS_TAG_BOOL => JsValue::Bool(JS_ToBool(ctx, v) != 0),
                JS_TAG_JS_TAG_NULL => JsValue::Null,
                JS_TAG_JS_TAG_EXCEPTION => JsValue::Exception(JsException(JsRef { ctx, v })),
                JS_TAG_JS_TAG_UNDEFINED => JsValue::UnDefined,
                JS_TAG_JS_TAG_FUNCTION_BYTECODE => {
                    JsValue::FunctionByteCode(JsFunctionByteCode(JsRef { ctx, v }))
                }
                JS_TAG_JS_TAG_SYMBOL => JsValue::Symbol(JsRef { ctx, v }),
                _ => JsValue::Other(JsRef { ctx, v }),
            }
        }
    }

    fn get_qjs_value(&self) -> JSValue {
        unsafe {
            match self {
                // JS_NewInt32 dont need ctx
                JsValue::Int(v) => JS_NewInt32_real(std::ptr::null_mut(), *v),
                // JS_NewFloat64 dont need ctx
                JsValue::Float(v) => JS_NewFloat64_real(std::ptr::null_mut(), *v),
                JsValue::BigNum(JsBigNum(JsRef { v, .. })) => *v,
                JsValue::String(JsString(JsRef { v, .. })) => *v,
                JsValue::Module(JsModule(JsRef { v, .. })) => *v,
                JsValue::Object(JsObject(JsRef { v, .. })) => *v,
                JsValue::Array(JsArray(JsRef { v, .. })) => *v,
                JsValue::ArrayBuffer(JsArrayBuffer(JsRef { v, .. })) => *v,
                JsValue::Function(JsFunction(JsRef { v, .. })) => *v,
                JsValue::Promise(JsPromise(JsRef { v, .. })) => *v,
                JsValue::Bool(b) => JS_NewBool_real(std::ptr::null_mut(), if *b { 1 } else { 0 }),
                JsValue::Null => js_null(),
                JsValue::UnDefined => js_undefined(),
                JsValue::Exception(JsException(JsRef { v, .. })) => *v,
                JsValue::FunctionByteCode(JsFunctionByteCode(JsRef { v, .. })) => *v,
                JsValue::Other(JsRef { v, .. }) => *v,
                JsValue::Symbol(JsRef { v, .. }) => *v,
            }
        }
    }

    fn into_qjs_value(self) -> JSValue {
        let s = std::mem::ManuallyDrop::new(self);
        s.get_qjs_value()
    }
}

impl JsValue {
    pub fn get(&self, key: &str) -> Option<JsValue> {
        match &self {
            JsValue::Object(obj) => Some(obj.get(key)),
            JsValue::Function(obj) => Some(obj.get(key)),
            JsValue::Array(obj) => Some(obj.get(key)),
            _ => None,
        }
    }
    pub fn index(&self, index: usize) -> Option<JsValue> {
        if let JsValue::Array(arr) = self {
            Some(arr.take(index))
        } else {
            None
        }
    }
    pub fn is_exception(&self) -> bool {
        if let JsValue::Exception(_) = self {
            true
        } else {
            false
        }
    }
    pub fn invoke(&mut self, fn_name: &str, argv: &[JsValue]) -> Option<JsValue> {
        if let JsValue::Object(obj) = self {
            Some(obj.invoke(fn_name, argv))
        } else {
            None
        }
    }
    pub fn to_obj(self) -> Option<JsObject> {
        if let JsValue::Object(o) = self {
            Some(o)
        } else {
            None
        }
    }
    pub fn to_function(self) -> Option<JsFunction> {
        if let JsValue::Function(o) = self {
            Some(o)
        } else {
            None
        }
    }
    pub fn to_array(self) -> Option<JsArray> {
        if let JsValue::Array(o) = self {
            Some(o)
        } else {
            None
        }
    }
    pub fn to_string(self) -> Option<JsString> {
        if let JsValue::String(s) = self {
            Some(s)
        } else {
            None
        }
    }
}

impl From<i32> for JsValue {
    fn from(v: i32) -> Self {
        Self::Int(v)
    }
}

impl From<f64> for JsValue {
    fn from(v: f64) -> Self {
        Self::Float(v)
    }
}

impl From<JsBigNum> for JsValue {
    fn from(v: JsBigNum) -> Self {
        Self::BigNum(v)
    }
}

impl From<JsString> for JsValue {
    fn from(v: JsString) -> Self {
        Self::String(v)
    }
}

impl From<JsModule> for JsValue {
    fn from(v: JsModule) -> Self {
        Self::Module(v)
    }
}

impl From<JsObject> for JsValue {
    fn from(v: JsObject) -> Self {
        Self::Object(v)
    }
}

impl From<JsArray> for JsValue {
    fn from(v: JsArray) -> Self {
        Self::Array(v)
    }
}

impl From<JsPromise> for JsValue {
    fn from(v: JsPromise) -> Self {
        Self::Promise(v)
    }
}

impl From<JsArrayBuffer> for JsValue {
    fn from(v: JsArrayBuffer) -> Self {
        Self::ArrayBuffer(v)
    }
}

impl From<JsFunction> for JsValue {
    fn from(v: JsFunction) -> Self {
        Self::Function(v)
    }
}

impl From<bool> for JsValue {
    fn from(v: bool) -> Self {
        Self::Bool(v)
    }
}

impl From<JsException> for JsValue {
    fn from(v: JsException) -> Self {
        Self::Exception(v)
    }
}

impl From<JsFunctionByteCode> for JsValue {
    fn from(v: JsFunctionByteCode) -> Self {
        Self::FunctionByteCode(v)
    }
}

impl From<JsRef> for JsValue {
    fn from(v: JsRef) -> Self {
        Self::from_qjs_value(v.ctx, v.v)
    }
}

impl From<()> for JsValue {
    fn from(_: ()) -> Self {
        JsValue::Null
    }
}
"
example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt,"__background__
Chaudin
Bambalouni
Ghoriba
Mango sticky rice
Jianbing
Aguachile
Carrozza
Miyan kuka
Efo riro
Ayam masak merah
Chiffon pie
/g/11b8_rxx4d
Riso patate e cozze
Bazin
Black bottom pie
Palc soup
Sailor sandwich
Tuwo shinkafa
Carne a la tampiquea
Pastel azteca
Fujian red wine chicken
Boeber
Lady Baltimore cake
Yam khai dao
Texas Tommy
Har cheong gai
Kolokythopita
Karydopita
Rinflaj
Hainanese curry rice
Sonoran hot dog
/g/11cfty6q3
Afghani burger
Teochew porridge
Minestra di ceci
Pastrami on rye
Roast beef sandwich
Chahan
Ekuru
Sciusceddu
Breakfast burrito
/g/11dyjj24g
Sausage Stroganoff
Roti jala
Pirao
Casatiello
Khanom tan
Muamba chicken
Dobradinha
Bruckfleisch
Molote
Spongata
Funge
/g/1212ghsj
Kttbullar
Ka'ak
Papet vaudois
/g/12148tdg
Prosciutto di Norcia
Malloreddus
/g/1214g6v_
Pannenkoek
Dirty macaroni
/g/12175t2y
Garlic butter shrimp
Fricasse
Stracciatella
/g/121b74wr
Sart
Matelote
Baodu
Mattentaart
Cartellate
Gyeran-ppang
Torta Pasqualina
Caltabo
Khanom mo kaeng
Suimono
Dimlama
Tav Kosi
/g/121p63r3
/g/121slhcd
Kalach
Jambon persill
Pork Bones
Pozharsky cutlet
Roccoc
Feijo de leo de palma
Calulu
Bey's Soup
/g/1226mnbh
Tht kho tu
Bon bon chicken
Zoque
Bint al-sahn
Tempoyak
Puran poli
/g/122m40vc
Chueo-tang
Naem
/g/122qyvy7
/g/122rd60t
Pizokel
/g/122vxtxs
Schiacciata
Daheen
Chapssal-tteok
/g/123267k_
Crescentina modenese
Pansotti
Fried eggplant
Portuguese seafood rice
Tripes  la mode de Caen
/g/12353lp9
Brenebon
Gnocco fritto
/g/12384pzv
Tahu tek-tek
Bibikkan
Squid tongseng
/g/12fgs6199
Bundevara
Sop saudara
/g/155q8w2m
Erbazzone
Kisra
Meat from tiblica
/g/1hc0hhj4r
Yufka
Pisarei e fa
/g/1pznmr_ch
Pampushka
Makowiec
Saleeg
/m/0100fwt6
Jkai bean soup
Bookbinder soup
Selat solo
Kutsinta
Sago soup
Vinegret
Shrimp and grits
Sirop de Lige
Woku
Muhallebi
Gepuk
Foue
Octopus
Koba
B lc lc
Squid l'au
Shrimp Louie
Black pudding
Cherry kebab
Pitsi-pits
Sabich salad
Mie kocok
Maraca pie
Banga
Baccal alla lucana
Nasi tumpang
Gratin dauphinois
Arroz chaufa
Kuih
Ayam goreng
Chongos zamoranos
/m/011c708
Mmlig
Candied almonds
Lasagne
Pecel Lele
Lettuce soup
Acquacotta
Pork blood soup
/m/011sq8kg
Buridda
Maccu
Turkey Devonshire
Ginestrata
Garmugia
Meringue
Peanut butter and jelly sandwich
Couque de Dinant
Omo tuo
Thapthim krop
Pie tee
Sutarfeni
Raclette
Wotou
Punugulu
Succotash
Chim chum
Wachipa
Boat noodles
Tantuni
Shab Deg
Ch gi
Ciabatta Bacon Cheeseburger
Mie kangkung
Tuwo masara
Kokonte
Akple
/m/012vypzp
Kwareimal
Bento
Osechi
Okonomiyaki
Miso soup
Dango
Onigiri
Hiyayakko
Tempura
Mochi
Peppersoup
Caldo de queso
Dodo ikire
Uir
Hong dou tang
Kakigri
Khichu
Bolo de arroz
Chips and dip
Murgh musallam
Utica greens
Zaalouk
Mutton curry
Mughlai paratha
Tuo Zaafi
Bnh bt lc
/m/013f387h
Cheeseburger
Jelly bean
Apple pie
Udon
Falafel
Agedashi dfu
Dashi
Tortell
Omelette
Crme brle
Cucumber soup
French toast
Tripe
Pepperoni
Salami
Kimchi
Kndel
Takoyaki
Halva
Pigs in a blanket
Spanakopita
Pumpkin pie
Jambalaya
Club sandwich
Churro
Turducken
Welsh rarebit
Hot dog
Oyakodon
Meatball
Waldorf salad
Potato salad
Satay
Pemmican
Mmmi
Fideu
Waffle
Pancake
Quiche
Borscht
Bratwurst
Foie gras
Burrito
Goulash
Spotted dick
Coq au vin
Ratatouille
Cornbread
Souvlaki
Chow mein
Roast beef
Peking duck
Fried chicken
Croquembouche
Tahini
Gumbo
Fajita
Chicken fried steak
Sukiyaki
Scrapple
Chili con carne
Monte Cristo sandwich
Kielbasa
Polenta
Reuben sandwich
S'more
Andouille
Beignet
Crpe
Gulai
Breakfast sausage
Chorizo
Gyro
Nachos
Larb
Couscous
Meze
Cheesesteak
Frozen yogurt
Injera
Muesli
Meatloaf
Fuet
Natt
Banana split
Pczki
Pound cake
Fuqi feipian
Nasi lemak
Flan
Pad thai
Yakitori
Amanatt
Tom kha kai
Lokma
Mooncake
Idli
Sptzle
Nopalito
Sincronizada
ganci
Totopo
Folar
Cherry pie
Umeboshi
Patty
Saltah
Khinkali
Shkedei marak
Tekkadon
Chadachadi
Kaipen
Draw soup
Shahan ful
Shiro
Ga'at
Skordalia
Budae jjigae
Anju
Fried Coke
Lemang
Basundi
Brown Betty
Khabees
Kottu
Isterband
Ciauscolo
Khatkhate
Pan de muerto
Caponata
/m/0267f9w
Sabaayad
Miyeok-guk
Imoni
Pitha
Kedgeree
Bife a cavalo
Yaki udon
She-crab soup
Koozh
Kekek
Cabidela
Gerber sandwich
Zagorski trukli
Himbasha
Satara
Kakuni
Enormous Omelet Sandwich
Turrn
Tsukudani
Hawaiian haystack
Kateh
Stoemp
Pajeon
bejna
Kaya toast
Fit-fit
Kitcha
Thalipeeth
Figgy pudding
Cachupa
Cherries jubilee
Crappit heid
Mince and tatties
Anadama bread
Carbonara
Kladdkaka
Shakshouka
Chicken Vesuvio
Jibarito
Chicken Divan
Motsunabe
Sonofabitch stew
Corn pudding
Johnny Marzetti
Mostarda
Maafe
Churma
Chole bhature
Dobos torte
Carne de porco  alentejana
Khao soi
Kissel
Cottage loaf
Silver needle noodles
Shrimp DeJonghe
Kiritanpo
Bean pie
Churchkhela
Yahni
Gringas
Annin tofu
Jiaozi
Breakfast sandwich
Tanghulu
Black sesame soup
Gougre
Namul
Kosambari
Ma'amoul
Caldo de pollo
Loukaniko
Doberge cake
Nasi campur
Snack cake
Taiyaki
Karnyark
Pierogi
Macaroni and cheese
Huevos motuleos
Chislic
Corn dog
Shawarma
Zongzi
Dumpling
Syrniki
King cake
Souffl
Gydon
Chicken nugget
Bulgogi
Eggs Benedict
Hot dry noodles
Mashed potato
Anpan
Quesadilla
Youtiao
Congee
Sekihan
Semla
Arctic roll
Castella
Hanabiramochi
Falukorv
Ketupat
Rendang
Chocolate brownie
Mapo doufu
Chinese noodles
Empanada
Fried rice
Chicago-style pizza
Cuban sandwich
Tarte Tatin
Yakisoba
Dagwood sandwich
Cheesecake
Samosa
Devil's food cake
Shashlik
Horseshoe sandwich
City chicken
Key lime pie
Potato skins
Haejang-guk
Burmese tofu
Shumai
Sour cherry soup
Gigandes plaki
Majboos
Chicken curry
Shrimp Creole
Pork tenderloin sandwich
Dampfnudel
Finnan haddie
Kenkey
Pincho
Gundruk
Chilorio
Koulourakia
Bryndzov haluky
Imagawayaki
Vasilopita
Strapaky
Po' boy
Capirotada
Beef Manhattan
Sandwich loaf
Jian dui
Almond biscuit
West Slavic fermented cereal soups
Fried plantain
Stuffed peppers
Piperade
Rogan josh
Fabada asturiana
Potato wedges
Calisson
Prawn ball
Kushikatsu
Lo mai chi
Manchet
Leek soup
Vanillerostbraten
Hangtown fry
Cabbie claw
Chitranna
Ragi mudde
Denver sandwich
Laverbread
Elote
Kulolo
Oxtail soup
Pantua
Corn relish
Pogaa
Qubani-ka-Meetha
Boondi
Arrosticini
Panelle
Santula
Tofu skin roll
Crispy fried chicken
Steamed meatball
Lobio
Suman
Ht
Matbukha
/m/02rgjs1
Aorda
Makdous
Soto
Frangollo
Patty melt
Taro dumpling
Entomatada
Bnh cun
Corunda
Zhaliang
Cassoulet
Debrecener
Scampi
Pilaf
Sambar
Century egg
Escargot
Cong you bing
Beef noodle soup
Magiritsa
Gugelhupf
Sachima
White rice
Maultasche
American chop suey
Fish slice
Sea cucumber
Beef ball
Siu yuk
Seafood birdsnest
White cut chicken
/m/02vwryj
Satsivi
Malpua
Chhena gaja
Flying Jacob
Steak de Burgo
Crab Louie
Butter chicken
Amok trey
Menemen
Piadina
Orange cuttlefish
Fudge
Cottage Pudding
Meatcake
Buttermilk pie
Kalamay
Puto
Dal makhani
Mixiote
Bagel dog
Bn riu
Feijoada
Pho
Milk toast
Liver and onions
Iced bun
Sheer khurma
Yi mein
Shrimp roe noodles
Lai fun
Oil noodles
Kal-guksu
Youmian
Avgolemono
Pork roll
Tart
Leberkse
Kalakukko
Mustamakkara
Baba ghanoush
Karelian pasty
Shortcake
Profiterole
Moussaka
Dulce de leche
Blaa
Risotto
Funnel cake
Fried dough
Consomm
Clam chowder
Tartiflette
Red curry
Tandoori chicken
Gazpacho
Prosciutto
Boerewors
Baked potato
Bouillabaisse
Kralan
Chireta
Bakewell tart
Grits
Shaved ice
Choco pie
Cumian
Jokbal
Grillades
Hotteok
Ezogelin soup
Knedle
Masgouf
Sope
Coconut rice
Bakarkhani
Asida
Dirt cake
Sel roti
Kalakand
Ghevar
Sussex pond pudding
Lontong
Bnh bo
Pring
Bull roast
Stuffed ham
Lablabi
Gooey butter cake
Carciofi alla giudia
Yin si juan
Babi panggang
Chao hong guo
Fun guo
Khira sagara
Coconut bar
Sundae
Tuna fish sandwich
Zhangcha duck
Marry girl cake
Frijoles charros
Rosca de reyes
Happy Faces
Deviled crab
Sundubu-jjigae
Sinseollo
Dongchimi
Nabak-kimchi
Dhondas
Soan papdi
Baek-kimchi
Chicken riggies
Afelia
Gulysleves
Marie biscuit
Caf ligeois
Ch
Pootharekulu
Escalope
Rajma
Beshbarmak
Torta Tre Monti
French dip
Pumpkin-coconut custard
Rose hip soup
Veggie burger
Steak tartare
Bologna sausage
Pt
Bibimbap
Shahi paneer
Fufu
Pyttipanna
Chicken sandwich
Ghari
Michigan salad
Cabinet pudding
American fried rice
Korovai
Churrasco
Pasulj
Mitraillette
Salat de boeuf
Rice pudding
Rsti
Naryn
Kaldereta
Makroudh
Kachumbari
Tsukemono
Cheese fries
Slatko
Qatayef
Passatelli
Sweet potato soup
Shchi
Kulfi
Dolma
Kai yang
Shark fin soup
Pozole
Pakora
Chantilly cake
Krwki
Russian tea cake
Ox-tongue pastry
Sachertorte
Palitaw
Jolpan
Mantou
Finger steaks
Steak sandwich
Talo
Erkuai
Mixian
St. Louis-style pizza
Moambe
Upma
Panjiri
Eggs Sardou
Shanghai fried noodles
Quarkkulchen
Cupcake
Snickerdoodle
Farl
Coleslaw
Calas
Beef Stroganoff
Shimotsukare
Squab
Basbousa
Watalappam
Tepsi baytinijan
Kuli-kuli
Shabu-shabu
Sundae
Fried brain sandwich
Rollmops
Higashi
Panna cotta
Aloo gobi
Aspic
Obatzda
Gulab jamun
Tuna casserole
Ribollita
Chomchom
Rassolnik
Jeongol
Cantonese seafood soup
Eggplant Salad
Krtskalcs
Plsa
Lobster roll
Sloppy joe
Schnitzel
Bacalhau
Sfenj
Menudo
Gujia
Liver soup
Panocha
Chakapuli
Sklandrausis
Liver pt
Rulleplse
Frikadeller
Frikandel
Cinnamon roll
Scotch pie
Hot wiener
Wodzionka
Greek salad
Raita
Dong'an chicken
Boortsog
Coca
Champon
Tabbouleh
Korokke
Chile relleno
Brandade
Hoppang
Gozinaki
Lazarakia
Puff Puff
Fatteh
Speculaas
Karasumi
Brandy snaps
Trdelnk
Cocido madrileo
Red velvet cake
Kringle
Quenelle
Toasted ravioli
Tajine
Cranachan
Rusk
Mille-feuille
Acorn noodle soup
Gachas
Jingisukan
Thekua
Ghugni
Tarama
Italian beef
Challah
Fried ice cream
Onion ring
Smoked meat
Dahi vada
Mother-in-law
Blondie
Guk
Hiyashi chka
Sweet shells
Salisbury steak
Poffertjes
Eggs Neptune
Galbi-jjim
Agwi-jjim
Ladob
Instant-boiled mutton
Cincalok
Jook-sing noodles
Potbrood
Burkinabe cuisine
Taralli
Carbonade flamande
Xi
Sauerbraten
Spiedie
Gimbap
Czernina
Kroppkaka
Buddha's delight
Pain au chocolat
Goetta
German chocolate cake
Melt sandwich
Popiah
Haleem
Hornazo
Janchi-guksu
Kipper
Bossam
Arbroath smokie
Bologna sandwich
Cobbler
Kouign-amann
Char kway teow
Rostbrtel
Doenjang-jjigae
Tharid
Hainanese chicken rice
Bak kut teh
Cabbage roll
Runza
Bananas Foster
Kozhukkatta
Kiukai
Smrrebrd
Kutia
Deviled egg
Buchteln
Apple strudel
Wonton
Chess pie
Pirozhki
Douzhi
Macaroni soup
Crossing-the-bridge noodles
Lechazo
Rolled oyster
Asam pedas
Mi krop
Patoleo
Rig Jancsi
Ollada
Garbure
Sabudana Khichadi
Pote
Phanaeng curry
Madeleine
Mashed pumpkin
Suet pudding
Bombay mix
Namagashi
Struffoli
Dak-galbi
Chuchvara
Misal
Patatnik
Yuxiang
Frozen banana
Psarosoupa
Mekitsa
Sanna
Qaz
Sorbetes
Potatoes O'Brien
Tom yum
Balushahi
Arroz a la cubana
Jalebi
Sopaipilla
Ukha
Svkov
Trs csusza
Pinnekjtt
Salty liquorice
Lemon ice box pie
Knickerbocker glory
Zhajiangmian
Cobb salad
Misua
Shoofly pie
Bhakri
Apple cake
Orange chicken
Jamn serrano
Bundt cake
Bara brith
Hot pot
Kung Pao chicken
Mulukhiyah
Piti
Double ka meetha
Choila
Moustalevria
Arizona cheese crisp
Rice Krispies Treats
Liangpi
Prinskorv
Salmorejo
Chicken Franaise
Flskkorv
Glorified rice
/m/04zzsvg
Stinky tofu
Muffuletta
Soy sauce chicken
Chicken fingers
Pecan pie
Eba
Parfait
Ndol
Cheese sandwich
Carne de vinha d'alhos
Bob Andy pie
Cincinnati chili
Frico
Tapioca pudding
Minestrone
Boxty
Naengmyeon
Seven-layer salad
/m/0553tg
Cawl
Chocolate pudding
Hotdish
Ciccioli
Douhua
Berliner
Fried fish
Apple crisp
Boudin
Yusheng
Babka
Pizzoccheri
Welsh cake
Parker House roll
Tripe soup
Chimichanga
Jucy Lucy
Dodger Dog
Pastiera
Huarache
Solkadhi
Schupfnudel
Waldorf pudding
Harees
Ash reshteh
Celery Victor
Diples
Kompot
French onion soup
Tres leches cake
Torta caprese
Black Forest gateau
Pt aux pommes de terre
Lpa
Bndner Nusstorte
Hachee
Spaghetti aglio e olio
Whoopie pie
Ais kacang
Chermoula
Gado-gado
Merguez
Snickers salad
Giouvetsi
Kharcho
Chicken fried bacon
Dessert bar
Coulibiac
Thieboudienne
Rabri
Sapin-sapin
Sealed crustless sandwich
Carne asada
Coyotas
Chocolate-covered bacon
Stroopwafel
Gravlax
Pot pie
Ghormeh sabzi
Surf and turf
Brunswick stew
Mititei
Fluffernutter
Khaja
Stottie cake
London broil
Fasolada
Strudel
llebrd
Tamago kake gohan
Hot water corn bread
Philippine adobo
Hulatang
Dyrlgens natmad
Chistorra
Polkagris
Galbi-tang
Mrouzia
Gopchang-jeongol
Miang kham
Clams casino
Nanbanzuke
Dripping cake
Cookie salad
Usal
Mandu-guk
Smalahove
Kokis
Ori-tang
Pakhala
Cream pie
Butajiru
New England boiled dinner
Chhena jalebi
Pastitsio
Panucho
Chhena kheeri
Kifli
Solyanka
Sadhya
Cullen skink
Havregrynskugle
Harira
Cornish game hen
Beef on weck
Tompouce
Caldo de siete mares
Millionbf
Chicago-style hot dog
Risalamande
Alinazik kebab
Medisterplse
Sarson da saag
Liangfen
Pistolette
Steamed clams
Ulam
Kheer
Tlacoyo
Tarator
/m/061ptq
/m/062p8x
Cochinita pibil
Buddha Jumps Over the Wall
Sfouf
Ham and cheese sandwich
""""""Peanut butter""
""""""Bacon""
Chicken karahi
Maple bacon donut
Litti
Nam Khao
Nam tok
Baozi
Kibbeh
Kushari
Jiuniang
/m/06603bl
Machher Jhol
Fahsa
Mysore pak
Chalupa
Swiss roll
Balkenbrij
Tortas de aceite
Popover
Falooda
Macaroni salad
Barbacoa
Hushpuppy
Luther Burger
Ragout
Bnh bao
Moronga
Hayashi rice
Zrcher Geschnetzeltes
clair
Colcannon
Bear claw
Francesinha
Wat
Loco moco
Hot milk cake
Hoe
Gordita
Macaron
Pepperoni roll
Rasgulla
Angel wings
Huevos rancheros
Caprese salad
Kombdi vade
Yong tau foo
Chai tow kway
Machaca
Ugali
Arrs negre
Kimchi fried rice
Frybread
Halo-halo
Shiokara
Janssons frestelse
Hot Brown
Torta
evapi
Salt water taffy
lbr
Murtabak
Tahu goreng
Soto ayam
Mee siam
Submarine sandwich
Haluky
Kimchi-jjigae
Fish ball
Blodpalt
Lebanon bologna
Okroshka
Linzer torte
Shrikhand
Yakiniku
Huevos divorciados
Nihari
Sauted reindeer
Hasty pudding
Mission burrito
Sweet and sour pork
Rdgrd
Booyah
Bienenstich
Dressed herring
New York-style pizza
Bistek
Sinigang
Fios de ovos
Vitello tonnato
Bisque
/m/06w9wv4
Modak
New Haven-style pizza
California-style pizza
Wrap
Puri
Jamn
Khash
Beef bourguignon
Truffade
B nng l lt
Ful medames
Aligot
Kolach
Guaiwei
Kesme
Funeral potatoes
Sushi
Arancini
Creamed corn
Mozzarella sticks
American goulash
Gofio
Soup alla Canavese
Red beans and rice
Rssypottu
Flskpannkaka
Hyderabadi biryani
Baeckeoffe
Eton mess
Khachapuri
Banoffee pie
Ants climbing a tree
Dandan noodles
Suanla chaoshou
Samgye-tang
Spam musubi
Bridie
Kaju katli
Chocolate-covered potato chips
Enne gai
Ruske kape
Spaghetti
Grass jelly
Salt potatoes
Katsudon
Pasanda
Banitsa
Flammekueche
Twice-cooked pork
Kare-kare
Laobing
Banmian
Honey cake
Swiss wing
Michigan hot dog
Tong sui
Taco
Sosatie
Pap
Umngqusho
Malva pudding
Vichyssoise
Zni
Maxwell Street Polish
Vetkoek
Mealie bread
Chakalaka
Frikkadel
/m/07fr1x
Tteokguk
Coney Island hot dog
Tirokafteri
Fesikh
Boston cream pie
Buttermilk koldskl
White boiled shrimp
Bagnun
Buntil
/m/07l949
Pisto
Dhokla
Al pastor
St. Paul sandwich
Melonpan
Haupia
Lngos
touffe
Galaktoboureko
Brek
Suya
Rye bread
Escudella i carn d'olla
Gari
Tilkut
Botok
Tatws Pum Munud
Char siu
Burgoo
Cack
Barfi
Mulligan stew
Biangbiang noodles
Banana pudding
Crab cake
Chinese sausage
Veal
Curry bread
Pastry heart
Crme caramel
Panada
Pie  la Mode
Bonus Jack
Princess cake
Harihari-nabe
Hot chicken
Chhena Jhili
Grape pie
Chicken bog
Sausage gravy
Derby pie
Ice cream cake
Swiss steak
/m/083tx9
Stack cake
Lobster Newberg
Nikujaga
Manti
Parmigiana
Palatschinke
Gujeolpan
Rajas con crema
Mak-guksu
Tetrazzini
Squid
Palak paneer
Krumkake
Bolani
Pork and beans
Nian gao
Oysters Rockefeller
Tave grave
Bakkwa
Xacuti
Sarapatel
Taquito
Egg drop soup
Shaobing
Chawanmushi
Nshima/Nsima
Pollock roe
Slinger
Japchae
St. Honor cake
Barm cake
Tulumba
Xiaolongbao
Delmonico steak
Stromboli
Kanafeh
Hamdog
Garri
Kofta
Chana masala
Salo
Lung fung soup
Dirty rice
Urnebes
Andouillette
Landjger
Fisherman's soup
Romeritos
Lane cake
Pork jelly
Idiyappam
Smrgstrta
Smaen sr
Arroz con pollo
/m/08xmsn
Petit gteau
Tea egg
Cocada amarela
Japanese curry
Qeema
Unagi
Hoppin' John
Gyhi
Clafoutis
Green curry
Gi cun
Chilli crab
Lo mai gai
Lo mein
Puttu
Fried pie
Spanish rice
Nuea phat phrik
Jeow bong
Massaman curry
Ostkaka
Guilinggao
Spettekaka
Cudighi
Saltimbocca
Sfogliatella
Beef chow fun
Chow mein sandwich
Carnitas
Chinese steamed eggs
Oyster omelette
Garden salad
Salade nioise
Dal bhat
Biscuits and gravy
Omurice
Pao cai
Nasi liwet
Thai suki
Moo shu pork
Corn crab soup
Fabes con almejas
Golden Opulence Sundae
Ketoprak
Mala Mogodu
Tekwan
Vatrushka
Yin Yang fish
Boston cream doughnut
Ramen
Home fries
Mustacciuoli
Clam cake
Sarma
Shahe fen
Charleston red rice
Fish head curry
Podvarak
Pihtije
Popara
Kaamak
Seolleongtang
Gobki
Szaloncukor
Kalduny
Zrazy
Panettone
Ambelopoulia
Persimmon pudding
Floating island
Zeeuwse bolus
Ambuyat
Smulpaj
Moravian spice cookies
Mee pok
Jjigae
Pizza bagel
Tteok
Brndende krlighed
Beaten biscuit
bleflsk
Chicken paprikash
Tangyuan
Tuna pot
Burnt ends
Jamn ibrico
Rakfisk
Zarangollo
Tr Rudi
Flummery
Cecina
Galinha  portuguesa
Ankimo
Galinha  africana
Cha siu bao
Fugu chiri
Assidat Zgougou
Oxtail stew
Laping
Chaku
Caldillo de perro
Sopa de Gato
Keledo
Mcver
Brotzeit
Shekerbura
Oeufs en meurette
Pappa al pomodoro
Teurgoule
Bnh xo
Musakhan
Maqluba
Bob chorba
Rum baba
Veda bread
Fried shrimp
Pastilla
Strawberry delight
Cheese dream
Frejon
Gyeran-jjim
Revithia
Nasi bogana
Torta de gazpacho
Double Down
Seri Muka
Obi non
Garganelli
Kig ha farz
Mississippi mud pie
Eve's pudding
Amala
Okinawa soba
Lamian
Soki
Chicken Maryland
Chanpur
Mlinci
Smyrna meatballs
Tavern sandwich
Yangzhou fried rice
Qutab
Dum Aloo
Queijo do Pico
Cocada
Calf's liver and bacon
Moules-frites
Anarsa
Tlayuda
akotis
Jollof rice
Moin moin
Jam roly-poly
Hochzeitssuppe
Mucenici
Ema datshi
Ngo hiang
Jello salad
Claypot chicken rice
Maeun-tang
Cifantuan
Rhubarb pie
Olla podrida
Har gow
Sayur lodeh
Memela
Wenchang chicken
Galinhada
Lecs
Gypsy tart
Bougatsa
Germkndel
Haystack
Yule log
Butter cookie
Chicken  la King
Mchoui
Croquette
Shami kebab
Chicken and waffles
Poke
Punsch-roll
Turtle soup
Kansar
Glamorgan sausage
Mango pudding
Bnh canh
Caparrones
Zopf
Bath bun
Chelsea bun
London bun
Saffron bun
Chakhchoukha
Angel food cake
Lalab
Suckling pig
Barmbrack
Kotlet schabowy
Pastel de nata
Shave ice
Tipsy cake
Creamed eggs on toast
Kerak telor
Ogok-bap
Mortadella
Nut roll
Fried green tomatoes
Beondegi
Tsoureki
Tiropita
Pljeskavica
Karaoreva nicla
Kokoretsi
Skilpadjies
Corn chowder
Tarhana
Tufahije
Birria
Veal Orloff
Fattoush
Pane carasau
Rab cake
Buffalo burger
Treacle tart
Hamburger
Stamppot
Kopytka
Khai yat sai
Minchee
Kinema
Sgabeo
Chili dog
Spaghetti alle vongole
Bavarian cream
Bhaji
Kachori
Chowder
Scotch broth
Pea soup
Kitfo
Gored gored
Bnh chng
Bn b Hu
B 7 mn
Cm tm
Ambrosia
Rnttnen
Balcho
Gibassier
Bacalhau  Z do Pipo
Pane di Altamura
Mykyrokka
Paska
Blackberry pie
Mince pie
Corn cookie
Francesinha poveira
Picadillo
Runeberg torte
Khakhra
Ohn no khao sw
Sultsina
/m/0crv0m
Paella
Espetada
Pathiri
Horumonyaki
Khubz
Ciorb
Kimchi-buchimgae
Sesame chicken
Thukpa
Chwinamul
Kabuni
Jhunka
Jolada rotti
Spoonbread
Kulich
Phat khing
Namasu
Wonton noodles
Johnnycake
Panellets
Manj
Mandi
Fortune cookie
Noppe
Slavink
Cockle bread
Caruru
Ch la
Pan bagnat
Sardenara
Enchilada
Sausage sandwich
Pistachio pudding
Chikki
Champorado
Coconut cake
Kaassouffl
Carne pizzaiola
Khauk sw thoke
Gamja-tang
Kadhi
Green bean casserole
Apple dumpling
Cozonac
Pissaladire
Phat si-io
Drunken noodles
Jing Jiang Rou Si
Enduri Pitha
Kakara pitha
Tarta de Santiago
/m/0dn9nd
Sheftalia
Soybean sprout
Italian hot dog
Makchang
Meeshay
Bacalhau com natas
Mazurek
Nan gyi thohk
Ajapsandali
Carac
Mont di
Geng
Vispipuuro
Bakso
Canjica
Fougasse
Fool's Gold Loaf
Blueberry pie
Pickled cucumber
Ogbono soup
Champ
Oysters en brochette
Paskha
Shish taouk
Acaraj
Ras malai
San-nakji
Bungeo-ppang
Skilandis
Gosh-e Fil
Nasi dagang
Gheimeh
Fesenjn
Bacalhau  Gomes de S
Frikl
Bedfordshire clanger
Tonkatsu
Thai fried rice
Manakish
Schweinshaxe
Chorba
Oliebol
Ropa vieja
Natchitoches meat pie
Icebox cake
Sorrel soup
Lahoh
Bolillo
Mollete
Caldeirada
Ogi
Watergate salad
Yaksik
Half-smoke
Dakos
Sweet potato pie
Cappon magro
Serundeng
Rijstevlaai
Ajoblanco
Yaka mein
Jujeh kabab
Soy egg
Shuizhu
Puliyogare
Sago
Laulau
Curtido
Tapai
Press cake
Cuchifritos
Vlaai
Malvern pudding
Baklava
Cheese dog
Luchi
Cowboy beans
Sandesh
Steak Diane
Lobster stew
Finikia
Bibingka
Tafelspitz
Ploye
Sayur asem
Trinxat
Nikuman
Cozido  portuguesa
Bacalhau  Brs
Tomato compote
Sesame seed candy
Dhebra
Kaeng pa
Mas riha
Zosui
Yassa
Pambazo
Imarti
Bacalhau com todos
Black pepper crab
Queso flameado
Black and white cookie
Red braised pork belly
Krofne
Utipci
Roata
Punjena paprika
Fusi
Manetra
Krotule
Fritule
Protein bar
Cordon bleu
Pirog
Pachi Pulusu
Frigrui
Chhena poda
Poornalu
Ponganalu
Bing
Flaouna
Chakodi
Aloo paratha
Konro
Cemita
Asinan
Broa
Trifle
Rat na
Borlengo
Gazpachuelo
Esterhzy torte
Magenbrot
Detroit-style pizza
Fuling jiabing
Lakhamari
Mukalica
Sukhdi
Kilishi
Baji
Peanut butter cookie
Rabbit pie
Paling in 't groen
Chataamari
Lawar
Arisa Pitha
Empal gentong
Carne asada fries
Takikomi gohan
Kamameshi
Pasta salad
Fasole cu crnai
Zelnik
Plcint
Tongseng
Soto mie
Sarburma
Lutefisk
Khichdi
Briouat
Chili burger
Bolo de mel
Clootie
Seswaa
Tahu sumedang
Pichelsteiner
Bread soup
Scotcheroos
Kartoffelkse
Schuxen
Caramel
Zwetschgenkuchen
Alloco
Vangibath
Torricado
Phat phrik khing
Tomato and egg soup
/m/0h65ym4
Spanakorizo
Ostropel
Tamale
Seattle-style hot dog
Ammonia cookie
Boston baked beans
Amandine
Duck blood and vermicelli soup
Azerbaijani pakhlava
Bakwan
Wallenbergare
Pastry
Melomakarono
Cocido lebaniego
Koi
Stir-fried tomato and scrambled eggs
Flskesteg
Beggar's Chicken
/m/0hzpvf0
Konkonte
Stuffed squash
Kaeng som
Kentucky jam cake
Murturi
Tochitur
Urap
Cornulee
Quad City-style pizza
Paneer tikka
Ciorb de perioare
/m/0j66841
Shaker lemon pie
Doodhpak
Ceviche
Cabbage soup
Nasi timbel
Pa amb tomquet
Escalivada
Meimurska gibanica
Khanom chan
Ohaw
Baghrir
Hummingbird cake
Neapolitan pizza
Doughnut
Hummus
Nimono
Chocolate chip cookie
Bn c
Cheese straw
Sausage
Frogeye salad
Senate bean soup
Botifarra
Leberkndel
Laziji
Quzi
Chazuke
Sandwich
BLT
Chikhirtma
Pico de gallo
Oden
Tostada
Chilaquiles
Cocido montas
Lontong Cap Go Meh
Porra antequerana
Kedjenou
Tourin
Attik
Dak-bokkeum-tang
emlovka
Dovga
Rice and gravy
Sai ua
Nam ngiao
Kaeng khae
Kaeng tai pla
Dim sum
Tahri
Bolo do caco
Buffalo wing
Pustakari
Pieds paquets
Tinginys
Sunnundallu
Lapskaus
Caldo tlalpeo
Milho frito
Kalu dodol
Poppyseed muffin
Peanut soup
Tarte  la Bouillie
Caldo gallego
Samay Baji
Limburger sandwich
Huachinango a la Veracruzana
Sambal stingray
Kuluban
Modjeska
Pan dulce
Florina pepper
Oysters Bienville
Cronut
Duck rice
Sulu kfte
Toyga soup
Majjige huli
Ikan goreng
Lekor
Ciulama
Ayam bakar
Hinava
Waakye
Salbute
Kuchmachi
Kibinai
Lobiani
Chanakhi
Baghali ghatogh
Pkhali
Poc Chuc
Bionico
Bamischijf
Racuchy
Kuurdak
Hokkien fried rice
Mu kratha
Thong yip
Zuppa toscana
Dhindo
Thiakry
Kondowole"
modules/internal/fs/utils.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
""use strict"";

import { Buffer } from ""../../buffer"";
import {
  ERR_FS_EISDIR,
  ERR_FS_INVALID_SYMLINK_TYPE,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
  ERR_OUT_OF_RANGE,
  hideStackFrames,
  uvException,
} from ""../errors"";

import {
  isArrayBufferView,
  isBigUint64Array,
  isDate,
  isUint8Array,
} from ""../util/types"";
import { deprecate, once } from ""../util"";
import { toPathIfFileURL } from ""../url"";
import {
  validateAbortSignal,
  validateBoolean,
  validateFunction,
  validateInt32,
  validateInteger,
  validateObject,
  validateUint32,
} from ""../validators"";
import * as pathModule from ""../../path"";
const kType = Symbol(""type"");
const kStats = Symbol(""stats"");
import { assert } from ""../assert"";
import { lstat, lstatSync } from ""../fs"";
import { stat, statSync } from ""../fs"";
const isWindows = false;
import * as process from ""../../process"";

import {
  fs as fsConstants,
  os as osConstants,
} from ""../../internal_binding/constants"";

import * as errors from ""../errors""

const {
  F_OK = 0,
  W_OK = 0,
  R_OK = 0,
  X_OK = 0,
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
  O_APPEND,
  O_CREAT,
  O_EXCL,
  O_RDONLY,
  O_RDWR,
  O_SYNC,
  O_TRUNC,
  O_WRONLY,
  S_IFBLK,
  S_IFCHR,
  S_IFDIR,
  S_IFIFO,
  S_IFLNK,
  S_IFMT,
  S_IFREG,
  S_IFSOCK,
  UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION,
  UV_DIRENT_UNKNOWN,
  UV_DIRENT_FILE,
  UV_DIRENT_DIR,
  UV_DIRENT_LINK,
  UV_DIRENT_FIFO,
  UV_DIRENT_SOCKET,
  UV_DIRENT_CHAR,
  UV_DIRENT_BLOCK,
} = fsConstants;
const {
  errno: {
    EISDIR,
  },
} = osConstants;

// The access modes can be any of F_OK, R_OK, W_OK or X_OK. Some might not be
// available on specific systems. They can be used in combination as well
// (F_OK | R_OK | W_OK | X_OK).
const kMinimumAccessMode = Math.min(F_OK, W_OK, R_OK, X_OK);
const kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;

const kDefaultCopyMode = 0;
// The copy modes can be any of COPYFILE_EXCL, COPYFILE_FICLONE or
// COPYFILE_FICLONE_FORCE. They can be used in combination as well
// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).
const kMinimumCopyMode = Math.min(
  kDefaultCopyMode,
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
);
const kMaximumCopyMode = COPYFILE_EXCL |
  COPYFILE_FICLONE |
  COPYFILE_FICLONE_FORCE;

// Most platforms don't allow reads or writes >= 2 GB.
// See https://github.com/libuv/libuv/pull/1501.
const kIoMaxLength = 2 ** 31 - 1;

// Use 64kb in case the file type is not a regular file and thus do not know the
// actual file size. Increasing the value further results in more frequent over
// allocation for small files and consumes CPU time and memory that should be
// used else wise.
// Use up to 512kb per read otherwise to partition reading big files to prevent
// blocking other threads in case the available threads are all in use.
const kReadFileUnknownBufferLength = 64 * 1024;
const kReadFileBufferLength = 512 * 1024;

const kWriteFileMaxChunkSize = 512 * 1024;

export const kMaxUserId = 2 ** 32 - 1;

export function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    const reason = ""is invalid encoding"";
    throw new ERR_INVALID_ARG_VALUE(encoding, ""encoding"", reason);
  }
}

export class Dirent {
  constructor(name, type) {
    this.name = name;
    this[kType] = type;
  }

  isDirectory() {
    return this[kType] === UV_DIRENT_DIR;
  }

  isFile() {
    return this[kType] === UV_DIRENT_FILE;
  }

  isBlockDevice() {
    return this[kType] === UV_DIRENT_BLOCK;
  }

  isCharacterDevice() {
    return this[kType] === UV_DIRENT_CHAR;
  }

  isSymbolicLink() {
    return this[kType] === UV_DIRENT_LINK;
  }

  isFIFO() {
    return this[kType] === UV_DIRENT_FIFO;
  }

  isSocket() {
    return this[kType] === UV_DIRENT_SOCKET;
  }
}

class DirentFromStats extends Dirent {
  constructor(name, stats) {
    super(name, null);
    this[kStats] = stats;
  }
}

for (const name of Reflect.ownKeys(Dirent.prototype)) {
  if (name === ""constructor"") {
    continue;
  }
  DirentFromStats.prototype[name] = function () {
    return this[kStats][name]();
  };
}

export function copyObject(source) {
  const target = {};
  for (const key in source) {
    target[key] = source[key];
  }
  return target;
}

const bufferSep = Buffer.from(pathModule.sep ?? '/');

function join(path, name) {
  if (
    (typeof path === ""string"" || isUint8Array(path)) &&
    name === undefined
  ) {
    return path;
  }

  if (typeof path === ""string"" && isUint8Array(name)) {
    const pathBuffer = Buffer.from(pathModule.join(path, pathModule.sep));
    return Buffer.concat([pathBuffer, name]);
  }

  if (typeof path === ""string"" && typeof name === ""string"") {
    return pathModule.join(path, name);
  }

  if (isUint8Array(path) && isUint8Array(name)) {
    return Buffer.concat([path, bufferSep, name]);
  }

  throw new ERR_INVALID_ARG_TYPE(
    ""path"",
    [""string"", ""Buffer""],
    path,
  );
}

export function getDirents(path, { 0: names, 1: types }, callback) {
  let i;
  if (typeof callback === ""function"") {
    const len = names.length;
    let toFinish = 0;
    callback = once(callback);
    for (i = 0; i < len; i++) {
      const type = types[i];
      if (type === UV_DIRENT_UNKNOWN) {
        const name = names[i];
        const idx = i;
        toFinish++;
        let filepath;
        try {
          filepath = join(path, name);
        } catch (err) {
          callback(err);
          return;
        }
        lstat(filepath, (err, stats) => {
          if (err) {
            callback(err);
            return;
          }
          names[idx] = new DirentFromStats(name, stats);
          if (--toFinish === 0) {
            callback(null, names);
          }
        });
      } else {
        names[i] = new Dirent(names[i], types[i]);
      }
    }
    if (toFinish === 0) {
      callback(null, names);
    }
  } else {
    const len = names.length;
    for (i = 0; i < len; i++) {
      names[i] = getDirent(path, names[i], types[i]);
    }
    return names;
  }
}

export function getDirent(path, name, type, callback) {
  if (typeof callback === ""function"") {
    if (type === UV_DIRENT_UNKNOWN) {
      let filepath;
      try {
        filepath = join(path, name);
      } catch (err) {
        callback(err);
        return;
      }
      lstat(filepath, (err, stats) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, new DirentFromStats(name, stats));
      });
    } else {
      callback(null, new Dirent(name, type));
    }
  } else if (type === UV_DIRENT_UNKNOWN) {
    const stats = lstatSync(join(path, name));
    return new DirentFromStats(name, stats);
  } else {
    return new Dirent(name, type);
  }
}

export function getOptions(options, defaultOptions) {
  if (
    options === null || options === undefined ||
    typeof options === ""function""
  ) {
    return defaultOptions;
  }

  if (typeof options === ""string"") {
    defaultOptions = { ...defaultOptions };
    defaultOptions.encoding = options;
    options = defaultOptions;
  } else if (typeof options !== ""object"") {
    throw new ERR_INVALID_ARG_TYPE(""options"", [""string"", ""Object""], options);
  }

  if (options.encoding !== ""buffer"") {
    assertEncoding(options.encoding);
  }

  if (options.signal !== undefined) {
    validateAbortSignal(options.signal, ""options.signal"");
  }
  return options;
}

/**
 * @param {InternalFSBinding.FSSyncContext} ctx
 */
export function handleErrorFromBinding(ctx) {
  if (ctx.errno !== undefined) { // libuv error numbers
    const err = uvException(ctx);
    Error.captureStackTrace(err, handleErrorFromBinding);
    throw err;
  }
  if (ctx.error !== undefined) { // Errors created in C++ land.
    // TODO(joyeecheung): currently, ctx.error are encoding errors
    // usually caused by memory problems. We need to figure out proper error
    // code(s) for this.
    Error.captureStackTrace(ctx.error, handleErrorFromBinding);
    throw ctx.error;
  }
}

// Check if the path contains null types if it is a string nor Uint8Array,
// otherwise return silently.
export const nullCheck = hideStackFrames(
  (path, propName, throwError = true) => {
    const pathIsString = typeof path === ""string"";
    const pathIsUint8Array = isUint8Array(path);

    // We can only perform meaningful checks on strings and Uint8Arrays.
    if (
      (!pathIsString && !pathIsUint8Array) ||
      (pathIsString && !path.includes(""\u0000"")) ||
      (pathIsUint8Array && !path.includes(0))
    ) {
      return;
    }

    const err = new ERR_INVALID_ARG_VALUE(
      propName,
      path,
      ""must be a string or Uint8Array without null bytes"",
    );
    if (throwError) {
      throw err;
    }
    return err;
  },
);

export function preprocessSymlinkDestination(path, type, linkPath) {
  if (!isWindows) {
    // No preprocessing is needed on Unix.
    return path;
  }
  path = """" + path;
  if (type === ""junction"") {
    // Junctions paths need to be absolute and \\?\-prefixed.
    // A relative target is relative to the link's parent directory.
    path = pathModule.resolve(linkPath, "".."", path);
    return pathModule.toNamespacedPath(path);
  }
  if (pathModule.isAbsolute(path)) {
    // If the path is absolute, use the \\?\-prefix to enable long filenames
    return pathModule.toNamespacedPath(path);
  }
  // Windows symlinks don't tolerate forward slashes.
  return path.replace(/\//g, ""\\"");
}

// Constructor for file stats.
function StatsBase(
  dev,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  blksize,
  ino,
  size,
  blocks,
) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
}

StatsBase.prototype.isDirectory = function () {
  return this._checkModeProperty(S_IFDIR);
};

StatsBase.prototype.isFile = function () {
  return this._checkModeProperty(S_IFREG);
};

StatsBase.prototype.isBlockDevice = function () {
  return this._checkModeProperty(S_IFBLK);
};

StatsBase.prototype.isCharacterDevice = function () {
  return this._checkModeProperty(S_IFCHR);
};

StatsBase.prototype.isSymbolicLink = function () {
  return this._checkModeProperty(S_IFLNK);
};

StatsBase.prototype.isFIFO = function () {
  return this._checkModeProperty(S_IFIFO);
};

StatsBase.prototype.isSocket = function () {
  return this._checkModeProperty(S_IFSOCK);
};

const kNsPerMsBigInt = 10n ** 6n;
const kNsPerSecBigInt = 10n ** 9n;
const kMsPerSec = 10 ** 3;
const kNsPerMs = 10 ** 6;
function msFromTimeSpec(sec, nsec) {
  return sec * kMsPerSec + nsec / kNsPerMs;
}

function nsFromTimeSpecBigInt(sec, nsec) {
  return sec * kNsPerSecBigInt + nsec;
}

// The Date constructor performs Math.floor() to the timestamp.
// https://www.ecma-international.org/ecma-262/#sec-timeclip
// Since there may be a precision loss when the timestamp is
// converted to a floating point number, we manually round
// the timestamp here before passing it to Date().
// Refs: https://github.com/nodejs/node/pull/12607
function dateFromMs(ms) {
  return new Date(Number(ms) + 0.5);
}

export function BigIntStats(
  dev,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  blksize,
  ino,
  size,
  blocks,
  atimeNs,
  mtimeNs,
  ctimeNs,
  birthtimeNs,
) {
  Reflect.apply(StatsBase, this, [
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks,
  ]);

  this.atimeMs = atimeNs / kNsPerMsBigInt;
  this.mtimeMs = mtimeNs / kNsPerMsBigInt;
  this.ctimeMs = ctimeNs / kNsPerMsBigInt;
  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
  this.atimeNs = atimeNs;
  this.mtimeNs = mtimeNs;
  this.ctimeNs = ctimeNs;
  this.birthtimeNs = birthtimeNs;
  this.atime = dateFromMs(this.atimeMs);
  this.mtime = dateFromMs(this.mtimeMs);
  this.ctime = dateFromMs(this.ctimeMs);
  this.birthtime = dateFromMs(this.birthtimeMs);
}

Object.setPrototypeOf(BigIntStats.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats, StatsBase);

BigIntStats.prototype._checkModeProperty = function (property) {
  if (
    isWindows && (property === S_IFIFO || property === S_IFBLK ||
      property === S_IFSOCK)
  ) {
    return false; // Some types are not available on Windows
  }
  return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};

export function Stats(
  dev,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  blksize,
  ino,
  size,
  blocks,
  atimeMs,
  mtimeMs,
  ctimeMs,
  birthtimeMs,
) {
  StatsBase.call(
    this,
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks,
  );
  this.atimeMs = atimeMs;
  this.mtimeMs = mtimeMs;
  this.ctimeMs = ctimeMs;
  this.birthtimeMs = birthtimeMs;
  this.atime = dateFromMs(atimeMs);
  this.mtime = dateFromMs(mtimeMs);
  this.ctime = dateFromMs(ctimeMs);
  this.birthtime = dateFromMs(birthtimeMs);
}

Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);

// HACK: Workaround for https://github.com/standard-things/esm/issues/821.
// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.
Stats.prototype.isFile = StatsBase.prototype.isFile;

Stats.prototype._checkModeProperty = function (property) {
  if (
    isWindows && (property === S_IFIFO || property === S_IFBLK ||
      property === S_IFSOCK)
  ) {
    return false; // Some types are not available on Windows
  }
  return (this.mode & S_IFMT) === property;
};

/**
 * @param {Float64Array | BigUint64Array} stats
 * @param {number} offset
 * @returns
 */
export function getStatsFromBinding(stats, offset = 0) {
  if (isBigUint64Array(stats)) {
    return new BigIntStats(
      stats[0 + offset],
      stats[1 + offset],
      stats[2 + offset],
      stats[3 + offset],
      stats[4 + offset],
      stats[5 + offset],
      stats[6 + offset],
      stats[7 + offset],
      stats[8 + offset],
      stats[9 + offset],
      nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]),
      nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]),
      nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]),
      nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]),
    );
  }
  return new Stats(
    stats[0 + offset],
    stats[1 + offset],
    stats[2 + offset],
    stats[3 + offset],
    stats[4 + offset],
    stats[5 + offset],
    stats[6 + offset],
    stats[7 + offset],
    stats[8 + offset],
    stats[9 + offset],
    msFromTimeSpec(stats[10 + offset], stats[11 + offset]),
    msFromTimeSpec(stats[12 + offset], stats[13 + offset]),
    msFromTimeSpec(stats[14 + offset], stats[15 + offset]),
    msFromTimeSpec(stats[16 + offset], stats[17 + offset]),
  );
}

export function stringToFlags(flags, name = ""flags"") {
  if (typeof flags === ""number"") {
    validateInt32(flags, name);
    return flags;
  }

  if (flags == null) {
    return O_RDONLY;
  }

  switch (flags) {
    case ""r"":
      return O_RDONLY;
    case ""rs"": // Fall through.
    case ""sr"":
      return O_RDONLY | O_SYNC;
    case ""r+"":
      return O_RDWR;
    case ""rs+"": // Fall through.
    case ""sr+"":
      return O_RDWR | O_SYNC;

    case ""w"":
      return O_TRUNC | O_CREAT | O_WRONLY;
    case ""wx"": // Fall through.
    case ""xw"":
      return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;

    case ""w+"":
      return O_TRUNC | O_CREAT | O_RDWR;
    case ""wx+"": // Fall through.
    case ""xw+"":
      return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;

    case ""a"":
      return O_APPEND | O_CREAT | O_WRONLY;
    case ""ax"": // Fall through.
    case ""xa"":
      return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
    case ""as"": // Fall through.
    case ""sa"":
      return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;

    case ""a+"":
      return O_APPEND | O_CREAT | O_RDWR;
    case ""ax+"": // Fall through.
    case ""xa+"":
      return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
    case ""as+"": // Fall through.
    case ""sa+"":
      return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
  }

  throw new ERR_INVALID_ARG_VALUE(""flags"", flags);
}

export const stringToSymlinkType = hideStackFrames((type) => {
  let flags = 0;
  if (typeof type === ""string"") {
    switch (type) {
      case ""dir"":
        flags |= UV_FS_SYMLINK_DIR;
        break;
      case ""junction"":
        flags |= UV_FS_SYMLINK_JUNCTION;
        break;
      case ""file"":
        break;
      default:
        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);
    }
  }
  return flags;
});

// converts Date or number to a fractional UNIX timestamp
export function toUnixTimestamp(time, name = ""time"") {
  // eslint-disable-next-line eqeqeq
  if (typeof time === ""string"" && +time == time) {
    return +time;
  }
  if (Number.isFinite(time)) {
    if (time < 0) {
      return Date.now() / 1000;
    }
    return time;
  }
  if (isDate(time)) {
    // Convert to 123.456 UNIX timestamp
    return Date.getTime(time) / 1000;
  }
  throw new ERR_INVALID_ARG_TYPE(name, [""Date"", ""Time in seconds""], time);
}

export const validateOffsetLengthRead = hideStackFrames(
  (offset, length, bufferLength) => {
    if (offset < 0) {
      throw new ERR_OUT_OF_RANGE(""offset"", "">= 0"", offset);
    }
    if (length < 0) {
      throw new ERR_OUT_OF_RANGE(""length"", "">= 0"", length);
    }
    if (offset + length > bufferLength) {
      throw new ERR_OUT_OF_RANGE(
        ""length"",
        `<= ${bufferLength - offset}`,
        length,
      );
    }
  },
);

export const validateOffsetLengthWrite = hideStackFrames(
  (offset, length, byteLength) => {
    if (offset > byteLength) {
      throw new ERR_OUT_OF_RANGE(""offset"", `<= ${byteLength}`, offset);
    }

    if (length > byteLength - offset) {
      throw new ERR_OUT_OF_RANGE(""length"", `<= ${byteLength - offset}`, length);
    }

    if (length < 0) {
      throw new ERR_OUT_OF_RANGE(""length"", "">= 0"", length);
    }

    validateInt32(length, ""length"", 0);
  },
);

export const validatePath = hideStackFrames((path, propName = ""path"") => {
  if (typeof path !== ""string"" && !isUint8Array(path)) {
    throw new ERR_INVALID_ARG_TYPE(propName, [""string"", ""Buffer"", ""URL""], path);
  }

  const err = nullCheck(path, propName, false);

  if (err !== undefined) {
    throw err;
  }
});

export const getValidatedPath = hideStackFrames(
  (fileURLOrPath, propName = ""path"") => {
    const path = toPathIfFileURL(fileURLOrPath);
    validatePath(path, propName);
    return typeof(path) === ""string"" ? path : path.toString();
  },
);

export const getValidatedFd = hideStackFrames((fd, propName = ""fd"") => {
  if (Object.is(fd, -0)) {
    return 0;
  }

  validateInt32(fd, propName, 0);

  return fd;
});

export const validateBufferArray = hideStackFrames(
  (buffers, propName = ""buffers"") => {
    if (!Array.isArray(buffers)) {
      throw new ERR_INVALID_ARG_TYPE(propName, ""ArrayBufferView[]"", buffers);
    }

    for (let i = 0; i < buffers.length; i++) {
      if (!isArrayBufferView(buffers[i])) {
        throw new ERR_INVALID_ARG_TYPE(propName, ""ArrayBufferView[]"", buffers);
      }
    }

    return buffers;
  },
);

let nonPortableTemplateWarn = true;

export function warnOnNonPortableTemplate(template) {
  // Template strings passed to the mkdtemp() family of functions should not
  // end with 'X' because they are handled inconsistently across platforms.
  if (nonPortableTemplateWarn && template.endsWith(""X"")) {
    process.emitWarning(
      ""mkdtemp() templates ending with X are not portable. "" +
      ""For details see: https://nodejs.org/api/fs.html"",
    );
    nonPortableTemplateWarn = false;
  }
}

const defaultCpOptions = {
  dereference: false,
  errorOnExist: false,
  filter: undefined,
  force: true,
  preserveTimestamps: false,
  recursive: false,
};

const defaultRmOptions = {
  recursive: false,
  force: false,
  retryDelay: 100,
  maxRetries: 0,
};

const defaultRmdirOptions = {
  retryDelay: 100,
  maxRetries: 0,
  recursive: false,
};

export const validateCpOptions = hideStackFrames((options) => {
  if (options === undefined) {
    return { ...defaultCpOptions };
  }
  validateObject(options, ""options"");
  options = { ...defaultCpOptions, ...options };
  validateBoolean(options.dereference, ""options.dereference"");
  validateBoolean(options.errorOnExist, ""options.errorOnExist"");
  validateBoolean(options.force, ""options.force"");
  validateBoolean(options.preserveTimestamps, ""options.preserveTimestamps"");
  validateBoolean(options.recursive, ""options.recursive"");
  if (options.filter !== undefined) {
    validateFunction(options.filter, ""options.filter"");
  }
  return options;
});

export const validateRmOptions = hideStackFrames(
  (path, options, expectDir, cb) => {
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, ""options.force"");

    stat(path, (err, stats) => {
      if (err) {
        if (options.force && err.code === ""ENOENT"") {
          return cb(null, options);
        }
        return cb(err, options);
      }

      if (expectDir && !stats.isDirectory()) {
        return cb(false);
      }

      if (stats.isDirectory() && !options.recursive) {
        return cb(
          new ERR_FS_EISDIR({
            code: ""EISDIR"",
            message: ""is a directory"",
            path,
            syscall: ""rm"",
            errno: EISDIR,
          }),
        );
      }
      return cb(null, options);
    });
  },
);

export const validateRmOptionsSync = hideStackFrames(
  (path, options, expectDir) => {
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, ""options.force"");

    if (!options.force || expectDir || !options.recursive) {
      const isDirectory = statSync(path, { throwIfNoEntry: !options.force })
        ?.isDirectory();

      if (expectDir && !isDirectory) {
        return false;
      }

      if (isDirectory && !options.recursive) {
        throw new ERR_FS_EISDIR({
          code: ""EISDIR"",
          message: ""is a directory"",
          path,
          syscall: ""rm"",
          errno: EISDIR,
        });
      }
    }

    return options;
  },
);

let recursiveRmdirWarned = process.noDeprecation;
export function emitRecursiveRmdirWarning() {
  if (!recursiveRmdirWarned) {
    process.emitWarning(
      ""In future versions of Node.js, fs.rmdir(path, { recursive: true }) "" +
      ""will be removed. Use fs.rm(path, { recursive: true }) instead"",
      ""DeprecationWarning"",
      ""DEP0147"",
    );
    recursiveRmdirWarned = true;
  }
}

export const validateRmdirOptions = hideStackFrames(
  (options, defaults = defaultRmdirOptions) => {
    if (options === undefined) {
      return defaults;
    }
    validateObject(options, ""options"");

    options = { ...defaults, ...options };

    validateBoolean(options.recursive, ""options.recursive"");
    validateInt32(options.retryDelay, ""options.retryDelay"", 0);
    validateUint32(options.maxRetries, ""options.maxRetries"");

    return options;
  },
);

export const getValidMode = hideStackFrames((mode, type) => {
  let min = kMinimumAccessMode;
  let max = kMaximumAccessMode;
  let def = F_OK;
  if (type === ""copyFile"") {
    min = kMinimumCopyMode;
    max = kMaximumCopyMode;
    def = mode || kDefaultCopyMode;
  } else {
    assert(type === ""access"");
  }
  if (mode == null) {
    return def;
  }
  if (Number.isInteger(mode) && mode >= min && mode <= max) {
    return mode;
  }
  if (typeof mode !== ""number"") {
    throw new ERR_INVALID_ARG_TYPE(""mode"", ""integer"", mode);
  }
  throw new ERR_OUT_OF_RANGE(
    ""mode"",
    `an integer >= ${min} && <= ${max}`,
    mode,
  );
});

export const validateStringAfterArrayBufferView = hideStackFrames(
  (buffer, name) => {
    if (typeof buffer === ""string"") {
      return;
    }

    if (
      typeof buffer === ""object"" &&
      buffer !== null &&
      typeof buffer.toString === ""function"" &&
      Object.prototype.hasOwnProperty.call(buffer, ""toString"")
    ) {
      return;
    }

    throw new ERR_INVALID_ARG_TYPE(
      name,
      [""string"", ""Buffer"", ""TypedArray"", ""DataView""],
      buffer,
    );
  },
);

export const validatePosition = hideStackFrames((position) => {
  if (typeof position === ""number"") {
    validateInteger(position, ""position"");
  } else if (typeof position === ""bigint"") {
    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
      throw new ERR_OUT_OF_RANGE(
        ""position"",
        `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`,
        position,
      );
    }
  } else {
    throw new ERR_INVALID_ARG_TYPE(""position"", [""integer"", ""bigint""], position);
  }
});

export const realpathCacheKey = Symbol(""realpathCacheKey"");
export const constants = {
  kIoMaxLength,
  kMaxUserId,
  kReadFileBufferLength,
  kReadFileUnknownBufferLength,
  kWriteFileMaxChunkSize,
};

export const showStringCoercionDeprecation = deprecate(
  () => { },
  ""Implicit coercion of objects with own toString property is deprecated."",
  ""DEP0162"",
);


export const validateEncoding = hideStackFrames((value, name) => {
  let exist = [
      'utf8', 'utf-8', '', 'hex', 'base64', 'latin1', 'usc2', 'utf16le', 'ascii', 'base64url'
  ].indexOf(value);

  if (exist < 0) {
      throw new errors.ERR_INVALID_ARG_VALUE(name, value);
  }
})

export default {
  constants,
  assertEncoding,
  BigIntStats, // for testing
  copyObject,
  Dirent,
  emitRecursiveRmdirWarning,
  getDirent,
  getDirents,
  getOptions,
  getValidatedFd,
  getValidatedPath,
  getValidMode,
  handleErrorFromBinding,
  kMaxUserId,
  nullCheck,
  preprocessSymlinkDestination,
  realpathCacheKey,
  getStatsFromBinding,
  showStringCoercionDeprecation,
  stringToFlags,
  stringToSymlinkType,
  Stats,
  toUnixTimestamp,
  validateBufferArray,
  validateCpOptions,
  validateOffsetLengthRead,
  validateOffsetLengthWrite,
  validatePath,
  validatePosition,
  validateRmOptions,
  validateRmOptionsSync,
  validateRmdirOptions,
  validateStringAfterArrayBufferView,
  warnOnNonPortableTemplate,
  validateEncoding
};"
Cargo.lock,"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = ""ab_glyph_rasterizer""
version = ""0.1.8""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""c71b1793ee61086797f5c80b6efa2b8ffa6d5dd703f118545808a7f2e27f7046""

[[package]]
name = ""addr2line""
version = ""0.21.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb""
dependencies = [
 ""gimli"",
]

[[package]]
name = ""adler""
version = ""1.0.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe""

[[package]]
name = ""adler32""
version = ""1.2.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""aae1277d39aeec15cb388266ecc24b11c80469deae6067e17a1a7aa9e5c1f234""

[[package]]
name = ""aho-corasick""
version = ""1.1.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""b2969dcb958b36655471fc61f7e416fa76033bdd4bfed0678d8fee1e2d07a1f0""
dependencies = [
 ""memchr"",
]

[[package]]
name = ""argparse""
version = ""0.2.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3f8ebf5827e4ac4fd5946560e6a99776ea73b596d80898f357007317a7141e47""

[[package]]
name = ""autocfg""
version = ""1.1.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa""

[[package]]
name = ""backtrace""
version = ""0.3.69""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""2089b7e3f35b9dd2d0ed921ead4f6d318c27680d4a5bd167b3ee120edb105837""
dependencies = [
 ""addr2line"",
 ""cc"",
 ""cfg-if"",
 ""libc"",
 ""miniz_oxide 0.7.1"",
 ""object"",
 ""rustc-demangle"",
]

[[package]]
name = ""base64""
version = ""0.13.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8""

[[package]]
name = ""base64""
version = ""0.21.7""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567""

[[package]]
name = ""bitflags""
version = ""1.3.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a""

[[package]]
name = ""bitflags""
version = ""2.4.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ed570934406eb16438a4e976b1b4500774099c13b8cb96eec99f620f05090ddf""

[[package]]
name = ""bytemuck""
version = ""1.14.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ed2490600f404f2b94c167e31d3ed1d5f3c225a0f3b80230053b3e0b7b962bd9""

[[package]]
name = ""byteorder""
version = ""1.5.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b""

[[package]]
name = ""bytes""
version = ""1.5.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a2bd12c1caf447e69cd4528f47f94d203fd2582878ecb9e9465484c4148a8223""

[[package]]
name = ""cc""
version = ""1.0.83""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0""
dependencies = [
 ""libc"",
]

[[package]]
name = ""cfg-if""
version = ""1.0.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd""

[[package]]
name = ""chat-prompts""
version = ""0.3.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""2b01b39dd6fff99d78eaef963e1b2076754a81850417356fa623bdee253eebbd""
dependencies = [
 ""endpoints"",
 ""enum_dispatch"",
 ""thiserror"",
]

[[package]]
name = ""color_quant""
version = ""1.1.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3d7b894f5411737b7867f4827955924d7c254fc9f4d91a6aad6b097804b1018b""

[[package]]
name = ""const-oid""
version = ""0.9.6""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8""

[[package]]
name = ""conv""
version = ""0.3.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""78ff10625fd0ac447827aa30ea8b861fead473bb60aeb73af6c1c58caf0d1299""
dependencies = [
 ""custom_derive"",
]

[[package]]
name = ""crc32fast""
version = ""1.3.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d""
dependencies = [
 ""cfg-if"",
]

[[package]]
name = ""crossbeam-deque""
version = ""0.8.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d""
dependencies = [
 ""crossbeam-epoch"",
 ""crossbeam-utils"",
]

[[package]]
name = ""crossbeam-epoch""
version = ""0.9.18""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e""
dependencies = [
 ""crossbeam-utils"",
]

[[package]]
name = ""crossbeam-utils""
version = ""0.8.19""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""248e3bacc7dc6baa3b21e405ee045c3047101a49145e7e9eca583ab4c2ca5345""

[[package]]
name = ""crypto-wasi""
version = ""0.1.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ac0fad491b70b319705c5564b53ee302299f2654972119330a9e1f62f4baa303""
dependencies = [
 ""base64 0.21.7"",
 ""der"",
 ""pem"",
]

[[package]]
name = ""custom_derive""
version = ""0.1.7""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ef8ae57c4978a2acd8b869ce6b9ca1dfe817bff704c220209fdef2c0b75a01b9""

[[package]]
name = ""deflate""
version = ""0.8.6""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""73770f8e1fe7d64df17ca66ad28994a0a623ea497fa69486e14984e715c5d174""
dependencies = [
 ""adler32"",
 ""byteorder"",
]

[[package]]
name = ""der""
version = ""0.7.8""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""fffa369a668c8af7dbf8b5e56c9f744fbd399949ed171606040001947de40b1c""
dependencies = [
 ""const-oid"",
 ""zeroize"",
]

[[package]]
name = ""dns-parser""
version = ""0.8.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""c4d33be9473d06f75f58220f71f7a9317aca647dc061dbd3c361b0bef505fbea""
dependencies = [
 ""byteorder"",
 ""quick-error"",
]

[[package]]
name = ""either""
version = ""1.9.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07""

[[package]]
name = ""encoding""
version = ""0.2.33""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""6b0d943856b990d12d3b55b359144ff341533e516d94098b1d3fc1ac666d36ec""
dependencies = [
 ""encoding-index-japanese"",
 ""encoding-index-korean"",
 ""encoding-index-simpchinese"",
 ""encoding-index-singlebyte"",
 ""encoding-index-tradchinese"",
]

[[package]]
name = ""encoding-index-japanese""
version = ""1.20141219.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""04e8b2ff42e9a05335dbf8b5c6f7567e5591d0d916ccef4e0b1710d32a0d0c91""
dependencies = [
 ""encoding_index_tests"",
]

[[package]]
name = ""encoding-index-korean""
version = ""1.20141219.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""4dc33fb8e6bcba213fe2f14275f0963fd16f0a02c878e3095ecfdf5bee529d81""
dependencies = [
 ""encoding_index_tests"",
]

[[package]]
name = ""encoding-index-simpchinese""
version = ""1.20141219.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""d87a7194909b9118fc707194baa434a4e3b0fb6a5a757c73c3adb07aa25031f7""
dependencies = [
 ""encoding_index_tests"",
]

[[package]]
name = ""encoding-index-singlebyte""
version = ""1.20141219.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3351d5acffb224af9ca265f435b859c7c01537c0849754d3db3fdf2bfe2ae84a""
dependencies = [
 ""encoding_index_tests"",
]

[[package]]
name = ""encoding-index-tradchinese""
version = ""1.20141219.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""fd0e20d5688ce3cab59eb3ef3a2083a5c77bf496cb798dc6fcdb75f323890c18""
dependencies = [
 ""encoding_index_tests"",
]

[[package]]
name = ""encoding_index_tests""
version = ""0.1.4""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a246d82be1c9d791c5dfde9a2bd045fc3cbba3fa2b11ad558f27d01712f00569""

[[package]]
name = ""endpoints""
version = ""0.2.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""844f278cb4e558c0cb2f920bbb221884bfa35cace9e61d3e238fc01ec09ca8a5""
dependencies = [
 ""serde"",
]

[[package]]
name = ""enum_dispatch""
version = ""0.3.12""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8f33313078bb8d4d05a2733a94ac4c2d8a0df9a2b84424ebf4f33bfc224a890e""
dependencies = [
 ""once_cell"",
 ""proc-macro2"",
 ""quote"",
 ""syn 2.0.48"",
]

[[package]]
name = ""env_logger""
version = ""0.10.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580""
dependencies = [
 ""humantime"",
 ""is-terminal"",
 ""log"",
 ""regex"",
 ""termcolor"",
]

[[package]]
name = ""errno""
version = ""0.3.8""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a258e46cdc063eb8519c00b9fc845fc47bcfca4130e2f08e88665ceda8474245""
dependencies = [
 ""libc"",
 ""windows-sys 0.52.0"",
]

[[package]]
name = ""form_urlencoded""
version = ""1.2.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456""
dependencies = [
 ""percent-encoding"",
]

[[package]]
name = ""getrandom""
version = ""0.1.16""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce""
dependencies = [
 ""cfg-if"",
 ""libc"",
 ""wasi 0.9.0+wasi-snapshot-preview1"",
]

[[package]]
name = ""getrandom""
version = ""0.2.12""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""190092ea657667030ac6a35e305e62fc4dd69fd98ac98631e5d3a2b1575a12b5""
dependencies = [
 ""cfg-if"",
 ""libc"",
 ""wasi 0.11.0+wasi-snapshot-preview1"",
]

[[package]]
name = ""gimli""
version = ""0.28.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""4271d37baee1b8c7e4b708028c57d816cf9d2434acb33a549475f78c181f6253""

[[package]]
name = ""hermit-abi""
version = ""0.3.4""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""5d3d0e0f38255e7fa3cf31335b3a56f05febd18025f4db5ef7a0cfb4f8da651f""

[[package]]
name = ""humantime""
version = ""2.1.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4""

[[package]]
name = ""idna""
version = ""0.5.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6""
dependencies = [
 ""unicode-bidi"",
 ""unicode-normalization"",
]

[[package]]
name = ""image""
version = ""0.23.14""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""24ffcb7e7244a9bf19d35bf2883b9c080c4ced3c07a9895572178cdb8f13f6a1""
dependencies = [
 ""bytemuck"",
 ""byteorder"",
 ""color_quant"",
 ""jpeg-decoder"",
 ""num-iter"",
 ""num-rational"",
 ""num-traits"",
 ""png"",
]

[[package]]
name = ""imageproc""
version = ""0.22.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""7923654f3ce7cb6849d5dc9e544aaeab49c508a90b56c721b046e7234c74ab53""
dependencies = [
 ""conv"",
 ""image"",
 ""itertools"",
 ""num 0.3.1"",
 ""rand 0.7.3"",
 ""rand_distr"",
 ""rayon"",
 ""rulinalg"",
 ""rusttype"",
]

[[package]]
name = ""is-terminal""
version = ""0.4.10""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""0bad00257d07be169d870ab665980b06cdb366d792ad690bf2e76876dc503455""
dependencies = [
 ""hermit-abi"",
 ""rustix"",
 ""windows-sys 0.52.0"",
]

[[package]]
name = ""itertools""
version = ""0.9.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""284f18f85651fe11e8a991b2adb42cb078325c996ed026d994719efcfca1d54b""
dependencies = [
 ""either"",
]

[[package]]
name = ""jpeg-decoder""
version = ""0.1.22""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""229d53d58899083193af11e15917b5640cd40b29ff475a1fe4ef725deb02d0f2""

[[package]]
name = ""lazy_static""
version = ""1.4.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646""

[[package]]
name = ""libc""
version = ""0.2.152""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""13e3bf6590cbc649f4d1a3eefc9d5d6eb746f5200ffb04e5e142700b8faa56e7""

[[package]]
name = ""linux-raw-sys""
version = ""0.4.13""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""01cda141df6706de531b6c46c3a33ecca755538219bd484262fa09410c13539c""

[[package]]
name = ""lock_api""
version = ""0.4.11""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3c168f8615b12bc01f9c17e2eb0cc07dcae1940121185446edc3744920e8ef45""
dependencies = [
 ""autocfg"",
 ""scopeguard"",
]

[[package]]
name = ""log""
version = ""0.4.20""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f""

[[package]]
name = ""matrixmultiply""
version = ""0.1.15""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""dcad67dcec2d58ff56f6292582377e6921afdf3bfbd533e26fb8900ae575e002""
dependencies = [
 ""rawpointer"",
]

[[package]]
name = ""memchr""
version = ""2.7.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149""

[[package]]
name = ""miniz_oxide""
version = ""0.3.7""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""791daaae1ed6889560f8c4359194f56648355540573244a5448a83ba1ecc7435""
dependencies = [
 ""adler32"",
]

[[package]]
name = ""miniz_oxide""
version = ""0.7.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7""
dependencies = [
 ""adler"",
]

[[package]]
name = ""mio_wasi""
version = ""0.8.9""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""826049861effde5245d1107a8eb21846bd8fc7a16486e60be4d0568361c947e5""
dependencies = [
 ""libc"",
 ""log"",
 ""wasi 0.11.0+wasi-snapshot-preview1"",
 ""wasmedge_wasi_socket"",
 ""windows-sys 0.48.0"",
]

[[package]]
name = ""num""
version = ""0.1.42""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""4703ad64153382334aa8db57c637364c322d3372e097840c72000dabdcf6156e""
dependencies = [
 ""num-integer"",
 ""num-iter"",
 ""num-traits"",
]

[[package]]
name = ""num""
version = ""0.3.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8b7a8e9be5e039e2ff869df49155f1c06bd01ade2117ec783e56ab0932b67a8f""
dependencies = [
 ""num-bigint"",
 ""num-complex"",
 ""num-integer"",
 ""num-iter"",
 ""num-rational"",
 ""num-traits"",
]

[[package]]
name = ""num-bigint""
version = ""0.3.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""5f6f7833f2cbf2360a6cfd58cd41a53aa7a90bd4c202f5b1c7dd2ed73c57b2c3""
dependencies = [
 ""autocfg"",
 ""num-integer"",
 ""num-traits"",
]

[[package]]
name = ""num-complex""
version = ""0.3.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""747d632c0c558b87dbabbe6a82f3b4ae03720d0646ac5b7b4dae89394be5f2c5""
dependencies = [
 ""num-traits"",
]

[[package]]
name = ""num-integer""
version = ""0.1.45""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9""
dependencies = [
 ""autocfg"",
 ""num-traits"",
]

[[package]]
name = ""num-iter""
version = ""0.1.43""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""7d03e6c028c5dc5cac6e2dec0efda81fc887605bb3d884578bb6d6bf7514e252""
dependencies = [
 ""autocfg"",
 ""num-integer"",
 ""num-traits"",
]

[[package]]
name = ""num-rational""
version = ""0.3.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""12ac428b1cb17fce6f731001d307d351ec70a6d202fc2e60f7d4c5e42d8f4f07""
dependencies = [
 ""autocfg"",
 ""num-bigint"",
 ""num-integer"",
 ""num-traits"",
]

[[package]]
name = ""num-traits""
version = ""0.2.17""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""39e3200413f237f41ab11ad6d161bc7239c84dcb631773ccd7de3dfe4b5c267c""
dependencies = [
 ""autocfg"",
]

[[package]]
name = ""num_cpus""
version = ""1.16.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43""
dependencies = [
 ""hermit-abi"",
 ""libc"",
]

[[package]]
name = ""object""
version = ""0.32.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441""
dependencies = [
 ""memchr"",
]

[[package]]
name = ""once_cell""
version = ""1.19.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92""

[[package]]
name = ""owned_ttf_parser""
version = ""0.15.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""05e6affeb1632d6ff6a23d2cd40ffed138e82f1532571a26f527c8a284bb2fbb""
dependencies = [
 ""ttf-parser"",
]

[[package]]
name = ""parking_lot""
version = ""0.12.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f""
dependencies = [
 ""lock_api"",
 ""parking_lot_core"",
]

[[package]]
name = ""parking_lot_core""
version = ""0.9.9""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""4c42a9226546d68acdd9c0a280d17ce19bfe27a46bf68784e4066115788d008e""
dependencies = [
 ""cfg-if"",
 ""libc"",
 ""redox_syscall"",
 ""smallvec"",
 ""windows-targets 0.48.5"",
]

[[package]]
name = ""pem""
version = ""1.1.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a8835c273a76a90455d7344889b0964598e3316e2a79ede8e36f16bdcf2228b8""
dependencies = [
 ""base64 0.13.1"",
]

[[package]]
name = ""percent-encoding""
version = ""2.3.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e""

[[package]]
name = ""pin-project-lite""
version = ""0.2.13""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8afb450f006bf6385ca15ef45d71d2288452bc3683ce2e2cacc0d18e4be60b58""

[[package]]
name = ""png""
version = ""0.16.8""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3c3287920cb847dee3de33d301c463fba14dda99db24214ddf93f83d3021f4c6""
dependencies = [
 ""bitflags 1.3.2"",
 ""crc32fast"",
 ""deflate"",
 ""miniz_oxide 0.3.7"",
]

[[package]]
name = ""ppv-lite86""
version = ""0.2.17""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de""

[[package]]
name = ""proc-macro2""
version = ""1.0.78""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e2422ad645d89c99f8f3e6b88a9fdeca7fabeac836b1002371c4367c8f984aae""
dependencies = [
 ""unicode-ident"",
]

[[package]]
name = ""quick-error""
version = ""1.2.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0""

[[package]]
name = ""quote""
version = ""1.0.35""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef""
dependencies = [
 ""proc-macro2"",
]

[[package]]
name = ""rand""
version = ""0.7.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03""
dependencies = [
 ""getrandom 0.1.16"",
 ""libc"",
 ""rand_chacha 0.2.2"",
 ""rand_core 0.5.1"",
 ""rand_hc"",
]

[[package]]
name = ""rand""
version = ""0.8.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404""
dependencies = [
 ""libc"",
 ""rand_chacha 0.3.1"",
 ""rand_core 0.6.4"",
]

[[package]]
name = ""rand_chacha""
version = ""0.2.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402""
dependencies = [
 ""ppv-lite86"",
 ""rand_core 0.5.1"",
]

[[package]]
name = ""rand_chacha""
version = ""0.3.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88""
dependencies = [
 ""ppv-lite86"",
 ""rand_core 0.6.4"",
]

[[package]]
name = ""rand_core""
version = ""0.5.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19""
dependencies = [
 ""getrandom 0.1.16"",
]

[[package]]
name = ""rand_core""
version = ""0.6.4""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c""
dependencies = [
 ""getrandom 0.2.12"",
]

[[package]]
name = ""rand_distr""
version = ""0.2.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""96977acbdd3a6576fb1d27391900035bf3863d4a16422973a409b488cf29ffb2""
dependencies = [
 ""rand 0.7.3"",
]

[[package]]
name = ""rand_hc""
version = ""0.2.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c""
dependencies = [
 ""rand_core 0.5.1"",
]

[[package]]
name = ""rawpointer""
version = ""0.1.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ebac11a9d2e11f2af219b8b8d833b76b1ea0e054aa0e8d8e9e4cbde353bdf019""

[[package]]
name = ""rayon""
version = ""1.8.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""fa7237101a77a10773db45d62004a272517633fbcc3df19d96455ede1122e051""
dependencies = [
 ""either"",
 ""rayon-core"",
]

[[package]]
name = ""rayon-core""
version = ""1.12.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2""
dependencies = [
 ""crossbeam-deque"",
 ""crossbeam-utils"",
]

[[package]]
name = ""redox_syscall""
version = ""0.4.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa""
dependencies = [
 ""bitflags 1.3.2"",
]

[[package]]
name = ""regex""
version = ""1.10.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""b62dbe01f0b06f9d8dc7d49e05a0785f153b00b2c227856282f671e0318c9b15""
dependencies = [
 ""aho-corasick"",
 ""memchr"",
 ""regex-automata"",
 ""regex-syntax"",
]

[[package]]
name = ""regex-automata""
version = ""0.4.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""5bb987efffd3c6d0d8f5f89510bb458559eab11e4f869acb20bf845e016259cd""
dependencies = [
 ""aho-corasick"",
 ""memchr"",
 ""regex-syntax"",
]

[[package]]
name = ""regex-syntax""
version = ""0.8.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""c08c74e62047bb2de4ff487b251e4a92e24f48745648451635cec7d591162d9f""

[[package]]
name = ""ring""
version = ""0.17.7""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""688c63d65483050968b2a8937f7995f443e27041a0f7700aa59b0822aedebb74""
dependencies = [
 ""cc"",
 ""getrandom 0.2.12"",
 ""libc"",
 ""spin"",
 ""untrusted"",
 ""windows-sys 0.48.0"",
]

[[package]]
name = ""rulinalg""
version = ""0.4.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""04ada202c9685e1d72a7420c578e92b358dbf807d3dfabb676a3dab9cc3bb12f""
dependencies = [
 ""matrixmultiply"",
 ""num 0.1.42"",
]

[[package]]
name = ""rustc-demangle""
version = ""0.1.23""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76""

[[package]]
name = ""rustix""
version = ""0.38.30""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""322394588aaf33c24007e8bb3238ee3e4c5c09c084ab32bc73890b99ff326bca""
dependencies = [
 ""bitflags 2.4.2"",
 ""errno"",
 ""libc"",
 ""linux-raw-sys"",
 ""windows-sys 0.52.0"",
]

[[package]]
name = ""rustls""
version = ""0.21.10""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""f9d5a6813c0759e4609cd494e8e725babae6a2ca7b62a5536a13daaec6fcb7ba""
dependencies = [
 ""log"",
 ""ring"",
 ""rustls-webpki"",
 ""sct"",
]

[[package]]
name = ""rustls-pemfile""
version = ""1.0.4""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""1c74cae0a4cf6ccbbf5f359f08efdf8ee7e1dc532573bf0db71968cb56b1448c""
dependencies = [
 ""base64 0.21.7"",
]

[[package]]
name = ""rustls-webpki""
version = ""0.101.7""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8b6275d1ee7a1cd780b64aca7726599a1dbc893b1e64144529e55c3c2f745765""
dependencies = [
 ""ring"",
 ""untrusted"",
]

[[package]]
name = ""rusttype""
version = ""0.9.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3ff8374aa04134254b7995b63ad3dc41c7f7236f69528b28553da7d72efaa967""
dependencies = [
 ""ab_glyph_rasterizer"",
 ""owned_ttf_parser"",
]

[[package]]
name = ""scopeguard""
version = ""1.2.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49""

[[package]]
name = ""sct""
version = ""0.7.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""da046153aa2352493d6cb7da4b6e5c0c057d8a1d0a9aa8560baffdd945acd414""
dependencies = [
 ""ring"",
 ""untrusted"",
]

[[package]]
name = ""serde""
version = ""1.0.196""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""870026e60fa08c69f064aa766c10f10b1d62db9ccd4d0abb206472bee0ce3b32""
dependencies = [
 ""serde_derive"",
]

[[package]]
name = ""serde_derive""
version = ""1.0.196""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""33c85360c95e7d137454dc81d9a4ed2b8efd8fbe19cee57357b32b9771fccb67""
dependencies = [
 ""proc-macro2"",
 ""quote"",
 ""syn 2.0.48"",
]

[[package]]
name = ""signal-hook-registry""
version = ""1.4.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1""
dependencies = [
 ""libc"",
]

[[package]]
name = ""smallvec""
version = ""1.13.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e6ecd384b10a64542d77071bd64bd7b231f4ed5940fba55e98c3de13824cf3d7""

[[package]]
name = ""socket2""
version = ""0.4.10""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""9f7916fc008ca5542385b89a3d3ce689953c143e9304a9bf8beec1de48994c0d""
dependencies = [
 ""libc"",
 ""winapi"",
]

[[package]]
name = ""spin""
version = ""0.9.8""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67""

[[package]]
name = ""syn""
version = ""1.0.109""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237""
dependencies = [
 ""proc-macro2"",
 ""quote"",
 ""unicode-ident"",
]

[[package]]
name = ""syn""
version = ""2.0.48""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""0f3531638e407dfc0814761abb7c00a5b54992b849452a0646b7f65c9f770f3f""
dependencies = [
 ""proc-macro2"",
 ""quote"",
 ""unicode-ident"",
]

[[package]]
name = ""termcolor""
version = ""1.4.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755""
dependencies = [
 ""winapi-util"",
]

[[package]]
name = ""thiserror""
version = ""1.0.56""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""d54378c645627613241d077a3a79db965db602882668f9136ac42af9ecb730ad""
dependencies = [
 ""thiserror-impl"",
]

[[package]]
name = ""thiserror-impl""
version = ""1.0.56""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""fa0faa943b50f3db30a20aa7e265dbc66076993efed8463e8de414e5d06d3471""
dependencies = [
 ""proc-macro2"",
 ""quote"",
 ""syn 2.0.48"",
]

[[package]]
name = ""tinyvec""
version = ""1.6.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50""
dependencies = [
 ""tinyvec_macros"",
]

[[package]]
name = ""tinyvec_macros""
version = ""0.1.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20""

[[package]]
name = ""tokio""
version = ""1.35.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""c89b4efa943be685f629b149f53829423f8f5531ea21249408e8e2f8671ec104""
dependencies = [
 ""backtrace"",
 ""pin-project-lite"",
]

[[package]]
name = ""tokio-macros""
version = ""1.8.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""d266c00fde287f55d3f1c3e96c500c362a2b8c695076ec180f27918820bc6df8""
dependencies = [
 ""proc-macro2"",
 ""quote"",
 ""syn 1.0.109"",
]

[[package]]
name = ""tokio-rustls-wasi""
version = ""0.24.1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""f8c00c7bdbd252bfc42ff5f091066b27d86c10732ecad16ac06500ac09c1ecc6""
dependencies = [
 ""rustls"",
 ""tokio"",
 ""tokio_wasi"",
]

[[package]]
name = ""tokio_wasi""
version = ""1.25.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""6b3a7120cdbe4719425355a0f6b59191c67ab5ed4eebc64bdb12ea3bc8776adf""
dependencies = [
 ""autocfg"",
 ""bytes"",
 ""libc"",
 ""memchr"",
 ""mio_wasi"",
 ""num_cpus"",
 ""parking_lot"",
 ""pin-project-lite"",
 ""signal-hook-registry"",
 ""socket2"",
 ""tokio-macros"",
 ""wasmedge_wasi_socket"",
 ""windows-sys 0.45.0"",
]

[[package]]
name = ""ttf-parser""
version = ""0.15.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""7b3e06c9b9d80ed6b745c7159c40b311ad2916abb34a49e9be2653b90db0d8dd""

[[package]]
name = ""unicode-bidi""
version = ""0.3.15""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""08f95100a766bf4f8f28f90d77e0a5461bbdb219042e7679bebe79004fed8d75""

[[package]]
name = ""unicode-ident""
version = ""1.0.12""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b""

[[package]]
name = ""unicode-normalization""
version = ""0.1.22""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921""
dependencies = [
 ""tinyvec"",
]

[[package]]
name = ""untrusted""
version = ""0.9.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1""

[[package]]
name = ""url""
version = ""2.5.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""31e6302e3bb753d46e83516cae55ae196fc0c309407cf11ab35cc51a4c2a4633""
dependencies = [
 ""form_urlencoded"",
 ""idna"",
 ""percent-encoding"",
]

[[package]]
name = ""wasi""
version = ""0.9.0+wasi-snapshot-preview1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519""

[[package]]
name = ""wasi""
version = ""0.11.0+wasi-snapshot-preview1""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423""

[[package]]
name = ""wasi-nn""
version = ""0.6.0""
source = ""git+https://github.com/second-state/wasmedge-wasi-nn?branch=ggml#891f7c414bf1eecaa1b36c5792d1c88097ceafd6""
dependencies = [
 ""thiserror"",
]

[[package]]
name = ""wasmedge_quickjs""
version = ""0.6.0-alpha""
dependencies = [
 ""argparse"",
 ""chat-prompts"",
 ""crypto-wasi"",
 ""encoding"",
 ""endpoints"",
 ""env_logger"",
 ""image"",
 ""imageproc"",
 ""lazy_static"",
 ""libc"",
 ""log"",
 ""rustls"",
 ""rustls-pemfile"",
 ""tokio-rustls-wasi"",
 ""tokio_wasi"",
 ""url"",
 ""wasi-nn"",
 ""wasmedge_wasi_socket"",
 ""webpki-roots"",
]

[[package]]
name = ""wasmedge_wasi_socket""
version = ""0.5.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""77b48797e35a2929cb9d5bf67370f6e4da275be54e6552be5942f98b109530b4""
dependencies = [
 ""bytes"",
 ""dns-parser"",
 ""libc"",
 ""rand 0.8.5"",
]

[[package]]
name = ""webpki-roots""
version = ""0.25.3""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""1778a42e8b3b90bff8d0f5032bf22250792889a5cdc752aa0020c84abe3aaf10""

[[package]]
name = ""winapi""
version = ""0.3.9""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419""
dependencies = [
 ""winapi-i686-pc-windows-gnu"",
 ""winapi-x86_64-pc-windows-gnu"",
]

[[package]]
name = ""winapi-i686-pc-windows-gnu""
version = ""0.4.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6""

[[package]]
name = ""winapi-util""
version = ""0.1.6""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""f29e6f9198ba0d26b4c9f07dbe6f9ed633e1f3d5b8b414090084349e46a52596""
dependencies = [
 ""winapi"",
]

[[package]]
name = ""winapi-x86_64-pc-windows-gnu""
version = ""0.4.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f""

[[package]]
name = ""windows-sys""
version = ""0.45.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0""
dependencies = [
 ""windows-targets 0.42.2"",
]

[[package]]
name = ""windows-sys""
version = ""0.48.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9""
dependencies = [
 ""windows-targets 0.48.5"",
]

[[package]]
name = ""windows-sys""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d""
dependencies = [
 ""windows-targets 0.52.0"",
]

[[package]]
name = ""windows-targets""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071""
dependencies = [
 ""windows_aarch64_gnullvm 0.42.2"",
 ""windows_aarch64_msvc 0.42.2"",
 ""windows_i686_gnu 0.42.2"",
 ""windows_i686_msvc 0.42.2"",
 ""windows_x86_64_gnu 0.42.2"",
 ""windows_x86_64_gnullvm 0.42.2"",
 ""windows_x86_64_msvc 0.42.2"",
]

[[package]]
name = ""windows-targets""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c""
dependencies = [
 ""windows_aarch64_gnullvm 0.48.5"",
 ""windows_aarch64_msvc 0.48.5"",
 ""windows_i686_gnu 0.48.5"",
 ""windows_i686_msvc 0.48.5"",
 ""windows_x86_64_gnu 0.48.5"",
 ""windows_x86_64_gnullvm 0.48.5"",
 ""windows_x86_64_msvc 0.48.5"",
]

[[package]]
name = ""windows-targets""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8a18201040b24831fbb9e4eb208f8892e1f50a37feb53cc7ff887feb8f50e7cd""
dependencies = [
 ""windows_aarch64_gnullvm 0.52.0"",
 ""windows_aarch64_msvc 0.52.0"",
 ""windows_i686_gnu 0.52.0"",
 ""windows_i686_msvc 0.52.0"",
 ""windows_x86_64_gnu 0.52.0"",
 ""windows_x86_64_gnullvm 0.52.0"",
 ""windows_x86_64_msvc 0.52.0"",
]

[[package]]
name = ""windows_aarch64_gnullvm""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8""

[[package]]
name = ""windows_aarch64_gnullvm""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8""

[[package]]
name = ""windows_aarch64_gnullvm""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""cb7764e35d4db8a7921e09562a0304bf2f93e0a51bfccee0bd0bb0b666b015ea""

[[package]]
name = ""windows_aarch64_msvc""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43""

[[package]]
name = ""windows_aarch64_msvc""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc""

[[package]]
name = ""windows_aarch64_msvc""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""bbaa0368d4f1d2aaefc55b6fcfee13f41544ddf36801e793edbbfd7d7df075ef""

[[package]]
name = ""windows_i686_gnu""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f""

[[package]]
name = ""windows_i686_gnu""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e""

[[package]]
name = ""windows_i686_gnu""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""a28637cb1fa3560a16915793afb20081aba2c92ee8af57b4d5f28e4b3e7df313""

[[package]]
name = ""windows_i686_msvc""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060""

[[package]]
name = ""windows_i686_msvc""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406""

[[package]]
name = ""windows_i686_msvc""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ffe5e8e31046ce6230cc7215707b816e339ff4d4d67c65dffa206fd0f7aa7b9a""

[[package]]
name = ""windows_x86_64_gnu""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36""

[[package]]
name = ""windows_x86_64_gnu""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e""

[[package]]
name = ""windows_x86_64_gnu""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""3d6fa32db2bc4a2f5abeacf2b69f7992cd09dca97498da74a151a3132c26befd""

[[package]]
name = ""windows_x86_64_gnullvm""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3""

[[package]]
name = ""windows_x86_64_gnullvm""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc""

[[package]]
name = ""windows_x86_64_gnullvm""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""1a657e1e9d3f514745a572a6846d3c7aa7dbe1658c056ed9c3344c4109a6949e""

[[package]]
name = ""windows_x86_64_msvc""
version = ""0.42.2""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0""

[[package]]
name = ""windows_x86_64_msvc""
version = ""0.48.5""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538""

[[package]]
name = ""windows_x86_64_msvc""
version = ""0.52.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""dff9641d1cd4be8d1a070daf9e3773c5f67e78b4d9d42263020c057706765c04""

[[package]]
name = ""zeroize""
version = ""1.7.0""
source = ""registry+https://github.com/rust-lang/crates.io-index""
checksum = ""525b4ec142c6b68a2d10f01f7bbf6755599ca3f81ea53b8431b7dd348f5fdb2d""
"
src/internal_module/fs.rs,"use crate::event_loop::wasi_fs;
use crate::quickjs_sys::*;
use std::convert::TryInto;
use std::fs;
use std::fs::Permissions;
use std::io;
use std::os::wasi::prelude::FromRawFd;
use std::time::SystemTime;
use std::time::UNIX_EPOCH;

impl From<u64> for JsValue {
    fn from(val: u64) -> Self {
        JsValue::Float(val as f64)
    }
}

fn permissions_to_mode(permit: Permissions) -> i32 {
    const F_OK: i32 = 0;
    const R_OK: i32 = 4;
    const W_OK: i32 = 2;
    const X_OK: i32 = 1;
    let p = if permit.readonly() {
        F_OK | R_OK | X_OK
    } else {
        F_OK | R_OK | W_OK | X_OK
    };
    p | p << 3 | p << 6
}

fn stat_to_js_object(ctx: &mut Context, stat: wasi_fs::Filestat) -> JsValue {
    let mut res = ctx.new_object();
    res.set(
        ""is_file"",
        (stat.filetype == wasi_fs::FILETYPE_REGULAR_FILE).into(),
    );
    res.set(
        ""is_directory"",
        (stat.filetype == wasi_fs::FILETYPE_DIRECTORY).into(),
    );
    res.set(
        ""is_symlink"",
        (stat.filetype == wasi_fs::FILETYPE_SYMBOLIC_LINK).into(),
    );
    res.set(
        ""is_block_device"",
        (stat.filetype == wasi_fs::FILETYPE_BLOCK_DEVICE).into(),
    );
    res.set(
        ""is_char_device"",
        (stat.filetype == wasi_fs::FILETYPE_CHARACTER_DEVICE).into(),
    );
    res.set(
        ""is_socket"",
        (stat.filetype == wasi_fs::FILETYPE_SOCKET_DGRAM
            || stat.filetype == wasi_fs::FILETYPE_SOCKET_STREAM)
            .into(),
    );
    res.set(""size"", stat.size.into());
    res.set(""mtime"", (stat.mtim / 1000000).into());
    res.set(""atime"", (stat.atim / 1000000).into());
    res.set(""birthtime"", (stat.ctim / 1000000).into());
    res.set(""dev"", stat.dev.into());
    res.set(""ino"", stat.ino.into());
    res.set(""mode"", 0o666.into());
    res.set(""nlink"", stat.nlink.into());
    res.set(""uid"", 0.into());
    res.set(""gid"", 0.into());
    res.set(""rdev"", 0.into());
    res.set(""blksize"", 0.into());
    res.set(""blocks"", 0.into());
    JsValue::Object(res)
}

fn err_to_js_object(ctx: &mut Context, e: io::Error) -> JsValue {
    errno_to_js_object(ctx, wasi_fs::Errno(e.raw_os_error().unwrap() as u16))
}

pub fn errno_to_js_object(ctx: &mut Context, e: wasi_fs::Errno) -> JsValue {
    let mut res = ctx.new_object();
    res.set(""message"", JsValue::String(ctx.new_string(e.message())));
    res.set(""code"", JsValue::String(ctx.new_string(e.name())));
    res.set(""errno"", JsValue::Int(e.raw() as i32));
    JsValue::Object(res)
}

fn stat_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    if path.is_none() {
        return JsValue::UnDefined;
    }
    if let JsValue::String(s) = path.unwrap() {
        let (dir, file) = match wasi_fs::open_parent(s.as_str()) {
            Ok(ok) => ok,
            Err(e) => {
                return {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            }
        };
        return match unsafe {
            wasi_fs::path_filestat_get(dir, wasi_fs::LOOKUPFLAGS_SYMLINK_FOLLOW, file.as_str())
        } {
            Ok(stat) => stat_to_js_object(ctx, stat),
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    } else {
        return JsValue::UnDefined;
    }
}

fn fstat_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let fd = arg.get(0);
    if fd.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(f) = get_js_number(fd) {
        return match unsafe { wasi_fs::fd_filestat_get(f as u32) } {
            Ok(stat) => stat_to_js_object(ctx, stat),
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    } else {
        return JsValue::UnDefined;
    }
}

fn lstat_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    if path.is_none() {
        return JsValue::UnDefined;
    }
    if let JsValue::String(s) = path.unwrap() {
        let (dir, file) = match wasi_fs::open_parent(s.as_str()) {
            Ok(ok) => ok,
            Err(e) => {
                return {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            }
        };
        return match unsafe { wasi_fs::path_filestat_get(dir, 0, file.as_str()) } {
            Ok(stat) => stat_to_js_object(ctx, stat),
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    } else {
        return JsValue::UnDefined;
    }
}

fn mkdir_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    let recursive = arg.get(1);
    let mode = arg.get(2);
    if path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(s)) = path {
        if let Some(JsValue::Bool(r)) = recursive {
            if let Some(JsValue::Int(_m)) = mode {
                let res = if *r {
                    fs::create_dir_all(s.as_str())
                } else {
                    fs::create_dir(s.as_str())
                };
                return match res {
                    Ok(()) => JsValue::UnDefined,
                    Err(e) => {
                        let err = err_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn rmdir_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    let recursive = arg.get(1);
    if path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(s)) = path {
        if let Some(JsValue::Bool(r)) = recursive {
            let res = if *r {
                fs::remove_dir_all(s.as_str())
            } else {
                fs::remove_dir(s.as_str())
            };
            return match res {
                Ok(()) => JsValue::UnDefined,
                Err(e) => {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

fn rm_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    let recursive = arg.get(1);
    let force = arg.get(2);
    if path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(s)) = path {
        if let Some(JsValue::Bool(r)) = recursive {
            if let Some(JsValue::Bool(f)) = force {
                let res = fs::metadata(s.as_str()).and_then(|stat| {
                    if stat.is_file() {
                        fs::remove_file(s.as_str())
                    } else {
                        if *r {
                            fs::remove_dir_all(s.as_str())
                        } else {
                            fs::remove_dir(s.as_str())
                        }
                    }
                });
                return match res {
                    Ok(()) => JsValue::UnDefined,
                    Err(e) => {
                        if e.kind() == std::io::ErrorKind::NotFound && *f {
                            JsValue::UnDefined
                        } else {
                            let err = err_to_js_object(ctx, e);
                            JsValue::Exception(ctx.throw_error(err))
                        }
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn rename_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let old_path = arg.get(0);
    let new_path = arg.get(1);
    if old_path.is_none() || new_path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(from)) = old_path {
        if let Some(JsValue::String(to)) = new_path {
            return match fs::rename(from.as_str(), to.as_str()) {
                Ok(()) => JsValue::UnDefined,
                Err(e) => {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

fn truncate_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    let len = arg.get(1);
    if path.is_none() || len.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(p)) = path {
        if let Some(l) = get_js_number(len) {
            let res = fs::OpenOptions::new()
                .write(true)
                .open(p.as_str())
                .and_then(|file| file.set_len(l as u64));
            return match res {
                Ok(()) => JsValue::UnDefined,
                Err(e) => {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

fn ftruncate_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let fd = arg.get(0);
    let len = arg.get(1);
    if fd.is_none() || len.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::Int(f)) = fd {
        if let Some(l) = get_js_number(len) {
            let res = unsafe { wasi_fs::fd_filestat_set_size(*f as u32, l as u64) };
            return match res {
                Ok(()) => JsValue::UnDefined,
                Err(e) => {
                    let err = errno_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

fn realpath_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    if path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(p)) = path {
        let (dir, file) = match wasi_fs::open_parent(p.as_str()) {
            Ok(ok) => ok,
            Err(e) => {
                return {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            }
        };
        let mut buf = vec![0; 1024];
        let res =
            unsafe { wasi_fs::path_readlink(dir, file.as_str(), buf.as_mut_ptr(), buf.len()) };
        return match res {
            Ok(size) => ctx
                .new_string(std::str::from_utf8(&buf[0..size]).unwrap())
                .into(),
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    }
    return JsValue::UnDefined;
}

fn copy_file_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let from_path = arg.get(0);
    let to_path = arg.get(1);
    if from_path.is_none() || to_path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(from)) = from_path {
        if let Some(JsValue::String(to)) = to_path {
            let res = fs::copy(from.as_str(), to.as_str());
            return match res {
                Ok(_) => JsValue::UnDefined,
                Err(e) => {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

fn link_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let from_path = arg.get(0);
    let to_path = arg.get(1);
    if from_path.is_none() || to_path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(from)) = from_path {
        if let Some(JsValue::String(to)) = to_path {
            let res = fs::hard_link(from.as_str(), to.as_str());
            return match res {
                Ok(_) => JsValue::UnDefined,
                Err(e) => {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

fn symlink_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let from_path = arg.get(0);
    let to_path = arg.get(1);
    if from_path.is_none() || to_path.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(from)) = from_path {
        if let Some(JsValue::String(to)) = to_path {
            let (dir, file) = match wasi_fs::open_parent(to.as_str()) {
                Ok(ok) => ok,
                Err(e) => {
                    return {
                        let err = err_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                }
            };
            let res = unsafe { wasi_fs::path_symlink(from.as_str(), dir, file.as_str()) };
            return match res {
                Ok(_) => JsValue::UnDefined,
                Err(e) => {
                    let err = errno_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

fn utime_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    let atime = arg.get(1);
    let mtime = arg.get(2);
    if path.is_none() || atime.is_none() || mtime.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(p)) = path {
        if let Some(a) = get_js_number(atime) {
            if let Some(m) = get_js_number(mtime) {
                let (dir, file) = match wasi_fs::open_parent(p.as_str()) {
                    Ok(ok) => ok,
                    Err(e) => {
                        return {
                            let err = err_to_js_object(ctx, e);
                            JsValue::Exception(ctx.throw_error(err))
                        }
                    }
                };
                let res = unsafe {
                    wasi_fs::path_filestat_set_times(
                        dir,
                        wasi_fs::LOOKUPFLAGS_SYMLINK_FOLLOW,
                        file.as_str(),
                        (a as u64) * 1000000,
                        (m as u64) * 1000000,
                        wasi_fs::FSTFLAGS_ATIM | wasi_fs::FSTFLAGS_MTIM,
                    )
                };
                return match res {
                    Ok(_) => JsValue::UnDefined,
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn lutime_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let path = arg.get(0);
    let atime = arg.get(1);
    let mtime = arg.get(2);
    if path.is_none() || atime.is_none() || mtime.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::String(p)) = path {
        if let Some(a) = get_js_number(atime) {
            if let Some(m) = get_js_number(mtime) {
                let (dir, file) = match wasi_fs::open_parent(p.as_str()) {
                    Ok(ok) => ok,
                    Err(e) => {
                        return {
                            let err = err_to_js_object(ctx, e);
                            JsValue::Exception(ctx.throw_error(err))
                        }
                    }
                };
                let res = unsafe {
                    wasi_fs::path_filestat_set_times(
                        dir,
                        0,
                        file.as_str(),
                        (a as u64) * 1000000,
                        (m as u64) * 1000000,
                        wasi_fs::FSTFLAGS_ATIM | wasi_fs::FSTFLAGS_MTIM,
                    )
                };
                return match res {
                    Ok(_) => JsValue::UnDefined,
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn futime_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let fd = arg.get(0);
    let atime = arg.get(1);
    let mtime = arg.get(2);
    if fd.is_none() || atime.is_none() || mtime.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::Int(f)) = fd {
        if let Some(JsValue::Float(a)) = atime {
            if let Some(JsValue::Float(m)) = mtime {
                let res = unsafe {
                    wasi_fs::fd_filestat_set_times(
                        *f as u32,
                        *a as u64,
                        *m as u64,
                        wasi_fs::FSTFLAGS_ATIM | wasi_fs::FSTFLAGS_MTIM,
                    )
                };
                return match res {
                    Ok(_) => JsValue::UnDefined,
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn fclose_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let fd = arg.get(0);
    if fd.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::Int(f)) = fd {
        let res = unsafe { wasi_fs::fd_close(*f as u32) };
        return match res {
            Ok(_) => JsValue::UnDefined,
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    }
    return JsValue::UnDefined;
}

fn fdatasync_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let fd = arg.get(0);
    if fd.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::Int(f)) = fd {
        let res = unsafe { wasi_fs::fd_datasync(*f as u32) };
        return match res {
            Ok(_) => JsValue::UnDefined,
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    }
    return JsValue::UnDefined;
}

fn fsync_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let fd = arg.get(0);
    if fd.is_none() {
        return JsValue::UnDefined;
    }
    if let Some(JsValue::Int(f)) = fd {
        let res = unsafe { wasi_fs::fd_sync(*f as u32) };
        return match res {
            Ok(_) => JsValue::UnDefined,
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    }
    return JsValue::UnDefined;
}

fn get_js_number(val: Option<&JsValue>) -> Option<i64> {
    match val {
        Some(JsValue::Int(i)) => Some(*i as i64),
        Some(JsValue::Float(f)) => Some(*f as i64),
        _ => None,
    }
}

fn fread(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    if let Some(JsValue::Int(fd)) = arg.get(0) {
        if let Some(position) = get_js_number(arg.get(1)) {
            if let Some(JsValue::Int(length)) = arg.get(2) {
                let (promise, ok, error) = ctx.new_promise();
                let nctx = ctx.clone();
                let len = *length as usize; // len.min(event.fd_readwrite.nbytes) as usize;
                let fd = *fd;

                if let Some(event_loop) = ctx.event_loop() {
                    event_loop.add_immediate_task(Box::new(move || {
                        let mut ctx = nctx;
                        let pos = position;
                        let mut buf = vec![0u8; len];
                        let res = if pos >= 0 {
                            unsafe {
                                wasi_fs::fd_pread(
                                    fd as u32,
                                    &[wasi_fs::Iovec {
                                        buf: buf.as_mut_ptr(),
                                        buf_len: len,
                                    }],
                                    pos as u64,
                                )
                            }
                        } else {
                            unsafe {
                                wasi_fs::fd_read(
                                    fd as u32,
                                    &[wasi_fs::Iovec {
                                        buf: buf.as_mut_ptr(),
                                        buf_len: len,
                                    }],
                                )
                            }
                        };
                        match res {
                            Ok(rlen) => {
                                let buf = ctx.new_array_buffer(&buf[0..rlen]);
                                if let JsValue::Function(resolve) = ok {
                                    resolve.call(&[JsValue::ArrayBuffer(buf)]);
                                }
                            }
                            Err(e) => {
                                if let JsValue::Function(reject) = error {
                                    reject.call(&[errno_to_js_object(&mut ctx, e)]);
                                }
                            }
                        };
                    }))
                }

                return promise;
            }
        }
    }
    return JsValue::UnDefined;
}

fn fread_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    if let Some(JsValue::Int(fd)) = arg.get(0) {
        if let Some(position) = get_js_number(arg.get(1)) {
            if let Some(JsValue::Int(length)) = arg.get(2) {
                let len = *length as usize;
                let mut buf = vec![0; len];
                let res = if position >= 0 {
                    unsafe {
                        wasi_fs::fd_pread(
                            *fd as u32,
                            &[wasi_fs::Iovec {
                                buf: buf.as_mut_ptr(),
                                buf_len: len,
                            }],
                            position as u64,
                        )
                    }
                } else {
                    unsafe {
                        wasi_fs::fd_read(
                            *fd as u32,
                            &[wasi_fs::Iovec {
                                buf: buf.as_mut_ptr(),
                                buf_len: len,
                            }],
                        )
                    }
                };
                return match res {
                    Ok(rlen) => {
                        let data = ctx.new_array_buffer(&buf[0..rlen]);
                        JsValue::ArrayBuffer(data)
                    }
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn open_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    if let Some(JsValue::String(path)) = arg.get(0) {
        if let Some(JsValue::Int(flag)) = arg.get(1) {
            if let Some(JsValue::Int(_mode)) = arg.get(2) {
                let fdflag = if flag & 128 == 128 {
                    wasi_fs::FDFLAGS_NONBLOCK
                } else {
                    wasi_fs::FDFLAGS_SYNC
                } | if flag & 8 == 8 {
                    wasi_fs::FDFLAGS_APPEND
                } else {
                    0
                };
                let oflag = if flag & 512 == 512 {
                    wasi_fs::OFLAGS_CREAT
                } else {
                    0
                } | if flag & 2048 == 2048 {
                    wasi_fs::OFLAGS_EXCL
                } else {
                    0
                } | if flag & 1024 == 1024 {
                    wasi_fs::OFLAGS_TRUNC
                } else {
                    0
                };
                let right = if flag & 1 == 1 || flag & 2 == 2 {
                    wasi_fs::RIGHTS_FD_WRITE
                        | wasi_fs::RIGHTS_FD_ADVISE
                        | wasi_fs::RIGHTS_FD_ALLOCATE
                        | wasi_fs::RIGHTS_FD_DATASYNC
                        | wasi_fs::RIGHTS_FD_FDSTAT_SET_FLAGS
                        | wasi_fs::RIGHTS_FD_FILESTAT_SET_SIZE
                        | wasi_fs::RIGHTS_FD_FILESTAT_SET_TIMES
                        | wasi_fs::RIGHTS_FD_SYNC
                        | wasi_fs::RIGHTS_FD_WRITE
                } else {
                    0
                } | wasi_fs::RIGHTS_FD_FILESTAT_GET
                    | wasi_fs::RIGHTS_FD_SEEK
                    | wasi_fs::RIGHTS_POLL_FD_READWRITE
                    | wasi_fs::RIGHTS_FD_READ
                    | wasi_fs::RIGHTS_FD_READDIR;
                let (dir, file) = match wasi_fs::open_parent(path.as_str()) {
                    Ok(ok) => ok,
                    Err(e) => {
                        return {
                            let err = err_to_js_object(ctx, e);
                            JsValue::Exception(ctx.throw_error(err))
                        }
                    }
                };
                let res =
                    unsafe { wasi_fs::path_open(dir, 0, file.as_str(), oflag, right, 0, fdflag) };
                return match res {
                    Ok(fd) => JsValue::Int(fd as i32),
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn readlink_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    if let Some(JsValue::String(path)) = arg.get(0) {
        let mut buf = vec![0; 1024];
        let (dir, file) = match wasi_fs::open_parent(path.as_str().into()) {
            Ok(ok) => ok,
            Err(e) => {
                return {
                    let err = err_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            }
        };
        let res =
            unsafe { wasi_fs::path_readlink(dir, file.as_str(), buf.as_mut_ptr(), buf.len()) };
        return match res {
            Ok(_len) => match String::from_utf8(buf) {
                Ok(s) => ctx.new_string(s.as_str()).into(),
                Err(e) => ctx.new_error(e.to_string().as_str()),
            },
            Err(e) => {
                let err = errno_to_js_object(ctx, e);
                JsValue::Exception(ctx.throw_error(err))
            }
        };
    }
    return JsValue::UnDefined;
}

fn fwrite(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    let (promise, ok, error) = ctx.new_promise();
    let nctx = ctx.clone();
    let arg = arg.to_vec();
    if let Some(event_loop) = ctx.event_loop() {
        event_loop.add_immediate_task(Box::new(move || {
            let mut ctx = nctx;
            let r = fwrite_sync(&mut ctx, _this_val, &arg);
            match r {
                JsValue::UnDefined => {
                    if let JsValue::Function(resolve) = ok {
                        resolve.call(&[JsValue::UnDefined]);
                    };
                }
                JsValue::Int(len) => {
                    if let JsValue::Function(resolve) = ok {
                        resolve.call(&[JsValue::Int(len)]);
                    };
                }
                other => {
                    if let JsValue::Function(reject) = error {
                        reject.call(&[other]);
                    };
                }
            };
        }))
    }

    promise
}

fn fwrite_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    if let Some(JsValue::Int(fd)) = arg.get(0) {
        if let Some(JsValue::Int(position)) = arg.get(1) {
            if let Some(JsValue::ArrayBuffer(buf)) = arg.get(2) {
                if *position >= 0 {
                    let res = unsafe {
                        wasi_fs::fd_seek(*fd as u32, *position as i64, wasi_fs::WHENCE_SET)
                    };
                    if let Err(e) = res {
                        let err = errno_to_js_object(ctx, e);
                        return JsValue::Exception(ctx.throw_error(err));
                    }
                }
                let data = buf.to_vec();
                let res = unsafe {
                    wasi_fs::fd_write(
                        *fd as u32,
                        &[wasi_fs::Ciovec {
                            buf: data.as_ptr(),
                            buf_len: data.len(),
                        }],
                    )
                };
                return match res {
                    Ok(len) => JsValue::Int(len as i32),
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                };
            }
        }
    }
    return JsValue::UnDefined;
}

fn freaddir_sync(ctx: &mut Context, _this_val: JsValue, arg: &[JsValue]) -> JsValue {
    if let Some(JsValue::Int(fd)) = arg.get(0) {
        if let Some(JsValue::Int(cookie)) = arg.get(1) {
            let mut buf = vec![0; 4096];
            let res = unsafe {
                wasi_fs::fd_readdir(*fd as u32, buf.as_mut_ptr(), buf.len(), *cookie as u64)
            };
            return match res {
                Ok(len) => {
                    let s = std::mem::size_of::<wasi_fs::Dirent>();
                    let mut idx = 0;
                    let mut data_pack = ctx.new_array();
                    let mut aidx = 0;
                    let mut dir_next = 0;
                    while (idx + s) < len.min(4096) {
                        let dir = unsafe {
                            (&buf[idx..(idx + s)] as *const [u8] as *const wasi_fs::Dirent)
                                .as_ref()
                                .unwrap()
                                .clone()
                        };
                        idx += s;
                        if (idx + dir.d_namlen as usize) > len.min(4096) {
                            break;
                        }
                        let name =
                            String::from_utf8_lossy(&buf[idx..(idx + dir.d_namlen as usize)])
                                .to_string();
                        idx += dir.d_namlen as usize;
                        let mut dirent = ctx.new_object();

                        dirent.set(""filetype"", JsValue::Int(dir.d_type.raw() as i32));
                        dirent.set(""name"", ctx.new_string(name.as_str()).into());
                        data_pack.put(aidx, dirent.into());
                        dir_next = dir.d_next;
                        aidx += 1;
                    }
                    let mut data = ctx.new_object();
                    data.set(""res"", data_pack.into());
                    data.set(""fin"", (len < buf.len()).into());
                    data.set(""cookie"", JsValue::Int(dir_next as i32));
                    data.into()
                }
                Err(e) => {
                    let err = errno_to_js_object(ctx, e);
                    JsValue::Exception(ctx.throw_error(err))
                }
            };
        }
    }
    return JsValue::UnDefined;
}

struct FS;

impl ModuleInit for FS {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
        let stat_s = ctx.wrap_function(""statSync"", stat_sync);
        let lstat_s = ctx.wrap_function(""lstatSync"", lstat_sync);
        let fstat_s = ctx.wrap_function(""fstatSync"", fstat_sync);
        let mkdir_s = ctx.wrap_function(""mkdirSync"", mkdir_sync);
        let rmdir_s = ctx.wrap_function(""rmdirSync"", rmdir_sync);
        let rm_s = ctx.wrap_function(""rmSync"", rm_sync);
        let rename_s = ctx.wrap_function(""renameSync"", rename_sync);
        let truncate_s = ctx.wrap_function(""truncateSync"", truncate_sync);
        let ftruncate_s = ctx.wrap_function(""ftruncateSync"", ftruncate_sync);
        let realpath_s = ctx.wrap_function(""realpathSync"", realpath_sync);
        let copy_file_s = ctx.wrap_function(""copyFileSync"", copy_file_sync);
        let link_s = ctx.wrap_function(""linkSync"", link_sync);
        let symlink_s = ctx.wrap_function(""symlinkSync"", symlink_sync);
        let utime_s = ctx.wrap_function(""utimeSync"", utime_sync);
        let lutime_s = ctx.wrap_function(""lutimeSync"", lutime_sync);
        let futime_s = ctx.wrap_function(""futimeSync"", futime_sync);
        let fclose_s = ctx.wrap_function(""fcloseSync"", fclose_sync);
        let fsync_s = ctx.wrap_function(""fsyncSync"", fsync_sync);
        let fdatasync_s = ctx.wrap_function(""fdatasyncSync"", fdatasync_sync);
        let fread_s = ctx.wrap_function(""freadSync"", fread_sync);
        let fread_a = ctx.wrap_function(""fread"", fread);
        let open_s = ctx.wrap_function(""openSync"", open_sync);
        let readlink_s = ctx.wrap_function(""readlinkSync"", readlink_sync);
        let fwrite_s = ctx.wrap_function(""fwriteSync"", fwrite_sync);
        let fwrite_a = ctx.wrap_function(""fwrite"", fwrite);
        let freaddir_s = ctx.wrap_function(""freaddirSync"", freaddir_sync);
        m.add_export(""statSync"", stat_s.into());
        m.add_export(""lstatSync"", lstat_s.into());
        m.add_export(""fstatSync"", fstat_s.into());
        m.add_export(""mkdirSync"", mkdir_s.into());
        m.add_export(""rmdirSync"", rmdir_s.into());
        m.add_export(""rmSync"", rm_s.into());
        m.add_export(""renameSync"", rename_s.into());
        m.add_export(""truncateSync"", truncate_s.into());
        m.add_export(""ftruncateSync"", ftruncate_s.into());
        m.add_export(""realpathSync"", realpath_s.into());
        m.add_export(""copyFileSync"", copy_file_s.into());
        m.add_export(""linkSync"", link_s.into());
        m.add_export(""symlinkSync"", symlink_s.into());
        m.add_export(""utimeSync"", utime_s.into());
        m.add_export(""lutimeSync"", lutime_s.into());
        m.add_export(""futimeSync"", futime_s.into());
        m.add_export(""fcloseSync"", fclose_s.into());
        m.add_export(""fsyncSync"", fsync_s.into());
        m.add_export(""fdatasyncSync"", fdatasync_s.into());
        m.add_export(""freadSync"", fread_s.into());
        m.add_export(""fread"", fread_a.into());
        m.add_export(""openSync"", open_s.into());
        m.add_export(""readlinkSync"", readlink_s.into());
        m.add_export(""fwriteSync"", fwrite_s.into());
        m.add_export(""fwrite"", fwrite_a.into());
        m.add_export(""freaddirSync"", freaddir_s.into());
    }
}

pub fn init_module(ctx: &mut Context) {
    ctx.register_module(
        ""_node:fs\0"",
        FS,
        &[
            ""statSync\0"",
            ""lstatSync\0"",
            ""fstatSync\0"",
            ""mkdirSync\0"",
            ""rmdirSync\0"",
            ""rmSync\0"",
            ""renameSync\0"",
            ""truncateSync\0"",
            ""ftruncateSync\0"",
            ""realpathSync\0"",
            ""copyFileSync\0"",
            ""linkSync\0"",
            ""symlinkSync\0"",
            ""utimeSync\0"",
            ""lutimeSync\0"",
            ""futimeSync\0"",
            ""fcloseSync\0"",
            ""fsyncSync\0"",
            ""fdatasyncSync\0"",
            ""freadSync\0"",
            ""fread\0"",
            ""openSync\0"",
            ""readlinkSync\0"",
            ""fwriteSync\0"",
            ""fwrite\0"",
            ""freaddirSync\0"",
        ],
    )
}
"
modules/internal/streams/writable.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { addAbortSignalNoValidate } from ""./add-abort-signal.js"";
import { Buffer } from ""buffer"";
import { getDefaultHighWaterMark, getHighWaterMark } from ""./state.js"";
import { isUint8Array } from ""../util/types.js"";
import { Stream } from ""./legacy.js"";
import {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING,
} from ""../errors.js"";
import destroyImpl from ""./destroy.js"";
import EE from ""events"";
import Readable from ""./readable.js"";

function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(
        chunk.buffer,
        chunk.byteOffset,
        chunk.byteLength,
    );
}

const { errorOrDestroy } = destroyImpl;

// This function prevents a circular dependency with Duplex
// This checks if the passed stream is an instance of a Readable stream
// and one of its prototypes is named Duplex
function isDuplexStream(maybe_duplex) {
    const isReadable = Readable.prototype.isPrototypeOf(maybe_duplex);

    let prototype = maybe_duplex;
    let isDuplex = false;
    while (prototype?.constructor && prototype.constructor.name !== ""Object"") {
        if (prototype.constructor.name === ""Duplex"") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }

    return isReadable && isDuplex;
}


function nop() { }

const kOnFinished = Symbol(""kOnFinished"");

function WritableState(options, stream, isDuplex) {
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== ""boolean"") {
        isDuplex = isDuplexStream(stream);
    }

    // Object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!(options && options.objectMode);

    if (isDuplex) {
        this.objectMode = this.objectMode ||
            !!(options && options.writableObjectMode);
    }

    // The point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write().
    this.highWaterMark = options
        ? getHighWaterMark(this, options, ""writableHighWaterMark"", isDuplex)
        : getDefaultHighWaterMark(false);

    // if _final has been called.
    this.finalCalled = false;

    // drain event flag.
    this.needDrain = false;
    // At the start of calling end()
    this.ending = false;
    // When end() has been called, and returned.
    this.ended = false;
    // When 'finish' is emitted.
    this.finished = false;

    // Has it been destroyed
    this.destroyed = false;

    // Should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = (options && options.defaultEncoding) || ""utf8"";

    // Not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;

    // A flag to see when we're in the middle of a write.
    this.writing = false;

    // When true all writes will be buffered until .uncork() call.
    this.corked = 0;

    // A flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until ""later"" should generally also
    // not happen before the first write call.
    this.sync = true;

    // A flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;

    // The callback that's passed to _write(chunk, cb).
    this.onwrite = onwrite.bind(undefined, stream);

    // The callback that the user supplies to write(chunk, encoding, cb).
    this.writecb = null;

    // The amount that is being written when _write is called.
    this.writelen = 0;

    // Storage for data passed to the afterWrite() callback in case of
    // synchronous _write() completion.
    this.afterWriteTickInfo = null;

    resetBuffer(this);

    // Number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted.
    this.pendingcb = 0;

    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    this.constructed = true;

    // Emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams.
    this.prefinished = false;

    // True if the error was already emitted and should not be thrown again.
    this.errorEmitted = false;

    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = !options || options.emitClose !== false;

    // Should .destroy() be called after 'finish' (and potentially 'end').
    this.autoDestroy = !options || options.autoDestroy !== false;

    // Indicates whether the stream has errored. When true all write() calls
    // should return false. This is needed since when autoDestroy
    // is disabled we need a way to tell whether the stream has failed.
    this.errored = null;

    // Indicates whether the stream has finished destroying.
    this.closed = false;

    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    this.closeEmitted = false;

    this[kOnFinished] = [];
}

function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
}

WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};

Object.defineProperty(WritableState.prototype, ""bufferedRequestCount"", {
    get() {
        return this.buffered.length - this.bufferedIndex;
    },
});

function Writable(options) {
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.

    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.

    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5.
    const isDuplex = isDuplexStream(this);

    if (
        !isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)
    ) {
        return new Writable(options);
    }

    this._writableState = new WritableState(options, this, isDuplex);

    if (options) {
        if (typeof options.write === ""function"") {
            this._write = options.write;
        }

        if (typeof options.writev === ""function"") {
            this._writev = options.writev;
        }

        if (typeof options.destroy === ""function"") {
            this._destroy = options.destroy;
        }

        if (typeof options.final === ""function"") {
            this._final = options.final;
        }

        if (typeof options.construct === ""function"") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }

    Stream.call(this, options);

    destroyImpl.construct(this, () => {
        const state = this._writableState;

        if (!state.writing) {
            clearBuffer(this, state);
        }

        finishMaybe(this, state);
    });
}

Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);

Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;

        return object && object._writableState instanceof WritableState;
    },
});

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;

    if (typeof encoding === ""function"") {
        cb = encoding;
        encoding = state.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state.defaultEncoding;
        } else if (encoding !== ""buffer"" && !Buffer.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== ""function"") {
            cb = nop;
        }
    }

    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state.objectMode) {
        if (typeof chunk === ""string"") {
            if (state.decodeStrings !== false) {
                chunk = Buffer.from(chunk, encoding);
                encoding = ""buffer"";
            }
        } else if (chunk instanceof Buffer) {
            encoding = ""buffer"";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = ""buffer"";
        } else {
            throw new ERR_INVALID_ARG_TYPE(
                ""chunk"",
                [""string"", ""Buffer"", ""Uint8Array""],
                chunk,
            );
        }
    }

    let err;
    if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED(""write"");
    }

    if (err) {
        nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
}

Writable.prototype.write = function (chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};

Writable.prototype.cork = function () {
    this._writableState.corked++;
};

Writable.prototype.uncork = function () {
    const state = this._writableState;

    if (state.corked) {
        state.corked--;

        if (!state.writing) {
            clearBuffer(this, state);
        }
    }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === ""string"") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};

// If we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;

    state.length += len;

    // stream._write resets state.length
    const ret = state.length < state.highWaterMark;
    // We must ensure that previous needDrain will not be reset to false.
    if (!ret) {
        state.needDrain = true;
    }

    if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({ chunk, encoding, callback });
        if (state.allBuffers && encoding !== ""buffer"") {
            state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
            state.allNoop = false;
        }
    } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
    }

    // Return false if errored or destroyed in order to break
    // any synchronous while(stream.write(data)) loops.
    return ret && !state.errored && !state.destroyed;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) {
        state.onwrite(new ERR_STREAM_DESTROYED(""write""));
    } else if (writev) {
        stream._writev(chunk, state.onwrite);
    } else {
        stream._write(chunk, encoding, state.onwrite);
    }
    state.sync = false;
}

function onwriteError(stream, state, er, cb) {
    --state.pendingcb;

    cb(er);
    // Ensure callbacks are invoked even when autoDestroy is
    // not enabled. Passing `er` here doesn't make sense since
    // it's related to one specific write, not to the buffered
    // writes.
    errorBuffer(state);
    // This can emit error, but error must always follow cb.
    errorOrDestroy(stream, er);
}

function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;

    if (typeof cb !== ""function"") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }

    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;

    if (er) {
        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
        er.stack; // eslint-disable-line no-unused-expressions

        if (!state.errored) {
            state.errored = er;
        }

        // In case of duplex streams we need to notify the readable side of the
        // error.
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }

        if (sync) {
            nextTick(onwriteError, stream, state, er, cb);
        } else {
            onwriteError(stream, state, er, cb);
        }
    } else {
        if (state.buffered.length > state.bufferedIndex) {
            clearBuffer(stream, state);
        }

        if (sync) {
            // It is a common case that the callback passed to .write() is always
            // the same. In that case, we do not schedule a new nextTick(), but
            // rather just increase a counter, to improve performance and avoid
            // memory allocations.
            if (
                state.afterWriteTickInfo !== null &&
                state.afterWriteTickInfo.cb === cb
            ) {
                state.afterWriteTickInfo.count++;
            } else {
                state.afterWriteTickInfo = { count: 1, cb, stream, state };
                nextTick(afterWriteTick, state.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state, 1, cb);
        }
    }
}

function afterWriteTick({ stream, state, count, cb }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
}

function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&
        state.needDrain;
    if (needDrain) {
        state.needDrain = false;
        stream.emit(""drain"");
    }

    while (count-- > 0) {
        state.pendingcb--;
        cb();
    }

    if (state.destroyed) {
        errorBuffer(state);
    }

    finishMaybe(stream, state);
}

// If there's something in the buffer waiting, then invoke callbacks.
function errorBuffer(state) {
    if (state.writing) {
        return;
    }

    for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(new ERR_STREAM_DESTROYED(""write""));
    }

    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](new ERR_STREAM_DESTROYED(""end""));
    }

    resetBuffer(state);
}

// If there's something in the buffer waiting, then process it.
function clearBuffer(stream, state) {
    if (
        state.corked ||
        state.bufferProcessing ||
        state.destroyed ||
        !state.constructed
    ) {
        return;
    }

    const { buffered, bufferedIndex, objectMode } = state;
    const bufferedLength = buffered.length - bufferedIndex;

    if (!bufferedLength) {
        return;
    }

    let i = bufferedIndex;

    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;

        const callback = state.allNoop ? nop : (err) => {
            for (let n = i; n < buffered.length; ++n) {
                buffered[n].callback(err);
            }
        };
        // Make a copy of `buffered` if it's going to be used by `callback` above,
        // since `doWrite` will mutate the array.
        const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
        chunks.allBuffers = state.allBuffers;

        doWrite(stream, state, true, state.length, chunks, """", callback);

        resetBuffer(state);
    } else {
        do {
            const { chunk, encoding, callback } = buffered[i];
            buffered[i++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);

        if (i === buffered.length) {
            resetBuffer(state);
        } else if (i > 256) {
            buffered.splice(0, i);
            state.bufferedIndex = 0;
        } else {
            state.bufferedIndex = i;
        }
    }
    state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
    if (this._writev) {
        this._writev([{ chunk, encoding }], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED(""_write()"");
    }
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
    const state = this._writableState;

    if (typeof chunk === ""function"") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === ""function"") {
        cb = encoding;
        encoding = null;
    }

    let err;

    if (chunk !== null && chunk !== undefined) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error) {
            err = ret;
        }
    }

    // .end() fully uncorks.
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }

    if (err) {
        // Do nothing...
    } else if (!state.errored && !state.ending) {
        // This is forgiving in terms of unnecessary calls to end() and can hide
        // logic errors. However, usually such errors are harmless and causing a
        // hard error can be disproportionately destructive. It is not always
        // trivial for the user to determine whether end() needs to be called
        // or not.

        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
    } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED(""end"");
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED(""end"");
    }

    if (typeof cb === ""function"") {
        if (err || state.finished) {
            nextTick(cb, err);
        } else {
            state[kOnFinished].push(cb);
        }
    }

    return this;
};

function needFinish(state) {
    return (state.ending &&
        state.constructed &&
        state.length === 0 &&
        !state.errored &&
        state.buffered.length === 0 &&
        !state.finished &&
        !state.writing &&
        !state.errorEmitted &&
        !state.closeEmitted);
}

function callFinal(stream, state) {
    let called = false;

    function onFinish(err) {
        if (called) {
            errorOrDestroy(stream, err ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;

        state.pendingcb--;
        if (err) {
            const onfinishCallbacks = state[kOnFinished].splice(0);
            for (let i = 0; i < onfinishCallbacks.length; i++) {
                onfinishCallbacks[i](err);
            }
            errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
            state.prefinished = true;
            stream.emit(""prefinish"");
            // Backwards compat. Don't check state.sync here.
            // Some streams assume 'finish' will be emitted
            // asynchronously relative to _final callback.
            state.pendingcb++;
            nextTick(finish, stream, state);
        }
    }

    state.sync = true;
    state.pendingcb++;

    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    function () {
                        nextTick(onFinish, null);
                    },
                    function (err) {
                        nextTick(onFinish, err);
                    },
                );
            }
        }
    } catch (err) {
        onFinish(stream, state, err);
    }

    state.sync = false;
}

function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === ""function"" && !state.destroyed) {
            state.finalCalled = true;
            callFinal(stream, state);
        } else {
            state.prefinished = true;
            stream.emit(""prefinish"");
        }
    }
}

function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0 && needFinish(state)) {
            state.pendingcb++;
            if (sync) {
                nextTick(finish, stream, state);
            } else {
                finish(stream, state);
            }
        }
    }
}

function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;

    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
    }

    stream.emit(""finish"");

    if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well.
        const rState = stream._readableState;
        const autoDestroy = !rState || (
            rState.autoDestroy &&
            // We don't expect the readable to ever 'end'
            // if readable is explicitly set to false.
            (rState.endEmitted || rState.readable === false)
        );
        if (autoDestroy) {
            stream.destroy();
        }
    }
}

Object.defineProperties(Writable.prototype, {
    destroyed: {
        get() {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
            // Backward compatibility, the user is explicitly managing destroyed.
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        },
    },

    writable: {
        get() {
            const w = this._writableState;
            // w.writable === false means that this is part of a Duplex stream
            // where the writable side was disabled upon construction.
            // Compat. The user might manually disable writable side through
            // deprecated setter.
            return !!w && w.writable !== false && !w.destroyed && !w.errored &&
                !w.ending && !w.ended;
        },
        set(val) {
            // Backwards compatible.
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        },
    },

    writableFinished: {
        get() {
            return this._writableState ? this._writableState.finished : false;
        },
    },

    writableObjectMode: {
        get() {
            return this._writableState ? this._writableState.objectMode : false;
        },
    },

    writableBuffer: {
        get() {
            return this._writableState && this._writableState.getBuffer();
        },
    },

    writableEnded: {
        get() {
            return this._writableState ? this._writableState.ending : false;
        },
    },

    writableNeedDrain: {
        get() {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        },
    },

    writableHighWaterMark: {
        get() {
            return this._writableState && this._writableState.highWaterMark;
        },
    },

    writableCorked: {
        get() {
            return this._writableState ? this._writableState.corked : 0;
        },
    },

    writableLength: {
        get() {
            return this._writableState && this._writableState.length;
        },
    },
});

const destroy = destroyImpl.destroy;
Writable.prototype.destroy = function (err, cb) {
    const state = this._writableState;

    // Invoke pending callbacks.
    if (
        !state.destroyed &&
        (state.bufferedIndex < state.buffered.length ||
            state[kOnFinished].length)
    ) {
        nextTick(errorBuffer, state);
    }

    destroy.call(this, err, cb);
    return this;
};

Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
    cb(err);
};

Writable.prototype[EE.captureRejectionSymbol] = function (err) {
    this.destroy(err);
};

Writable.WritableState = WritableState;

export default Writable;
export { Writable, WritableState };"
test/fs/test-fs-cp.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import { mustCall, mustNotMutateObjectDeep } from '../common';

import assert from 'assert';
import fs from 'fs';
const {
  cp,
  cpSync,
  lstatSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  readlinkSync,
  symlinkSync,
  statSync,
  writeFileSync,
} = fs;
// import net from 'net';
import { join } from 'path';
import { pathToFileURL } from 'url';
import process from 'process';

const setTimeoutAsync = (timeout, val) => {
  print(""setTimeoutAsync"", timeout)
  return new Promise((res, rej) => {
    setTimeout(() => {
      res(val);
    }, timeout);
  })
}

const isWindows = process.platform === 'win32';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

let dirc = 0;
function nextdir() {
  return join(tmpdir.path, `copy_${++dirc}`);
}

// Synchronous implementation of copy.

// It copies a nested folder structure with files and folders.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assertDirEquivalent(src, dest);
}

// It does not throw errors when directory is copied over and force is false.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'README.md'), 'hello world', 'utf8');
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  const initialStat = lstatSync(join(dest, 'README.md'));
  cpSync(src, dest, mustNotMutateObjectDeep({ force: false, recursive: true }));
  // File should not have been copied over, so access times will be identical:
  assertDirEquivalent(src, dest);
  const finalStat = lstatSync(join(dest, 'README.md'));
  assert.strictEqual(finalStat.ctime.getTime(), initialStat.ctime.getTime());
}

// It overwrites existing files if force is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'README.md'), '# Goodbye', 'utf8');
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assertDirEquivalent(src, dest);
  const content = readFileSync(join(dest, 'README.md'), 'utf8');
  assert.strictEqual(content.trim(), '# Hello');
}

// It does not fail if the same directory is copied to dest twice,
// when dereference is true, and force is false (fails silently).
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const destFile = join(dest, 'a/b/README2.md');
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  const stat = lstatSync(destFile);
  assert(stat.isFile());
}

// path_readlink is unusable in wasmedge, so skip the tests about symlink
/*
// It copies file itself, rather than symlink, when dereference is true.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync(join(src, 'foo.js'), join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  const destFile = join(dest, 'foo.js');

  cpSync(join(src, 'bar.js'), destFile, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  const stat = lstatSync(destFile);
  assert(stat.isFile());
}


// It throws error when verbatimSymlinks is not a boolean.
{
  const src = './test/fixtures/copy/kitchen-sink';
  [1, [], {}, null, 1n, undefined, null, Symbol(), '', () => { }]
    .forEach((verbatimSymlinks) => {
      assert.throws(
        () => cpSync(src, src, { verbatimSymlinks }),
        { code: 'ERR_INVALID_ARG_TYPE' }
      );
    });
}


// It throws an error when both dereference and verbatimSymlinks are enabled.
{
  const src = './test/fixtures/copy/kitchen-sink';
  assert.throws(
    () => cpSync(src, src, mustNotMutateObjectDeep({ dereference: true, verbatimSymlinks: true })),
    { code: 'ERR_INCOMPATIBLE_OPTION_PAIR' }
  );
}


// It resolves relative symlinks to their absolute path by default.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync('foo.js', join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));

  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  const link = readlinkSync(join(dest, 'bar.js'));
  assert.strictEqual(link, join(src, 'foo.js'));
}


// It resolves relative symlinks when verbatimSymlinks is false.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync('foo.js', join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));

  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true, verbatimSymlinks: false }));
  const link = readlinkSync(join(dest, 'bar.js'));
  assert.strictEqual(link, join(src, 'foo.js'));
}


// It does not resolve relative symlinks when verbatimSymlinks is true.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync('foo.js', join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));

  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true, verbatimSymlinks: true }));
  const link = readlinkSync(join(dest, 'bar.js'));
  assert.strictEqual(link, 'foo.js');
}

*/
// It throws error when src and dest are identical.
{
  const src = './test/fixtures/copy/kitchen-sink';
  assert.throws(
    () => cpSync(src, src),
    { code: 'ERR_FS_CP_EINVAL' }
  );
}
/*
// It throws error if symlink in src points to location in dest.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest);
  symlinkSync(dest, join(src, 'link'));
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.throws(
    () => cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true })),
    {
      code: 'ERR_FS_CP_EINVAL'
    }
  );
}

// It throws error if symlink in dest points to location in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(dest, 'a', 'c'));
  assert.throws(
    () => cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true })),
    { code: 'ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY' }
  );
}

// It throws error if parent directory of symlink in dest points to src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  // Create symlink in dest pointing to src.
  const destLink = join(dest, 'b');
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, destLink);
  assert.throws(
    () => cpSync(src, join(dest, 'b', 'c')),
    { code: 'ERR_FS_CP_EINVAL' }
  );
}
*/
// It throws error if attempt is made to copy directory to file.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = './test/fixtures/copy/kitchen-sink/README.md';
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_CP_DIR_TO_NON_DIR' }
  );
}

// It allows file to be copied to a file path.
{
  const srcFile = './test/fixtures/copy/kitchen-sink/index.js';
  const destFile = join(nextdir(), 'index.js');
  cpSync(srcFile, destFile, mustNotMutateObjectDeep({ dereference: true }));
  const stat = lstatSync(destFile);
  assert(stat.isFile());
}

// It throws error if directory copied without recursive flag.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_EISDIR' }
  );
}


// It throws error if attempt is made to copy file to directory.
{
  const src = './test/fixtures/copy/kitchen-sink/README.md';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_CP_NON_DIR_TO_DIR' }
  );
}

// It throws error if attempt is made to copy to subdirectory of self.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = './test/fixtures/copy/kitchen-sink/a';
  assert.throws(
    () => cpSync(src, dest),
    { code: 'ERR_FS_CP_EINVAL' }
  );
}

// It throws an error if attempt is made to copy socket.
if (!isWindows && false) {
  const dest = nextdir();
  const sock = `${process.pid}.sock`;
  const server = net.createServer();
  server.listen(sock);
  assert.throws(
    () => cpSync(sock, dest),
    { code: 'ERR_FS_CP_SOCKET' }
  );
  server.close();
}

// It copies timestamps from src to dest if preserveTimestamps is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ preserveTimestamps: true, recursive: true }));
  assertDirEquivalent(src, dest);
  const srcStat = lstatSync(join(src, 'index.js'));
  const destStat = lstatSync(join(dest, 'index.js'));
  assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
}

// It applies filter function.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, {
    filter: (path) => {
      const pathStat = statSync(path);
      return pathStat.isDirectory() || path.endsWith('.js');
    },
    dereference: true,
    recursive: true,
  });
  const destEntries = [];
  collectEntries(dest, destEntries);
  for (const entry of destEntries) {
    assert.strictEqual(
      entry.isDirectory() || entry.name.endsWith('.js'),
      true
    );
  }
}

// It throws error if filter function is asynchronous.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  assert.throws(() => {
    cpSync(src, dest, {
      filter: async (path) => {
        await setTimeoutAsync(500, 'done');
        const pathStat = statSync(path);
        return pathStat.isDirectory() || path.endsWith('.js');
      },
      dereference: true,
      recursive: true,
    });
  }, { code: 'ERR_INVALID_RETURN_VALUE' });
}

// It throws error if errorOnExist is true, force is false, and file or folder
// copied over.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.throws(
    () => cpSync(src, dest, {
      dereference: true,
      errorOnExist: true,
      force: false,
      recursive: true,
    }),
    { code: 'ERR_FS_CP_EEXIST' }
  );
}
/*
// It throws EEXIST error if attempt is made to copy symlink over file.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'a', 'c'), 'hello', 'utf8');
  assert.throws(
    () => cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true })),
    { code: 'EEXIST' }
  );
}
*/
// It makes file writeable when updating timestamp, if not writeable.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.txt'), 'foo', mustNotMutateObjectDeep({ mode: 0o444 }));
  cpSync(src, dest, mustNotMutateObjectDeep({ preserveTimestamps: true, recursive: true }));
  assertDirEquivalent(src, dest);
  const srcStat = lstatSync(join(src, 'foo.txt'));
  const destStat = lstatSync(join(dest, 'foo.txt'));
  assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
}
/*
// It copies link if it does not point to folder in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(src, 'a', 'c'));
  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(dest, join(dest, 'a', 'c'));
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  const link = readlinkSync(join(dest, 'a', 'c'));
  assert.strictEqual(link, src);
}
*/
// It accepts file URL as src and dest.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(pathToFileURL(src), pathToFileURL(dest), mustNotMutateObjectDeep({ recursive: true }));
  assertDirEquivalent(src, dest);
}

// It throws if options is not object.
{
  assert.throws(
    () => cpSync('a', 'b', () => { }),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
}

// Callback implementation of copy.

// It copies a nested folder structure with files and folders.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
  }));
}

// It does not throw errors when directory is copied over and force is false.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'README.md'), 'hello world', 'utf8');
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  const initialStat = lstatSync(join(dest, 'README.md'));
  cp(src, dest, {
    dereference: true,
    force: false,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    // File should not have been copied over, so access times will be identical:
    const finalStat = lstatSync(join(dest, 'README.md'));
    assert.strictEqual(finalStat.ctime.getTime(), initialStat.ctime.getTime());
  }));
}

// It overwrites existing files if force is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'README.md'), '# Goodbye', 'utf8');

  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    const content = readFileSync(join(dest, 'README.md'), 'utf8');
    assert.strictEqual(content.trim(), '# Hello');
  }));
}

// It does not fail if the same directory is copied to dest twice,
// when dereference is true, and force is false (fails silently).
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const destFile = join(dest, 'a/b/README2.md');
  cpSync(src, dest, mustNotMutateObjectDeep({ dereference: true, recursive: true }));
  cp(src, dest, {
    dereference: true,
    recursive: true
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    const stat = lstatSync(destFile);
    assert(stat.isFile());
  }));
}
/*
// It copies file itself, rather than symlink, when dereference is true.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.js'), 'foo', 'utf8');
  symlinkSync(join(src, 'foo.js'), join(src, 'bar.js'));

  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  const destFile = join(dest, 'foo.js');

  cp(join(src, 'bar.js'), destFile, mustNotMutateObjectDeep({ dereference: true }),
    mustCall((err) => {
      assert.strictEqual(err, null);
      const stat = lstatSync(destFile);
      assert(stat.isFile());
    })
  );
}
*/
// It returns error when src and dest are identical.
{
  const src = './test/fixtures/copy/kitchen-sink';
  cp(src, src, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}
/*
// It returns error if symlink in src points to location in dest.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest);
  symlinkSync(dest, join(src, 'link'));
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}

// It returns error if symlink in dest points to location in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(dest, 'a', 'c'));
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY');
  }));
}

// It returns error if parent directory of symlink in dest points to src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  // Create symlink in dest pointing to src.
  const destLink = join(dest, 'b');
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, destLink);
  cp(src, join(dest, 'b', 'c'), mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}
*/
// It returns error if attempt is made to copy directory to file.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = './test/fixtures/copy/kitchen-sink/README.md';
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_DIR_TO_NON_DIR');
  }));
}

// It allows file to be copied to a file path.
{
  const srcFile = './test/fixtures/copy/kitchen-sink/README.md';
  const destFile = join(nextdir(), 'index.js');
  cp(srcFile, destFile, mustNotMutateObjectDeep({ dereference: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    const stat = lstatSync(destFile);
    assert(stat.isFile());
  }));
}

// It returns error if directory copied without recursive flag.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_EISDIR');
  }));
}

// It returns error if attempt is made to copy file to directory.
{
  const src = './test/fixtures/copy/kitchen-sink/README.md';
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_NON_DIR_TO_DIR');
  }));
}

// It returns error if attempt is made to copy to subdirectory of self.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = './test/fixtures/copy/kitchen-sink/a';
  cp(src, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EINVAL');
  }));
}

// It returns an error if attempt is made to copy socket.
if (!isWindows && false) {
  const dest = nextdir();
  const sock = `${process.pid}.sock`;
  const server = net.createServer();
  server.listen(sock);
  cp(sock, dest, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_SOCKET');
    server.close();
  }));
}

// It copies timestamps from src to dest if preserveTimestamps is true.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, {
    preserveTimestamps: true,
    recursive: true
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    const srcStat = lstatSync(join(src, 'index.js'));
    const destStat = lstatSync(join(dest, 'index.js'));
    assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
  }));
}

// It applies filter function.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, {
    filter: (path) => {
      const pathStat = statSync(path);
      return pathStat.isDirectory() || path.endsWith('.js');
    },
    dereference: true,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    const destEntries = [];
    collectEntries(dest, destEntries);
    for (const entry of destEntries) {
      assert.strictEqual(
        entry.isDirectory() || entry.name.endsWith('.js'),
        true
      );
    }
  }));
}

// It supports async filter function.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(src, dest, {
    filter: async (path) => {
      await setTimeout(5, 'done');
      const pathStat = statSync(path);
      return pathStat.isDirectory() || path.endsWith('.js');
    },
    dereference: true,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    const destEntries = [];
    collectEntries(dest, destEntries);
    for (const entry of destEntries) {
      assert.strictEqual(
        entry.isDirectory() || entry.name.endsWith('.js'),
        true
      );
    }
  }));
}

// It returns error if errorOnExist is true, force is false, and file or folder
// copied over.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cpSync(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  cp(src, dest, {
    dereference: true,
    errorOnExist: true,
    force: false,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err.code, 'ERR_FS_CP_EEXIST');
  }));
}
/*
// It returns EEXIST error if attempt is made to copy symlink over file.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(join(src, 'a', 'b'), join(src, 'a', 'c'));

  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(dest, 'a', 'c'), 'hello', 'utf8');
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err.code, 'EEXIST');
  }));
}
*/
// It makes file writeable when updating timestamp, if not writeable.
{
  const src = nextdir();
  mkdirSync(src, mustNotMutateObjectDeep({ recursive: true }));
  const dest = nextdir();
  mkdirSync(dest, mustNotMutateObjectDeep({ recursive: true }));
  writeFileSync(join(src, 'foo.txt'), 'foo', mustNotMutateObjectDeep({ mode: 0o444 }));
  cp(src, dest, {
    preserveTimestamps: true,
    recursive: true,
  }, mustCall((err) => {
    assert.strictEqual(err, null);
    assertDirEquivalent(src, dest);
    const srcStat = lstatSync(join(src, 'foo.txt'));
    const destStat = lstatSync(join(dest, 'foo.txt'));
    assert.strictEqual(srcStat.mtime.getTime(), destStat.mtime.getTime());
  }));
}
/*
// It copies link if it does not point to folder in src.
{
  const src = nextdir();
  mkdirSync(join(src, 'a', 'b'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(src, join(src, 'a', 'c'));
  const dest = nextdir();
  mkdirSync(join(dest, 'a'), mustNotMutateObjectDeep({ recursive: true }));
  symlinkSync(dest, join(dest, 'a', 'c'));
  cp(src, dest, mustNotMutateObjectDeep({ recursive: true }), mustCall((err) => {
    assert.strictEqual(err, null);
    const link = readlinkSync(join(dest, 'a', 'c'));
    assert.strictEqual(link, src);
  }));
}
*/
// It accepts file URL as src and dest.
{
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  cp(pathToFileURL(src), pathToFileURL(dest), mustNotMutateObjectDeep({ recursive: true }),
    mustCall((err) => {
      assert.strictEqual(err, null);
      assertDirEquivalent(src, dest);
    }));
}

// It throws if options is not object.
{
  assert.throws(
    () => cp('a', 'b', 'hello', () => { }),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
}

// Promises implementation of copy.

// It copies a nested folder structure with files and folders.
(async function () {
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const p = await fs.promises.cp(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(p, undefined);
  assertDirEquivalent(src, dest);
})();

// It accepts file URL as src and dest.
(async function () {
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  const p = await fs.promises.cp(
    pathToFileURL(src),
    pathToFileURL(dest),
    { recursive: true }
  );
  assert.strictEqual(p, undefined);
  assertDirEquivalent(src, dest);
})();

// It allows async error to be caught.
(async function () {
  const src = './test/fixtures/copy/kitchen-sink';
  const dest = nextdir();
  await fs.promises.cp(src, dest, mustNotMutateObjectDeep({ recursive: true }));
  await assert.rejects(
    fs.promises.cp(src, dest, {
      dereference: true,
      errorOnExist: true,
      force: false,
      recursive: true,
    }),
    { code: 'ERR_FS_CP_EEXIST' }
  );
})();

// It rejects if options is not object.
(async function () {
  await assert.rejects(
    fs.promises.cp('a', 'b', () => { }),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
})();

function assertDirEquivalent(dir1, dir2) {
  const dir1Entries = [];
  collectEntries(dir1, dir1Entries);
  const dir2Entries = [];
  collectEntries(dir2, dir2Entries);
  assert.strictEqual(dir1Entries.length, dir2Entries.length);
  for (const entry1 of dir1Entries) {
    const entry2 = dir2Entries.find((entry) => {
      return entry.name === entry1.name;
    });
    assert(entry2, `entry ${entry2.name} not copied`);
    if (entry1.isFile()) {
      assert(entry2.isFile(), `${entry2.name} was not file`);
    } else if (entry1.isDirectory()) {
      assert(entry2.isDirectory(), `${entry2.name} was not directory`);
    } else if (entry1.isSymbolicLink()) {
      assert(entry2.isSymbolicLink(), `${entry2.name} was not symlink`);
    }
  }
}

function collectEntries(dir, dirEntries) {
  const newEntries = readdirSync(dir, mustNotMutateObjectDeep({ withFileTypes: true }));
  for (const entry of newEntries) {
    if (entry.isDirectory()) {
      collectEntries(join(dir, entry.name), dirEntries);
    }
  }
  dirEntries.push(...newEntries);
}
"
test/crypto/test-crypto-key-objects.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const {
  createCipheriv,
  createDecipheriv,
  createSign,
  createVerify,
  createSecretKey,
  createPublicKey,
  createPrivateKey,
  KeyObject,
  randomBytes,
  publicDecrypt,
  publicEncrypt,
  privateDecrypt,
  privateEncrypt,
  getCurves,
  generateKeySync,
  generateKeyPairSync,
} = require('crypto');

const fixtures = require('../common/fixtures');

const publicPem = fixtures.readKey('rsa_public.pem', 'ascii');
const privatePem = fixtures.readKey('rsa_private.pem', 'ascii');

const publicDsa = fixtures.readKey('dsa_public_1025.pem', 'ascii');
const privateDsa = fixtures.readKey('dsa_private_encrypted_1025.pem',
                                    'ascii');

{
  // Attempting to create a key of a wrong type should throw
  const TYPE = 'wrong_type';

  assert.throws(() => new KeyObject(TYPE), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_VALUE',
    message: `The argument 'type' is invalid. Received '${TYPE}'`
  });
}

{
  // Attempting to create a key with non-object handle should throw
  assert.throws(() => new KeyObject('secret', ''), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message:
      'The ""handle"" argument must be of type object. Received type ' +
      ""string ('')""
  });
}

{
  assert.throws(() => KeyObject.from('invalid_key'), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message:
      'The ""key"" argument must be an instance of CryptoKey. Received type ' +
      ""string ('invalid_key')""
  });
}

{
  const keybuf = randomBytes(32);
  const key = createSecretKey(keybuf);
  assert.strictEqual(key.type, 'secret');
  assert.strictEqual(key.symmetricKeySize, 32);
  assert.strictEqual(key.asymmetricKeyType, undefined);
  assert.strictEqual(key.asymmetricKeyDetails, undefined);

  const exportedKey = key.export();
  assert(keybuf.equals(exportedKey));

  const plaintext = Buffer.from('Hello world', 'utf8');

  const cipher = createCipheriv('aes-256-ecb', key, null);
  const ciphertext = Buffer.concat([
    cipher.update(plaintext), cipher.final(),
  ]);

  const decipher = createDecipheriv('aes-256-ecb', key, null);
  const deciphered = Buffer.concat([
    decipher.update(ciphertext), decipher.final(),
  ]);

  assert(plaintext.equals(deciphered));
}

{
  // Passing an existing public key object to createPublicKey should throw.
  const publicKey = createPublicKey(publicPem);
  assert.throws(() => createPublicKey(publicKey), {
    name: 'TypeError',
    code: 'ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE',
    message: 'Invalid key object type public, expected private.'
  });

  // Constructing a private key from a public key should be impossible, even
  // if the public key was derived from a private key.
  assert.throws(() => createPrivateKey(createPublicKey(privatePem)), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
  });

  // Similarly, passing an existing private key object to createPrivateKey
  // should throw.
  const privateKey = createPrivateKey(privatePem);
  assert.throws(() => createPrivateKey(privateKey), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
  });
}

{
  const jwk = {
    e: 'AQAB',
    n: 't9xYiIonscC3vz_A2ceR7KhZZlDu_5bye53nCVTcKnWd2seY6UAdKersX6njr83Dd5OVe' +
       '1BW_wJvp5EjWTAGYbFswlNmeD44edEGM939B6Lq-_8iBkrTi8mGN4YCytivE24YI0D4XZ' +
       'MPfkLSpab2y_Hy4DjQKBq1ThZ0UBnK-9IhX37Ju_ZoGYSlTIGIhzyaiYBh7wrZBoPczIE' +
       'u6et_kN2VnnbRUtkYTF97ggcv5h-hDpUQjQW0ZgOMcTc8n-RkGpIt0_iM_bTjI3Tz_gsF' +
       'di6hHcpZgbopPL630296iByyigQCPJVzdusFrQN5DeC-zT_nGypQkZanLb4ZspSx9Q',
    d: 'ktnq2LvIMqBj4txP82IEOorIRQGVsw1khbm8A-cEpuEkgM71Yi_0WzupKktucUeevQ5i0' +
       'Yh8w9e1SJiTLDRAlJz66kdky9uejiWWl6zR4dyNZVMFYRM43ijLC-P8rPne9Fz16IqHFW' +
       '5VbJqA1xCBhKmuPMsD71RNxZ4Hrsa7Kt_xglQTYsLbdGIwDmcZihId9VGXRzvmCPsDRf2' +
       'fCkAj7HDeRxpUdEiEDpajADc-PWikra3r3b40tVHKWm8wxJLivOIN7GiYXKQIW6RhZgH-' +
       'Rk45JIRNKxNagxdeXUqqyhnwhbTo1Hite0iBDexN9tgoZk0XmdYWBn6ElXHRZ7VCDQ',
    p: '8UovlB4nrBm7xH-u7XXBMbqxADQm5vaEZxw9eluc-tP7cIAI4sglMIvL_FMpbd2pEeP_B' +
       'kR76NTDzzDuPAZvUGRavgEjy0O9j2NAs_WPK4tZF-vFdunhnSh4EHAF4Ij9kbsUi90NOp' +
       'bGfVqPdOaHqzgHKoR23Cuusk9wFQ2XTV8',
    q: 'wxHdEYT9xrpfrHPqSBQPpO0dWGKJEkrWOb-76rSfuL8wGR4OBNmQdhLuU9zTIh22pog-X' +
       'PnLPAecC-4yu_wtJ2SPCKiKDbJBre0CKPyRfGqzvA3njXwMxXazU4kGs-2Fg-xu_iKbaI' +
       'jxXrclBLhkxhBtySrwAFhxxOk6fFcPLSs',
    dp: 'qS_Mdr5CMRGGMH0bKhPUWEtAixUGZhJaunX5wY71Xoc_Gh4cnO-b7BNJ_-5L8WZog0vr' +
       '6PgiLhrqBaCYm2wjpyoG2o2wDHm-NAlzN_wp3G2EFhrSxdOux-S1c0kpRcyoiAO2n29rN' +
       'Da-jOzwBBcU8ACEPdLOCQl0IEFFJO33tl8',
    dq: 'WAziKpxLKL7LnL4dzDcx8JIPIuwnTxh0plCDdCffyLaT8WJ9lXbXHFTjOvt8WfPrlDP_' +
       'Ylxmfkw5BbGZOP1VLGjZn2DkH9aMiwNmbDXFPdG0G3hzQovx_9fajiRV4DWghLHeT9wzJ' +
       'fZabRRiI0VQR472300AVEeX4vgbrDBn600',
    qi: 'k7czBCT9rHn_PNwCa17hlTy88C4vXkwbz83Oa-aX5L4e5gw5lhcR2ZuZHLb2r6oMt9rl' +
       'D7EIDItSs-u21LOXWPTAlazdnpYUyw_CzogM_PN-qNwMRXn5uXFFhmlP2mVg2EdELTahX' +
       'ch8kWqHaCSX53yvqCtRKu_j76V31TfQZGM',
    kty: 'RSA',
  };
  const publicJwk = { kty: jwk.kty, e: jwk.e, n: jwk.n };

  const publicKey = createPublicKey(publicPem);
  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(publicKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(publicKey.symmetricKeySize, undefined);

  const privateKey = createPrivateKey(privatePem);
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(privateKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(privateKey.symmetricKeySize, undefined);

  // It should be possible to derive a public key from a private key.
  const derivedPublicKey = createPublicKey(privateKey);
  assert.strictEqual(derivedPublicKey.type, 'public');
  assert.strictEqual(derivedPublicKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(derivedPublicKey.symmetricKeySize, undefined);

  const publicKeyFromJwk = createPublicKey({ key: publicJwk, format: 'jwk' });
  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(publicKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(publicKey.symmetricKeySize, undefined);

  const privateKeyFromJwk = createPrivateKey({ key: jwk, format: 'jwk' });
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(privateKey.asymmetricKeyType, 'rsa');
  assert.strictEqual(privateKey.symmetricKeySize, undefined);

  // It should also be possible to import an encrypted private key as a public
  // key.
  const decryptedKey = createPublicKey({
    key: privateKey.export({
      type: 'pkcs8',
      format: 'pem',
      passphrase: '123',
      cipher: 'aes-128-cbc'
    }),
    format: 'pem',
    passphrase: '123'
  });
  assert.strictEqual(decryptedKey.type, 'public');
  assert.strictEqual(decryptedKey.asymmetricKeyType, 'rsa');

  // Test exporting with an invalid options object, this should throw.
  for (const opt of [undefined, null, 'foo', 0, NaN]) {
    assert.throws(() => publicKey.export(opt), {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""options"" argument must be of type object/
    });
  }

  for (const keyObject of [publicKey, derivedPublicKey, publicKeyFromJwk]) {
    assert.deepStrictEqual(
      keyObject.export({ format: 'jwk' }),
      { kty: 'RSA', n: jwk.n, e: jwk.e }
    );
  }

  for (const keyObject of [privateKey, privateKeyFromJwk]) {
    assert.deepStrictEqual(
      keyObject.export({ format: 'jwk' }),
      jwk
    );
  }

  // Exporting the key using JWK should not work since this format does not
  // support key encryption
  assert.throws(() => {
    privateKey.export({ format: 'jwk', passphrase: 'secret' });
  }, {
    message: 'The selected key encoding jwk does not support encryption.',
    code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'
  });

  const publicDER = publicKey.export({
    format: 'der',
    type: 'pkcs1'
  });

  const privateDER = privateKey.export({
    format: 'der',
    type: 'pkcs1'
  });

  assert(Buffer.isBuffer(publicDER));
  assert(Buffer.isBuffer(privateDER));

  const plaintext = Buffer.from('Hello world', 'utf8');
  const testDecryption = (fn, ciphertexts, decryptionKeys) => {
    for (const ciphertext of ciphertexts) {
      for (const key of decryptionKeys) {
        const deciphered = fn(key, ciphertext);
        assert.deepStrictEqual(deciphered, plaintext);
      }
    }
  };

  testDecryption(privateDecrypt, [
    // Encrypt using the public key.
    publicEncrypt(publicKey, plaintext),
    publicEncrypt({ key: publicKey }, plaintext),
    publicEncrypt({ key: publicJwk, format: 'jwk' }, plaintext),

    // Encrypt using the private key.
    publicEncrypt(privateKey, plaintext),
    publicEncrypt({ key: privateKey }, plaintext),
    publicEncrypt({ key: jwk, format: 'jwk' }, plaintext),

    // Encrypt using a public key derived from the private key.
    publicEncrypt(derivedPublicKey, plaintext),
    publicEncrypt({ key: derivedPublicKey }, plaintext),

    // Test distinguishing PKCS#1 public and private keys based on the
    // DER-encoded data only.
    publicEncrypt({ format: 'der', type: 'pkcs1', key: publicDER }, plaintext),
    publicEncrypt({ format: 'der', type: 'pkcs1', key: privateDER }, plaintext),
  ], [
    privateKey,
    { format: 'pem', key: privatePem },
    { format: 'der', type: 'pkcs1', key: privateDER },
    { key: jwk, format: 'jwk' },
  ]);

  testDecryption(publicDecrypt, [
    privateEncrypt(privateKey, plaintext),
  ], [
    // Decrypt using the public key.
    publicKey,
    { format: 'pem', key: publicPem },
    { format: 'der', type: 'pkcs1', key: publicDER },
    { key: publicJwk, format: 'jwk' },

    // Decrypt using the private key.
    privateKey,
    { format: 'pem', key: privatePem },
    { format: 'der', type: 'pkcs1', key: privateDER },
    { key: jwk, format: 'jwk' },
  ]);
}

{
  // This should not cause a crash: https://github.com/nodejs/node/issues/25247
  assert.throws(() => {
    createPrivateKey({ key: '' });
  }, common.hasOpenSSL3 ? {
    message: 'error:1E08010C:DECODER routines::unsupported',
  } : {
    message: 'error:0909006C:PEM routines:get_name:no start line',
    code: 'ERR_OSSL_PEM_NO_START_LINE',
    reason: 'no start line',
    library: 'PEM routines',
    function: 'get_name',
  });

  // This should not abort either: https://github.com/nodejs/node/issues/29904
  assert.throws(() => {
    createPrivateKey({ key: Buffer.alloc(0), format: 'der', type: 'spki' });
  }, {
    code: 'ERR_INVALID_ARG_VALUE',
    message: ""The property 'options.type' is invalid. Received 'spki'""
  });

  // Unlike SPKI, PKCS#1 is a valid encoding for private keys (and public keys),
  // so it should be accepted by createPrivateKey, but OpenSSL won't parse it.
  assert.throws(() => {
    const key = createPublicKey(publicPem).export({
      format: 'der',
      type: 'pkcs1'
    });
    createPrivateKey({ key, format: 'der', type: 'pkcs1' });
  }, common.hasOpenSSL3 ? {
    message: /error:1E08010C:DECODER routines::unsupported/,
    library: 'DECODER routines'
  } : {
    message: /asn1 encoding/,
    library: 'asn1 encoding routines'
  });
}

[
  { private: fixtures.readKey('ed25519_private.pem', 'ascii'),
    public: fixtures.readKey('ed25519_public.pem', 'ascii'),
    keyType: 'ed25519',
    jwk: {
      crv: 'Ed25519',
      x: 'K1wIouqnuiA04b3WrMa-xKIKIpfHetNZRv3h9fBf768',
      d: 'wVK6M3SMhQh3NK-7GRrSV-BVWQx1FO5pW8hhQeu_NdA',
      kty: 'OKP'
    } },
  { private: fixtures.readKey('ed448_private.pem', 'ascii'),
    public: fixtures.readKey('ed448_public.pem', 'ascii'),
    keyType: 'ed448',
    jwk: {
      crv: 'Ed448',
      x: 'oX_ee5-jlcU53-BbGRsGIzly0V-SZtJ_oGXY0udf84q2hTW2RdstLktvwpkVJOoNb7o' +
         'Dgc2V5ZUA',
      d: '060Ke71sN0GpIc01nnGgMDkp0sFNQ09woVo4AM1ffax1-mjnakK0-p-S7-Xf859QewX' +
         'jcR9mxppY',
      kty: 'OKP'
    } },
  { private: fixtures.readKey('x25519_private.pem', 'ascii'),
    public: fixtures.readKey('x25519_public.pem', 'ascii'),
    keyType: 'x25519',
    jwk: {
      crv: 'X25519',
      x: 'aSb8Q-RndwfNnPeOYGYPDUN3uhAPnMLzXyfi-mqfhig',
      d: 'mL_IWm55RrALUGRfJYzw40gEYWMvtRkesP9mj8o8Omc',
      kty: 'OKP'
    } },
  { private: fixtures.readKey('x448_private.pem', 'ascii'),
    public: fixtures.readKey('x448_public.pem', 'ascii'),
    keyType: 'x448',
    jwk: {
      crv: 'X448',
      x: 'ioHSHVpTs6hMvghosEJDIR7ceFiE3-Xccxati64oOVJ7NWjfozE7ae31PXIUFq6cVYg' +
         'vSKsDFPA',
      d: 'tMNtrO_q8dlY6Y4NDeSTxNQ5CACkHiPvmukidPnNIuX_EkcryLEXt_7i6j6YZMKsrWy' +
         'S0jlSYJk',
      kty: 'OKP'
    } },
].forEach((info) => {
  const keyType = info.keyType;

  {
    const key = createPrivateKey(info.private);
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    const key = createPrivateKey({ key: info.jwk, format: 'jwk' });
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    for (const input of [
      info.private, info.public, { key: info.jwk, format: 'jwk' }]) {
      const key = createPublicKey(input);
      assert.strictEqual(key.type, 'public');
      assert.strictEqual(key.asymmetricKeyType, keyType);
      assert.strictEqual(key.symmetricKeySize, undefined);
      assert.strictEqual(
        key.export({ type: 'spki', format: 'pem' }), info.public);
      const jwk = { ...info.jwk };
      delete jwk.d;
      assert.deepStrictEqual(
        key.export({ format: 'jwk' }), jwk);
    }
  }
});

[
  { private: fixtures.readKey('ec_p256_private.pem', 'ascii'),
    public: fixtures.readKey('ec_p256_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'prime256v1',
    jwk: {
      crv: 'P-256',
      d: 'DxBsPQPIgMuMyQbxzbb9toew6Ev6e9O6ZhpxLNgmAEo',
      kty: 'EC',
      x: 'X0mMYR_uleZSIPjNztIkAS3_ud5LhNpbiIFp6fNf2Gs',
      y: 'UbJuPy2Xi0lW7UYTBxPK3yGgDu9EAKYIecjkHX5s2lI'
    } },
  { private: fixtures.readKey('ec_secp256k1_private.pem', 'ascii'),
    public: fixtures.readKey('ec_secp256k1_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'secp256k1',
    jwk: {
      crv: 'secp256k1',
      d: 'c34ocwTwpFa9NZZh3l88qXyrkoYSxvC0FEsU5v1v4IM',
      kty: 'EC',
      x: 'cOzhFSpWxhalCbWNdP2H_yUkdC81C9T2deDpfxK7owA',
      y: '-A3DAZTk9IPppN-f03JydgHaFvL1fAHaoXf4SX4NXyo'
    } },
  { private: fixtures.readKey('ec_p384_private.pem', 'ascii'),
    public: fixtures.readKey('ec_p384_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'secp384r1',
    jwk: {
      crv: 'P-384',
      d: 'dwfuHuAtTlMRn7ZBCBm_0grpc1D_4hPeNAgevgelljuC0--k_LDFosDgBlLLmZsi',
      kty: 'EC',
      x: 'hON3nzGJgv-08fdHpQxgRJFZzlK-GZDGa5f3KnvM31cvvjJmsj4UeOgIdy3rDAjV',
      y: 'fidHhtecNCGCfLqmrLjDena1NSzWzWH1u_oUdMKGo5XSabxzD7-8JZxjpc8sR9cl'
    } },
  { private: fixtures.readKey('ec_p521_private.pem', 'ascii'),
    public: fixtures.readKey('ec_p521_public.pem', 'ascii'),
    keyType: 'ec',
    namedCurve: 'secp521r1',
    jwk: {
      crv: 'P-521',
      d: 'ABIIbmn3Gm_Y11uIDkC3g2ijpRxIrJEBY4i_JJYo5OougzTl3BX2ifRluPJMaaHcNer' +
         'bQH_WdVkLLX86ShlHrRyJ',
      kty: 'EC',
      x: 'AaLFgjwZtznM3N7qsfb86awVXe6c6djUYOob1FN-kllekv0KEXV0bwcDjPGQz5f6MxL' +
         'CbhMeHRavUS6P10rsTtBn',
      y: 'Ad3flexBeAfXceNzRBH128kFbOWD6W41NjwKRqqIF26vmgW_8COldGKZjFkOSEASxPB' +
         'cvA2iFJRUyQ3whC00j0Np'
    } },
].forEach((info) => {
  const { keyType, namedCurve } = info;

  {
    const key = createPrivateKey(info.private);
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.deepStrictEqual(key.asymmetricKeyDetails, { namedCurve });
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    const key = createPrivateKey({ key: info.jwk, format: 'jwk' });
    assert.strictEqual(key.type, 'private');
    assert.strictEqual(key.asymmetricKeyType, keyType);
    assert.deepStrictEqual(key.asymmetricKeyDetails, { namedCurve });
    assert.strictEqual(key.symmetricKeySize, undefined);
    assert.strictEqual(
      key.export({ type: 'pkcs8', format: 'pem' }), info.private);
    assert.deepStrictEqual(
      key.export({ format: 'jwk' }), info.jwk);
  }

  {
    for (const input of [
      info.private, info.public, { key: info.jwk, format: 'jwk' }]) {
      const key = createPublicKey(input);
      assert.strictEqual(key.type, 'public');
      assert.strictEqual(key.asymmetricKeyType, keyType);
      assert.deepStrictEqual(key.asymmetricKeyDetails, { namedCurve });
      assert.strictEqual(key.symmetricKeySize, undefined);
      assert.strictEqual(
        key.export({ type: 'spki', format: 'pem' }), info.public);
      const jwk = { ...info.jwk };
      delete jwk.d;
      assert.deepStrictEqual(
        key.export({ format: 'jwk' }), jwk);
    }
  }
});

{
  // Reading an encrypted key without a passphrase should fail.
  assert.throws(() => createPrivateKey(privateDsa), common.hasOpenSSL3 ? {
    name: 'Error',
    message: 'error:07880109:common libcrypto routines::interrupted or ' +
             'cancelled',
  } : {
    name: 'TypeError',
    code: 'ERR_MISSING_PASSPHRASE',
    message: 'Passphrase required for encrypted key'
  });

  // Reading an encrypted key with a passphrase that exceeds OpenSSL's buffer
  // size limit should fail with an appropriate error code.
  assert.throws(() => createPrivateKey({
    key: privateDsa,
    format: 'pem',
    passphrase: Buffer.alloc(1025, 'a')
  }), common.hasOpenSSL3 ? { name: 'Error' } : {
    code: 'ERR_OSSL_PEM_BAD_PASSWORD_READ',
    name: 'Error'
  });

  // The buffer has a size of 1024 bytes, so this passphrase should be permitted
  // (but will fail decryption).
  assert.throws(() => createPrivateKey({
    key: privateDsa,
    format: 'pem',
    passphrase: Buffer.alloc(1024, 'a')
  }), {
    message: /bad decrypt/
  });

  const publicKey = createPublicKey(publicDsa);
  assert.strictEqual(publicKey.type, 'public');
  assert.strictEqual(publicKey.asymmetricKeyType, 'dsa');
  assert.strictEqual(publicKey.symmetricKeySize, undefined);
  assert.throws(
    () => publicKey.export({ format: 'jwk' }),
    { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });

  const privateKey = createPrivateKey({
    key: privateDsa,
    format: 'pem',
    passphrase: 'secret'
  });
  assert.strictEqual(privateKey.type, 'private');
  assert.strictEqual(privateKey.asymmetricKeyType, 'dsa');
  assert.strictEqual(privateKey.symmetricKeySize, undefined);
  assert.throws(
    () => privateKey.export({ format: 'jwk' }),
    { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });
}

{
  // Test RSA-PSS.
  {
    // This key pair does not restrict the message digest algorithm or salt
    // length.
    const publicPem = fixtures.readKey('rsa_pss_public_2048.pem');
    const privatePem = fixtures.readKey('rsa_pss_private_2048.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    // Because no RSASSA-PSS-params appears in the PEM, no defaults should be
    // added for the PSS parameters. This is different from an empty
    // RSASSA-PSS-params sequence (see test below).
    const expectedKeyDetails = {
      modulusLength: 2048,
      publicExponent: 65537n
    };

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.throws(
      () => publicKey.export({ format: 'jwk' }),
      { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });
    assert.throws(
      () => privateKey.export({ format: 'jwk' }),
      { code: 'ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE' });

    for (const key of [privatePem, privateKey]) {
      // Any algorithm should work.
      for (const algo of ['sha1', 'sha256']) {
        // Any salt length should work.
        for (const saltLength of [undefined, 8, 10, 12, 16, 18, 20]) {
          const signature = createSign(algo)
                            .update('foo')
                            .sign({ key, saltLength });

          for (const pkey of [key, publicKey, publicPem]) {
            const okay = createVerify(algo)
                         .update('foo')
                         .verify({ key: pkey, saltLength }, signature);

            assert.ok(okay);
          }
        }
      }
    }

    // Exporting the key using PKCS#1 should not work since this would discard
    // any algorithm restrictions.
    assert.throws(() => {
      publicKey.export({ format: 'pem', type: 'pkcs1' });
    }, {
      code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'
    });
  }

  {
    // This key pair enforces sha1 as the message digest and the MGF1
    // message digest and a salt length of 20 bytes.

    const publicPem = fixtures.readKey('rsa_pss_public_2048_sha1_sha1_20.pem');
    const privatePem =
        fixtures.readKey('rsa_pss_private_2048_sha1_sha1_20.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    // Unlike the previous key pair, this key pair contains an RSASSA-PSS-params
    // sequence. However, because all values in the RSASSA-PSS-params are set to
    // their defaults (see RFC 3447), the ASN.1 structure contains an empty
    // sequence. Node.js should add the default values to the key details.
    const expectedKeyDetails = {
      modulusLength: 2048,
      publicExponent: 65537n,
      hashAlgorithm: 'sha1',
      mgf1HashAlgorithm: 'sha1',
      saltLength: 20
    };

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, expectedKeyDetails);
  }

  {
    // This key pair enforces sha256 as the message digest and the MGF1
    // message digest and a salt length of at least 16 bytes.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha256_sha256_16.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha256_sha256_16.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');

    for (const key of [privatePem, privateKey]) {
      // Signing with anything other than sha256 should fail.
      assert.throws(() => {
        createSign('sha1').sign(key);
      }, /digest not allowed/);

      // Signing with salt lengths less than 16 bytes should fail.
      for (const saltLength of [8, 10, 12]) {
        assert.throws(() => {
          createSign('sha1').sign({ key, saltLength });
        }, /pss saltlen too small/);
      }

      // Signing with sha256 and appropriate salt lengths should work.
      for (const saltLength of [undefined, 16, 18, 20]) {
        const signature = createSign('sha256')
                          .update('foo')
                          .sign({ key, saltLength });

        for (const pkey of [key, publicKey, publicPem]) {
          const okay = createVerify('sha256')
                       .update('foo')
                       .verify({ key: pkey, saltLength }, signature);

          assert.ok(okay);
        }
      }
    }
  }

  {
    // This key enforces sha512 as the message digest and sha256 as the MGF1
    // message digest.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha512_sha256_20.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha512_sha256_20.pem');

    const publicKey = createPublicKey(publicPem);
    const privateKey = createPrivateKey(privatePem);

    const expectedKeyDetails = {
      modulusLength: 2048,
      publicExponent: 65537n,
      hashAlgorithm: 'sha512',
      mgf1HashAlgorithm: 'sha256',
      saltLength: 20
    };

    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, expectedKeyDetails);

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, expectedKeyDetails);

    // Node.js usually uses the same hash function for the message and for MGF1.
    // However, when a different MGF1 message digest algorithm has been
    // specified as part of the key, it should automatically switch to that.
    // This behavior is required by sections 3.1 and 3.3 of RFC4055.
    for (const key of [privatePem, privateKey]) {
      // sha256 matches the MGF1 hash function and should be used internally,
      // but it should not be permitted as the main message digest algorithm.
      for (const algo of ['sha1', 'sha256']) {
        assert.throws(() => {
          createSign(algo).sign(key);
        }, /digest not allowed/);
      }

      // sha512 should produce a valid signature.
      const signature = createSign('sha512')
                        .update('foo')
                        .sign(key);

      for (const pkey of [key, publicKey, publicPem]) {
        const okay = createVerify('sha512')
                     .update('foo')
                     .verify(pkey, signature);

        assert.ok(okay);
      }
    }
  }
}

{
  // Exporting an encrypted private key requires a cipher
  const privateKey = createPrivateKey(privatePem);
  assert.throws(() => {
    privateKey.export({
      format: 'pem', type: 'pkcs8', passphrase: 'super-secret'
    });
  }, {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_VALUE',
    message: ""The property 'options.cipher' is invalid. Received undefined""
  });
}

{
  // SecretKeyObject export buffer format (default)
  const buffer = Buffer.from('Hello World');
  const keyObject = createSecretKey(buffer);
  assert.deepStrictEqual(keyObject.export(), buffer);
  assert.deepStrictEqual(keyObject.export({}), buffer);
  assert.deepStrictEqual(keyObject.export({ format: 'buffer' }), buffer);
  assert.deepStrictEqual(keyObject.export({ format: undefined }), buffer);
}

{
  // Exporting an ""oct"" JWK from a SecretKeyObject
  const buffer = Buffer.from('Hello World');
  const keyObject = createSecretKey(buffer);
  assert.deepStrictEqual(
    keyObject.export({ format: 'jwk' }),
    { kty: 'oct', k: 'SGVsbG8gV29ybGQ' }
  );
}

{
  // Exporting a JWK unsupported curve EC key
  const supported = ['prime256v1', 'secp256k1', 'secp384r1', 'secp521r1'];
  // Find an unsupported curve regardless of whether a FIPS compliant crypto
  // provider is currently in use.
  const namedCurve = getCurves().find((curve) => !supported.includes(curve));
  assert(namedCurve);
  const keyPair = generateKeyPairSync('ec', { namedCurve });
  const { publicKey, privateKey } = keyPair;
  assert.throws(
    () => publicKey.export({ format: 'jwk' }),
    {
      code: 'ERR_CRYPTO_JWK_UNSUPPORTED_CURVE',
      message: `Unsupported JWK EC curve: ${namedCurve}.`
    });
  assert.throws(
    () => privateKey.export({ format: 'jwk' }),
    {
      code: 'ERR_CRYPTO_JWK_UNSUPPORTED_CURVE',
      message: `Unsupported JWK EC curve: ${namedCurve}.`
    });
}

{
  const first = Buffer.from('Hello');
  const second = Buffer.from('World');
  const keyObject = createSecretKey(first);
  assert(createSecretKey(first).equals(createSecretKey(first)));
  assert(!createSecretKey(first).equals(createSecretKey(second)));

  assert.throws(() => keyObject.equals(0), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The ""otherKeyObject"" argument must be an instance of KeyObject. Received type number (0)'
  });

  assert(keyObject.equals(keyObject));
  assert(!keyObject.equals(createPublicKey(publicPem)));
  assert(!keyObject.equals(createPrivateKey(privatePem)));
}

{
  const first = generateKeyPairSync('ed25519');
  const second = generateKeyPairSync('ed25519');
  const secret = generateKeySync('aes', { length: 128 });

  assert(first.publicKey.equals(first.publicKey));
  assert(first.publicKey.equals(createPublicKey(
    first.publicKey.export({ format: 'pem', type: 'spki' }))));
  assert(!first.publicKey.equals(second.publicKey));
  assert(!first.publicKey.equals(second.privateKey));
  assert(!first.publicKey.equals(secret));

  assert(first.privateKey.equals(first.privateKey));
  assert(first.privateKey.equals(createPrivateKey(
    first.privateKey.export({ format: 'pem', type: 'pkcs8' }))));
  assert(!first.privateKey.equals(second.privateKey));
  assert(!first.privateKey.equals(second.publicKey));
  assert(!first.privateKey.equals(secret));
}

{
  const first = generateKeyPairSync('ed25519');
  const second = generateKeyPairSync('ed448');

  assert(!first.publicKey.equals(second.publicKey));
  assert(!first.publicKey.equals(second.privateKey));
  assert(!first.privateKey.equals(second.privateKey));
  assert(!first.privateKey.equals(second.publicKey));
}

{
  const first = createSecretKey(Buffer.alloc(0));
  const second = createSecretKey(new ArrayBuffer(0));
  const third = createSecretKey(Buffer.alloc(1));
  assert(first.equals(first));
  assert(first.equals(second));
  assert(!first.equals(third));
  assert(!third.equals(first));
}

{
  // This should not cause a crash: https://github.com/nodejs/node/issues/44471
  for (const key of ['', 'foo', null, undefined, true, Boolean]) {
    assert.throws(() => {
      createPublicKey({ key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      createPrivateKey({ key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
  }
}
"
test/crypto/test-crypto-authenticated.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// Flags: --no-warnings
'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { inspect } = require('util');
const fixtures = require('../common/fixtures');

crypto.DEFAULT_ENCODING = 'buffer';

//
// Test authenticated encryption modes.
//
// !NEVER USE STATIC IVs IN REAL LIFE!
//

const TEST_CASES = require(fixtures.path('aead-vectors.js'));

const errMessages = {
  auth: / auth/,
  state: / state/,
  FIPS: /not supported in FIPS mode/,
  length: /Invalid initialization vector/,
  authTagLength: /Invalid authentication tag length/
};

const ciphers = crypto.getCiphers();

const expectedWarnings = common.hasFipsCrypto ?
  [] : [
    ['Use Cipheriv for counter mode of aes-192-gcm'],
    ['Use Cipheriv for counter mode of aes-192-ccm'],
    ['Use Cipheriv for counter mode of aes-192-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-256-ccm'],
    ['Use Cipheriv for counter mode of aes-128-ccm'],
  ];

const expectedDeprecationWarnings = [
  ['crypto.DEFAULT_ENCODING is deprecated.', 'DEP0091'],
  ['crypto.createCipher is deprecated.', 'DEP0106'],
];

common.expectWarning({
  Warning: expectedWarnings,
  DeprecationWarning: expectedDeprecationWarnings
});

for (const test of TEST_CASES) {
  if (!ciphers.includes(test.algo)) {
    common.printSkipMessage(`unsupported ${test.algo} test`);
    continue;
  }

  if (common.hasFipsCrypto && test.iv.length < 24) {
    common.printSkipMessage('IV len < 12 bytes unsupported in FIPS mode');
    continue;
  }

  const isCCM = /^aes-(128|192|256)-ccm$/.test(test.algo);
  const isOCB = /^aes-(128|192|256)-ocb$/.test(test.algo);

  let options;
  if (isCCM || isOCB)
    options = { authTagLength: test.tag.length / 2 };

  const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';

  let aadOptions;
  if (isCCM) {
    aadOptions = {
      plaintextLength: Buffer.from(test.plain, inputEncoding).length
    };
  }

  {
    const encrypt = crypto.createCipheriv(test.algo,
                                          Buffer.from(test.key, 'hex'),
                                          Buffer.from(test.iv, 'hex'),
                                          options);

    if (test.aad)
      encrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);

    let hex = encrypt.update(test.plain, inputEncoding, 'hex');
    hex += encrypt.final('hex');

    const auth_tag = encrypt.getAuthTag();
    // Only test basic encryption run if output is marked as tampered.
    if (!test.tampered) {
      assert.strictEqual(hex, test.ct);
      assert.strictEqual(auth_tag.toString('hex'), test.tag);
    }
  }

  {
    if (isCCM && common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createDecipheriv(test.algo,
                                Buffer.from(test.key, 'hex'),
                                Buffer.from(test.iv, 'hex'),
                                options);
      }, errMessages.FIPS);
    } else {
      const decrypt = crypto.createDecipheriv(test.algo,
                                              Buffer.from(test.key, 'hex'),
                                              Buffer.from(test.iv, 'hex'),
                                              options);
      decrypt.setAuthTag(Buffer.from(test.tag, 'hex'));
      if (test.aad)
        decrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);

      const outputEncoding = test.plainIsHex ? 'hex' : 'ascii';

      let msg = decrypt.update(test.ct, 'hex', outputEncoding);
      if (!test.tampered) {
        msg += decrypt.final(outputEncoding);
        assert.strictEqual(msg, test.plain);
      } else {
        // Assert that final throws if input data could not be verified!
        assert.throws(function() { decrypt.final('hex'); }, errMessages.auth);
      }
    }
  }

  if (test.password) {
    if (common.hasFipsCrypto) {
      assert.throws(() => { crypto.createCipher(test.algo, test.password); },
                    errMessages.FIPS);
    } else {
      const encrypt = crypto.createCipher(test.algo, test.password, options);
      if (test.aad)
        encrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);
      let hex = encrypt.update(test.plain, 'ascii', 'hex');
      hex += encrypt.final('hex');
      const auth_tag = encrypt.getAuthTag();
      // Only test basic encryption run if output is marked as tampered.
      if (!test.tampered) {
        assert.strictEqual(hex, test.ct);
        assert.strictEqual(auth_tag.toString('hex'), test.tag);
      }
    }
  }

  if (test.password) {
    if (common.hasFipsCrypto) {
      assert.throws(() => { crypto.createDecipher(test.algo, test.password); },
                    errMessages.FIPS);
    } else {
      const decrypt = crypto.createDecipher(test.algo, test.password, options);
      decrypt.setAuthTag(Buffer.from(test.tag, 'hex'));
      if (test.aad)
        decrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);
      let msg = decrypt.update(test.ct, 'hex', 'ascii');
      if (!test.tampered) {
        msg += decrypt.final('ascii');
        assert.strictEqual(msg, test.plain);
      } else {
        // Assert that final throws if input data could not be verified!
        assert.throws(function() { decrypt.final('ascii'); }, errMessages.auth);
      }
    }
  }

  {
    // Trying to get tag before inputting all data:
    const encrypt = crypto.createCipheriv(test.algo,
                                          Buffer.from(test.key, 'hex'),
                                          Buffer.from(test.iv, 'hex'),
                                          options);
    encrypt.update('blah', 'ascii');
    assert.throws(function() { encrypt.getAuthTag(); }, errMessages.state);
  }

  {
    // Trying to create cipher with incorrect IV length
    assert.throws(function() {
      crypto.createCipheriv(
        test.algo,
        Buffer.from(test.key, 'hex'),
        Buffer.alloc(0)
      );
    }, errMessages.length);
  }
}

// Non-authenticating mode:
{
  const encrypt =
      crypto.createCipheriv('aes-128-cbc',
                            'ipxp9a6i1Mb4USb4',
                            '6fKjEjR3Vl30EUYC');
  encrypt.update('blah', 'ascii');
  encrypt.final();
  assert.throws(() => encrypt.getAuthTag(), errMessages.state);
  assert.throws(() => encrypt.setAAD(Buffer.from('123', 'ascii')),
                errMessages.state);
}

// GCM only supports specific authentication tag lengths, invalid lengths should
// throw.
{
  for (const length of [0, 1, 2, 6, 9, 10, 11, 17]) {
    assert.throws(() => {
      const decrypt = crypto.createDecipheriv('aes-128-gcm',
                                              'FxLKsqdmv0E9xrQh',
                                              'qkuZpJWCewa6Szih');
      decrypt.setAuthTag(Buffer.from('1'.repeat(length)));
    }, {
      name: 'TypeError',
      message: /Invalid authentication tag length/
    });

    assert.throws(() => {
      crypto.createCipheriv('aes-256-gcm',
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6Szih',
                            {
                              authTagLength: length
                            });
    }, {
      name: 'TypeError',
      message: /Invalid authentication tag length/
    });

    assert.throws(() => {
      crypto.createDecipheriv('aes-256-gcm',
                              'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                              'qkuZpJWCewa6Szih',
                              {
                                authTagLength: length
                              });
    }, {
      name: 'TypeError',
      message: /Invalid authentication tag length/
    });
  }
}

// Test that GCM can produce shorter authentication tags than 16 bytes.
{
  const fullTag = '1debb47b2c91ba2cea16fad021703070';
  for (const [authTagLength, e] of [[undefined, 16], [12, 12], [4, 4]]) {
    const cipher = crypto.createCipheriv('aes-256-gcm',
                                         'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                         'qkuZpJWCewa6Szih', {
                                           authTagLength
                                         });
    cipher.setAAD(Buffer.from('abcd'));
    cipher.update('01234567', 'hex');
    cipher.final();
    const tag = cipher.getAuthTag();
    assert.strictEqual(tag.toString('hex'), fullTag.substr(0, 2 * e));
  }
}

// Test that users can manually restrict the GCM tag length to a single value.
{
  const decipher = crypto.createDecipheriv('aes-256-gcm',
                                           'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                           'qkuZpJWCewa6Szih', {
                                             authTagLength: 8
                                           });

  assert.throws(() => {
    // This tag would normally be allowed.
    decipher.setAuthTag(Buffer.from('1'.repeat(12)));
  }, {
    name: 'TypeError',
    message: /Invalid authentication tag length/
  });

  // The Decipher object should be left intact.
  decipher.setAuthTag(Buffer.from('445352d3ff85cf94', 'hex'));
  const text = Buffer.concat([
    decipher.update('3a2a3647', 'hex'),
    decipher.final(),
  ]);
  assert.strictEqual(text.toString('utf8'), 'node');
}

// Test that create(De|C)ipher(iv)? throws if the mode is CCM and an invalid
// authentication tag length has been specified.
{
  for (const authTagLength of [-1, true, false, NaN, 5.5]) {
    assert.throws(() => {
      crypto.createCipheriv('aes-256-ccm',
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6S',
                            {
                              authTagLength
                            });
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: ""The property 'options.authTagLength' is invalid. "" +
               `Received ${inspect(authTagLength)}`
    });

    assert.throws(() => {
      crypto.createDecipheriv('aes-256-ccm',
                              'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                              'qkuZpJWCewa6S',
                              {
                                authTagLength
                              });
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: ""The property 'options.authTagLength' is invalid. "" +
        `Received ${inspect(authTagLength)}`
    });

    if (!common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createCipher('aes-256-ccm', 'bad password', { authTagLength });
      }, {
        name: 'TypeError',
        code: 'ERR_INVALID_ARG_VALUE',
        message: ""The property 'options.authTagLength' is invalid. "" +
          `Received ${inspect(authTagLength)}`
      });

      assert.throws(() => {
        crypto.createDecipher('aes-256-ccm', 'bad password', { authTagLength });
      }, {
        name: 'TypeError',
        code: 'ERR_INVALID_ARG_VALUE',
        message: ""The property 'options.authTagLength' is invalid. "" +
          `Received ${inspect(authTagLength)}`
      });
    }
  }

  // The following values will not be caught by the JS layer and thus will not
  // use the default error codes.
  for (const authTagLength of [0, 1, 2, 3, 5, 7, 9, 11, 13, 15, 17, 18]) {
    assert.throws(() => {
      crypto.createCipheriv('aes-256-ccm',
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6S',
                            {
                              authTagLength
                            });
    }, errMessages.authTagLength);

    if (!common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createDecipheriv('aes-256-ccm',
                                'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                'qkuZpJWCewa6S',
                                {
                                  authTagLength
                                });
      }, errMessages.authTagLength);

      assert.throws(() => {
        crypto.createCipher('aes-256-ccm', 'bad password', { authTagLength });
      }, errMessages.authTagLength);

      assert.throws(() => {
        crypto.createDecipher('aes-256-ccm', 'bad password', { authTagLength });
      }, errMessages.authTagLength);
    }
  }
}

// Test that create(De|C)ipher(iv)? throws if the mode is CCM or OCB and no
// authentication tag has been specified.
{
  for (const mode of ['ccm', 'ocb']) {
    assert.throws(() => {
      crypto.createCipheriv(`aes-256-${mode}`,
                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                            'qkuZpJWCewa6S');
    }, {
      message: `authTagLength required for aes-256-${mode}`
    });

    // CCM decryption and create(De|C)ipher are unsupported in FIPS mode.
    if (!common.hasFipsCrypto) {
      assert.throws(() => {
        crypto.createDecipheriv(`aes-256-${mode}`,
                                'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                'qkuZpJWCewa6S');
      }, {
        message: `authTagLength required for aes-256-${mode}`
      });

      assert.throws(() => {
        crypto.createCipher(`aes-256-${mode}`, 'very bad password');
      }, {
        message: `authTagLength required for aes-256-${mode}`
      });

      assert.throws(() => {
        crypto.createDecipher(`aes-256-${mode}`, 'very bad password');
      }, {
        message: `authTagLength required for aes-256-${mode}`
      });
    }
  }
}

// Test that setAAD throws if an invalid plaintext length has been specified.
{
  const cipher = crypto.createCipheriv('aes-256-ccm',
                                       'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                       'qkuZpJWCewa6S',
                                       {
                                         authTagLength: 10
                                       });

  for (const plaintextLength of [-1, true, false, NaN, 5.5]) {
    assert.throws(() => {
      cipher.setAAD(Buffer.from('0123456789', 'hex'), { plaintextLength });
    }, {
      name: 'TypeError',
      code: 'ERR_INVALID_ARG_VALUE',
      message: ""The property 'options.plaintextLength' is invalid. "" +
        `Received ${inspect(plaintextLength)}`
    });
  }
}

// Test that setAAD and update throw if the plaintext is too long.
{
  for (const ivLength of [13, 12]) {
    const maxMessageSize = (1 << (8 * (15 - ivLength))) - 1;
    const key = 'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8';
    const cipher = () => crypto.createCipheriv('aes-256-ccm', key,
                                               '0'.repeat(ivLength),
                                               {
                                                 authTagLength: 10
                                               });

    assert.throws(() => {
      cipher().setAAD(Buffer.alloc(0), {
        plaintextLength: maxMessageSize + 1
      });
    }, /Invalid message length$/);

    const msg = Buffer.alloc(maxMessageSize + 1);
    assert.throws(() => {
      cipher().update(msg);
    }, /Invalid message length/);

    const c = cipher();
    c.setAAD(Buffer.alloc(0), {
      plaintextLength: maxMessageSize
    });
    c.update(msg.slice(1));
  }
}

// Test that setAAD throws if the mode is CCM and the plaintext length has not
// been specified.
{
  assert.throws(() => {
    const cipher = crypto.createCipheriv('aes-256-ccm',
                                         'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                         'qkuZpJWCewa6S',
                                         {
                                           authTagLength: 10
                                         });
    cipher.setAAD(Buffer.from('0123456789', 'hex'));
  }, /options\.plaintextLength required for CCM mode with AAD/);

  if (!common.hasFipsCrypto) {
    assert.throws(() => {
      const cipher = crypto.createDecipheriv('aes-256-ccm',
                                             'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
                                             'qkuZpJWCewa6S',
                                             {
                                               authTagLength: 10
                                             });
      cipher.setAAD(Buffer.from('0123456789', 'hex'));
    }, /options\.plaintextLength required for CCM mode with AAD/);
  }
}

// Test that final() throws in CCM mode when no authentication tag is provided.
{
  if (!common.hasFipsCrypto) {
    const key = Buffer.from('1ed2233fa2223ef5d7df08546049406c', 'hex');
    const iv = Buffer.from('7305220bca40d4c90e1791e9', 'hex');
    const ct = Buffer.from('8beba09d4d4d861f957d51c0794f4abf8030848e', 'hex');
    const decrypt = crypto.createDecipheriv('aes-128-ccm', key, iv, {
      authTagLength: 10
    });
    // Normally, we would do this:
    // decrypt.setAuthTag(Buffer.from('0d9bcd142a94caf3d1dd', 'hex'));
    assert.throws(() => {
      decrypt.setAAD(Buffer.from('63616c76696e', 'hex'), {
        plaintextLength: ct.length
      });
      decrypt.update(ct);
      decrypt.final();
    }, errMessages.state);
  }
}

// Test that setAuthTag does not throw in GCM mode when called after setAAD.
{
  const key = Buffer.from('1ed2233fa2223ef5d7df08546049406c', 'hex');
  const iv = Buffer.from('579d9dfde9cd93d743da1ceaeebb86e4', 'hex');
  const decrypt = crypto.createDecipheriv('aes-128-gcm', key, iv);
  decrypt.setAAD(Buffer.from('0123456789', 'hex'));
  decrypt.setAuthTag(Buffer.from('1bb9253e250b8069cde97151d7ef32d9', 'hex'));
  assert.strictEqual(decrypt.update('807022', 'hex', 'hex'), 'abcdef');
  assert.strictEqual(decrypt.final('hex'), '');
}

// Test that an IV length of 11 does not overflow max_message_size_.
{
  const key = 'x'.repeat(16);
  const iv = Buffer.from('112233445566778899aabb', 'hex');
  const options = { authTagLength: 8 };
  const encrypt = crypto.createCipheriv('aes-128-ccm', key, iv, options);
  encrypt.update('boom');  // Should not throw 'Message exceeds maximum size'.
  encrypt.final();
}

// Test that the authentication tag can be set at any point before calling
// final() in GCM or OCB mode.
{
  const plain = Buffer.from('Hello world', 'utf8');
  const key = Buffer.from('0123456789abcdef', 'utf8');
  const iv = Buffer.from('0123456789ab', 'utf8');

  for (const mode of ['gcm', 'ocb']) {
    for (const authTagLength of mode === 'gcm' ? [undefined, 8] : [8]) {
      const cipher = crypto.createCipheriv(`aes-128-${mode}`, key, iv, {
        authTagLength
      });
      const ciphertext = Buffer.concat([cipher.update(plain), cipher.final()]);
      const authTag = cipher.getAuthTag();

      for (const authTagBeforeUpdate of [true, false]) {
        const decipher = crypto.createDecipheriv(`aes-128-${mode}`, key, iv, {
          authTagLength
        });
        if (authTagBeforeUpdate) {
          decipher.setAuthTag(authTag);
        }
        const resultUpdate = decipher.update(ciphertext);
        if (!authTagBeforeUpdate) {
          decipher.setAuthTag(authTag);
        }
        const resultFinal = decipher.final();
        const result = Buffer.concat([resultUpdate, resultFinal]);
        assert(result.equals(plain));
      }
    }
  }
}

// Test that setAuthTag can only be called once.
{
  const plain = Buffer.from('Hello world', 'utf8');
  const key = Buffer.from('0123456789abcdef', 'utf8');
  const iv = Buffer.from('0123456789ab', 'utf8');
  const opts = { authTagLength: 8 };

  for (const mode of ['gcm', 'ccm', 'ocb']) {
    const cipher = crypto.createCipheriv(`aes-128-${mode}`, key, iv, opts);
    const ciphertext = Buffer.concat([cipher.update(plain), cipher.final()]);
    const tag = cipher.getAuthTag();

    const decipher = crypto.createDecipheriv(`aes-128-${mode}`, key, iv, opts);
    decipher.setAuthTag(tag);
    assert.throws(() => {
      decipher.setAuthTag(tag);
    }, errMessages.state);
    // Decryption should still work.
    const plaintext = Buffer.concat([
      decipher.update(ciphertext),
      decipher.final(),
    ]);
    assert(plain.equals(plaintext));
  }
}


// Test chacha20-poly1305 rejects invalid IV lengths of 13, 14, 15, and 16 (a
// length of 17 or greater was already rejected).
// - https://www.openssl.org/news/secadv/20190306.txt
{
  // Valid extracted from TEST_CASES, check that it detects IV tampering.
  const valid = {
    algo: 'chacha20-poly1305',
    key: '808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f',
    iv: '070000004041424344454647',
    plain: '4c616469657320616e642047656e746c656d656e206f662074686520636c6173' +
           '73206f66202739393a204966204920636f756c64206f6666657220796f75206f' +
           '6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73' +
           '637265656e20776f756c642062652069742e',
    plainIsHex: true,
    aad: '50515253c0c1c2c3c4c5c6c7',
    ct: 'd31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5' +
        'a736ee62d63dbea45e8ca9671282fafb69da92728b1a71de0a9e06' +
        '0b2905d6a5b67ecd3b3692ddbd7f2d778b8c9803aee328091b58fa' +
        'b324e4fad675945585808b4831d7bc3ff4def08e4b7a9de576d265' +
        '86cec64b6116',
    tag: '1ae10b594f09e26a7e902ecbd0600691',
    tampered: false,
  };

  // Invalid IV lengths should be detected:
  // - 12 and below are valid.
  // - 13-16 are not detected as invalid by some OpenSSL versions.
  check(13);
  check(14);
  check(15);
  check(16);
  // - 17 and above were always detected as invalid by OpenSSL.
  check(17);

  function check(ivLength) {
    const prefix = ivLength - valid.iv.length / 2;
    assert.throws(() => crypto.createCipheriv(
      valid.algo,
      Buffer.from(valid.key, 'hex'),
      Buffer.from(H(prefix) + valid.iv, 'hex')
    ), errMessages.length, `iv length ${ivLength} was not rejected`);

    function H(length) { return '00'.repeat(length); }
  }
}

{
  // CCM cipher without data should not crash, see https://github.com/nodejs/node/issues/38035.
  const algo = 'aes-128-ccm';
  const key = Buffer.alloc(16);
  const iv = Buffer.alloc(12);
  const opts = { authTagLength: 10 };

  for (const cipher of [
    crypto.createCipher(algo, 'foo', opts),
    crypto.createCipheriv(algo, key, iv, opts),
  ]) {
    assert.throws(() => {
      cipher.final();
    }, common.hasOpenSSL3 ? {
      code: 'ERR_OSSL_TAG_NOT_SET'
    } : {
      message: /Unsupported state/
    });
  }
}

{
  const key = Buffer.alloc(32);
  const iv = Buffer.alloc(12);

  for (const authTagLength of [0, 17]) {
    assert.throws(() => {
      crypto.createCipheriv('chacha20-poly1305', key, iv, { authTagLength });
    }, {
      code: 'ERR_CRYPTO_INVALID_AUTH_TAG',
      message: errMessages.authTagLength
    });
  }
}

// ChaCha20-Poly1305 should respect the authTagLength option and should not
// require the authentication tag before calls to update() during decryption.
{
  const key = Buffer.alloc(32);
  const iv = Buffer.alloc(12);

  for (let authTagLength = 1; authTagLength <= 16; authTagLength++) {
    const cipher =
        crypto.createCipheriv('chacha20-poly1305', key, iv, { authTagLength });
    const ciphertext = Buffer.concat([cipher.update('foo'), cipher.final()]);
    const authTag = cipher.getAuthTag();
    assert.strictEqual(authTag.length, authTagLength);

    // The decipher operation should reject all authentication tags other than
    // that of the expected length.
    for (let other = 1; other <= 16; other++) {
      const decipher = crypto.createDecipheriv('chacha20-poly1305', key, iv, {
        authTagLength: other
      });
      // ChaCha20 is a stream cipher so we do not need to call final() to obtain
      // the full plaintext.
      const plaintext = decipher.update(ciphertext);
      assert.strictEqual(plaintext.toString(), 'foo');
      if (other === authTagLength) {
        // The authentication tag length is as expected and the tag itself is
        // correct, so this should work.
        decipher.setAuthTag(authTag);
        decipher.final();
      } else {
        // The authentication tag that we are going to pass to setAuthTag is
        // either too short or too long. If other < authTagLength, the
        // authentication tag is still correct, but it should still be rejected
        // because its security assurance is lower than expected.
        assert.throws(() => {
          decipher.setAuthTag(authTag);
        }, {
          code: 'ERR_CRYPTO_INVALID_AUTH_TAG',
          message: `Invalid authentication tag length: ${authTagLength}`
        });
      }
    }
  }
}

// ChaCha20-Poly1305 should default to an authTagLength of 16. When encrypting,
// this matches the behavior of GCM ciphers. When decrypting, however, it is
// stricter than GCM in that it only allows authentication tags that are exactly
// 16 bytes long, whereas, when no authTagLength was specified, GCM would accept
// shorter tags as long as their length was valid according to NIST SP 800-38D.
// For ChaCha20-Poly1305, we intentionally deviate from that because there are
// no recommended or approved authentication tag lengths below 16 bytes.
{
  const rfcTestCases = TEST_CASES.filter(({ algo, tampered }) => {
    return algo === 'chacha20-poly1305' && tampered === false;
  });
  assert.strictEqual(rfcTestCases.length, 1);

  const [testCase] = rfcTestCases;
  const key = Buffer.from(testCase.key, 'hex');
  const iv = Buffer.from(testCase.iv, 'hex');
  const aad = Buffer.from(testCase.aad, 'hex');

  for (const opt of [
    undefined,
    { authTagLength: undefined },
    { authTagLength: 16 },
  ]) {
    const cipher = crypto.createCipheriv('chacha20-poly1305', key, iv, opt);
    const ciphertext = Buffer.concat([
      cipher.setAAD(aad).update(testCase.plain, 'hex'),
      cipher.final(),
    ]);
    const authTag = cipher.getAuthTag();

    assert.strictEqual(ciphertext.toString('hex'), testCase.ct);
    assert.strictEqual(authTag.toString('hex'), testCase.tag);

    const decipher = crypto.createDecipheriv('chacha20-poly1305', key, iv, opt);
    const plaintext = Buffer.concat([
      decipher.setAAD(aad).update(ciphertext),
      decipher.setAuthTag(authTag).final(),
    ]);

    assert.strictEqual(plaintext.toString('hex'), testCase.plain);
  }
}
"
modules/internal/errors.js,"import { inspect } from ""./util/inspect"";

/**
 * 
 * @template T
 * @param {T} fn 
 * @return {T}
 */
export function hideStackFrames(fn) {
    const hidden = ""__node_internal_"" + fn.name;
    Object.defineProperty(fn, ""name"", { value: hidden });

    return fn;
}

export class ERR_HTTP_HEADERS_SENT extends Error {
    constructor(x) {
        super(
            `Cannot ${x} headers after they are sent to the client`,
        );
        this.code = ""ERR_HTTP_HEADERS_SENT"";
    }
}

export class ERR_HTTP_INVALID_HEADER_VALUE extends TypeError {
    constructor(x, y) {
        super(
            `Invalid value ""${x}"" for header ""${y}""`,
        );
        this.code = ""ERR_HTTP_INVALID_HEADER_VALUE"";
    }
}

export class ERR_HTTP_TRAILER_INVALID extends Error {
    constructor() {
        super(
            `Trailers are invalid with this transfer encoding`,
        );
        this.code = ""ERR_HTTP_TRAILER_INVALID"";
    }
}

export class ERR_INVALID_HTTP_TOKEN extends TypeError {
    constructor(x, y) {
        super(`${x} must be a valid HTTP token [""${y}""]`);
        this.code = ""ERR_INVALID_HTTP_TOKEN"";
    }
}

const classRegExp = /^([A-Z][a-z0-9]*)+$/;

const kTypes = [
    ""string"",
    ""function"",
    ""number"",
    ""object"",
    ""Function"",
    ""Object"",
    ""boolean"",
    ""bigint"",
    ""symbol"",
];

function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [expected];
    let msg = ""The "";
    if (name.endsWith("" argument"")) {
        msg += `${name} `;
    } else {
        const type = name.includes(""."") ? ""property"" : ""argument"";
        msg += `""${name}"" ${type} `;
    }
    msg += ""must be "";

    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }

    if (instances.length > 0) {
        const pos = types.indexOf(""object"");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push(""Object"");
        }
    }

    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join("", "")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += "" or "";
        }
    }

    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join("", "")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += "" or "";
        }
    }

    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join("", "")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += ""an "";
            }
            msg += `${other[0]}`;
        }
    }

    return msg;
}

function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === ""function"" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === ""object"") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, { depth: -1 })}`;
    }
    let inspected = inspect(input, { colors: false });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}

/**
 * 
 * @param {string} val 
 * @returns {string}
 */
function addNumericalSeparator(val) {
    let res = """";
    let i = val.length;
    const start = val[0] === ""-"" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}

export class ERR_OUT_OF_RANGE extends RangeError {
    code = ""ERR_OUT_OF_RANGE"";

    /**
     * 
     * @param {string} str 
     * @param {string} range 
     * @param {unknown} input 
     * @param {boolean} replaceDefaultBoolean 
     */
    constructor(
        str,
        range,
        input,
        replaceDefaultBoolean = false,
    ) {
        // assert(range, 'Missing ""range"" argument');
        let msg = replaceDefaultBoolean
            ? str
            : `The value of ""${str}"" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === ""bigint"") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += ""n"";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;

        super(msg);

        const { name } = this;
        // Add the error code to the name to include it in the stack trace.
        this.name = `${name} [${this.code}]`;
        // Access the stack to generate the error message including the error code from the name.
        this.stack;
        // Reset the name to the actual name.
        this.name = name;
    }
}

export class ERR_INVALID_ARG_TYPE_RANGE extends RangeError {
    constructor(name, expected, actual) {
        const msg = createInvalidArgType(name, expected);

        super(`${msg}.${invalidArgTypeHelper(actual)}`);
        this.code = ""ERR_INVALID_ARG_TYPE"";
    }
}

export class ERR_INVALID_ARG_TYPE extends TypeError {
    /**
     * 
     * @param {string} name 
     * @param {string | string[]} expected 
     * @param {unknown} actual 
     */
    constructor(name, expected, actual) {
        const msg = createInvalidArgType(name, expected);

        super(`${msg}.${invalidArgTypeHelper(actual)}`);
        this.code = ""ERR_INVALID_ARG_TYPE"";
    }

    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}

export class ERR_INVALID_ARG_VALUE_RANGE extends RangeError {
    constructor(name, value, reason = ""is invalid"") {
        const type = name.includes(""."") ? ""property"" : ""argument"";
        const inspected = JSON.stringify(value);

        super(`The ${type} '${name}' ${reason}. Received ${inspected}`,);

        this.code = ""ERR_INVALID_ARG_VALUE""
    }
}

export class ERR_INVALID_ARG_VALUE extends TypeError {
    constructor(name, value, reason = ""is invalid"") {
        const type = name.includes(""."") ? ""property"" : ""argument"";
        const inspected = JSON.stringify(value);

        super(`The ${type} '${name}' ${reason}. Received ${inspected}`,);

        this.code = ""ERR_INVALID_ARG_VALUE""
    }
}

export class ERR_INVALID_CHAR extends TypeError {
    constructor(name, field) {
        super(field
            ? `Invalid character in ${name}`
            : `Invalid character in ${name} [""${field}""]`,
        );
        this.code = ""ERR_INVALID_CHAR"";
    }
}

export class ERR_METHOD_NOT_IMPLEMENTED extends Error {
    constructor(x) {
        super(`The ${x} method is not implemented`);
        this.code = ""ERR_METHOD_NOT_IMPLEMENTED"";
    }
}

export class ERR_STREAM_CANNOT_PIPE extends Error {
    constructor() {
        super(`Cannot pipe, not readable`);
        this.code = ""ERR_STREAM_CANNOT_PIPE"";
    }
}

export class ERR_STREAM_ALREADY_FINISHED extends Error {
    constructor(x) {
        super(
            `Cannot call ${x} after a stream was finished`,
        );
        this.code = ""ERR_STREAM_ALREADY_FINISHED"";
    }
}

export class ERR_STREAM_WRITE_AFTER_END extends Error {
    constructor() {
        super(`write after end`);
        this.code = ""ERR_STREAM_WRITE_AFTER_END"";
    }
}

export class ERR_STREAM_NULL_VALUES extends TypeError {
    constructor() {
        super(`May not write null values to stream`);
        this.code = ""ERR_STREAM_NULL_VALUES"";
    }
}

export class ERR_STREAM_DESTROYED extends Error {
    constructor(x) {
        super(
            `Cannot call ${x} after a stream was destroyed`,
        );
        this.code = ""ERR_STREAM_DESTROYED"";
    }
}

export function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            // If `outerError` is already an `AggregateError`.
            outerError.errors.push(innerError);
            return outerError;
        }
        // eslint-disable-next-line no-restricted-syntax
        const err = new AggregateError(
            [
                outerError,
                innerError,
            ],
            outerError.message,
        );
        // deno-lint-ignore no-explicit-any
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}

export class ERR_SOCKET_BAD_PORT extends RangeError {
    constructor(name, port, allowZero = true) {
        assert(
            typeof allowZero === ""boolean"",
            ""The 'allowZero' argument must be of type boolean."",
        );

        const operator = allowZero ? "">="" : "">"";

        super(
            `${name} should be ${operator} 0 and < 65536. Received ${port}.`,
        );
        this.code = ""ERR_SOCKET_BAD_PORT"";
    }
}

export class ERR_STREAM_PREMATURE_CLOSE extends Error {
    constructor() {
        super(`Premature close`);
        this.code = ""ERR_STREAM_PREMATURE_CLOSE"";
    }
}

export class AbortError extends Error {
    constructor() {
        super(""The operation was aborted"");
        this.code = ""ABORT_ERR"";
        this.name = ""AbortError"";
    }
}

export class ERR_INVALID_CALLBACK extends TypeError {
    constructor(object) {
        super(
            `Callback must be a function. Received ${JSON.stringify(object)}`,
        );
        this.code = ""ERR_INVALID_CALLBACK"";
    }
}

export class ERR_MISSING_ARGS extends TypeError {
    constructor(...args) {
        let msg = ""The "";

        const len = args.length;

        const wrap = (a) => `""${a}""`;

        args = args.map((a) =>
            Array.isArray(a) ? a.map(wrap).join("" or "") : wrap(a)
        );

        switch (len) {
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join("", "");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }

        super(`${msg} must be specified`);
        this.code = ""ERR_MISSING_ARGS"";
    }
}
export class ERR_MISSING_OPTION extends TypeError {
    constructor(x) {
        super(`${x} is required`);
        this.code = ""ERR_MISSING_OPTION"";
    }
}
export class ERR_MULTIPLE_CALLBACK extends Error {
    constructor() {
        super(`Callback called multiple times`);
        this.code = ""ERR_MULTIPLE_CALLBACK"";
    }
}

export class ERR_STREAM_PUSH_AFTER_EOF extends Error {
    constructor() {
        super(`stream.push() after EOF`);
        this.code = ""ERR_STREAM_PUSH_AFTER_EOF"";
    }
}

export class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends Error {
    constructor() {
        super(
            `stream.unshift() after end event`,
        );
        this.code = ""ERR_STREAM_UNSHIFT_AFTER_END_EVENT"";
    }
}

export class ERR_UNKNOWN_ENCODING extends TypeError {
    constructor(x) {
        super(`Unknown encoding: ${x}`);
        this.code = ""ERR_UNKNOWN_ENCODING"";
    }
}

function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}

export class ERR_INVALID_RETURN_VALUE extends TypeError {
    constructor(input, name, value) {
        super(
            `Expected ${input} to be returned from the ""${name}"" function but got ${buildReturnPropertyType(value)}.`,
        );
        this.code = ""ERR_INVALID_RETURN_VALUE"";
    }
}

export class ERR_INCOMPATIBLE_OPTION_PAIR extends TypeError {
    constructor(input, name) {
        super(
            `Option ""${input}"" cannot be used in combination with option ""${name}""`,
        );
        this.code = ""ERR_INCOMPATIBLE_OPTION_PAIR"";
    }
}

export const captureStackTrace = hideStackFrames(
    function captureStackTrace(err) {
        // Error.captureStackTrace is only available in V8
        const e = new Error();
        Object.defineProperties(err, {
            stack: {
                configurable: true,
                writable: true,
                get: () => e.stack
            }
        })
        return err;
    },
);

const captureLargerStackTrace = hideStackFrames(
    function captureLargerStackTrace(err) {
        captureStackTrace(err);

        return err;
    },
);


/**
 * All error instances in Node have additional methods and properties
 * This export class is meant to be extended by these instances abstracting native JS error instances
 */
export class NodeErrorAbstraction extends Error {
    /**
     * @type {string}
     */
    code;

    /**
     * 
     * @param {string} name 
     * @param {string} code 
     * @param {string} message 
     */
    constructor(name, code, message) {
        super(message);
        this.code = code;
        this.name = name;
        //This number changes depending on the name of this class
        //20 characters as of now
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }

    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}

const kIsNodeError = Symbol(""kIsNodeError"");

/**
 * @typedef {Object} NodeSystemErrorCtx
 * @property {string} code
 * @property {string} syscall
 * @property {string} message
 * @property {number} errno
 * @property {string=} path
 * @property {string=} dest
 */

class NodeSystemError extends NodeErrorAbstraction {
    /**
     * 
     * @param {string} key 
     * @param {NodeSystemErrorCtx} context 
     * @param {string} msgPrefix 
     */
    constructor(key, context, msgPrefix) {
        let message = `${msgPrefix}: ${context.syscall} returned ` +
            `${context.code} (${context.message})`;

        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }

        super(""SystemError"", key, message);
        // captureLargerStackTrace(this);

        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true,
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false,
            },
            errno: {
                get() {
                    return context.errno;
                },
                set: (value) => {
                    context.errno = value;
                },
                enumerable: true,
                configurable: true,
            },
            syscall: {
                get() {
                    return context.syscall;
                },
                set: (value) => {
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true,
            },
        });

        if (context.path !== undefined) {
            Object.defineProperty(this, ""path"", {
                get() {
                    return context.path;
                },
                set: (value) => {
                    context.path = value;
                },
                enumerable: true,
                configurable: true,
            });
        }

        if (context.dest !== undefined) {
            Object.defineProperty(this, ""dest"", {
                get() {
                    return context.dest;
                },
                set: (value) => {
                    context.dest = value;
                },
                enumerable: true,
                configurable: true,
            });
        }
    }

    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}

/**
 * 
 * @param {string} key 
 * @param {string} msgPrfix 
 */
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        /**
         * 
         * @param {NodeSystemErrorCtx} ctx 
         */
        constructor(ctx) {
            super(key, ctx, msgPrfix);
        }
    };
}

export const ERR_FS_EISDIR = makeSystemErrorWithCode(
    ""ERR_FS_EISDIR"",
    ""Path is a directory"",
);

export const ERR_FS_CP_DIR_TO_NON_DIR = makeSystemErrorWithCode('ERR_FS_CP_DIR_TO_NON_DIR',
    'Cannot overwrite directory with non-directory');
export const ERR_FS_CP_EEXIST = makeSystemErrorWithCode('ERR_FS_CP_EEXIST', 'Target already exists');
export const ERR_FS_CP_EINVAL = makeSystemErrorWithCode('ERR_FS_CP_EINVAL', 'Invalid src or dest');
export const ERR_FS_CP_FIFO_PIPE = makeSystemErrorWithCode('ERR_FS_CP_FIFO_PIPE', 'Cannot copy a FIFO pipe');
export const ERR_FS_CP_NON_DIR_TO_DIR = makeSystemErrorWithCode('ERR_FS_CP_NON_DIR_TO_DIR',
    'Cannot overwrite non-directory with directory');
export const ERR_FS_CP_SOCKET = makeSystemErrorWithCode('ERR_FS_CP_SOCKET', 'Cannot copy a socket file');
export const ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY = makeSystemErrorWithCode('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY',
    'Cannot overwrite symlink in subdirectory of self');
export const ERR_FS_CP_UNKNOWN = makeSystemErrorWithCode('ERR_FS_CP_UNKNOWN', 'Cannot copy an unknown file type');

/**
 * 
 * @param {number} name 
 * @returns {[string, string]}
 */
function uvErrmapGet(name) {
    return errorMap.get(name);
}

const uvUnmappedError = [""UNKNOWN"", ""unknown error""];

/**
 * This creates an error compatible with errors produced in the C++
 * function UVException using a context object with data assembled in C++.
 * The goal is to migrate them to ERR_* errors later when compatibility is
 * not a concern.
 */
export const uvException = hideStackFrames(
    /**
     * 
     * @param {NodeSystemErrorCtx} ctx 
     * @returns 
     */
    function uvException(ctx) {
        const { 0: code, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;

        let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;

        let path;
        let dest;

        if (ctx.path) {
            path = ctx.path.toString();
            message += ` '${path}'`;
        }
        if (ctx.dest) {
            dest = ctx.dest.toString();
            message += ` -> '${dest}'`;
        }


        const err = new Error(message);

        for (const prop of Object.keys(ctx)) {
            if (prop === ""message"" || prop === ""path"" || prop === ""dest"") {
                continue;
            }

            err[prop] = ctx[prop];
        }

        err.code = code;

        if (path) {
            err.path = path;
        }

        if (dest) {
            err.dest = dest;
        }

        return captureLargerStackTrace(err);
    }
);

export function isErrorStackTraceLimitWritable() {
    // Do no touch Error.stackTraceLimit as V8 would attempt to install
    // it again during deserialization.
    if (false && import('v8').startupSnapshot.isBuildingSnapshot()) {
        return false;
    }

    const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');
    if (desc === undefined) {
        return Object.isExtensible(Error);
    }

    return Object.prototype.hasOwnProperty(desc, 'writable') ?
        desc.writable :
        desc.set !== undefined;
}

export class ERR_UNAVAILABLE_DURING_EXIT extends Error {
    constructor() {
        super(
            ""ERR_UNAVAILABLE_DURING_EXIT"",
            `Cannot call function in process exit handler`,
        );
    }
}

export class ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED extends TypeError {
    constructor() {
        super(
            ""ERR_ASSERT_SNAPSHOT_NOT_SUPPORTED"",
            `Snapshot is not supported in this context`,
        );
    }
}

export class ERR_AMBIGUOUS_ARGUMENT extends TypeError {
    constructor(arg, msg) {
        super(
            ""ERR_AMBIGUOUS_ARGUMENT"",
            `The ${arg} argument is ambiguous. ${msg}`,
        );
    }
}

export class ERR_DIR_CLOSED extends Error {
    constructor() {
        super(""Directory handle was closed"");
        this.code = ""ERR_DIR_CLOSED"";
    }
}

export class ERR_DIR_CONCURRENT_OPERATION extends Error {
    constructor() {
        super(
            ""Cannot do synchronous work on directory handle with concurrent asynchronous operations"",
        );
        this.code = ""ERR_DIR_CONCURRENT_OPERATION"";
    }
}

export class ERR_FS_FILE_TOO_LARGE extends RangeError {
    constructor(x) {
        super(
            `File size (${x}) is greater than 2 GB`,
        );
        this.code = ""ERR_FS_FILE_TOO_LARGE"";
    }
}

export class AggregateError extends Error {
    constructor(errs) {
        super();
        this.name = ""AggregateError"";
        this.code = errs[0].code;
        this.errors = errs;
    }
}

export class ERR_FS_INVALID_SYMLINK_TYPE extends Error {
    constructor(x) {
        super(
            `Symlink type must be one of ""dir"", ""file"", or ""junction"". Received ""${x}""`,
        );
        this.code = ""ERR_FS_INVALID_SYMLINK_TYPE"";
    }
}

export class ERR_CRYPTO_FIPS_FORCED extends Error {
    constructor() {
        super(
            'Cannot set FIPS mode, it was forced with --force-fips at startup.',
        );
        this.code = ""ERR_CRYPTO_FIPS_FORCED"";
    }
}

export class ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH extends RangeError {
    constructor() {
        super(
            'Input buffers must have the same byte length',
        );
        this.code = ""ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH"";
    }
}

export class ERR_OPERATION_FAILED extends Error {
    constructor(x) {
        super(
            `Operation failed: ${x}`,
        );
        this.code = ""ERR_OPERATION_FAILED"";
    }
}

export class ERR_CRYPTO_ENGINE_UNKNOWN extends Error {
    constructor(x) {
        super(
            `Engine ""${x}"" was not found`,
        );
        this.code = ""ERR_CRYPTO_ENGINE_UNKNOWN"";
    }
}

export class ERR_CRYPTO_INVALID_DIGEST extends TypeError {
    constructor(x) {
        super(`Invalid digest: ${x}`);
        this.code = ""ERR_CRYPTO_INVALID_DIGEST"";
    }
}

export class ERR_CRYPTO_SCRYPT_INVALID_PARAMETER extends Error {
    constructor() {
        super(`Invalid scrypt parameter`);
        this.code = ""ERR_CRYPTO_SCRYPT_INVALID_PARAMETER"";
    }
}

export class ERR_CRYPTO_SCRYPT_NOT_SUPPORTED extends Error {
    constructor() {
        super(`Scrypt algorithm not supported`);
        this.code = ""ERR_CRYPTO_SCRYPT_NOT_SUPPORTED"";
    }
}

export class ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS extends Error {
    constructor(a, b) {
        super(`The selected key encoding ${a} ${b}.`);
        this.code = ""ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS"";
    }
}

export class ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE extends TypeError {
    constructor(t, e) {
        super(`Invalid key object type ${t}, expected ${e}.`);
        this.code = ""ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE"";
    }
}

export class ERR_CRYPTO_INVALID_JWK extends TypeError {
    constructor() {
        super(`Invalid JWK data`);
        this.code = ""ERR_CRYPTO_INVALID_JWK"";
    }
}

export class ERR_ILLEGAL_CONSTRUCTOR extends TypeError {
    constructor() {
        super(`Illegal constructor`);
        this.code = ""ERR_ILLEGAL_CONSTRUCTOR"";
    }
}

export class ERR_CRYPTO_INVALID_KEYLEN extends RangeError {
    constructor() {
        super(`Invalid key length`);
        this.code = ""ERR_CRYPTO_INVALID_KEYLEN"";
    }
}

export class ERR_CRYPTO_HASH_FINALIZED extends Error {
    constructor() {
        super(`Digest already called`);
        this.code = ""ERR_CRYPTO_HASH_FINALIZED"";
    }
}

export class ERR_CRYPTO_HASH_UPDATE_FAILED extends Error {
    constructor() {
        super(`Hash update failed`);
        this.code = ""ERR_CRYPTO_HASH_UPDATE_FAILED"";
    }
}

export class ERR_CRYPTO_INVALID_STATE extends Error {
    constructor() {
        super(`Invalid state`);
        this.code = ""ERR_CRYPTO_INVALID_STATE"";
    }
}

export class ERR_CRYPTO_UNKNOWN_CIPHER extends Error {
    constructor() {
        super(`Unknown cipher`);
        this.code = ""ERR_CRYPTO_UNKNOWN_CIPHER"";
    }
}
"
modules/http.js,"import * as net from 'wasi_net'
import * as httpx from 'wasi_http'
import { TextDecoder } from 'util'
import { Buffer } from 'buffer'
import { EventEmitter } from 'events'
import process from 'process'
import { validatePort } from 'internal/validators'
import { Readable, Writable } from ""stream"";
import { isTypedArray } from 'util/types'

const URL = httpx.URL;

export class Request {
    constructor(input, init = {}) {

        let parsedURL

        if (input instanceof Request) {
            parsedURL = new URL(input.url)
        } else {
            parsedURL = new URL(input)
            input = {}
        }

        this.url = parsedURL;

        if (parsedURL.username !== '' || parsedURL.password !== '') {
            throw new TypeError(`${parsedURL} is an url with embedded credentails.`)
        }

        let method = init.method || input.method || 'GET'
        this.method = method.toUpperCase();

        let headers = init.headers || input.headers || {}
        if (!headers.has('Accept')) {
            headers.set('Accept', '*/*')
        }

        this.headers = headers
    }

    get [Symbol.toStringTag]() {
        return 'Request'
    }

    clone() {
        return new Request(this)
    }
}

export class Response {
    #chunked = false;
    #chunkBuff = null;
    #bodyUsed = false

    constructor(resp, buffer, reader, option = {}) {
        this.response = resp
        this.buffer = buffer
        this.reader = reader
        this.url = option.url

        this.headers = resp.headers
        this.statusText = resp.statusText
        this.status = resp.status

        if (typeof (resp.bodyLength) === ""number"") {
            this.#chunked = false
        } else {
            this.#chunked = true
            this.#chunkBuff = buffer
            this.buffer = new httpx.Buffer()
        }

        this.onChunk = undefined;
    }

    get chunked() {
        return this.#chunked
    }

    get ok() {
        return this.status >= 200 && this.status < 300;
    }

    get bodyUsed() {
        return this.#bodyUsed
    }

    async #readChunk() {
        while (true) {
            let chunk = this.#chunkBuff.parseChunk();

            if (chunk === undefined) {
                let data = await this.reader.read()
                if (data === undefined) {
                    throw new Error('socket is shutdown')
                }
                this.#chunkBuff.write(data)
                continue
            } else if (chunk === null) {
                // end
                return null
            } else if (chunk instanceof ArrayBuffer) {
                return chunk
            } else {
                throw chunk
            }
        }
    }

    async #readBody() {
        while (true) {

            if (this.buffer.byteLength >= this.response.bodyLength) {
                let buf = this.buffer.buffer;
                this.buffer.clear();
                return buf;
            }

            let data = await this.reader.read()
            if (data === undefined) {
                let buf = this.buffer.buffer;
                this.buffer.clear();
                return buf;
            }

            this.buffer.write(data)
        }
    }

    async arrayBuffer() {
        this.#bodyUsed = true;
        if (this.#chunked) {
            while (true) {
                let chunk = await this.#readChunk();
                if (chunk === null) {
                    let buf = this.buffer.buffer;
                    this.buffer.clear();
                    return buf;
                }
                this.buffer.write(chunk)
                if (typeof this.onChunk === 'function') {
                    let onChunk = this.onChunk;
                    onChunk(chunk)
                }
            }
        } else {
            let body = await this.#readBody()
            if (typeof this.onChunk === 'function') {
                let onChunk = this.onChunk;
                onChunk(body)
            }
            return body
        }
    }

    async text() {
        return new TextDecoder().decode(await this.arrayBuffer())
    }

    async json() {
        return JSON.parse(await this.text())
    }

    get [Symbol.toStringTag]() {
        return 'Response'
    }
}

async function wait_response(reader, url) {
    let buf = new httpx.Buffer()
    let resp = undefined
    while (true) {
        let buff = await reader.read()
        if (buff == undefined && resp == undefined) {
            throw new TypeError('Illegal response')
        }
        buf.append(buff)
        resp = buf.parseResponse()
        if (resp instanceof httpx.WasiResponse) {
            return new Response(resp, buf, reader, { url })
        }
    }
}

export async function fetch(input, init = {}) {
    let url = new httpx.URL(input)
    if (url.username !== '' || url.password != '') {
        throw new TypeError(`${input} is an url with embedded credentails.`)
    }

    let method = init.method || 'GET'
    method = method.toUpperCase();

    let headers = init.headers || {}
    if (!headers['Accept']) {
        headers['Accept'] = '*/*'
    }
    if (!headers['Host']) {
        headers['Host'] = url.host
    }

    var s;
    if (url.scheme == 'https' && net.WasiTlsConn) {
        s = await net.WasiTlsConn.connect(url.host, url.port);
    } else {
        s = await net.WasiTcpConn.connect(url.host, url.port);
    }

    let req = new httpx.WasiRequest()
    req.version = init.version || 'HTTP/1.1'
    req.headers = headers

    let path = url.path
    let query = url.query
    if (query != undefined) {
        req.uri = `${path}?${query}`
    } else {
        req.uri = path
    }

    req.method = method
    req.body = init.body || ''
    s.write(req.encode())
    return await wait_response(s, url)
}

const STATUS_CODES = {
    100: 'Continue',                   // RFC 7231 6.2.1
    101: 'Switching Protocols',        // RFC 7231 6.2.2
    102: 'Processing',                 // RFC 2518 10.1 (obsoleted by RFC 4918)
    103: 'Early Hints',                // RFC 8297 2
    200: 'OK',                         // RFC 7231 6.3.1
    201: 'Created',                    // RFC 7231 6.3.2
    202: 'Accepted',                   // RFC 7231 6.3.3
    203: 'Non-Authoritative Information', // RFC 7231 6.3.4
    204: 'No Content',                 // RFC 7231 6.3.5
    205: 'Reset Content',              // RFC 7231 6.3.6
    206: 'Partial Content',            // RFC 7233 4.1
    207: 'Multi-Status',               // RFC 4918 11.1
    208: 'Already Reported',           // RFC 5842 7.1
    226: 'IM Used',                    // RFC 3229 10.4.1
    300: 'Multiple Choices',           // RFC 7231 6.4.1
    301: 'Moved Permanently',          // RFC 7231 6.4.2
    302: 'Found',                      // RFC 7231 6.4.3
    303: 'See Other',                  // RFC 7231 6.4.4
    304: 'Not Modified',               // RFC 7232 4.1
    305: 'Use Proxy',                  // RFC 7231 6.4.5
    307: 'Temporary Redirect',         // RFC 7231 6.4.7
    308: 'Permanent Redirect',         // RFC 7238 3
    400: 'Bad Request',                // RFC 7231 6.5.1
    401: 'Unauthorized',               // RFC 7235 3.1
    402: 'Payment Required',           // RFC 7231 6.5.2
    403: 'Forbidden',                  // RFC 7231 6.5.3
    404: 'Not Found',                  // RFC 7231 6.5.4
    405: 'Method Not Allowed',         // RFC 7231 6.5.5
    406: 'Not Acceptable',             // RFC 7231 6.5.6
    407: 'Proxy Authentication Required', // RFC 7235 3.2
    408: 'Request Timeout',            // RFC 7231 6.5.7
    409: 'Conflict',                   // RFC 7231 6.5.8
    410: 'Gone',                       // RFC 7231 6.5.9
    411: 'Length Required',            // RFC 7231 6.5.10
    412: 'Precondition Failed',        // RFC 7232 4.2
    413: 'Payload Too Large',          // RFC 7231 6.5.11
    414: 'URI Too Long',               // RFC 7231 6.5.12
    415: 'Unsupported Media Type',     // RFC 7231 6.5.13
    416: 'Range Not Satisfiable',      // RFC 7233 4.4
    417: 'Expectation Failed',         // RFC 7231 6.5.14
    418: 'I\'m a Teapot',              // RFC 7168 2.3.3
    421: 'Misdirected Request',        // RFC 7540 9.1.2
    422: 'Unprocessable Entity',       // RFC 4918 11.2
    423: 'Locked',                     // RFC 4918 11.3
    424: 'Failed Dependency',          // RFC 4918 11.4
    425: 'Too Early',                  // RFC 8470 5.2
    426: 'Upgrade Required',           // RFC 2817 and RFC 7231 6.5.15
    428: 'Precondition Required',      // RFC 6585 3
    429: 'Too Many Requests',          // RFC 6585 4
    431: 'Request Header Fields Too Large', // RFC 6585 5
    451: 'Unavailable For Legal Reasons', // RFC 7725 3
    500: 'Internal Server Error',      // RFC 7231 6.6.1
    501: 'Not Implemented',            // RFC 7231 6.6.2
    502: 'Bad Gateway',                // RFC 7231 6.6.3
    503: 'Service Unavailable',        // RFC 7231 6.6.4
    504: 'Gateway Timeout',            // RFC 7231 6.6.5
    505: 'HTTP Version Not Supported', // RFC 7231 6.6.6
    506: 'Variant Also Negotiates',    // RFC 2295 8.1
    507: 'Insufficient Storage',       // RFC 4918 11.5
    508: 'Loop Detected',              // RFC 5842 7.2
    509: 'Bandwidth Limit Exceeded',
    510: 'Not Extended',               // RFC 2774 7
    511: 'Network Authentication Required' // RFC 6585 6
};

const METHODS = [
    'GET',
    'POST',
    'PUT',
    'DELETE',
    'CONNECT',
    'HEAD',
    'OPTIONS',
    'TRACE',
    'PATCH'
];

function chunkToU8(chunk) {
    if (typeof chunk === ""string"") {
        return Buffer.from(chunk);
    }
    if (isTypedArray(chunk)) {
        return Buffer.from(chunk);
    }
    return chunk;
}

class ClientRequest extends Writable {
    body = null;
    constructor(opts, cb) {
        super();
        this.opts = opts;
        this.cb = cb
        this.body = new httpx.Buffer()
    }

    // deno-lint-ignore no-explicit-any
    _write(chunk, _enc, cb) {
        this.body.write(chunkToU8(chunk)?.buffer)
        cb()
    }

    async _final() {
        try {
            const opts = { body: this.body, method: this.opts.method, headers: this.opts.headers };
            const mayResponse = await fetch(this._createUrlStrFromOptions(this.opts), opts)
            const res = new IncomingMessageForClient(mayResponse);
            this.emit(""response"", res);
            this.cb?.(res);
        } catch (e) {
            this.emit('error', e)
        }
    }

    abort() {
        this.destroy();
    }

    _createCustomClient() {
        return Promise.resolve(undefined);
    }

    // deno-lint-ignore no-explicit-any
    _createUrlStrFromOptions(opts) {
        if (opts.href) {
            return opts.href;
        } else {
            const {
                auth,
                protocol,
                host,
                hostname,
                path,
                port,
            } = opts;
            return `${protocol}//${auth ? `${auth}@` : """"}${host ?? hostname}${port ? `:${port}` : """"}${path}`;
        }
    }

    get [Symbol.toStringTag]() {
        return 'Request'
    }
}

export class IncomingMessageForClient extends Readable {
    constructor(response) {
        super();
        this.response = response;
    }

    async _read(_size) {
        try {
            this.response.onChunk = (chunk) => {
                this.push(Buffer.from(chunk));
            }

            const _ = await this.response.arrayBuffer();
            this.emit('end')
        } catch (e) {
            // deno-lint-ignore no-explicit-any
            this.destroy(e);
        }
    }

    get headers() {
        if (this.response) {
            return Object.fromEntries(this.response.headers.entries());
        }
        return {};
    }

    get trailers() {
        return {};
    }

    get statusCode() {
        return this.response?.status || 0;
    }

    get statusMessage() {
        return this.response?.statusText || """";
    }
}

export class ServerResponse extends Writable {
    statusCode = undefined;
    statusMessage = undefined;
    #headers = {};
    headersSent = false;
    #conn;
    #firstChunk = null;
    #_end = false;

    constructor(conn) {
        super({
            autoDestroy: true,
            defaultEncoding: ""utf-8"",
            emitClose: true,
            write: (chunk, _encoding, cb) => {
                if (!this.headersSent) {
                    if (this.#firstChunk === null) {
                        this.#firstChunk = chunk;
                        if (!this.#_end) {
                            this.respond(false, this.#firstChunk);
                            this.#firstChunk = null;
                        }
                        return cb();
                    } else {
                        this.respond(false, this.#firstChunk);
                        this.#firstChunk = null;
                    }
                }

                this.#conn.write(chunk);
                return cb();
            },
            final: (cb) => {
                if (this.#firstChunk) {
                    this.respond(true, this.#firstChunk);
                } else if (!this.headersSent) {
                    this.respond(true);
                }
                if (this.#conn.connection == 'close') {
                    this.#conn.close()
                } else {
                    this.#conn.end();
                }
                return cb();
            },
            destroy: (err, cb) => {
                // if (err) {
                //     controller.error(err);
                // }
                return cb(null);
            },
        });
        this.#conn = conn;
    }

    setHeader(name, value) {
        this.#headers[name.toLowerCase()] = value;
        return this;
    }

    getHeader(name) {
        return this.#headers[name.toLowerCase()];
    }
    removeHeader(name) {
        return delete this.#headers[name.toLowerCase()];
    }
    getHeaderNames() {
        return Array.from(Object.keys(this.#headers));
    }
    hasHeader(name) {
        return this.#headers[name.toLowerCase()] != undefined;
    }

    writeHead(status, headers) {
        this.statusCode = status;
        for (const k in headers) {
            this.#headers[k.toLowerCase()] = headers[k];
        }
        return this;
    }

    #ensureHeaders(singleChunk) {
        if (this.statusCode === undefined) {
            this.statusCode = 200;
            this.statusMessage = ""OK"";
        }
        if (typeof singleChunk === ""string"" && !this.hasHeader(""content-type"")) {
            this.setHeader(""content-type"", ""text/plain;charset=UTF-8"");
        }
    }

    respond(final, singleChunk) {

        this.headersSent = true;
        this.#ensureHeaders(singleChunk);
        if (final) {
            this.#conn.respondWith(
                singleChunk, {
                headers: this.#headers,
                status: this.statusCode,
                statusText: this.statusMessage,
            }
            ).catch(() => {
                // ignore this error
            });
        } else {
            this.#conn.chunk({
                headers: this.#headers,
                status: this.statusCode,
                statusText: this.statusMessage,
            });
            this.#conn.write(singleChunk)
        }
    }

    // deno-lint-ignore no-explicit-any
    end(chunk, encoding, cb) {
        if (!this.headersSent) {
            if (!chunk && this.hasHeader(""transfer-encoding"")) {
                // FIXME(bnoordhuis) Node sends a zero length chunked body instead, i.e.,
                // the trailing ""0\r\n"", but respondWith() just hangs when I try that.
                this.setHeader(""content-length"", ""0"");
                this.removeHeader(""transfer-encoding"");
            }
        }
        this.#_end = true;

        // @ts-expect-error The signature for cb is stricter than the one implemented here
        return super.end(chunk, encoding, cb);
    }
}

export class IncomingMessageForServer extends Readable {
    #req;
    url;

    constructor(req, conn) {
        // Check if no body (GET/HEAD/OPTIONS/...)
        let value = req.body;
        super({
            autoDestroy: true,
            emitClose: true,
            objectMode: false,
            read: async function (_size) {
                if (!value) {
                    this.push(null);
                } else {
                    this.push(Buffer.from(value));
                    value = null;
                }
            },
            destroy: (err, cb) => {
                conn.close();
                cb(err);
            },
        });
        this.#req = req;
        this.url = req.uri;
    }

    get aborted() {
        return false;
    }
    get httpVersion() {
        return this.#req.version;
    }

    get headers() {
        return this.#req.headers;
    }
    get method() {
        return this.#req.method;
    }
}

class HttpConn {

    #chunk = undefined;
    #connection = 'close';
    #version = ""HTTP/1.1"";
    #chunkBuffer = undefined;
    #respHeaders;

    constructor(socket) {
        this.socket = socket
    }

    get connection() {
        return this.#connection;
    }

    get version() {
        return this.#version
    }

    async nextRequest() {
        let buffer = new httpx.Buffer();
        while (true) {
            let d = await this.socket.read();
            if (d == undefined || d.byteLength <= 0) {
                return null;
            }
            buffer.append(d);
            try {
                let req = buffer.parseRequest();
                if (req instanceof httpx.WasiRequest) {
                    this.#version = req.version;
                    if (this.#version == ""HTTP/1.1"") {
                        this.#connection = (req.getHeader('connection') ?? ""keep-alive"").toLowerCase()
                    } else if (this.#version == ""HTTP/1.0"") {
                        this.#connection = (req.getHeader('connection') ?? ""close"").toLowerCase()
                    }
                    return req
                }
            } catch (e) {
                return null;
            }
        }
    }

    respondWith(body, resp_header) {
        if (!this.socket) {
            return
        }
        if (body) {
            body = chunkToU8(body)?.buffer;
        }
        let resp = new httpx.WasiResponse()
        resp.version = this.#version;
        resp.headers = resp_header.headers;
        resp.status = resp_header.status;
        resp.statusText = resp_header.statusText;
        this.socket.write(resp.encode(body))
    }

    chunk(resp_header) {
        if (this.#version == ""HTTP/1.1"") {
            let resp = new httpx.WasiResponse()
            resp.version = this.#version;
            resp.headers = resp_header.headers;
            resp.status = resp_header.status;
            resp.statusText = resp_header.statusText;
            this.#chunk = resp.chunk(this.socket)
        } else {
            this.#chunkBuffer = new httpx.Buffer();
            this.#respHeaders = resp_header;
        }
    }

    write(chunk) {
        if (chunk) {
            let conn = this.#chunkBuffer ?? this.#chunk ?? this.socket;
            conn?.write(chunkToU8(chunk).buffer);
        }
    }

    end(chunk) {
        if (this.#chunk) {
            this.#chunk.end(chunk)
            this.#chunk = undefined
            return
        }

        if (this.#chunkBuffer && chunk) {
            this.#chunkBuffer.write(chunk)
        }

        if (this.#chunkBuffer) {
            this.respondWith(this.#chunkBuffer, this.#respHeaders);
            this.#chunkBuffer = null;
        }
    }

    close() {
        this.end()
        this.socket = undefined
    }
}


export function Server(handler) {
    return new ServerImpl(handler);
}


function _normalizeArgs(args) {
    let arr;

    if (args.length === 0) {
        arr = [{}, null];

        return arr;
    }

    const arg0 = args[0];
    let options = {};

    if (typeof arg0 === ""object"" && arg0 !== null) {
        // (options[...][, cb])
        options = arg0;
    } else {
        // ([port][, host][...][, cb])
        options.port = arg0;

        if (args.length > 1 && typeof args[1] === ""string"") {
            options.host = args[1];
        }
    }

    const cb = args[args.length - 1];

    if (typeof cb !== ""function"") {
        arr = [options, null];
    } else {
        arr = [options, cb];
    }

    return arr;
}


class ServerImpl extends EventEmitter {
    #httpConnections = new Set();
    #listener = undefined;
    #listening = false;

    constructor(handler) {
        super();

        if (handler !== undefined) {
            this.on(""request"", handler);
        }
    }

    listen(...args) {
        // TODO(bnoordhuis) Delegate to net.Server#listen().
        const normalized = _normalizeArgs(args);
        const options = normalized[0];
        const cb = normalized[1];

        if (cb != null) {
            // @ts-ignore change EventEmitter's sig to use CallableFunction
            this.once(""listening"", cb);
        }

        let port = 0;
        if (typeof options.port === ""number"" || typeof options.port === ""string"") {
            validatePort(options.port, ""options.port"");
            port = options.port | 0;
        }

        // TODO(bnoordhuis) Node prefers [::] when host is omitted,
        // we on the other hand default to 0.0.0.0.
        // const hostname = options.host ?? """";

        this.#listener = new net.WasiTcpServer(port);
        this.#listening = true;
        this.#listenLoop();

        return this;
    }

    async #listenLoop() {
        const go = async (httpConn) => {
            try {
                for (; ;) {
                    let request = null;
                    try {
                        // Note: httpConn.nextRequest() calls httpConn.close() on error.
                        request = await httpConn.nextRequest();
                    } catch {
                        // Connection closed.
                        // TODO(bnoordhuis) Emit ""clientError"" event on the http.Server
                        // instance? Node emits it when request parsing fails and expects
                        // the listener to send a raw 4xx HTTP response on the underlying
                        // net.Socket but we don't have one to pass to the listener.
                    }
                    if (request === null) {
                        break;
                    }
                    const req = new IncomingMessageForServer(request, httpConn);
                    const res = new ServerResponse(httpConn);
                    this.emit(""request"", req, res);
                }
            } finally {
                this.#httpConnections.delete(httpConn);
                httpConn.close()
            }
        };

        const listener = this.#listener;

        if (listener !== undefined) {
            this.emit(""listening"");

            try {
                while (this.#listening) {
                    let tcp_conn = await listener.accept();
                    try {
                        let httpConn = new HttpConn(tcp_conn);
                        this.#httpConnections.add(httpConn);
                        go(httpConn);
                    } catch {
                        continue;
                    }
                }
            } catch (e) {
                this.emit('error', e)
            } finally {
                this.listening = false
            }
        }
    }

    get listening() {
        return this.#listening !== undefined;
    }

    close(cb) {
        const listening = this.#listening;

        if (typeof cb === ""function"") {
            if (listening) {
                this.once(""close"", cb);
            } else {
                this.once(""close"", function close() {
                    cb(new ERR_SERVER_NOT_RUNNING());
                });
            }
        }

        process.nextTick(() => this.emit(""close""));

        if (listening) {
            this.#listener.close();
            this.#listener = undefined;
            this.#listening = false;

            for (const httpConn of this.#httpConnections) {
                try {
                    httpConn.close();
                } catch {
                    // Already closed.
                }
            }

            this.#httpConnections.clear();
        }

        return this;
    }

    get listening() {
        return this.#listener
    }

    address() {
        const addr = this.#listener.addr;
        return {
            port: addr.port,
            address: addr.hostname,
        };
    }
}

Server.prototype = ServerImpl.prototype;

export function createServer(handler) {
    return Server(handler);
}

function urlToHttpOptions(url) {
    // deno-lint-ignore no-explicit-any
    const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === ""string"" &&
            url.hostname.startsWith(""["")
            ? url.hostname.slice(1, -1)
            : url.hostname,
        path: url.path,
        href: url.href,
    };
    if (url.port !== """") {
        options.port = url.port;
    }
    if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
    }
    return options;
}

export function request(...args) {
    let options = {};
    if (typeof args[0] === ""string"") {
        options = urlToHttpOptions(new URL(args.shift()));
    } else if (args[0] instanceof URL) {
        options = urlToHttpOptions(args.shift());
    }
    if (args[0] && typeof args[0] !== ""function"") {
        Object.assign(options, args.shift());
    }
    args.unshift(options);
    return new ClientRequest(args[0], args[1]);
}

export function get(...args) {
    const req = request(args[0], args[1], args[2]);
    req.end();
    return req;
}

export default {
    ClientRequest,
    STATUS_CODES,
    METHODS,
    createServer,
    Server,
    IncomingMessage: IncomingMessageForServer,
    ServerResponse,
    request,
    get,
};"
modules/fmt/printf.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
/**
 * This implementation is inspired by POSIX and Golang but does not port
 * implementation code. */

const State = {
    PASSTHROUGH: 1,
    PERCENT: 2,
    POSITIONAL: 3,
    PRECISION: 4,
    WIDTH: 5,
}

const WorP = {
    WIDTH: 'WIDTH',
    PRECISION: 'PREC',
}

class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}

const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = ""\ufffd"";
const DEFAULT_PRECISION = 6;
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;

const F = {
    sign: 1,
    mantissa: 2,
    fractional: 3,
    esign: 4,
    exponent: 5,
}

class Printf {
    format;
    args = [];
    i;

    state = State.PASSTHROUGH;
    verb = """";
    buf = """";
    argNum = 0;
    flags = new Flags();

    haveSeen;

    // barf, store precision and width errors for later processing ...
    tmpError;

    constructor(format, ...args) {
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({ length: args.length });
        this.i = 0;
    }

    doPrintf() {
        for (; this.i < this.format.length; ++this.i) {
            const c = this.format[this.i];
            switch (this.state) {
                case State.PASSTHROUGH:
                    if (c === ""%"") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === ""%"") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error(""Should be unreachable, certainly a bug in the lib."");
            }
        }
        let extras = false;
        let err = ""%!(EXTRA)"";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }

    // %[<positional>]<flag>...<verb>
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for (; this.i < this.format.length; ++this.i) {
            const c = this.format[this.i];
            switch (this.state) {
                case State.PERCENT:
                    switch (c) {
                        case ""["":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case ""+"":
                            flags.plus = true;
                            break;
                        case ""<"":
                            flags.lessthan = true;
                            break;
                        case ""-"":
                            flags.dash = true;
                            flags.zero = false; // only left pad zeros, dash takes precedence
                            break;
                        case ""#"":
                            flags.sharp = true;
                            break;
                        case "" "":
                            flags.space = true;
                            break;
                        case ""0"":
                            // only left pad zeros, dash takes precedence
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ((""1"" <= c && c <= ""9"") || c === ""."" || c === ""*"") {
                                if (c === ""."") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return; // always end in verb
                            }
                    } // switch c
                    break;
                case State.POSITIONAL:
                    // TODO(bartlomieju): either a verb or * only verb for now
                    if (c === ""*"") {
                        const worp = this.flags.precision === -1
                            ? WorP.WIDTH
                            : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return; // always end in verb
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            } // switch state
        }
    }

    /**
     * Handle width or precision
     * @param wOrP
     */
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            // handle Positional should have already taken care of it...
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === ""number"") {
            switch (wOrP) {
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? ""WIDTH"" : ""PREC"";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }

    /**
     * Handle width and precision
     * @param flags
     */
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for (; this.i !== this.format.length; ++this.i) {
            const c = fmt[this.i];
            switch (this.state) {
                case State.WIDTH:
                    switch (c) {
                        case ""."":
                            // initialize precision, %9.f -> precision=0
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case ""*"":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            // force . or flag at this point
                            break;
                        default: {
                            const val = parseInt(c);
                            // most likely parseInt does something stupid that makes
                            // it unusable for this scenario ...
                            // if we encounter a non (number|*|.) we're done with prec & wid
                            if (isNaN(val)) {
                                this.i--;
                                this.state = State.PERCENT;
                                return;
                            }
                            flags.width = flags.width == -1 ? 0 : flags.width;
                            flags.width *= 10;
                            flags.width += val;
                        }
                    } // switch c
                    break;
                case State.PRECISION: {
                    if (c === ""*"") {
                        this.handleWidthOrPrecisionRef(WorP.PRECISION);
                        break;
                    }
                    const val = parseInt(c);
                    if (isNaN(val)) {
                        // one too far, rewind
                        this.i--;
                        this.state = State.PERCENT;
                        return;
                    }
                    flags.precision *= 10;
                    flags.precision += val;
                    break;
                }
                default:
                    throw new Error(""can't be here. bug."");
            } // switch state
        }
    }

    /** Handle positional */
    handlePositional() {
        if (this.format[this.i] !== ""["") {
            // sanity only
            throw new Error(""Can't happen? Bug."");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for (; this.i !== this.format.length; ++this.i) {
            if (format[this.i] === ""]"") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                //throw new Error(
                //  `invalid character in positional: ${format}[${format[this.i]}]`
                //);
                this.tmpError = ""%!(BAD INDEX)"";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = ""%!(BAD INDEX)"";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }

    /** Handle less than */
    handleLessThan() {
        // deno-lint-ignore no-explicit-any
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== ""Array"") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = ""[ "";
        for (let i = 0; i !== arg.length; ++i) {
            if (i !== 0) str += "", "";
            str += this._handleVerb(arg[i]);
        }
        return str + "" ]"";
    }

    /** Handle verb */
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true; // keep track of used args
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum]; // check out of range
            this.haveSeen[this.argNum] = true; // keep track of used args
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++; // if there is a further positional, it will reset.
        this.state = State.PASSTHROUGH;
    }

    // deno-lint-ignore no-explicit-any
    _handleVerb(arg) {
        switch (this.verb) {
            case ""t"":
                return this.pad(arg.toString());
            case ""b"":
                return this.fmtNumber(arg, 2);
            case ""c"":
                return this.fmtNumberCodePoint(arg);
            case ""d"":
                return this.fmtNumber(arg, 10);
            case ""o"":
                return this.fmtNumber(arg, 8);
            case ""x"":
                return this.fmtHex(arg);
            case ""X"":
                return this.fmtHex(arg, true);
            case ""e"":
                return this.fmtFloatE(arg);
            case ""E"":
                return this.fmtFloatE(arg, true);
            case ""f"":
            case ""F"":
                return this.fmtFloatF(arg);
            case ""g"":
                return this.fmtFloatG(arg);
            case ""G"":
                return this.fmtFloatG(arg, true);
            case ""s"":
                return this.fmtString(arg);
            case ""T"":
                return this.fmtString(typeof arg);
            case ""v"":
                return this.fmtV(arg);
            case ""j"":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }

    /**
     * Pad a string
     * @param s text to pad
     */
    pad(s) {
        const padding = this.flags.zero ? ""0"" : "" "";

        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }

        return s.padStart(this.flags.width, padding);
    }

    /**
     * Pad a number
     * @param nStr
     * @param neg
     */
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = ""-"";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? ""+"" : "" "";
        } else {
            sign = """";
        }
        const zero = this.flags.zero;
        if (!zero) {
            // sign comes in front of padding when padding w/ zero,
            // in from of value if padding with spaces.
            nStr = sign + nStr;
        }

        const pad = zero ? ""0"" : "" "";
        const len = zero ? this.flags.width - sign.length : this.flags.width;

        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }

        if (zero) {
            // see above
            nStr = sign + nStr;
        }
        return nStr;
    }

    /**
     * Format a number
     * @param n
     * @param radix
     * @param upcase
     */
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? """" : num;
            while (num.length < prec) {
                num = ""0"" + num;
            }
        }
        let prefix = """";
        if (this.flags.sharp) {
            switch (radix) {
                case 2:
                    prefix += ""0b"";
                    break;
                case 8:
                    // don't annotate octal 0 with 0...
                    prefix += num.startsWith(""0"") ? """" : ""0"";
                    break;
                case 16:
                    prefix += ""0x"";
                    break;
                default:
                    throw new Error(""cannot handle base: "" + radix);
            }
        }
        // don't add prefix in front of value truncated by precision=0, val=0
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }

    /**
     * Format number with code points
     * @param n
     */
    fmtNumberCodePoint(n) {
        let s = """";
        try {
            s = String.fromCodePoint(n);
        } catch {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }

    /**
     * Format special float
     * @param n
     */
    fmtFloatSpecial(n) {
        // formatting of NaN and Inf are pants-on-head
        // stupid and more or less arbitrary.

        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum(""NaN"", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum(""Inf"", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum(""Inf"", true);
        }
        return """";
    }

    /**
     * Round fraction to precision
     * @param fractional
     * @param precision
     * @returns tuple of fractional and round
     */
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = ""1"" + fractional; // prepend a 1 in case of leading 0
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === ""2"";
            fractional = fractional.substr(1); // remove extra 1
        } else {
            while (fractional.length < precision) {
                fractional += ""0"";
            }
        }
        return [fractional, round];
    }

    /**
     * Format float E
     * @param n
     * @param upcase
     */
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== """") {
            return special;
        }

        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error(""can't happen, bug"");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1
            ? this.flags.precision
            : DEFAULT_PRECISION;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(
            fractional,
            precision,
        );

        let e = m[F.exponent];
        let esign = m[F.esign];
        // scientific notation output with exponent padded to minlen 2
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? ""-"" : ""+"";
            }
        }
        e = e.length == 1 ? ""0"" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? ""E"" : ""e""}${esign}${e}`;
        return this.padNum(val, n < 0);
    }

    /**
     * Format float F
     * @param n
     */
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== """") {
            return special;
        }

        // stupid helper that turns a number into a (potentially)
        // VERY long string.
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ""."";
            }

            const t = n.toExponential().split(""e"");
            let m = t[0].replace(""."", """");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = ""0."";
                for (let i = 0; i !== Math.abs(e) - 1; ++i) {
                    nStr += ""0"";
                }
                return (nStr += m);
            } else {
                const splIdx = e + 1;
                while (m.length < splIdx) {
                    m += ""0"";
                }
                return m.substr(0, splIdx) + ""."" + m.substr(splIdx);
            }
        }
        // avoiding sign makes padding easier
        const val = expandNumber(Math.abs(n));
        const arr = val.split(""."");
        let dig = arr[0];
        let fractional = arr[1];

        const precision = this.flags.precision !== -1
            ? this.flags.precision
            : DEFAULT_PRECISION;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }

    /**
     * Format float G
     * @param n
     * @param upcase
     */
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== """") {
            return special;
        }

        // The double argument representing a floating-point number shall be
        // converted in the style f or e (or in the style F or E in
        // the case of a G conversion specifier), depending on the
        // value converted and the precision. Let P equal the
        // precision if non-zero, 6 if the precision is omitted, or 1
        // if the precision is zero. Then, if a conversion with style E would
        // have an exponent of X:

        //     - If P > X>=-4, the conversion shall be with style f (or F )
        //     and precision P -( X+1).

        //     - Otherwise, the conversion shall be with style e (or E )
        //     and precision P -1.

        // Finally, unless the '#' flag is used, any trailing zeros shall be
        // removed from the fractional portion of the result and the
        // decimal-point character shall be removed if there is no
        // fractional portion remaining.

        // A double argument representing an infinity or NaN shall be
        // converted in the style of an f or F conversion specifier.
        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html

        let P = this.flags.precision !== -1
            ? this.flags.precision
            : DEFAULT_PRECISION;
        P = P === 0 ? 1 : P;

        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error(""can't happen"");
        }

        const X = parseInt(m[F.exponent]) * (m[F.esign] === ""-"" ? -1 : 1);
        let nStr = """";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, """");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? ""E"" : ""e"");
            }
        }
        return nStr;
    }

    /**
     * Format string
     * @param s
     */
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }

    /**
     * Format hex
     * @param val
     * @param upper
     */
    fmtHex(val, upper = false) {
        // allow others types ?
        switch (typeof val) {
            case ""number"":
                return this.fmtNumber(val, 16, upper);
            case ""string"": {
                const sharp = this.flags.sharp && val.length !== 0;
                let hex = sharp ? ""0x"" : """";
                const prec = this.flags.precision;
                const end = prec !== -1 ? min(prec, val.length) : val.length;
                for (let i = 0; i !== end; ++i) {
                    if (i !== 0 && this.flags.space) {
                        hex += sharp ? "" 0x"" : "" "";
                    }
                    // TODO(bartlomieju): for now only taking into account the
                    // lower half of the codePoint, ie. as if a string
                    // is a list of 8bit values instead of UCS2 runes
                    const c = (val.charCodeAt(i) & 0xff).toString(16);
                    hex += c.length === 1 ? `0${c}` : c;
                }
                if (upper) {
                    hex = hex.toUpperCase();
                }
                return this.pad(hex);
            }
            default:
                throw new Error(
                    ""currently only number and string are implemented for hex"",
                );
        }
    }

    /**
     * Format value
     * @param val
     */
    fmtV(val) {
        if (this.flags.sharp) {
            return this.pad(JSON.stringify(val));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }

    /**
     * Format JSON
     * @param val
     */
    fmtJ(val) {
        return JSON.stringify(val);
    }
}

/**
 * Converts and format a variable number of `args` as is specified by `format`.
 * `sprintf` returns the formatted string.
 *
 * @param format
 * @param args
 */
export function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}

/**
 * Converts and format a variable number of `args` as is specified by `format`.
 * `printf` writes the formatted string to standard output.
 * @param format
 * @param args
 */
export function printf(format, ...args) {
    const s = sprintf(format, ...args);
    print(s);
}"
test/fixtures/keys/Makefile,"all: \
  ca1-cert.pem \
  ca2-cert.pem \
  ca2-crl.pem \
  ca3-cert.pem \
  ca4-cert.pem \
  ca5-cert.pem \
  ca6-cert.pem \
  agent1-cert.pem \
  agent1.pfx \
  agent2-cert.pem \
  agent3-cert.pem \
  agent4-cert.pem \
  agent5-cert.pem \
  agent6-cert.pem \
  agent6.pfx \
  agent7-cert.pem \
  agent8-cert.pem \
  agent9-cert.pem \
  agent10-cert.pem \
  agent10.pfx \
  ec10-cert.pem \
  ec10.pfx \
  dh512.pem \
  dh1024.pem \
  dh2048.pem \
  dherror.pem \
  dsa_params.pem \
  dsa_private.pem \
  dsa_private_encrypted.pem \
  dsa_private_pkcs8.pem \
  dsa_public.pem \
  dsa1025.pem \
  dsa_private_1025.pem \
  dsa_private_encrypted_1025.pem \
  dsa_public_1025.pem \
  ec-cert.pem \
  ec.pfx \
  fake-cnnic-root-cert.pem \
  rsa_private.pem \
  rsa_private_encrypted.pem \
  rsa_private_pkcs8.pem \
  rsa_private_pkcs8_bad.pem \
  rsa_public.pem \
  rsa_ca.crt \
  rsa_cert.crt \
  rsa_cert.pfx \
  rsa_public_sha1_signature_signedby_rsa_private.sha1 \
  rsa_public_sha1_signature_signedby_rsa_private_pkcs8.sha1 \
  rsa_private_b.pem \
  I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256 \
  rsa_public_b.pem \
  rsa_cert_foafssl_b.crt \
  rsa_cert_foafssl_b.modulus \
  rsa_cert_foafssl_b.exponent \
  rsa_spkac.spkac \
  rsa_spkac_invalid.spkac \
  rsa_private_1024.pem \
  rsa_private_2048.pem \
  rsa_private_4096.pem \
  rsa_public_1024.pem \
  rsa_public_2048.pem \
  rsa_public_4096.pem \
  rsa_pss_private_2048.pem \
  rsa_pss_private_2048_sha256_sha256_16.pem \
  rsa_pss_private_2048_sha512_sha256_20.pem \
  rsa_pss_private_2048_sha1_sha1_20.pem \
  rsa_pss_public_2048.pem \
  rsa_pss_public_2048_sha256_sha256_16.pem \
  rsa_pss_public_2048_sha512_sha256_20.pem \
  rsa_pss_public_2048_sha1_sha1_20.pem \
  ed25519_private.pem \
  ed25519_public.pem \
  x25519_private.pem \
  x25519_public.pem \
  ed448_private.pem \
  ed448_public.pem \
  x448_private.pem \
  x448_public.pem \
  ec_p256_private.pem \
  ec_p256_public.pem \
  ec_p384_private.pem \
  ec_p384_public.pem \
  ec_p521_private.pem \
  ec_p521_public.pem \
  ec_secp256k1_private.pem \
  ec_secp256k1_public.pem \
  incorrect_san_correct_subject-cert.pem \
  incorrect_san_correct_subject-key.pem \
  irrelevant_san_correct_subject-cert.pem \
  irrelevant_san_correct_subject-key.pem \

#
# Create Certificate Authority: ca1
# ('password' is used for the CA password.)
#
ca1-cert.pem: ca1.cnf
	openssl req -new -x509 -days 99999 -config ca1.cnf -keyout ca1-key.pem -out ca1-cert.pem

#
# Create Certificate Authority: ca2
# ('password' is used for the CA password.)
#
ca2-cert.pem: ca2.cnf
	openssl req -new -x509 -days 99999 -config ca2.cnf -keyout ca2-key.pem -out ca2-cert.pem
	echo '01' > ca2-serial
	touch ca2-database.txt

#
# Create Subordinate Certificate Authority: ca3 issued by ca1
# ('password' is used for the CA password.)
#
ca3-key.pem:
	openssl genrsa -out ca3-key.pem 1024

ca3-csr.pem: ca3.cnf ca3-key.pem
	openssl req -new \
		-extensions v3_ca \
		-config ca3.cnf \
		-key ca3-key.pem \
		-out ca3-csr.pem

ca3-cert.pem: ca3-csr.pem ca3-key.pem ca3.cnf ca1-cert.pem ca1-key.pem
	openssl x509 -req \
		-extfile ca3.cnf \
		-extensions v3_ca \
		-days 99999 \
		-passin ""pass:password"" \
		-in ca3-csr.pem \
		-CA ca1-cert.pem \
		-CAkey ca1-key.pem \
		-CAcreateserial \
		-out ca3-cert.pem

#
# Create Subordinate Certificate Authority: ca4 issued by ca2
# ('password' is used for the CA password.)
#
ca4-key.pem:
	openssl genrsa -out ca4-key.pem 1024

ca4-csr.pem: ca4.cnf ca4-key.pem
	openssl req -new \
		-extensions v3_ca \
		-config ca4.cnf \
		-key ca4-key.pem \
		-out ca4-csr.pem

ca4-cert.pem: ca4-csr.pem ca4-key.pem ca4.cnf ca2-cert.pem ca2-key.pem
	openssl x509 -req \
		-extfile ca4.cnf \
		-extensions v3_ca \
		-days 99999 \
		-passin ""pass:password"" \
		-in ca4-csr.pem \
		-CA ca2-cert.pem \
		-CAkey ca2-key.pem \
		-CAcreateserial \
		-out ca4-cert.pem

#
# Create Certificate Authority: ca5 with ECC
# ('password' is used for the CA password.)
#
ca5-key.pem:
	openssl ecparam -genkey -out ca5-key.pem -name prime256v1

ca5-csr.pem: ca5.cnf ca5-key.pem
	openssl req -new \
		-config ca5.cnf \
		-key ca5-key.pem \
		-out ca5-csr.pem

ca5-cert.pem: ca5.cnf ca5-key.pem ca5-csr.pem
	openssl x509 -req \
		-extfile ca5.cnf \
		-extensions v3_ca \
		-days 99999 \
		-passin ""pass:password"" \
		-in ca5-csr.pem \
		-signkey ca5-key.pem \
		-out ca5-cert.pem

#
# Create Subordinate Certificate Authority: ca6 issued by ca5 with ECC
# ('password' is used for the CA password.)
#
ca6-key.pem:
	openssl ecparam -genkey -out ca6-key.pem -name prime256v1

ca6-csr.pem: ca6.cnf ca6-key.pem
	openssl req -new \
		-extensions v3_ca \
		-config ca6.cnf \
		-key ca6-key.pem \
		-out ca6-csr.pem

ca6-cert.pem: ca6-csr.pem ca6-key.pem ca6.cnf ca5-cert.pem ca5-key.pem
	openssl x509 -req \
		-extfile ca6.cnf \
		-extensions v3_ca \
		-days 99999 \
		-passin ""pass:password"" \
		-in ca6-csr.pem \
		-CA ca5-cert.pem \
		-CAkey ca5-key.pem \
		-CAcreateserial \
		-out ca6-cert.pem

#
# Create Fake CNNIC Root Certificate Authority: fake-cnnic-root
#

fake-cnnic-root-key.pem:
	openssl genrsa -out fake-cnnic-root-key.pem 2048

fake-cnnic-root-cert.pem: fake-cnnic-root.cnf fake-cnnic-root-key.pem
	openssl req -x509 -new \
	        -key fake-cnnic-root-key.pem \
	        -days 99999 \
	        -out fake-cnnic-root-cert.pem \
	        -config fake-cnnic-root.cnf

#
# Create Fake StartCom Root Certificate Authority: fake-startcom-root
#
fake-startcom-root-key.pem:
	openssl genrsa -out fake-startcom-root-key.pem 2048

fake-startcom-root-cert.pem: fake-startcom-root.cnf \
	fake-startcom-root-key.pem
	openssl req -new -x509 -days 99999 -config \
	fake-startcom-root.cnf -key fake-startcom-root-key.pem -out \
	fake-startcom-root-cert.pem
	echo '01' > fake-startcom-root-serial
	touch fake-startcom-root-database.txt

#
# agent1 is signed by ca1.
#

agent1-key.pem:
	openssl genrsa -out agent1-key.pem 1024

agent1-csr.pem: agent1.cnf agent1-key.pem
	openssl req -new -config agent1.cnf -key agent1-key.pem -out agent1-csr.pem

agent1-cert.pem: agent1-csr.pem ca1-cert.pem ca1-key.pem
	openssl x509 -req \
		-extfile agent1.cnf \
		-extensions v3_ca \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent1-csr.pem \
		-CA ca1-cert.pem \
		-CAkey ca1-key.pem \
		-CAcreateserial \
		-out agent1-cert.pem

agent1.pfx: agent1-cert.pem agent1-key.pem ca1-cert.pem
	openssl pkcs12 -export \
		-descert \
		-in agent1-cert.pem \
		-inkey agent1-key.pem \
		-certfile ca1-cert.pem \
		-out agent1.pfx \
		-password pass:sample

agent1-verify: agent1-cert.pem ca1-cert.pem
	openssl verify -CAfile ca1-cert.pem agent1-cert.pem


#
# agent2 has a self signed cert
#
# Generate new private key
agent2-key.pem:
	openssl genrsa -out agent2-key.pem 1024

# Create a Certificate Signing Request for the key
agent2-csr.pem: agent2-key.pem agent2.cnf
	openssl req -new -config agent2.cnf -key agent2-key.pem -out agent2-csr.pem

# Create a Certificate for the agent.
agent2-cert.pem: agent2-csr.pem agent2-key.pem
	openssl x509 -req \
		-days 99999 \
		-in agent2-csr.pem \
		-signkey agent2-key.pem \
		-out agent2-cert.pem

agent2-verify: agent2-cert.pem
	openssl verify -CAfile agent2-cert.pem agent2-cert.pem

#
# agent3 is signed by ca2.
#

agent3-key.pem:
	openssl genrsa -out agent3-key.pem 1024

agent3-csr.pem: agent3.cnf agent3-key.pem
	openssl req -new -config agent3.cnf -key agent3-key.pem -out agent3-csr.pem

agent3-cert.pem: agent3-csr.pem ca2-cert.pem ca2-key.pem
	openssl x509 -req \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent3-csr.pem \
		-CA ca2-cert.pem \
		-CAkey ca2-key.pem \
		-CAcreateserial \
		-out agent3-cert.pem

agent3-verify: agent3-cert.pem ca2-cert.pem
	openssl verify -CAfile ca2-cert.pem agent3-cert.pem


#
# agent4 is signed by ca2 (client cert)
#

agent4-key.pem:
	openssl genrsa -out agent4-key.pem 1024

agent4-csr.pem: agent4.cnf agent4-key.pem
	openssl req -new -config agent4.cnf -key agent4-key.pem -out agent4-csr.pem

agent4-cert.pem: agent4-csr.pem ca2-cert.pem ca2-key.pem
	openssl x509 -req \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent4-csr.pem \
		-CA ca2-cert.pem \
		-CAkey ca2-key.pem \
		-CAcreateserial \
		-extfile agent4.cnf \
		-extensions ext_key_usage \
		-out agent4-cert.pem

agent4-verify: agent4-cert.pem ca2-cert.pem
	openssl verify -CAfile ca2-cert.pem agent4-cert.pem

#
# Make CRL with agent4 being rejected
#
ca2-crl.pem: ca2-key.pem ca2-cert.pem ca2.cnf agent4-cert.pem
	openssl ca -revoke agent4-cert.pem \
		-keyfile ca2-key.pem \
		-cert ca2-cert.pem \
		-config ca2.cnf \
		-passin 'pass:password'
	openssl ca \
		-keyfile ca2-key.pem \
		-cert ca2-cert.pem \
		-config ca2.cnf \
		-gencrl \
		-out ca2-crl.pem \
		-passin 'pass:password'

#
# agent5 is signed by ca2 (client cert)
#

agent5-key.pem:
	openssl genrsa -out agent5-key.pem 1024

agent5-csr.pem: agent5.cnf agent5-key.pem
	openssl req -new -config agent5.cnf -key agent5-key.pem -out agent5-csr.pem

agent5-cert.pem: agent5-csr.pem ca2-cert.pem ca2-key.pem
	openssl x509 -req \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent5-csr.pem \
		-CA ca2-cert.pem \
		-CAkey ca2-key.pem \
		-CAcreateserial \
		-extfile agent5.cnf \
		-extensions ext_key_usage \
		-out agent5-cert.pem

agent5-verify: agent5-cert.pem ca2-cert.pem
	openssl verify -CAfile ca2-cert.pem agent5-cert.pem

#
# agent6 is a client RSA cert signed by ca3
#

agent6-key.pem:
	openssl genrsa -out agent6-key.pem 1024

agent6-csr.pem: agent6.cnf agent6-key.pem
	openssl req -new -config agent6.cnf -key agent6-key.pem -out agent6-csr.pem

agent6-cert.pem: agent6-csr.pem ca3-cert.pem ca3-key.pem
	openssl x509 -req \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent6-csr.pem \
		-CA ca3-cert.pem \
		-CAkey ca3-key.pem \
		-CAcreateserial \
		-extfile agent6.cnf \
		-out agent6-cert.pem
	cat ca3-cert.pem >> agent6-cert.pem

agent6-verify: agent6-cert.pem ca3-cert.pem ca1-cert.pem
	openssl verify -trusted ca1-cert.pem -untrusted ca3-cert.pem agent6-cert.pem

agent6.pfx: agent6-cert.pem agent6-key.pem ca1-cert.pem
	openssl pkcs12 -export \
		-descert \
		-in agent6-cert.pem \
		-inkey agent6-key.pem \
		-certfile ca1-cert.pem \
		-out agent6.pfx \
		-password pass:sample

#
# agent7 is signed by fake-cnnic-root.
#

agent7-key.pem:
	openssl genrsa -out agent7-key.pem 2048

agent7-csr.pem: agent1.cnf agent7-key.pem
	openssl req -new -config agent7.cnf -key agent7-key.pem -out agent7-csr.pem

agent7-cert.pem: agent7-csr.pem fake-cnnic-root-cert.pem fake-cnnic-root-key.pem
	openssl x509 -req \
		-extfile agent7.cnf \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent7-csr.pem \
		-CA fake-cnnic-root-cert.pem \
		-CAkey fake-cnnic-root-key.pem \
		-CAcreateserial \
		-out agent7-cert.pem

agent7-verify: agent7-cert.pem fake-cnnic-root-cert.pem
	openssl verify -CAfile fake-cnnic-root-cert.pem agent7-cert.pem

#
# agent8 is signed by fake-startcom-root with notBefore
# of Oct 20 23:59:59 2016 GMT
#

agent8-key.pem:
	openssl genrsa -out agent8-key.pem 2048

agent8-csr.pem: agent8.cnf agent8-key.pem
	openssl req -new -config agent8.cnf -key agent8-key.pem \
	-out agent8-csr.pem

agent8-cert.pem: agent8-csr.pem fake-startcom-root-cert.pem fake-startcom-root-key.pem
	openssl ca \
		-config fake-startcom-root.cnf \
		-keyfile fake-startcom-root-key.pem \
		-cert fake-startcom-root-cert.pem \
		-batch \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent8-csr.pem \
		-startdate 161020235959Z \
		-notext -out agent8-cert.pem


agent8-verify: agent8-cert.pem fake-startcom-root-cert.pem
	openssl verify -CAfile fake-startcom-root-cert.pem \
	agent8-cert.pem


#
# agent9 is signed by fake-startcom-root with notBefore
# of Oct 21 00:00:01 2016 GMT
#
agent9-key.pem:
	openssl genrsa -out agent9-key.pem 2048

agent9-csr.pem: agent9.cnf agent9-key.pem
	openssl req -new -config agent9.cnf -key agent9-key.pem \
	-out agent9-csr.pem


agent9-cert.pem: agent9-csr.pem
	openssl ca \
		-config fake-startcom-root.cnf \
		-keyfile fake-startcom-root-key.pem \
		-cert fake-startcom-root-cert.pem \
		-batch \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent9-csr.pem \
		-startdate 20161021000001Z \
		-notext -out agent9-cert.pem

# agent10 is a server RSA cert signed by ca4 for agent10.example.com
#

agent10-key.pem:
	openssl genrsa -out agent10-key.pem 1024

agent10-csr.pem: agent10.cnf agent10-key.pem
	openssl req -new -config agent10.cnf -key agent10-key.pem -out agent10-csr.pem

agent10-cert.pem: agent10-csr.pem ca4-cert.pem ca4-key.pem
	openssl x509 -req \
		-days 99999 \
		-passin ""pass:password"" \
		-in agent10-csr.pem \
		-CA ca4-cert.pem \
		-CAkey ca4-key.pem \
		-CAcreateserial \
		-extfile agent10.cnf \
		-out agent10-cert.pem
	cat ca4-cert.pem >> agent10-cert.pem

agent10-verify: agent10-cert.pem ca4-cert.pem ca2-cert.pem
	openssl verify -trusted ca2-cert.pem -untrusted ca4-cert.pem agent10-cert.pem

agent10.pfx: agent10-cert.pem agent10-key.pem ca1-cert.pem
	openssl pkcs12 -export \
		-descert \
		-in agent10-cert.pem \
		-inkey agent10-key.pem \
		-certfile ca1-cert.pem \
		-out agent10.pfx \
		-password pass:sample

#
# ec10 is a server EC cert signed by ca6 for agent10.example.com
#

ec10-key.pem:
	openssl ecparam -genkey -out ec10-key.pem -name prime256v1

ec10-csr.pem: ec10-key.pem
	openssl req -new -config agent10.cnf -key ec10-key.pem -out ec10-csr.pem

ec10-cert.pem: ec10-csr.pem ca6-cert.pem ca6-key.pem
	openssl x509 -req \
		-days 99999 \
		-passin ""pass:password"" \
		-in ec10-csr.pem \
		-CA ca6-cert.pem \
		-CAkey ca6-key.pem \
		-CAcreateserial \
		-extfile agent10.cnf \
		-out ec10-cert.pem
	cat ca6-cert.pem >> ec10-cert.pem

ec10-verify: ec10-cert.pem ca6-cert.pem ca5-cert.pem
	openssl verify -trusted ca5-cert.pem -untrusted ca6-cert.pem ec10-cert.pem

ec10.pfx: ec10-cert.pem ec10-key.pem ca6-cert.pem
	openssl pkcs12 -export \
		-descert \
		-in ec10-cert.pem \
		-inkey ec10-key.pem \
		-certfile ca6-cert.pem \
		-out ec10.pfx \
		-password pass:sample


#
# ec is a self-signed EC cert for CN ""agent2""
#
ec-key.pem:
	openssl ecparam -genkey -out ec-key.pem -name prime256v1

ec-csr.pem: ec-key.pem
	openssl req -new -config ec.cnf -key ec-key.pem -out ec-csr.pem

ec-cert.pem: ec-csr.pem ec-key.pem
	openssl x509 -req \
		-days 99999 \
		-in ec-csr.pem \
		-signkey ec-key.pem \
		-out ec-cert.pem

ec.pfx: ec-cert.pem ec-key.pem
	openssl pkcs12 -export \
		-descert \
		-in ec-cert.pem \
		-inkey ec-key.pem \
		-out ec.pfx \
		-password pass:

dh512.pem:
	openssl dhparam -out dh512.pem 512

dh1024.pem:
	openssl dhparam -out dh1024.pem 1024

dh2048.pem:
	openssl dhparam -out dh2048.pem 2048

dherror.pem: dh512.pem
	sed 's/^[^-].*/AAAAAAAAAA/g' dh512.pem > dherror.pem

dsa_params.pem:
	openssl dsaparam -out dsa_params.pem 2048

dsa_private.pem: dsa_params.pem
	openssl gendsa -out dsa_private.pem dsa_params.pem

dsa_private_encrypted.pem: dsa_private.pem
	openssl dsa -aes256 -in dsa_private.pem -passout 'pass:password' -out dsa_private_encrypted.pem

dsa_private_pkcs8.pem: dsa_private.pem
	openssl pkcs8 -topk8 -inform PEM -outform PEM -in dsa_private.pem -out dsa_private_pkcs8.pem -nocrypt

dsa_public.pem: dsa_private.pem
	openssl dsa -in dsa_private.pem -pubout -out dsa_public.pem

dsa1025.pem:
	openssl dsaparam -out dsa1025.pem 1025

dsa_private_1025.pem:
	openssl gendsa -out dsa_private_1025.pem dsa1025.pem

dsa_private_encrypted_1025.pem:
	openssl pkcs8 -in dsa_private_1025.pem -topk8 -passout 'pass:secret' -out dsa_private_encrypted_1025.pem

dsa_public_1025.pem:
	openssl dsa -in dsa_private_1025.pem -pubout -out dsa_public_1025.pem

rsa_private.pem:
	openssl genrsa -out rsa_private.pem 2048

rsa_private_encrypted.pem: rsa_private.pem
	openssl rsa -aes256 -in rsa_private.pem -passout 'pass:password' -out rsa_private_encrypted.pem

rsa_private_pkcs8.pem: rsa_private.pem
	openssl pkcs8 -topk8 -inform PEM -outform PEM -in rsa_private.pem -out rsa_private_pkcs8.pem -nocrypt

rsa_private_pkcs8_bad.pem: rsa_private_pkcs8.pem
	sed 's/PRIVATE/RSA PRIVATE/g' rsa_private_pkcs8.pem > rsa_private_pkcs8_bad.pem

rsa_public.pem: rsa_private.pem
	openssl rsa -in rsa_private.pem -pubout -out rsa_public.pem

rsa_cert.crt: rsa_private.pem
	openssl req -new -x509 -days 99999 -key rsa_private.pem -config rsa_cert.cnf -out rsa_cert.crt

rsa_cert.pfx: rsa_cert.crt
	openssl pkcs12 -export -descert -passout 'pass:sample' -inkey rsa_private.pem -in rsa_cert.crt -out rsa_cert.pfx

rsa_ca.crt: rsa_cert.crt
	cp rsa_cert.crt rsa_ca.crt

rsa_public_sha1_signature_signedby_rsa_private.sha1: rsa_public.pem rsa_private.pem
	openssl dgst -sha1 -sign rsa_private.pem -out rsa_public_sha1_signature_signedby_rsa_private.sha1 rsa_public.pem

rsa_public_sha1_signature_signedby_rsa_private_pkcs8.sha1: rsa_public.pem rsa_private_pkcs8.pem
	openssl dgst -sha1 -sign rsa_private_pkcs8.pem -out rsa_public_sha1_signature_signedby_rsa_private_pkcs8.sha1 rsa_public.pem

rsa_private_b.pem:
	openssl genrsa -out rsa_private_b.pem 2048

I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256: rsa_private_b.pem
	echo -n ""I AM THE WALRUS"" | openssl dgst -sha256 -sign rsa_private_b.pem -out I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256

rsa_public_b.pem: rsa_private_b.pem
	openssl rsa -in rsa_private_b.pem -pubout -out rsa_public_b.pem

# The following 'foafssl' cert is used in test/parallel/test-https-foafssl.js.
# It requires a SAN like 'http://example.com/#me'. More info here:
# https://www.w3.org/wiki/Foaf+ssl
rsa_cert_foafssl_b.crt: rsa_private_b.pem
	openssl req -new -x509 -days 99999 -config rsa_cert_foafssl_b.cnf -key rsa_private_b.pem -out rsa_cert_foafssl_b.crt

# The 'modulus=' in the output must be stripped out
rsa_cert_foafssl_b.modulus: rsa_cert_foafssl_b.crt
	openssl x509 -modulus -in rsa_cert_foafssl_b.crt -noout | cut -c 9- > rsa_cert_foafssl_b.modulus

# Have to parse out the hex exponent
rsa_cert_foafssl_b.exponent: rsa_cert_foafssl_b.crt
	openssl x509 -in  rsa_cert_foafssl_b.crt -text | grep -o 'Exponent:.*' | sed 's/\(.*(\|).*\)//g' > rsa_cert_foafssl_b.exponent

# openssl outputs `SPKAC=[SPKAC]`. That prefix needs to be removed to work with node
rsa_spkac.spkac: rsa_private.pem
	openssl spkac -key rsa_private.pem -challenge this-is-a-challenge | cut -c 7- > rsa_spkac.spkac

# cutting characters from the start to invalidate the spkac
rsa_spkac_invalid.spkac: rsa_spkac.spkac
	cat rsa_spkac.spkac | cut -c 5- > rsa_spkac_invalid.spkac

rsa_private_1024.pem:
	openssl genrsa -out rsa_private_1024.pem 1024

rsa_private_2048.pem:
	openssl genrsa -out rsa_private_2048.pem 2048

rsa_private_4096.pem:
	openssl genrsa -out rsa_private_4096.pem 4096

rsa_public_1024.pem: rsa_private_1024.pem
	openssl rsa -in rsa_private_1024.pem -pubout -out rsa_public_1024.pem

rsa_public_2048.pem: rsa_private_2048.pem
	openssl rsa -in rsa_private_2048.pem -pubout -out rsa_public_2048.pem

rsa_public_4096.pem: rsa_private_4096.pem
	openssl rsa -in rsa_private_4096.pem -pubout -out rsa_public_4096.pem

rsa_pss_private_2048.pem:
	openssl genpkey -algorithm RSA-PSS -pkeyopt rsa_keygen_bits:2048 -pkeyopt rsa_keygen_pubexp:65537 -out rsa_pss_private_2048.pem

rsa_pss_private_2048_sha256_sha256_16.pem:
	openssl genpkey -algorithm RSA-PSS -pkeyopt rsa_keygen_bits:2048 -pkeyopt rsa_keygen_pubexp:65537 -pkeyopt rsa_pss_keygen_md:sha256 -pkeyopt rsa_pss_keygen_mgf1_md:sha256 -pkeyopt rsa_pss_keygen_saltlen:16 -out rsa_pss_private_2048_sha256_sha256_16.pem

rsa_pss_private_2048_sha512_sha256_20.pem:
	openssl genpkey -algorithm RSA-PSS -pkeyopt rsa_keygen_bits:2048 -pkeyopt rsa_keygen_pubexp:65537 -pkeyopt rsa_pss_keygen_md:sha512 -pkeyopt rsa_pss_keygen_mgf1_md:sha256 -pkeyopt rsa_pss_keygen_saltlen:20 -out rsa_pss_private_2048_sha512_sha256_20.pem

rsa_pss_private_2048_sha1_sha1_20.pem:
	openssl genpkey -algorithm RSA-PSS -pkeyopt rsa_keygen_bits:2048 -pkeyopt rsa_keygen_pubexp:65537 -pkeyopt rsa_pss_keygen_md:sha1 -pkeyopt rsa_pss_keygen_mgf1_md:sha1 -pkeyopt rsa_pss_keygen_saltlen:20 -out rsa_pss_private_2048_sha1_sha1_20.pem

rsa_pss_public_2048.pem: rsa_pss_private_2048.pem
	openssl pkey -in rsa_pss_private_2048.pem -pubout -out rsa_pss_public_2048.pem

rsa_pss_public_2048_sha256_sha256_16.pem: rsa_pss_private_2048_sha256_sha256_16.pem
	openssl pkey -in rsa_pss_private_2048_sha256_sha256_16.pem -pubout -out rsa_pss_public_2048_sha256_sha256_16.pem

rsa_pss_public_2048_sha512_sha256_20.pem: rsa_pss_private_2048_sha512_sha256_20.pem
	openssl pkey -in rsa_pss_private_2048_sha512_sha256_20.pem -pubout -out rsa_pss_public_2048_sha512_sha256_20.pem

rsa_pss_public_2048_sha1_sha1_20.pem: rsa_pss_private_2048_sha1_sha1_20.pem
	openssl pkey -in rsa_pss_private_2048_sha1_sha1_20.pem -pubout -out rsa_pss_public_2048_sha1_sha1_20.pem

ed25519_private.pem:
	openssl genpkey -algorithm ED25519 -out ed25519_private.pem

ed25519_public.pem: ed25519_private.pem
	openssl pkey -in ed25519_private.pem -pubout -out ed25519_public.pem

x25519_private.pem:
	openssl genpkey -algorithm x25519 -out x25519_private.pem

x25519_public.pem: x25519_private.pem
	openssl pkey -in x25519_private.pem -pubout -out x25519_public.pem

ed448_private.pem:
	openssl genpkey -algorithm ed448 -out ed448_private.pem

ed448_public.pem: ed448_private.pem
	openssl pkey -in ed448_private.pem -pubout -out ed448_public.pem

x448_private.pem:
	openssl genpkey -algorithm x448 -out x448_private.pem

x448_public.pem: x448_private.pem
	openssl pkey -in x448_private.pem -pubout -out x448_public.pem

ec_p256_private.pem:
	openssl ecparam -name prime256v1 -genkey -noout -out sec1_ec_p256_private.pem
	openssl pkcs8 -topk8 -nocrypt -in sec1_ec_p256_private.pem -out ec_p256_private.pem
	rm sec1_ec_p256_private.pem

ec_p256_public.pem: ec_p256_private.pem
	openssl ec -in ec_p256_private.pem -pubout -out ec_p256_public.pem

ec_p384_private.pem:
	openssl ecparam -name secp384r1 -genkey -noout -out sec1_ec_p384_private.pem
	openssl pkcs8 -topk8 -nocrypt -in sec1_ec_p384_private.pem -out ec_p384_private.pem
	rm sec1_ec_p384_private.pem

ec_p384_public.pem: ec_p384_private.pem
	openssl ec -in ec_p384_private.pem -pubout -out ec_p384_public.pem

ec_p521_private.pem:
	openssl ecparam -name secp521r1 -genkey -noout -out sec1_ec_p521_private.pem
	openssl pkcs8 -topk8 -nocrypt -in sec1_ec_p521_private.pem -out ec_p521_private.pem
	rm sec1_ec_p521_private.pem

ec_p521_public.pem: ec_p521_private.pem
	openssl ec -in ec_p521_private.pem -pubout -out ec_p521_public.pem

ec_secp256k1_private.pem:
	openssl ecparam -name secp256k1 -genkey -noout -out sec1_ec_secp256k1_private.pem
	openssl pkcs8 -topk8 -nocrypt -in sec1_ec_secp256k1_private.pem -out ec_secp256k1_private.pem
	rm sec1_ec_secp256k1_private.pem

ec_secp256k1_public.pem: ec_secp256k1_private.pem
	openssl ec -in ec_secp256k1_private.pem -pubout -out ec_secp256k1_public.pem

incorrect_san_correct_subject-cert.pem: incorrect_san_correct_subject-key.pem
	openssl req -x509 \
	            -key incorrect_san_correct_subject-key.pem \
	            -out incorrect_san_correct_subject-cert.pem \
	            -sha256 \
	            -days 3650 \
	            -subj ""/CN=good.example.com"" \
	            -addext ""subjectAltName = DNS:evil.example.com""

incorrect_san_correct_subject-key.pem:
	openssl ecparam -name prime256v1 -genkey -noout -out incorrect_san_correct_subject-key.pem

irrelevant_san_correct_subject-cert.pem: irrelevant_san_correct_subject-key.pem
	openssl req -x509 \
	            -key irrelevant_san_correct_subject-key.pem \
	            -out irrelevant_san_correct_subject-cert.pem \
	            -sha256 \
	            -days 3650 \
	            -subj ""/CN=good.example.com"" \
	            -addext ""subjectAltName = IP:1.2.3.4""

irrelevant_san_correct_subject-key.pem:
	openssl ecparam -name prime256v1 -genkey -noout -out irrelevant_san_correct_subject-key.pem

clean:
	rm -f *.pfx *.pem *.srl ca2-database.txt ca2-serial fake-startcom-root-serial *.print *.old fake-startcom-root-issued-certs/*.pem
	@> fake-startcom-root-database.txt

test: agent1-verify agent2-verify agent3-verify agent4-verify agent5-verify agent6-verify agent7-verify agent8-verify agent10-verify ec10-verify

%-cert.pem.print: %-cert.pem
	openssl x509 -in $< -text -noout > $@

.PHONY: all clean test agent1-verify agent2-verify agent3-verify agent4-verify agent5-verify agent6-verify agent7-verify agent8-verify agent10-verify ec10-verify
"
modules/path.js,"import process from 'process';
import { ERR_INVALID_ARG_TYPE } from './internal/errors';
import { getValidatedPath } from './internal/fs/utils';

var exports$1 = {},
    _dewExec = false;
function dew() {
  if (_dewExec) { return exports$1; }
  _dewExec = true;
  var process$1 = process;

  function assertPath(path) {
    if (typeof path !== ""string"") {
      throw new ERR_INVALID_ARG_TYPE(""path"", ""string"", path);
    }
  } // Resolves . and .. elements in a path with directory names


  function normalizeStringPosix(path, allowAboveRoot) {
    var res = """";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;

    for (var i = 0; i <= path.length; ++i) {
      if (i < path.length) { code = path.charCodeAt(i); }else if (code === 47
      /*/*/
      ) { break; }else { code = 47
      /*/*/
      ; }

      if (code === 47
      /*/*/
      ) {
        if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46
          /*.*/
          || res.charCodeAt(res.length - 2) !== 46
          /*.*/
          ) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf(""/"");

              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = """";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf(""/"");
                }

                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = """";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }

          if (allowAboveRoot) {
            if (res.length > 0) { res += ""/..""; }else { res = ""..""; }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) { res += ""/"" + path.slice(lastSlash + 1, i); }else { res = path.slice(lastSlash + 1, i); }
          lastSegmentLength = i - lastSlash - 1;
        }

        lastSlash = i;
        dots = 0;
      } else if (code === 46
      /*.*/
      && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }

    return res;
  }

  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || """") + (pathObject.ext || """");

    if (!dir) {
      return base;
    }

    if (dir === pathObject.root) {
      return dir + base;
    }

    return dir + sep + base;
  }

  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
      var arguments$1 = arguments;

      var resolvedPath = """";
      var resolvedAbsolute = false;
      var cwd;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path;
        if (i >= 0) { path = arguments$1[i]; }else {
          if (cwd === undefined) { cwd = process$1.cwd(); }
          path = cwd;
        }
        assertPath(path); // Skip empty entries

        if (path.length === 0) {
          continue;
        }

        resolvedPath = path + ""/"" + resolvedPath;
        resolvedAbsolute = path.charCodeAt(0) === 47
        /*/*/
        ;
      } // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path


      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) { return ""/"" + resolvedPath; }else { return ""/""; }
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ""."";
      }
    },
    normalize: function normalize(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var isAbsolute = path.charCodeAt(0) === 47
      /*/*/
      ;
      var trailingSeparator = path.charCodeAt(path.length - 1) === 47
      /*/*/
      ; // Normalize the path

      path = normalizeStringPosix(path, !isAbsolute);
      if (path.length === 0 && !isAbsolute) { path = "".""; }
      if (path.length > 0 && trailingSeparator) { path += ""/""; }
      if (isAbsolute) { return ""/"" + path; }
      return path;
    },
    isAbsolute: function isAbsolute(path) {
      assertPath(path);
      return path.length > 0 && path.charCodeAt(0) === 47
      /*/*/
      ;
    },
    join: function join() {
      var arguments$1 = arguments;

      if (arguments.length === 0) { return "".""; }
      var joined;

      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments$1[i];
        assertPath(arg);

        if (arg.length > 0) {
          if (joined === undefined) { joined = arg; }else { joined += ""/"" + arg; }
        }
      }

      if (joined === undefined) { return "".""; }
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) { return """"; }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) { return """"; } // Trim any leading backslashes

      var fromStart = 1;

      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47
        /*/*/
        ) { break; }
      }

      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart; // Trim any leading backslashes

      var toStart = 1;

      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47
        /*/*/
        ) { break; }
      }

      var toEnd = to.length;
      var toLen = toEnd - toStart; // Compare paths to find the longest common path from root

      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;

      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47
            /*/*/
            ) {
              // We get here if `from` is the exact base path for `to`.
              // For example: from='/foo/bar'; to='/foo/bar/baz'
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              // We get here if `from` is the root
              // For example: from='/'; to='/foo'
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47
            /*/*/
            ) {
              // We get here if `to` is the exact base path for `from`.
              // For example: from='/foo/bar/baz'; to='/foo/bar'
              lastCommonSep = i;
            } else if (i === 0) {
              // We get here if `to` is the root.
              // For example: from='/foo'; to='/'
              lastCommonSep = 0;
            }
          }

          break;
        }

        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) { break; }else if (fromCode === 47
        /*/*/
        ) { lastCommonSep = i; }
      }

      var out = """"; // Generate the relative path based on the path difference between `to`
      // and `from`

      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47
        /*/*/
        ) {
          if (out.length === 0) { out += ""..""; }else { out += ""/..""; }
        }
      } // Lastly, append the rest of the destination (`to`) path that comes after
      // the common path parts


      if (out.length > 0) { return out + to.slice(toStart + lastCommonSep); }else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47
        /*/*/
        ) { ++toStart; }
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path) {
      return path;
    },
    dirname: function dirname(path) {
      assertPath(path);
      if (path.length === 0) { return "".""; }
      var code = path.charCodeAt(0);
      var hasRoot = code === 47
      /*/*/
      ;
      var end = -1;
      var matchedSlash = true;

      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }

      if (end === -1) { return hasRoot ? ""/"" : "".""; }
      if (hasRoot && end === 1) { return ""//""; }
      return path.slice(0, end);
    },
    basename: function basename(path, ext) {
      if (ext !== undefined && typeof ext !== ""string"") { throw new ERR_INVALID_ARG_TYPE(""ext"", ""string"", ext); }
      assertPath(path);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;

      if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) { return """"; }
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;

        for (i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);

          if (code === 47
          /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              // We saw the first non-path separator, remember this index in case
              // we need it if the extension ends up not matching
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }

            if (extIdx >= 0) {
              // Try to match the explicit extension
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  // We matched the extension, so mark this as the end of our path
                  // component
                  end = i;
                }
              } else {
                // Extension does not match, so our result is the entire path
                // component
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }

        if (start === end) { end = firstNonSlashEnd; }else if (end === -1) { end = path.length; }
        return path.slice(start, end);
      } else {
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === 47
          /*/*/
          ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // path component
            matchedSlash = false;
            end = i + 1;
          }
        }

        if (end === -1) { return """"; }
        return path.slice(start, end);
      }
    },
    extname: function extname(path) {
      assertPath(path);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0;

      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
        /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; }else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return """";
      }

      return path.slice(startDot, end);
    },
    format: function format(pathObject) {
      if (pathObject === null || typeof pathObject !== ""object"") {
        throw new ERR_INVALID_ARG_TYPE(""pathObject"", ""object"", pathObject);
      }

      return _format(""/"", pathObject);
    },
    parse: function parse(path) {
      assertPath(path);
      var ret = {
        root: """",
        dir: """",
        base: """",
        ext: """",
        name: """"
      };
      if (path.length === 0) { return ret; }
      var code = path.charCodeAt(0);
      var isAbsolute = code === 47
      /*/*/
      ;
      var start;

      if (isAbsolute) {
        ret.root = ""/"";
        start = 1;
      } else {
        start = 0;
      }

      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find

      var preDotState = 0; // Get non-dir info

      for (; i >= start; --i) {
        code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }

        if (code === 46
        /*.*/
        ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) { startDot = i; }else if (preDotState !== 1) { preDotState = 1; }
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute) { ret.base = ret.name = path.slice(1, end); }else { ret.base = ret.name = path.slice(startPart, end); }
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
        }

        ret.ext = path.slice(startDot, end);
      }

      if (startPart > 0) { ret.dir = path.slice(0, startPart - 1); }else if (isAbsolute) { ret.dir = ""/""; }
      return ret;
    },
    toNamespacedPath: (val) => val,
    sep: ""/"",
    delimiter: "":"",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports$1 = posix;
  return exports$1;
}

var exports = dew();

var _makeLong = exports._makeLong;
var basename = exports.basename;
var delimiter = exports.delimiter;
var dirname = exports.dirname;
var extname = exports.extname;
var format = exports.format;
var isAbsolute = exports.isAbsolute;
var join = exports.join;
var normalize = exports.normalize;
var parse = exports.parse;
var posix = exports.posix;
var relative = exports.relative;
var resolve = exports.resolve;
var sep = exports.sep;
var win32 = exports.win32;
var toNamespacedPath = exports.toNamespacedPath;

export { _makeLong, basename, exports as default, delimiter, dirname, extname, format, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32, toNamespacedPath };
"
test/crypto/test-crypto-sign-verify.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const fs = require('fs');
const path = require('path');
const exec = require('child_process').exec;
const crypto = require('crypto');
const fixtures = require('../common/fixtures');

// Test certificates
const certPem = fixtures.readKey('rsa_cert.crt');
const keyPem = fixtures.readKey('rsa_private.pem');
const keySize = 2048;

{
  const Sign = crypto.Sign;
  const instance = Sign('SHA256');
  assert(instance instanceof Sign, 'Sign is expected to return a new ' +
                                   'instance when called without `new`');
}

{
  const Verify = crypto.Verify;
  const instance = Verify('SHA256');
  assert(instance instanceof Verify, 'Verify is expected to return a new ' +
                                     'instance when called without `new`');
}

// Test handling of exceptional conditions
{
  const library = {
    configurable: true,
    set() {
      throw new Error('bye, bye, library');
    }
  };
  Object.defineProperty(Object.prototype, 'library', library);

  assert.throws(() => {
    crypto.createSign('sha1').sign(
      `-----BEGIN RSA PRIVATE KEY-----
      AAAAAAAAAAAA
      -----END RSA PRIVATE KEY-----`);
  }, { message: 'bye, bye, library' });

  delete Object.prototype.library;

  const errorStack = {
    configurable: true,
    set() {
      throw new Error('bye, bye, error stack');
    }
  };
  Object.defineProperty(Object.prototype, 'opensslErrorStack', errorStack);

  assert.throws(() => {
    crypto.createSign('SHA1')
      .update('Test123')
      .sign({
        key: keyPem,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
      });
  }, { message: common.hasOpenSSL3 ?
    'error:1C8000A5:Provider routines::illegal or unsupported padding mode' :
    'bye, bye, error stack' });

  delete Object.prototype.opensslErrorStack;
}

assert.throws(
  () => crypto.createVerify('SHA256').verify({
    key: certPem,
    padding: null,
  }, ''),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    name: 'TypeError',
    message: ""The property 'options.padding' is invalid. Received null"",
  });

assert.throws(
  () => crypto.createVerify('SHA256').verify({
    key: certPem,
    saltLength: null,
  }, ''),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    name: 'TypeError',
    message: ""The property 'options.saltLength' is invalid. Received null"",
  });

// Test signing and verifying
{
  const s1 = crypto.createSign('SHA1')
                   .update('Test123')
                   .sign(keyPem, 'base64');
  let s1stream = crypto.createSign('SHA1');
  s1stream.end('Test123');
  s1stream = s1stream.sign(keyPem, 'base64');
  assert.strictEqual(s1, s1stream, `${s1} should equal ${s1stream}`);

  const verified = crypto.createVerify('SHA1')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s1, 'base64');
  assert.strictEqual(verified, true);
}

{
  const s2 = crypto.createSign('SHA256')
                   .update('Test123')
                   .sign(keyPem, 'latin1');
  let s2stream = crypto.createSign('SHA256');
  s2stream.end('Test123');
  s2stream = s2stream.sign(keyPem, 'latin1');
  assert.strictEqual(s2, s2stream, `${s2} should equal ${s2stream}`);

  let verified = crypto.createVerify('SHA256')
                       .update('Test')
                       .update('123')
                       .verify(certPem, s2, 'latin1');
  assert.strictEqual(verified, true);

  const verStream = crypto.createVerify('SHA256');
  verStream.write('Tes');
  verStream.write('t12');
  verStream.end('3');
  verified = verStream.verify(certPem, s2, 'latin1');
  assert.strictEqual(verified, true);
}

{
  const s3 = crypto.createSign('SHA1')
                   .update('Test123')
                   .sign(keyPem, 'buffer');
  let verified = crypto.createVerify('SHA1')
                       .update('Test')
                       .update('123')
                       .verify(certPem, s3);
  assert.strictEqual(verified, true);

  const verStream = crypto.createVerify('SHA1');
  verStream.write('Tes');
  verStream.write('t12');
  verStream.end('3');
  verified = verStream.verify(certPem, s3);
  assert.strictEqual(verified, true);
}

// Special tests for RSA_PKCS1_PSS_PADDING
{
  function testPSS(algo, hLen) {
    // Maximum permissible salt length
    const max = keySize / 8 - hLen - 2;

    function getEffectiveSaltLength(saltLength) {
      switch (saltLength) {
        case crypto.constants.RSA_PSS_SALTLEN_DIGEST:
          return hLen;
        case crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN:
          return max;
        default:
          return saltLength;
      }
    }

    const signSaltLengths = [
      crypto.constants.RSA_PSS_SALTLEN_DIGEST,
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_DIGEST),
      crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN,
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN),
      0, 16, 32, 64, 128,
    ];

    const verifySaltLengths = [
      crypto.constants.RSA_PSS_SALTLEN_DIGEST,
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_DIGEST),
      getEffectiveSaltLength(crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN),
      0, 16, 32, 64, 128,
    ];
    const errMessage = /^Error:.*data too large for key size$/;

    const data = Buffer.from('Test123');

    signSaltLengths.forEach((signSaltLength) => {
      if (signSaltLength > max) {
        // If the salt length is too big, an Error should be thrown
        assert.throws(() => {
          crypto.createSign(algo)
            .update(data)
            .sign({
              key: keyPem,
              padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
              saltLength: signSaltLength
            });
        }, errMessage);
        assert.throws(() => {
          crypto.sign(algo, data, {
            key: keyPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: signSaltLength
          });
        }, errMessage);
      } else {
        // Otherwise, a valid signature should be generated
        const s4 = crypto.createSign(algo)
                         .update(data)
                         .sign({
                           key: keyPem,
                           padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                           saltLength: signSaltLength
                         });
        const s4_2 = crypto.sign(algo, data, {
          key: keyPem,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: signSaltLength
        });

        [s4, s4_2].forEach((sig) => {
          let verified;
          verifySaltLengths.forEach((verifySaltLength) => {
            // Verification should succeed if and only if the salt length is
            // correct
            verified = crypto.createVerify(algo)
                             .update(data)
                             .verify({
                               key: certPem,
                               padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                               saltLength: verifySaltLength
                             }, sig);
            assert.strictEqual(verified, crypto.verify(algo, data, {
              key: certPem,
              padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
              saltLength: verifySaltLength
            }, sig));
            const saltLengthCorrect = getEffectiveSaltLength(signSaltLength) ===
                                      getEffectiveSaltLength(verifySaltLength);
            assert.strictEqual(verified, saltLengthCorrect);
          });

          // Verification using RSA_PSS_SALTLEN_AUTO should always work
          verified = crypto.createVerify(algo)
                           .update(data)
                           .verify({
                             key: certPem,
                             padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                             saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
                           }, sig);
          assert.strictEqual(verified, true);
          assert.strictEqual(verified, crypto.verify(algo, data, {
            key: certPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
          }, sig));

          // Verifying an incorrect message should never work
          const wrongData = Buffer.from('Test1234');
          verified = crypto.createVerify(algo)
                           .update(wrongData)
                           .verify({
                             key: certPem,
                             padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                             saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
                           }, sig);
          assert.strictEqual(verified, false);
          assert.strictEqual(verified, crypto.verify(algo, wrongData, {
            key: certPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_AUTO
          }, sig));
        });
      }
    });
  }

  testPSS('SHA1', 20);
  testPSS('SHA256', 32);
}

// Test vectors for RSA_PKCS1_PSS_PADDING provided by the RSA Laboratories:
// https://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm
{
  // We only test verification as we cannot specify explicit salts when signing
  function testVerify(cert, vector) {
    const verified = crypto.createVerify('SHA1')
                          .update(Buffer.from(vector.message, 'hex'))
                          .verify({
                            key: cert,
                            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                            saltLength: vector.salt.length / 2
                          }, vector.signature, 'hex');
    assert.strictEqual(verified, true);
  }

  const examples = JSON.parse(fixtures.readSync('pss-vectors.json', 'utf8'));

  for (const key in examples) {
    const example = examples[key];
    const publicKey = example.publicKey.join('\n');
    example.tests.forEach((test) => testVerify(publicKey, test));
  }
}

// Test exceptions for invalid `padding` and `saltLength` values
{
  [null, NaN, 'boom', {}, [], true, false]
    .forEach((invalidValue) => {
      assert.throws(() => {
        crypto.createSign('SHA256')
          .update('Test123')
          .sign({
            key: keyPem,
            padding: invalidValue
          });
      }, {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError'
      });

      assert.throws(() => {
        crypto.createSign('SHA256')
          .update('Test123')
          .sign({
            key: keyPem,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: invalidValue
          });
      }, {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError'
      });
    });

  assert.throws(() => {
    crypto.createSign('SHA1')
      .update('Test123')
      .sign({
        key: keyPem,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
      });
  }, common.hasOpenSSL3 ? {
    code: 'ERR_OSSL_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE',
    message: /illegal or unsupported padding mode/,
  } : {
    code: 'ERR_OSSL_RSA_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE',
    message: /illegal or unsupported padding mode/,
    opensslErrorStack: [
      'error:06089093:digital envelope routines:EVP_PKEY_CTX_ctrl:' +
      'command not supported',
    ],
  });
}

// Test throws exception when key options is null
{
  assert.throws(() => {
    crypto.createSign('SHA1').update('Test123').sign(null, 'base64');
  }, {
    code: 'ERR_CRYPTO_SIGN_KEY_REQUIRED',
    name: 'Error'
  });
}

{
  const sign = crypto.createSign('SHA1');
  const verify = crypto.createVerify('SHA1');

  [1, [], {}, undefined, null, true, Infinity].forEach((input) => {
    const errObj = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""algorithm"" argument must be of type string.' +
               `${common.invalidArgTypeHelper(input)}`
    };
    assert.throws(() => crypto.createSign(input), errObj);
    assert.throws(() => crypto.createVerify(input), errObj);

    errObj.message = 'The ""data"" argument must be of type string or an ' +
                     'instance of Buffer, TypedArray, or DataView.' +
                     common.invalidArgTypeHelper(input);
    assert.throws(() => sign.update(input), errObj);
    assert.throws(() => verify.update(input), errObj);
    assert.throws(() => sign._write(input, 'utf8', () => {}), errObj);
    assert.throws(() => verify._write(input, 'utf8', () => {}), errObj);
  });

  [
    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,
  ].forEach((clazz) => {
    // These should all just work
    sign.update(new clazz());
    verify.update(new clazz());
  });

  [1, {}, [], Infinity].forEach((input) => {
    const errObj = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    };
    assert.throws(() => sign.sign(input), errObj);
    assert.throws(() => verify.verify(input), errObj);
    assert.throws(() => verify.verify('test', input), errObj);
  });
}

{
  assert.throws(
    () => crypto.createSign('sha8'),
    /Invalid digest/);
  assert.throws(
    () => crypto.sign('sha8', Buffer.alloc(1), keyPem),
    /Invalid digest/);
}

[
  { private: fixtures.readKey('ed25519_private.pem', 'ascii'),
    public: fixtures.readKey('ed25519_public.pem', 'ascii'),
    algo: null,
    sigLen: 64 },
  { private: fixtures.readKey('ed448_private.pem', 'ascii'),
    public: fixtures.readKey('ed448_public.pem', 'ascii'),
    algo: null,
    sigLen: 114 },
  { private: fixtures.readKey('rsa_private_2048.pem', 'ascii'),
    public: fixtures.readKey('rsa_public_2048.pem', 'ascii'),
    algo: 'sha1',
    sigLen: 256 },
].forEach((pair) => {
  const algo = pair.algo;

  {
    const data = Buffer.from('Hello world');
    const sig = crypto.sign(algo, data, pair.private);
    assert.strictEqual(sig.length, pair.sigLen);

    assert.strictEqual(crypto.verify(algo, data, pair.private, sig),
                       true);
    assert.strictEqual(crypto.verify(algo, data, pair.public, sig),
                       true);
  }

  {
    const data = Buffer.from('Hello world');
    const privKeyObj = crypto.createPrivateKey(pair.private);
    const pubKeyObj = crypto.createPublicKey(pair.public);

    const sig = crypto.sign(algo, data, privKeyObj);
    assert.strictEqual(sig.length, pair.sigLen);

    assert.strictEqual(crypto.verify(algo, data, privKeyObj, sig), true);
    assert.strictEqual(crypto.verify(algo, data, pubKeyObj, sig), true);
  }

  {
    const data = Buffer.from('Hello world');
    const otherData = Buffer.from('Goodbye world');
    const otherSig = crypto.sign(algo, otherData, pair.private);
    assert.strictEqual(crypto.verify(algo, data, pair.private, otherSig),
                       false);
  }

  [
    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,
  ].forEach((clazz) => {
    const data = new clazz();
    const sig = crypto.sign(algo, data, pair.private);
    assert.strictEqual(crypto.verify(algo, data, pair.private, sig),
                       true);
  });
});

[1, {}, [], true, Infinity].forEach((input) => {
  const data = Buffer.alloc(1);
  const sig = Buffer.alloc(1);
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  };

  assert.throws(() => crypto.sign(null, input, 'asdf'), errObj);
  assert.throws(() => crypto.verify(null, input, 'asdf', sig), errObj);

  assert.throws(() => crypto.sign(null, data, input), errObj);
  assert.throws(() => crypto.verify(null, data, input, sig), errObj);

  errObj.message = 'The ""signature"" argument must be an instance of ' +
                   'Buffer, TypedArray, or DataView.' +
                   common.invalidArgTypeHelper(input);
  assert.throws(() => crypto.verify(null, data, 'test', input), errObj);
});

{
  const data = Buffer.from('Hello world');
  const keys = [['ec-key.pem', 64], ['dsa_private_1025.pem', 40]];

  for (const [file, length] of keys) {
    const privKey = fixtures.readKey(file);
    [
      crypto.createSign('sha1').update(data).sign(privKey),
      crypto.sign('sha1', data, privKey),
      crypto.sign('sha1', data, { key: privKey, dsaEncoding: 'der' }),
    ].forEach((sig) => {
      // Signature length variability due to DER encoding
      assert(sig.length >= length + 4 && sig.length <= length + 8);

      assert.strictEqual(
        crypto.createVerify('sha1').update(data).verify(privKey, sig),
        true
      );
      assert.strictEqual(crypto.verify('sha1', data, privKey, sig), true);
    });

    // Test (EC)DSA signature conversion.
    const opts = { key: privKey, dsaEncoding: 'ieee-p1363' };
    let sig = crypto.sign('sha1', data, opts);
    // Unlike DER signatures, IEEE P1363 signatures have a predictable length.
    assert.strictEqual(sig.length, length);
    assert.strictEqual(crypto.verify('sha1', data, opts, sig), true);
    assert.strictEqual(crypto.createVerify('sha1')
                             .update(data)
                             .verify(opts, sig), true);

    // Test invalid signature lengths.
    for (const i of [-2, -1, 1, 2, 4, 8]) {
      sig = crypto.randomBytes(length + i);
      let result;
      try {
        result = crypto.verify('sha1', data, opts, sig);
      } catch (err) {
        assert.match(err.message, /asn1 encoding/);
        assert.strictEqual(err.library, 'asn1 encoding routines');
        continue;
      }
      assert.strictEqual(result, false);
    }
  }

  // Test verifying externally signed messages.
  const extSig = Buffer.from('494c18ab5c8a62a72aea5041966902bcfa229821af2bf65' +
                             '0b5b4870d1fe6aebeaed9460c62210693b5b0a300033823' +
                             '33d9529c8abd8c5948940af944828be16c', 'hex');
  for (const ok of [true, false]) {
    assert.strictEqual(
      crypto.verify('sha256', data, {
        key: fixtures.readKey('ec-key.pem'),
        dsaEncoding: 'ieee-p1363'
      }, extSig),
      ok
    );

    assert.strictEqual(
      crypto.createVerify('sha256').update(data).verify({
        key: fixtures.readKey('ec-key.pem'),
        dsaEncoding: 'ieee-p1363'
      }, extSig),
      ok
    );

    extSig[Math.floor(Math.random() * extSig.length)] ^= 1;
  }

  // Non-(EC)DSA keys should ignore the option.
  const sig = crypto.sign('sha1', data, {
    key: keyPem,
    dsaEncoding: 'ieee-p1363'
  });
  assert.strictEqual(crypto.verify('sha1', data, certPem, sig), true);
  assert.strictEqual(
    crypto.verify('sha1', data, {
      key: certPem,
      dsaEncoding: 'ieee-p1363'
    }, sig),
    true
  );
  assert.strictEqual(
    crypto.verify('sha1', data, {
      key: certPem,
      dsaEncoding: 'der'
    }, sig),
    true
  );

  for (const dsaEncoding of ['foo', null, {}, 5, true, NaN]) {
    assert.throws(() => {
      crypto.sign('sha1', data, {
        key: certPem,
        dsaEncoding
      });
    }, {
      code: 'ERR_INVALID_ARG_VALUE'
    });
  }
}


// RSA-PSS Sign test by verifying with 'openssl dgst -verify'
// Note: this particular test *must* be the last in this file as it will exit
// early if no openssl binary is found
{
  if (!common.opensslCli)
    common.skip('node compiled without OpenSSL CLI.');

  const pubfile = fixtures.path('keys', 'rsa_public_2048.pem');
  const privkey = fixtures.readKey('rsa_private_2048.pem');

  const msg = 'Test123';
  const s5 = crypto.createSign('SHA256')
    .update(msg)
    .sign({
      key: privkey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING
    });

  const tmpdir = require('../common/tmpdir');
  tmpdir.refresh();

  const sigfile = path.join(tmpdir.path, 's5.sig');
  fs.writeFileSync(sigfile, s5);
  const msgfile = path.join(tmpdir.path, 's5.msg');
  fs.writeFileSync(msgfile, msg);

  const cmd =
    `""${common.opensslCli}"" dgst -sha256 -verify ""${pubfile}"" -signature ""${
      sigfile}"" -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-2 ""${
      msgfile}""`;

  exec(cmd, common.mustCall((err, stdout, stderr) => {
    assert(stdout.includes('Verified OK'));
  }));
}

{
  // Test RSA-PSS.
  {
    // This key pair does not restrict the message digest algorithm or salt
    // length.
    const publicPem = fixtures.readKey('rsa_pss_public_2048.pem');
    const privatePem = fixtures.readKey('rsa_pss_private_2048.pem');

    const publicKey = crypto.createPublicKey(publicPem);
    const privateKey = crypto.createPrivateKey(privatePem);

    for (const key of [privatePem, privateKey]) {
      // Any algorithm should work.
      for (const algo of ['sha1', 'sha256']) {
        // Any salt length should work.
        for (const saltLength of [undefined, 8, 10, 12, 16, 18, 20]) {
          const signature = crypto.sign(algo, 'foo', { key, saltLength });

          for (const pkey of [key, publicKey, publicPem]) {
            const okay = crypto.verify(
              algo,
              'foo',
              { key: pkey, saltLength },
              signature
            );

            assert.ok(okay);
          }
        }
      }
    }
  }

  {
    // This key pair enforces sha256 as the message digest and the MGF1
    // message digest and a salt length of at least 16 bytes.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha256_sha256_16.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha256_sha256_16.pem');

    const publicKey = crypto.createPublicKey(publicPem);
    const privateKey = crypto.createPrivateKey(privatePem);

    for (const key of [privatePem, privateKey]) {
      // Signing with anything other than sha256 should fail.
      assert.throws(() => {
        crypto.sign('sha1', 'foo', key);
      }, /digest not allowed/);

      // Signing with salt lengths less than 16 bytes should fail.
      for (const saltLength of [8, 10, 12]) {
        assert.throws(() => {
          crypto.sign('sha256', 'foo', { key, saltLength });
        }, /pss saltlen too small/);
      }

      // Signing with sha256 and appropriate salt lengths should work.
      for (const saltLength of [undefined, 16, 18, 20]) {
        const signature = crypto.sign('sha256', 'foo', { key, saltLength });

        for (const pkey of [key, publicKey, publicPem]) {
          const okay = crypto.verify(
            'sha256',
            'foo',
            { key: pkey, saltLength },
            signature
          );

          assert.ok(okay);
        }
      }
    }
  }

  {
    // This key enforces sha512 as the message digest and sha256 as the MGF1
    // message digest.
    const publicPem =
      fixtures.readKey('rsa_pss_public_2048_sha512_sha256_20.pem');
    const privatePem =
      fixtures.readKey('rsa_pss_private_2048_sha512_sha256_20.pem');

    const publicKey = crypto.createPublicKey(publicPem);
    const privateKey = crypto.createPrivateKey(privatePem);

    // Node.js usually uses the same hash function for the message and for MGF1.
    // However, when a different MGF1 message digest algorithm has been
    // specified as part of the key, it should automatically switch to that.
    // This behavior is required by sections 3.1 and 3.3 of RFC4055.
    for (const key of [privatePem, privateKey]) {
      // sha256 matches the MGF1 hash function and should be used internally,
      // but it should not be permitted as the main message digest algorithm.
      for (const algo of ['sha1', 'sha256']) {
        assert.throws(() => {
          crypto.sign(algo, 'foo', key);
        }, /digest not allowed/);
      }

      // sha512 should produce a valid signature.
      const signature = crypto.sign('sha512', 'foo', key);

      for (const pkey of [key, publicKey, publicPem]) {
        const okay = crypto.verify('sha512', 'foo', pkey, signature);

        assert.ok(okay);
      }
    }
  }
}

// The sign function should not swallow OpenSSL errors.
// Regression test for https://github.com/nodejs/node/issues/40794.
{
  assert.throws(() => {
    const { privateKey } = crypto.generateKeyPairSync('rsa', {
      modulusLength: 512
    });
    crypto.sign('sha512', 'message', privateKey);
  }, {
    code: 'ERR_OSSL_RSA_DIGEST_TOO_BIG_FOR_RSA_KEY',
    message: /digest too big for rsa key/
  });
}

{
  // This should not cause a crash: https://github.com/nodejs/node/issues/44471
  for (const key of ['', 'foo', null, undefined, true, Boolean]) {
    assert.throws(() => {
      crypto.verify('sha256', 'foo', { key, format: 'jwk' }, Buffer.alloc(0));
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      crypto.createVerify('sha256').verify({ key, format: 'jwk' }, Buffer.alloc(0));
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      crypto.sign('sha256', 'foo', { key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
    assert.throws(() => {
      crypto.createSign('sha256').sign({ key, format: 'jwk' });
    }, { code: 'ERR_INVALID_ARG_TYPE', message: /The ""key\.key"" property must be of type object/ });
  }
}
"
modules/internal/crypto/keys.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

class SecretKeyHandle {
  #keyBuffer

  constructor(key) {
    this.#keyBuffer = Buffer.from(key);
  }

  // base
  equals(key) {
    return this.export().equals(key.export());
  }

  // secretKey
  getSymmetricKeySize() {
    return this.#keyBuffer.byteLength;
  }

  export() {
    return Buffer.from(this.#keyBuffer)
  }

  exportJwk(_obj, _bool) {
    return {
      kty: 'oct',
      k: this.#keyBuffer.toString(""base64"").replace(/=+$/, '')
    };
  }
}

const kKeyTypeSecret = Symbol(""kKeyTypeSecret"");
const kKeyTypePublic = Symbol(""kKeyTypePublic"");
const kKeyTypePrivate = Symbol(""kKeyTypePrivate"");
const kKeyFormatPEM = Symbol(""kKeyFormatPEM"");
const kKeyFormatDER = Symbol(""kKeyFormatDER"");
const kKeyFormatJWK = Symbol(""kKeyFormatJWK"");
const kKeyEncodingPKCS1 = Symbol(""kKeyEncodingPKCS1"");
const kKeyEncodingPKCS8 = Symbol(""kKeyEncodingPKCS8"");
const kKeyEncodingSPKI = Symbol(""kKeyEncodingSPKI"");
const kKeyEncodingSEC1 = Symbol(""kKeyEncodingSEC1"");

import {
  validateObject,
  validateOneOf,
  validateString,
} from '../validators';

import {
  ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,
  ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,
  ERR_CRYPTO_INVALID_JWK,
  ERR_ILLEGAL_CONSTRUCTOR,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
} from '../errors';

import {
  kHandle,
  kKeyObject,
  getArrayBufferOrView,
  bigIntArrayToUnsignedBigInt,
} from '../crypto/util';

import {
  isAnyArrayBuffer,
  isArrayBufferView,
} from '../util/types';

/*const {
  JSTransferable,
  kClone,
  kDeserialize,
} = require('internal/worker/js_transferable');*/

const kClone = Symbol('kClone');
const kDeserialize = Symbol('kDeserialize');

import {
  customInspectSymbol as kInspect,
} from '../util';

import { inspect } from '../util/inspect';

import { Buffer } from '../../buffer';

const kAlgorithm = Symbol('kAlgorithm');
const kExtractable = Symbol('kExtractable');
const kKeyType = Symbol('kKeyType');
const kKeyUsages = Symbol('kKeyUsages');

// Key input contexts.
const kConsumePublic = 0;
const kConsumePrivate = 1;
const kCreatePublic = 2;
const kCreatePrivate = 3;

const encodingNames = [];
for (const m of [[kKeyEncodingPKCS1, 'pkcs1'], [kKeyEncodingPKCS8, 'pkcs8'],
[kKeyEncodingSPKI, 'spki'], [kKeyEncodingSEC1, 'sec1']])
  encodingNames[m[0]] = m[1];

// Creating the KeyObject class is a little complicated due to inheritance
// and the fact that KeyObjects should be transferrable between threads,
// which requires the KeyObject base class to be implemented in C++.
// The creation requires a callback to make sure that the NativeKeyObject
// base class cannot exist without the other KeyObject implementations.
/*const {
  0: KeyObject,
  1: SecretKeyObject,
  2: PublicKeyObject,
  3: PrivateKeyObject,
} = createNativeKeyObjectClass((NativeKeyObject) => {*/
// Publicly visible KeyObject class.
class KeyObject/* extends NativeKeyObject*/ {
  constructor(type, handle) {
    if (type !== 'secret' && type !== 'public' && type !== 'private')
      throw new ERR_INVALID_ARG_VALUE('type', type);
    if (typeof handle !== 'object'/* || !(handle instanceof KeyObjectHandle)*/)
      throw new ERR_INVALID_ARG_TYPE('handle', 'object', handle);

    // super(handle);

    this[kKeyType] = type;

    Object.defineProperty(this, kHandle, {
      __proto__: null,
      value: handle,
      enumerable: false,
      configurable: false,
      writable: false
    });
  }

  get type() {
    return this[kKeyType];
  }

  static from(key) {
    if (!isCryptoKey(key))
      throw new ERR_INVALID_ARG_TYPE('key', 'CryptoKey', key);
    return key[kKeyObject];
  }

  equals(otherKeyObject) {
    if (!isKeyObject(otherKeyObject)) {
      throw new ERR_INVALID_ARG_TYPE(
        'otherKeyObject', 'KeyObject', otherKeyObject);
    }

    return otherKeyObject.type === this.type &&
      this[kHandle].equals(otherKeyObject[kHandle]);
  }
}

class SecretKeyObject extends KeyObject {
  constructor(handle) {
    super('secret', handle);
  }

  get symmetricKeySize() {
    return this[kHandle].getSymmetricKeySize();
  }

  export(options) {
    if (options !== undefined) {
      validateObject(options, 'options');
      validateOneOf(
        options.format, 'options.format', [undefined, 'buffer', 'jwk']);
      if (options.format === 'jwk') {
        return this[kHandle].exportJwk({}, false);
      }
    }
    return this[kHandle].export();
  }
}

const kAsymmetricKeyType = Symbol('kAsymmetricKeyType');
const kAsymmetricKeyDetails = Symbol('kAsymmetricKeyDetails');

function normalizeKeyDetails(details = {}) {
  if (details.publicExponent !== undefined) {
    return {
      ...details,
      publicExponent:
        bigIntArrayToUnsignedBigInt(new Uint8Array(details.publicExponent))
    };
  }
  return details;
}

class AsymmetricKeyObject extends KeyObject {
  // eslint-disable-next-line no-useless-constructor
  constructor(type, handle) {
    super(type, handle);
  }

  get asymmetricKeyType() {
    return this[kAsymmetricKeyType] ||
      (this[kAsymmetricKeyType] = this[kHandle].getAsymmetricKeyType());
  }

  get asymmetricKeyDetails() {
    switch (this.asymmetricKeyType) {
      case 'rsa':
      case 'rsa-pss':
      case 'dsa':
      case 'ec':
        return this[kAsymmetricKeyDetails] ||
          (this[kAsymmetricKeyDetails] = normalizeKeyDetails(
            this[kHandle].keyDetail({})
          ));
      default:
        return {};
    }
  }
}

class PublicKeyObject extends AsymmetricKeyObject {
  constructor(handle) {
    super('public', handle);
  }

  export(options) {
    if (options && options.format === 'jwk') {
      return this[kHandle].exportJwk({}, false);
    }
    const {
      format,
      type
    } = parsePublicKeyEncoding(options, this.asymmetricKeyType);
    return this[kHandle].export(format, type);
  }
}

class PrivateKeyObject extends AsymmetricKeyObject {
  constructor(handle) {
    super('private', handle);
  }

  export(options) {
    if (options && options.format === 'jwk') {
      if (options.passphrase !== undefined) {
        throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
          'jwk', 'does not support encryption');
      }
      return this[kHandle].exportJwk({}, false);
    }
    const {
      format,
      type,
      cipher,
      passphrase
    } = parsePrivateKeyEncoding(options, this.asymmetricKeyType);
    return this[kHandle].export(format, type, cipher, passphrase);
  }
}
/*
  return [KeyObject, SecretKeyObject, PublicKeyObject, PrivateKeyObject];
});*/

function parseKeyFormat(formatStr, defaultFormat, optionName) {
  if (formatStr === undefined && defaultFormat !== undefined)
    return defaultFormat;
  else if (formatStr === 'pem')
    return kKeyFormatPEM;
  else if (formatStr === 'der')
    return kKeyFormatDER;
  else if (formatStr === 'jwk')
    return kKeyFormatJWK;
  throw new ERR_INVALID_ARG_VALUE(optionName, formatStr);
}

function parseKeyType(typeStr, required, keyType, isPublic, optionName) {
  if (typeStr === undefined && !required) {
    return undefined;
  } else if (typeStr === 'pkcs1') {
    if (keyType !== undefined && keyType !== 'rsa') {
      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
        typeStr, 'can only be used for RSA keys');
    }
    return kKeyEncodingPKCS1;
  } else if (typeStr === 'spki' && isPublic !== false) {
    return kKeyEncodingSPKI;
  } else if (typeStr === 'pkcs8' && isPublic !== true) {
    return kKeyEncodingPKCS8;
  } else if (typeStr === 'sec1' && isPublic !== true) {
    if (keyType !== undefined && keyType !== 'ec') {
      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
        typeStr, 'can only be used for EC keys');
    }
    return kKeyEncodingSEC1;
  }

  throw new ERR_INVALID_ARG_VALUE(optionName, typeStr);
}

function option(name, objName) {
  return objName === undefined ?
    `options.${name}` : `options.${objName}.${name}`;
}

function parseKeyFormatAndType(enc, keyType, isPublic, objName) {
  const { format: formatStr, type: typeStr } = enc;

  const isInput = keyType === undefined;
  const format = parseKeyFormat(formatStr,
    isInput ? kKeyFormatPEM : undefined,
    option('format', objName));

  const isRequired = (!isInput ||
    format === kKeyFormatDER) &&
    format !== kKeyFormatJWK;
  const type = parseKeyType(typeStr,
    isRequired,
    keyType,
    isPublic,
    option('type', objName));
  return { format, type };
}

function isStringOrBuffer(val) {
  return typeof val === 'string' ||
    isArrayBufferView(val) ||
    isAnyArrayBuffer(val);
}

function parseKeyEncoding(enc, keyType, isPublic, objName) {
  validateObject(enc, 'options');

  const isInput = keyType === undefined;

  const {
    format,
    type
  } = parseKeyFormatAndType(enc, keyType, isPublic, objName);

  let cipher, passphrase, encoding;
  if (isPublic !== true) {
    ({ cipher, passphrase, encoding } = enc);

    if (!isInput) {
      if (cipher != null) {
        if (typeof cipher !== 'string')
          throw new ERR_INVALID_ARG_VALUE(option('cipher', objName), cipher);
        if (format === kKeyFormatDER &&
          (type === kKeyEncodingPKCS1 ||
            type === kKeyEncodingSEC1)) {
          throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(
            encodingNames[type], 'does not support encryption');
        }
      } else if (passphrase !== undefined) {
        throw new ERR_INVALID_ARG_VALUE(option('cipher', objName), cipher);
      }
    }

    if ((isInput && passphrase !== undefined &&
      !isStringOrBuffer(passphrase)) ||
      (!isInput && cipher != null && !isStringOrBuffer(passphrase))) {
      throw new ERR_INVALID_ARG_VALUE(option('passphrase', objName),
        passphrase);
    }
  }

  if (passphrase !== undefined)
    passphrase = getArrayBufferOrView(passphrase, 'key.passphrase', encoding);

  return { format, type, cipher, passphrase };
}

// Parses the public key encoding based on an object. keyType must be undefined
// when this is used to parse an input encoding and must be a valid key type if
// used to parse an output encoding.
function parsePublicKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, keyType ? true : undefined, objName);
}

// Parses the private key encoding based on an object. keyType must be undefined
// when this is used to parse an input encoding and must be a valid key type if
// used to parse an output encoding.
function parsePrivateKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, false, objName);
}

function getKeyObjectHandle(key, ctx) {
  if (ctx === kCreatePrivate) {
    throw new ERR_INVALID_ARG_TYPE(
      'key',
      ['string', 'ArrayBuffer', 'Buffer', 'TypedArray', 'DataView'],
      key
    );
  }

  if (key.type !== 'private') {
    if (ctx === kConsumePrivate || ctx === kCreatePublic)
      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, 'private');
    if (key.type !== 'public') {
      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type,
        'private or public');
    }
  }

  return key[kHandle];
}

function getKeyTypes(allowKeyObject, bufferOnly = false) {
  const types = [
    'ArrayBuffer',
    'Buffer',
    'TypedArray',
    'DataView',
    'string', // Only if bufferOnly == false
    'KeyObject', // Only if allowKeyObject == true && bufferOnly == false
    'CryptoKey', // Only if allowKeyObject == true && bufferOnly == false
  ];
  if (bufferOnly) {
    return Array.prototype.slice.call(types, 0, 4);
  } else if (!allowKeyObject) {
    return Array.prototype.slice.call(types, 0, 5);
  }
  return types;
}

function getKeyObjectHandleFromJwk(key, ctx) {
  validateObject(key, 'key');
  validateOneOf(
    key.kty, 'key.kty', ['RSA', 'EC', 'OKP']);
  const isPublic = ctx === kConsumePublic || ctx === kCreatePublic;

  if (key.kty === 'OKP') {
    validateString(key.crv, 'key.crv');
    validateOneOf(
      key.crv, 'key.crv', ['Ed25519', 'Ed448', 'X25519', 'X448']);
    validateString(key.x, 'key.x');

    if (!isPublic)
      validateString(key.d, 'key.d');

    let keyData;
    if (isPublic)
      keyData = Buffer.from(key.x, 'base64');
    else
      keyData = Buffer.from(key.d, 'base64');

    switch (key.crv) {
      case 'Ed25519':
      case 'X25519':
        if (keyData.byteLength !== 32) {
          throw new ERR_CRYPTO_INVALID_JWK();
        }
        break;
      case 'Ed448':
        if (keyData.byteLength !== 57) {
          throw new ERR_CRYPTO_INVALID_JWK();
        }
        break;
      case 'X448':
        if (keyData.byteLength !== 56) {
          throw new ERR_CRYPTO_INVALID_JWK();
        }
        break;
    }

    const handle = new KeyObjectHandle();

    const keyType = isPublic ? kKeyTypePublic : kKeyTypePrivate;
    if (!handle.initEDRaw(key.crv, keyData, keyType)) {
      throw new ERR_CRYPTO_INVALID_JWK();
    }

    return handle;
  }

  if (key.kty === 'EC') {
    validateString(key.crv, 'key.crv');
    validateOneOf(
      key.crv, 'key.crv', ['P-256', 'secp256k1', 'P-384', 'P-521']);
    validateString(key.x, 'key.x');
    validateString(key.y, 'key.y');

    const jwk = {
      kty: key.kty,
      crv: key.crv,
      x: key.x,
      y: key.y
    };

    if (!isPublic) {
      validateString(key.d, 'key.d');
      jwk.d = key.d;
    }

    const handle = new KeyObjectHandle();
    const type = handle.initJwk(jwk, jwk.crv);
    if (type === undefined)
      throw new ERR_CRYPTO_INVALID_JWK();

    return handle;
  }

  // RSA
  validateString(key.n, 'key.n');
  validateString(key.e, 'key.e');

  const jwk = {
    kty: key.kty,
    n: key.n,
    e: key.e
  };

  if (!isPublic) {
    validateString(key.d, 'key.d');
    validateString(key.p, 'key.p');
    validateString(key.q, 'key.q');
    validateString(key.dp, 'key.dp');
    validateString(key.dq, 'key.dq');
    validateString(key.qi, 'key.qi');
    jwk.d = key.d;
    jwk.p = key.p;
    jwk.q = key.q;
    jwk.dp = key.dp;
    jwk.dq = key.dq;
    jwk.qi = key.qi;
  }

  const handle = new KeyObjectHandle();
  const type = handle.initJwk(jwk);
  if (type === undefined)
    throw new ERR_CRYPTO_INVALID_JWK();

  return handle;
}

function prepareAsymmetricKey(key, ctx) {
  if (isKeyObject(key)) {
    // Best case: A key object, as simple as that.
    return { data: getKeyObjectHandle(key, ctx) };
  } else if (isCryptoKey(key)) {
    return { data: getKeyObjectHandle(key[kKeyObject], ctx) };
  } else if (isStringOrBuffer(key)) {
    // Expect PEM by default, mostly for backward compatibility.
    return { format: kKeyFormatPEM, data: getArrayBufferOrView(key, 'key') };
  } else if (typeof key === 'object') {
    const { key: data, encoding, format } = key;

    // The 'key' property can be a KeyObject as well to allow specifying
    // additional options such as padding along with the key.
    if (isKeyObject(data))
      return { data: getKeyObjectHandle(data, ctx) };
    else if (isCryptoKey(data))
      return { data: getKeyObjectHandle(data[kKeyObject], ctx) };
    else if (format === 'jwk') {
      validateObject(data, 'key.key');
      return { data: getKeyObjectHandleFromJwk(data, ctx), format: 'jwk' };
    }

    // Either PEM or DER using PKCS#1 or SPKI.
    if (!isStringOrBuffer(data)) {
      throw new ERR_INVALID_ARG_TYPE(
        'key.key',
        getKeyTypes(ctx !== kCreatePrivate),
        data);
    }

    const isPublic =
      (ctx === kConsumePrivate || ctx === kCreatePrivate) ? false : undefined;
    return {
      data: getArrayBufferOrView(data, 'key', encoding),
      ...parseKeyEncoding(key, undefined, isPublic)
    };
  }
  throw new ERR_INVALID_ARG_TYPE(
    'key',
    getKeyTypes(ctx !== kCreatePrivate),
    key);
}

function preparePrivateKey(key) {
  return prepareAsymmetricKey(key, kConsumePrivate);
}

function preparePublicOrPrivateKey(key) {
  return prepareAsymmetricKey(key, kConsumePublic);
}

function prepareSecretKey(key, encoding, bufferOnly = false) {
  if (!bufferOnly) {
    if (isKeyObject(key)) {
      if (key.type !== 'secret')
        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, 'secret');
      return key[kHandle];
    } else if (isCryptoKey(key)) {
      if (key.type !== 'secret')
        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, 'secret');
      return key[kKeyObject][kHandle];
    }
  }
  if (typeof key !== 'string' &&
    !isArrayBufferView(key) &&
    !isAnyArrayBuffer(key)) {
    throw new ERR_INVALID_ARG_TYPE(
      'key',
      getKeyTypes(!bufferOnly, bufferOnly),
      key);
  }
  return getArrayBufferOrView(key, 'key', encoding);
}

function createSecretKey(key, encoding) {
  key = prepareSecretKey(key, encoding, true);
  const handle = new SecretKeyHandle(key);
  // handle.init(kKeyTypeSecret, key);
  return new SecretKeyObject(handle);
}

function createPublicKey(key) {
  const { format, type, data, passphrase } =
    prepareAsymmetricKey(key, kCreatePublic);
  let handle;
  if (format === 'jwk') {
    handle = data;
  } else {
    handle = new KeyObjectHandle();
    handle.init(kKeyTypePublic, data, format, type, passphrase);
  }
  return new PublicKeyObject(handle);
}

function createPrivateKey(key) {
  const { format, type, data, passphrase } =
    prepareAsymmetricKey(key, kCreatePrivate);
  let handle;
  if (format === 'jwk') {
    handle = data;
  } else {
    handle = new KeyObjectHandle();
    handle.init(kKeyTypePrivate, data, format, type, passphrase);
  }
  return new PrivateKeyObject(handle);
}

function isKeyObject(obj) {
  return obj != null && obj[kKeyType] !== undefined;
}

// Our implementation of CryptoKey is a simple wrapper around a KeyObject
// that adapts it to the standard interface. This implementation also
// extends the JSTransferable class, allowing the CryptoKey to be cloned
// to Workers.
// TODO(@jasnell): Embedder environments like electron may have issues
// here similar to other things like URL. A chromium provided CryptoKey
// will not be recognized as a Node.js CryptoKey, and vice versa. It
// would be fantastic if we could find a way of making those interop.
class CryptoKey /*extends JSTransferable*/ {
  constructor() {
    throw new ERR_ILLEGAL_CONSTRUCTOR();
  }

  [kInspect](depth, options) {
    if (depth < 0)
      return this;

    const opts = {
      ...options,
      depth: options.depth == null ? null : options.depth - 1
    };

    return `CryptoKey ${inspect({
      type: this.type,
      extractable: this.extractable,
      algorithm: this.algorithm,
      usages: this.usages
    }, opts)}`;
  }

  get type() {
    return this[kKeyObject].type;
  }

  get extractable() {
    return this[kExtractable];
  }

  get algorithm() {
    return this[kAlgorithm];
  }

  get usages() {
    return Array.from(this[kKeyUsages]);
  }

  [kClone]() {
    const keyObject = this[kKeyObject];
    const algorithm = this.algorithm;
    const extractable = this.extractable;
    const usages = this.usages;

    return {
      data: {
        keyObject,
        algorithm,
        usages,
        extractable,
      },
      deserializeInfo: 'internal/crypto/keys:InternalCryptoKey'
    };
  }

  [kDeserialize]({ keyObject, algorithm, usages, extractable }) {
    this[kKeyObject] = keyObject;
    this[kAlgorithm] = algorithm;
    this[kKeyUsages] = usages;
    this[kExtractable] = extractable;
  }
}

// All internal code must use new InternalCryptoKey to create
// CryptoKey instances. The CryptoKey class is exposed to end
// user code but is not permitted to be constructed directly.
class InternalCryptoKey /*extends JSTransferable*/ {
  constructor(
    keyObject,
    algorithm,
    keyUsages,
    extractable) {
    // super();
    // Using symbol properties here currently instead of private
    // properties because (for now) the performance penalty of
    // private fields is still too high.
    this[kKeyObject] = keyObject;
    this[kAlgorithm] = algorithm;
    this[kExtractable] = extractable;
    this[kKeyUsages] = keyUsages;
  }
}

InternalCryptoKey.prototype.constructor = CryptoKey;
Object.setPrototypeOf(InternalCryptoKey.prototype, CryptoKey.prototype);

function isCryptoKey(obj) {
  return obj != null && obj[kKeyObject] !== undefined;
}

export {
  // Public API.
  createSecretKey,
  createPublicKey,
  createPrivateKey,
  KeyObject,
  CryptoKey,
  InternalCryptoKey,

  // These are designed for internal use only and should not be exposed.
  parsePublicKeyEncoding,
  parsePrivateKeyEncoding,
  parseKeyEncoding,
  preparePrivateKey,
  preparePublicOrPrivateKey,
  prepareSecretKey,
  SecretKeyObject,
  PublicKeyObject,
  PrivateKeyObject,
  isKeyObject,
  isCryptoKey,
};
"
src/internal_module/httpx/js_module.rs,"use super::core::chunk::HttpChunk;
use super::core::request::HttpRequest;
use super::core::ParseError;
use crate::event_loop::AsyncTcpConn;
use crate::internal_module::httpx::core::response::{BodyLen, HttpResponse};
use crate::internal_module::httpx::core::Version::V1_1;
use crate::{
    register_class, AsObject, Context, JsClassDef, JsClassProto, JsClassTool, JsFn, JsModuleDef,
    JsObject, JsValue, ModuleInit,
};
use std::collections::HashMap;
use std::fmt::format;
use std::io::BufReader;
use std::ops::{Deref, DerefMut};
use std::str::FromStr;

struct Buffer(Vec<u8>, usize);

impl Deref for Buffer {
    type Target = Vec<u8>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Buffer {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl AsRef<[u8]> for Buffer {
    fn as_ref(&self) -> &[u8] {
        if self.len() > self.1 {
            &self.0[self.1..]
        } else {
            &[]
        }
    }
}

impl Buffer {
    fn js_buffer(&self, ctx: &mut Context) -> JsValue {
        let buf = self.as_ref();
        if buf.len() > 0 {
            ctx.new_array_buffer(buf).into()
        } else {
            JsValue::Null
        }
    }

    fn js_length(&self, _ctx: &mut Context) -> JsValue {
        JsValue::Int(self.as_ref().len() as i32)
    }

    fn js_append(
        &mut self,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        match argv.get(0) {
            Some(JsValue::ArrayBuffer(data)) => {
                self.extend_from_slice(data.as_ref());
                JsValue::Bool(true)
            }
            Some(JsValue::Object(obj)) => {
                if let Some(v) = Buffer::opaque(&JsValue::Object(obj.clone())) {
                    self.extend_from_slice(v.as_ref());
                    JsValue::Bool(true)
                } else {
                    JsValue::Bool(false)
                }
            }
            _ => JsValue::Bool(false),
        }
    }

    fn js_parse_request(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match HttpRequest::parse(self.as_ref()) {
            Ok(req) => HttpRequest::wrap_obj(ctx, req),
            Err(ParseError::Pending) => JsValue::UnDefined,
            Err(e) => {
                let err = ctx.new_error(format!(""{:?}"", e).as_str());
                ctx.throw_error(err).into()
            }
        }
    }

    fn js_parse_response(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match HttpResponse::parse(self.as_ref()) {
            Ok((resp, n)) => {
                self.1 += n;
                HttpResponse::wrap_obj(ctx, resp)
            }
            Err(ParseError::Pending) => JsValue::UnDefined,
            Err(e) => ctx.new_error(format!(""{:?}"", e).as_str()),
        }
    }

    fn js_parse_chunk_data(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match HttpChunk::parse(self.as_ref()) {
            Ok((buf, n)) => {
                let r = if buf.len() == 0 {
                    JsValue::Null
                } else {
                    let array_buf = ctx.new_array_buffer(buf);
                    array_buf.into()
                };
                self.1 += n;
                r
            }
            Err(ParseError::Pending) => JsValue::UnDefined,
            Err(e) => ctx.new_error(format!(""{:?}"", e).as_str()),
        }
    }

    fn js_clear(
        &mut self,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        self.0.clear();
        self.1 = 0;
        JsValue::UnDefined
    }
}

impl JsClassDef for Buffer {
    type RefType = Buffer;

    const CLASS_NAME: &'static str = ""Buffer"";
    const CONSTRUCTOR_ARGC: u8 = 0;

    fn constructor_fn(_ctx: &mut Context, argv: &[JsValue]) -> Result<Buffer, JsValue> {
        if let Some(JsValue::ArrayBuffer(s)) = argv.get(0) {
            Ok(Buffer(s.as_ref().to_vec(), 0))
        } else {
            Ok(Buffer(vec![], 0))
        }
    }

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[
        (""length"", Self::js_length, None),
        (""byteLength"", Self::js_length, None),
        (""buffer"", Self::js_buffer, None),
    ];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] = &[
        (""append"", 1, Self::js_append),
        (""write"", 1, Self::js_append),
        (""parseRequest"", 0, Self::js_parse_request),
        (""parseResponse"", 0, Self::js_parse_response),
        (""parseChunk"", 0, Self::js_parse_chunk_data),
        (""clear"", 0, Self::js_clear),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }
}

impl HttpRequest {
    pub fn js_get_body(&self, ctx: &mut Context) -> JsValue {
        if self.body.len() > 0 {
            ctx.new_array_buffer(self.body.as_slice()).into()
        } else {
            JsValue::Null
        }
    }

    pub fn js_set_body(&mut self, _ctx: &mut Context, val: JsValue) {
        match val {
            JsValue::String(s) => {
                self.body = Vec::from(s.to_string());
            }
            JsValue::Object(obj) => {
                if let Some(v) = Buffer::opaque(&JsValue::Object(obj)) {
                    self.body = v.to_vec();
                }
            }
            JsValue::ArrayBuffer(buf) => {
                self.body = buf.to_vec();
            }
            _ => {}
        }
    }

    pub fn js_get_headers(&self, ctx: &mut Context) -> JsValue {
        let mut headers = ctx.new_object();
        for (k, v) in &self.headers {
            headers.set(k.as_str(), ctx.new_string(v.as_str()).into());
        }
        headers.into()
    }

    pub fn js_set_headers(&mut self, ctx: &mut Context, val: JsValue) {
        if let JsValue::Object(headers) = val {
            if let Ok(h) = headers.to_map() {
                self.headers.clear();
                for (k, v) in h {
                    if let JsValue::String(v_str) = ctx.value_to_string(&v) {
                        self.headers.insert(k.to_lowercase(), v_str.to_string());
                    }
                }
            }
        }
    }

    pub fn js_get_method(&self, ctx: &mut Context) -> JsValue {
        ctx.new_string(self.method.to_string().as_str()).into()
    }

    pub fn js_set_method(&mut self, _ctx: &mut Context, val: JsValue) {
        if let JsValue::String(method) = val {
            let method = method.to_string().to_uppercase();
            if let Ok(m) = super::core::Method::from_str(method.as_str()) {
                self.method = m;
            }
        }
    }

    pub fn js_get_version(&self, ctx: &mut Context) -> JsValue {
        ctx.new_string(&format!(""{}"", self.version)).into()
    }

    pub fn js_set_version(&mut self, _ctx: &mut Context, val: JsValue) {
        if let JsValue::String(version) = val {
            let version = version.to_string();
            if let Ok(m) = super::core::Version::from_str(version.as_str()) {
                self.version = m;
            }
        }
    }

    pub fn js_get_uri(&self, ctx: &mut Context) -> JsValue {
        ctx.new_string(format!(""{}"", self.resource).as_str()).into()
    }

    pub fn js_set_uri(&mut self, _ctx: &mut Context, val: JsValue) {
        if let JsValue::String(uri) = val {
            let uri = uri.to_string();
            let uri = super::core::request::Resource::Path(uri);
            self.resource = uri;
        }
    }

    pub fn js_get_header(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some(JsValue::String(s)) = argv.first() {
            let key = s.as_str();
            if let Some(v) = self.headers.get(key) {
                ctx.new_string(&v).into()
            } else {
                JsValue::Null
            }
        } else {
            JsValue::Null
        }
    }

    pub fn js_set_header(
        &mut self,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let (Some(JsValue::String(k)), Some(JsValue::String(v))) = (argv.get(0), argv.get(1)) {
            self.headers
                .insert(k.as_str().to_lowercase(), v.to_string());
        }

        JsValue::UnDefined
    }

    pub fn js_encode(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        let mut buf = Vec::from(format!(""{}"", self));
        buf.extend_from_slice(self.body.as_slice());
        ctx.new_array_buffer(buf.as_slice()).into()
    }
}

impl JsClassDef for HttpRequest {
    type RefType = HttpRequest;

    const CLASS_NAME: &'static str = ""WasiRequest"";
    const CONSTRUCTOR_ARGC: u8 = 0;

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<HttpRequest, JsValue> {
        use super::core::request;
        use super::core::*;
        Ok(HttpRequest {
            method: Method::Get,
            version: Version::V1_0,
            resource: request::Resource::Path(Default::default()),
            headers: Default::default(),
            body: vec![],
        })
    }

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[
        (""body"", Self::js_get_body, Some(Self::js_set_body)),
        (""headers"", Self::js_get_headers, Some(Self::js_set_headers)),
        (""method"", Self::js_get_method, Some(Self::js_set_method)),
        (""version"", Self::js_get_version, Some(Self::js_set_version)),
        (""uri"", Self::js_get_uri, Some(Self::js_set_uri)),
    ];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] = &[
        (""encode"", 0, Self::js_encode),
        (""getHeader"", 1, Self::js_get_header),
        (""setHeader"", 1, Self::js_set_header),
    ];
}

impl HttpResponse {
    fn js_get_body_length(&self, ctx: &mut Context) -> JsValue {
        match self.body_len {
            BodyLen::Length(n) => JsValue::Int(n as i32),
            BodyLen::Chunked => ctx.new_string(""chunked"").into(),
        }
    }

    fn js_set_body_length(&mut self, _ctx: &mut Context, val: JsValue) {
        match val {
            JsValue::UnDefined | JsValue::Null => {
                self.body_len = BodyLen::Length(0);
            }
            JsValue::Int(n) => {
                self.body_len = BodyLen::Length(n as usize);
            }
            _ => {}
        }
    }

    fn js_get_headers(&self, ctx: &mut Context) -> JsValue {
        let mut headers = ctx.new_object();
        for (k, v) in &self.headers {
            headers.set(k.as_str(), ctx.new_string(v.as_str()).into());
        }
        headers.into()
    }

    fn js_set_headers(&mut self, ctx: &mut Context, val: JsValue) {
        if let JsValue::Object(headers) = val {
            if let Ok(h) = headers.to_map() {
                self.headers.clear();
                for (k, v) in h {
                    if let JsValue::String(v_str) = ctx.value_to_string(&v) {
                        self.headers.insert(k, v_str.to_string());
                    }
                }
            }
        }
    }

    fn js_get_status(&self, _ctx: &mut Context) -> JsValue {
        JsValue::Int(self.status_code as i32)
    }

    fn js_set_status(&mut self, _ctx: &mut Context, val: JsValue) {
        if let JsValue::Int(status) = val {
            self.status_code = status as u16;
            self.status_text = match status {
                200 => ""OK"",
                400 => ""Bad Request"",
                404 => ""Not Found"",
                500 => ""Internal Server Error"",
                _ => """",
            }
            .to_string();
        }
    }

    fn js_get_version(&self, ctx: &mut Context) -> JsValue {
        ctx.new_string(&format!(""{}"", self.version)).into()
    }

    fn js_set_version(&mut self, _ctx: &mut Context, val: JsValue) {
        if let JsValue::String(version) = val {
            let version = version.to_string();
            if let Ok(m) = super::core::Version::from_str(version.as_str()) {
                self.version = m;
            }
        }
    }

    fn js_get_status_text(&self, ctx: &mut Context) -> JsValue {
        ctx.new_string(self.status_text.as_str()).into()
    }

    fn js_set_status_text(&mut self, _ctx: &mut Context, val: JsValue) {
        if let JsValue::String(status_text) = val {
            let status_text = status_text.to_string();
            self.status_text = status_text;
        }
    }

    fn js_encode(&mut self, _this: &mut JsObject, ctx: &mut Context, argv: &[JsValue]) -> JsValue {
        let body = argv.get(0);
        let body = match body {
            Some(JsValue::ArrayBuffer(buffer)) => {
                let body = buffer.as_ref().to_vec();
                self.body_len = BodyLen::Length(body.len());
                Some(body)
            }
            Some(JsValue::String(s)) => {
                let body = Vec::from(s.to_string());
                self.body_len = BodyLen::Length(body.len());
                Some(body)
            }
            _ => {
                if self.body_len != BodyLen::Chunked {
                    self.body_len = BodyLen::Length(0);
                }
                None
            }
        };
        let mut buf = Vec::from(format!(""{}"", self));

        if let Some(body) = body {
            if !body.is_empty() {
                buf.extend_from_slice(body.as_slice());
            }
        }
        ctx.new_array_buffer(buf.as_slice()).into()
    }

    fn js_chunk(&mut self, _this: &mut JsObject, ctx: &mut Context, argv: &[JsValue]) -> JsValue {
        if let Some(JsValue::Object(s)) = argv.get(0) {
            self.body_len = BodyLen::Chunked;
            self.version = V1_1;

            let header_buff = Vec::from(format!(""{}"", self));
            let resp_header = ctx.new_array_buffer(&header_buff);

            let mut s = s.clone();
            s.invoke(""write"", &[resp_header.into()]);
            WasiChunkResponse::wrap_obj(ctx, WasiChunkResponse(s.into()))
        } else {
            JsValue::UnDefined
        }
    }
}

impl JsClassDef for HttpResponse {
    type RefType = HttpResponse;

    const CLASS_NAME: &'static str = ""WasiResponse"";
    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[
        (
            ""bodyLength"",
            Self::js_get_body_length,
            Some(Self::js_set_body_length),
        ),
        (""headers"", Self::js_get_headers, Some(Self::js_set_headers)),
        (""status"", Self::js_get_status, Some(Self::js_set_status)),
        (""version"", Self::js_get_version, Some(Self::js_set_version)),
        (
            ""statusText"",
            Self::js_get_status_text,
            Some(Self::js_set_status_text),
        ),
    ];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] =
        &[(""encode"", 0, Self::js_encode), (""chunk"", 1, Self::js_chunk)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<HttpResponse, JsValue> {
        use super::core::request;
        use super::core::*;
        Ok(HttpResponse {
            version: Version::V1_0,
            status_code: 200,
            status_text: ""OK"".to_string(),
            headers: Default::default(),
            body_len: BodyLen::Length(0),
        })
    }
}

struct WasiChunkResponse(JsValue);

impl WasiChunkResponse {
    pub fn js_on(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some(v) = self.0.invoke(""on"", argv) {
            v
        } else {
            ctx.throw_internal_type_error(""socket is shutdown"").into()
        }
    }

    pub fn js_write(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let JsValue::UnDefined = self.0 {
            return ctx.throw_internal_type_error(""socket is shutdown"").into();
        }
        match argv.get(0) {
            Some(JsValue::String(s)) => {
                let data = s.to_string();
                let data_len = data.len();
                self.0.invoke(
                    ""write"",
                    &[ctx
                        .new_string(format!(""{:x}\r\n"", data_len).as_str())
                        .into()],
                );
                self.0.invoke(""write"", &[s.clone().into()]);
                self.0.invoke(""write"", &[ctx.new_string(""\r\n"").into()]);
            }
            Some(JsValue::ArrayBuffer(buff)) => {
                let data = buff.as_ref();
                let data_len = data.len();
                self.0.invoke(
                    ""write"",
                    &[ctx
                        .new_string(format!(""{:x}\r\n"", data_len).as_str())
                        .into()],
                );
                self.0.invoke(""write"", &[buff.clone().into()]);
                self.0.invoke(""write"", &[ctx.new_string(""\r\n"").into()]);
            }
            Some(JsValue::Object(o)) => {
                let data = o.to_string();
                let data_len = data.len();
                self.0.invoke(
                    ""write"",
                    &[ctx
                        .new_string(format!(""{:x}\r\n"", data_len).as_str())
                        .into()],
                );
                self.0.invoke(""write"", &[o.clone().into()]);
                self.0.invoke(""write"", &[ctx.new_string(""\r\n"").into()]);
            }
            Some(JsValue::Symbol(s)) => {
                let data = format!(""{:?}"", s);
                let data_len = data.len();
                self.0.invoke(
                    ""write"",
                    &[ctx
                        .new_string(format!(""{:x}\r\n"", data_len).as_str())
                        .into()],
                );
                self.0.invoke(""write"", &[JsValue::Symbol(s.clone())]);
                self.0.invoke(""write"", &[ctx.new_string(""\r\n"").into()]);
            }
            _ => {}
        };
        JsValue::Bool(true)
    }

    pub fn js_end(
        &mut self,
        this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let JsValue::UnDefined = self.0 {
            return ctx.throw_internal_type_error(""socket is shutdown"").into();
        }
        let e = this_obj.invoke(""write"", argv);
        if e.is_exception() {
            return e;
        }

        self.0.invoke(""end"", &[ctx.new_string(""0\r\n\r\n"").into()]);
        // drop socket
        self.0 = JsValue::UnDefined;
        JsValue::Bool(true)
    }
}

impl JsClassDef for WasiChunkResponse {
    type RefType = WasiChunkResponse;

    const CLASS_NAME: &'static str = ""ChunkResponse"";
    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] = &[
        (""on"", 2, Self::js_on),
        (""write"", 1, Self::js_write),
        (""end"", 1, Self::js_end),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<WasiChunkResponse, JsValue> {
        Err(JsValue::UnDefined)
    }

    fn gc_mark(data: &Self, make: &mut dyn Fn(&JsValue)) {
        make(&data.0)
    }
}

mod js_url {
    use std::ops::{Deref, DerefMut};

    use url::quirks::password;

    use crate::*;

    pub(super) struct URL(pub url::Url);

    impl Deref for URL {
        type Target = url::Url;

        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl DerefMut for URL {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }

    impl URL {
        pub fn js_to_string(
            &mut self,
            _this: &mut JsObject,
            ctx: &mut Context,
            _argv: &[JsValue],
        ) -> JsValue {
            ctx.new_string(format!(""{}"", self.0).as_str()).into()
        }

        pub fn js_get_href(&self, ctx: &mut Context) -> JsValue {
            ctx.new_string(format!(""{}"", self.0).as_str()).into()
        }

        pub fn js_get_scheme(&self, ctx: &mut Context) -> JsValue {
            ctx.new_string(self.scheme()).into()
        }

        pub fn js_get_username(&self, ctx: &mut Context) -> JsValue {
            ctx.new_string(self.username()).into()
        }

        pub fn js_get_password(&self, ctx: &mut Context) -> JsValue {
            let password = self.password().unwrap_or_default();
            ctx.new_string(password).into()
        }

        pub fn js_get_host(&self, ctx: &mut Context) -> JsValue {
            match self.host_str() {
                Some(host) => ctx.new_string(host).into(),
                None => JsValue::UnDefined,
            }
        }

        pub fn js_get_port(&self, _ctx: &mut Context) -> JsValue {
            match self.port_or_known_default() {
                Some(port) => JsValue::Int(port as i32),
                None => JsValue::UnDefined,
            }
        }

        pub fn js_get_path(&self, ctx: &mut Context) -> JsValue {
            ctx.new_string(self.path()).into()
        }

        pub fn js_get_query(&self, ctx: &mut Context) -> JsValue {
            match self.query() {
                Some(query) => ctx.new_string(query).into(),
                None => JsValue::UnDefined,
            }
        }
    }

    impl JsClassDef for URL {
        type RefType = Self;
        const CLASS_NAME: &'static str = ""URL"";
        const CONSTRUCTOR_ARGC: u8 = 1;

        const FIELDS: &'static [JsClassField<Self::RefType>] = &[
            (""href"", Self::js_get_href, None),
            (""scheme"", Self::js_get_scheme, None),
            (""username"", Self::js_get_username, None),
            (""password"", Self::js_get_password, None),
            (""host"", Self::js_get_host, None),
            (""port"", Self::js_get_port, None),
            (""path"", Self::js_get_path, None),
            (""query"", Self::js_get_query, None),
        ];
        const METHODS: &'static [JsClassMethod<Self::RefType>] =
            &[(""toString"", 0, Self::js_to_string)];

        unsafe fn mut_class_id_ptr() -> &'static mut u32 {
            static mut CLASS_ID: u32 = 0;
            &mut CLASS_ID
        }

        fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<URL, JsValue> {
            let input = argv.get(0);
            if let Some(JsValue::String(url_str)) = input {
                let u = url::Url::parse(url_str.as_str()).map_err(|e| {
                    JsValue::Exception(ctx.throw_internal_type_error(e.to_string().as_str()))
                })?;
                Ok(URL(u))
            } else {
                Err(JsValue::UnDefined)
            }
        }
    }
}
use js_url::URL;

struct HttpX;

impl ModuleInit for HttpX {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
        let class_ctor = register_class::<Buffer>(ctx);
        m.add_export(Buffer::CLASS_NAME, class_ctor);

        let class_ctor = register_class::<HttpRequest>(ctx);
        m.add_export(HttpRequest::CLASS_NAME, class_ctor);

        let class_ctor = register_class::<HttpResponse>(ctx);
        m.add_export(HttpResponse::CLASS_NAME, class_ctor);

        let class_ctor = register_class::<WasiChunkResponse>(ctx);
        m.add_export(WasiChunkResponse::CLASS_NAME, class_ctor);

        let class_ctor = register_class::<URL>(ctx);
        m.add_export(URL::CLASS_NAME, class_ctor);
    }
}

pub fn init_module(ctx: &mut Context) {
    ctx.register_module(
        ""wasi_http\0"",
        HttpX,
        &[
            Buffer::CLASS_NAME,
            HttpRequest::CLASS_NAME,
            HttpResponse::CLASS_NAME,
            WasiChunkResponse::CLASS_NAME,
            URL::CLASS_NAME,
        ],
    )
}
"
modules/internal/assert/assertion_error.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import { inspect } from 'internal/util/inspect';
import { removeColors } from 'internal/util';
import { blue, white, green, red, refresh } from 'internal/util/colors';
import { validateObject } from 'internal/validators';
import { isErrorStackTraceLimitWritable } from 'internal/errors';

const kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected ""actual"" to be reference-equal to ""expected"":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  notDeepStrictEqual: 'Expected ""actual"" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected ""actual"" to be strictly unequal to:',
  notStrictEqualObject:
    'Expected ""actual"" not to be reference-equal to ""expected"":',
  notDeepEqual: 'Expected ""actual"" not to be loosely deep-equal to:',
  notIdentical: 'Values have same structure but are not reference-equal:',
  notDeepEqualUnequal: 'Expected values not to be loosely deep-equal:'
};

// Comparing short primitives should just show === / !== instead of using the
// diff.
const kMaxShortLength = 12;

function copyError(source) {
  const keys = Object.keys(source);
  const target = Object.create(Object.getPrototypeOf(source));
  for (const key of keys) {
    target[key] = source[key];
  }
  Object.defineProperty(target, 'message', { __proto__: null, value: source.message });
  return target;
}

function inspectValue(val) {
  // return JSON.stringify(val) || ""undefined"";
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(
    val,
    {
      compact: false,
      customInspect: false,
      depth: 1000,
      maxArrayLength: Infinity,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: false,
      // Assert does not detect proxies currently.
      showProxy: false,
      sorted: true,
      // Inspect getters as we also check them when comparing entries.
      getters: true,
    }
  ) ?? JSON.stringify(val);
}

function createErrDiff(actual, expected, operator) {
  let other = '';
  let res = '';
  let end = '';
  let skipped = false;
  const actualInspected = inspectValue(actual);
  const actualLines = String.prototype.split.call(actualInspected, '\n');
  const expectedLines = String.prototype.split.call(inspectValue(expected), '\n');

  let i = 0;
  let indicator = '';

  // In case both values are objects or functions explicitly mark them as not
  // reference equal for the `strictEqual` operator.
  if (operator === 'strictEqual' &&
      ((typeof actual === 'object' && actual !== null &&
        typeof expected === 'object' && expected !== null) ||
       (typeof actual === 'function' && typeof expected === 'function'))) {
    operator = 'strictEqualObject';
  }

  // If ""actual"" and ""expected"" fit on a single line and they are not strictly
  // equal, check further special handling.
  if (actualLines.length === 1 && expectedLines.length === 1 &&
    actualLines[0] !== expectedLines[0]) {
    // Check for the visible length using the `removeColors()` function, if
    // appropriate.
    const c = inspect.defaultOptions.colors;
    const actualRaw = c ? removeColors(actualLines[0]) : actualLines[0];
    const expectedRaw = c ? removeColors(expectedLines[0]) : expectedLines[0];
    const inputLength = actualRaw.length + expectedRaw.length;
    // If the character length of ""actual"" and ""expected"" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.
    if (inputLength <= kMaxShortLength) {
      if ((typeof actual !== 'object' || actual === null) &&
          (typeof expected !== 'object' || expected === null) &&
          (actual !== 0 || expected !== 0)) { // -0 === +0
        return `${kReadableOperator[operator]}\n\n` +
            `${actualLines[0]} !== ${expectedLines[0]}\n`;
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      const maxLength = /*process.stderr.isTTY ? process.stderr.columns :*/ 80;
      if (inputLength < maxLength) {
        while (actualRaw[i] === expectedRaw[i]) {
          i++;
        }
        // Ignore the first characters.
        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = `\n  ${String.prototype.repeat.call(' ', i)}^`;
          i = 0;
        }
      }
    }
  }

  // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).
  let a = actualLines[actualLines.length - 1];
  let b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 3) {
      end = `\n  ${a}${end}`;
    } else {
      other = a;
    }
    Array.prototype.pop.call(actualLines);
    Array.prototype.pop.call(expectedLines);
    if (actualLines.length === 0 || expectedLines.length === 0)
      break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  const maxLines = Math.max(actualLines.length, expectedLines.length);
  // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    const actualLines = String.prototype.split.call(actualInspected, '\n');

    // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.
    if (actualLines.length > 50) {
      actualLines[46] = `${blue}...${white}`;
      while (actualLines.length > 47) {
        Array.prototype.pop.call(actualLines);
      }
    }

    return `${kReadableOperator.notIdentical}\n\n` +
           `${Array.prototype.join.call(actualLines, '\n')}\n`;
  }

  // There were at least five identical lines at the end. Mark a couple of
  // skipped.
  if (i >= 5) {
    end = `\n${blue}...${white}${end}`;
    skipped = true;
  }
  if (other !== '') {
    end = `\n  ${other}${end}`;
    other = '';
  }

  let printedLines = 0;
  let identical = 0;
  const msg = kReadableOperator[operator] +
        `\n${green}+ actual${white} ${red}- expected${white}`;
  const skippedMsg = ` ${blue}...${white} Lines skipped`;

  let lines = actualLines;
  let plusMinus = `${green}+${white}`;
  let maxLength = expectedLines.length;
  if (actualLines.length < maxLines) {
    lines = expectedLines;
    plusMinus = `${red}-${white}`;
    maxLength = actualLines.length;
  }

  for (i = 0; i < maxLines; i++) {
    if (maxLength < i + 1) {
      // If more than two former lines are identical, print them. Collapse them
      // in case more than five lines were identical.
      if (identical > 2) {
        if (identical > 3) {
          if (identical > 4) {
            if (identical === 5) {
              res += `\n  ${lines[i - 3]}`;
              printedLines++;
            } else {
              res += `\n${blue}...${white}`;
              skipped = true;
            }
          }
          res += `\n  ${lines[i - 2]}`;
          printedLines++;
        }
        res += `\n  ${lines[i - 1]}`;
        printedLines++;
      }
      // No identical lines before.
      identical = 0;
      // Add the expected line to the cache.
      if (lines === actualLines) {
        res += `\n${plusMinus} ${lines[i]}`;
      } else {
        other += `\n${plusMinus} ${lines[i]}`;
      }
      printedLines++;
    // Only extra actual lines exist
    // Lines diverge
    } else {
      const expectedLine = expectedLines[i];
      let actualLine = actualLines[i];
      // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.
      let divergingLines =
        actualLine !== expectedLine &&
        (!String.prototype.endsWith.call(actualLine, ',') ||
         String.prototype.slice.call(actualLine, 0, -1) !== expectedLine);
      // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //
      if (divergingLines &&
          String.prototype.endsWith.call(expectedLine, ',') &&
          String.prototype.slice.call(expectedLine, 0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If more than two former lines are identical, print them. Collapse
        // them in case more than five lines were identical.
        if (identical > 2) {
          if (identical > 3) {
            if (identical > 4) {
              if (identical === 5) {
                res += `\n  ${actualLines[i - 3]}`;
                printedLines++;
              } else {
                res += `\n${blue}...${white}`;
                skipped = true;
              }
            }
            res += `\n  ${actualLines[i - 2]}`;
            printedLines++;
          }
          res += `\n  ${actualLines[i - 1]}`;
          printedLines++;
        }
        // No identical lines before.
        identical = 0;
        // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
        res += `\n${green}+${white} ${actualLine}`;
        other += `\n${red}-${white} ${expectedLine}`;
        printedLines += 2;
      // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = '';
        identical++;
        // The very first identical line since the last diverging line is be
        // added to the result.
        if (identical <= 2) {
          res += `\n  ${actualLine}`;
          printedLines++;
        }
      }
    }
    // Inspected object to big (Show ~50 rows max)
    if (printedLines > 50 && i < maxLines - 2) {
      return `${msg}${skippedMsg}\n${res}\n${blue}...${white}${other}\n` +
             `${blue}...${white}`;
    }
  }

  return `${msg}${skipped ? skippedMsg : ''}\n${res}${other}${end}${indicator}`;
}

function addEllipsis(string) {
  const lines = String.prototype.split.call(string, '\n', 11);
  if (lines.length > 10) {
    lines.length = 10;
    return `${Array.prototype.join.call(lines, '\n')}\n...`;
  } else if (string.length > 512) {
    return `${String.prototype.slice.call(string, 512)}...`;
  }
  return string;
}

class AssertionError extends Error {
  constructor(options) {

    // let quickjs context know assertion has failed
    globalThis.assertPass = false;
    print(""assert fail"");
    print(new Error().stack);

    validateObject(options, 'options');
    const {
      message,
      operator,
      stackStartFn,
      details,
      // Compatibility with older versions.
      stackStartFunction
    } = options;
    let {
      actual,
      expected
    } = options;

    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;

    if (message != null) {
      super(String(message));
    } else {
      // Reset colors on each call to make sure we handle dynamically set environment
      // variables correct.
      refresh();
      // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.
      if (typeof actual === 'object' && actual !== null &&
          typeof expected === 'object' && expected !== null &&
          'stack' in actual && actual instanceof Error &&
          'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        super(createErrDiff(actual, expected, operator));
      } else if (operator === 'notDeepStrictEqual' ||
        operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        let base = kReadableOperator[operator];
        const res = String.prototype.split.call(inspectValue(actual), '\n');

        // In case ""actual"" is an object or a function, it should not be
        // reference equal.
        if (operator === 'notStrictEqual' &&
            ((typeof actual === 'object' && actual !== null) ||
             typeof actual === 'function')) {
          base = kReadableOperator.notStrictEqualObject;
        }

        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (res.length > 50) {
          res[46] = `${blue}...${white}`;
          while (res.length > 47) {
            Array.prototype.pop.call(res);
          }
        }

        // Only print a single input.
        if (res.length === 1) {
          super(`${base}${res[0].length > 5 ? '\n\n' : ' '}${res[0]}`);
        } else {
          super(`${base}\n\n${Array.prototype.join.call(res, '\n')}\n`);
        }
      } else {
        let res = inspectValue(actual);
        let other = inspectValue(expected);
        const knownOperator = kReadableOperator[operator];
        if (operator === 'notDeepEqual' && res === other) {
          res = `${knownOperator}\n\n${res}`;
          if (res.length > 1024) {
            res = `${String.prototype.slice.call(res, 0, 1021)}...`;
          }
          super(res);
        } else {
          if (res.length > 512) {
            res = `${String.prototype.slice.call(res, 0, 509)}...`;
          }
          if (other.length > 512) {
            other = `${String.prototype.slice.call(other, 0, 509)}...`;
          }
          if (operator === 'deepEqual') {
            res = `${knownOperator}\n\n${res}\n\nshould loosely deep-equal\n\n`;
          } else {
            const newOp = kReadableOperator[`${operator}Unequal`];
            if (newOp) {
              res = `${newOp}\n\n${res}\n\nshould not loosely deep-equal\n\n`;
            } else {
              other = ` ${operator} ${other}`;
            }
          }
          super(`${res}${other}`);
        }
      }
    }

    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;

    this.generatedMessage = !message;
    Object.defineProperty(this, 'name', {
      __proto__: null,
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    this.code = 'ERR_ASSERTION';
    if (details) {
      this.actual = undefined;
      this.expected = undefined;
      this.operator = undefined;
      for (let i = 0; i < details.length; i++) {
        this['message ' + i] = details[i].message;
        this['actual ' + i] = details[i].actual;
        this['expected ' + i] = details[i].expected;
        this['operator ' + i] = details[i].operator;
        this['stack trace ' + i] = details[i].stack;
      }
    } else {
      this.actual = actual;
      this.expected = expected;
      this.operator = operator;
    }
    // Error.captureStackTrace(this, stackStartFn || stackStartFunction);
    // Create error message including the error code in the name.
    this.stack; // eslint-disable-line no-unused-expressions
    // Reset the name.
    this.name = 'AssertionError';

    print(this);
    print(this.stack);
  }

  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }

  [inspect.custom](recurseTimes, ctx) {
    // Long strings should not be fully inspected.
    const tmpActual = this.actual;
    const tmpExpected = this.expected;

    if (typeof this.actual === 'string') {
      this.actual = addEllipsis(this.actual);
    }
    if (typeof this.expected === 'string') {
      this.expected = addEllipsis(this.expected);
    }

    // This limits the `actual` and `expected` property default inspection to
    // the minimum depth. Otherwise those values would be too verbose compared
    // to the actual error message which contains a combined view of these two
    // input values.
    const result = inspect(this, {
      ...ctx,
      customInspect: false,
      depth: 0
    });

    // Reset the properties after inspection.
    this.actual = tmpActual;
    this.expected = tmpExpected;

    return result;
  }
}

export default AssertionError;
"
test/fs/test-fs-error-messages.js,"// Flags: --expose-internals
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();


const nonexistentFile = path.join(tmpdir.path, 'non-existent');
const nonexistentDir = path.join(tmpdir.path, 'non-existent', 'foo', 'bar');
const existingFile = path.join(tmpdir.path, 'existingFile.js');
const existingFile2 = path.join(tmpdir.path, 'existingFile2.js');
const existingDir = path.join(tmpdir.path, 'dir');
const existingDir2 = fixtures.path('keys');
fs.mkdirSync(existingDir);
fs.writeFileSync(existingFile, 'test', 'utf-8');
fs.writeFileSync(existingFile2, 'test', 'utf-8');


const { COPYFILE_EXCL } = fs.constants;
import { internalBinding } from 'internal/test/binding';
const {
  UV_EBADF,
  UV_EEXIST,
  UV_EINVAL,
  UV_ENOENT,
  UV_ENOTDIR,
  UV_ENOTEMPTY,
  UV_EPERM
} = internalBinding('uv');

// Template tag function for escaping special characters in strings so that:
// new RegExp(re`${str}`).test(str) === true
function re(literals, ...values) {
  const escapeRE = /[\\^$.*+?()[\]{}|=!<>:-]/g;
  let result = literals[0].replace(escapeRE, '\\$&');
  for (const [i, value] of values.entries()) {
    result += value.replace(escapeRE, '\\$&');
    result += literals[i + 1].replace(escapeRE, '\\$&');
  }
  return result;
}

// stat
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, stat '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'stat');
    return true;
  };

  fs.stat(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.statSync(nonexistentFile),
    validateError
  );
}

// lstat
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, lstat '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'lstat');
    return true;
  };

  fs.lstat(nonexistentFile, common.mustCall(validateError));
  assert.throws(
    () => fs.lstatSync(nonexistentFile),
    validateError
  );
}

// fstat
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fstat');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fstat');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fstat(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.fstatSync(fd),
      validateError
    );
  });
}

// realpath
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, lstat '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'lstat');
    return true;
  };

  fs.realpath(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.realpathSync(nonexistentFile),
    validateError
  );
}

// native realpath
/*{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, realpath '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'realpath');
    return true;
  };

  fs.realpath.native(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.realpathSync.native(nonexistentFile),
    validateError
  );
}*/

// readlink
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, readlink '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'readlink');
    return true;
  };

  fs.readlink(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.readlinkSync(nonexistentFile),
    validateError
  );
}

// Link nonexistent file
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    // Could be resolved to an absolute path
    assert.ok(err.dest.endsWith('foo'),
              `expect ${err.dest} to end with 'foo'`);
    const regexp = new RegExp('^ENOENT: no such file or directory, link ' +
                              re`'${nonexistentFile}' -> ` + '\'.*foo\'');
    assert.match(err.message, regexp);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'link');
    return true;
  };

  fs.link(nonexistentFile, 'foo', common.mustCall(validateError));

  assert.throws(
    () => fs.linkSync(nonexistentFile, 'foo'),
    validateError
  );
}

// link existing file
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(existingFile2, err.dest);
    assert.strictEqual(
      err.message,
      `EEXIST: file already exists, link '${existingFile}' -> ` +
      `'${existingFile2}'`);
    assert.strictEqual(err.errno, UV_EEXIST);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'link');
    return true;
  };

  fs.link(existingFile, existingFile2, common.mustCall(validateError));

  assert.throws(
    () => fs.linkSync(existingFile, existingFile2),
    validateError
  );
}

// symlink
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(existingFile2, err.dest);
    assert.strictEqual(
      err.message,
      `EEXIST: file already exists, symlink '${existingFile}' -> ` +
      `'${existingFile2}'`);
    assert.strictEqual(err.errno, UV_EEXIST);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'symlink');
    return true;
  };

  fs.symlink(existingFile, existingFile2, common.mustCall(validateError));

  assert.throws(
    () => fs.symlinkSync(existingFile, existingFile2),
    validateError
  );
}

// unlink
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, unlink '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'unlink');
    return true;
  };

  fs.unlink(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.unlinkSync(nonexistentFile),
    validateError
  );
}

// rename
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    // Could be resolved to an absolute path
    assert.ok(err.dest.endsWith('foo'),
              `expect ${err.dest} to end with 'foo'`);
    const regexp = new RegExp('ENOENT: no such file or directory, rename ' +
                              re`'${nonexistentFile}' -> ` + '\'.*foo\'');
    assert.match(err.message, regexp);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'rename');
    return true;
  };

  const destFile = path.join(tmpdir.path, 'foo');
  fs.rename(nonexistentFile, destFile, common.mustCall(validateError));

  assert.throws(
    () => fs.renameSync(nonexistentFile, destFile),
    validateError
  );
}

// Rename non-empty directory
{
  const validateError = (err) => {
    assert.strictEqual(existingDir, err.path);
    assert.strictEqual(existingDir2, err.dest);
    assert.strictEqual(err.syscall, 'rename');
    // Could be ENOTEMPTY, EEXIST, or EPERM, depending on the platform
    if (err.code === 'ENOTEMPTY') {
      assert.strictEqual(
        err.message,
        `ENOTEMPTY: directory not empty, rename '${existingDir}' -> ` +
        `'${existingDir2}'`);
      assert.strictEqual(err.errno, UV_ENOTEMPTY);
    } else if (err.code === 'EXDEV') {  // Not on the same mounted filesystem
      assert.strictEqual(
        err.message,
        `EXDEV: cross-device link not permitted, rename '${existingDir}' -> ` +
            `'${existingDir2}'`);
    } else if (err.code === 'EEXIST') {  // smartos and aix
      assert.strictEqual(
        err.message,
        `EEXIST: file already exists, rename '${existingDir}' -> ` +
        `'${existingDir2}'`);
      assert.strictEqual(err.errno, UV_EEXIST);
    } else {  // windows
      assert.strictEqual(
        err.message,
        `EPERM: operation not permitted, rename '${existingDir}' -> ` +
        `'${existingDir2}'`);
      assert.strictEqual(err.errno, UV_EPERM);
      assert.strictEqual(err.code, 'EPERM');
    }
    return true;
  };

  fs.rename(existingDir, existingDir2, common.mustCall(validateError));

  assert.throws(
    () => fs.renameSync(existingDir, existingDir2),
    validateError
  );
}

// rmdir
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, rmdir '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'rmdir');
    return true;
  };

  fs.rmdir(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.rmdirSync(nonexistentFile),
    validateError
  );
}

// rmdir a file
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(err.syscall, 'rmdir');
    if (err.code === 'ENOTDIR') {
      assert.strictEqual(
        err.message,
        `ENOTDIR: not a directory, rmdir '${existingFile}'`);
      assert.strictEqual(err.errno, UV_ENOTDIR);
    } else {  // windows
      assert.strictEqual(
        err.message,
        `ENOENT: no such file or directory, rmdir '${existingFile}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
    }
    return true;
  };

  fs.rmdir(existingFile, common.mustCall(validateError));

  assert.throws(
    () => fs.rmdirSync(existingFile),
    validateError
  );
}

// mkdir
{
  const validateError = (err) => {
    assert.strictEqual(existingFile, err.path);
    assert.strictEqual(
      err.message,
      `EEXIST: file already exists, mkdir '${existingFile}'`);
    assert.strictEqual(err.errno, UV_EEXIST);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'mkdir');
    return true;
  };

  fs.mkdir(existingFile, 0o666, common.mustCall(validateError));

  assert.throws(
    () => fs.mkdirSync(existingFile, 0o666),
    validateError
  );
}

// chmod
/*
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, chmod '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'chmod');
    return true;
  };

  fs.chmod(nonexistentFile, 0o666, common.mustCall(validateError));

  assert.throws(
    () => fs.chmodSync(nonexistentFile, 0o666),
    validateError
  );
}*/

// open
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, open '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'open');
    return true;
  };

  fs.open(nonexistentFile, 'r', 0o666, common.mustCall(validateError));

  assert.throws(
    () => fs.openSync(nonexistentFile, 'r', 0o666),
    validateError
  );
}


// close
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, close');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'close');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.close(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.closeSync(fd),
      validateError
    );
  });
}

// readFile
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, open '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'open');
    return true;
  };

  fs.readFile(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.readFileSync(nonexistentFile),
    validateError
  );
}

// readdir
{
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, scandir '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'scandir');
    return true;
  };

  fs.readdir(nonexistentFile, common.mustCall(validateError));

  assert.throws(
    () => fs.readdirSync(nonexistentFile),
    validateError
  );
}

// ftruncate
{
  const validateError = (err) => {
    assert.strictEqual(err.syscall, 'ftruncate');
    // Could be EBADF or EINVAL, depending on the platform
    if (err.code === 'EBADF') {
      assert.strictEqual(err.message, 'EBADF: bad file descriptor, ftruncate');
      assert.strictEqual(err.errno, UV_EBADF);
    } else {
      assert.strictEqual(err.message, 'EINVAL: invalid argument, ftruncate');
      assert.strictEqual(err.errno, UV_EINVAL);
      assert.strictEqual(err.code, 'EINVAL');
    }
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.ftruncate(fd, 4, common.mustCall(validateError));

    assert.throws(
      () => fs.ftruncateSync(fd, 4),
      validateError
    );
  });
}

// fdatasync
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fdatasync');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fdatasync');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fdatasync(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.fdatasyncSync(fd),
      validateError
    );
  });
}

// fsync
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fsync');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fsync');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fsync(fd, common.mustCall(validateError));

    assert.throws(
      () => fs.fsyncSync(fd),
      validateError
    );
  });
}

// chown
/*if (!common.isWindows) {
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, chown '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'chown');
    return true;
  };

  fs.chown(nonexistentFile, process.getuid(), process.getgid(),
           common.mustCall(validateError));

  assert.throws(
    () => fs.chownSync(nonexistentFile,
                       process.getuid(), process.getgid()),
    validateError
  );
}*/

// utimes
if (!common.isAIX) {
  const validateError = (err) => {
    assert.strictEqual(nonexistentFile, err.path);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, utime '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'utime');
    return true;
  };

  fs.utimes(nonexistentFile, new Date(), new Date(),
            common.mustCall(validateError));

  assert.throws(
    () => fs.utimesSync(nonexistentFile, new Date(), new Date()),
    validateError
  );
}

// mkdtemp
{
  const validateError = (err) => {
    const pathPrefix = new RegExp('^' + re`${nonexistentDir}`);
    assert.match(err.path, pathPrefix);

    const prefix = new RegExp('^ENOENT: no such file or directory, mkdtemp ' +
                              re`'${nonexistentDir}`);
    assert.match(err.message, prefix);

    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'mkdtemp');
    return true;
  };

  fs.mkdtemp(nonexistentDir, common.mustCall(validateError));

  assert.throws(
    () => fs.mkdtempSync(nonexistentDir),
    validateError
  );
}

// Check copyFile with invalid modes.
{
  const validateError = {
    message: /""mode"".+must be an integer >= 0 && <= 7\. Received -1/,
    code: 'ERR_OUT_OF_RANGE'
  };

  assert.throws(
    () => fs.copyFile(existingFile, nonexistentFile, -1, () => {}),
    validateError
  );
  assert.throws(
    () => fs.copyFileSync(existingFile, nonexistentFile, -1),
    validateError
  );
}

// copyFile: destination exists but the COPYFILE_EXCL flag is provided.
{
  const validateError = (err) => {
    if (err.code === 'ENOENT') {  // Could be ENOENT or EEXIST
      assert.strictEqual(err.message,
                         'ENOENT: no such file or directory, copyfile ' +
                         `'${existingFile}' -> '${existingFile2}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
      assert.strictEqual(err.syscall, 'copyfile');
    } else {
      assert.strictEqual(err.message,
                         'EEXIST: file already exists, copyfile ' +
                         `'${existingFile}' -> '${existingFile2}'`);
      assert.strictEqual(err.errno, UV_EEXIST);
      assert.strictEqual(err.code, 'EEXIST');
      assert.strictEqual(err.syscall, 'copyfile');
    }
    return true;
  };

  fs.copyFile(existingFile, existingFile2, COPYFILE_EXCL,
              common.mustCall(validateError));

  assert.throws(
    () => fs.copyFileSync(existingFile, existingFile2, COPYFILE_EXCL),
    validateError
  );
}

// copyFile: the source does not exist.
{
  const validateError = (err) => {
    assert.strictEqual(err.message,
                       'ENOENT: no such file or directory, copyfile ' +
                       `'${nonexistentFile}' -> '${existingFile2}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'copyfile');
    return true;
  };

  fs.copyFile(nonexistentFile, existingFile2, COPYFILE_EXCL,
              common.mustCall(validateError));

  assert.throws(
    () => fs.copyFileSync(nonexistentFile, existingFile2, COPYFILE_EXCL),
    validateError
  );
}

// read
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, read');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'read');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    const buf = Buffer.alloc(5);
    fs.read(fd, buf, 0, 1, 1, common.mustCall(validateError));

    assert.throws(
      () => fs.readSync(fd, buf, 0, 1, 1),
      validateError
    );
  });
}

// fchmod
/*{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fchmod');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fchmod');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fchmod(fd, 0o666, common.mustCall(validateError));

    assert.throws(
      () => fs.fchmodSync(fd, 0o666),
      validateError
    );
  });
}

// fchown
if (!common.isWindows) {
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, fchown');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'fchown');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.fchown(fd, process.getuid(), process.getgid(),
              common.mustCall(validateError));

    assert.throws(
      () => fs.fchownSync(fd, process.getuid(), process.getgid()),
      validateError
    );
  });
}*/

// write buffer
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, write');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'write');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    const buf = Buffer.alloc(5);
    fs.write(fd, buf, 0, 1, 1, common.mustCall(validateError));

    assert.throws(
      () => fs.writeSync(fd, buf, 0, 1, 1),
      validateError
    );
  });
}

// write string
{
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, write');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'write');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.write(fd, 'test', 1, common.mustCall(validateError));

    assert.throws(
      () => fs.writeSync(fd, 'test', 1),
      validateError
    );
  });
}


// futimes
if (!common.isAIX) {
  const validateError = (err) => {
    assert.strictEqual(err.message, 'EBADF: bad file descriptor, futime');
    assert.strictEqual(err.errno, UV_EBADF);
    assert.strictEqual(err.code, 'EBADF');
    assert.strictEqual(err.syscall, 'futime');
    return true;
  };

  common.runWithInvalidFD((fd) => {
    fs.futimes(fd, new Date(), new Date(), common.mustCall(validateError));

    assert.throws(
      () => fs.futimesSync(fd, new Date(), new Date()),
      validateError
    );
  });
}
"
modules/punycode.js,"use strict';

/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	const parts = string.split('@');
	let result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	const labels = string.split('.');
	const encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter < length) {
		const value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = array => String.fromCodePoint(...array);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function(delta, numPoints, firstTime) {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function(input) {
	// Don't use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (let j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		let oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index >= inputLength) {
				error('invalid-input');
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error('overflow');
			}

			i += digit * w;
			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

			if (digit < t) {
				break;
			}

			const baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error('overflow');
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function(input) {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	let inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue < 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	let basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue >= n && currentValue < m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue < n && ++delta > maxInt) {
				error('overflow');
			}
			if (currentValue == n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
					if (q < t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function(input) {
	return mapDomain(input, function(string) {
		return regexPunycode.test(string)
			? decode(string.slice(4).toLowerCase())
			: string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function(input) {
	return mapDomain(input, function(string) {
		return regexNonASCII.test(string)
			? 'xn--' + encode(string)
			: string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	'version': '2.1.0',
	/**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

export { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };
export default punycode;
"
src/quickjs_sys/js_class.rs,"use crate::quickjs_sys::qjs::*;
use crate::{Context, EventLoop, JsObject, JsRef, JsValue};

use std::collections::HashMap;
use std::ops::{Deref, DerefMut};

fn parse_c_string(s: &mut String) {
    if !s.ends_with('\0') {
        let len = s.len();
        s.push('\0');
        s.truncate(len);
    }
}

unsafe extern ""C"" fn js_method_magic_trampoline<Def: JsClassDef>(
    ctx: *mut JSContext,
    this_val: JSValue,
    len: i32,
    argv: *mut JSValue,
    magic: i32,
) -> JSValue {
    let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });

    let class_id = Def::class_id();
    let data = JS_GetOpaque(this_val, class_id) as *mut Def::RefType;
    if data.is_null() {
        return JsValue::Exception(n_ctx.throw_type_error(""Invalid Class"")).into_qjs_value();
    }

    let mut arg_vec = vec![];
    for i in 0..len {
        let arg = argv.offset(i as isize);
        let v = *arg;
        let v = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, v));
        arg_vec.push(v);
    }

    let data = data.as_mut().unwrap();
    let mut this_obj = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, this_val))
        .to_obj()
        .unwrap();

    let r = Def::invoke_method_index(data, &mut this_obj, magic as usize, &mut n_ctx, &arg_vec);
    r.into_qjs_value()
}

unsafe extern ""C"" fn getter_magic_trampoline<Def: JsClassDef>(
    ctx: *mut JSContext,
    this_val: JSValue,
    magic: i32,
) -> JSValue {
    let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });

    let class_id = Def::class_id();
    let data = JS_GetOpaque(this_val, class_id) as *mut Def::RefType;
    if data.is_null() {
        return JsValue::Exception(n_ctx.throw_type_error(""Invalid Class"")).into_qjs_value();
    }

    let data = data.as_mut().unwrap();
    let r = Def::field_get(data, magic as usize, &mut n_ctx);
    r.into_qjs_value()
}

unsafe extern ""C"" fn setter_magic_trampoline<Def: JsClassDef>(
    ctx: *mut JSContext,
    this_val: JSValue,
    val: JSValue,
    magic: i32,
) -> JSValue {
    let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });

    let class_id = Def::class_id();
    let data = JS_GetOpaque(this_val, class_id) as *mut Def::RefType;
    if data.is_null() {
        return JsValue::Exception(n_ctx.throw_type_error(""Invalid Class"")).into_qjs_value();
    }

    let data = data.as_mut().unwrap();
    let val = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, val));

    Def::field_set(data, magic as usize, &mut n_ctx, val);
    js_undefined()
}

#[derive(Debug, Default)]
pub struct JsClassProto {
    methods: HashMap<String, (u8, usize)>,
    fields: HashMap<String, usize>,
}

fn into_proto_function_list<Def: JsClassDef>(p: JsClassProto) -> &'static [JSCFunctionListEntry] {
    let mut entry_vec = vec![];

    let JsClassProto { methods, fields } = p;

    for (mut field_name, i) in fields {
        parse_c_string(&mut field_name);

        let e = JSCFunctionListEntry {
            name: field_name.as_ptr().cast(),
            prop_flags: JS_PROP_CONFIGURABLE as u8,
            def_type: JS_DEF_CGETSET_MAGIC as u8,
            magic: i as i16,
            u: JSCFunctionListEntry__bindgen_ty_1 {
                getset: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2 {
                    get: JSCFunctionType {
                        getter_magic: Some(getter_magic_trampoline::<Def>),
                    },
                    set: JSCFunctionType {
                        setter_magic: Some(setter_magic_trampoline::<Def>),
                    },
                },
            },
        };

        entry_vec.push(e);
        std::mem::forget(field_name);
    }

    for (mut method_name, (argc, i)) in methods {
        parse_c_string(&mut method_name);
        let e = JSCFunctionListEntry {
            name: method_name.as_ptr().cast(),
            prop_flags: (JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE) as u8,
            def_type: JS_DEF_CFUNC as u8,
            magic: i as i16,
            u: JSCFunctionListEntry__bindgen_ty_1 {
                func: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1 {
                    length: argc,
                    cproto: JSCFunctionEnum_JS_CFUNC_generic_magic as u8,
                    cfunc: JSCFunctionType {
                        generic_magic: Some(js_method_magic_trampoline::<Def>),
                    },
                },
            },
        };
        entry_vec.push(e);
        std::mem::forget(method_name);
    }

    Vec::leak(entry_vec)
}

pub struct SelfRefJsValue<R, T> {
    data: T,
    val: JsValue,
    _p: std::marker::PhantomData<(R, T)>,
}

impl<R, T> Deref for SelfRefJsValue<R, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.data
    }
}

impl<R, T> DerefMut for SelfRefJsValue<R, T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.data
    }
}

pub trait JsClassTool: JsClassDef {
    fn class_id() -> u32;

    fn proto(ctx: &mut Context) -> JsValue {
        ctx.get_class_proto(Self::class_id())
    }

    fn constructor(ctx: &mut Context) -> Option<JsValue> {
        ctx.get_class_constructor(Self::class_id())
    }

    fn self_ref_opaque_mut<T, E>(
        js_obj: JsValue,
        f: impl FnOnce(&'static Self::RefType) -> Result<T, E>,
    ) -> Option<Result<SelfRefJsValue<Self, T>, E>>
    where
        Self: Sized,
    {
        unsafe {
            let class_id = Self::class_id();
            let ptr = JS_GetOpaque(js_obj.get_qjs_value(), class_id) as *mut Self::RefType;
            let r: &'static mut <Self as JsClassDef>::RefType = ptr.as_mut()?;
            match f(r) {
                Ok(data) => Some(Ok(SelfRefJsValue {
                    data,
                    val: js_obj,
                    _p: Default::default(),
                })),
                Err(e) => Some(Err(e)),
            }
        }
    }

    fn opaque_mut(js_obj: &mut JsValue) -> Option<&mut Self::RefType> {
        unsafe {
            let class_id = Self::class_id();
            let ptr = JS_GetOpaque(js_obj.get_qjs_value(), class_id) as *mut Self::RefType;
            ptr.as_mut()
        }
    }

    fn opaque(js_obj: &JsValue) -> Option<&Self::RefType> {
        unsafe {
            let class_id = Self::class_id();
            let ptr = JS_GetOpaque(js_obj.get_qjs_value(), class_id) as *mut Self::RefType;
            ptr.as_ref()
        }
    }

    fn wrap_obj(ctx: &mut Context, data: Self::RefType) -> JsValue {
        unsafe {
            let class_id = Self::class_id();
            let obj = JS_NewObjectClass(ctx.ctx, class_id as i32);

            if JS_IsException_real(obj) > 0 {
                JsValue::from_qjs_value(ctx.ctx, obj)
            } else {
                let ptr_data = Box::leak(Box::new(data));
                JS_SetOpaque(obj, (ptr_data as *mut Self::RefType).cast());
                JsValue::from_qjs_value(ctx.ctx, obj)
            }
        }
    }
}

impl<T: JsClassDef> JsClassTool for T {
    fn class_id() -> u32 {
        unsafe { *Self::mut_class_id_ptr() }
    }
}

pub trait ExtendsJsClassDef {
    type RefType: Sized
        + AsRef<<Self::BaseDef as JsClassDef>::RefType>
        + AsMut<<Self::BaseDef as JsClassDef>::RefType>
        + 'static;

    type BaseDef: JsClassDef;

    const EXT_CLASS_NAME: &'static str;
    const CONSTRUCTOR_ARGC: u8;
    const FIELDS: &'static [JsClassField<Self::RefType>];
    const METHODS: &'static [JsClassMethod<Self::RefType>];

    unsafe fn mut_class_id_ptr() -> &'static mut u32;

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue>;

    fn finalizer(_data: &mut Self::RefType, _event_loop: Option<&mut EventLoop>) {}

    fn gc_mark(_data: &Self::RefType, _make: &mut dyn Fn(&JsValue)) {}
}

impl<S: ExtendsJsClassDef> JsClassDef for S {
    type RefType = <Self as ExtendsJsClassDef>::RefType;

    const CLASS_NAME: &'static str = <Self as ExtendsJsClassDef>::EXT_CLASS_NAME;

    const CONSTRUCTOR_ARGC: u8 = <Self as ExtendsJsClassDef>::CONSTRUCTOR_ARGC;

    const FIELDS: &'static [JsClassField<Self::RefType>] = <Self as ExtendsJsClassDef>::FIELDS;

    const METHODS: &'static [JsClassMethod<Self::RefType>] = <Self as ExtendsJsClassDef>::METHODS;

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        <Self as ExtendsJsClassDef>::mut_class_id_ptr()
    }

    #[inline(always)]
    fn methods_size() -> PropEntrySize {
        let l = Self::METHODS.len()
            + *<<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::methods_size();
        PropEntrySize(l)
    }

    #[inline(always)]
    fn invoke_method_index(
        this: &mut Self::RefType,
        this_obj: &mut JsObject,
        i: usize,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let base_methods_len =
            *<<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::methods_size();
        if i < base_methods_len {
            <<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::invoke_method_index(
                this.as_mut(),
                this_obj,
                i,
                ctx,
                argv,
            )
        } else {
            if let Some((_, _, f)) = Self::METHODS.get(i - base_methods_len) {
                f(this, this_obj, ctx, argv)
            } else {
                JsValue::UnDefined
            }
        }
    }

    #[inline(always)]
    fn field_size() -> PropEntrySize {
        let s = Self::FIELDS.len()
            + *<<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::field_size();
        PropEntrySize(s)
    }

    fn field_get(this: &Self::RefType, i: usize, ctx: &mut Context) -> JsValue {
        let base_fields_len = *<<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::field_size();
        if i < base_fields_len {
            <<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::field_get(this.as_ref(), i, ctx)
        } else {
            if let Some((_, getter, _)) = Self::FIELDS.get(i) {
                getter(this, ctx)
            } else {
                JsValue::UnDefined
            }
        }
    }
    fn field_set(this: &mut Self::RefType, i: usize, ctx: &mut Context, val: JsValue) {
        let base_fields_len = *<<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::field_size();
        if i < base_fields_len {
            <<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::field_set(
                this.as_mut(),
                i,
                ctx,
                val,
            )
        } else {
            if let Some((_, _, Some(setter))) = Self::FIELDS.get(i) {
                setter(this, ctx, val)
            }
        }
    }

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        <Self as ExtendsJsClassDef>::constructor_fn(ctx, argv)
    }

    fn finalizer(data: &mut Self::RefType, event_loop: Option<&mut EventLoop>) {
        if let Some(e) = event_loop {
            <Self as ExtendsJsClassDef>::finalizer(data, Some(e));
            <<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::finalizer(data.as_mut(), Some(e));
        } else {
            <Self as ExtendsJsClassDef>::finalizer(data, None);
            <<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::finalizer(data.as_mut(), None);
        }
    }

    fn gc_mark(data: &Self::RefType, make: &mut dyn Fn(&JsValue)) {
        <<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::gc_mark(data.as_ref(), make);
        <Self as ExtendsJsClassDef>::gc_mark(data, make);
    }

    fn property_keys_init(p: &mut JsClassProto) -> PropInitResult {
        <<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::property_keys_init(p);

        let l = *<<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::methods_size();
        for (i, (name, argc, ..)) in Self::METHODS.iter().enumerate() {
            p.methods.insert(name.to_string(), (*argc, i + l));
        }

        let l = *<<Self as ExtendsJsClassDef>::BaseDef as JsClassDef>::field_size();
        for (i, (name, ..)) in Self::FIELDS.iter().enumerate() {
            p.fields.insert(name.to_string(), i + l);
        }

        PropInitResult(())
    }
}

// only make user can't impl JsClassDef::property_keys_init
pub struct PropInitResult(());

pub struct PropEntrySize(usize);
impl Deref for PropEntrySize {
    type Target = usize;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl DerefMut for PropEntrySize {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

pub struct PropEntryName(&'static str);
impl Deref for PropEntryName {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

pub type JsClassField<T> = (
    &'static str,
    fn(&T, &mut Context) -> JsValue,
    Option<fn(&mut T, &mut Context, JsValue)>,
);

pub type JsClassMethod<T> = (
    &'static str,
    u8,
    fn(&mut T, &mut JsObject, &mut Context, &[JsValue]) -> JsValue,
);

pub trait JsClassDef {
    type RefType: Sized + 'static;

    const CLASS_NAME: &'static str;
    const CONSTRUCTOR_ARGC: u8;

    const FIELDS: &'static [JsClassField<Self::RefType>];

    const METHODS: &'static [JsClassMethod<Self::RefType>];

    unsafe fn mut_class_id_ptr() -> &'static mut u32;

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue>;

    /// don't modify on impl trait
    fn property_keys_init(p: &mut JsClassProto) -> PropInitResult {
        for (i, (name, argc, ..)) in Self::METHODS.iter().enumerate() {
            p.methods.insert(name.to_string(), (*argc, i));
        }
        for (i, (name, ..)) in Self::FIELDS.iter().enumerate() {
            p.fields.insert(name.to_string(), i);
        }

        PropInitResult(())
    }

    /// don't modify on impl trait
    fn methods_size() -> PropEntrySize {
        PropEntrySize(Self::METHODS.len())
    }

    /// don't modify on impl trait
    fn invoke_method_index(
        this: &mut Self::RefType,
        this_obj: &mut JsObject,
        i: usize,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some((_, _, f)) = Self::METHODS.get(i) {
            f(this, this_obj, ctx, argv)
        } else {
            JsValue::UnDefined
        }
    }

    /// don't modify on impl trait
    fn field_size() -> PropEntrySize {
        PropEntrySize(Self::FIELDS.len())
    }

    /// don't modify on impl trait
    fn field_get(this: &Self::RefType, i: usize, ctx: &mut Context) -> JsValue {
        if let Some((_, getter, _)) = Self::FIELDS.get(i) {
            getter(this, ctx)
        } else {
            JsValue::UnDefined
        }
    }

    /// don't modify on impl trait
    fn field_set(this: &mut Self::RefType, i: usize, ctx: &mut Context, val: JsValue) {
        if let Some((_, _, Some(setter))) = Self::FIELDS.get(i) {
            setter(this, ctx, val)
        }
    }

    fn finalizer(_data: &mut Self::RefType, _event_loop: Option<&mut EventLoop>) {}

    fn gc_mark(_data: &Self::RefType, _make: &mut dyn Fn(&JsValue)) {}
}

unsafe fn gc_mark_value(
    rt: *mut JSRuntime,
    v: &JsValue,
    mark_func: Option<unsafe extern ""C"" fn(*mut JSRuntime, *mut JSGCObjectHeader)>,
) {
    match v {
        JsValue::BigNum(_) => {}
        JsValue::String(_) => {}
        JsValue::Object(_) => {}
        JsValue::ArrayBuffer(_) => {}
        JsValue::Function(_) => {}
        _ => return,
    }
    JS_MarkValue(rt, v.get_qjs_value(), mark_func);
}

unsafe extern ""C"" fn gc_mark<Def: JsClassDef>(
    rt: *mut JSRuntime,
    val: JSValue,
    mark_func: Option<unsafe extern ""C"" fn(*mut JSRuntime, *mut JSGCObjectHeader)>,
) {
    let ptr = JS_GetOpaque(val, Def::class_id()) as *mut Def::RefType;
    if let Some(ptr) = ptr.as_ref() {
        Def::gc_mark(&ptr, &mut |v| gc_mark_value(rt, v, mark_func));
    }
}

unsafe extern ""C"" fn finalizer<Def: JsClassDef>(rt: *mut JSRuntime, val: JSValue) {
    let class_id = Def::class_id();

    let s = JS_GetOpaque(val, class_id) as *mut Def::RefType;
    if !s.is_null() {
        let mut s = Box::from_raw(s);
        let event_loop_ptr = JS_GetRuntimeOpaque(rt) as *mut crate::EventLoop;
        Def::finalizer(&mut s, event_loop_ptr.as_mut());
    }
}

unsafe extern ""C"" fn constructor<Def: JsClassDef>(
    ctx: *mut JSContext,
    new_target: JSValue,
    len: ::std::os::raw::c_int,
    argv: *mut JSValue,
) -> JSValue {
    let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });

    let new_target = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, new_target));

    let proto = new_target.get(""prototype"").unwrap_or(JsValue::Null);
    if let JsValue::Exception(_) = &proto {
        return JS_Throw(ctx, proto.into_qjs_value());
    }

    let mut arg_vec = vec![];
    for i in 0..len {
        let arg = argv.offset(i as isize);
        let v = *arg;
        let v = JsValue::from_qjs_value(ctx, JS_DupValue_real(ctx, v));
        arg_vec.push(v);
    }
    let data = Def::constructor_fn(&mut n_ctx, arg_vec.as_slice());
    match data {
        Ok(data) => {
            let class_id = Def::class_id();
            let obj = JS_NewObjectProtoClass(ctx, proto.get_qjs_value(), class_id);

            if JS_IsException_real(obj) != 0 {
                JS_Throw(ctx, obj)
            } else {
                let ptr_data = Box::leak(Box::new(data));
                JS_SetOpaque(obj, (ptr_data as *mut Def::RefType).cast());
                obj
            }
        }
        Err(e) => e.into_qjs_value(),
    }
}

pub fn register_class<Def: JsClassDef>(ctx: &mut Context) -> JsValue {
    unsafe {
        let rt = ctx.rt();
        let mut class_id = Def::class_id();
        let mut class_name = Def::CLASS_NAME.to_string();
        parse_c_string(&mut class_name);

        if JS_IsRegisteredClass(rt, class_id) == 0 {
            let class_id_ptr = Def::mut_class_id_ptr();
            JS_NewClassID(class_id_ptr);
            class_id = *class_id_ptr;

            let js_def = JSClassDef {
                class_name: class_name.as_ptr().cast(),
                finalizer: Some(finalizer::<Def>),
                gc_mark: Some(gc_mark::<Def>),
                call: None,
                exotic: std::ptr::null_mut(),
            };
            JS_NewClass(rt, class_id, &js_def);
        }

        let mut proto_ref = JsClassProto::default();
        Def::property_keys_init(&mut proto_ref);

        //fixme leak
        let function_list = into_proto_function_list::<Def>(proto_ref);

        let proto = JS_NewObject(ctx.ctx);

        JS_SetPropertyFunctionList(
            ctx.ctx,
            proto,
            function_list.as_ptr(),
            function_list.len() as i32,
        );

        let js_ctor = JS_NewCFunction2(
            ctx.ctx,
            Some(constructor::<Def>),
            class_name.as_ptr().cast(),
            Def::CONSTRUCTOR_ARGC as i32,
            JSCFunctionEnum_JS_CFUNC_constructor,
            0,
        );

        JS_SetConstructor(ctx.ctx, js_ctor, proto);
        JS_SetClassProto(ctx.ctx, class_id, proto);
        JsValue::from_qjs_value(ctx.ctx, js_ctor)
    }
}

pub fn class_extends(ctx: &mut Context, proto: JsValue, base_proto: JsValue) -> bool {
    unsafe { JS_SetPrototype(ctx.ctx, proto.get_qjs_value(), base_proto.get_qjs_value()) > 0 }
}

impl Context {
    pub fn get_class_proto(&self, class_id: u32) -> JsValue {
        unsafe { JsValue::from_qjs_value(self.ctx, JS_GetClassProto(self.ctx, class_id)) }
    }

    pub fn get_class_constructor(&self, class_id: u32) -> Option<JsValue> {
        let proto = self.get_class_proto(class_id);
        proto.get(""constructor"")
    }

    pub fn call_class_constructor(&self, constructor_fn: JsValue, args: &[JsValue]) -> JsValue {
        unsafe {
            let argc = args.len();
            let mut argv: Vec<JSValue> = args.iter().map(JsValue::get_qjs_value).collect();

            let v = JS_CallConstructor(
                self.ctx,
                constructor_fn.get_qjs_value(),
                argc as i32,
                argv.as_mut_ptr(),
            );
            JsValue::from_qjs_value(self.ctx, v)
        }
    }
}
"
test/crypto/test-crypto-binary-default.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Flags: --expose-internals

// This is the same as test/simple/test-crypto, but from before the shift
// to use buffers by default.


const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const fs = require('fs');
const tls = require('tls');
const fixtures = require('../common/fixtures');

require('internal/crypto/util').setDefaultEncoding('latin1');

// Test Certificates
const certPem = fixtures.readKey('rsa_cert.crt');
const certPfx = fixtures.readKey('rsa_cert.pfx');
const keyPem = fixtures.readKey('rsa_private.pem');
const rsaPubPem = fixtures.readKey('rsa_public.pem', 'ascii');
const rsaKeyPem = fixtures.readKey('rsa_private.pem', 'ascii');

// PFX tests
tls.createSecureContext({ pfx: certPfx, passphrase: 'sample' });

assert.throws(function() {
  tls.createSecureContext({ pfx: certPfx });
}, /^Error: mac verify failure$/);

assert.throws(function() {
  tls.createSecureContext({ pfx: certPfx, passphrase: 'test' });
}, /^Error: mac verify failure$/);

assert.throws(function() {
  tls.createSecureContext({ pfx: 'sample', passphrase: 'test' });
}, /^Error: not enough data$/);

// Test HMAC
{
  const hmacHash = crypto.createHmac('sha1', 'Node')
                         .update('some data')
                         .update('to hmac')
                         .digest('hex');
  assert.strictEqual(hmacHash, '19fd6e1ba73d9ed2224dd5094a71babe85d9a892');
}

// Test HMAC-SHA-* (rfc 4231 Test Cases)
{
  const rfc4231 = [
    {
      key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
      data: Buffer.from('4869205468657265', 'hex'), // 'Hi There'
      hmac: {
        sha224: '896fb1128abbdf196832107cd49df33f47b4b1169912ba4f53684b22',
        sha256:
            'b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c' +
            '2e32cff7',
        sha384:
            'afd03944d84895626b0825f4ab46907f15f9dadbe4101ec682aa034c' +
            '7cebc59cfaea9ea9076ede7f4af152e8b2fa9cb6',
        sha512:
            '87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b305' +
            '45e17cdedaa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f170' +
            '2e696c203a126854'
      }
    },
    {
      key: Buffer.from('4a656665', 'hex'), // 'Jefe'
      data: Buffer.from('7768617420646f2079612077616e7420666f72206e6f74686' +
                        '96e673f', 'hex'), // 'what do ya want for nothing?'
      hmac: {
        sha224: 'a30e01098bc6dbbf45690f3a7e9e6d0f8bbea2a39e6148008fd05e44',
        sha256:
            '5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b9' +
            '64ec3843',
        sha384:
            'af45d2e376484031617f78d2b58a6b1b9c7ef464f5a01b47e42ec373' +
            '6322445e8e2240ca5e69e2c78b3239ecfab21649',
        sha512:
            '164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7' +
            'ea2505549758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b' +
            '636e070a38bce737'
      }
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
      data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                        'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                        'hex'),
      hmac: {
        sha224: '7fb3cb3588c6c1f6ffa9694d7d6ad2649365b0c1f65d69d1ec8333ea',
        sha256:
            '773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514' +
            'ced565fe',
        sha384:
            '88062608d3e6ad8a0aa2ace014c8a86f0aa635d947ac9febe83ef4e5' +
            '5966144b2a5ab39dc13814b94e3ab6e101a34f27',
        sha512:
            'fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33' +
            'b2279d39bf3e848279a722c806b485a47e67c807b946a337bee89426' +
            '74278859e13292fb'
      }
    },
    {
      key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                       'hex'),
      data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                        'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd',
                        'hex'),
      hmac: {
        sha224: '6c11506874013cac6a2abc1bb382627cec6a90d86efc012de7afec5a',
        sha256:
            '82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff4' +
            '6729665b',
        sha384:
            '3e8a69b7783c25851933ab6290af6ca77a9981480850009cc5577c6e' +
            '1f573b4e6801dd23c4a7d679ccf8a386c674cffb',
        sha512:
            'b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050' +
            '361ee3dba91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2d' +
            'e2adebeb10a298dd'
      }
    },
    {
      key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
      // 'Test With Truncation'
      data: Buffer.from('546573742057697468205472756e636174696f6e', 'hex'),
      hmac: {
        sha224: '0e2aea68a90c8d37c988bcdb9fca6fa8',
        sha256: 'a3b6167473100ee06e0c796c2955552b',
        sha384: '3abf34c3503b2a23a46efc619baef897',
        sha512: '415fad6271580a531d4179bc891d87a6'
      },
      truncate: true
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaa', 'hex'),
      // 'Test Using Larger Than Block-Size Key - Hash Key First'
      data: Buffer.from('54657374205573696e67204c6172676572205468616e20426' +
                        'c6f636b2d53697a65204b6579202d2048617368204b657920' +
                        '4669727374', 'hex'),
      hmac: {
        sha224: '95e9a0db962095adaebe9b2d6f0dbce2d499f112f2d2b7273fa6870e',
        sha256:
            '60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f' +
            '0ee37f54',
        sha384:
            '4ece084485813e9088d2c63a041bc5b44f9ef1012a2b588f3cd11f05' +
            '033ac4c60c2ef6ab4030fe8296248df163f44952',
        sha512:
            '80b24263c7c1a3ebb71493c1dd7be8b49b46d1f41b4aeec1121b0137' +
            '83f8f3526b56d037e05f2598bd0fd2215d6a1e5295e64f73f63f0aec' +
            '8b915a985d786598'
      }
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaa', 'hex'),
      // 'This is a test using a larger than block-size key and a larger ' +
      // 'than block-size data. The key needs to be hashed before being ' +
      // 'used by the HMAC algorithm.'
      data: Buffer.from('5468697320697320612074657374207573696e672061206c6' +
                        '172676572207468616e20626c6f636b2d73697a65206b6579' +
                        '20616e642061206c6172676572207468616e20626c6f636b2' +
                        'd73697a6520646174612e20546865206b6579206e65656473' +
                        '20746f20626520686173686564206265666f7265206265696' +
                        'e6720757365642062792074686520484d414320616c676f72' +
                        '6974686d2e', 'hex'),
      hmac: {
        sha224: '3a854166ac5d9f023f54d517d0b39dbd946770db9c2b95c9f6f565d1',
        sha256:
            '9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f5153' +
            '5c3a35e2',
        sha384:
            '6617178e941f020d351e2f254e8fd32c602420feb0b8fb9adccebb82' +
            '461e99c5a678cc31e799176d3860e6110c46523e',
        sha512:
            'e37b6a775dc87dbaa4dfa9f96e5e3ffddebd71f8867289865df5a32d' +
            '20cdc944b6022cac3c4982b10d5eeb55c3e4de15134676fb6de04460' +
            '65c97440fa8c6a58'
      }
    },
  ];

  for (const testCase of rfc4231) {
    for (const hash in testCase.hmac) {
      let result = crypto.createHmac(hash, testCase.key)
                       .update(testCase.data)
                       .digest('hex');
      if (testCase.truncate) {
        result = result.substr(0, 32); // first 128 bits == 32 hex chars
      }
      assert.strictEqual(
        testCase.hmac[hash],
        result
      );
    }
  }
}

// Test HMAC-MD5/SHA1 (rfc 2202 Test Cases)
{
  const rfc2202_md5 = [
    {
      key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
      data: 'Hi There',
      hmac: '9294727a3638bb1c13f48ef8158bfc9d'
    },
    {
      key: 'Jefe',
      data: 'what do ya want for nothing?',
      hmac: '750c783e6ab0b503eaa86e310a5db738'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
      data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                        'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                        'hex'),
      hmac: '56be34521d144c88dbb8c733f0e8b3f6'
    },
    {
      key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                       'hex'),
      data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                        'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                        'cdcdcdcdcd',
                        'hex'),
      hmac: '697eaf0aca3a3aea3a75164746ffaa79'
    },
    {
      key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
      data: 'Test With Truncation',
      hmac: '56461ef2342edc00f9bab995690efd4c'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data: 'Test Using Larger Than Block-Size Key - Hash Key First',
      hmac: '6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data:
          'Test Using Larger Than Block-Size Key and Larger Than One ' +
          'Block-Size Data',
      hmac: '6f630fad67cda0ee1fb1f562db3aa53e'
    },
  ];
  const rfc2202_sha1 = [
    {
      key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
      data: 'Hi There',
      hmac: 'b617318655057264e28bc0b6fb378c8ef146be00'
    },
    {
      key: 'Jefe',
      data: 'what do ya want for nothing?',
      hmac: 'effcdf6ae5eb2fa2d27416d5f184df9c259a7c79'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
      data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddd' +
                        'ddddddddddddddddddddddddddddddddddddddddddddd' +
                        'dddddddddd',
                        'hex'),
      hmac: '125d7342b9ac11cd91a39af48aa17b4f63f175d3'
    },
    {
      key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                       'hex'),
      data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                        'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                        'cdcdcdcdcd',
                        'hex'),
      hmac: '4c9007f4026250c6bc8414f9bf50c86c2d7235da'
    },
    {
      key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
      data: 'Test With Truncation',
      hmac: '4c1a03424b55e07fe7f27be1d58bb9324a9a5a04'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data: 'Test Using Larger Than Block-Size Key - Hash Key First',
      hmac: 'aa4ae5e15272d00e95705637ce8a3b55ed402112'
    },
    {
      key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                       'aaaaaaaaaaaaaaaaaaaaaa',
                       'hex'),
      data:
          'Test Using Larger Than Block-Size Key and Larger Than One ' +
          'Block-Size Data',
      hmac: 'e8e99d0f45237d786d6bbaa7965c7808bbff1a91'
    },
  ];

  if (!common.hasFipsCrypto) {
    for (const testCase of rfc2202_md5) {
      assert.strictEqual(
        testCase.hmac,
        crypto.createHmac('md5', testCase.key)
          .update(testCase.data)
          .digest('hex')
      );
    }
  }
  for (const testCase of rfc2202_sha1) {
    assert.strictEqual(
      testCase.hmac,
      crypto.createHmac('sha1', testCase.key)
        .update(testCase.data)
        .digest('hex')
    );
  }
}

// Test hashing
{
  const a1 = crypto.createHash('sha1').update('Test123').digest('hex');
  const a2 = crypto.createHash('sha256').update('Test123').digest('base64');
  const a3 = crypto.createHash('sha512').update('Test123').digest(); // binary
  const a4 = crypto.createHash('sha1').update('Test123').digest('buffer');

  if (!common.hasFipsCrypto) {
    const a0 = crypto.createHash('md5').update('Test123').digest('latin1');
    assert.strictEqual(
      a0,
      'h\u00ea\u00cb\u0097\u00d8o\fF!\u00fa+\u000e\u0017\u00ca\u00bd\u008c'
    );
  }

  assert.strictEqual(a1, '8308651804facb7b9af8ffc53a33a22d6a1c8ac2');

  assert.strictEqual(a2, '2bX1jws4GYKTlxhloUB09Z66PoJZW+y+hq5R8dnx9l4=');

  // Test SHA512 as assumed latin1
  assert.strictEqual(
    a3,
    '\u00c1(4\u00f1\u0003\u001fd\u0097!O\'\u00d4C/&Qz\u00d4' +
    '\u0094\u0015l\u00b8\u008dQ+\u00db\u001d\u00c4\u00b5}\u00b2' +
    '\u00d6\u0092\u00a3\u00df\u00a2i\u00a1\u009b\n\n*\u000f' +
    '\u00d7\u00d6\u00a2\u00a8\u0085\u00e3<\u0083\u009c\u0093' +
    '\u00c2\u0006\u00da0\u00a1\u00879(G\u00ed\''
  );

  assert.deepStrictEqual(
    a4,
    Buffer.from('8308651804facb7b9af8ffc53a33a22d6a1c8ac2', 'hex')
  );
}

// Test multiple updates to same hash
{
  const h1 = crypto.createHash('sha1').update('Test123').digest('hex');
  const h2 = crypto.createHash('sha1').update('Test').update('123')
    .digest('hex');
  assert.strictEqual(h1, h2);
}

// Test hashing for binary files
{
  const fn = fixtures.path('sample.png');
  const sha1Hash = crypto.createHash('sha1');
  const fileStream = fs.createReadStream(fn);
  fileStream.on('data', function(data) {
    sha1Hash.update(data);
  });
  fileStream.on('close', common.mustCall(function() {
    assert.strictEqual(
      sha1Hash.digest('hex'),
      '22723e553129a336ad96e10f6aecdf0f45e4149e'
    );
  }));
}

// Unknown digest method should throw an error:
// https://github.com/nodejs/node-v0.x-archive/issues/2227
assert.throws(function() {
  crypto.createHash('xyzzy');
}, /^Error: Digest method not supported$/);

// Test signing and verifying
{
  const s1 = crypto.createSign('SHA1')
                 .update('Test123')
                 .sign(keyPem, 'base64');
  const s1Verified = crypto.createVerify('SHA1')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s1, 'base64');
  assert.strictEqual(s1Verified, true);

  const s2 = crypto.createSign('SHA256')
                 .update('Test123')
                 .sign(keyPem); // binary
  const s2Verified = crypto.createVerify('SHA256')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s2); // binary
  assert.strictEqual(s2Verified, true);

  const s3 = crypto.createSign('SHA1')
                 .update('Test123')
                 .sign(keyPem, 'buffer');
  const s3Verified = crypto.createVerify('SHA1')
                         .update('Test')
                         .update('123')
                         .verify(certPem, s3);
  assert.strictEqual(s3Verified, true);
}


function testCipher1(key) {
  // Test encryption and decryption
  const plaintext = 'Keep this a secret? No! Tell everyone about node.js!';
  const cipher = crypto.createCipher('aes192', key);

  // Encrypt plaintext which is in utf8 format
  // to a ciphertext which will be in hex
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  // Only use binary or hex, not base64.
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipher('aes192', key);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher2(key) {
  // Encryption and decryption with Base64.
  // Reported in https://github.com/joyent/node/issues/738
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipher('aes256', key);

  // Encrypt plaintext which is in utf8 format
  // to a ciphertext which will be in Base64
  let ciph = cipher.update(plaintext, 'utf8', 'base64');
  ciph += cipher.final('base64');

  const decipher = crypto.createDecipher('aes256', key);
  let txt = decipher.update(ciph, 'base64', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher3(key, iv) {
  // Test encryption and decryption with explicit key and iv
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher4(key, iv) {
  // Test encryption and decryption with explicit key and iv
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'buffer', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher5(key, iv) {
  // Test encryption and decryption with explicit key with aes128-wrap
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipher('id-aes128-wrap', key);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);

  const decipher = crypto.createDecipher('id-aes128-wrap', key);
  let txt = decipher.update(ciph, 'buffer', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}

if (!common.hasFipsCrypto) {
  testCipher1('MySecretKey123');
  testCipher1(Buffer.from('MySecretKey123'));

  testCipher2('0123456789abcdef');
  testCipher2(Buffer.from('0123456789abcdef'));

  testCipher5(Buffer.from('0123456789abcd0123456789'));
}

testCipher3('0123456789abcd0123456789', '12345678');
testCipher3('0123456789abcd0123456789', Buffer.from('12345678'));
testCipher3(Buffer.from('0123456789abcd0123456789'), '12345678');
testCipher3(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));

testCipher4(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));


// update() should only take buffers / strings
assert.throws(
  () => crypto.createHash('sha1').update({ foo: 'bar' }),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });


// Test Diffie-Hellman with two parties sharing a secret,
// using various encodings as we go along
{
  const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
  const dh1 = crypto.createDiffieHellman(size);
  const p1 = dh1.getPrime('buffer');
  const dh2 = crypto.createDiffieHellman(p1, 'base64');
  const key1 = dh1.generateKeys();
  const key2 = dh2.generateKeys('hex');
  const secret1 = dh1.computeSecret(key2, 'hex', 'base64');
  const secret2 = dh2.computeSecret(key1, 'latin1', 'buffer');

  assert.strictEqual(secret1, secret2.toString('base64'));

  // Create ""another dh1"" using generated keys from dh1,
  // and compute secret again
  const dh3 = crypto.createDiffieHellman(p1, 'buffer');
  const privkey1 = dh1.getPrivateKey();
  dh3.setPublicKey(key1);
  dh3.setPrivateKey(privkey1);

  assert.strictEqual(dh1.getPrime(), dh3.getPrime());
  assert.strictEqual(dh1.getGenerator(), dh3.getGenerator());
  assert.strictEqual(dh1.getPublicKey(), dh3.getPublicKey());
  assert.strictEqual(dh1.getPrivateKey(), dh3.getPrivateKey());

  const secret3 = dh3.computeSecret(key2, 'hex', 'base64');

  assert.strictEqual(secret1, secret3);

  // https://github.com/joyent/node/issues/2338
  const p = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +
            '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +
            '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +
            'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF';
  crypto.createDiffieHellman(p, 'hex');

  // Test RSA key signing/verification
  const rsaSign = crypto.createSign('SHA1');
  const rsaVerify = crypto.createVerify('SHA1');
  assert.ok(rsaSign instanceof crypto.Sign);
  assert.ok(rsaVerify instanceof crypto.Verify);

  rsaSign.update(rsaPubPem);
  const rsaSignature = rsaSign.sign(rsaKeyPem, 'hex');
  const expectedSignature = fixtures.readKey(
    'rsa_public_sha1_signature_signedby_rsa_private.sha1',
    'hex'
  );
  assert.strictEqual(rsaSignature, expectedSignature);

  rsaVerify.update(rsaPubPem);
  assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);
}

//
// Test RSA signing and verification
//
{
  const privateKey = fixtures.readKey('rsa_private_b.pem');
  const publicKey = fixtures.readKey('rsa_public_b.pem');

  const input = 'I AM THE WALRUS';

  const signature = fixtures.readKey(
    'I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256',
    'hex'
  );

  const sign = crypto.createSign('SHA256');
  sign.update(input);

  const output = sign.sign(privateKey, 'hex');
  assert.strictEqual(output, signature);

  const verify = crypto.createVerify('SHA256');
  verify.update(input);

  assert.strictEqual(verify.verify(publicKey, signature, 'hex'), true);
}


//
// Test DSA signing and verification
//
{
  const privateKey = fixtures.readKey('dsa_private.pem');
  const publicKey = fixtures.readKey('dsa_public.pem');

  const input = 'I AM THE WALRUS';

  // DSA signatures vary across runs so there is no static string to verify
  // against
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signature = sign.sign(privateKey, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(publicKey, signature, 'hex'), true);
}


//
// Test PBKDF2 with RFC 6070 test vectors (except #4)
//
function testPBKDF2(password, salt, iterations, keylen, expected) {
  const actual = crypto.pbkdf2Sync(password, salt, iterations, keylen,
                                   'sha256');
  assert.strictEqual(actual, expected);

  const cb = common.mustCall((err, actual) => {
    assert.strictEqual(actual, expected);
  });
  crypto.pbkdf2(password, salt, iterations, keylen, 'sha256', cb);
}


testPBKDF2('password', 'salt', 1, 20,
           '\x12\x0f\xb6\xcf\xfc\xf8\xb3\x2c\x43\xe7\x22\x52' +
           '\x56\xc4\xf8\x37\xa8\x65\x48\xc9');

testPBKDF2('password', 'salt', 2, 20,
           '\xae\x4d\x0c\x95\xaf\x6b\x46\xd3\x2d\x0a\xdf\xf9' +
           '\x28\xf0\x6d\xd0\x2a\x30\x3f\x8e');

testPBKDF2('password', 'salt', 4096, 20,
           '\xc5\xe4\x78\xd5\x92\x88\xc8\x41\xaa\x53\x0d\xb6' +
           '\x84\x5c\x4c\x8d\x96\x28\x93\xa0');

testPBKDF2('passwordPASSWORDpassword',
           'saltSALTsaltSALTsaltSALTsaltSALTsalt',
           4096,
           25,
           '\x34\x8c\x89\xdb\xcb\xd3\x2b\x2f\x32\xd8\x14\xb8' +
           '\x11\x6e\x84\xcf\x2b\x17\x34\x7e\xbc\x18\x00\x18\x1c');

testPBKDF2('pass\0word', 'sa\0lt', 4096, 16,
           '\x89\xb6\x9d\x05\x16\xf8\x29\x89\x3c\x69\x62\x26' +
           '\x65\x0a\x86\x87');
"
modules/internal/util/comparisons.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// deno-lint-ignore-file
import {
  isAnyArrayBuffer,
  isArrayBufferView,
  isBigIntObject,
  isBooleanObject,
  isBoxedPrimitive,
  isDate,
  isFloat32Array,
  isFloat64Array,
  isMap,
  isNativeError,
  isNumberObject,
  isRegExp,
  isSet,
  isStringObject,
  isSymbolObject,
  isTypedArray,
} from ""./types.js"";

import { Buffer } from ""buffer"";
import {
  getOwnNonIndexProperties,
  ONLY_ENUMERABLE,
  SKIP_SYMBOLS,
} from ""../../internal_binding/util"";

const valueType = {
  noIterator: 0,
  isArray: 1,
  isSet: 2,
  isMap: 3,
}

let memo;

export function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, true);
}
export function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, false);
}

function innerDeepEqual(
  val1,
  val2,
  strict,
  memos = memo,
) {
  // Basic case covered by Strict Equality Comparison
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    // Cases where the values are not objects
    // If both values are Not a Number NaN
    if (typeof val1 !== ""object"") {
      return (
        typeof val1 === ""number"" && Number.isNaN(val1) && Number.isNaN(val2)
      );
    }
    // If either value is null
    if (typeof val2 !== ""object"" || val1 === null || val2 === null) {
      return false;
    }
    // If the prototype are not the same
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    // Non strict case where values are either null or NaN
    if (val1 === null || typeof val1 !== ""object"") {
      if (val2 === null || typeof val2 !== ""object"") {
        return val1 == val2 || (Number.isNaN(val1) && Number.isNaN(val2));
      }
      return false;
    }
    if (val2 === null || typeof val2 !== ""object"") {
      return false;
    }
  }

  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);

  // prototype must be Strictly Equal
  if (
    val1Tag !== val2Tag
  ) {
    return false;
  }

  // handling when values are array
  if (Array.isArray(val1)) {
    // quick rejection cases
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keys1 = getOwnNonIndexProperties(val1, filter);
    const keys2 = getOwnNonIndexProperties(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
  } else if (val1Tag === ""[object Object]"") {
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.noIterator,
    );
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // stack may or may not be same, hence it shouldn't be compared
    if (
      // How to handle the type errors here
      (!isNativeError(val2) && !(val2 instanceof Error)) ||
      (val1).message !== (val2).message ||
      (val1).name !== (val2).name
    ) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) =>
      Object.getOwnPropertySymbols(val)
        .map((item) => item.toString())
        .toString();
    if (
      isTypedArray(val1) &&
      isTypedArray(val2) &&
      (TypedArrayPrototypeGetSymbolToStringTag(val1) !==
        TypedArrayPrototypeGetSymbolToStringTag(val2))
    ) {
      return false;
    }

    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keysVal1 = getOwnNonIndexProperties(val1, filter);
    const keysVal2 = getOwnNonIndexProperties(val2, filter);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.noIterator,
      keysVal1,
    );
  } else if (isSet(val1)) {
    if (
      !isSet(val2) ||
      (val1).size !== (val2).size
    ) {
      return false;
    }
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.isSet,
    );
  } else if (isMap(val1)) {
    if (
      !isMap(val2) ||
      (val1).size !== (val2).size
    ) {
      return false;
    }
    return keyCheck(
      val1,
      val2,
      strict,
      memos,
      valueType.isMap,
    );
  } else if (isAnyArrayBuffer(val1)) {
    if (!isAnyArrayBuffer(val2) || !areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1)) {
    if (!isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
  } else if (
    Array.isArray(val2) ||
    isArrayBufferView(val2) ||
    isSet(val2) ||
    isMap(val2) ||
    isDate(val2) ||
    isRegExp(val2) ||
    isAnyArrayBuffer(val2) ||
    isBoxedPrimitive(val2) ||
    isNativeError(val2) ||
    val2 instanceof Error
  ) {
    return false;
  }
  return keyCheck(
    val1,
    val2,
    strict,
    memos,
    valueType.noIterator,
  );
}

function keyCheck(
  val1,
  val2,
  strict,
  memos,
  iterationType,
  aKeys = [],
) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);

    // The pair must have the same number of owned properties.
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }

  // Cheap key test
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key)) {
          if (!val2.propertyIsEnumerable(key)) {
            return false;
          }
          // added toString here
          aKeys.push(key.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (
        symbolKeysA.length !== symbolKeysB.length &&
        getEnumerables(val2, symbolKeysB).length !== count
      ) {
        return false;
      }
    } else {
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (
        symbolKeysB.length !== 0 &&
        getEnumerables(val2, symbolKeysB).length !== 0
      ) {
        return false;
      }
    }
  }
  if (
    aKeys.length === 0 &&
    (iterationType === valueType.noIterator ||
      (iterationType === valueType.isArray && (val1).length === 0) ||
      (val1).size === 0)
  ) {
    return true;
  }

  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0,
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);

  const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);

  memos.val1.delete(val1);
  memos.val2.delete(val2);

  return areEq;
}

function areSimilarRegExps(a, b) {
  return a.source === b.source && a.flags === b.flags &&
    a.lastIndex === b.lastIndex;
}

// TODO(standvpmnt): add type for arguments
function areSimilarFloatArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

// TODO(standvpmnt): add type for arguments
function areSimilarTypedArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return (
    Buffer.compare(
      new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength),
      new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength),
    ) === 0
  );
}
// TODO(standvpmnt): add type for arguments
function areEqualArrayBuffers(buf1, buf2) {
  return (
    buf1.byteLength === buf2.byteLength &&
    Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0
  );
}

// TODO(standvpmnt):  this check of getOwnPropertySymbols and getOwnPropertyNames
// length is sufficient to handle the current test case, however this will fail
// to catch a scenario wherein the getOwnPropertySymbols and getOwnPropertyNames
// length is the same(will be very contrived but a possible shortcoming
function isEqualBoxedPrimitive(a, b) {
  if (
    Object.getOwnPropertyNames(a).length !==
    Object.getOwnPropertyNames(b).length
  ) {
    return false;
  }
  if (
    Object.getOwnPropertySymbols(a).length !==
    Object.getOwnPropertySymbols(b).length
  ) {
    return false;
  }
  if (isNumberObject(a)) {
    return (
      isNumberObject(b) &&
      Object.is(
        Number.prototype.valueOf.call(a),
        Number.prototype.valueOf.call(b),
      )
    );
  }
  if (isStringObject(a)) {
    return (
      isStringObject(b) &&
      (String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b))
    );
  }
  if (isBooleanObject(a)) {
    return (
      isBooleanObject(b) &&
      (Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b))
    );
  }
  if (isBigIntObject(a)) {
    return (
      isBigIntObject(b) &&
      (BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b))
    );
  }
  if (isSymbolObject(a)) {
    return (
      isSymbolObject(b) &&
      (Symbol.prototype.valueOf.call(a) ===
        Symbol.prototype.valueOf.call(b))
    );
  }
  // assert.fail(`Unknown boxed type ${val1}`);
  // return false;
  throw Error(`Unknown boxed type`);
}

function getEnumerables(val, keys) {
  return keys.filter((key) => val.propertyIsEnumerable(key));
}

function objEquiv(
  obj1,
  obj2,
  strict,
  keys,
  memos,
  iterationType,
) {
  let i = 0;

  if (iterationType === valueType.isSet) {
    if (!setEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType.isMap) {
    if (!mapEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType.isArray) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (
          !obj2.hasOwnProperty(i) ||
          !innerDeepEqual(obj1[i], obj2[i], strict, memos)
        ) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key = keys1[i];
          if (
            !obj2.hasOwnProperty(key) ||
            !innerDeepEqual(obj1[key], obj2[key], strict, memos)
          ) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }

  // Expensive test
  for (i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
      return false;
    }
  }
  return true;
}

function findLooseMatchingPrimitives(
  primitive,
) {
  switch (typeof primitive) {
    case ""undefined"":
      return null;
    case ""object"":
      return undefined;
    case ""symbol"":
      return false;
    case ""string"":
      primitive = +primitive;
    case ""number"":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}

function setMightHaveLoosePrim(
  set1,
  set2,
  primitive,
) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null) return altValue;

  return set2.has(altValue) && !set1.has(altValue);
}

function setHasEqualElement(
  set,
  val1,
  strict,
  memos,
) {
  for (const val2 of set) {
    if (innerDeepEqual(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }

  return false;
}

function setEquiv(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === ""object"" && item !== null) {
      if (set === null) {
        // What is SafeSet from primordials?
        // set = new SafeSet();
        set = new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict) return false;

      if (!setMightHaveLoosePrim(set1, set2, item)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }
      set.add(item);
    }
  }

  if (set !== null) {
    for (const item of set2) {
      if (typeof item === ""object"" && item !== null) {
        if (!setHasEqualElement(set, item, strict, memos)) return false;
      } else if (
        !strict &&
        !set1.has(item) &&
        !setHasEqualElement(set, item, strict, memos)
      ) {
        return false;
      }
    }
    return set.size === 0;
  }

  return true;
}

// TODO(standvpmnt): add types for argument
function mapMightHaveLoosePrimitive(
  map1,
  map2,
  primitive,
  item,
  memos,
) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (
    (curB === undefined && !map2.has(altValue)) ||
    !innerDeepEqual(item, curB, false, memo)
  ) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}

function mapEquiv(map1, map2, strict, memos) {
  let set = null;

  for (const { 0: key, 1: item1 } of map1) {
    if (typeof key === ""object"" && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      const item2 = map2.get(key);
      if (
        (
          (item2 === undefined && !map2.has(key)) ||
          !innerDeepEqual(item1, item2, strict, memos)
        )
      ) {
        if (strict) return false;
        if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }

  if (set !== null) {
    for (const { 0: key, 1: item } of map2) {
      if (typeof key === ""object"" && key !== null) {
        if (!mapHasEqualEntry(set, map1, key, item, strict, memos)) {
          return false;
        }
      } else if (
        !strict && (!map1.has(key) ||
          !innerDeepEqual(map1.get(key), item, false, memos)) &&
        !mapHasEqualEntry(set, map1, key, item, false, memos)
      ) {
        return false;
      }
    }
    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(
  set,
  map,
  key1,
  item1,
  strict,
  memos
) {
  for (const key2 of set) {
    if (
      innerDeepEqual(key1, key2, strict, memos) &&
      innerDeepEqual(item1, map.get(key2), strict, memos)
    ) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
"
modules/events.js,"use strict';

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a ""clean"" empty
// object (tested with v8 v4.9).

const kRejection = Symbol.for(""nodejs.rejection"");


function EventHandlers() { }
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

const captureRejectionSymbol = EventEmitter.captureRejectionSymbol;
EventEmitter.captureRejectionSymbol = kRejection;

export default EventEmitter;
export { EventEmitter, captureRejectionSymbol };

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function () {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('""n"" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified ""error"" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified ""error"" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('""listener"" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === ""newListener""! Before
    // adding it to the listeners, first emit ""newListener"".
    if (events.newListener) {
      target.emit('newListener', type,
        listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
        [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
          existing.length + ' ' + type + ' listeners added. ' +
          'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
  function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('""listener"" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
  function prependOnceListener(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('""listener"" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
  function removeListener(type, listener) {
    var list, events, position, i, originalListener;

    if (typeof listener !== 'function')
      throw new TypeError('""listener"" argument must be a function');

    events = this._events;
    if (!events)
      return this;

    list = events[type];
    if (!list)
      return this;

    if (list === listener || (list.listener && list.listener === listener)) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else {
        delete events[type];
        if (events.removeListener)
          this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length; i-- > 0;) {
        if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0)
        return this;

      if (list.length === 1) {
        list[0] = undefined;
        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }

      if (events.removeListener)
        this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

EventEmitter.prototype.removeAllListeners =
  function removeAllListeners(type) {
    var listeners, events;

    events = this._events;
    if (!events)
      return this;

    // not listening for removeListener, no need to emit
    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else
          delete events[type];
      }
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      var keys = Object.keys(events);
      for (var i = 0, key; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }

    return this;
  };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/**
 * Creates a `Promise` that is fulfilled when the emitter
 * emits the given event.
 * @param {EventEmitter} emitter
 * @param {string} name
 * @param {{ signal: AbortSignal; }} [options]
 * @returns {Promise}
 */
export async function once(emitter, name, options = kEmptyObject) {
  const signal = options?.signal;
  validateAbortSignal(signal, 'options.signal');
  if (signal?.aborted)
    throw new AbortError(undefined, { cause: signal?.reason });
  return new Promise((resolve, reject) => {
    const errorListener = (err) => {
      emitter.removeListener(name, resolver);
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);
      }
      reject(err);
    };
    const resolver = (...args) => {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, 'abort', abortListener);
      }
      resolve(args);
    };
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error' && typeof emitter.once === 'function') {
      // EventTarget does not have `error` event semantics like Node
      // EventEmitters, we listen to `error` events only on EventEmitters.
      emitter.once('error', errorListener);
    }
    function abortListener() {
      eventTargetAgnosticRemoveListener(emitter, name, resolver);
      eventTargetAgnosticRemoveListener(emitter, 'error', errorListener);
      reject(new AbortError(undefined, { cause: signal?.reason }));
    }
    if (signal != null) {
      eventTargetAgnosticAddListener(
        signal, 'abort', abortListener, { once: true });
    }
  });
}"
src/internal_module/tensorflow_module.rs,"use crate::*;

/// reference https://github.com/second-state/wasmedge_tensorflow_interface
mod wasmedge_tensorflow {
    // wasmedge_tensorflow host functions.
    #[link(wasm_import_module = ""wasmedge_tensorflow"")]
    extern ""C"" {
        pub fn wasmedge_tensorflow_create_session(model_buf: *const u8, model_buf_len: u32) -> u64;
        pub fn wasmedge_tensorflow_delete_session(context: u64);
        pub fn wasmedge_tensorflow_run_session(context: u64) -> u32;
        pub fn wasmedge_tensorflow_get_output_tensor(
            context: u64,
            output_name: *const u8,
            output_name_len: u32,
            index: u32,
        ) -> u64;
        pub fn wasmedge_tensorflow_get_tensor_len(tensor_ptr: u64) -> u32;
        pub fn wasmedge_tensorflow_get_tensor_data(tensor_ptr: u64, buf: *mut u8);
        pub fn wasmedge_tensorflow_append_input(
            context: u64,
            input_name: *const u8,
            input_name_len: u32,
            index: u32,
            dim_vec: *const u8,
            dim_cnt: u32,
            data_type: u32,
            tensor_buf: *const u8,
            tensor_buf_len: u32,
        );
        pub fn wasmedge_tensorflow_append_output(
            context: u64,
            output_name: *const u8,
            output_name_len: u32,
            index: u32,
        );
        pub fn wasmedge_tensorflow_clear_input(context: u64);
        pub fn wasmedge_tensorflow_clear_output(context: u64);
    }

    // wasmedge_tensorflowlite host functions.
    #[link(wasm_import_module = ""wasmedge_tensorflowlite"")]
    extern ""C"" {
        pub fn wasmedge_tensorflowlite_create_session(
            model_buf: *const u8,
            model_buf_len: u32,
        ) -> u64;
        pub fn wasmedge_tensorflowlite_delete_session(context: u64);
        pub fn wasmedge_tensorflowlite_run_session(context: u64) -> u32;
        pub fn wasmedge_tensorflowlite_get_output_tensor(
            context: u64,
            output_name: *const u8,
            output_name_len: u32,
        ) -> u64;
        pub fn wasmedge_tensorflowlite_get_tensor_len(tensor_ptr: u64) -> u32;
        pub fn wasmedge_tensorflowlite_get_tensor_data(tensor_ptr: u64, buf: *mut u8);
        pub fn wasmedge_tensorflowlite_append_input(
            context: u64,
            input_name: *const u8,
            input_name_len: u32,
            tensor_buf: *const u8,
            tensor_buf_len: u32,
        );
    }

    // wasmedge_image host helper functions.
    #[link(wasm_import_module = ""wasmedge_image"")]
    extern ""C"" {
        pub fn wasmedge_image_load_jpg_to_rgb8(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
        pub fn wasmedge_image_load_jpg_to_bgr8(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
        pub fn wasmedge_image_load_jpg_to_rgb32f(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
        pub fn wasmedge_image_load_jpg_to_bgr32f(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
        pub fn wasmedge_image_load_png_to_rgb8(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
        pub fn wasmedge_image_load_png_to_bgr8(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
        pub fn wasmedge_image_load_png_to_rgb32f(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
        pub fn wasmedge_image_load_png_to_bgr32f(
            img_buf: *const u8,
            img_buf_len: u32,
            img_width: u32,
            img_height: u32,
            dst_buf: *mut u8,
        ) -> u32;
    }
}
//---------------------

mod tensorflow {
    use super::wasmedge_tensorflow::*;
    use crate::*;
    use std::path::Path;

    pub enum InputDataType {
        F32 = 1,
        F64 = 2,
        I32 = 3,
        U8 = 4,
        U16 = 17,
        U32 = 22,
        U64 = 23,
        I16 = 5,
        I8 = 6,
        I64 = 9,
        Bool = 10,
    }

    pub struct TensorflowSession {
        context: u64,
        data: Vec<u8>,
    }

    impl Drop for TensorflowSession {
        fn drop(&mut self) {
            unsafe {
                wasmedge_tensorflow_delete_session(self.context);
            }
        }
    }

    impl TensorflowSession {
        pub fn new_from_path<T: AsRef<Path>>(path: T) -> Result<Self, String> {
            let data = std::fs::read(path).map_err(|e| e.to_string())?;
            let context = unsafe {
                wasmedge_tensorflow_create_session(
                    data.as_slice().as_ptr().cast(),
                    data.len() as u32,
                )
            };
            Ok(TensorflowSession { context, data })
        }

        pub unsafe fn add_input(
            &mut self,
            name: &str,
            tensor_buf: *const u8,
            tensor_buf_len: u32,
            data_type: u32,
            shape: &[i64],
        ) {
            let mut idx: u32 = 0;

            let name_pair: Vec<&str> = name.split("":"").collect();
            if name_pair.len() > 1 {
                idx = name_pair[1].parse().unwrap();
            }
            let input_name = make_c_string(name_pair[0]);
            wasmedge_tensorflow_append_input(
                self.context,
                input_name.as_ptr() as *const u8,
                input_name.as_bytes().len() as u32,
                idx,
                shape.as_ptr() as *const u8,
                shape.len() as u32,
                data_type,
                tensor_buf,
                tensor_buf_len,
            );
        }

        pub unsafe fn add_output(&mut self, name: &str) {
            let name_pair: Vec<&str> = name.split("":"").collect();
            let output_name = make_c_string(name_pair[0]);
            let mut idx = 0;
            if name_pair.len() > 1 {
                idx = name_pair[1].parse().unwrap()
            };
            wasmedge_tensorflow_append_output(
                self.context,
                output_name.as_ptr() as *const u8,
                output_name.as_bytes().len() as u32,
                idx,
            );
        }

        pub unsafe fn run(&mut self) {
            wasmedge_tensorflow_run_session(self.context);
        }

        pub unsafe fn get_output(&self, name: &str) -> Vec<u8> {
            // Parse name and operation index.
            let name_pair: Vec<&str> = name.split("":"").collect();
            let output_name = make_c_string(name_pair[0]);
            let mut idx = 0;
            if name_pair.len() > 1 {
                idx = name_pair[1].parse().unwrap()
            };

            // Get tensor data.
            let tensor = wasmedge_tensorflow_get_output_tensor(
                self.context,
                output_name.as_ptr() as *const u8,
                output_name.as_bytes().len() as u32,
                idx,
            );
            let buf_len = wasmedge_tensorflow_get_tensor_len(tensor) as usize;
            if buf_len == 0 {
                return Vec::new();
            }
            let mut data = vec![0u8; buf_len];
            wasmedge_tensorflow_get_tensor_data(tensor, data.as_mut_ptr() as *mut u8);
            return data;
        }

        pub unsafe fn clear_input(&mut self) {
            wasmedge_tensorflow_clear_input(self.context);
        }

        pub unsafe fn clear_output(&mut self) {
            wasmedge_tensorflow_clear_output(self.context);
        }
    }

    impl TensorflowSession {
        fn js_add_input_8u(
            &mut self,
            _: &mut JsObject,
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> JsValue {
            let name = if let Some(JsValue::String(s)) = argv.get(0) {
                s.to_string()
            } else {
                return ctx.throw_type_error(""'name' must be of type string"").into();
            };

            let tensor_buf = if let Some(JsValue::ArrayBuffer(buf)) = argv.get(1) {
                buf.as_ref()
            } else {
                return ctx
                    .throw_type_error(""'tensor_buf' must be of type buffer"")
                    .into();
            };

            let shape = if let Some(JsValue::Array(arr)) = argv.get(2) {
                match arr.to_vec() {
                    Ok(a) => a,
                    Err(e) => return e.into(),
                }
            } else {
                return ctx.throw_type_error(""'shape' must be of type array"").into();
            };

            let mut shape_arr = vec![];

            for i in shape {
                let v = match i {
                    JsValue::Int(i) => i as i64,
                    JsValue::Float(i) => i as i64,
                    _ => {
                        return ctx
                            .throw_type_error(""'shape' must be of type number array"")
                            .into()
                    }
                };
                shape_arr.push(v);
            }

            unsafe {
                self.add_input(
                    name.as_str(),
                    tensor_buf.as_ptr(),
                    tensor_buf.len() as u32,
                    InputDataType::U8 as u32,
                    shape_arr.as_slice(),
                );
            }
            JsValue::UnDefined
        }

        fn js_add_input_32f(
            &mut self,
            _: &mut JsObject,
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> JsValue {
            let name = if let Some(JsValue::String(s)) = argv.get(0) {
                s.to_string()
            } else {
                return ctx.throw_type_error(""'name' must be of type string"").into();
            };

            let tensor_buf = if let Some(JsValue::ArrayBuffer(buf)) = argv.get(1) {
                buf.as_ref()
            } else {
                return ctx
                    .throw_type_error(""'tensor_buf' must be of type buffer"")
                    .into();
            };

            let shape = if let Some(JsValue::Array(arr)) = argv.get(2) {
                match arr.to_vec() {
                    Ok(a) => a,
                    Err(e) => return e.into(),
                }
            } else {
                return ctx.throw_type_error(""'shape' must be of type array"").into();
            };

            let mut shape_arr = vec![];

            for i in shape {
                let v = match i {
                    JsValue::Int(i) => i as i64,
                    JsValue::Float(i) => i as i64,
                    _ => {
                        return ctx
                            .throw_type_error(""'shape' must be of type number array"")
                            .into()
                    }
                };
                shape_arr.push(v);
            }

            unsafe {
                self.add_input(
                    name.as_str(),
                    tensor_buf.as_ptr(),
                    tensor_buf.len() as u32,
                    InputDataType::F32 as u32,
                    shape_arr.as_slice(),
                );
            }
            JsValue::UnDefined
        }

        fn js_add_output(
            &mut self,
            _: &mut JsObject,
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> JsValue {
            let name = if let Some(JsValue::String(s)) = argv.get(0) {
                s.to_string()
            } else {
                return ctx.throw_type_error(""'name' must be of type string"").into();
            };

            unsafe {
                self.add_output(name.as_str());
            }
            JsValue::UnDefined
        }

        fn js_run(&mut self, _: &mut JsObject, _ctx: &mut Context, _argv: &[JsValue]) -> JsValue {
            unsafe { self.run() }
            JsValue::UnDefined
        }

        fn js_get_output(
            &mut self,
            _: &mut JsObject,
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> JsValue {
            let name = if let Some(JsValue::String(s)) = argv.get(0) {
                s.to_string()
            } else {
                return ctx.throw_type_error(""'name' must be of type string"").into();
            };
            let data = unsafe { self.get_output(name.as_str()) };

            ctx.new_array_buffer(data.as_slice()).into()
        }

        fn js_clear_output(
            &mut self,
            _: &mut JsObject,
            _ctx: &mut Context,
            _argv: &[JsValue],
        ) -> JsValue {
            unsafe { self.clear_output() }
            JsValue::UnDefined
        }

        fn js_clear_input(
            &mut self,
            _: &mut JsObject,
            _ctx: &mut Context,
            _argv: &[JsValue],
        ) -> JsValue {
            unsafe { self.clear_input() }
            JsValue::UnDefined
        }
    }

    impl JsClassDef for TensorflowSession {
        type RefType = TensorflowSession;
        const CLASS_NAME: &'static str = ""TensorflowSession\0"";
        const CONSTRUCTOR_ARGC: u8 = 1;

        const FIELDS: &'static [JsClassField<Self::RefType>] = &[];
        const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
            (""add_input_8u"", 3, Self::js_add_input_8u),
            (""add_input_32f"", 3, Self::js_add_input_32f),
            (""add_output"", 1, Self::js_add_output),
            (""run"", 0, Self::js_run),
            (""get_output"", 1, Self::js_get_output),
            (""clear_output"", 0, Self::js_clear_output),
            (""clear_input"", 0, Self::js_clear_input),
        ];

        unsafe fn mut_class_id_ptr() -> &'static mut u32 {
            static mut CLASS_ID: u32 = 0;
            &mut CLASS_ID
        }

        fn constructor_fn(
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> Result<TensorflowSession, JsValue> {
            match argv.get(0).ok_or(JsValue::UnDefined)? {
                JsValue::String(path) => {
                    let path = path.to_string();
                    let session = TensorflowSession::new_from_path(path)
                        .map_err(|e| ctx.throw_internal_type_error(e.as_str()))?;
                    Ok(session)
                }
                _ => Err(JsValue::UnDefined),
            }
        }
    }

    struct TensorflowModDef;
    impl ModuleInit for TensorflowModDef {
        fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
            let ctor = register_class::<TensorflowSession>(ctx);
            m.add_export(TensorflowSession::CLASS_NAME, ctor)
        }
    }

    pub fn init_module_tensorflow(ctx: &mut Context) {
        ctx.register_module(
            ""tensorflow\0"",
            TensorflowModDef,
            &[TensorflowSession::CLASS_NAME],
        )
    }
}

mod tensorflow_lite {
    use super::{tensorflow, wasmedge_tensorflow::*};
    use crate::*;
    use std::path::Path;

    struct TensorflowLiteSession {
        context: u64,
        data: Vec<u8>,
    }

    impl Drop for TensorflowLiteSession {
        fn drop(&mut self) {
            unsafe {
                wasmedge_tensorflowlite_delete_session(self.context);
            }
        }
    }

    impl TensorflowLiteSession {
        pub fn new_from_path<T: AsRef<Path>>(path: T) -> Result<Self, String> {
            let data = std::fs::read(path).map_err(|e| e.to_string())?;
            let context = unsafe {
                wasmedge_tensorflowlite_create_session(
                    data.as_slice().as_ptr().cast(),
                    data.len() as u32,
                )
            };
            Ok(TensorflowLiteSession { context, data })
        }

        pub unsafe fn add_input(&mut self, name: &str, tensor_buf: *const u8, tensor_buf_len: u32) {
            let input_name = make_c_string(name);
            wasmedge_tensorflowlite_append_input(
                self.context,
                input_name.as_ptr() as *const u8,
                input_name.as_bytes().len() as u32,
                tensor_buf as *const u8,
                tensor_buf_len,
            );
        }

        pub unsafe fn run(&mut self) {
            wasmedge_tensorflowlite_run_session(self.context);
        }

        pub unsafe fn get_output(&self, name: &str) -> Vec<u8> {
            // Parse name and operation index.
            let output_name = make_c_string(name);

            // Get tensor data.
            let tensor = wasmedge_tensorflowlite_get_output_tensor(
                self.context,
                output_name.as_ptr() as *const u8,
                output_name.as_bytes().len() as u32,
            );
            let buf_len = wasmedge_tensorflowlite_get_tensor_len(tensor) as usize;
            if buf_len == 0 {
                return Vec::new();
            }
            let mut data = vec![0u8; buf_len];
            wasmedge_tensorflowlite_get_tensor_data(tensor, data.as_mut_ptr() as *mut u8);
            return data;
        }
    }

    impl TensorflowLiteSession {
        pub fn js_add_input(
            &mut self,
            _: &mut JsObject,
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> JsValue {
            let name = if let Some(JsValue::String(s)) = argv.get(0) {
                s.to_string()
            } else {
                return ctx.throw_type_error(""'name' must be of type string"").into();
            };

            let tensor_buf = if let Some(JsValue::ArrayBuffer(buf)) = argv.get(1) {
                buf.as_ref()
            } else {
                return ctx
                    .throw_type_error(""'tensor_buf' must be of type buffer"")
                    .into();
            };

            unsafe {
                self.add_input(name.as_str(), tensor_buf.as_ptr(), tensor_buf.len() as u32);
            }
            JsValue::UnDefined
        }

        pub fn js_run(
            &mut self,
            _: &mut JsObject,
            _ctx: &mut Context,
            _argv: &[JsValue],
        ) -> JsValue {
            unsafe { self.run() }
            JsValue::UnDefined
        }

        pub fn js_get_output(
            &mut self,
            _: &mut JsObject,
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> JsValue {
            let name = if let Some(JsValue::String(s)) = argv.get(0) {
                s.to_string()
            } else {
                return ctx.throw_type_error(""'name' must be of type string"").into();
            };
            let data = unsafe { self.get_output(name.as_str()) };

            ctx.new_array_buffer(data.as_slice()).into()
        }
    }

    impl JsClassDef for TensorflowLiteSession {
        type RefType = TensorflowLiteSession;
        const CLASS_NAME: &'static str = ""TensorflowLiteSession\0"";
        const CONSTRUCTOR_ARGC: u8 = 1;

        const FIELDS: &'static [JsClassField<Self::RefType>] = &[];
        const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
            (""add_input"", 2, Self::js_add_input),
            (""run"", 0, Self::js_run),
            (""get_output"", 1, Self::js_get_output),
        ];

        unsafe fn mut_class_id_ptr() -> &'static mut u32 {
            static mut CLASS_ID: u32 = 0;
            &mut CLASS_ID
        }

        fn constructor_fn(
            ctx: &mut Context,
            argv: &[JsValue],
        ) -> Result<TensorflowLiteSession, JsValue> {
            match argv.get(0).ok_or(JsValue::UnDefined)? {
                JsValue::String(path) => {
                    let path = path.to_string();
                    let session = TensorflowLiteSession::new_from_path(path)
                        .map_err(|e| ctx.throw_internal_type_error(e.as_str()))?;
                    Ok(session)
                }
                _ => Err(JsValue::UnDefined),
            }
        }
    }

    struct TensorflowModDef;
    impl ModuleInit for TensorflowModDef {
        fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
            let ctor = register_class::<TensorflowLiteSession>(ctx);
            m.add_export(TensorflowLiteSession::CLASS_NAME, ctor)
        }
    }

    pub fn init_module_tensorflow_lite(ctx: &mut Context) {
        ctx.register_module(
            ""tensorflow_lite\0"",
            TensorflowModDef,
            &[TensorflowLiteSession::CLASS_NAME],
        )
    }
}

pub use tensorflow::init_module_tensorflow;
pub use tensorflow_lite::init_module_tensorflow_lite;
"
test/fs/test-fs-realpath.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';

if (!common.isMainThread)
  common.skip('process.chdir is not available in Workers');

import assert from 'assert';
import fs from 'fs';
import path from 'path';
let async_completed = 0;
let async_expected = 0;
const unlink = [];
const skipSymlinks = !common.canCreateSymLink();
const tmpDir = tmpdir.path;

tmpdir.refresh();

let root = '/';
let assertEqualPath = assert.strictEqual;
if (common.isWindows) {
  // Something like ""C:\\""
  root = process.cwd().substr(0, 3);
  assertEqualPath = function(path_left, path_right, message) {
    assert
      .strictEqual(path_left.toLowerCase(), path_right.toLowerCase(), message);
  };
}

process.nextTick(runTest);

function tmp(p) {
  return path.join(tmpDir, p);
}

const targetsAbsDir = path.join(tmpDir, 'targets');
const tmpAbsDir = tmpDir;

// Set up targetsAbsDir and expected subdirectories
fs.mkdirSync(targetsAbsDir);
fs.mkdirSync(path.join(targetsAbsDir, 'nested-index'));
fs.mkdirSync(path.join(targetsAbsDir, 'nested-index', 'one'));
fs.mkdirSync(path.join(targetsAbsDir, 'nested-index', 'two'));

function asynctest(testBlock, args, callback, assertBlock) {
  async_expected++;
  testBlock.apply(testBlock, args.concat(function(err) {
    let ignoreError = false;
    if (assertBlock) {
      try {
        ignoreError = assertBlock.apply(assertBlock, arguments);
      } catch (e) {
        err = e;
      }
    }
    async_completed++;
    callback(ignoreError ? null : err);
  }));
}

// sub-tests:
function test_simple_error_callback(realpath, realpathSync, cb) {
  realpath('/this/path/does/not/exist', common.mustCall(function(err, s) {
    assert(err);
    assert(!s);
    cb();
  }));
}

function test_simple_error_cb_with_null_options(realpath, realpathSync, cb) {
  realpath('/this/path/does/not/exist', null, common.mustCall(function(err, s) {
    assert(err);
    assert(!s);
    cb();
  }));
}

function test_simple_relative_symlink(realpath, realpathSync, callback) {
  console.log('test_simple_relative_symlink');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const entry = `${tmpDir}/symlink`;
  const expected = `${tmpDir}/cycles/root.js`;
  [
    [entry, `../${path.basename(tmpDir)}/cycles/root.js`],
  ].forEach(function(t) {
    try { fs.unlinkSync(t[0]); } catch {
      // Continue regardless of error.
    }
    console.log('fs.symlinkSync(%j, %j, %j)', t[1], t[0], 'file');
    fs.symlinkSync(t[1], t[0], 'file');
    unlink.push(t[0]);
  });
  const result = realpathSync(entry);
  assertEqualPath(result, path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_simple_absolute_symlink(realpath, realpathSync, callback) {
  console.log('test_simple_absolute_symlink');

  // This one should still run, even if skipSymlinks is set,
  // because it uses a junction.
  const type = skipSymlinks ? 'junction' : 'dir';

  console.log('using type=%s', type);

  const entry = `${tmpAbsDir}/symlink`;
  const expected = fixtures.path('nested-index', 'one');
  [
    [entry, expected],
  ].forEach(function(t) {
    try { fs.unlinkSync(t[0]); } catch {
      // Continue regardless of error.
    }
    console.error('fs.symlinkSync(%j, %j, %j)', t[1], t[0], type);
    fs.symlinkSync(t[1], t[0], type);
    unlink.push(t[0]);
  });
  const result = realpathSync(entry);
  assertEqualPath(result, path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_deep_relative_file_symlink(realpath, realpathSync, callback) {
  console.log('test_deep_relative_file_symlink');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }

  const expected = fixtures.path('cycles', 'root.js');
  const linkData1 = path
                      .relative(path.join(targetsAbsDir, 'nested-index', 'one'),
                                expected);
  const linkPath1 = path.join(targetsAbsDir,
                              'nested-index', 'one', 'symlink1.js');
  try { fs.unlinkSync(linkPath1); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData1, linkPath1, 'file');

  const linkData2 = '../one/symlink1.js';
  const entry = path.join(targetsAbsDir,
                          'nested-index', 'two', 'symlink1-b.js');
  try { fs.unlinkSync(entry); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData2, entry, 'file');
  unlink.push(linkPath1);
  unlink.push(entry);

  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_deep_relative_dir_symlink(realpath, realpathSync, callback) {
  console.log('test_deep_relative_dir_symlink');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const expected = fixtures.path('cycles', 'folder');
  const path1b = path.join(targetsAbsDir, 'nested-index', 'one');
  const linkPath1b = path.join(path1b, 'symlink1-dir');
  const linkData1b = path.relative(path1b, expected);
  try { fs.unlinkSync(linkPath1b); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData1b, linkPath1b, 'dir');

  const linkData2b = '../one/symlink1-dir';
  const entry = path.join(targetsAbsDir,
                          'nested-index', 'two', 'symlink12-dir');
  try { fs.unlinkSync(entry); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(linkData2b, entry, 'dir');
  unlink.push(linkPath1b);
  unlink.push(entry);

  assertEqualPath(realpathSync(entry), path.resolve(expected));

  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
  });
}

function test_cyclic_link_protection(realpath, realpathSync, callback) {
  console.log('test_cyclic_link_protection');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const entry = path.join(tmpDir, '/cycles/realpath-3a');
  [
    [entry, '../cycles/realpath-3b'],
    [path.join(tmpDir, '/cycles/realpath-3b'), '../cycles/realpath-3c'],
    [path.join(tmpDir, '/cycles/realpath-3c'), '../cycles/realpath-3a'],
  ].forEach(function(t) {
    try { fs.unlinkSync(t[0]); } catch {
      // Continue regardless of error.
    }
    fs.symlinkSync(t[1], t[0], 'dir');
    unlink.push(t[0]);
  });
  assert.throws(() => {
    realpathSync(entry);
  }, { code: 'ELOOP', name: 'Error' });
  asynctest(
    realpath, [entry], callback, common.mustCall(function(err, result) {
      assert.strictEqual(err.path, entry);
      assert.strictEqual(result, undefined);
      return true;
    }));
}

function test_cyclic_link_overprotection(realpath, realpathSync, callback) {
  console.log('test_cyclic_link_overprotection');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }
  const cycles = `${tmpDir}/cycles`;
  const expected = realpathSync(cycles);
  const folder = `${cycles}/folder`;
  const link = `${folder}/cycles`;
  let testPath = cycles;
  testPath += '/folder/cycles'.repeat(10);
  try { fs.unlinkSync(link); } catch {
    // Continue regardless of error.
  }
  fs.symlinkSync(cycles, link, 'dir');
  unlink.push(link);
  assertEqualPath(realpathSync(testPath), path.resolve(expected));
  asynctest(realpath, [testPath], callback, function(er, res) {
    assertEqualPath(res, path.resolve(expected));
  });
}

function test_relative_input_cwd(realpath, realpathSync, callback) {
  console.log('test_relative_input_cwd');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }

  // We need to calculate the relative path to the tmp dir from cwd
  const entrydir = process.cwd();
  const entry = path.relative(entrydir,
                              path.join(`${tmpDir}/cycles/realpath-3a`));
  const expected = `${tmpDir}/cycles/root.js`;
  [
    [entry, '../cycles/realpath-3b'],
    [`${tmpDir}/cycles/realpath-3b`, '../cycles/realpath-3c'],
    [`${tmpDir}/cycles/realpath-3c`, 'root.js'],
  ].forEach(function(t) {
    const fn = t[0];
    console.error('fn=%j', fn);
    try { fs.unlinkSync(fn); } catch {
      // Continue regardless of error.
    }
    const b = path.basename(t[1]);
    const type = (b === 'root.js' ? 'file' : 'dir');
    console.log('fs.symlinkSync(%j, %j, %j)', t[1], fn, type);
    fs.symlinkSync(t[1], fn, 'file');
    unlink.push(fn);
  });

  const origcwd = process.cwd();
  process.chdir(entrydir);
  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    process.chdir(origcwd);
    assertEqualPath(result, path.resolve(expected));
    return true;
  });
}

function test_deep_symlink_mix(realpath, realpathSync, callback) {
  console.log('test_deep_symlink_mix');
  if (common.isWindows) {
    // This one is a mix of files and directories, and it's quite tricky
    // to get the file/dir links sorted out correctly.
    common.printSkipMessage('symlink test (no privs)');
    return callback();
  }

  // /tmp/node-test-realpath-f1 -> $tmpDir/node-test-realpath-d1/foo
  // /tmp/node-test-realpath-d1 -> $tmpDir/node-test-realpath-d2
  // /tmp/node-test-realpath-d2/foo -> $tmpDir/node-test-realpath-f2
  // /tmp/node-test-realpath-f2
  //   -> $tmpDir/targets/nested-index/one/realpath-c
  // $tmpDir/targets/nested-index/one/realpath-c
  //   -> $tmpDir/targets/nested-index/two/realpath-c
  // $tmpDir/targets/nested-index/two/realpath-c -> $tmpDir/cycles/root.js
  // $tmpDir/targets/cycles/root.js (hard)

  const entry = tmp('node-test-realpath-f1');
  try { fs.unlinkSync(tmp('node-test-realpath-d2/foo')); } catch {
    // Continue regardless of error.
  }
  try { fs.rmdirSync(tmp('node-test-realpath-d2')); } catch {
    // Continue regardless of error.
  }
  fs.mkdirSync(tmp('node-test-realpath-d2'), 0o700);
  try {
    [
      [entry, `${tmpDir}/node-test-realpath-d1/foo`],
      [tmp('node-test-realpath-d1'),
       `${tmpDir}/node-test-realpath-d2`],
      [tmp('node-test-realpath-d2/foo'), '../node-test-realpath-f2'],
      [tmp('node-test-realpath-f2'),
       `${targetsAbsDir}/nested-index/one/realpath-c`],
      [`${targetsAbsDir}/nested-index/one/realpath-c`,
       `${targetsAbsDir}/nested-index/two/realpath-c`],
      [`${targetsAbsDir}/nested-index/two/realpath-c`,
       `${tmpDir}/cycles/root.js`],
    ].forEach(function(t) {
      try { fs.unlinkSync(t[0]); } catch {
        // Continue regardless of error.
      }
      fs.symlinkSync(t[1], t[0]);
      unlink.push(t[0]);
    });
  } finally {
    unlink.push(tmp('node-test-realpath-d2'));
  }
  const expected = `${tmpAbsDir}/cycles/root.js`;
  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    assertEqualPath(result, path.resolve(expected));
    return true;
  });
}

function test_non_symlinks(realpath, realpathSync, callback) {
  console.log('test_non_symlinks');
  const entrydir = path.dirname(tmpAbsDir);
  const entry = `${tmpAbsDir.substr(entrydir.length + 1)}/cycles/root.js`;
  const expected = `${tmpAbsDir}/cycles/root.js`;
  const origcwd = process.cwd();
  process.chdir(entrydir);
  assertEqualPath(realpathSync(entry), path.resolve(expected));
  asynctest(realpath, [entry], callback, function(err, result) {
    process.chdir(origcwd);
    assertEqualPath(result, path.resolve(expected));
    return true;
  });
}

const upone = path.join(process.cwd(), '..');
function test_escape_cwd(realpath, realpathSync, cb) {
  console.log('test_escape_cwd');
  asynctest(realpath, ['..'], cb, function(er, uponeActual) {
    assertEqualPath(
      upone, uponeActual,
      `realpath("".."") expected: ${path.resolve(upone)} actual:${uponeActual}`);
  });
}

function test_upone_actual(realpath, realpathSync, cb) {
  console.log('test_upone_actual');
  const uponeActual = realpathSync('..');
  assertEqualPath(upone, uponeActual);
  cb();
}

import tmpdir from '../common/tmpdir';

// Going up with .. multiple times
// .
// `-- a/
//     |-- b/
//     |   `-- e -> ..
//     `-- d -> ..
// realpath(a/b/e/d/a/b/e/d/a) ==> a
function test_up_multiple(realpath, realpathSync, cb) {
  console.error('test_up_multiple');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return cb();
  }
  
  tmpdir.refresh();
  fs.mkdirSync(tmp('a'), 0o755);
  fs.mkdirSync(tmp('a/b'), 0o755);
  fs.symlinkSync('..', tmp('a/d'), 'dir');
  unlink.push(tmp('a/d'));
  fs.symlinkSync('..', tmp('a/b/e'), 'dir');
  unlink.push(tmp('a/b/e'));

  const abedabed = tmp('abedabed'.split('').join('/'));
  const abedabed_real = tmp('');

  const abedabeda = tmp('abedabeda'.split('').join('/'));
  const abedabeda_real = tmp('a');

  assertEqualPath(realpathSync(abedabeda), abedabeda_real);
  assertEqualPath(realpathSync(abedabed), abedabed_real);

  realpath(abedabeda, function(er, real) {
    assert.ifError(er);
    assertEqualPath(abedabeda_real, real);
    realpath(abedabed, function(er, real) {
      assert.ifError(er);
      assertEqualPath(abedabed_real, real);
      cb();
    });
  });
}


// Going up with .. multiple times with options = null
// .
// `-- a/
//     |-- b/
//     |   `-- e -> ..
//     `-- d -> ..
// realpath(a/b/e/d/a/b/e/d/a) ==> a
function test_up_multiple_with_null_options(realpath, realpathSync, cb) {
  console.error('test_up_multiple');
  if (skipSymlinks) {
    common.printSkipMessage('symlink test (no privs)');
    return cb();
  }
  tmpdir.refresh();
  fs.mkdirSync(tmp('a'), 0o755);
  fs.mkdirSync(tmp('a/b'), 0o755);
  fs.symlinkSync('..', tmp('a/d'), 'dir');
  unlink.push(tmp('a/d'));
  fs.symlinkSync('..', tmp('a/b/e'), 'dir');
  unlink.push(tmp('a/b/e'));

  const abedabed = tmp('abedabed'.split('').join('/'));
  const abedabed_real = tmp('');

  const abedabeda = tmp('abedabeda'.split('').join('/'));
  const abedabeda_real = tmp('a');

  assertEqualPath(realpathSync(abedabeda), abedabeda_real);
  assertEqualPath(realpathSync(abedabed), abedabed_real);

  realpath(abedabeda, null, function(er, real) {
    assert.ifError(er);
    assertEqualPath(abedabeda_real, real);
    realpath(abedabed, null, function(er, real) {
      assert.ifError(er);
      assertEqualPath(abedabed_real, real);
      cb();
    });
  });
}

// Absolute symlinks with children.
// .
// `-- a/
//     |-- b/
//     |   `-- c/
//     |       `-- x.txt
//     `-- link -> /tmp/node-test-realpath-abs-kids/a/b/
// realpath(root+'/a/link/c/x.txt') ==> root+'/a/b/c/x.txt'
function test_abs_with_kids(realpath, realpathSync, cb) {
  console.log('test_abs_with_kids');

  // This one should still run, even if skipSymlinks is set,
  // because it uses a junction.
  const type = skipSymlinks ? 'junction' : 'dir';

  console.log('using type=%s', type);

  const root = `${tmpAbsDir}/node-test-realpath-abs-kids`;
  function cleanup() {
    ['/a/b/c/x.txt',
     '/a/link',
    ].forEach(function(file) {
      try { fs.unlinkSync(root + file); } catch {
        // Continue regardless of error.
      }
    });
    ['/a/b/c',
     '/a/b',
     '/a',
     '',
    ].forEach(function(folder) {
      try { fs.rmdirSync(root + folder); } catch {
        // Continue regardless of error.
      }
    });
  }

  function setup() {
    cleanup();
    ['',
     '/a',
     '/a/b',
     '/a/b/c',
    ].forEach(function(folder) {
      console.log(`mkdir ${root}${folder}`);
      fs.mkdirSync(root + folder, 0o700);
    });
    fs.writeFileSync(`${root}/a/b/c/x.txt`, 'foo');
    fs.symlinkSync(`${root}/a/b`, `${root}/a/link`, type);
  }
  setup();
  const linkPath = `${root}/a/link/c/x.txt`;
  const expectPath = `${root}/a/b/c/x.txt`;
  const actual = realpathSync(linkPath);
  // console.log({link:linkPath,expect:expectPath,actual:actual},'sync');
  assertEqualPath(actual, path.resolve(expectPath));
  asynctest(realpath, [linkPath], cb, function(er, actual) {
    // console.log({link:linkPath,expect:expectPath,actual:actual},'async');
    assertEqualPath(actual, path.resolve(expectPath));
    cleanup();
  });
}

function test_root(realpath, realpathSync, cb) {
  assertEqualPath(root, realpathSync('/'));
  realpath('/', function(err, result) {
    assert.ifError(err);
    assertEqualPath(root, result);
    cb();
  });
}

function test_root_with_null_options(realpath, realpathSync, cb) {
  realpath('/', null, function(err, result) {
    assert.ifError(err);
    assertEqualPath(root, result);
    cb();
  });
}

// ----------------------------------------------------------------------------

const tests = [
  test_simple_error_callback,
  test_simple_error_cb_with_null_options,
  test_simple_relative_symlink,
  test_simple_absolute_symlink,
  test_deep_relative_file_symlink,
  test_deep_relative_dir_symlink,
  test_cyclic_link_protection,
  test_cyclic_link_overprotection,
  test_relative_input_cwd,
  test_deep_symlink_mix,
  test_non_symlinks,
  test_escape_cwd,
  test_upone_actual,
  test_abs_with_kids,
  test_up_multiple,
  test_up_multiple_with_null_options,
  test_root,
  test_root_with_null_options,
];
const numtests = tests.length;
let testsRun = 0;
function runNextTest(err) {
  assert.ifError(err);
  const test = tests.shift();
  if (!test) {
    return console.log(`${numtests} subtests completed OK for fs.realpath`);
  }
  testsRun++;
  test(fs.realpath, fs.realpathSync, common.mustSucceed(() => {
    testsRun++;
    test(fs.realpath.native,
         fs.realpathSync.native,
         common.mustCall(runNextTest));
  }));
}

function runTest() {
  const tmpDirs = ['cycles', 'cycles/folder'];
  tmpDirs.forEach(function(t) {
    t = tmp(t);
    fs.mkdirSync(t, 0o700);
  });
  fs.writeFileSync(tmp('cycles/root.js'), ""console.error('roooot!');"");
  console.error('start tests');
  runNextTest();
}


process.on('exit', function() {
  assert.strictEqual(2 * numtests, testsRun);
  assert.strictEqual(async_completed, async_expected);
});
"
tests/test-fs.rs,"#![allow(dead_code, unused_imports, unused_must_use)]

use std::borrow::{Borrow, BorrowMut};
use wasmedge_quickjs::*;

fn test_js_file(file_path: &str) {
    use wasmedge_quickjs as q;

    env_logger::builder()
        // .filter_level(log::LevelFilter::Trace)
        .is_test(true)
        .try_init();

    let tokio_rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();

    tokio_rt.block_on(async {
        let mut rt = q::Runtime::new();
        let file_path = file_path.to_string();
        rt.async_run_with_context(Box::new(move |ctx| {
            let code = std::fs::read_to_string(&file_path);
            match code {
                Ok(code) => {
                    ctx.put_args(vec![file_path.clone()]);
                    ctx.eval_module_str(code, &file_path);
                }
                Err(e) => {
                    eprintln!(""{}"", e.to_string());
                    assert!(false, ""run js test file fail"");
                }
            }
            JsValue::UnDefined
        }))
        .await;
        rt.async_run_with_context(Box::new(|ctx| {
            log::trace!(""try _onExit"");
            if let JsValue::Function(func) = ctx.get_global().get(""_onExit"") {
                func.call(&[]);
            };
            JsValue::UnDefined
        }))
        .await;
        rt.async_run_with_context(Box::new(|ctx| {
            log::trace!(""try commonExitCheck"");
            if let JsValue::Function(func) = ctx.get_global().get(""commonExitCheck"") {
                func.call(&[]);
            };
            JsValue::UnDefined
        }))
        .await;
        rt.async_run_with_context(Box::new(|ctx| {
            log::trace!(""try assertPass"");
            if let JsValue::Function(func) = ctx.get_global().get(""assertPass"") {
                func.call(&[]);
            };
            JsValue::UnDefined
        }))
        .await;
    });
    std::fs::remove_dir_all(""./test/.tmp.0"");
}

#[test]
fn test_fs_access() {
    test_js_file(""test/fs/test-fs-access.js"");
}

#[test]
fn test_fs_append_file() {
    test_js_file(""test/fs/test-fs-append-file.js"");
}

#[test]
fn test_fs_append_file_sync() {
    test_js_file(""test/fs/test-fs-append-file-sync.js"");
}

#[test]
fn test_fs_assert_encoding_error() {
    test_js_file(""test/fs/test-fs-assert-encoding-error.js"");
}

#[test]
fn test_fs_buffer() {
    test_js_file(""test/fs/test-fs-buffer.js"");
}

#[test]
fn test_fs_buffertype_writesync() {
    test_js_file(""test/fs/test-fs-buffertype-writesync.js"");
}

#[ignore = ""unsupported, chmod""]
fn test_fs_chmod() {
    test_js_file(""test/fs/test-fs-chmod.js"");
}

#[ignore = ""unsupported, chmod""]
fn test_fs_chmod_mask() {
    test_js_file(""test/fs/test-fs-chmod-mask.js"");
}

#[ignore = ""unsupported, chown""]
fn test_fs_chown_type_check() {
    test_js_file(""test/fs/test-fs-chown-type-check.js"");
}

#[test]
fn test_fs_close_errors() {
    test_js_file(""test/fs/test-fs-close-errors.js"");
}

#[test]
fn test_fs_close() {
    test_js_file(""test/fs/test-fs-close.js"");
}

#[test]
fn test_fs_constants() {
    test_js_file(""test/fs/test-fs-constants.js"");
}

#[test]
fn test_fs_copyfile() {
    test_js_file(""test/fs/test-fs-copyfile.js"");
}

#[ignore = ""unsupported, chmod""]
fn test_fs_copyfile_respect_permissions() {
    test_js_file(""test/fs/test-fs-copyfile-respect-permissions.js"");
}

#[test]
fn test_fs_cp() {
    test_js_file(""test/fs/test-fs-cp.js"");
}

#[test]
fn test_fs_empty_read_stream() {
    test_js_file(""test/fs/test-fs-empty-readStream.js"");
}

#[test]
fn test_fs_error_messages() {
    test_js_file(""test/fs/test-fs-error-messages.js"");
}

#[test]
fn test_fs_exists() {
    test_js_file(""test/fs/test-fs-exists.js"");
}

#[ignore = ""unsupported, too long path""]
fn test_fs_existssync_false() {
    test_js_file(""test/fs/test-fs-existssync-false.js"");
}

#[ignore = ""unsupported, chmod""]
fn test_fs_fchmod() {
    test_js_file(""test/fs/test-fs-fchmod.js"");
}

#[ignore = ""unsupported, chown""]
fn test_fs_fchown() {
    test_js_file(""test/fs/test-fs-fchown.js"");
}

#[ignore = ""v8 specific""]
fn test_fs_filehandle() {
    test_js_file(""test/fs/test-fs-filehandle.js"");
}

#[test]
fn test_fs_filehandle_use_after_close() {
    test_js_file(""test/fs/test-fs-filehandle-use-after-close.js"");
}

#[test]
fn test_fs_fmap() {
    test_js_file(""test/fs/test-fs-fmap.js"");
}

#[test]
fn test_fs_fsync() {
    test_js_file(""test/fs/test-fs-fsync.js"");
}

#[ignore = ""unsupported, chmod""]
fn test_fs_lchmod() {
    test_js_file(""test/fs/test-fs-lchmod.js"");
}

#[ignore = ""unsupported, chown""]
fn test_fs_lchown() {
    test_js_file(""test/fs/test-fs-lchown.js"");
}

#[test]
fn test_fs_link() {
    test_js_file(""test/fs/test-fs-link.js"");
}

#[ignore = ""windows specific""]
fn test_fs_long_path() {
    test_js_file(""test/fs/test-fs-long-path.js"");
}

#[test]
fn test_fs_make_callback() {
    test_js_file(""test/fs/test-fs-make-callback.js"");
}

#[test]
fn test_fs_make_stats_callback() {
    test_js_file(""test/fs/test-fs-makeStatsCallback.js"");
}

#[test]
fn test_fs_mkdir() {
    test_js_file(""test/fs/test-fs-mkdir.js"");
}

#[ignore = ""unsupported, chmod""]
fn test_fs_mkdir_mode_mask() {
    test_js_file(""test/fs/test-fs-mkdir-mode-mask.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_mkdir_recursive_eaccess() {
    test_js_file(""test/fs/test-fs-mkdir-recursive-eaccess.js"");
}

#[test]
fn test_fs_mkdir_rmdir() {
    test_js_file(""test/fs/test-fs-mkdir-rmdir.js"");
}

#[test]
fn test_fs_mkdtemp() {
    test_js_file(""test/fs/test-fs-mkdtemp.js"");
}

#[test]
fn test_fs_mkdtemp_prefix_check() {
    test_js_file(""test/fs/test-fs-mkdtemp-prefix-check.js"");
}

#[test]
fn test_fs_non_number_arguments_throw() {
    test_js_file(""test/fs/test-fs-non-number-arguments-throw.js"");
}

#[test]
fn test_fs_null_bytes() {
    test_js_file(""test/fs/test-fs-null-bytes.js"");
}

#[test]
fn test_fs_opendir() {
    test_js_file(""test/fs/test-fs-opendir.js"");
}

#[test]
fn test_fs_open_flags() {
    test_js_file(""test/fs/test-fs-open-flags.js"");
}

#[test]
fn test_fs_open() {
    test_js_file(""test/fs/test-fs-open.js"");
}

#[ignore = ""unsupported, mode""]
fn test_fs_open_mode_mask() {
    test_js_file(""test/fs/test-fs-open-mode-mask.js"");
}

#[test]
fn test_fs_open_no_close() {
    test_js_file(""test/fs/test-fs-open-no-close.js"");
}

#[test]
fn test_fs_open_numeric_flags() {
    test_js_file(""test/fs/test-fs-open-numeric-flags.js"");
}

#[test]
fn test_fs_options_immutable() {
    test_js_file(""test/fs/test-fs-options-immutable.js"");
}

#[test]
fn test_fs_promises_exists() {
    test_js_file(""test/fs/test-fs-promises-exists.js"");
}

#[test]
fn test_fs_promises_file_handle_aggregate_errors() {
    test_js_file(""test/fs/test-fs-promises-file-handle-aggregate-errors.js"");
}

#[test]
fn test_fs_promises_file_handle_append_file() {
    test_js_file(""test/fs/test-fs-promises-file-handle-append-file.js"");
}

#[ignore = ""unsupported, chomd""]
fn test_fs_promises_file_handle_chmod() {
    test_js_file(""test/fs/test-fs-promises-file-handle-chmod.js"");
}

#[test]
fn test_fs_promises_file_handle_close_errors() {
    test_js_file(""test/fs/test-fs-promises-file-handle-close-errors.js"");
}

#[ignore = ""unsupported, required manual triggered gc""]
fn test_fs_promises_file_handle_close() {
    test_js_file(""test/fs/test-fs-promises-file-handle-close.js"");
}

#[test]
fn test_fs_promises_file_handle_op_errors() {
    test_js_file(""test/fs/test-fs-promises-file-handle-op-errors.js"");
}

#[test]
fn test_fs_promises_file_handle_read_file() {
    test_js_file(""test/fs/test-fs-promises-file-handle-readFile.js"");
}

#[test]
fn test_fs_promises_file_handle_read() {
    test_js_file(""test/fs/test-fs-promises-file-handle-read.js"");
}

#[ignore = ""unsupported, worker_threads""]
fn test_fs_promises_file_handle_read_worker() {
    test_js_file(""test/fs/test-fs-promises-file-handle-read-worker.js"");
}

#[test]
fn test_fs_promises_file_handle_stat() {
    test_js_file(""test/fs/test-fs-promises-file-handle-stat.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_promises_file_handle_stream() {
    test_js_file(""test/fs/test-fs-promises-file-handle-stream.js"");
}

#[test]
fn test_fs_promises_file_handle_sync() {
    test_js_file(""test/fs/test-fs-promises-file-handle-sync.js"");
}

#[test]
fn test_fs_promises_file_handle_truncate() {
    test_js_file(""test/fs/test-fs-promises-file-handle-truncate.js"");
}

#[test]
fn test_fs_promises_file_handle_write_file() {
    test_js_file(""test/fs/test-fs-promises-file-handle-writeFile.js"");
}

#[test]
fn test_fs_promises_file_handle_write() {
    test_js_file(""test/fs/test-fs-promises-file-handle-write.js"");
}

#[test]
fn test_fs_promises() {
    test_js_file(""test/fs/test-fs-promises.js"");
}

#[test]
fn test_fs_promises_readfile_empty() {
    test_js_file(""test/fs/test-fs-promises-readfile-empty.js"");
}

#[test]
fn test_fs_promises_readfile() {
    test_js_file(""test/fs/test-fs-promises-readfile.js"");
}

#[test]
fn test_fs_promises_readfile_with_fd() {
    test_js_file(""test/fs/test-fs-promises-readfile-with-fd.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_promises_watch() {
    test_js_file(""test/fs/test-fs-promises-watch.js"");
}

#[test]
fn test_fs_promises_writefile() {
    test_js_file(""test/fs/test-fs-promises-writefile.js"");
}

#[test]
fn test_fs_promises_writefile_typedarray() {
    test_js_file(""test/fs/test-fs-promises-writefile-typedarray.js"");
}

#[test]
fn test_fs_promises_writefile_with_fd() {
    test_js_file(""test/fs/test-fs-promises-writefile-with-fd.js"");
}

#[test]
fn test_fs_promises_write_optional_params() {
    test_js_file(""test/fs/test-fs-promises-write-optional-params.js"");
}

#[test]
fn test_fs_promisified() {
    test_js_file(""test/fs/test-fs-promisified.js"");
}

#[ignore = ""MacOS specific""]
fn test_fs_readdir_buffer() {
    test_js_file(""test/fs/test-fs-readdir-buffer.js"");
}

#[test]
fn test_fs_readdir() {
    test_js_file(""test/fs/test-fs-readdir.js"");
}

#[ignore = ""unsupported""]
fn test_fs_readdir_stack_overflow() {
    test_js_file(""test/fs/test-fs-readdir-stack-overflow.js"");
}

#[test]
fn test_fs_readdir_types() {
    test_js_file(""test/fs/test-fs-readdir-types.js"");
}

#[ignore = ""linux specific""]
fn test_fs_readdir_ucs2() {
    test_js_file(""test/fs/test-fs-readdir-ucs2.js"");
}

#[test]
fn test_fs_read_empty_buffer() {
    test_js_file(""test/fs/test-fs-read-empty-buffer.js"");
}

#[test]
fn test_fs_read_file_assert_encoding() {
    test_js_file(""test/fs/test-fs-read-file-assert-encoding.js"");
}

#[test]
fn test_fs_readfile_empty() {
    test_js_file(""test/fs/test-fs-readfile-empty.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_readfile_error() {
    test_js_file(""test/fs/test-fs-readfile-error.js"");
}

#[test]
fn test_fs_readfile_fd() {
    test_js_file(""test/fs/test-fs-readfile-fd.js"");
}

#[test]
fn test_fs_readfile_flags() {
    test_js_file(""test/fs/test-fs-readfile-flags.js"");
}

#[test]
fn test_fs_readfile() {
    test_js_file(""test/fs/test-fs-readfile.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_readfile_pipe() {
    test_js_file(""test/fs/test-fs-readfile-pipe.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_readfile_pipe_large() {
    test_js_file(""test/fs/test-fs-readfile-pipe-large.js"");
}

#[ignore = ""windows specific""]
fn test_fs_readfilesync_enoent() {
    test_js_file(""test/fs/test-fs-readfilesync-enoent.js"");
}

#[ignore = ""linux specific""]
fn test_fs_read_file_sync_hostname() {
    test_js_file(""test/fs/test-fs-read-file-sync-hostname.js"");
}

#[test]
fn test_fs_read_file_sync() {
    test_js_file(""test/fs/test-fs-read-file-sync.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_readfilesync_pipe_large() {
    test_js_file(""test/fs/test-fs-readfilesync-pipe-large.js"");
}

#[test]
fn test_fs_readfile_unlink() {
    test_js_file(""test/fs/test-fs-readfile-unlink.js"");
}

#[test]
fn test_fs_readfile_zero_byte_liar() {
    test_js_file(""test/fs/test-fs-readfile-zero-byte-liar.js"");
}

#[test]
fn test_fs_read() {
    test_js_file(""test/fs/test-fs-read.js"");
}

#[test]
fn test_fs_readlink_type_check() {
    test_js_file(""test/fs/test-fs-readlink-type-check.js"");
}

#[test]
fn test_fs_read_offset_null() {
    test_js_file(""test/fs/test-fs-read-offset-null.js"");
}

#[test]
fn test_fs_read_optional_params() {
    test_js_file(""test/fs/test-fs-read-optional-params.js"");
}

#[test]
fn test_fs_read_position_validation() {
    test_js_file(""test/fs/test-fs-read-position-validation.js"");
}

#[test]
fn test_fs_read_promises_optional_params() {
    test_js_file(""test/fs/test-fs-read-promises-optional-params.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_auto_close() {
    test_js_file(""test/fs/test-fs-read-stream-autoClose.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_concurrent_reads() {
    test_js_file(""test/fs/test-fs-read-stream-concurrent-reads.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_double_close() {
    test_js_file(""test/fs/test-fs-read-stream-double-close.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_encoding() {
    test_js_file(""test/fs/test-fs-read-stream-encoding.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_err() {
    test_js_file(""test/fs/test-fs-read-stream-err.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_fd() {
    test_js_file(""test/fs/test-fs-read-stream-fd.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_fd_leak() {
    test_js_file(""test/fs/test-fs-read-stream-fd-leak.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_file_handle() {
    test_js_file(""test/fs/test-fs-read-stream-file-handle.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_inherit() {
    test_js_file(""test/fs/test-fs-read-stream-inherit.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream() {
    test_js_file(""test/fs/test-fs-read-stream.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_patch_open() {
    test_js_file(""test/fs/test-fs-read-stream-patch-open.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_pos() {
    test_js_file(""test/fs/test-fs-read-stream-pos.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_resume() {
    test_js_file(""test/fs/test-fs-read-stream-resume.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_read_stream_throw_type_error() {
    test_js_file(""test/fs/test-fs-read-stream-throw-type-error.js"");
}

#[test]
fn test_fs_read_sync_optional_params() {
    test_js_file(""test/fs/test-fs-readSync-optional-params.js"");
}

#[test]
fn test_fs_read_sync_position_validation() {
    test_js_file(""test/fs/test-fs-readSync-position-validation.js"");
}

#[test]
fn test_fs_read_type() {
    test_js_file(""test/fs/test-fs-read-type.js"");
}

#[test]
fn test_fs_readv() {
    test_js_file(""test/fs/test-fs-readv.js"");
}

#[test]
fn test_fs_readv_promises() {
    test_js_file(""test/fs/test-fs-readv-promises.js"");
}

#[test]
fn test_fs_readv_promisify() {
    test_js_file(""test/fs/test-fs-readv-promisify.js"");
}

#[test]
fn test_fs_readv_sync() {
    test_js_file(""test/fs/test-fs-readv-sync.js"");
}

#[test]
fn test_fs_ready_event_stream() {
    test_js_file(""test/fs/test-fs-ready-event-stream.js"");
}

#[test]
fn test_fs_read_zero_length() {
    test_js_file(""test/fs/test-fs-read-zero-length.js"");
}

#[ignore = ""unsupported, realpath""]
fn test_fs_realpath_buffer_encoding() {
    test_js_file(""test/fs/test-fs-realpath-buffer-encoding.js"");
}

#[ignore = ""unsupported, realpath""]
fn test_fs_realpath() {
    test_js_file(""test/fs/test-fs-realpath.js"");
}

#[ignore = ""unsupported, realpath""]
fn test_fs_realpath_native() {
    test_js_file(""test/fs/test-fs-realpath-native.js"");
}

#[ignore = ""unsupported, realpath""]
fn test_fs_realpath_on_substed_drive() {
    test_js_file(""test/fs/test-fs-realpath-on-substed-drive.js"");
}

#[ignore = ""unsupported, realpath""]
fn test_fs_realpath_pipe() {
    test_js_file(""test/fs/test-fs-realpath-pipe.js"");
}

#[test]
fn test_fs_rename_type_check() {
    test_js_file(""test/fs/test-fs-rename-type-check.js"");
}

#[test]
fn test_fs_rmdir_recursive() {
    test_js_file(""test/fs/test-fs-rmdir-recursive.js"");
}

#[test]
fn test_fs_rmdir_recursive_sync_warns_not_found() {
    test_js_file(""test/fs/test-fs-rmdir-recursive-sync-warns-not-found.js"");
}

#[test]
fn test_fs_rmdir_recursive_sync_warns_on_file() {
    test_js_file(""test/fs/test-fs-rmdir-recursive-sync-warns-on-file.js"");
}

#[test]
fn test_fs_rmdir_recursive_throws_not_found() {
    test_js_file(""test/fs/test-fs-rmdir-recursive-throws-not-found.js"");
}

#[test]
fn test_fs_rmdir_recursive_throws_on_file() {
    test_js_file(""test/fs/test-fs-rmdir-recursive-throws-on-file.js"");
}

#[test]
fn test_fs_rmdir_recursive_warns_not_found() {
    test_js_file(""test/fs/test-fs-rmdir-recursive-warns-not-found.js"");
}

#[test]
fn test_fs_rmdir_recursive_warns_on_file() {
    test_js_file(""test/fs/test-fs-rmdir-recursive-warns-on-file.js"");
}

#[test]
fn test_fs_rmdir_type_check() {
    test_js_file(""test/fs/test-fs-rmdir-type-check.js"");
}

#[test]
fn test_fs_rm() {
    test_js_file(""test/fs/test-fs-rm.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_sir_writes_alot() {
    test_js_file(""test/fs/test-fs-sir-writes-alot.js"");
}

#[test]
fn test_fs_stat_bigint() {
    test_js_file(""test/fs/test-fs-stat-bigint.js"");
}

#[test]
fn test_fs_stat_date() {
    test_js_file(""test/fs/test-fs-stat-date.js"");
}

#[test]
fn test_fs_stat() {
    test_js_file(""test/fs/test-fs-stat.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_construct_compat_error_read() {
    test_js_file(""test/fs/test-fs-stream-construct-compat-error-read.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_construct_compat_error_write() {
    test_js_file(""test/fs/test-fs-stream-construct-compat-error-write.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_construct_compat_graceful_fs() {
    test_js_file(""test/fs/test-fs-stream-construct-compat-graceful-fs.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_construct_compat_old_node() {
    test_js_file(""test/fs/test-fs-stream-construct-compat-old-node.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_destroy_emit_error() {
    test_js_file(""test/fs/test-fs-stream-destroy-emit-error.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_double_close() {
    test_js_file(""test/fs/test-fs-stream-double-close.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_fs_options() {
    test_js_file(""test/fs/test-fs-stream-fs-options.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_stream_options() {
    test_js_file(""test/fs/test-fs-stream-options.js"");
}

#[test]
fn test_fs_symlink_buffer_path() {
    test_js_file(""test/fs/test-fs-symlink-buffer-path.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_symlink_dir() {
    test_js_file(""test/fs/test-fs-symlink-dir.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_symlink_dir_junction() {
    test_js_file(""test/fs/test-fs-symlink-dir-junction.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_symlink_dir_junction_relative() {
    test_js_file(""test/fs/test-fs-symlink-dir-junction-relative.js"");
}

#[test]
fn test_fs_symlink() {
    test_js_file(""test/fs/test-fs-symlink.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_symlink_longpath() {
    test_js_file(""test/fs/test-fs-symlink-longpath.js"");
}

#[ignore = ""nodejs implement specific""]
fn test_fs_sync_fd_leak() {
    test_js_file(""test/fs/test-fs-sync-fd-leak.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_syncwritestream() {
    test_js_file(""test/fs/test-fs-syncwritestream.js"");
}

#[ignore = ""nodejs implement specific""]
fn test_fs_timestamp_parsing_error() {
    test_js_file(""test/fs/test-fs-timestamp-parsing-error.js"");
}

#[test]
fn test_fs_truncate_clear_file_zero() {
    test_js_file(""test/fs/test-fs-truncate-clear-file-zero.js"");
}

#[test]
fn test_fs_truncate_fd() {
    test_js_file(""test/fs/test-fs-truncate-fd.js"");
}

#[test]
fn test_fs_truncate() {
    test_js_file(""test/fs/test-fs-truncate.js"");
}

#[test]
fn test_fs_truncate_sync() {
    test_js_file(""test/fs/test-fs-truncate-sync.js"");
}

#[test]
fn test_fs_unlink_type_check() {
    test_js_file(""test/fs/test-fs-unlink-type-check.js"");
}

#[ignore = ""nodejs implement specific""]
fn test_fs_utils_get_dirents() {
    test_js_file(""test/fs/test-fs-utils-get-dirents.js"");
}

#[ignore = ""nodejs implement specific""]
fn test_fs_util_validateoffsetlength() {
    test_js_file(""test/fs/test-fs-util-validateoffsetlength.js"");
}

#[test]
fn test_fs_utimes() {
    test_js_file(""test/fs/test-fs-utimes.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_utimes_y2_k38() {
    test_js_file(""test/fs/test-fs-utimes-y2K38.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_abort_signal() {
    test_js_file(""test/fs/test-fs-watch-abort-signal.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_close_when_destroyed() {
    test_js_file(""test/fs/test-fs-watch-close-when-destroyed.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_encoding() {
    test_js_file(""test/fs/test-fs-watch-encoding.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_enoent() {
    test_js_file(""test/fs/test-fs-watch-enoent.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watchfile_bigint() {
    test_js_file(""test/fs/test-fs-watchfile-bigint.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_file_enoent_after_deletion() {
    test_js_file(""test/fs/test-fs-watch-file-enoent-after-deletion.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watchfile() {
    test_js_file(""test/fs/test-fs-watchfile.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watchfile_ref_unref() {
    test_js_file(""test/fs/test-fs-watchfile-ref-unref.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch() {
    test_js_file(""test/fs/test-fs-watch.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_recursive() {
    test_js_file(""test/fs/test-fs-watch-recursive.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_ref_unref() {
    test_js_file(""test/fs/test-fs-watch-ref-unref.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_stop_async() {
    test_js_file(""test/fs/test-fs-watch-stop-async.js"");
}

#[ignore = ""unsupported, watch""]
fn test_fs_watch_stop_sync() {
    test_js_file(""test/fs/test-fs-watch-stop-sync.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_whatwg_url() {
    test_js_file(""test/fs/test-fs-whatwg-url.js"");
}

#[test]
fn test_fs_write_buffer() {
    test_js_file(""test/fs/test-fs-write-buffer.js"");
}

#[ignore = ""unsupported, 64bit""]
fn test_fs_write_buffer_large() {
    test_js_file(""test/fs/test-fs-write-buffer-large.js"");
}

#[test]
fn test_fs_write_file_buffer() {
    test_js_file(""test/fs/test-fs-write-file-buffer.js"");
}

#[ignore = ""windows specific""]
fn test_fs_write_file_invalid_path() {
    test_js_file(""test/fs/test-fs-write-file-invalid-path.js"");
}

#[test]
fn test_fs_write_file() {
    test_js_file(""test/fs/test-fs-write-file.js"");
}

#[test]
fn test_fs_write_file_sync() {
    test_js_file(""test/fs/test-fs-write-file-sync.js"");
}

#[test]
fn test_fs_write_file_typedarrays() {
    test_js_file(""test/fs/test-fs-write-file-typedarrays.js"");
}

#[test]
fn test_fs_writefile_with_fd() {
    test_js_file(""test/fs/test-fs-writefile-with-fd.js"");
}

#[test]
fn test_fs_write() {
    test_js_file(""test/fs/test-fs-write.js"");
}

#[test]
fn test_fs_write_negativeoffset() {
    test_js_file(""test/fs/test-fs-write-negativeoffset.js"");
}

#[test]
fn test_fs_write_no_fd() {
    test_js_file(""test/fs/test-fs-write-no-fd.js"");
}

#[test]
fn test_fs_write_optional_params() {
    test_js_file(""test/fs/test-fs-write-optional-params.js"");
}

#[ignore = ""unsupport, v8 specific""]
fn test_fs_write_reuse_callback() {
    test_js_file(""test/fs/test-fs-write-reuse-callback.js"");
}

#[ignore = ""unsupport, child_process""]
fn test_fs_write_sigxfsz() {
    test_js_file(""test/fs/test-fs-write-sigxfsz.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_autoclose_option() {
    test_js_file(""test/fs/test-fs-write-stream-autoclose-option.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_change_open() {
    test_js_file(""test/fs/test-fs-write-stream-change-open.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_close_without_callback() {
    test_js_file(""test/fs/test-fs-write-stream-close-without-callback.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_double_close() {
    test_js_file(""test/fs/test-fs-write-stream-double-close.js"");
}

#[test]
fn test_fs_write_stream_encoding() {
    test_js_file(""test/fs/test-fs-write-stream-encoding.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_end() {
    test_js_file(""test/fs/test-fs-write-stream-end.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_err() {
    test_js_file(""test/fs/test-fs-write-stream-err.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_file_handle_2() {
    test_js_file(""test/fs/test-fs-write-stream-file-handle-2.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_file_handle() {
    test_js_file(""test/fs/test-fs-write-stream-file-handle.js"");
}

#[test]
#[ignore = ""working""]
fn test_fs_write_stream_fs() {
    test_js_file(""test/fs/test-fs-write-stream-fs.js"");
}

#[test]
fn test_fs_write_stream() {
    test_js_file(""test/fs/test-fs-write-stream.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_fs_write_stream_patch_open() {
    test_js_file(""test/fs/test-fs-write-stream-patch-open.js"");
}

#[test]
fn test_fs_write_stream_throw_type_error() {
    test_js_file(""test/fs/test-fs-write-stream-throw-type-error.js"");
}

#[test]
fn test_fs_write_sync() {
    test_js_file(""test/fs/test-fs-write-sync.js"");
}

#[test]
fn test_fs_write_sync_optional_params() {
    test_js_file(""test/fs/test-fs-write-sync-optional-params.js"");
}

#[test]
fn test_fs_writev() {
    test_js_file(""test/fs/test-fs-writev.js"");
}

#[test]
fn test_fs_writev_promises() {
    test_js_file(""test/fs/test-fs-writev-promises.js"");
}

#[test]
fn test_fs_writev_sync() {
    test_js_file(""test/fs/test-fs-writev-sync.js"");
}
"
src/internal_module/crypto.rs,"use crate::event_loop::wasi_fs::{Errno, Size};
use crate::quickjs_sys::*;
use crate::EventLoop;
use core::arch;
use crypto_wasi::{
    generate_key_pair, hkdf_hmac, pbkdf2, raw, scrypt, Cipheriv, Decipheriv, Hash, Hmac,
    KeyEncodingFormat, PrivateKey, PrivateKeyEncodingType, PublicKey, PublicKeyEncodingType,
};

mod wasi_snapshot_preview1 {
    #[link(wasm_import_module = ""wasi_snapshot_preview1"")]
    extern ""C"" {
        /// Write high-quality random data into a buffer.
        /// This function blocks when the implementation is unable to immediately
        /// provide sufficient high-quality random data.
        /// This function may execute slowly, so when large mounts of random data are
        /// required, it's advisable to use this function to seed a pseudo-random
        /// number generator, rather than to provide the random data directly.
        pub fn random_get(arg0: i32, arg1: i32) -> i32;
    }
}

/// Write high-quality random data into a buffer.
/// This function blocks when the implementation is unable to immediately
/// provide sufficient high-quality random data.
/// This function may execute slowly, so when large mounts of random data are
/// required, it's advisable to use this function to seed a pseudo-random
/// number generator, rather than to provide the random data directly.
///
/// ## Parameters
///
/// * `buf` - The buffer to fill with random data.
unsafe fn random_get(buf: *mut u8, buf_len: Size) -> Result<(), Errno> {
    let ret = wasi_snapshot_preview1::random_get(buf as i32, buf_len as i32);
    match ret {
        0 => Ok(()),
        _ => Err(Errno(ret as u16)),
    }
}

macro_rules! get_arg {
    ($argv:ident, $m:path, $i:expr) => {
        if let Some($m(val)) = $argv.get($i) {
            val
        } else {
            return JsValue::UnDefined;
        }
    };
}

fn timing_safe_equal(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let a = get_arg!(argv, JsValue::ArrayBuffer, 0);
    let b = get_arg!(argv, JsValue::ArrayBuffer, 1);
    let buf1 = a.as_ref();
    let buf2 = b.as_ref();
    let mut eq = true;
    for i in 0..buf1.len() {
        eq &= buf1[i] == buf2[i];
    }
    eq.into()
}

fn random_fill(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let buf = get_arg!(argv, JsValue::ArrayBuffer, 0);
    let offset = get_arg!(argv, JsValue::Int, 1);
    let size = get_arg!(argv, JsValue::Int, 2);
    return match unsafe {
        let (ptr, buf_len) = buf.get_mut_ptr();
        random_get(
            ptr.offset(*offset as isize),
            (buf_len - *offset as usize).min(*size as usize),
        )
    } {
        Ok(()) => JsValue::UnDefined,
        Err(e) => {
            let err = super::fs::errno_to_js_object(ctx, e);
            JsValue::Exception(ctx.throw_error(err))
        }
    };
}

pub fn errno_to_js_object(ctx: &mut Context, e: raw::CryptoErrno) -> JsValue {
    let mut res = ctx.new_object();
    res.set(""message"", JsValue::String(ctx.new_string(e.message())));
    res.set(""code"", JsValue::String(ctx.new_string(e.name())));
    res.set(""errno"", JsValue::Int(e.raw() as i32));
    JsValue::Object(res)
}

fn pbkdf2_sync(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let password = get_arg!(argv, JsValue::ArrayBuffer, 0);
    let salt = get_arg!(argv, JsValue::ArrayBuffer, 1);
    let iters = get_arg!(argv, JsValue::Int, 2);
    let key_len = get_arg!(argv, JsValue::Int, 3);
    let alg = get_arg!(argv, JsValue::String, 4);
    match {
        pbkdf2(
            password.as_ref(),
            salt.as_ref(),
            *iters as usize,
            *key_len as usize,
            alg.as_str(),
        )
    } {
        Ok(res) => ctx.new_array_buffer(res.as_slice()).into(),
        Err(e) => {
            let err = errno_to_js_object(ctx, e);
            JsValue::Exception(ctx.throw_error(err))
        }
    }
}

fn scrypt_sync(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let password = get_arg!(argv, JsValue::ArrayBuffer, 0);
    let salt = get_arg!(argv, JsValue::ArrayBuffer, 1);
    let n = *get_arg!(argv, JsValue::Int, 2);
    let r = *get_arg!(argv, JsValue::Int, 3);
    let p = *get_arg!(argv, JsValue::Int, 4);
    let key_len = *get_arg!(argv, JsValue::Int, 5);
    if key_len == 0 {
        return ctx.new_array_buffer(&vec![0; 0]).into();
    }
    match {
        scrypt(
            password.as_ref(),
            salt.as_ref(),
            n as usize,
            r as usize,
            p as usize,
            key_len as usize,
        )
    } {
        Ok(res) => ctx.new_array_buffer(res.as_slice()).into(),
        Err(e) => {
            let err = errno_to_js_object(ctx, e);
            JsValue::Exception(ctx.throw_error(err))
        }
    }
}

fn hkdf_sync(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let key = get_arg!(argv, JsValue::ArrayBuffer, 0);
    let salt = get_arg!(argv, JsValue::ArrayBuffer, 1);
    let info = get_arg!(argv, JsValue::ArrayBuffer, 2);
    let key_len = get_arg!(argv, JsValue::Int, 3);
    let alg = get_arg!(argv, JsValue::String, 4);
    match {
        hkdf_hmac(
            alg.as_str(),
            key.as_ref(),
            salt.as_ref(),
            info.as_ref(),
            *key_len as usize,
        )
    } {
        Ok(res) => ctx.new_array_buffer(res.as_slice()).into(),
        Err(e) => {
            let err = errno_to_js_object(ctx, e);
            JsValue::Exception(ctx.throw_error(err))
        }
    }
}

fn gen_keypair(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let alg = get_arg!(argv, JsValue::String, 0);
    match { generate_key_pair(alg.as_str()) } {
        Ok((pk, sk)) => {
            let js_pk = JsKeyObjectHandle::PubKey(pk);
            let js_sk = JsKeyObjectHandle::PriKey(sk);
            let mut arr = ctx.new_array();
            arr.put(0, JsKeyObjectHandle::wrap_obj(ctx, js_pk));
            arr.put(1, JsKeyObjectHandle::wrap_obj(ctx, js_sk));
            JsValue::Array(arr)
        }
        Err(e) => {
            let err = errno_to_js_object(ctx, e);
            JsValue::Exception(ctx.throw_error(err))
        }
    }
}

struct JsHash {
    handle: Hash,
}

impl JsHash {
    pub fn js_update(
        &mut self,
        _this: &mut JsObject,
        _ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let data = get_arg!(argv, JsValue::ArrayBuffer, 0);
        if let Ok(()) = self.handle.update(data.as_ref()) {
            JsValue::Bool(true)
        } else {
            JsValue::Bool(false)
        }
    }

    pub fn js_digest(
        &mut self,
        _this: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        if let Ok(res) = self.handle.digest() {
            ctx.new_array_buffer(&res).into()
        } else {
            JsValue::UnDefined
        }
    }

    fn copy(&self) -> Result<Self, raw::CryptoErrno> {
        self.handle.copy().map(|h| JsHash { handle: h })
    }
}

impl JsClassDef for JsHash {
    type RefType = JsHash;

    const CLASS_NAME: &'static str = ""JsHash"";

    const CONSTRUCTOR_ARGC: u8 = 1;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
        (""update"", 1, Self::js_update),
        (""digest"", 0, Self::js_digest),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        match argv.get(0) {
            Some(JsValue::String(alg)) => Hash::create(alg.as_str())
                .or_else(|e| {
                    let err = errno_to_js_object(ctx, e);
                    Err(JsValue::Exception(ctx.throw_error(err)))
                })
                .map(|h| JsHash { handle: h }),
            Some(obj) => JsHash::opaque(obj).ok_or(JsValue::UnDefined).and_then(|h| {
                h.copy().or_else(|e| {
                    let err = errno_to_js_object(ctx, e);
                    Err(JsValue::Exception(ctx.throw_error(err)))
                })
            }),
            _ => Err(JsValue::UnDefined),
        }
    }
}

struct JsHmac {
    handle: Hmac,
}

impl JsHmac {
    pub fn js_update(
        &mut self,
        _this: &mut JsObject,
        _ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let data = get_arg!(argv, JsValue::ArrayBuffer, 0);
        if let Ok(()) = self.handle.update(data.as_ref()) {
            JsValue::Bool(true)
        } else {
            JsValue::Bool(false)
        }
    }

    pub fn js_digest(
        &mut self,
        _this: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        if let Ok(res) = self.handle.digest() {
            ctx.new_array_buffer(&res).into()
        } else {
            JsValue::UnDefined
        }
    }
}

impl JsClassDef for JsHmac {
    type RefType = JsHmac;

    const CLASS_NAME: &'static str = ""JsHmac"";

    const CONSTRUCTOR_ARGC: u8 = 2;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
        (""update"", 1, Self::js_update),
        (""digest"", 0, Self::js_digest),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        match (argv.get(0), argv.get(1)) {
            (Some(JsValue::String(alg)), Some(JsValue::ArrayBuffer(key))) => {
                Hmac::create(alg.as_str(), key.as_ref())
                    .or_else(|e| {
                        let err = errno_to_js_object(ctx, e);
                        Err(JsValue::Exception(ctx.throw_error(err)))
                    })
                    .map(|h| JsHmac { handle: h })
            }
            _ => Err(JsValue::UnDefined),
        }
    }
}

enum JsCipher {
    Cipher(Cipheriv),
    Decipher(Decipheriv),
}

impl JsCipher {
    pub fn js_update(
        &mut self,
        _this: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some(JsValue::ArrayBuffer(buf)) = argv.get(0) {
            match self {
                JsCipher::Cipher(c) => c.update(buf.as_ref()),
                JsCipher::Decipher(d) => d.update(buf.as_ref()),
            }
            .map_or(JsValue::UnDefined, |()| ctx.new_array_buffer(&[]).into())
        } else {
            JsValue::UnDefined
        }
    }

    pub fn js_set_aad(
        &mut self,
        _this: &mut JsObject,
        _ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some(JsValue::ArrayBuffer(buf)) = argv.get(0) {
            match self {
                JsCipher::Cipher(c) => c.set_aad(buf.as_ref()),
                JsCipher::Decipher(d) => d.set_aad(buf.as_ref()),
            }
            .map_or(JsValue::UnDefined, |()| JsValue::Bool(true))
        } else {
            JsValue::UnDefined
        }
    }

    pub fn js_set_auth_tag(
        &mut self,
        _this: &mut JsObject,
        _ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some(JsValue::ArrayBuffer(buf)) = argv.get(0) {
            match self {
                JsCipher::Cipher(_) => JsValue::UnDefined,
                JsCipher::Decipher(d) => d
                    .set_auth_tag(buf.as_ref())
                    .map_or(JsValue::UnDefined, |()| JsValue::Bool(true)),
            }
        } else {
            JsValue::UnDefined
        }
    }

    pub fn js_get_auth_tag(
        &mut self,
        _this: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match self {
            JsCipher::Cipher(c) => c
                .get_auth_tag()
                .map_or(JsValue::UnDefined, |tag| ctx.new_array_buffer(&tag).into()),
            JsCipher::Decipher(_) => JsValue::UnDefined,
        }
    }

    pub fn js_final(
        &mut self,
        _this: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match self {
            JsCipher::Cipher(c) => c.fin(),
            JsCipher::Decipher(d) => d.fin(),
        }
        .map_or(JsValue::UnDefined, |res| ctx.new_array_buffer(&res).into())
    }

    pub fn js_set_auto_padding(
        &mut self,
        _this: &mut JsObject,
        _ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        true.into()
    }
}

impl JsClassDef for JsCipher {
    type RefType = Self;

    const CLASS_NAME: &'static str = ""JsCipher"";

    const CONSTRUCTOR_ARGC: u8 = 5;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
        (""update"", 1, Self::js_update),
        (""final"", 0, Self::js_final),
        (""setAAD"", 0, Self::js_set_aad),
        (""setAuthTag"", 0, Self::js_set_auth_tag),
        (""getAuthTag"", 0, Self::js_get_auth_tag),
        (""setAutoPadding"", 0, Self::js_set_auto_padding),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        if let (
            Some(JsValue::String(alg)),
            Some(JsValue::ArrayBuffer(key)),
            Some(JsValue::ArrayBuffer(iv)),
            Some(JsValue::Bool(is_encrypt)),
        ) = (argv.get(0), argv.get(1), argv.get(2), argv.get(4))
        {
            if *is_encrypt {
                Cipheriv::create(alg.as_str(), key.as_ref(), iv.as_ref())
                    .or_else(|e| {
                        let err = errno_to_js_object(ctx, e);
                        Err(JsValue::Exception(ctx.throw_error(err)))
                    })
                    .map(|c| JsCipher::Cipher(c))
            } else {
                Decipheriv::create(alg.as_str(), key.as_ref(), iv.as_ref())
                    .or_else(|e| {
                        let err = errno_to_js_object(ctx, e);
                        Err(JsValue::Exception(ctx.throw_error(err)))
                    })
                    .map(|c| JsCipher::Decipher(c))
            }
        } else {
            Err(JsValue::UnDefined)
        }
    }
}

enum JsKeyObjectHandle {
    PubKey(PublicKey),
    PriKey(PrivateKey),
}

impl JsKeyObjectHandle {
    pub fn js_export(
        &mut self,
        _this: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let skenc_enums = [
            PrivateKeyEncodingType::Pkcs1,
            PrivateKeyEncodingType::Pkcs8,
            PrivateKeyEncodingType::Sec1,
        ];
        let pkenc_enums = [PublicKeyEncodingType::Pkcs1, PublicKeyEncodingType::Spki];
        let format_enums = [
            KeyEncodingFormat::Der,
            KeyEncodingFormat::Pem,
            KeyEncodingFormat::Jwk,
        ];
        let enc = get_arg!(argv, JsValue::Int, 0);
        let format = get_arg!(argv, JsValue::Int, 0);
        match self {
            JsKeyObjectHandle::PriKey(sk) => {
                return match sk.export(skenc_enums[*enc as usize], format_enums[*format as usize]) {
                    Ok(res) => ctx.new_array_buffer(res.as_slice()).into(),
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                }
            }
            JsKeyObjectHandle::PubKey(pk) => {
                return match pk.export(pkenc_enums[*enc as usize], format_enums[*format as usize]) {
                    Ok(res) => ctx.new_array_buffer(res.as_slice()).into(),
                    Err(e) => {
                        let err = errno_to_js_object(ctx, e);
                        JsValue::Exception(ctx.throw_error(err))
                    }
                }
            }
        };
    }
}

impl JsClassDef for JsKeyObjectHandle {
    type RefType = Self;

    const CLASS_NAME: &'static str = ""JsKeyObjectHandle"";

    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[(""export"", 2, Self::js_export)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    // can't construct by user
    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        Err(JsValue::UnDefined)
    }
}

struct Crypto;

impl ModuleInit for Crypto {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
        m.add_export(
            ""timing_safe_equal\0"",
            ctx.wrap_function(""timing_safe_equal"", timing_safe_equal)
                .into(),
        );
        m.add_export(
            ""random_fill\0"",
            ctx.wrap_function(""random_fill"", random_fill).into(),
        );
        m.add_export(
            ""pbkdf2_sync\0"",
            ctx.wrap_function(""pbkdf2_sync"", pbkdf2_sync).into(),
        );
        m.add_export(
            ""scrypt_sync\0"",
            ctx.wrap_function(""scrypt_sync"", scrypt_sync).into(),
        );
        m.add_export(
            ""hkdf_sync\0"",
            ctx.wrap_function(""hkdf_sync"", hkdf_sync).into(),
        );
        m.add_export(
            ""gen_keypair\0"",
            ctx.wrap_function(""gen_keypair"", gen_keypair).into(),
        );
        m.add_export(JsHash::CLASS_NAME, register_class::<JsHash>(ctx));
        m.add_export(JsHmac::CLASS_NAME, register_class::<JsHmac>(ctx));
        m.add_export(JsCipher::CLASS_NAME, register_class::<JsCipher>(ctx));
        m.add_export(
            JsKeyObjectHandle::CLASS_NAME,
            register_class::<JsKeyObjectHandle>(ctx),
        );
    }
}

pub fn init_module(ctx: &mut Context) {
    ctx.register_module(
        ""_node:crypto\0"",
        Crypto,
        &[
            ""timing_safe_equal\0"",
            ""random_fill\0"",
            ""pbkdf2_sync\0"",
            ""scrypt_sync\0"",
            ""hkdf_sync\0"",
            ""gen_keypair\0"",
            JsHash::CLASS_NAME,
            JsHmac::CLASS_NAME,
            JsCipher::CLASS_NAME,
            JsKeyObjectHandle::CLASS_NAME,
        ],
    )
}
"
LICENSE,"                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      ""License"" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      ""Licensor"" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      ""Legal Entity"" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      ""control"" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      ""You"" (or ""Your"") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      ""Source"" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      ""Object"" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      ""Work"" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      ""Derivative Works"" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      ""Contribution"" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, ""submitted""
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as ""Not a Contribution.""

      ""Contributor"" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a ""NOTICE"" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an ""AS IS"" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets ""[]""
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same ""printed page"" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the ""License"");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an ""AS IS"" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"
modules/internal/crypto/random.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import { kEmptyObject } from '../util';

import { Buffer, kMaxLength, FastBuffer } from '../../buffer';

import { ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, ERR_OPERATION_FAILED } from '../errors';

import { validateNumber, validateBoolean, validateFunction, validateInt32, validateObject, validateUint32 } from '../validators';

import { isArrayBufferView, isAnyArrayBuffer, isTypedArray, isFloat32Array, isFloat64Array } from '../util/types';

import { lazyDOMException } from '../util';

import { random_fill } from ""_node:crypto"";

import process from ""process"";

const kMaxInt32 = 2 ** 31 - 1;
const kMaxPossibleLength = Math.min(kMaxLength, kMaxInt32);

function assertOffset(offset, elementSize, length) {
  validateNumber(offset, 'offset');
  offset *= elementSize;

  const maxLength = Math.min(length, kMaxPossibleLength);
  if (Number.isNaN(offset) || offset > maxLength || offset < 0) {
    throw new ERR_OUT_OF_RANGE('offset', `>= 0 && <= ${maxLength}`, offset);
  }

  return offset >>> 0;  // Convert to uint32.
}

function assertSize(size, elementSize, offset, length) {
  validateNumber(size, 'size');
  size *= elementSize;

  if (Number.isNaN(size) || size > kMaxPossibleLength || size < 0) {
    throw new ERR_OUT_OF_RANGE('size',
      `>= 0 && <= ${kMaxPossibleLength}`, size);
  }

  if (size + offset > length) {
    throw new ERR_OUT_OF_RANGE('size + offset', `<= ${length}`, size + offset);
  }

  return size >>> 0;  // Convert to uint32.
}

function randomBytes(size, callback) {
  size = assertSize(size, 1, 0, Infinity);
  if (callback !== undefined) {
    validateFunction(callback, 'callback');
  }

  const buf = new Buffer(size);

  if (callback === undefined) {
    randomFillSync(buf.buffer, 0, size);
    return buf;
  }

  // Keep the callback as a regular function so this is propagated.
  randomFill(buf.buffer, 0, size, function (error) {
    if (error) return Function.prototype.call.call(callback, this, error);
    Function.prototype.call.call(callback, this, null, buf);
  });
}

function randomFillSync(buf, offset = 0, size) {
  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {
    throw new ERR_INVALID_ARG_TYPE(
      'buf',
      ['ArrayBuffer', 'ArrayBufferView'],
      buf);
  }

  const elementSize = buf.BYTES_PER_ELEMENT || 1;

  offset = assertOffset(offset, elementSize, buf.byteLength);

  if (size === undefined) {
    size = buf.byteLength - offset;
  } else {
    size = assertSize(size, elementSize, offset, buf.byteLength);
  }

  if (size === 0)
    return buf;

  random_fill(buf.buffer ?? buf, offset + (buf.byteOffset ?? 0), size);
  return buf;
}

function randomFill(buf, offset, size, callback) {
  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {
    throw new ERR_INVALID_ARG_TYPE(
      'buf',
      ['ArrayBuffer', 'ArrayBufferView'],
      buf);
  }

  const elementSize = buf.BYTES_PER_ELEMENT || 1;

  if (typeof offset === 'function') {
    callback = offset;
    offset = 0;
    // Size is a length here, assertSize() call turns it into a number of bytes
    size = buf.length;
  } else if (typeof size === 'function') {
    callback = size;
    size = buf.length - offset;
  } else {
    validateFunction(callback, 'callback');
  }

  offset = assertOffset(offset, elementSize, buf.byteLength);

  if (size === undefined) {
    size = buf.byteLength - offset;
  } else {
    size = assertSize(size, elementSize, offset, buf.byteLength);
  }

  if (size === 0) {
    callback(null, buf);
    return;
  }

  setTimeout(() => {
    random_fill(buf.buffer ?? buf, offset + (buf.byteOffset ?? 0), size);
    callback(null, buf);
  }, 0);
}

// Largest integer we can read from a buffer.
// e.g.: Buffer.from(""ff"".repeat(6), ""hex"").readUIntBE(0, 6);
const RAND_MAX = 0xFFFF_FFFF_FFFF;

// Cache random data to use in randomInt. The cache size must be evenly
// divisible by 6 because each attempt to obtain a random int uses 6 bytes.
const randomCache = new Buffer(6 * 1024);
let randomCacheOffset = randomCache.length;
let asyncCacheFillInProgress = false;
const asyncCachePendingTasks = [];

// Generates an integer in [min, max) range where min is inclusive and max is
// exclusive.
function randomInt(min, max, callback) {
  // Detect optional min syntax
  // randomInt(max)
  // randomInt(max, callback)
  const minNotSpecified = typeof max === 'undefined' ||
    typeof max === 'function';

  if (minNotSpecified) {
    callback = max;
    max = min;
    min = 0;
  }

  const isSync = typeof callback === 'undefined';
  if (!isSync) {
    validateFunction(callback, 'callback');
  }
  if (!Number.isSafeInteger(min)) {
    throw new ERR_INVALID_ARG_TYPE('min', 'a safe integer', min);
  }
  if (!Number.isSafeInteger(max)) {
    throw new ERR_INVALID_ARG_TYPE('max', 'a safe integer', max);
  }
  if (max <= min) {
    throw new ERR_OUT_OF_RANGE(
      'max', `greater than the value of ""min"" (${min})`, max
    );
  }

  // First we generate a random int between [0..range)
  const range = max - min;

  if (!(range <= RAND_MAX)) {
    throw new ERR_OUT_OF_RANGE(`max${minNotSpecified ? '' : ' - min'}`,
      `<= ${RAND_MAX}`, range);
  }

  // For (x % range) to produce an unbiased value greater than or equal to 0 and
  // less than range, x must be drawn randomly from the set of integers greater
  // than or equal to 0 and less than randLimit.
  const randLimit = RAND_MAX - (RAND_MAX % range);

  // If we don't have a callback, or if there is still data in the cache, we can
  // do this synchronously, which is super fast.
  while (isSync || (randomCacheOffset < randomCache.length)) {
    if (randomCacheOffset === randomCache.length) {
      // This might block the thread for a bit, but we are in sync mode.
      randomFillSync(randomCache);
      randomCacheOffset = 0;
    }

    const x = randomCache.readUIntBE(randomCacheOffset, 6);
    randomCacheOffset += 6;

    if (x < randLimit) {
      const n = (x % range) + min;
      if (isSync) return n;
      process.nextTick(callback, undefined, n);
      return;
    }
  }

  // At this point, we are in async mode with no data in the cache. We cannot
  // simply refill the cache, because another async call to randomInt might
  // already be doing that. Instead, queue this call for when the cache has
  // been refilled.
  Array.prototype.push.call(asyncCachePendingTasks, { min, max, callback });
  asyncRefillRandomIntCache();
}

function asyncRefillRandomIntCache() {
  if (asyncCacheFillInProgress)
    return;

  asyncCacheFillInProgress = true;
  randomFill(randomCache, (err) => {
    asyncCacheFillInProgress = false;

    const tasks = asyncCachePendingTasks;
    const errorReceiver = err && Array.prototype.shift.call(tasks);
    if (!err)
      randomCacheOffset = 0;

    // Restart all pending tasks. If an error occurred, we only notify a single
    // callback (errorReceiver) about it. This way, every async call to
    // randomInt has a chance of being successful, and it avoids complex
    // exception handling here.
    Array.prototype.forEach.call(Array.prototype.splice.call(tasks, 0), (task) => {
      randomInt(task.min, task.max, task.callback);
    });

    // This is the only call that might throw, and is therefore done at the end.
    if (errorReceiver)
      errorReceiver.callback(err);
  });
}

// Really just the Web Crypto API alternative
// to require('crypto').randomFillSync() with an
// additional limitation that the input buffer is
// not allowed to exceed 65536 bytes, and can only
// be an integer-type TypedArray.
function getRandomValues(data) {
  if (!isTypedArray(data) ||
    isFloat32Array(data) ||
    isFloat64Array(data)) {
    // Ordinarily this would be an ERR_INVALID_ARG_TYPE. However,
    // the Web Crypto API and web platform tests expect this to
    // be a DOMException with type TypeMismatchError.
    throw lazyDOMException(
      'The data argument must be an integer-type TypedArray',
      'TypeMismatchError');
  }
  if (data.byteLength > 65536) {
    throw lazyDOMException(
      'The requested length exceeds 65,536 bytes',
      'QuotaExceededError');
  }
  randomFillSync(data, 0);
  return data;
}

// Implements an RFC 4122 version 4 random UUID.
// To improve performance, random data is generated in batches
// large enough to cover kBatchSize UUID's at a time. The uuidData
// buffer is reused. Each call to randomUUID() consumes 16 bytes
// from the buffer.

const kBatchSize = 128;
let uuidData;
let uuidNotBuffered;
let uuidBatch = 0;

let hexBytesCache;
function getHexBytes() {
  if (hexBytesCache === undefined) {
    hexBytesCache = new Array(256);
    for (let i = 0; i < hexBytesCache.length; i++) {
      const hex = Number.prototype.toString.call(i, 16);
      hexBytesCache[i] = String.prototype.padStart.call(hex, 2, '0');
    }
  }
  return hexBytesCache;
}

function serializeUUID(buf, offset = 0) {
  const kHexBytes = getHexBytes();
  // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  return kHexBytes[buf[offset]] +
    kHexBytes[buf[offset + 1]] +
    kHexBytes[buf[offset + 2]] +
    kHexBytes[buf[offset + 3]] +
    '-' +
    kHexBytes[buf[offset + 4]] +
    kHexBytes[buf[offset + 5]] +
    '-' +
    kHexBytes[(buf[offset + 6] & 0x0f) | 0x40] +
    kHexBytes[buf[offset + 7]] +
    '-' +
    kHexBytes[(buf[offset + 8] & 0x3f) | 0x80] +
    kHexBytes[buf[offset + 9]] +
    '-' +
    kHexBytes[buf[offset + 10]] +
    kHexBytes[buf[offset + 11]] +
    kHexBytes[buf[offset + 12]] +
    kHexBytes[buf[offset + 13]] +
    kHexBytes[buf[offset + 14]] +
    kHexBytes[buf[offset + 15]];
}

function getBufferedUUID() {
  // uuidData ??= secureBuffer(16 * kBatchSize);
  uuidData ??= new Uint8Array(16 * kBatchSize);
  if (uuidData === undefined)
    throw new ERR_OPERATION_FAILED('Out of memory');

  if (uuidBatch === 0) randomFillSync(uuidData);
  uuidBatch = (uuidBatch + 1) % kBatchSize;
  return serializeUUID(uuidData, uuidBatch * 16);
}

function getUnbufferedUUID() {
  // uuidNotBuffered ??= secureBuffer(16);
  uuidNotBuffered ??= new Uint8Array(16);
  if (uuidNotBuffered === undefined)
    throw new ERR_OPERATION_FAILED('Out of memory');
  randomFillSync(uuidNotBuffered);
  return serializeUUID(uuidNotBuffered);
}

function randomUUID(options) {
  if (options !== undefined)
    validateObject(options, 'options');
  const {
    disableEntropyCache = false,
  } = options || kEmptyObject;

  validateBoolean(disableEntropyCache, 'options.disableEntropyCache');

  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();
}

function generatePrime(size, options, callback) {
  validateInt32(size, 'size', 1);
  if (typeof options === 'function') {
    callback = options;
    options = kEmptyObject;
  }
  validateFunction(callback, 'callback');

  throw new Error(""crypto.generatePrime is unimplemented"");
}

function generatePrimeSync(size, options = kEmptyObject) {
  validateInt32(size, 'size', 1);

  throw new Error(""crypto.generatePrimeSync is unimplemented"");

}

function unsignedBigIntToBuffer(bigint, name) {
  if (bigint < 0) {
    throw new ERR_OUT_OF_RANGE(name, '>= 0', bigint);
  }

  const hex = bigint.toString(16);
  const padded = hex.padStart(hex.length + (hex.length % 2), 0);
  return Buffer.from(padded, 'hex');
}

function checkPrime(candidate, options = kEmptyObject, callback) {
  if (typeof candidate === 'bigint')
    candidate = unsignedBigIntToBuffer(candidate, 'candidate');
  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {
    throw new ERR_INVALID_ARG_TYPE(
      'candidate',
      [
        'ArrayBuffer',
        'TypedArray',
        'Buffer',
        'DataView',
        'bigint',
      ],
      candidate
    );
  }
  if (typeof options === 'function') {
    callback = options;
    options = kEmptyObject;
  }
  validateFunction(callback, 'callback');
  validateObject(options, 'options');
  const {
    checks = 0,
  } = options;

  validateUint32(checks, 'options.checks');

  throw new Error(""crypto.checkPrime is unimplemented"");

}

function checkPrimeSync(candidate, options = kEmptyObject) {
  if (typeof candidate === 'bigint')
    candidate = unsignedBigIntToBuffer(candidate, 'candidate');
  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {
    throw new ERR_INVALID_ARG_TYPE(
      'candidate',
      [
        'ArrayBuffer',
        'TypedArray',
        'Buffer',
        'DataView',
        'bigint',
      ],
      candidate
    );
  }
  validateObject(options, 'options');
  const {
    checks = 0,
  } = options;

  validateUint32(checks, 'options.checks');

  throw new Error(""crypto.checkPrimeSync is unimplemented"");
}

export {
  checkPrime,
  checkPrimeSync,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  getRandomValues,
  randomUUID,
  generatePrime,
  generatePrimeSync,
}

export default {
  checkPrime,
  checkPrimeSync,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  getRandomValues,
  randomUUID,
  generatePrime,
  generatePrimeSync,
};
"
test/crypto/test-crypto-random.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Flags: --pending-deprecation
'use strict';
import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';
// const cryptop = require('crypto').webcrypto;
import { kMaxLength } from 'buffer';

const kMaxInt32 = 2 ** 31 - 1;
const kMaxPossibleLength = Math.min(kMaxLength, kMaxInt32);

common.expectWarning('DeprecationWarning',
                     'crypto.pseudoRandomBytes is deprecated.', 'DEP0115');

{
  [crypto.randomBytes/*, crypto.pseudoRandomBytes*/].forEach((f) => {
    [undefined, null, false, true, {}, []].forEach((value) => {
      const errObj = {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""size"" argument must be of type number.' +
                 common.invalidArgTypeHelper(value)
      };
      assert.throws(() => f(value), errObj);
      assert.throws(() => f(value, common.mustNotCall()), errObj);
    });

    [-1, NaN, 2 ** 32, 2 ** 31].forEach((value) => {
      const errObj = {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""size"" is out of range. It must be >= 0 && <= ' +
                 `${kMaxPossibleLength}. Received ${value}`
      };
      assert.throws(() => f(value), errObj);
      assert.throws(() => f(value, common.mustNotCall()), errObj);
    });

    [0, 1, 2, 4, 16, 256, 1024, 101.2].forEach((len) => {
      f(len, common.mustCall((ex, buf) => {
        assert.strictEqual(ex, null);
        assert.strictEqual(buf.length, Math.floor(len));
        assert.ok(Buffer.isBuffer(buf));
      }));
    });
  });
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  const after = crypto.randomFillSync(buf).toString('hex');
  assert.notStrictEqual(before, after);
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFillSync(buf);
  const after = Buffer.from(buf).toString('hex');
  assert.notStrictEqual(before, after);
}

{
  [
    new Uint16Array(10),
    new Uint32Array(10),
    new Float32Array(10),
    new Float64Array(10),
    new DataView(new ArrayBuffer(10)),
  ].forEach((buf) => {
    const before = Buffer.from(buf.buffer).toString('hex');
    crypto.randomFillSync(buf);
    const after = Buffer.from(buf.buffer).toString('hex');
    assert.notStrictEqual(before, after);
  });
}

/*{
  [
    new Uint16Array(10),
    new Uint32Array(10),
  ].forEach((buf) => {
    const before = Buffer.from(buf.buffer).toString('hex');
    cryptop.getRandomValues(buf);
    const after = Buffer.from(buf.buffer).toString('hex');
    assert.notStrictEqual(before, after);
  });
}*/

{
  [
    new ArrayBuffer(10),
    new SharedArrayBuffer(10),
  ].forEach((buf) => {
    const before = Buffer.from(buf).toString('hex');
    crypto.randomFillSync(buf);
    const after = Buffer.from(buf).toString('hex');
    assert.notStrictEqual(before, after);
  });
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFill(buf, common.mustSucceed((buf) => {
    const after = buf.toString('hex');
    assert.notStrictEqual(before, after);
  }));
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFill(buf, common.mustSucceed((buf) => {
    const after = Buffer.from(buf).toString('hex');
    assert.notStrictEqual(before, after);
  }));
}

{
  [
    new Uint16Array(10),
    new Uint32Array(10),
    new Float32Array(10),
    new Float64Array(10),
    new DataView(new ArrayBuffer(10)),
  ].forEach((buf) => {
    const before = Buffer.from(buf.buffer).toString('hex');
    crypto.randomFill(buf, common.mustSucceed((buf) => {
      const after = Buffer.from(buf.buffer).toString('hex');
      assert.notStrictEqual(before, after);
    }));
  });
}

{
  [
    new ArrayBuffer(10),
    new SharedArrayBuffer(10),
  ].forEach((buf) => {
    const before = Buffer.from(buf).toString('hex');
    crypto.randomFill(buf, common.mustSucceed((buf) => {
      const after = Buffer.from(buf).toString('hex');
      assert.notStrictEqual(before, after);
    }));
  });
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFillSync(buf, 5, 5);
  const after = buf.toString('hex');
  assert.notStrictEqual(before, after);
  assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFillSync(buf, 5, 5);
  const after = Buffer.from(buf).toString('hex');
  assert.notStrictEqual(before, after);
  assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFillSync(buf, 5);
  const after = buf.toString('hex');
  assert.notStrictEqual(before, after);
  assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
}

{
  const buf = Buffer.alloc(10);
  const before = buf.toString('hex');
  crypto.randomFill(buf, 5, 5, common.mustSucceed((buf) => {
    const after = buf.toString('hex');
    assert.notStrictEqual(before, after);
    assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
  }));
}

{
  const buf = new Uint8Array(new Array(10).fill(0));
  const before = Buffer.from(buf).toString('hex');
  crypto.randomFill(buf, 5, 5, common.mustSucceed((buf) => {
    const after = Buffer.from(buf).toString('hex');
    assert.notStrictEqual(before, after);
    assert.deepStrictEqual(before.slice(0, 5), after.slice(0, 5));
  }));
}

{
  [
    Buffer.alloc(10),
    new Uint8Array(new Array(10).fill(0)),
  ].forEach((buf) => {
    const len = Buffer.byteLength(buf);
    assert.strictEqual(len, 10, `Expected byteLength of 10, got ${len}`);

    const typeErrObj = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""offset"" argument must be of type number. ' +
               ""Received type string ('test')""
    };

    assert.throws(() => crypto.randomFillSync(buf, 'test'), typeErrObj);

    assert.throws(
      () => crypto.randomFill(buf, 'test', common.mustNotCall()),
      typeErrObj);

    typeErrObj.message = typeErrObj.message.replace('offset', 'size');
    assert.throws(() => crypto.randomFillSync(buf, 0, 'test'), typeErrObj);

    assert.throws(
      () => crypto.randomFill(buf, 0, 'test', common.mustNotCall()),
      typeErrObj
    );

    [NaN, kMaxPossibleLength + 1, -10, (-1 >>> 0) + 1].forEach((offsetSize) => {
      const errObj = {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""offset"" is out of range. ' +
                 `It must be >= 0 && <= 10. Received ${offsetSize}`
      };

      assert.throws(() => crypto.randomFillSync(buf, offsetSize), errObj);

      assert.throws(
        () => crypto.randomFill(buf, offsetSize, common.mustNotCall()),
        errObj);

      errObj.message = 'The value of ""size"" is out of range. It must be >= ' +
                       `0 && <= ${kMaxPossibleLength}. Received ${offsetSize}`;
      assert.throws(() => crypto.randomFillSync(buf, 1, offsetSize), errObj);

      assert.throws(
        () => crypto.randomFill(buf, 1, offsetSize, common.mustNotCall()),
        errObj
      );
    });

    const rangeErrObj = {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""size + offset"" is out of range. ' +
               'It must be <= 10. Received 11'
    };
    assert.throws(() => crypto.randomFillSync(buf, 1, 10), rangeErrObj);

    assert.throws(
      () => crypto.randomFill(buf, 1, 10, common.mustNotCall()),
      rangeErrObj
    );
  });
}

// https://github.com/nodejs/node-v0.x-archive/issues/5126,
// ""FATAL ERROR: v8::Object::SetIndexedPropertiesToExternalArrayData() length
// exceeds max acceptable value""
assert.throws(
  () => crypto.randomBytes((-1 >>> 0) + 1),
  {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""size"" is out of range. ' +
             `It must be >= 0 && <= ${kMaxPossibleLength}. Received 4294967296`
  }
);

[1, true, NaN, null, undefined, {}, []].forEach((i) => {
  const buf = Buffer.alloc(10);
  assert.throws(
    () => crypto.randomFillSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => crypto.randomFill(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => crypto.randomFill(buf, 0, 10, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
});

[1, true, NaN, null, {}, []].forEach((i) => {
  assert.throws(
    () => crypto.randomBytes(1, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );
});

/*['pseudoRandomBytes', 'prng', 'rng'].forEach((f) => {
  const desc = Object.getOwnPropertyDescriptor(crypto, f);
  assert.ok(desc);
  assert.strictEqual(desc.configurable, true);
  assert.strictEqual(desc.enumerable, false);
});*/


{
  // Asynchronous API
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    crypto.randomInt(3, common.mustSucceed((n) => {
      assert.ok(n >= 0);
      assert.ok(n < 3);
      randomInts.push(n);
      if (randomInts.length === 100) {
        assert.ok(!randomInts.includes(-1));
        assert.ok(randomInts.includes(0));
        assert.ok(randomInts.includes(1));
        assert.ok(randomInts.includes(2));
        assert.ok(!randomInts.includes(3));
      }
    }));
  }
}
{
  // Synchronous API
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    const n = crypto.randomInt(3);
    assert.ok(n >= 0);
    assert.ok(n < 3);
    randomInts.push(n);
  }

  assert.ok(!randomInts.includes(-1));
  assert.ok(randomInts.includes(0));
  assert.ok(randomInts.includes(1));
  assert.ok(randomInts.includes(2));
  assert.ok(!randomInts.includes(3));
}
{
  // Positive range
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    crypto.randomInt(1, 3, common.mustSucceed((n) => {
      assert.ok(n >= 1);
      assert.ok(n < 3);
      randomInts.push(n);
      if (randomInts.length === 100) {
        assert.ok(!randomInts.includes(0));
        assert.ok(randomInts.includes(1));
        assert.ok(randomInts.includes(2));
        assert.ok(!randomInts.includes(3));
      }
    }));
  }
}
{
  // Negative range
  const randomInts = [];
  for (let i = 0; i < 100; i++) {
    crypto.randomInt(-10, -8, common.mustSucceed((n) => {
      assert.ok(n >= -10);
      assert.ok(n < -8);
      randomInts.push(n);
      if (randomInts.length === 100) {
        assert.ok(!randomInts.includes(-11));
        assert.ok(randomInts.includes(-10));
        assert.ok(randomInts.includes(-9));
        assert.ok(!randomInts.includes(-8));
      }
    }));
  }
}
{

  ['10', true, NaN, null, {}, []].forEach((i) => {
    const invalidMinError = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""min"" argument must be a safe integer.' +
               `${common.invalidArgTypeHelper(i)}`,
    };
    const invalidMaxError = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""max"" argument must be a safe integer.' +
               `${common.invalidArgTypeHelper(i)}`,
    };

    assert.throws(
      () => crypto.randomInt(i, 100),
      invalidMinError
    );
    assert.throws(
      () => crypto.randomInt(i, 100, common.mustNotCall()),
      invalidMinError
    );
    assert.throws(
      () => crypto.randomInt(i),
      invalidMaxError
    );
    assert.throws(
      () => crypto.randomInt(i, common.mustNotCall()),
      invalidMaxError
    );
    assert.throws(
      () => crypto.randomInt(0, i, common.mustNotCall()),
      invalidMaxError
    );
    assert.throws(
      () => crypto.randomInt(0, i),
      invalidMaxError
    );
  });

  const maxInt = Number.MAX_SAFE_INTEGER;
  const minInt = Number.MIN_SAFE_INTEGER;

  crypto.randomInt(minInt, minInt + 5, common.mustSucceed());
  crypto.randomInt(maxInt - 5, maxInt, common.mustSucceed());

  assert.throws(
    () => crypto.randomInt(minInt - 1, minInt + 5, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""min"" argument must be a safe integer.' +
      `${common.invalidArgTypeHelper(minInt - 1)}`,
    }
  );

  assert.throws(
    () => crypto.randomInt(maxInt + 1, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""max"" argument must be a safe integer.' +
      `${common.invalidArgTypeHelper(maxInt + 1)}`,
    }
  );

  crypto.randomInt(1, common.mustSucceed());
  crypto.randomInt(0, 1, common.mustSucceed());
  for (const arg of [[0], [1, 1], [3, 2], [-5, -5], [11, -10]]) {
    assert.throws(() => crypto.randomInt(...arg, common.mustNotCall()), {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""max"" is out of range. It must be greater than ' +
      `the value of ""min"" (${arg[arg.length - 2] || 0}). ` +
      `Received ${arg[arg.length - 1]}`
    });
  }

  const MAX_RANGE = 0xFFFF_FFFF_FFFF;
  crypto.randomInt(MAX_RANGE, common.mustSucceed());
  crypto.randomInt(1, MAX_RANGE + 1, common.mustSucceed());
  assert.throws(
    () => crypto.randomInt(1, MAX_RANGE + 2, common.mustNotCall()),
    {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""max - min"" is out of range. ' +
               `It must be <= ${MAX_RANGE}. ` +
               'Received 281_474_976_710_656'
    }
  );

  assert.throws(() => crypto.randomInt(MAX_RANGE + 1, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""max"" is out of range. ' +
             `It must be <= ${MAX_RANGE}. ` +
             'Received 281_474_976_710_656'
  });

  [true, NaN, null, {}, [], 10].forEach((i) => {
    const cbError = {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    };
    assert.throws(() => crypto.randomInt(0, 1, i), cbError);
  });
}

{
  // Verify that it doesn't throw or abort
  crypto.randomFill(new Uint16Array(10), 0, common.mustSucceed());
  crypto.randomFill(new Uint32Array(10), 0, common.mustSucceed());
  crypto.randomFill(new Uint32Array(10), 0, 1, common.mustSucceed());
}
"
src/internal_module/ggml/mod.rs,"use std::str::FromStr;

use chat_prompts::{
    chat::{BuildChatPrompt, ChatPrompt},
    PromptTemplateType,
};
use endpoints::chat::{ChatCompletionRequest, ChatCompletionRequestMessage, ChatCompletionRole};
use wasi_nn::BackendError;

use crate::{
    register_class, AsObject, Context, JsClassDef, JsClassTool, JsModuleDef, JsObject, JsValue,
    SelfRefJsValue,
};

struct WasiNNGraph(wasi_nn::Graph);

impl JsClassDef for WasiNNGraph {
    type RefType = WasiNNGraph;

    const CLASS_NAME: &'static str = ""Graph"";

    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] =
        &[(""init_execution_context"", 0, Self::js_init_execution_context)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(
        _ctx: &mut crate::Context,
        _argv: &[JsValue],
    ) -> Result<Self::RefType, JsValue> {
        Err(JsValue::UnDefined)
    }
}

impl WasiNNGraph {
    pub fn js_init_execution_context(
        &mut self,
        this: &mut JsObject,
        js_ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        let r = Self::self_ref_opaque_mut(this.clone().into(), |v| v.0.init_execution_context());
        match r {
            None => JsValue::UnDefined,
            Some(Ok(ctx)) => {
                WasiNNGraphExecutionContext::wrap_obj(js_ctx, WasiNNGraphExecutionContext { ctx })
            }
            Some(Err(e)) => {
                let err = ggml_error_to_js_error(js_ctx, e);
                js_ctx.throw_error(err).into()
            }
        }
    }
}

struct WasiNNGraphExecutionContext {
    ctx: SelfRefJsValue<WasiNNGraph, wasi_nn::GraphExecutionContext<'static>>,
}

impl JsClassDef for WasiNNGraphExecutionContext {
    type RefType = Self;

    const CLASS_NAME: &'static str = ""GraphExecutionContext"";

    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] = &[
        (""set_input"", 4, Self::js_set_input),
        (""compute"", 0, Self::js_compute),
        (""compute_single"", 0, Self::js_compute_single),
        (""fini_single"", 0, Self::js_fini_single),
        (""get_output"", 2, Self::js_get_output),
        (""get_output_single"", 2, Self::js_get_output_single),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        Err(JsValue::UnDefined)
    }
}

lazy_static::lazy_static! {
    static ref MAX_OUTPUT_SIZE: usize ={
        std::env::var(""GGML_OUTPUT_BUFF_SIZE"")
        .unwrap_or_default()
        .parse()
        .unwrap_or(1024)
    };
}

fn ggml_error_to_js_error(ctx: &mut Context, error: wasi_nn::Error) -> JsValue {
    let (t, msg) = match error {
        wasi_nn::Error::IoError(e) => {
            let mut js_err = ctx.new_error(e.to_string().as_str());
            if let JsValue::Object(js_err) = &mut js_err {
                js_err.set(""type"", ctx.new_string(""IO"").into());
            };
            return js_err;
        }
        wasi_nn::Error::BackendError(BackendError::InvalidArgument) => {
            (""BackendError"", ""InvalidArgument"")
        }
        wasi_nn::Error::BackendError(BackendError::InvalidEncoding) => {
            (""BackendError"", ""InvalidEncoding"")
        }
        wasi_nn::Error::BackendError(BackendError::MissingMemory) => {
            (""BackendError"", ""MissingMemory"")
        }
        wasi_nn::Error::BackendError(BackendError::Busy) => (""BackendError"", ""Busy""),
        wasi_nn::Error::BackendError(BackendError::RuntimeError) => {
            (""BackendError"", ""RuntimeError"")
        }
        wasi_nn::Error::BackendError(BackendError::UnsupportedOperation) => {
            (""BackendError"", ""UnsupportedOperation"")
        }
        wasi_nn::Error::BackendError(BackendError::TooLarge) => (""BackendError"", ""TooLarge""),
        wasi_nn::Error::BackendError(BackendError::NotFound) => (""BackendError"", ""NotFound""),
        wasi_nn::Error::BackendError(BackendError::EndOfSequence) => {
            (""BackendError"", ""EndOfSequence"")
        }
        wasi_nn::Error::BackendError(BackendError::ContextFull) => (""BackendError"", ""ContextFull""),
        wasi_nn::Error::BackendError(BackendError::PromptTooLong) => {
            (""BackendError"", ""PromptTooLong"")
        }
        wasi_nn::Error::BackendError(BackendError::UnknownError(i)) => {
            let mut js_err = ctx.new_error(format!(""UnknownError:{i}"").as_str());
            if let JsValue::Object(js_err) = &mut js_err {
                js_err.set(""type"", ctx.new_string(""BackendError"").into());
            };
            return js_err;
        }
    };
    let mut js_err = ctx.new_error(msg);
    if let JsValue::Object(js_err) = &mut js_err {
        js_err.set(""type"", ctx.new_string(t).into());
    };
    js_err
}

impl WasiNNGraphExecutionContext {
    fn js_set_input(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let index = if let Some(JsValue::Int(index)) = argv.get(0) {
            *index as usize
        } else {
            return ctx.throw_type_error(""'index' must be of type int"").into();
        };

        let tensor_buf = match argv.get(1) {
            Some(JsValue::ArrayBuffer(buf)) => buf.as_ref(),
            Some(JsValue::String(s)) => s.as_str().trim().as_bytes(),
            _ => {
                return ctx
                    .throw_type_error(""'tensor_buf' must be of type buffer or string"")
                    .into();
            }
        };

        let dimensions = if let Some(JsValue::Array(arr)) = argv.get(2) {
            match arr.to_vec() {
                Ok(dimensions) => {
                    let mut dimension_arr = Vec::with_capacity(dimensions.len());

                    for i in dimensions {
                        let v = match i {
                            JsValue::Int(i) => i as usize,
                            JsValue::Float(i) => i as usize,
                            _ => {
                                return ctx
                                    .throw_type_error(""'dimensions' must be of type number array"")
                                    .into()
                            }
                        };
                        dimension_arr.push(v);
                    }
                    dimension_arr
                }
                Err(e) => return e.into(),
            }
        } else {
            return ctx
                .throw_type_error(""'dimensions' must be of type array"")
                .into();
        };

        let tensor_type = if let Some(JsValue::Int(input_type)) = argv.get(3) {
            let input_type = *input_type;
            match input_type {
                0 => wasi_nn::TensorType::F16,
                1 => wasi_nn::TensorType::F32,
                2 => wasi_nn::TensorType::F64,
                3 => wasi_nn::TensorType::U8,
                4 => wasi_nn::TensorType::I32,
                5 => wasi_nn::TensorType::I64,

                _ => {
                    return ctx
                        .throw_type_error(&format!(""undefined `input_type` {}"", input_type))
                        .into();
                }
            }
        } else {
            return ctx.throw_type_error(""'index' must be of type int"").into();
        };

        if let Err(e) = self
            .ctx
            .set_input(index, tensor_type, &dimensions, tensor_buf)
        {
            let err = ggml_error_to_js_error(ctx, e);
            ctx.throw_error(err).into()
        } else {
            JsValue::UnDefined
        }
    }

    fn js_compute(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        if let Err(e) = self.ctx.compute() {
            let err = ggml_error_to_js_error(ctx, e);
            ctx.throw_error(err).into()
        } else {
            JsValue::UnDefined
        }
    }

    fn js_compute_single(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        if let Err(e) = self.ctx.compute_single() {
            let err = ggml_error_to_js_error(ctx, e);
            ctx.throw_error(err).into()
        } else {
            JsValue::UnDefined
        }
    }

    fn js_fini_single(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        if let Err(e) = self.ctx.fini_single() {
            let err = ggml_error_to_js_error(ctx, e);
            ctx.throw_error(err).into()
        } else {
            JsValue::UnDefined
        }
    }

    fn js_get_output_single(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let index = if let Some(JsValue::Int(index)) = argv.get(0) {
            *index as usize
        } else {
            return ctx.throw_type_error(""'index' must be of type int"").into();
        };

        let output_type = if let Some(JsValue::Int(type_index)) = argv.get(1) {
            *type_index
        } else {
            return ctx
                .throw_type_error(""'output_type' must be of type Int"")
                .into();
        };

        let mut output_buffer = vec![0u8; *MAX_OUTPUT_SIZE];

        match self.ctx.get_output_single(index, output_buffer.as_mut()) {
            Ok(n) => match output_type {
                0 => ctx.new_array_buffer(&output_buffer[0..n]).into(),
                _ => ctx
                    .new_string(unsafe { std::str::from_utf8_unchecked(&output_buffer[0..n]) })
                    .into(),
            },
            Err(e) => {
                let err = ggml_error_to_js_error(ctx, e);
                ctx.throw_error(err).into()
            }
        }
    }

    fn js_get_output(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let index = if let Some(JsValue::Int(index)) = argv.get(0) {
            *index as usize
        } else {
            return ctx.throw_type_error(""'index' must be of type int"").into();
        };

        let mut output = if let Some(JsValue::ArrayBuffer(buf)) = argv.get(1) {
            buf.clone()
        } else {
            return ctx
                .throw_type_error(""'output' must be of type buffer"")
                .into();
        };

        match self.ctx.get_output(index, output.as_mut()) {
            Ok(n) => JsValue::Int(n as i32),
            Err(e) => {
                let err = ggml_error_to_js_error(ctx, e);
                ctx.throw_error(err).into()
            }
        }
    }
}

fn js_build_graph_from_cache(ctx: &mut Context, _this: JsValue, param: &[JsValue]) -> JsValue {
    if let Some(
        [JsValue::Int(target_index), JsValue::String(metadata), JsValue::String(module_name)],
    ) = param.get(0..3)
    {
        let target = match *target_index {
            0 => wasi_nn::ExecutionTarget::CPU,
            1 => wasi_nn::ExecutionTarget::GPU,
            2 => wasi_nn::ExecutionTarget::TPU,
            _ => wasi_nn::ExecutionTarget::AUTO,
        };
        let config = wasi_nn::GraphBuilder::new(wasi_nn::GraphEncoding::Ggml, target)
            .config(metadata.to_string())
            .build_from_cache(module_name.as_str());

        match config {
            Ok(g) => WasiNNGraph::wrap_obj(ctx, WasiNNGraph(g)),
            Err(e) => {
                let err = ggml_error_to_js_error(ctx, e);
                ctx.throw_error(err).into()
            }
        }
    } else {
        JsValue::UnDefined
    }
}

pub fn init_wasi_nn_ggml_module(ctx: &mut Context) {
    ctx.register_fn_module(
        ""_wasi_nn_ggml"",
        &[
            WasiNNGraph::CLASS_NAME,
            WasiNNGraphExecutionContext::CLASS_NAME,
            ""build_graph_from_cache"",
        ],
        |ctx, m| {
            let class_ctor = register_class::<WasiNNGraph>(ctx);
            m.add_export(WasiNNGraph::CLASS_NAME, class_ctor);

            let class_ctor = register_class::<WasiNNGraphExecutionContext>(ctx);
            m.add_export(WasiNNGraphExecutionContext::CLASS_NAME, class_ctor);

            let f = ctx.wrap_function(""build_graph_from_cache"", js_build_graph_from_cache);
            m.add_export(""build_graph_from_cache"", f.into());
        },
    )
}

struct GGMLChatPromptTemplate {
    prompt: ChatPrompt,
}

fn create_prompt_template(template_ty: PromptTemplateType) -> ChatPrompt {
    match template_ty {
        PromptTemplateType::Llama2Chat => {
            ChatPrompt::Llama2ChatPrompt(chat_prompts::chat::llama::Llama2ChatPrompt::default())
        }
        PromptTemplateType::MistralInstruct => ChatPrompt::MistralInstructPrompt(
            chat_prompts::chat::mistral::MistralInstructPrompt::default(),
        ),
        PromptTemplateType::MistralLite => {
            ChatPrompt::MistralLitePrompt(chat_prompts::chat::mistral::MistralLitePrompt::default())
        }
        PromptTemplateType::OpenChat => {
            ChatPrompt::OpenChatPrompt(chat_prompts::chat::openchat::OpenChatPrompt::default())
        }
        PromptTemplateType::CodeLlama => ChatPrompt::CodeLlamaInstructPrompt(
            chat_prompts::chat::llama::CodeLlamaInstructPrompt::default(),
        ),
        PromptTemplateType::BelleLlama2Chat => ChatPrompt::BelleLlama2ChatPrompt(
            chat_prompts::chat::belle::BelleLlama2ChatPrompt::default(),
        ),
        PromptTemplateType::VicunaChat => {
            ChatPrompt::VicunaChatPrompt(chat_prompts::chat::vicuna::VicunaChatPrompt::default())
        }
        PromptTemplateType::Vicuna11Chat => {
            ChatPrompt::Vicuna11ChatPrompt(chat_prompts::chat::vicuna::Vicuna11ChatPrompt::default())
        }
        PromptTemplateType::ChatML => {
            ChatPrompt::ChatMLPrompt(chat_prompts::chat::chatml::ChatMLPrompt::default())
        }
        PromptTemplateType::Baichuan2 => ChatPrompt::Baichuan2ChatPrompt(
            chat_prompts::chat::baichuan::Baichuan2ChatPrompt::default(),
        ),
        PromptTemplateType::WizardCoder => {
            ChatPrompt::WizardCoderPrompt(chat_prompts::chat::wizard::WizardCoderPrompt::default())
        }
        PromptTemplateType::Zephyr => {
            ChatPrompt::ZephyrChatPrompt(chat_prompts::chat::zephyr::ZephyrChatPrompt::default())
        }
        PromptTemplateType::IntelNeural => {
            ChatPrompt::NeuralChatPrompt(chat_prompts::chat::intel::NeuralChatPrompt::default())
        }
        PromptTemplateType::DeepseekChat => ChatPrompt::DeepseekChatPrompt(
            chat_prompts::chat::deepseek::DeepseekChatPrompt::default(),
        ),
        PromptTemplateType::DeepseekCoder => ChatPrompt::DeepseekCoderPrompt(
            chat_prompts::chat::deepseek::DeepseekCoderPrompt::default(),
        ),
        PromptTemplateType::SolarInstruct => ChatPrompt::SolarInstructPrompt(
            chat_prompts::chat::solar::SolarInstructPrompt::default(),
        ),
    }
}

impl GGMLChatPromptTemplate {
    fn js_build(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some(JsValue::Object(js_obj)) = argv.first() {
            let mut js_obj = js_obj.clone().into();
            if let Some(req) = GGMLChatCompletionRequest::opaque_mut(&mut js_obj) {
                return match self.prompt.build(&mut req.req.messages) {
                    Ok(s) => ctx.new_string(s.as_str()).into(),
                    Err(e) => {
                        let error = ctx.new_error(e.to_string().as_str());
                        ctx.throw_error(error).into()
                    }
                };
            }
        }
        ctx.throw_type_error(""'request' must be of type GGMLChatCompletionRequest"")
            .into()
    }
}

impl JsClassDef for GGMLChatPromptTemplate {
    type RefType = GGMLChatPromptTemplate;

    const CLASS_NAME: &'static str = ""GGMLChatPrompt"";

    const CONSTRUCTOR_ARGC: u8 = 1;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] = &[(""build"", 1, Self::js_build)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        if let Some(JsValue::String(type_str)) = argv.first() {
            match PromptTemplateType::from_str(type_str.as_str()) {
                Ok(template_ty) => Ok(Self {
                    prompt: create_prompt_template(template_ty),
                }),
                Err(_) => Err(JsValue::UnDefined),
            }
        } else {
            Err(ctx
                .throw_type_error(""'tensor_buf' must be of type buffer or string"")
                .into())
        }
    }
}

struct GGMLChatCompletionRequest {
    req: ChatCompletionRequest,
}

impl GGMLChatCompletionRequest {
    fn js_push_message(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        if let Some([JsValue::String(role), JsValue::String(content)]) = argv.get(0..2) {
            let role =
                match role.as_str() {
                    ""system"" => ChatCompletionRole::System,
                    ""user"" => ChatCompletionRole::User,
                    ""function"" => ChatCompletionRole::Function,
                    ""assistant"" => ChatCompletionRole::Assistant,
                    _ => return ctx
                        .throw_type_error(
                            ""`role` must be either `system`, `user`, `assistant`, or `function`."",
                        )
                        .into(),
                };
            self.req
                .messages
                .push(ChatCompletionRequestMessage::new(role, content.as_str()));
            JsValue::UnDefined
        } else {
            JsValue::UnDefined
        }
    }
}

impl JsClassDef for GGMLChatCompletionRequest {
    type RefType = GGMLChatCompletionRequest;

    const CLASS_NAME: &'static str = ""GGMLChatCompletionRequest"";

    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] =
        &[(""push_message"", 2, Self::js_push_message)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        Ok(Self {
            req: ChatCompletionRequest::default(),
        })
    }
}

pub fn init_ggml_template_module(ctx: &mut Context) {
    ctx.register_fn_module(
        ""_wasi_nn_ggml_template"",
        &[
            GGMLChatCompletionRequest::CLASS_NAME,
            GGMLChatPromptTemplate::CLASS_NAME,
        ],
        |ctx, m| {
            let class_ctor = register_class::<GGMLChatCompletionRequest>(ctx);
            m.add_export(GGMLChatCompletionRequest::CLASS_NAME, class_ctor);

            let class_ctor = register_class::<GGMLChatPromptTemplate>(ctx);
            m.add_export(GGMLChatPromptTemplate::CLASS_NAME, class_ctor);
        },
    )
}
"
example_js/tensorflow_demo/imagenet_slim_labels.txt,"dummy
tench
goldfish
great white shark
tiger shark
hammerhead
electric ray
stingray
cock
hen
ostrich
brambling
goldfinch
house finch
junco
indigo bunting
robin
bulbul
jay
magpie
chickadee
water ouzel
kite
bald eagle
vulture
great grey owl
European fire salamander
common newt
eft
spotted salamander
axolotl
bullfrog
tree frog
tailed frog
loggerhead
leatherback turtle
mud turtle
terrapin
box turtle
banded gecko
common iguana
American chameleon
whiptail
agama
frilled lizard
alligator lizard
Gila monster
green lizard
African chameleon
Komodo dragon
African crocodile
American alligator
triceratops
thunder snake
ringneck snake
hognose snake
green snake
king snake
garter snake
water snake
vine snake
night snake
boa constrictor
rock python
Indian cobra
green mamba
sea snake
horned viper
diamondback
sidewinder
trilobite
harvestman
scorpion
black and gold garden spider
barn spider
garden spider
black widow
tarantula
wolf spider
tick
centipede
black grouse
ptarmigan
ruffed grouse
prairie chicken
peacock
quail
partridge
African grey
macaw
sulphur-crested cockatoo
lorikeet
coucal
bee eater
hornbill
hummingbird
jacamar
toucan
drake
red-breasted merganser
goose
black swan
tusker
echidna
platypus
wallaby
koala
wombat
jellyfish
sea anemone
brain coral
flatworm
nematode
conch
snail
slug
sea slug
chiton
chambered nautilus
Dungeness crab
rock crab
fiddler crab
king crab
American lobster
spiny lobster
crayfish
hermit crab
isopod
white stork
black stork
spoonbill
flamingo
little blue heron
American egret
bittern
crane
limpkin
European gallinule
American coot
bustard
ruddy turnstone
red-backed sandpiper
redshank
dowitcher
oystercatcher
pelican
king penguin
albatross
grey whale
killer whale
dugong
sea lion
Chihuahua
Japanese spaniel
Maltese dog
Pekinese
Shih-Tzu
Blenheim spaniel
papillon
toy terrier
Rhodesian ridgeback
Afghan hound
basset
beagle
bloodhound
bluetick
black-and-tan coonhound
Walker hound
English foxhound
redbone
borzoi
Irish wolfhound
Italian greyhound
whippet
Ibizan hound
Norwegian elkhound
otterhound
Saluki
Scottish deerhound
Weimaraner
Staffordshire bullterrier
American Staffordshire terrier
Bedlington terrier
Border terrier
Kerry blue terrier
Irish terrier
Norfolk terrier
Norwich terrier
Yorkshire terrier
wire-haired fox terrier
Lakeland terrier
Sealyham terrier
Airedale
cairn
Australian terrier
Dandie Dinmont
Boston bull
miniature schnauzer
giant schnauzer
standard schnauzer
Scotch terrier
Tibetan terrier
silky terrier
soft-coated wheaten terrier
West Highland white terrier
Lhasa
flat-coated retriever
curly-coated retriever
golden retriever
Labrador retriever
Chesapeake Bay retriever
German short-haired pointer
vizsla
English setter
Irish setter
Gordon setter
Brittany spaniel
clumber
English springer
Welsh springer spaniel
cocker spaniel
Sussex spaniel
Irish water spaniel
kuvasz
schipperke
groenendael
malinois
briard
kelpie
komondor
Old English sheepdog
Shetland sheepdog
collie
Border collie
Bouvier des Flandres
Rottweiler
German shepherd
Doberman
miniature pinscher
Greater Swiss Mountain dog
Bernese mountain dog
Appenzeller
EntleBucher
boxer
bull mastiff
Tibetan mastiff
French bulldog
Great Dane
Saint Bernard
Eskimo dog
malamute
Siberian husky
dalmatian
affenpinscher
basenji
pug
Leonberg
Newfoundland
Great Pyrenees
Samoyed
Pomeranian
chow
keeshond
Brabancon griffon
Pembroke
Cardigan
toy poodle
miniature poodle
standard poodle
Mexican hairless
timber wolf
white wolf
red wolf
coyote
dingo
dhole
African hunting dog
hyena
red fox
kit fox
Arctic fox
grey fox
tabby
tiger cat
Persian cat
Siamese cat
Egyptian cat
cougar
lynx
leopard
snow leopard
jaguar
lion
tiger
cheetah
brown bear
American black bear
ice bear
sloth bear
mongoose
meerkat
tiger beetle
ladybug
ground beetle
long-horned beetle
leaf beetle
dung beetle
rhinoceros beetle
weevil
fly
bee
ant
grasshopper
cricket
walking stick
cockroach
mantis
cicada
leafhopper
lacewing
dragonfly
damselfly
admiral
ringlet
monarch
cabbage butterfly
sulphur butterfly
lycaenid
starfish
sea urchin
sea cucumber
wood rabbit
hare
Angora
hamster
porcupine
fox squirrel
marmot
beaver
guinea pig
sorrel
zebra
hog
wild boar
warthog
hippopotamus
ox
water buffalo
bison
ram
bighorn
ibex
hartebeest
impala
gazelle
Arabian camel
llama
weasel
mink
polecat
black-footed ferret
otter
skunk
badger
armadillo
three-toed sloth
orangutan
gorilla
chimpanzee
gibbon
siamang
guenon
patas
baboon
macaque
langur
colobus
proboscis monkey
marmoset
capuchin
howler monkey
titi
spider monkey
squirrel monkey
Madagascar cat
indri
Indian elephant
African elephant
lesser panda
giant panda
barracouta
eel
coho
rock beauty
anemone fish
sturgeon
gar
lionfish
puffer
abacus
abaya
academic gown
accordion
acoustic guitar
aircraft carrier
airliner
airship
altar
ambulance
amphibian
analog clock
apiary
apron
ashcan
assault rifle
backpack
bakery
balance beam
balloon
ballpoint
Band Aid
banjo
bannister
barbell
barber chair
barbershop
barn
barometer
barrel
barrow
baseball
basketball
bassinet
bassoon
bathing cap
bath towel
bathtub
beach wagon
beacon
beaker
bearskin
beer bottle
beer glass
bell cote
bib
bicycle-built-for-two
bikini
binder
binoculars
birdhouse
boathouse
bobsled
bolo tie
bonnet
bookcase
bookshop
bottlecap
bow
bow tie
brass
brassiere
breakwater
breastplate
broom
bucket
buckle
bulletproof vest
bullet train
butcher shop
cab
caldron
candle
cannon
canoe
can opener
cardigan
car mirror
carousel
carpenter's kit
carton
car wheel
cash machine
cassette
cassette player
castle
catamaran
CD player
cello
cellular telephone
chain
chainlink fence
chain mail
chain saw
chest
chiffonier
chime
china cabinet
Christmas stocking
church
cinema
cleaver
cliff dwelling
cloak
clog
cocktail shaker
coffee mug
coffeepot
coil
combination lock
computer keyboard
confectionery
container ship
convertible
corkscrew
cornet
cowboy boot
cowboy hat
cradle
crane
crash helmet
crate
crib
Crock Pot
croquet ball
crutch
cuirass
dam
desk
desktop computer
dial telephone
diaper
digital clock
digital watch
dining table
dishrag
dishwasher
disk brake
dock
dogsled
dome
doormat
drilling platform
drum
drumstick
dumbbell
Dutch oven
electric fan
electric guitar
electric locomotive
entertainment center
envelope
espresso maker
face powder
feather boa
file
fireboat
fire engine
fire screen
flagpole
flute
folding chair
football helmet
forklift
fountain
fountain pen
four-poster
freight car
French horn
frying pan
fur coat
garbage truck
gasmask
gas pump
goblet
go-kart
golf ball
golfcart
gondola
gong
gown
grand piano
greenhouse
grille
grocery store
guillotine
hair slide
hair spray
half track
hammer
hamper
hand blower
hand-held computer
handkerchief
hard disc
harmonica
harp
harvester
hatchet
holster
home theater
honeycomb
hook
hoopskirt
horizontal bar
horse cart
hourglass
iPod
iron
jack-o'-lantern
jean
jeep
jersey
jigsaw puzzle
jinrikisha
joystick
kimono
knee pad
knot
lab coat
ladle
lampshade
laptop
lawn mower
lens cap
letter opener
library
lifeboat
lighter
limousine
liner
lipstick
Loafer
lotion
loudspeaker
loupe
lumbermill
magnetic compass
mailbag
mailbox
maillot
maillot
manhole cover
maraca
marimba
mask
matchstick
maypole
maze
measuring cup
medicine chest
megalith
microphone
microwave
military uniform
milk can
minibus
miniskirt
minivan
missile
mitten
mixing bowl
mobile home
Model T
modem
monastery
monitor
moped
mortar
mortarboard
mosque
mosquito net
motor scooter
mountain bike
mountain tent
mouse
mousetrap
moving van
muzzle
nail
neck brace
necklace
nipple
notebook
obelisk
oboe
ocarina
odometer
oil filter
organ
oscilloscope
overskirt
oxcart
oxygen mask
packet
paddle
paddlewheel
padlock
paintbrush
pajama
palace
panpipe
paper towel
parachute
parallel bars
park bench
parking meter
passenger car
patio
pay-phone
pedestal
pencil box
pencil sharpener
perfume
Petri dish
photocopier
pick
pickelhaube
picket fence
pickup
pier
piggy bank
pill bottle
pillow
ping-pong ball
pinwheel
pirate
pitcher
plane
planetarium
plastic bag
plate rack
plow
plunger
Polaroid camera
pole
police van
poncho
pool table
pop bottle
pot
potter's wheel
power drill
prayer rug
printer
prison
projectile
projector
puck
punching bag
purse
quill
quilt
racer
racket
radiator
radio
radio telescope
rain barrel
recreational vehicle
reel
reflex camera
refrigerator
remote control
restaurant
revolver
rifle
rocking chair
rotisserie
rubber eraser
rugby ball
rule
running shoe
safe
safety pin
saltshaker
sandal
sarong
sax
scabbard
scale
school bus
schooner
scoreboard
screen
screw
screwdriver
seat belt
sewing machine
shield
shoe shop
shoji
shopping basket
shopping cart
shovel
shower cap
shower curtain
ski
ski mask
sleeping bag
slide rule
sliding door
slot
snorkel
snowmobile
snowplow
soap dispenser
soccer ball
sock
solar dish
sombrero
soup bowl
space bar
space heater
space shuttle
spatula
speedboat
spider web
spindle
sports car
spotlight
stage
steam locomotive
steel arch bridge
steel drum
stethoscope
stole
stone wall
stopwatch
stove
strainer
streetcar
stretcher
studio couch
stupa
submarine
suit
sundial
sunglass
sunglasses
sunscreen
suspension bridge
swab
sweatshirt
swimming trunks
swing
switch
syringe
table lamp
tank
tape player
teapot
teddy
television
tennis ball
thatch
theater curtain
thimble
thresher
throne
tile roof
toaster
tobacco shop
toilet seat
torch
totem pole
tow truck
toyshop
tractor
trailer truck
tray
trench coat
tricycle
trimaran
tripod
triumphal arch
trolleybus
trombone
tub
turnstile
typewriter keyboard
umbrella
unicycle
upright
vacuum
vase
vault
velvet
vending machine
vestment
viaduct
violin
volleyball
waffle iron
wall clock
wallet
wardrobe
warplane
washbasin
washer
water bottle
water jug
water tower
whiskey jug
whistle
wig
window screen
window shade
Windsor tie
wine bottle
wing
wok
wooden spoon
wool
worm fence
wreck
yawl
yurt
web site
comic book
crossword puzzle
street sign
traffic light
book jacket
menu
plate
guacamole
consomme
hot pot
trifle
ice cream
ice lolly
French loaf
bagel
pretzel
cheeseburger
hotdog
mashed potato
head cabbage
broccoli
cauliflower
zucchini
spaghetti squash
acorn squash
butternut squash
cucumber
artichoke
bell pepper
cardoon
mushroom
Granny Smith
strawberry
orange
lemon
fig
pineapple
banana
jackfruit
custard apple
pomegranate
hay
carbonara
chocolate sauce
dough
meat loaf
pizza
potpie
burrito
red wine
espresso
cup
eggnog
alp
bubble
cliff
coral reef
geyser
lakeside
promontory
sandbar
seashore
valley
volcano
ballplayer
groom
scuba diver
rapeseed
daisy
yellow lady's slipper
corn
acorn
hip
buckeye
coral fungus
agaric
gyromitra
stinkhorn
earthstar
hen-of-the-woods
bolete
ear
toilet tissue
"
src/internal_module/wasi_net_module.rs,"use std::io::Write;

use crate::event_loop::{AsyncTcpConn, AsyncTcpServer, AsyncTlsConn};
use crate::*;

#[cfg(feature = ""tls"")]
impl AsyncTlsConn {
    pub fn js_connect(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
        use wasmedge_wasi_socket::ToSocketAddrs;
        let host = argv.get(0);
        let port = argv.get(1);
        let timeout = argv.get(2);

        let nctx = ctx.clone();

        if let (Some(JsValue::String(host)), Some(JsValue::Int(port))) = (host, port) {
            let timeout = if let Some(JsValue::Int(timeout)) = timeout {
                Some(std::time::Duration::from_millis((*timeout) as u64))
            } else {
                None
            };

            let host = host.to_string();
            let port = *port as u16;

            let pp = if let Some(duration) = timeout {
                ctx.future_to_promise(async move {
                    let mut ctx = nctx;
                    match tokio::time::timeout(
                        duration,
                        AsyncTlsConn::async_connect((host.as_str(), port), &host),
                    )
                    .await
                    {
                        Ok(Ok(conn)) => Ok(Self::wrap_obj(&mut ctx, conn)),
                        Ok(Err(e)) => Err(ctx.new_error(e.to_string().as_str())),
                        Err(e) => {
                            let err =
                                std::io::Error::new(std::io::ErrorKind::TimedOut, e.to_string());
                            Err(ctx.new_error(err.to_string().as_str()).into())
                        }
                    }
                })
            } else {
                ctx.future_to_promise(async move {
                    let mut ctx = nctx;
                    match AsyncTlsConn::async_connect((host.as_str(), port), &host).await {
                        Ok(conn) => Ok(Self::wrap_obj(&mut ctx, conn)),
                        Err(e) => Err(ctx.new_error(e.to_string().as_str())),
                    }
                })
            };
            pp
        } else {
            JsValue::UnDefined
        }
    }

    pub fn on(
        _this_val: &mut Self,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        JsValue::UnDefined
    }

    pub fn js_read(
        _this_val: &mut Self,
        this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let mut js_obj = this_obj.clone().into();
        let n_ctx = ctx.clone();
        if let Some(JsValue::Int(timeout)) = argv.get(0) {
            let duration = std::time::Duration::from_millis((*timeout) as u64);
            ctx.future_to_promise(async move {
                let mut ctx = n_ctx;
                let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                match tokio::time::timeout(duration, this_val.async_read_all()).await {
                    Ok(Ok(data)) => {
                        if data.len() > 0 {
                            let buff = ctx.new_array_buffer(data.as_slice());
                            Ok(JsValue::ArrayBuffer(buff))
                        } else {
                            Ok(JsValue::UnDefined)
                        }
                    }
                    Ok(Err(err)) => Err(ctx.new_error(err.to_string().as_str()).into()),
                    Err(e) => {
                        let err = std::io::Error::new(std::io::ErrorKind::TimedOut, e.to_string());
                        Err(ctx.new_error(err.to_string().as_str()).into())
                    }
                }
            })
        } else {
            ctx.future_to_promise(async move {
                let mut ctx = n_ctx;
                let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                match this_val.async_read_all().await {
                    Ok(data) => {
                        if data.len() > 0 {
                            let buff = ctx.new_array_buffer(data.as_slice());
                            log::trace!(""async_read_all return ArrayBuffer"");
                            Ok(JsValue::ArrayBuffer(buff))
                        } else {
                            Ok(JsValue::UnDefined)
                        }
                    }
                    Err(err) => Err(ctx.new_error(err.to_string().as_str()).into()),
                }
            })
        }
    }

    pub fn js_write(
        _this_val: &mut AsyncTlsConn,
        this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let mut js_obj = JsValue::Object(this_obj.clone());
        match argv.get(0) {
            Some(JsValue::String(s)) => {
                let data = s.to_string();
                ctx.future_to_promise(async move {
                    let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(data.as_bytes()).await;
                    Ok(JsValue::UnDefined)
                });
            }
            Some(JsValue::ArrayBuffer(buff)) => {
                let data = buff.to_vec();
                ctx.future_to_promise(async move {
                    let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(&data).await;
                    Ok(JsValue::UnDefined)
                });
            }
            Some(JsValue::Object(o)) => {
                let data = o.to_string();
                ctx.future_to_promise(async move {
                    let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(data.as_bytes()).await;
                    Ok(JsValue::UnDefined)
                });
            }
            Some(JsValue::Symbol(s)) => {
                let data = format!(""{:?}"", s);
                ctx.future_to_promise(async move {
                    let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(data.as_bytes()).await;
                    Ok(JsValue::UnDefined)
                });
            }
            _ => {}
        };
        JsValue::Bool(true)
    }

    pub fn js_local(
        this_val: &mut Self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match this_val.local() {
            Ok(addr) => ctx.new_string(addr.to_string().as_str()).into(),
            Err(e) => ctx.throw_internal_type_error(e.to_string().as_str()).into(),
        }
    }

    pub fn js_peer(
        this_val: &mut Self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match this_val.peer() {
            Ok(addr) => ctx.new_string(addr.to_string().as_str()).into(),
            Err(e) => ctx.throw_internal_type_error(e.to_string().as_str()).into(),
        }
    }
}

#[cfg(feature = ""tls"")]
impl JsClassDef for AsyncTlsConn {
    type RefType = AsyncTlsConn;
    const CLASS_NAME: &'static str = ""WasiTlsConn"";
    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
        (""on"", 1, Self::on),
        (""read"", 0, Self::js_read),
        (""write"", 1, Self::js_write),
        (""end"", 1, Self::js_write),
        (""local"", 0, Self::js_local),
        (""peer"", 0, Self::js_peer),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        Err(JsValue::Null)
    }
}

impl AsyncTcpConn {
    pub fn js_connect(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
        use wasmedge_wasi_socket::ToSocketAddrs;
        let host = argv.get(0);
        let port = argv.get(1);
        let timeout = argv.get(2);

        let nctx = ctx.clone();

        if let (Some(JsValue::String(host)), Some(JsValue::Int(port))) = (host, port) {
            let timeout = if let Some(JsValue::Int(timeout)) = timeout {
                Some(std::time::Duration::from_millis((*timeout) as u64))
            } else {
                None
            };

            let host = host.to_string();
            let port = *port as u16;

            let pp = if let Some(duration) = timeout {
                ctx.future_to_promise(async move {
                    let mut ctx = nctx;
                    match tokio::time::timeout(duration, AsyncTcpConn::async_connect((host, port)))
                        .await
                    {
                        Ok(Ok(conn)) => Ok(Self::wrap_obj(&mut ctx, conn)),
                        Ok(Err(e)) => Err(ctx.new_error(e.to_string().as_str())),
                        Err(e) => {
                            let err =
                                std::io::Error::new(std::io::ErrorKind::TimedOut, e.to_string());
                            Err(ctx.new_error(err.to_string().as_str()).into())
                        }
                    }
                })
            } else {
                ctx.future_to_promise(async move {
                    let mut ctx = nctx;
                    match AsyncTcpConn::async_connect((host, port)).await {
                        Ok(conn) => Ok(Self::wrap_obj(&mut ctx, conn)),
                        Err(e) => Err(ctx.new_error(e.to_string().as_str())),
                    }
                })
            };
            pp
        } else {
            JsValue::UnDefined
        }
    }

    pub fn on(
        _this_val: &mut AsyncTcpConn,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        JsValue::UnDefined
    }

    pub fn js_read(
        _this_val: &mut AsyncTcpConn,
        this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let mut js_obj = this_obj.clone().into();
        let n_ctx = ctx.clone();
        if let Some(JsValue::Int(timeout)) = argv.get(0) {
            let duration = std::time::Duration::from_millis((*timeout) as u64);
            ctx.future_to_promise(async move {
                let mut ctx = n_ctx;
                let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                match tokio::time::timeout(duration, this_val.async_read_all()).await {
                    Ok(Ok(data)) => {
                        if data.len() > 0 {
                            let buff = ctx.new_array_buffer(data.as_slice());
                            Ok(JsValue::ArrayBuffer(buff))
                        } else {
                            Ok(JsValue::UnDefined)
                        }
                    }
                    Ok(Err(err)) => Err(ctx.new_error(err.to_string().as_str()).into()),
                    Err(e) => {
                        let err = std::io::Error::new(std::io::ErrorKind::TimedOut, e.to_string());
                        Err(ctx.new_error(err.to_string().as_str()).into())
                    }
                }
            })
        } else {
            ctx.future_to_promise(async move {
                let mut ctx = n_ctx;
                let this_val = Self::opaque_mut(&mut js_obj).unwrap();
                match this_val.async_read_all().await {
                    Ok(data) => {
                        if data.len() > 0 {
                            let buff = ctx.new_array_buffer(data.as_slice());
                            log::trace!(""async_read_all return ArrayBuffer"");
                            Ok(JsValue::ArrayBuffer(buff))
                        } else {
                            Ok(JsValue::UnDefined)
                        }
                    }
                    Err(err) => Err(ctx.new_error(err.to_string().as_str()).into()),
                }
            })
        }
    }

    pub fn js_write(
        _this_val: &mut AsyncTcpConn,
        this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let mut js_obj = JsValue::Object(this_obj.clone());
        match argv.get(0) {
            Some(JsValue::String(s)) => {
                let data = s.to_string();
                ctx.future_to_promise(async move {
                    let this_val = AsyncTcpConn::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(data.as_bytes()).await;
                    Ok(JsValue::UnDefined)
                });
            }
            Some(JsValue::ArrayBuffer(buff)) => {
                let data = buff.to_vec();
                ctx.future_to_promise(async move {
                    let this_val = AsyncTcpConn::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(&data).await;
                    Ok(JsValue::UnDefined)
                });
            }
            Some(JsValue::Object(o)) => {
                let data = o.to_string();
                ctx.future_to_promise(async move {
                    let this_val = AsyncTcpConn::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(data.as_bytes()).await;
                    Ok(JsValue::UnDefined)
                });
            }
            Some(JsValue::Symbol(s)) => {
                let data = format!(""{:?}"", s);
                ctx.future_to_promise(async move {
                    let this_val = AsyncTcpConn::opaque_mut(&mut js_obj).unwrap();
                    this_val.async_write_all(data.as_bytes()).await;
                    Ok(JsValue::UnDefined)
                });
            }
            _ => {}
        };
        JsValue::Bool(true)
    }

    pub fn js_local(
        this_val: &mut AsyncTcpConn,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match this_val.local() {
            Ok(addr) => ctx.new_string(addr.to_string().as_str()).into(),
            Err(e) => ctx.throw_internal_type_error(e.to_string().as_str()).into(),
        }
    }

    pub fn js_peer(
        this_val: &mut AsyncTcpConn,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        match this_val.peer() {
            Ok(addr) => ctx.new_string(addr.to_string().as_str()).into(),
            Err(e) => ctx.throw_internal_type_error(e.to_string().as_str()).into(),
        }
    }
}

impl JsClassDef for AsyncTcpConn {
    type RefType = AsyncTcpConn;
    const CLASS_NAME: &'static str = ""WasiTcpConn"";
    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
        (""on"", 1, Self::on),
        (""read"", 0, Self::js_read),
        (""write"", 1, Self::js_write),
        (""end"", 1, Self::js_write),
        (""local"", 0, Self::js_local),
        (""peer"", 0, Self::js_peer),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        Err(JsValue::Null)
    }
}

impl AsyncTcpServer {
    pub fn js_accept(
        &mut self,
        this: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let timeout = if let Some(JsValue::Int(timeout)) = argv.get(0) {
            Some(std::time::Duration::from_millis((*timeout) as u64))
        } else {
            None
        };
        let n_ctx = ctx.clone();
        let mut js_obj = this.clone().into();
        ctx.future_to_promise(async move {
            let this = Self::opaque_mut(&mut js_obj).unwrap();
            let mut ctx = n_ctx;
            this.accept(&mut ctx, timeout).await
        })
    }
}

impl JsClassDef for AsyncTcpServer {
    const CLASS_NAME: &'static str = ""WasiTcpServer"";
    const CONSTRUCTOR_ARGC: u8 = 1;

    type RefType = AsyncTcpServer;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[(""accept"", 0, Self::js_accept)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        let port = argv.get(0).ok_or_else(|| JsValue::UnDefined)?;
        if let JsValue::Int(port) = port {
            match Self::bind(*port as u16) {
                Ok(tcp_server) => Ok(tcp_server),
                Err(e) => {
                    log::trace!(""tcp_listen err: {e}"");
                    Err(ctx.throw_internal_type_error(e.to_string().as_str()).into())
                }
            }
        } else {
            Err(JsValue::UnDefined)
        }
    }
}

fn js_nsloopup(ctx: &mut Context, _this: JsValue, param: &[JsValue]) -> JsValue {
    use wasmedge_wasi_socket::ToSocketAddrs;
    let node = param.get(0);
    let service = param.get(1);
    if let (Some(JsValue::String(node)), Some(JsValue::String(service))) = (node, service) {
        let r = format!(""{}:{}"", node.as_str(), service.as_str()).to_socket_addrs();
        match r {
            Ok(addr_vec) => {
                let mut array = ctx.new_array();
                for (i, addr) in addr_vec.enumerate() {
                    array.put(i, ctx.new_string(addr.to_string().as_str()).into());
                }
                array.into()
            }
            Err(e) => ctx.throw_internal_type_error(e.to_string().as_str()).into(),
        }
    } else {
        JsValue::UnDefined
    }
}

pub fn init_module(ctx: &mut Context) {
    ctx.register_fn_module(
        ""wasi_net\0"",
        &[
            AsyncTcpServer::CLASS_NAME,
            AsyncTcpConn::CLASS_NAME,
            #[cfg(feature = ""tls"")]
            AsyncTlsConn::CLASS_NAME,
            ""nsloopup"",
        ],
        |ctx, m| {
            let class_ctor = register_class::<AsyncTcpServer>(ctx);
            m.add_export(AsyncTcpServer::CLASS_NAME, class_ctor);

            let mut class_ctor = register_class::<AsyncTcpConn>(ctx);
            if let JsValue::Function(tcp_conn_ctor) = &mut class_ctor {
                let conn = ctx.wrap_function(""connect"", AsyncTcpConn::js_connect);
                tcp_conn_ctor.set(""connect"", conn.into());
            }
            m.add_export(AsyncTcpConn::CLASS_NAME, class_ctor);

            #[cfg(feature = ""tls"")]
            {
                let mut class_ctor = register_class::<AsyncTlsConn>(ctx);
                if let JsValue::Function(tls_conn_ctor) = &mut class_ctor {
                    let conn = ctx.wrap_function(""tls_connect"", AsyncTlsConn::js_connect);
                    tls_conn_ctor.set(""connect"", conn.into());
                }
                m.add_export(AsyncTlsConn::CLASS_NAME, class_ctor);
            }

            let f = ctx.wrap_function(""nsloopup"", js_nsloopup);
            m.add_export(""nsloopup"", f.into());
        },
    )
}
"
test/fs/test-fs-rm.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import { pathToFileURL } from 'url';
// import { execSync } from 'child_process';

import { validateRmOptionsSync } from 'internal/fs/utils';

tmpdir.refresh();

let count = 0;
const nextDirPath = (name = 'rm') =>
  path.join(tmpdir.path, `${name}-${count++}`);

const isGitPresent = (() => {
  // try { execSync('git --version'); return true; } catch { return false; }
  return false;
})();

/*function gitInit(gitDirectory) {
  fs.mkdirSync(gitDirectory);
  execSync('git init', common.mustNotMutateObjectDeep({ cwd: gitDirectory }));
}*/

function makeNonEmptyDirectory(depth, files, folders, dirname, createSymLinks) {
  fs.mkdirSync(dirname, common.mustNotMutateObjectDeep({ recursive: true }));
  fs.writeFileSync(path.join(dirname, 'text.txt'), 'hello', 'utf8');

  const options = common.mustNotMutateObjectDeep({ flag: 'wx' });

  for (let f = files; f > 0; f--) {
    fs.writeFileSync(path.join(dirname, `f-${depth}-${f}`), '', options);
  }

  if (createSymLinks) {
    // Valid symlink
    fs.symlinkSync(
      `f-${depth}-1`,
      path.join(dirname, `link-${depth}-good`),
      'file'
    );

    // Invalid symlink
    fs.symlinkSync(
      'does-not-exist',
      path.join(dirname, `link-${depth}-bad`),
      'file'
    );
  }

  // File with a name that looks like a glob
  fs.writeFileSync(path.join(dirname, '[a-z0-9].txt'), '', options);

  depth--;
  if (depth <= 0) {
    return;
  }

  for (let f = folders; f > 0; f--) {
    fs.mkdirSync(
      path.join(dirname, `folder-${depth}-${f}`),
      { recursive: true }
    );
    makeNonEmptyDirectory(
      depth,
      files,
      folders,
      path.join(dirname, `d-${depth}-${f}`),
      createSymLinks
    );
  }
}

function removeAsync(dir) {
  // Removal should fail without the recursive option.
  fs.rm(dir, common.mustCall((err) => {
    assert.strictEqual(err.syscall, 'rm');

    // Removal should fail without the recursive option set to true.
    fs.rm(dir, common.mustNotMutateObjectDeep({ recursive: false }), common.mustCall((err) => {
      assert.strictEqual(err.syscall, 'rm');

      // Recursive removal should succeed.
      fs.rm(dir, common.mustNotMutateObjectDeep({ recursive: true }), common.mustSucceed(() => {

        // Attempted removal should fail now because the directory is gone.
        fs.rm(dir, common.mustCall((err) => {
          assert.strictEqual(err.syscall, 'rm');
          // assert.strictEqual(err.syscall, 'stat'); nodejs doc api not indicate the implement ways.
        }));
      }));
    }));
  }));
}

// Test the asynchronous version
{
  // Create a 4-level folder hierarchy including symlinks
  let dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  removeAsync(dir);

  // Create a 2-level folder hierarchy without symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(dir);

  // Same test using URL instead of a path
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(pathToFileURL(dir));

  // Create a flat folder including symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(1, 10, 2, dir, true);
  removeAsync(dir);

  // Should fail if target does not exist
  fs.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    common.mustNotMutateObjectDeep({ recursive: true }),
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
    })
  );

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-async-file.txt');
  fs.writeFileSync(filePath, '');
  fs.rm(filePath, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall((err) => {
    try {
      assert.strictEqual(err, null);
      assert.strictEqual(fs.existsSync(filePath), false);
    } finally {
      fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
    }
  }));
}

// Removing a .git directory should not throw an EPERM.
// Refs: https://github.com/isaacs/rimraf/issues/21.
if (isGitPresent) {
  const gitDirectory = nextDirPath();
  gitInit(gitDirectory);
  fs.rm(gitDirectory, common.mustNotMutateObjectDeep({ recursive: true }), common.mustSucceed(() => {
    assert.strictEqual(fs.existsSync(gitDirectory), false);
  }));
}

// Test the synchronous version.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  assert.throws(() => {
    fs.rmSync(dir);
  }, { syscall: 'rm' });
  assert.throws(() => {
    fs.rmSync(dir, common.mustNotMutateObjectDeep({ recursive: false }));
  }, { syscall: 'rm' });

  // Should fail if target does not exist
  assert.throws(() => {
    fs.rmSync(path.join(tmpdir.path, 'noexist.txt'), common.mustNotMutateObjectDeep({ recursive: true }));
  }, {
    code: 'ENOENT',
    name: 'Error',
    // message: /^ENOENT: no such file or directory, stat/
    message: /^ENOENT: no such file or directory, rm/
  });

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-file.txt');
  fs.writeFileSync(filePath, '');

  try {
    fs.rmSync(filePath, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
  }

  // Should accept URL
  const fileURL = pathToFileURL(path.join(tmpdir.path, 'rm-file.txt'));
  fs.writeFileSync(fileURL, '');

  try {
    fs.rmSync(fileURL, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(fileURL, common.mustNotMutateObjectDeep({ force: true }));
  }

  // Recursive removal should succeed.
  fs.rmSync(dir, { recursive: true });

  // Attempted removal should fail now because the directory is gone.
  // assert.throws(() => fs.rmSync(dir), { syscall: 'stat' });
  assert.throws(() => fs.rmSync(dir), { syscall: 'rm' });
}

// Removing a .git directory should not throw an EPERM.
// Refs: https://github.com/isaacs/rimraf/issues/21.
if (isGitPresent) {
  const gitDirectory = nextDirPath();
  gitInit(gitDirectory);
  fs.rmSync(gitDirectory, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(gitDirectory), false);
}

// Test the Promises based version.
(async () => {
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  await assert.rejects(fs.promises.rm(dir), { syscall: 'rm' });
  await assert.rejects(fs.promises.rm(dir, common.mustNotMutateObjectDeep({ recursive: false })), {
    syscall: 'rm'
  });

  // Recursive removal should succeed.
  await fs.promises.rm(dir, common.mustNotMutateObjectDeep({ recursive: true }));

  // Attempted removal should fail now because the directory is gone.
  // await assert.rejects(fs.promises.rm(dir), { syscall: 'stat' });
  await assert.rejects(fs.promises.rm(dir), { syscall: 'rm' });

  // Should fail if target does not exist
  await assert.rejects(fs.promises.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true }
  ), {
    code: 'ENOENT',
    name: 'Error',
    message: /^ENOENT: no such file or directory, rm/
    // message: /^ENOENT: no such file or directory, stat/
  });

  // Should not fail if target does not exist and force option is true
  await fs.promises.rm(path.join(tmpdir.path, 'noexist.txt'), common.mustNotMutateObjectDeep({ force: true }));

  // Should delete file
  const filePath = path.join(tmpdir.path, 'rm-promises-file.txt');
  fs.writeFileSync(filePath, '');

  try {
    await fs.promises.rm(filePath, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
  }

  // Should accept URL
  const fileURL = pathToFileURL(path.join(tmpdir.path, 'rm-promises-file.txt'));
  fs.writeFileSync(fileURL, '');

  try {
    await fs.promises.rm(fileURL, common.mustNotMutateObjectDeep({ recursive: true }));
  } finally {
    fs.rmSync(fileURL, common.mustNotMutateObjectDeep({ force: true }));
  }
})().then(common.mustCall());

// Removing a .git directory should not throw an EPERM.
// Refs: https://github.com/isaacs/rimraf/issues/21.
if (isGitPresent) {
  (async () => {
    const gitDirectory = nextDirPath();
    gitInit(gitDirectory);
    await fs.promises.rm(gitDirectory, common.mustNotMutateObjectDeep({ recursive: true }));
    assert.strictEqual(fs.existsSync(gitDirectory), false);
  })().then(common.mustCall());
}

// Test input validation.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  const filePath = (path.join(tmpdir.path, 'rm-args-file.txt'));
  fs.writeFileSync(filePath, '');

  const defaults = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false,
    force: false
  };
  const modified = {
    retryDelay: 953,
    maxRetries: 5,
    recursive: true,
    force: false
  };

  assert.deepStrictEqual(validateRmOptionsSync(filePath), defaults);
  assert.deepStrictEqual(validateRmOptionsSync(filePath, {}), defaults);
  assert.deepStrictEqual(validateRmOptionsSync(filePath, modified), modified);
  assert.deepStrictEqual(validateRmOptionsSync(filePath, {
    maxRetries: 99
  }), {
    retryDelay: 100,
    maxRetries: 99,
    recursive: false,
    force: false
  });

  [null, 'foo', 5, NaN].forEach((bad) => {
    assert.throws(() => {
      validateRmOptionsSync(filePath, bad);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options"" argument must be of type object\./
    });
  });

  [undefined, null, 'foo', Infinity, function() {}].forEach((bad) => {
    assert.throws(() => {
      validateRmOptionsSync(filePath, { recursive: bad });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options\.recursive"" property must be of type boolean\./
    });
  });

  [undefined, null, 'foo', Infinity, function() {}].forEach((bad) => {
    assert.throws(() => {
      validateRmOptionsSync(filePath, { force: bad });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options\.force"" property must be of type boolean\./
    });
  });

  assert.throws(() => {
    validateRmOptionsSync(filePath, { retryDelay: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.retryDelay"" is out of range\./
  });

  assert.throws(() => {
    validateRmOptionsSync(filePath, { maxRetries: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.maxRetries"" is out of range\./
  });
}

// unsupport for chmod
/*{
  // IBMi has a different access permission mechanism
  // This test should not be run as `root`
  if (!common.isIBMi && (common.isWindows || process.getuid() !== 0)) {
    function makeDirectoryReadOnly(dir, mode) {
      let accessErrorCode = 'EACCES';
      if (common.isWindows) {
        accessErrorCode = 'EPERM';
        execSync(`icacls ${dir} /deny ""everyone:(OI)(CI)(DE,DC)""`);
      } else {
        fs.chmodSync(dir, mode);
      }
      return accessErrorCode;
    }

    function makeDirectoryWritable(dir) {
      if (fs.existsSync(dir)) {
        if (common.isWindows) {
          execSync(`icacls ${dir} /remove:d ""everyone""`);
        } else {
          fs.chmodSync(dir, 0o777);
        }
      }
    }

    {
      // Check that deleting a file that cannot be accessed using rmsync throws
      // https://github.com/nodejs/node/issues/38683
      const dirname = nextDirPath();
      const filePath = path.join(dirname, 'text.txt');
      try {
        fs.mkdirSync(dirname, common.mustNotMutateObjectDeep({ recursive: true }));
        fs.writeFileSync(filePath, 'hello');
        const code = makeDirectoryReadOnly(dirname, 0o444);
        assert.throws(() => {
          fs.rmSync(filePath, common.mustNotMutateObjectDeep({ force: true }));
        }, {
          code,
          name: 'Error',
        });
      } finally {
        makeDirectoryWritable(dirname);
      }
    }

    {
      // Check endless recursion.
      // https://github.com/nodejs/node/issues/34580
      const dirname = nextDirPath();
      fs.mkdirSync(dirname, common.mustNotMutateObjectDeep({ recursive: true }));
      const root = fs.mkdtempSync(path.join(dirname, 'fs-'));
      const middle = path.join(root, 'middle');
      fs.mkdirSync(middle);
      fs.mkdirSync(path.join(middle, 'leaf')); // Make `middle` non-empty
      try {
        const code = makeDirectoryReadOnly(middle, 0o555);
        try {
          assert.throws(() => {
            fs.rmSync(root, common.mustNotMutateObjectDeep({ recursive: true }));
          }, {
            code,
            name: 'Error',
          });
        } catch (err) {
          // Only fail the test if the folder was not deleted.
          // as in some cases rmSync succesfully deletes read-only folders.
          if (fs.existsSync(root)) {
            throw err;
          }
        }
      } finally {
        makeDirectoryWritable(middle);
      }
    }
  }
}*/
"
modules/internal/fs/cp/cp.js,"// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

'use strict';

// This file is a modified version of the fs-extra's copy method.

import * as errors from ""../../errors""
import { os } from ""../../../internal_binding/constants"";

const {
  ERR_FS_CP_DIR_TO_NON_DIR,
  ERR_FS_CP_EEXIST,
  ERR_FS_CP_EINVAL,
  ERR_FS_CP_FIFO_PIPE,
  ERR_FS_CP_NON_DIR_TO_DIR,
  ERR_FS_CP_SOCKET,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
  ERR_FS_CP_UNKNOWN,
  ERR_FS_EISDIR,
} = errors;
const {
  errno: {
    EEXIST,
    EISDIR,
    EINVAL,
    ENOTDIR,
  }
} = os;
import {
  chmod,
  copyFile,
  lstat,
  mkdir,
  opendir,
  readlink,
  stat,
  symlink,
  unlink,
  utimes,
} from ""fs/promises"";
import {
  dirname,
  isAbsolute,
  join,
  parse,
  resolve,
  sep,
} from ""path"";

import process from ""process"";

async function cpFn(src, dest, opts) {
  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    const warning = 'Using the preserveTimestamps option in 32-bit ' +
      'node is not recommended';
    process.emitWarning(warning, 'TimestampPrecisionWarning');
  }
  const stats = await checkPaths(src, dest, opts);
  const { srcStat, destStat } = stats;
  await checkParentPaths(src, srcStat, dest);
  if (opts.filter) {
    return handleFilter(checkParentDir, destStat, src, dest, opts);
  }
  return checkParentDir(destStat, src, dest, opts);
}

async function checkPaths(src, dest, opts) {
  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts);
  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL({
        message: 'src and dest cannot be the same',
        path: dest,
        syscall: 'cp',
        errno: EINVAL,
        code: 'EINVAL',
      });
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new ERR_FS_CP_DIR_TO_NON_DIR({
        message: `cannot overwrite directory ${src} ` +
          `with non-directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: EISDIR,
        code: 'EISDIR',
      });
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new ERR_FS_CP_NON_DIR_TO_DIR({
        message: `cannot overwrite non-directory ${src} ` +
          `with directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: ENOTDIR,
        code: 'ENOTDIR',
      });
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return { srcStat, destStat };
}

function areIdentical(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino &&
    destStat.dev === srcStat.dev;
}

function getStats(src, dest, opts) {
  const statFunc = opts.dereference ?
    (file) => stat(file, { bigint: true }) :
    (file) => lstat(file, { bigint: true });
  return Promise.all([
    statFunc(src),
    Promise.prototype.then.call(statFunc(dest), undefined, (err) => {
      if (err.code === 'ENOENT') return null;
      throw err;
    }),
  ]);
}

async function checkParentDir(destStat, src, dest, opts) {
  const destParent = dirname(dest);
  const dirExists = await pathExists(destParent);
  if (dirExists) return getStatsForCopy(destStat, src, dest, opts);
  await mkdir(destParent, { recursive: true });
  return getStatsForCopy(destStat, src, dest, opts);
}

function pathExists(dest) {
  return Promise.prototype.then.call(
    stat(dest),
    () => true,
    (err) => (err.code === 'ENOENT' ? false : PromiseReject(err)));
}

// Recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
async function checkParentPaths(src, srcStat, dest) {
  const srcParent = resolve(dirname(src));
  const destParent = resolve(dirname(dest));
  if (destParent === srcParent || destParent === parse(destParent).root || destParent === ""."") {
    return;
  }
  let destStat;
  try {
    destStat = await stat(destParent, { bigint: true });
  } catch (err) {
    if (err.code === 'ENOENT') return;
    throw err;
  }
  if (areIdentical(srcStat, destStat)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return checkParentPaths(src, srcStat, destParent);
}

const normalizePathToArray = (path) =>
  Array.prototype.filter.call(String.prototype.split.call(resolve(path), sep), Boolean);

// Return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir(src, dest) {
  const srcArr = normalizePathToArray(src);
  const destArr = normalizePathToArray(dest);
  return Array.prototype.every.call(srcArr, (cur, i) => destArr[i] === cur);
}

async function handleFilter(onInclude, destStat, src, dest, opts, cb) {
  const include = await opts.filter(src, dest);
  if (include) return onInclude(destStat, src, dest, opts, cb);
}

function startCopy(destStat, src, dest, opts) {
  if (opts.filter) {
    return handleFilter(getStatsForCopy, destStat, src, dest, opts);
  }
  return getStatsForCopy(destStat, src, dest, opts);
}

async function getStatsForCopy(destStat, src, dest, opts) {
  const statFn = opts.dereference ? stat : lstat;
  const srcStat = await statFn(src);
  if (srcStat.isDirectory() && opts.recursive) {
    return onDir(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isDirectory()) {
    throw new ERR_FS_EISDIR({
      message: `${src} is a directory (not copied)`,
      path: src,
      syscall: 'cp',
      errno: EISDIR,
      code: 'EISDIR',
    });
  } else if (srcStat.isFile() ||
    srcStat.isCharacterDevice() ||
    srcStat.isBlockDevice()) {
    return onFile(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isSymbolicLink()) {
    return onLink(destStat, src, dest, opts);
  } else if (srcStat.isSocket()) {
    throw new ERR_FS_CP_SOCKET({
      message: `cannot copy a socket file: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  } else if (srcStat.isFIFO()) {
    throw new ERR_FS_CP_FIFO_PIPE({
      message: `cannot copy a FIFO pipe: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  throw new ERR_FS_CP_UNKNOWN({
    message: `cannot copy an unknown file type: ${dest}`,
    path: dest,
    syscall: 'cp',
    errno: EINVAL,
    code: 'EINVAL',
  });
}

function onFile(srcStat, destStat, src, dest, opts) {
  if (!destStat) return _copyFile(srcStat, src, dest, opts);
  return mayCopyFile(srcStat, src, dest, opts);
}

async function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.force) {
    await unlink(dest);
    return _copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new ERR_FS_CP_EEXIST({
      message: `${dest} already exists`,
      path: dest,
      syscall: 'cp',
      errno: EEXIST,
      code: 'EEXIST',
    });
  }
}

async function _copyFile(srcStat, src, dest, opts) {
  await copyFile(src, dest);
  if (opts.preserveTimestamps) {
    return handleTimestampsAndMode(srcStat.mode, src, dest);
  }
  return setDestMode(dest, srcStat.mode);
}

async function handleTimestampsAndMode(srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) {
    await makeFileWritable(dest, srcMode);
    return setDestTimestampsAndMode(srcMode, src, dest);
  }
  return setDestTimestampsAndMode(srcMode, src, dest);
}

function fileIsNotWritable(srcMode) {
  return (srcMode & 0o200) === 0;
}

function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200);
}

async function setDestTimestampsAndMode(srcMode, src, dest) {
  await setDestTimestamps(src, dest);
  return setDestMode(dest, srcMode);
}

function setDestMode(dest, srcMode) {
  return chmod(dest, srcMode);
}

async function setDestTimestamps(src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = await stat(src);
  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}

function onDir(srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
  return copyDir(src, dest, opts);
}

async function mkDirAndCopy(srcMode, src, dest, opts) {
  await mkdir(dest);
  await copyDir(src, dest, opts);
  return setDestMode(dest, srcMode);
}

async function copyDir(src, dest, opts) {
  const dir = await opendir(src);

  for await (const { name } of dir) {
    const srcItem = join(src, name);
    const destItem = join(dest, name);
    const { destStat } = await checkPaths(srcItem, destItem, opts);
    await startCopy(destStat, srcItem, destItem, opts);
  }
}

async function onLink(destStat, src, dest, opts) {
  let resolvedSrc = await readlink(src);
  if (!opts.verbatimSymlinks && !isAbsolute(resolvedSrc)) {
    resolvedSrc = resolve(dirname(src), resolvedSrc);
  }
  if (!destStat) {
    return symlink(resolvedSrc, dest);
  }
  let resolvedDest;
  try {
    resolvedDest = await readlink(dest);
  } catch (err) {
    // Dest exists and is a regular file or directory,
    // Windows may throw UNKNOWN error. If dest already exists,
    // fs throws error anyway, so no need to guard against it here.
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {
      return symlink(resolvedSrc, dest);
    }
    throw err;
  }
  if (!isAbsolute(resolvedDest)) {
    resolvedDest = resolve(dirname(dest), resolvedDest);
  }
  if (isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +
        `${resolvedDest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  // Do not copy if src is a subdir of dest since unlinking
  // dest in this case would result in removing src contents
  // and therefore a broken symlink would be created.
  const srcStat = await stat(src);
  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return copyLink(resolvedSrc, dest);
}

async function copyLink(resolvedSrc, dest) {
  await unlink(dest);
  return symlink(resolvedSrc, dest);
}

export {
  areIdentical,
  cpFn,
  isSrcSubdir,
};
"
test/fs/test-fs-promises.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
import fixtures from '../common/fixtures';
import path from 'path';
import fs from 'fs';
const fsPromises = fs.promises;
const {
  access,
  //chmod,
  //chown,
  copyFile,
  //lchown,
  link,
  //lchmod,
  lstat,
  lutimes,
  mkdir,
  mkdtemp,
  open,
  readFile,
  readdir,
  //readlink,
  //realpath,
  rename,
  rmdir,
  stat,
  symlink,
  truncate,
  unlink,
  utimes,
  writeFile
} = fsPromises;

const tmpDir = tmpdir.path;

let dirc = 0;
function nextdir() {
  return `test${++dirc}`;
}

const __filename = args[0];

// fs.promises should be enumerable.
assert.strictEqual(
  Object.prototype.propertyIsEnumerable.call(fs, 'promises'),
  true
);

{
  access(__filename, 0)
    .then(common.mustCall());

  assert.rejects(
    access('this file does not exist', 0),
    {
      code: 'ENOENT',
      name: 'Error',
      message: /^ENOENT: no such file or directory, access/
    }
  );

  assert.rejects(
    access(__filename, 8),
    {
      code: 'ERR_OUT_OF_RANGE',
      message: /""mode"".*must be an integer >= 0 && <= 7\. Received 8$/
    }
  );

  assert.rejects(
    access(__filename, { [Symbol.toPrimitive]() { return 5; } }),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""mode"" argument.+integer\. Received an instance of Object$/
    }
  );
}

function verifyStatObject(stat) {
  assert.strictEqual(typeof stat, 'object');
  assert.strictEqual(typeof stat.dev, 'number');
  assert.strictEqual(typeof stat.mode, 'number');
}

async function getHandle(dest) {
  await copyFile(fixtures.path('baz.js'), dest);
  await access(dest);

  return open(dest, 'r+');
}

async function executeOnHandle(dest, func) {
  let handle;
  try {
    handle = await getHandle(dest);
    await func(handle);
  } finally {
    if (handle) {
      await handle.close();
    }
  }
}

{
  async function doTest() {
    tmpdir.refresh();

    const dest = path.resolve(tmpDir, 'baz.js');

    // handle is object
    {
      await executeOnHandle(dest, async (handle) => {
        assert.strictEqual(typeof handle, 'object');
      });
    }

    // file stats
    {
      await executeOnHandle(dest, async (handle) => {
        let stats = await handle.stat();
        verifyStatObject(stats);
        assert.strictEqual(stats.size, 35);

        await handle.truncate(1);

        stats = await handle.stat();
        verifyStatObject(stats);
        assert.strictEqual(stats.size, 1);

        stats = await stat(dest);
        verifyStatObject(stats);

        stats = await handle.stat();
        verifyStatObject(stats);

        await handle.datasync();
        await handle.sync();
      });
    }

    // Test fs.read promises when length to read is zero bytes
    {
      const dest = path.resolve(tmpDir, 'test1.js');
      await executeOnHandle(dest, async (handle) => {
        const buf = Buffer.from('DAWGS WIN');
        const bufLen = buf.length;
        await handle.write(buf);
        const ret = await handle.read(Buffer.alloc(bufLen), 0, 0, 0);
        assert.strictEqual(ret.bytesRead, 0);

        await unlink(dest);
      });
    }


    /* Undocumented usage
    // Use fallback buffer allocation when input not buffer
    {
      await executeOnHandle(dest, async (handle) => {
        const ret = await handle.read(0, 0, 0, 0);
        assert.strictEqual(ret.buffer.length, 16384);
      });
    }
    */

    // Bytes written to file match buffer
    {
      await executeOnHandle(dest, async (handle) => {
        const buf = Buffer.from('hello fsPromises');
        const bufLen = buf.length;
        await handle.write(buf);
        const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);
        assert.strictEqual(ret.bytesRead, bufLen);
        assert.deepStrictEqual(ret.buffer, buf);
      });
    }

    // Truncate file to specified length
    {
      await executeOnHandle(dest, async (handle) => {
        const buf = Buffer.from('hello FileHandle');
        const bufLen = buf.length;
        await handle.write(buf, 0, bufLen, 0);
        const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);
        assert.strictEqual(ret.bytesRead, bufLen);
        assert.deepStrictEqual(ret.buffer, buf);
        await truncate(dest, 5);
        assert.strictEqual((await readFile(dest)).toString(), 'hello');
      });
    }

    /*
    // Invalid change of ownership
    {
      await executeOnHandle(dest, async (handle) => {
        await chmod(dest, 0o666);
        await handle.chmod(0o666);

        await chmod(dest, (0o10777));
        await handle.chmod(0o10777);

        if (!common.isWindows) {
          await chown(dest, process.getuid(), process.getgid());
          await handle.chown(process.getuid(), process.getgid());
        }

        await assert.rejects(
          async () => {
            await chown(dest, 1, -2);
          },
          {
            code: 'ERR_OUT_OF_RANGE',
            name: 'RangeError',
            message: 'The value of ""gid"" is out of range. ' +
                     'It must be >= -1 && <= 4294967295. Received -2'
          });

        await assert.rejects(
          async () => {
            await handle.chown(1, -2);
          },
          {
            code: 'ERR_OUT_OF_RANGE',
            name: 'RangeError',
            message: 'The value of ""gid"" is out of range. ' +
                      'It must be >= -1 && <= 4294967295. Received -2'
          });
      });
    }
    */

    // Set modification times
    {
      await executeOnHandle(dest, async (handle) => {

        await utimes(dest, new Date(), new Date());

        try {
          await handle.utimes(new Date(), new Date());
        } catch (err) {
          // Some systems do not have futimes. If there is an error,
          // expect it to be ENOSYS
          common.expectsError({
            code: 'ENOSYS',
            name: 'Error'
          })(err);
        }
      });
    }

    /*
    // Set modification times with lutimes
    {
      const a_time = new Date();
      a_time.setMinutes(a_time.getMinutes() - 1);
      const m_time = new Date();
      m_time.setHours(m_time.getHours() - 1);
      await lutimes(dest, a_time, m_time);
      const stats = await stat(dest);

      assert.strictEqual(a_time.toString(), stats.atime.toString());
      assert.strictEqual(m_time.toString(), stats.mtime.toString());
    }
    */

    // create symlink
    {
      const newPath = path.resolve(tmpDir, 'baz2.js');
      await rename(dest, newPath);
      let stats = await stat(newPath);
      verifyStatObject(stats);

      if (common.canCreateSymLink()) {
        const newLink = path.resolve(tmpDir, 'baz3.js');
        await symlink(newPath, newLink);
        /*
        if (!common.isWindows) {
          await lchown(newLink, process.getuid(), process.getgid());
        }
        */
        stats = await lstat(newLink);
        verifyStatObject(stats);

        /*
        assert.strictEqual(newPath.toLowerCase(),
                           (await realpath(newLink)).toLowerCase());
        assert.strictEqual(newPath.toLowerCase(),
                           (await readlink(newLink)).toLowerCase());

        const newMode = 0o666;
        if (common.isOSX) {
          // `lchmod` is only available on macOS.
          await lchmod(newLink, newMode);
          stats = await lstat(newLink);
          assert.strictEqual(stats.mode & 0o777, newMode);
        } else {
          await Promise.all([
            assert.rejects(
              lchmod(newLink, newMode),
              common.expectsError({
                code: 'ERR_METHOD_NOT_IMPLEMENTED',
                name: 'Error',
                message: 'The lchmod() method is not implemented'
              })
            ),
          ]);
        }
        */

        await unlink(newLink);
      }
    }

    /*
    // specify symlink type
    {
      const dir = path.join(tmpDir, nextdir());
      await symlink(tmpDir, dir, 'dir');
      const stats = await lstat(dir);
      assert.strictEqual(stats.isSymbolicLink(), true);
      await unlink(dir);
    }
    */

    // create hard link
    {
      const newPath = path.resolve(tmpDir, 'baz2.js');
      const newLink = path.resolve(tmpDir, 'baz4.js');
      await link(newPath, newLink);

      await unlink(newLink);
    }

    // Testing readdir lists both files and directories
    {
      const newDir = path.resolve(tmpDir, 'dir');
      const newFile = path.resolve(tmpDir, 'foo.js');

      await mkdir(newDir);
      await writeFile(newFile, 'DAWGS WIN!', 'utf8');

      const stats = await stat(newDir);
      assert(stats.isDirectory());
      const list = await readdir(tmpDir);
      assert.notStrictEqual(list.indexOf('dir'), -1);
      assert.notStrictEqual(list.indexOf('foo.js'), -1);
      await rmdir(newDir);
      await unlink(newFile);
    }

    // Use fallback encoding when input is null
    {
      const newFile = path.resolve(tmpDir, 'dogs_running.js');
      await writeFile(newFile, 'dogs running', { encoding: null });
      const fileExists = fs.existsSync(newFile);
      assert.strictEqual(fileExists, true);
    }

    // `mkdir` when options is number.
    {
      const dir = path.join(tmpDir, nextdir());
      await mkdir(dir, 777);
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // `mkdir` when options is string.
    {
      const dir = path.join(tmpDir, nextdir());
      await mkdir(dir, '777');
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // `mkdirp` when folder does not yet exist.
    {
      const dir = path.join(tmpDir, nextdir(), nextdir());
      await mkdir(dir, { recursive: true });
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // `mkdirp` when path is a file.
    {
      const dir = path.join(tmpDir, nextdir(), nextdir());
      await mkdir(path.dirname(dir));
      await writeFile(dir, '');
      assert.rejects(
        mkdir(dir, { recursive: true }),
        {
          code: 'EEXIST',
          message: /EEXIST: .*mkdir/,
          name: 'Error',
          syscall: 'mkdir',
        }
      );
    }

    // `mkdirp` when part of the path is a file.
    {
      const file = path.join(tmpDir, nextdir(), nextdir());
      const dir = path.join(file, nextdir(), nextdir());
      await mkdir(path.dirname(file));
      await writeFile(file, '');
      assert.rejects(
        mkdir(dir, { recursive: true }),
        {
          code: 'ENOTDIR',
          message: /ENOTDIR: .*mkdir/,
          name: 'Error',
          syscall: 'mkdir',
        }
      );
    }

    // mkdirp ./
    {
      const dir = path.resolve(tmpDir, `${nextdir()}/./${nextdir()}`);
      await mkdir(dir, { recursive: true });
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // mkdirp ../
    {
      const dir = path.resolve(tmpDir, `${nextdir()}/../${nextdir()}`);
      await mkdir(dir, { recursive: true });
      const stats = await stat(dir);
      assert(stats.isDirectory());
    }

    // fs.mkdirp requires the recursive option to be of type boolean.
    // Everything else generates an error.
    {
      const dir = path.join(tmpDir, nextdir(), nextdir());
      ['', 1, {}, [], null, Symbol('test'), () => {}].forEach((recursive) => {
        assert.rejects(
          // mkdir() expects to get a boolean value for options.recursive.
          async () => mkdir(dir, { recursive }),
          {
            code: 'ERR_INVALID_ARG_TYPE',
            name: 'TypeError'
          }
        );
      });
    }

    // `mkdtemp` with invalid numeric prefix
    {
      await mkdtemp(path.resolve(tmpDir, 'FOO'));
      assert.rejects(
        // mkdtemp() expects to get a string prefix.
        async () => mkdtemp(1),
        {
          code: 'ERR_INVALID_ARG_TYPE',
          name: 'TypeError'
        }
      );
    }

    // Regression test for https://github.com/nodejs/node/issues/38168
    {
      await executeOnHandle(dest, async (handle) => {
        await assert.rejects(
          async () => handle.write('abc', 0, 'hex'),
          {
            code: 'ERR_INVALID_ARG_VALUE',
            message: /'encoding' is invalid for data of length 3/
          }
        );

        const ret = await handle.write('abcd', 0, 'hex');
        assert.strictEqual(ret.bytesWritten, 2);
      });
    }

    /*
    // Test prototype methods calling with contexts other than FileHandle
    {
      await executeOnHandle(dest, async (handle) => {
        await assert.rejects(() => handle.stat.call({}), {
          code: 'ERR_INTERNAL_ASSERTION',
          message: /handle must be an instance of FileHandle/
        });
      });
    }
    */
  }

  doTest().then(common.mustCall()).catch(err => print(err, err.stack));
}
"
test/fs/test-fs-mkdir.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import process from 'process';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

let dirc = 0;
function nextdir() {
  return `test${++dirc}`;
}

// fs.mkdir creates directory using assigned path
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdir(pathname, common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
  }));
}

// fs.mkdir creates directory with assigned mode value
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdir(pathname, 0o777, common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
  }));
}

// fs.mkdir creates directory with mode passed as an options object
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ mode: 0o777 }), common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
  }));
}

// fs.mkdirSync creates directory with mode passed as an options object
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ mode: 0o777 }));

  assert.strictEqual(fs.existsSync(pathname), true);
}

// mkdirSync successfully creates directory from given path
{
  const pathname = path.join(tmpdir.path, nextdir());

  fs.mkdirSync(pathname);

  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
}

// mkdirSync and mkdir require path to be a string, buffer or url.
// Anything else generates an error.
[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.mkdir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.mkdirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// mkdirpSync when both top-level, and sub-folders do not exist.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));

  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
}

// mkdirpSync when folder already exists.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(pathname, { recursive: true });
  // Should not cause an error.
  fs.mkdirSync(pathname, { recursive: true });

  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
}

// mkdirpSync ../
{
  const pathname = `${tmpdir.path}/${nextdir()}/../${nextdir()}/${nextdir()}`;
  fs.mkdirSync(pathname, { recursive: true });
  const exists = fs.existsSync(pathname);
  assert.strictEqual(exists, true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
}

// mkdirpSync when path is a file.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(pathname));
  fs.writeFileSync(pathname, '', 'utf8');

  assert.throws(
    () => { fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true })); },
    {
      code: 'EEXIST',
      message: /EEXIST: .*mkdir/,
      name: 'Error',
      syscall: 'mkdir',
    }
  );
}

// mkdirpSync when part of the path is a file.
{
  const filename = path.join(tmpdir.path, nextdir(), nextdir());
  const pathname = path.join(filename, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(filename));
  fs.writeFileSync(filename, '', 'utf8');

  assert.throws(
    () => { fs.mkdirSync(pathname, { recursive: true }); },
    {
      code: 'ENOTDIR',
      message: /ENOTDIR: .*mkdir/,
      name: 'Error',
      syscall: 'mkdir',
      path: pathname // See: https://github.com/nodejs/node/issues/28015
    }
  );
}

// `mkdirp` when folder does not yet exist.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  }));
}

// `mkdirp` when path is a file.
{
  const pathname = path.join(tmpdir.path, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(pathname));
  fs.writeFileSync(pathname, '', 'utf8');
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall((err) => {
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.syscall, 'mkdir');
    assert.strictEqual(fs.statSync(pathname).isDirectory(), false);
  }));
}

// `mkdirp` when part of the path is a file.
{
  const filename = path.join(tmpdir.path, nextdir(), nextdir());
  const pathname = path.join(filename, nextdir(), nextdir());

  fs.mkdirSync(path.dirname(filename));
  fs.writeFileSync(filename, '', 'utf8');
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall((err) => {
    assert.strictEqual(err.code, 'ENOTDIR');
    assert.strictEqual(err.syscall, 'mkdir');
    assert.strictEqual(fs.existsSync(pathname), false);
    // See: https://github.com/nodejs/node/issues/28015
    // The path field varies slightly in Windows errors, vs., other platforms
    // see: https://github.com/libuv/libuv/issues/2661, for this reason we
    // use startsWith() rather than comparing to the full ""pathname"".
    assert(err.path.startsWith(filename));
  }));
}

// mkdirpSync dirname loop
// XXX: windows and smartos have issues removing a directory that you're in.
if (common.isMainThread && (common.isLinux || common.isOSX)) {
  const pathname = path.join(tmpdir.path, nextdir());
  fs.mkdirSync(pathname);
  process.chdir(pathname);
  fs.rmdirSync(pathname);
  assert.throws(
    () => { fs.mkdirSync('X', common.mustNotMutateObjectDeep({ recursive: true })); },
    {
      code: 'ENOENT',
      message: /ENOENT: .*mkdir/,
      name: 'Error',
      syscall: 'mkdir',
    }
  );
  fs.mkdir('X', common.mustNotMutateObjectDeep({ recursive: true }), (err) => {
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'mkdir');
  });
}

// mkdirSync and mkdir require options.recursive to be a boolean.
// Anything else generates an error.
{
  const pathname = path.join(tmpdir.path, nextdir());
  ['', 1, {}, [], null, Symbol('test'), () => {}].forEach((recursive) => {
    const received = common.invalidArgTypeHelper(recursive);
    assert.throws(
      () => fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive }), common.mustNotCall()),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""options.recursive"" property must be of type boolean.' +
          received
      }
    );
    assert.throws(
      () => fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive })),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""options.recursive"" property must be of type boolean.' +
          received
      }
    );
  });
}

// `mkdirp` returns first folder created, when all folders are new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const firstPathCreated = path.join(tmpdir.path, dir1);
  const pathname = path.join(tmpdir.path, dir1, dir2);

  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err, path) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(path, firstPathCreated);
  }));
}

// `mkdirp` returns first folder created, when last folder is new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1));
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err, path) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(path, pathname);
  }));
}

// `mkdirp` returns undefined, when no new folders are created.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1, dir2), common.mustNotMutateObjectDeep({ recursive: true }));
  fs.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }), common.mustCall(function(err, path) {
    assert.strictEqual(err, null);
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(path, undefined);
  }));
}

// `mkdirp.sync` returns first folder created, when all folders are new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const firstPathCreated = path.join(tmpdir.path, dir1);
  const pathname = path.join(tmpdir.path, dir1, dir2);
  const p = fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(pathname), true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  assert.strictEqual(p, firstPathCreated);
}

// `mkdirp.sync` returns first folder created, when last folder is new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1), common.mustNotMutateObjectDeep({ recursive: true }));
  const p = fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(pathname), true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  assert.strictEqual(p, pathname);
}

// `mkdirp.sync` returns undefined, when no new folders are created.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const pathname = path.join(tmpdir.path, dir1, dir2);
  fs.mkdirSync(path.join(tmpdir.path, dir1, dir2), common.mustNotMutateObjectDeep({ recursive: true }));
  const p = fs.mkdirSync(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
  assert.strictEqual(fs.existsSync(pathname), true);
  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
  assert.strictEqual(p, undefined);
}

// `mkdirp.promises` returns first folder created, when all folders are new.
{
  const dir1 = nextdir();
  const dir2 = nextdir();
  const firstPathCreated = path.join(tmpdir.path, dir1);
  const pathname = path.join(tmpdir.path, dir1, dir2);
  async function testCase() {
    const p = await fs.promises.mkdir(pathname, common.mustNotMutateObjectDeep({ recursive: true }));
    assert.strictEqual(fs.existsSync(pathname), true);
    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);
    assert.strictEqual(p, firstPathCreated);
  }
  testCase();
}

// Keep the event loop alive so the async mkdir() requests
// have a chance to run (since they don't ref the event loop).
process.nextTick(() => {});
"
modules/internal/validators.js,"import {
    ERR_SOCKET_BAD_PORT,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_CALLBACK,
    ERR_OUT_OF_RANGE,
    hideStackFrames,
    ERR_INVALID_ARG_VALUE
} from './errors'

export function validatePort(port, name = ""Port"", allowZero = true) {
    if (
        (typeof port !== ""number"" && typeof port !== ""string"") ||
        (typeof port === ""string"" &&
            port.trim().length === 0) ||
        +port !== (+port >>> 0) ||
        port > 0xFFFF ||
        (port === 0 && !allowZero)
    ) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }

    return port;
}

export const validateFunction = hideStackFrames(
    (value, name) => {
        if (typeof value !== ""function"") {
            throw new ERR_INVALID_ARG_TYPE(name, ""Function"", value);
        }
    },
);

export function validateString(value, name) {
    if (typeof value !== ""string"") {
        throw new ERR_INVALID_ARG_TYPE(name, ""string"", value);
    }
}

/**
 * @param {unknown} value
 * @param {string} name
 */
export function validateBoolean(value, name) {
    if (typeof value !== ""boolean"") {
        throw new ERR_INVALID_ARG_TYPE(name, ""boolean"", value);
    }
}


/**
 * @param {unknown} signal
 * @param {string} name
 */
export const validateAbortSignal = hideStackFrames(
    (signal, name) => {
        if (
            signal !== undefined &&
            (signal === null ||
                typeof signal !== ""object"" ||
                !(""aborted"" in signal))
        ) {
            throw new ERR_INVALID_ARG_TYPE(name, ""AbortSignal"", signal);
        }
    },
);

export const validateObject = hideStackFrames((value, name, options) => {
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (
        (!nullable && value === null) ||
        (!allowArray && Array.isArray(value)) ||
        (typeof value !== ""object"" && (
            !allowFunction || typeof value !== ""function""
        ))
    ) {
        throw new ERR_INVALID_ARG_TYPE(name, ""Object"", value);
    }
});

export const validateCallback = hideStackFrames((callback) => {
    if (typeof callback !== ""function"") {
        throw new ERR_INVALID_CALLBACK(callback);
    }
});

/**
 * @param {number} value
 * @returns {boolean}
 */
function isInt32(value) {
    return value === (value | 0);
}

/**
 * @param {unknown} value
 * @returns {boolean}
 */
function isUint32(value) {
    return value === (value >>> 0);
}

export const validateInt32 = hideStackFrames(
    (value, name, min = -2147483648, max = 2147483647) => {
        // The defaults for min and max correspond to the limits of 32-bit integers.
        if (!isInt32(value)) {
            if (typeof value !== ""number"") {
                throw new ERR_INVALID_ARG_TYPE(name, ""number"", value);
            }

            if (!Number.isInteger(value)) {
                throw new ERR_OUT_OF_RANGE(name, ""an integer"", value);
            }

            throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
        }

        if (value < min || value > max) {
            throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
        }
    },
);

export const validateUint32 = hideStackFrames(
    (value, name, positive) => {
        if (!isUint32(value)) {
            if (typeof value !== ""number"") {
                throw new ERR_INVALID_ARG_TYPE(name, ""number"", value);
            }
            if (!Number.isInteger(value)) {
                throw new ERR_OUT_OF_RANGE(name, ""an integer"", value);
            }
            const min = positive ? 1 : 0;
            // 2 ** 32 === 4294967296
            throw new ERR_OUT_OF_RANGE(
                name,
                `>= ${min} && < 4294967296`,
                value,
            );
        }
        if (positive && value === 0) {
            throw new ERR_OUT_OF_RANGE(name, "">= 1 && < 4294967296"", value);
        }
    },
);

export const validateInteger = hideStackFrames(
    (
        value,
        name,
        min = Number.MIN_SAFE_INTEGER,
        max = Number.MAX_SAFE_INTEGER,
    ) => {
        if (typeof value !== ""number"") {
            throw new ERR_INVALID_ARG_TYPE(name, ""number"", value);
        }
        if (!Number.isInteger(value)) {
            throw new ERR_OUT_OF_RANGE(name, ""an integer"", value);
        }
        if (value < min || value > max) {
            throw new ERR_OUT_OF_RANGE(name, `an integer >= ${min} && <= ${max}`, value);
        }
    },
);

export const getValidMode = hideStackFrames((mode, type) => {
    let min = kMinimumAccessMode;
    let max = kMaximumAccessMode;
    let def = F_OK;
    if (type === ""copyFile"") {
        min = kMinimumCopyMode;
        max = kMaximumCopyMode;
        def = mode || kDefaultCopyMode;
    } else {
        // assert(type === ""access"");
    }
    if (mode == null) {
        return def;
    }
    if (Number.isInteger(mode) && mode >= min && mode <= max) {
        return mode;
    }
    if (typeof mode !== ""number"") {
        throw new ERR_INVALID_ARG_TYPE(""mode"", ""integer"", mode);
    }
    throw new ERR_OUT_OF_RANGE(
        ""mode"",
        `an integer >= ${min} && <= ${max}`,
        mode,
    );
});

/**
 * @callback validateNumber
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateNumber} */
export function validateNumber(value, name, min = undefined, max) {
    if (typeof value !== 'number')
        throw new ERR_INVALID_ARG_TYPE(name, 'number', value);

    if ((min != null && value < min) || (max != null && value > max) ||
        ((min != null || max != null) && Number.isNaN(value))) {
        throw new ERR_OUT_OF_RANGE(
            name,
            `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,
            value);
    }
}

/**
 * @callback validateArray
 * @param {*} value
 * @param {string} name
 * @param {number} [minLength]
 * @returns {asserts value is any[]}
 */

/** @type {validateArray} */
export const validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!Array.isArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, 'Array', value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});

/**
 * @callback validateOneOf
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} oneOf
 */

/** @type {validateOneOf} */
export const validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(
            Array.prototype.map.call(oneOf, (v) =>
                (typeof v === 'string' ? `'${v}'` : String(v))),
            ', ');
        const reason = 'must be one of: ' + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});

// Return undefined if there is no match.
// Move the ""slow cases"" to a separate function to make sure this function gets
// inlined properly. That prioritizes the common case.
function normalizeEncoding(enc) {
    if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';
    return slowCases(enc);
}

function slowCases(enc) {
    switch (enc.length) {
        case 4:
            if (enc === 'UTF8') return 'utf8';
            if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';
            enc = `${enc}`.toLowerCase();
            if (enc === 'utf8') return 'utf8';
            if (enc === 'ucs2') return 'utf16le';
            break;
        case 3:
            if (enc === 'hex' || enc === 'HEX' ||
                `${enc}`.toLowerCase() === 'hex')
                return 'hex';
            break;
        case 5:
            if (enc === 'ascii') return 'ascii';
            if (enc === 'ucs-2') return 'utf16le';
            if (enc === 'UTF-8') return 'utf8';
            if (enc === 'ASCII') return 'ascii';
            if (enc === 'UCS-2') return 'utf16le';
            enc = `${enc}`.toLowerCase();
            if (enc === 'utf-8') return 'utf8';
            if (enc === 'ascii') return 'ascii';
            if (enc === 'ucs-2') return 'utf16le';
            break;
        case 6:
            if (enc === 'base64') return 'base64';
            if (enc === 'latin1' || enc === 'binary') return 'latin1';
            if (enc === 'BASE64') return 'base64';
            if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';
            enc = `${enc}`.toLowerCase();
            if (enc === 'base64') return 'base64';
            if (enc === 'latin1' || enc === 'binary') return 'latin1';
            break;
        case 7:
            if (enc === 'utf16le' || enc === 'UTF16LE' ||
                `${enc}`.toLowerCase() === 'utf16le')
                return 'utf16le';
            break;
        case 8:
            if (enc === 'utf-16le' || enc === 'UTF-16LE' ||
                `${enc}`.toLowerCase() === 'utf-16le')
                return 'utf16le';
            break;
        case 9:
            if (enc === 'base64url' || enc === 'BASE64URL' ||
                `${enc}`.toLowerCase() === 'base64url')
                return 'base64url';
            break;
        default:
            if (enc === '') return 'utf8';
    }
}


/**
 * @param {string} data
 * @param {string} encoding
 */
export function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;

    if (normalizedEncoding === 'hex' && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE('encoding', encoding,
            `is invalid for data of length ${length}`);
    }
}

export default {
    validatePort,
    validateFunction,
    validateString,
    validateBoolean,
    validateObject,
    validateAbortSignal,
    validateCallback,
    validateInteger,
    validateNumber,
    validateArray,
    getValidMode,
    validateOneOf,
    validateEncoding
}"
test/crypto/test-crypto-rsa-dsa.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const constants = crypto.constants;

const fixtures = require('../common/fixtures');

// Test certificates
const certPem = fixtures.readKey('rsa_cert.crt');
const keyPem = fixtures.readKey('rsa_private.pem');
const rsaKeySize = 2048;
const rsaPubPem = fixtures.readKey('rsa_public.pem', 'ascii');
const rsaKeyPem = fixtures.readKey('rsa_private.pem', 'ascii');
const rsaKeyPemEncrypted = fixtures.readKey('rsa_private_encrypted.pem',
                                            'ascii');
const dsaPubPem = fixtures.readKey('dsa_public.pem', 'ascii');
const dsaKeyPem = fixtures.readKey('dsa_private.pem', 'ascii');
const dsaKeyPemEncrypted = fixtures.readKey('dsa_private_encrypted.pem',
                                            'ascii');
const rsaPkcs8KeyPem = fixtures.readKey('rsa_private_pkcs8.pem');
const dsaPkcs8KeyPem = fixtures.readKey('dsa_private_pkcs8.pem');

const ec = new TextEncoder();

const openssl1DecryptError = {
  message: 'error:06065064:digital envelope routines:EVP_DecryptFinal_ex:' +
    'bad decrypt',
  code: 'ERR_OSSL_EVP_BAD_DECRYPT',
  reason: 'bad decrypt',
  function: 'EVP_DecryptFinal_ex',
  library: 'digital envelope routines',
};

const decryptError = common.hasOpenSSL3 ?
  { message: 'error:1C800064:Provider routines::bad decrypt' } :
  openssl1DecryptError;

const decryptPrivateKeyError = common.hasOpenSSL3 ? {
  message: 'error:1C800064:Provider routines::bad decrypt',
} : openssl1DecryptError;

function getBufferCopy(buf) {
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

// Test RSA encryption/decryption
{
  const input = 'I AM THE WALRUS';
  const bufferToEncrypt = Buffer.from(input);
  const bufferPassword = Buffer.from('password');

  let encryptedBuffer = crypto.publicEncrypt(rsaPubPem, bufferToEncrypt);

  // Test other input types
  let otherEncrypted;
  {
    const ab = getBufferCopy(ec.encode(rsaPubPem));
    const ab2enc = getBufferCopy(bufferToEncrypt);

    crypto.publicEncrypt(ab, ab2enc);
    crypto.publicEncrypt(new Uint8Array(ab), new Uint8Array(ab2enc));
    crypto.publicEncrypt(new DataView(ab), new DataView(ab2enc));
    otherEncrypted = crypto.publicEncrypt({
      key: Buffer.from(ab).toString('hex'),
      encoding: 'hex'
    }, Buffer.from(ab2enc).toString('hex'));
  }

  let decryptedBuffer = crypto.privateDecrypt(rsaKeyPem, encryptedBuffer);
  const otherDecrypted = crypto.privateDecrypt(rsaKeyPem, otherEncrypted);
  assert.strictEqual(decryptedBuffer.toString(), input);
  assert.strictEqual(otherDecrypted.toString(), input);

  decryptedBuffer = crypto.privateDecrypt(rsaPkcs8KeyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  let decryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, encryptedBuffer);

  const otherDecryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: ec.encode('password')
  }, encryptedBuffer);

  assert.strictEqual(
    otherDecryptedBufferWithPassword.toString(),
    decryptedBufferWithPassword.toString());

  decryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, encryptedBuffer);

  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  encryptedBuffer = crypto.publicEncrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, bufferToEncrypt);

  decryptedBufferWithPassword = crypto.privateDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: 'password'
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  encryptedBuffer = crypto.privateEncrypt({
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, bufferToEncrypt);

  decryptedBufferWithPassword = crypto.publicDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  // Now with explicit RSA_PKCS1_PADDING.
  encryptedBuffer = crypto.privateEncrypt({
    padding: crypto.constants.RSA_PKCS1_PADDING,
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, bufferToEncrypt);

  decryptedBufferWithPassword = crypto.publicDecrypt({
    padding: crypto.constants.RSA_PKCS1_PADDING,
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  // Omitting padding should be okay because RSA_PKCS1_PADDING is the default.
  decryptedBufferWithPassword = crypto.publicDecrypt({
    key: rsaKeyPemEncrypted,
    passphrase: bufferPassword
  }, encryptedBuffer);
  assert.strictEqual(decryptedBufferWithPassword.toString(), input);

  // Now with RSA_NO_PADDING. Plaintext needs to match key size.
  // OpenSSL 3.x has a rsa_check_padding that will cause an error if
  // RSA_NO_PADDING is used.
  if (!common.hasOpenSSL3) {
    {
      const plaintext = 'x'.repeat(rsaKeySize / 8);
      encryptedBuffer = crypto.privateEncrypt({
        padding: crypto.constants.RSA_NO_PADDING,
        key: rsaKeyPemEncrypted,
        passphrase: bufferPassword
      }, Buffer.from(plaintext));

      decryptedBufferWithPassword = crypto.publicDecrypt({
        padding: crypto.constants.RSA_NO_PADDING,
        key: rsaKeyPemEncrypted,
        passphrase: bufferPassword
      }, encryptedBuffer);
      assert.strictEqual(decryptedBufferWithPassword.toString(), plaintext);
    }
  }

  encryptedBuffer = crypto.publicEncrypt(certPem, bufferToEncrypt);

  decryptedBuffer = crypto.privateDecrypt(keyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  encryptedBuffer = crypto.publicEncrypt(keyPem, bufferToEncrypt);

  decryptedBuffer = crypto.privateDecrypt(keyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  encryptedBuffer = crypto.privateEncrypt(keyPem, bufferToEncrypt);

  decryptedBuffer = crypto.publicDecrypt(keyPem, encryptedBuffer);
  assert.strictEqual(decryptedBuffer.toString(), input);

  assert.throws(() => {
    crypto.privateDecrypt({
      key: rsaKeyPemEncrypted,
      passphrase: 'wrong'
    }, bufferToEncrypt);
  }, decryptError);

  assert.throws(() => {
    crypto.publicEncrypt({
      key: rsaKeyPemEncrypted,
      passphrase: 'wrong'
    }, encryptedBuffer);
  }, decryptError);

  encryptedBuffer = crypto.privateEncrypt({
    key: rsaKeyPemEncrypted,
    passphrase: Buffer.from('password')
  }, bufferToEncrypt);

  assert.throws(() => {
    crypto.publicDecrypt({
      key: rsaKeyPemEncrypted,
      passphrase: Buffer.from('wrong')
    }, encryptedBuffer);
  }, decryptError);
}

function test_rsa(padding, encryptOaepHash, decryptOaepHash) {
  const size = (padding === 'RSA_NO_PADDING') ? rsaKeySize / 8 : 32;
  const input = Buffer.allocUnsafe(size);
  for (let i = 0; i < input.length; i++)
    input[i] = (i * 7 + 11) & 0xff;
  const bufferToEncrypt = Buffer.from(input);

  padding = constants[padding];

  const encryptedBuffer = crypto.publicEncrypt({
    key: rsaPubPem,
    padding: padding,
    oaepHash: encryptOaepHash
  }, bufferToEncrypt);

  let decryptedBuffer = crypto.privateDecrypt({
    key: rsaKeyPem,
    padding: padding,
    oaepHash: decryptOaepHash
  }, encryptedBuffer);
  assert.deepStrictEqual(decryptedBuffer, input);

  decryptedBuffer = crypto.privateDecrypt({
    key: rsaPkcs8KeyPem,
    padding: padding,
    oaepHash: decryptOaepHash
  }, encryptedBuffer);
  assert.deepStrictEqual(decryptedBuffer, input);
}

test_rsa('RSA_NO_PADDING');
test_rsa('RSA_PKCS1_PADDING');
test_rsa('RSA_PKCS1_OAEP_PADDING');

// Test OAEP with different hash functions.
test_rsa('RSA_PKCS1_OAEP_PADDING', undefined, 'sha1');
test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha1', undefined);
test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha256', 'sha256');
test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha512', 'sha512');
assert.throws(() => {
  test_rsa('RSA_PKCS1_OAEP_PADDING', 'sha256', 'sha512');
}, {
  code: 'ERR_OSSL_RSA_OAEP_DECODING_ERROR'
});

// The following RSA-OAEP test cases were created using the WebCrypto API to
// ensure compatibility when using non-SHA1 hash functions.
{
  const { decryptionTests } =
      JSON.parse(fixtures.readSync('rsa-oaep-test-vectors.js', 'utf8'));

  for (const { ct, oaepHash, oaepLabel } of decryptionTests) {
    const label = oaepLabel ? Buffer.from(oaepLabel, 'hex') : undefined;
    const copiedLabel = oaepLabel ? getBufferCopy(label) : undefined;

    const decrypted = crypto.privateDecrypt({
      key: rsaPkcs8KeyPem,
      oaepHash,
      oaepLabel: oaepLabel ? label : undefined
    }, Buffer.from(ct, 'hex'));

    assert.strictEqual(decrypted.toString('utf8'), 'Hello Node.js');

    const otherDecrypted = crypto.privateDecrypt({
      key: rsaPkcs8KeyPem,
      oaepHash,
      oaepLabel: copiedLabel
    }, Buffer.from(ct, 'hex'));

    assert.strictEqual(otherDecrypted.toString('utf8'), 'Hello Node.js');
  }
}

// Test invalid oaepHash and oaepLabel options.
for (const fn of [crypto.publicEncrypt, crypto.privateDecrypt]) {
  assert.throws(() => {
    fn({
      key: rsaPubPem,
      oaepHash: 'Hello world'
    }, Buffer.alloc(10));
  }, {
    code: 'ERR_OSSL_EVP_INVALID_DIGEST'
  });

  for (const oaepHash of [0, false, null, Symbol(), () => {}]) {
    assert.throws(() => {
      fn({
        key: rsaPubPem,
        oaepHash
      }, Buffer.alloc(10));
    }, {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  }

  for (const oaepLabel of [0, false, null, Symbol(), () => {}, {}]) {
    assert.throws(() => {
      fn({
        key: rsaPubPem,
        oaepLabel
      }, Buffer.alloc(10));
    }, {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  }
}

// Test RSA key signing/verification
let rsaSign = crypto.createSign('SHA1');
let rsaVerify = crypto.createVerify('SHA1');
assert.ok(rsaSign);
assert.ok(rsaVerify);

const expectedSignature = fixtures.readKey(
  'rsa_public_sha1_signature_signedby_rsa_private_pkcs8.sha1',
  'hex'
);

rsaSign.update(rsaPubPem);
let rsaSignature = rsaSign.sign(rsaKeyPem, 'hex');
assert.strictEqual(rsaSignature, expectedSignature);

rsaVerify.update(rsaPubPem);
assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);

// Test RSA PKCS#8 key signing/verification
rsaSign = crypto.createSign('SHA1');
rsaSign.update(rsaPubPem);
rsaSignature = rsaSign.sign(rsaPkcs8KeyPem, 'hex');
assert.strictEqual(rsaSignature, expectedSignature);

rsaVerify = crypto.createVerify('SHA1');
rsaVerify.update(rsaPubPem);
assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);

// Test RSA key signing/verification with encrypted key
rsaSign = crypto.createSign('SHA1');
rsaSign.update(rsaPubPem);
const signOptions = { key: rsaKeyPemEncrypted, passphrase: 'password' };
rsaSignature = rsaSign.sign(signOptions, 'hex');
assert.strictEqual(rsaSignature, expectedSignature);

rsaVerify = crypto.createVerify('SHA1');
rsaVerify.update(rsaPubPem);
assert.strictEqual(rsaVerify.verify(rsaPubPem, rsaSignature, 'hex'), true);

rsaSign = crypto.createSign('SHA1');
rsaSign.update(rsaPubPem);
assert.throws(() => {
  const signOptions = { key: rsaKeyPemEncrypted, passphrase: 'wrong' };
  rsaSign.sign(signOptions, 'hex');
}, decryptPrivateKeyError);

//
// Test RSA signing and verification
//
{
  const privateKey = fixtures.readKey('rsa_private_b.pem');
  const publicKey = fixtures.readKey('rsa_public_b.pem');

  const input = 'I AM THE WALRUS';

  const signature = fixtures.readKey(
    'I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256',
    'hex'
  );

  const sign = crypto.createSign('SHA256');
  sign.update(input);

  const output = sign.sign(privateKey, 'hex');
  assert.strictEqual(output, signature);

  const verify = crypto.createVerify('SHA256');
  verify.update(input);

  assert.strictEqual(verify.verify(publicKey, signature, 'hex'), true);

  // Test the legacy signature algorithm name.
  const sign2 = crypto.createSign('RSA-SHA256');
  sign2.update(input);

  const output2 = sign2.sign(privateKey, 'hex');
  assert.strictEqual(output2, signature);

  const verify2 = crypto.createVerify('SHA256');
  verify2.update(input);

  assert.strictEqual(verify2.verify(publicKey, signature, 'hex'), true);
}


//
// Test DSA signing and verification
//
{
  const input = 'I AM THE WALRUS';

  // DSA signatures vary across runs so there is no static string to verify
  // against.
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signature = sign.sign(dsaKeyPem, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(dsaPubPem, signature, 'hex'), true);

  // Test the legacy 'DSS1' name.
  const sign2 = crypto.createSign('DSS1');
  sign2.update(input);
  const signature2 = sign2.sign(dsaKeyPem, 'hex');

  const verify2 = crypto.createVerify('DSS1');
  verify2.update(input);

  assert.strictEqual(verify2.verify(dsaPubPem, signature2, 'hex'), true);
}


//
// Test DSA signing and verification with PKCS#8 private key
//
{
  const input = 'I AM THE WALRUS';

  // DSA signatures vary across runs so there is no static string to verify
  // against.
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signature = sign.sign(dsaPkcs8KeyPem, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(dsaPubPem, signature, 'hex'), true);
}


//
// Test DSA signing and verification with encrypted key
//
const input = 'I AM THE WALRUS';

{
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  assert.throws(() => {
    sign.sign({ key: dsaKeyPemEncrypted, passphrase: 'wrong' }, 'hex');
  }, decryptPrivateKeyError);
}

{
  // DSA signatures vary across runs so there is no static string to verify
  // against.
  const sign = crypto.createSign('SHA1');
  sign.update(input);
  const signOptions = { key: dsaKeyPemEncrypted, passphrase: 'password' };
  const signature = sign.sign(signOptions, 'hex');

  const verify = crypto.createVerify('SHA1');
  verify.update(input);

  assert.strictEqual(verify.verify(dsaPubPem, signature, 'hex'), true);
}
"
test/crypto/test-crypto.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

common.expectWarning({
  DeprecationWarning: [
    ['crypto.createCipher is deprecated.', 'DEP0106'],
  ]
});

const assert = require('assert');
const crypto = require('crypto');
const tls = require('tls');
const fixtures = require('../common/fixtures');

// Test Certificates
const certPfx = fixtures.readKey('rsa_cert.pfx');

// 'this' safety
// https://github.com/joyent/node/issues/6690
assert.throws(() => {
  const credentials = tls.createSecureContext();
  const context = credentials.context;
  const notcontext = { setOptions: context.setOptions };

  // Methods of native objects should not segfault when reassigned to a new
  // object and called illegally. This core dumped in 0.10 and was fixed in
  // 0.11.
  notcontext.setOptions();
}, (err) => {
  // Throws TypeError, so there is no opensslErrorStack property.
  return err instanceof TypeError &&
         err.name === 'TypeError' &&
         /^TypeError: Illegal invocation$/.test(err) &&
         !('opensslErrorStack' in err);
});

// PFX tests
tls.createSecureContext({ pfx: certPfx, passphrase: 'sample' });

assert.throws(() => {
  tls.createSecureContext({ pfx: certPfx });
}, (err) => {
  // Throws general Error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         err.name === 'Error' &&
         /^Error: mac verify failure$/.test(err) &&
         !('opensslErrorStack' in err);
});

assert.throws(() => {
  tls.createSecureContext({ pfx: certPfx, passphrase: 'test' });
}, (err) => {
  // Throws general Error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         err.name === 'Error' &&
         /^Error: mac verify failure$/.test(err) &&
         !('opensslErrorStack' in err);
});

assert.throws(() => {
  tls.createSecureContext({ pfx: 'sample', passphrase: 'test' });
}, (err) => {
  // Throws general Error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         err.name === 'Error' &&
         /^Error: not enough data$/.test(err) &&
         !('opensslErrorStack' in err);
});


// update() should only take buffers / strings
assert.throws(
  () => crypto.createHash('sha1').update({ foo: 'bar' }),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });


function validateList(list) {
  // The list must not be empty
  assert(list.length > 0);

  // The list should be sorted.
  // Array#sort() modifies the list in place so make a copy.
  const sorted = [...list].sort();
  assert.deepStrictEqual(list, sorted);

  // Each element should be unique.
  assert.strictEqual([...new Set(list)].length, list.length);

  // Each element should be a string.
  assert(list.every((value) => typeof value === 'string'));
}

// Assume that we have at least AES-128-CBC.
const cryptoCiphers = crypto.getCiphers();
assert(crypto.getCiphers().includes('aes-128-cbc'));
validateList(cryptoCiphers);
// Make sure all of the ciphers are supported by OpenSSL
for (const algo of cryptoCiphers) {
  const { ivLength, keyLength, mode } = crypto.getCipherInfo(algo);
  let options;
  if (mode === 'ccm')
    options = { authTagLength: 8 };
  else if (mode === 'ocb' || algo === 'chacha20-poly1305')
    options = { authTagLength: 16 };
  crypto.createCipheriv(algo,
                        crypto.randomBytes(keyLength),
                        crypto.randomBytes(ivLength || 0),
                        options);
}

// Assume that we have at least AES256-SHA.
const tlsCiphers = tls.getCiphers();
assert(tls.getCiphers().includes('aes256-sha'));
assert(tls.getCiphers().includes('tls_aes_128_ccm_8_sha256'));
// There should be no capital letters in any element.
const noCapitals = /^[^A-Z]+$/;
assert(tlsCiphers.every((value) => noCapitals.test(value)));
validateList(tlsCiphers);

// Assert that we have sha1 and sha256 but not SHA1 and SHA256.
assert.notStrictEqual(crypto.getHashes().length, 0);
assert(crypto.getHashes().includes('sha1'));
assert(crypto.getHashes().includes('sha256'));
assert(!crypto.getHashes().includes('SHA1'));
assert(!crypto.getHashes().includes('SHA256'));
assert(crypto.getHashes().includes('RSA-SHA1'));
assert(!crypto.getHashes().includes('rsa-sha1'));
validateList(crypto.getHashes());
// Make sure all of the hashes are supported by OpenSSL
for (const algo of crypto.getHashes())
  crypto.createHash(algo);

// Assume that we have at least secp384r1.
assert.notStrictEqual(crypto.getCurves().length, 0);
assert(crypto.getCurves().includes('secp384r1'));
assert(!crypto.getCurves().includes('SECP384R1'));
validateList(crypto.getCurves());

// Modifying return value from get* functions should not mutate subsequent
// return values.
function testImmutability(fn) {
  const list = fn();
  const copy = [...list];
  list.push('some-arbitrary-value');
  assert.deepStrictEqual(fn(), copy);
}

testImmutability(crypto.getCiphers);
testImmutability(tls.getCiphers);
testImmutability(crypto.getHashes);
testImmutability(crypto.getCurves);

const encodingError = {
  code: 'ERR_INVALID_ARG_VALUE',
  name: 'TypeError',
  message: ""The argument 'encoding' is invalid for data of length 1."" +
           "" Received 'hex'"",
};

// Regression tests for https://github.com/nodejs/node-v0.x-archive/pull/5725:
// hex input that's not a power of two should throw, not assert in C++ land.
['createCipher', 'createDecipher'].forEach((funcName) => {
  assert.throws(
    () => crypto[funcName]('aes192', 'test').update('0', 'hex'),
    (error) => {
      assert.ok(!('opensslErrorStack' in error));
      if (common.hasFipsCrypto) {
        return error instanceof Error &&
               error.name === 'Error' &&
               /^Error: not supported in FIPS mode$/.test(error);
      }
      assert.throws(() => { throw error; }, encodingError);
      return true;
    }
  );
});

assert.throws(
  () => crypto.createHash('sha1').update('0', 'hex'),
  (error) => {
    assert.ok(!('opensslErrorStack' in error));
    assert.throws(() => { throw error; }, encodingError);
    return true;
  }
);

assert.throws(
  () => crypto.createHmac('sha256', 'a secret').update('0', 'hex'),
  (error) => {
    assert.ok(!('opensslErrorStack' in error));
    assert.throws(() => { throw error; }, encodingError);
    return true;
  }
);

assert.throws(() => {
  const priv = [
    '-----BEGIN RSA PRIVATE KEY-----',
    'MIGrAgEAAiEA+3z+1QNF2/unumadiwEr+C5vfhezsb3hp4jAnCNRpPcCAwEAAQIgQNriSQK4',
    'EFwczDhMZp2dvbcz7OUUyt36z3S4usFPHSECEQD/41K7SujrstBfoCPzwC1xAhEA+5kt4BJy',
    'eKN7LggbF3Dk5wIQN6SL+fQ5H/+7NgARsVBp0QIRANxYRukavs4QvuyNhMx+vrkCEQCbf6j/',
    'Ig6/HueCK/0Jkmp+',
    '-----END RSA PRIVATE KEY-----',
    '',
  ].join('\n');
  crypto.createSign('SHA256').update('test').sign(priv);
}, (err) => {
  if (!common.hasOpenSSL3)
    assert.ok(!('opensslErrorStack' in err));
  assert.throws(() => { throw err; }, common.hasOpenSSL3 ? {
    name: 'Error',
    message: 'error:02000070:rsa routines::digest too big for rsa key',
    library: 'rsa routines',
  } : {
    name: 'Error',
    message: /routines:RSA_sign:digest too big for rsa key$/,
    library: 'rsa routines',
    function: 'RSA_sign',
    reason: 'digest too big for rsa key',
    code: 'ERR_OSSL_RSA_DIGEST_TOO_BIG_FOR_RSA_KEY'
  });
  return true;
});

if (!common.hasOpenSSL3) {
  assert.throws(() => {
    // The correct header inside `rsa_private_pkcs8_bad.pem` should have been
    // -----BEGIN PRIVATE KEY----- and -----END PRIVATE KEY-----
    // instead of
    // -----BEGIN RSA PRIVATE KEY----- and -----END RSA PRIVATE KEY-----
    const sha1_privateKey = fixtures.readKey('rsa_private_pkcs8_bad.pem',
                                             'ascii');
    // This would inject errors onto OpenSSL's error stack
    crypto.createSign('sha1').sign(sha1_privateKey);
  }, (err) => {
    // Do the standard checks, but then do some custom checks afterwards.
    assert.throws(() => { throw err; }, {
      message: 'error:0D0680A8:asn1 encoding routines:asn1_check_tlen:' +
               'wrong tag',
      library: 'asn1 encoding routines',
      function: 'asn1_check_tlen',
      reason: 'wrong tag',
      code: 'ERR_OSSL_ASN1_WRONG_TAG',
    });
    // Throws crypto error, so there is an opensslErrorStack property.
    // The openSSL stack should have content.
    assert(Array.isArray(err.opensslErrorStack));
    assert(err.opensslErrorStack.length > 0);
    return true;
  });
}

// Make sure memory isn't released before being returned
console.log(crypto.randomBytes(16));

assert.throws(() => {
  tls.createSecureContext({ crl: 'not a CRL' });
}, (err) => {
  // Throws general error, so there is no opensslErrorStack property.
  return err instanceof Error &&
         /^Error: Failed to parse CRL$/.test(err) &&
         !('opensslErrorStack' in err);
});

/**
 * Check if the stream function uses utf8 as a default encoding.
 */

function testEncoding(options, assertionHash) {
  const hash = crypto.createHash('sha256', options);
  let hashValue = '';

  hash.on('data', (data) => {
    hashValue += data.toString('hex');
  });

  hash.on('end', common.mustCall(() => {
    assert.strictEqual(hashValue, assertionHash);
  }));

  hash.write('');
  hash.end();
}

// Hash of """" in utf8 format
const assertionHashUtf8 =
  '4f53d15bee524f082380e6d7247cc541e7cb0d10c64efdcc935ceeb1e7ea345c';

// Hash of """" in latin1 format
const assertionHashLatin1 =
  'cd37bccd5786e2e76d9b18c871e919e6eb11cc12d868f5ae41c40ccff8e44830';

testEncoding(undefined, assertionHashUtf8);
testEncoding({}, assertionHashUtf8);

testEncoding({
  defaultEncoding: 'utf8'
}, assertionHashUtf8);

testEncoding({
  defaultEncoding: 'latin1'
}, assertionHashLatin1);
"
modules/internal/crypto/util.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

/*const {
  getCiphers: _getCiphers,
  getCurves: _getCurves,
  getHashes: _getHashes,
  setEngine: _setEngine,
  secureHeapUsed: _secureHeapUsed,
} = internalBinding('crypto');*/

import { getOptionValue } from '../options';

import { crypto } from '../../internal_binding/constants';
const { ENGINE_METHOD_ALL } = crypto;
import normalizeHashName from './hashnames';

import {
  hideStackFrames,
  ERR_CRYPTO_ENGINE_UNKNOWN,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
  ERR_OUT_OF_RANGE,
} from '../errors';

import {
  validateArray,
  validateNumber,
  validateString
} from '../validators';

import { Buffer } from 'buffer';

import {
  cachedResult,
  filterDuplicateStrings,
  lazyDOMException,
} from '../util';

import {
  isArrayBufferView,
  isAnyArrayBuffer,
} from '../util/types';

const kHandle = Symbol('kHandle');
const kKeyObject = Symbol('kKeyObject');

let defaultEncoding = 'buffer';

function setDefaultEncoding(val) {
  defaultEncoding = val;
}

function getDefaultEncoding() {
  return defaultEncoding;
}

// This is here because many functions accepted binary strings without
// any explicit encoding in older versions of node, and we don't want
// to break them unnecessarily.
function toBuf(val, encoding) {
  if (typeof val === 'string') {
    if (encoding === 'buffer')
      encoding = 'utf8';
    return Buffer.from(val, encoding);
  }
  return val;
}

const getCiphers = () => [""aes-128-gcm"", ""aes-256-gcm""];
const getHashes = () => [""sha256"", ""sha512"", ""sha512-256""];
const getCurves = () => [];

function setEngine(id, flags) {
  validateString(id, 'id');
  if (flags)
    validateNumber(flags, 'flags');
  flags = flags >>> 0;

  // Use provided engine for everything by default
  if (flags === 0)
    flags = ENGINE_METHOD_ALL;

  /*if (!_setEngine(id, flags))
    throw new ERR_CRYPTO_ENGINE_UNKNOWN(id);*/
}

const getArrayBufferOrView = hideStackFrames((buffer, name, encoding) => {
  if (isAnyArrayBuffer(buffer))
    return buffer;
  if (typeof buffer === 'string') {
    if (encoding === 'buffer')
      encoding = 'utf8';
    return Buffer.from(buffer, encoding);
  }
  if (!isArrayBufferView(buffer)) {
    throw new ERR_INVALID_ARG_TYPE(
      name,
      [
        'string',
        'ArrayBuffer',
        'Buffer',
        'TypedArray',
        'DataView',
      ],
      buffer
    );
  }
  return buffer;
});

// The maximum buffer size that we'll support in the WebCrypto impl
const kMaxBufferLength = (2 ** 31) - 1;

// The EC named curves that we currently support via the Web Crypto API.
const kNamedCurveAliases = {
  'P-256': 'prime256v1',
  'P-384': 'secp384r1',
  'P-521': 'secp521r1',
};

const kAesKeyLengths = [128, 192, 256];

// These are the only algorithms we currently support
// via the Web Crypto API
const kAlgorithms = {
  'rsassa-pkcs1-v1_5': 'RSASSA-PKCS1-v1_5',
  'rsa-pss': 'RSA-PSS',
  'rsa-oaep': 'RSA-OAEP',
  'ecdsa': 'ECDSA',
  'ecdh': 'ECDH',
  'aes-ctr': 'AES-CTR',
  'aes-cbc': 'AES-CBC',
  'aes-gcm': 'AES-GCM',
  'aes-kw': 'AES-KW',
  'hmac': 'HMAC',
  'sha-1': 'SHA-1',
  'sha-256': 'SHA-256',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'hkdf': 'HKDF',
  'pbkdf2': 'PBKDF2',
  'ed25519': 'Ed25519',
  'ed448': 'Ed448',
  'x25519': 'X25519',
  'x448': 'X448',
};
const kAlgorithmsKeys = Object.keys(kAlgorithms);

// These are the only export and import formats we currently
// support via the Web Crypto API
const kExportFormats = [
  'raw',
  'pkcs8',
  'spki',
  'jwk'];

// These are the only hash algorithms we currently support via
// the Web Crypto API.
const kHashTypes = [
  'SHA-1',
  'SHA-256',
  'SHA-384',
  'SHA-512',
];

function validateMaxBufferLength(data, name) {
  if (data.byteLength > kMaxBufferLength) {
    throw lazyDOMException(
      `${name} must be less than ${kMaxBufferLength + 1} bits`,
      'OperationError');
  }
}

function normalizeAlgorithm(algorithm) {
  if (algorithm != null) {
    if (typeof algorithm === 'string')
      algorithm = { name: algorithm };

    if (typeof algorithm === 'object') {
      const { name } = algorithm;
      if (typeof name !== 'string' ||
        !Array.prototype.includes.call(
          kAlgorithmsKeys,
          String.prototype.toLowerCase.call(name))) {
        throw lazyDOMException('Unrecognized name.', 'NotSupportedError');
      }
      let { hash } = algorithm;
      if (hash !== undefined) {
        hash = normalizeAlgorithm(hash);
        if (!Array.prototype.includes.call(kHashTypes, hash.name))
          throw lazyDOMException('Unrecognized name.', 'NotSupportedError');
      }
      const normalized = {
        ...algorithm,
        name: kAlgorithms[String.prototype.toLowerCase.call(name)],
      };
      if (hash) {
        normalized.hash = hash;
      }
      return normalized;
    }
  }
  throw lazyDOMException('Unrecognized name.', 'NotSupportedError');
}

function hasAnyNotIn(set, checks) {
  for (const s of set)
    if (!Array.prototype.includes.call(checks, s))
      return true;
  return false;
}

function validateBitLength(length, name, required = false) {
  if (length !== undefined || required) {
    validateNumber(length, name);
    if (length < 0)
      throw new ERR_OUT_OF_RANGE(name, '> 0');
    if (length % 8) {
      throw new ERR_INVALID_ARG_VALUE(
        name,
        length,
        'must be a multiple of 8');
    }
  }
}

function validateByteLength(buf, name, target) {
  if (buf.byteLength !== target) {
    throw lazyDOMException(
      `${name} must contain exactly ${target} bytes`,
      'OperationError');
  }
}

const validateByteSource = hideStackFrames((val, name) => {
  val = toBuf(val);

  if (isAnyArrayBuffer(val) || isArrayBufferView(val))
    return val;

  throw new ERR_INVALID_ARG_TYPE(
    name,
    [
      'string',
      'ArrayBuffer',
      'TypedArray',
      'DataView',
      'Buffer',
    ],
    val);
});

function onDone(resolve, reject, err, result) {
  if (err) {
    // TODO(@panva): add err as cause to DOMException
    return reject(lazyDOMException(
      'The operation failed for an operation-specific reason',
      'OperationError'));
  }
  resolve(result);
}

function jobPromise(job) {
  return new Promise((resolve, reject) => {
    job.ondone = Function.prototype.bind.call(onDone, job, resolve, reject);
    job.run();
  });
}

// In WebCrypto, the publicExponent option in RSA is represented as a
// WebIDL ""BigInteger""... that is, a Uint8Array that allows an arbitrary
// number of leading zero bits. Our conventional APIs for reading
// an unsigned int from a Buffer are not adequate. The implementation
// here is adapted from the chromium implementation here:
// https://github.com/chromium/chromium/blob/HEAD/third_party/blink/public/platform/web_crypto_algorithm_params.h, but ported to JavaScript
// Returns undefined if the conversion was unsuccessful.
function bigIntArrayToUnsignedInt(input) {
  let result = 0;

  for (let n = 0; n < input.length; ++n) {
    const n_reversed = input.length - n - 1;
    if (n_reversed >= 4 && input[n])
      return;  // Too large
    result |= input[n] << 8 * n_reversed;
  }

  return result;
}

function bigIntArrayToUnsignedBigInt(input) {
  let result = 0n;

  for (let n = 0; n < input.length; ++n) {
    const n_reversed = input.length - n - 1;
    result |= BigInt(input[n]) << 8n * BigInt(n_reversed);
  }

  return result;
}

function getStringOption(options, key) {
  let value;
  if (options && (value = options[key]) != null)
    validateString(value, `options.${key}`);
  return value;
}

function getUsagesUnion(usageSet, ...usages) {
  const newset = [];
  for (let n = 0; n < usages.length; n++) {
    if (usageSet.has(usages[n]))
      Array.prototype.push.call(newset, usages[n]);
  }
  return newset;
}

function getHashLength(name) {
  switch (name) {
    case 'SHA-1': return 160;
    case 'SHA-256': return 256;
    case 'SHA-384': return 384;
    case 'SHA-512': return 512;
  }
}

const kKeyOps = {
  sign: 1,
  verify: 2,
  encrypt: 3,
  decrypt: 4,
  wrapKey: 5,
  unwrapKey: 6,
  deriveKey: 7,
  deriveBits: 8,
};

function validateKeyOps(keyOps, usagesSet) {
  if (keyOps === undefined) return;
  validateArray(keyOps, 'keyData.key_ops');
  let flags = 0;
  for (let n = 0; n < keyOps.length; n++) {
    const op = keyOps[n];
    const op_flag = kKeyOps[op];
    // Skipping unknown key ops
    if (op_flag === undefined)
      continue;
    // Have we seen it already? if so, error
    if (flags & (1 << op_flag))
      throw lazyDOMException('Duplicate key operation', 'DataError');
    flags |= (1 << op_flag);

    // TODO(@jasnell): RFC7517 section 4.3 strong recommends validating
    // key usage combinations. Specifically, it says that unrelated key
    // ops SHOULD NOT be used together. We're not yet validating that here.
  }

  if (usagesSet !== undefined) {
    for (const use of usagesSet) {
      if (!Array.prototype.includes.call(keyOps, use)) {
        throw lazyDOMException(
          'Key operations and usage mismatch',
          'DataError');
      }
    }
  }
}

function secureHeapUsed() {
  /*const val = _secureHeapUsed();
  if (val === undefined)
    return { total: 0, used: 0, utilization: 0, min: 0 };
  const used = Number(_secureHeapUsed());
  const total = Number(getOptionValue('--secure-heap'));
  const min = Number(getOptionValue('--secure-heap-min'));
  const utilization = used / total;
  return { total, used, utilization, min };*/
}

export {
  getArrayBufferOrView,
  getCiphers,
  getCurves,
  getDefaultEncoding,
  getHashes,
  kHandle,
  kKeyObject,
  setDefaultEncoding,
  setEngine,
  toBuf,

  kHashTypes,
  kNamedCurveAliases,
  kAesKeyLengths,
  kExportFormats,
  normalizeAlgorithm,
  normalizeHashName,
  hasAnyNotIn,
  validateBitLength,
  validateByteLength,
  validateByteSource,
  validateKeyOps,
  jobPromise,
  validateMaxBufferLength,
  bigIntArrayToUnsignedBigInt,
  bigIntArrayToUnsignedInt,
  getStringOption,
  getUsagesUnion,
  getHashLength,
  secureHeapUsed,
};
"
test/crypto/test-crypto-hmac.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';
import { getHashes } from '../../modules/crypto';

{
  const Hmac = crypto.Hmac;
  const instance = crypto.Hmac('sha256', 'Node');
  assert(instance instanceof Hmac, 'Hmac is expected to return a new instance' +
                                   ' when called without `new`');
}

assert.throws(
  () => crypto.createHmac(null),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""hmac"" argument must be of type string. Received null'
  });

// This used to segfault. See: https://github.com/nodejs/node/issues/9819
assert.throws(
  () => crypto.createHmac('sha256', 'key').digest({
    toString: () => { throw new Error('boom'); },
  }),
  {
    name: 'Error',
    message: 'boom'
  });

/*assert.throws(
  () => crypto.createHmac('sha1', null),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });*/

function testHmac(algo, key, data, expected) {
  // FIPS does not support MD5.
  if (common.hasFipsCrypto && algo === 'md5')
    return;

  // wasi-crypto only support sha256 and sha512
  if (!getHashes().includes(algo)) 
    return;

  if (!Array.isArray(data))
    data = [data];

  // If the key is a Buffer, test Hmac with a key object as well.
  const keyWrappers = [
    (key) => key,
    ...(typeof key === 'string' ? [] : [crypto.createSecretKey]),
  ];

  for (const keyWrapper of keyWrappers) {
    const hmac = crypto.createHmac(algo, keyWrapper(key));
    for (const chunk of data)
      hmac.update(chunk);
    const actual = hmac.digest('hex');
    assert.strictEqual(actual, expected);
  }
}

{
  // Test HMAC with multiple updates.
  testHmac('sha1', 'Node', ['some data', 'to hmac'],
           '19fd6e1ba73d9ed2224dd5094a71babe85d9a892');
}

// Test HMAC (Wikipedia Test Cases)
const wikipedia = [
  {
    key: 'key', data: 'The quick brown fox jumps over the lazy dog',
    hmac: {  // HMACs lifted from Wikipedia.
      md5: '80070713463e7749b90c2dc24911e275',
      sha1: 'de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9',
      sha256:
          'f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc' +
          '2d1a3cd8'
    }
  },
  {
    key: 'key', data: '',
    hmac: {  // Intermediate test to help debugging.
      md5: '63530468a04e386459855da0063b6596',
      sha1: 'f42bb0eeb018ebbd4597ae7213711ec60760843f',
      sha256:
          '5d5d139563c95b5967b9bd9a8c9b233a9dedb45072794cd232dc1b74' +
          '832607d0'
    }
  },
  {
    key: '', data: 'The quick brown fox jumps over the lazy dog',
    hmac: {  // Intermediate test to help debugging.
      md5: 'ad262969c53bc16032f160081c4a07a0',
      sha1: '2ba7f707ad5f187c412de3106583c3111d668de8',
      sha256:
          'fb011e6154a19b9a4c767373c305275a5a69e8b68b0b4c9200c383dc' +
          'ed19a416'
    }
  },
  {
    key: '', data: '',
    hmac: {  // HMACs lifted from Wikipedia.
      md5: '74e6f7298a9c2d168935f58c001bad88',
      sha1: 'fbdb1d1b18aa6c08324b7d64b71fb76370690e1d',
      sha256:
          'b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c71214' +
          '4292c5ad'
    }
  },
];

for (const { key, data, hmac } of wikipedia) {
  for (const hash in hmac)
    testHmac(hash, key, data, hmac[hash]);
}

// Test HMAC-SHA-* (rfc 4231 Test Cases)
const rfc4231 = [
  {
    key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
    data: Buffer.from('4869205468657265', 'hex'), // 'Hi There'
    hmac: {
      sha224: '896fb1128abbdf196832107cd49df33f47b4b1169912ba4f53684b22',
      sha256:
          'b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c' +
          '2e32cff7',
      sha384:
          'afd03944d84895626b0825f4ab46907f15f9dadbe4101ec682aa034c' +
          '7cebc59cfaea9ea9076ede7f4af152e8b2fa9cb6',
      sha512:
          '87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b305' +
          '45e17cdedaa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f170' +
          '2e696c203a126854'
    }
  },
  {
    key: Buffer.from('4a656665', 'hex'), // 'Jefe'
    data: Buffer.from('7768617420646f2079612077616e7420666f72206e6f74686' +
                     '96e673f', 'hex'), // 'what do ya want for nothing?'
    hmac: {
      sha224: 'a30e01098bc6dbbf45690f3a7e9e6d0f8bbea2a39e6148008fd05e44',
      sha256:
          '5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b9' +
          '64ec3843',
      sha384:
          'af45d2e376484031617f78d2b58a6b1b9c7ef464f5a01b47e42ec373' +
          '6322445e8e2240ca5e69e2c78b3239ecfab21649',
      sha512:
          '164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7' +
          'ea2505549758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b' +
          '636e070a38bce737'
    }
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
    data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                     'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                      'hex'),
    hmac: {
      sha224: '7fb3cb3588c6c1f6ffa9694d7d6ad2649365b0c1f65d69d1ec8333ea',
      sha256:
          '773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514' +
          'ced565fe',
      sha384:
          '88062608d3e6ad8a0aa2ace014c8a86f0aa635d947ac9febe83ef4e5' +
          '5966144b2a5ab39dc13814b94e3ab6e101a34f27',
      sha512:
          'fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33' +
          'b2279d39bf3e848279a722c806b485a47e67c807b946a337bee89426' +
          '74278859e13292fb'
    }
  },
  {
    key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                     'hex'),
    data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                     'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd',
                      'hex'),
    hmac: {
      sha224: '6c11506874013cac6a2abc1bb382627cec6a90d86efc012de7afec5a',
      sha256:
          '82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff4' +
          '6729665b',
      sha384:
          '3e8a69b7783c25851933ab6290af6ca77a9981480850009cc5577c6e' +
          '1f573b4e6801dd23c4a7d679ccf8a386c674cffb',
      sha512:
          'b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050' +
          '361ee3dba91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2d' +
          'e2adebeb10a298dd'
    }
  },

  {
    key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
    // 'Test With Truncation'
    data: Buffer.from('546573742057697468205472756e636174696f6e', 'hex'),
    hmac: {
      sha224: '0e2aea68a90c8d37c988bcdb9fca6fa8',
      sha256: 'a3b6167473100ee06e0c796c2955552b',
      sha384: '3abf34c3503b2a23a46efc619baef897',
      sha512: '415fad6271580a531d4179bc891d87a6'
    },
    truncate: true
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaa', 'hex'),
    // 'Test Using Larger Than Block-Size Key - Hash Key First'
    data: Buffer.from('54657374205573696e67204c6172676572205468616e20426' +
                     'c6f636b2d53697a65204b6579202d2048617368204b657920' +
                     '4669727374', 'hex'),
    hmac: {
      sha224: '95e9a0db962095adaebe9b2d6f0dbce2d499f112f2d2b7273fa6870e',
      sha256:
          '60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f' +
          '0ee37f54',
      sha384:
          '4ece084485813e9088d2c63a041bc5b44f9ef1012a2b588f3cd11f05' +
          '033ac4c60c2ef6ab4030fe8296248df163f44952',
      sha512:
          '80b24263c7c1a3ebb71493c1dd7be8b49b46d1f41b4aeec1121b0137' +
          '83f8f3526b56d037e05f2598bd0fd2215d6a1e5295e64f73f63f0aec' +
          '8b915a985d786598'
    }
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaa', 'hex'),
    // 'This is a test using a larger than block-size key and a larger ' +
    // 'than block-size data. The key needs to be hashed before being ' +
    // 'used by the HMAC algorithm.'
    data: Buffer.from('5468697320697320612074657374207573696e672061206c6' +
                     '172676572207468616e20626c6f636b2d73697a65206b6579' +
                     '20616e642061206c6172676572207468616e20626c6f636b2' +
                     'd73697a6520646174612e20546865206b6579206e65656473' +
                     '20746f20626520686173686564206265666f7265206265696' +
                     'e6720757365642062792074686520484d414320616c676f72' +
                     '6974686d2e', 'hex'),
    hmac: {
      sha224: '3a854166ac5d9f023f54d517d0b39dbd946770db9c2b95c9f6f565d1',
      sha256:
          '9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f5153' +
          '5c3a35e2',
      sha384:
          '6617178e941f020d351e2f254e8fd32c602420feb0b8fb9adccebb82' +
          '461e99c5a678cc31e799176d3860e6110c46523e',
      sha512:
          'e37b6a775dc87dbaa4dfa9f96e5e3ffddebd71f8867289865df5a32d' +
          '20cdc944b6022cac3c4982b10d5eeb55c3e4de15134676fb6de04460' +
          '65c97440fa8c6a58'
    }
  },
];

for (let i = 0, l = rfc4231.length; i < l; i++) {
  for (const hash in rfc4231[i].hmac) {
    if (!getHashes().includes(hash))
      continue;
    const str = crypto.createHmac(hash, rfc4231[i].key);
    str.end(rfc4231[i].data);
    let strRes = str.read().toString('hex');
    let actual = crypto.createHmac(hash, rfc4231[i].key)
                       .update(rfc4231[i].data)
                       .digest('hex');
    if (rfc4231[i].truncate) {
      actual = actual.substr(0, 32); // first 128 bits == 32 hex chars
      strRes = strRes.substr(0, 32);
    }
    const expected = rfc4231[i].hmac[hash];
    assert.strictEqual(
      actual,
      expected,
      `Test HMAC-${hash} rfc 4231 case ${i + 1}: ${actual} must be ${expected}`
    );
    assert.strictEqual(
      actual,
      strRes,
      `Should get same result from stream (hash: ${hash} and case: ${i + 1})` +
      ` => ${actual} must be ${strRes}`
    );
  }
}

// Test HMAC-MD5/SHA1 (rfc 2202 Test Cases)
const rfc2202_md5 = [
  {
    key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
    data: 'Hi There',
    hmac: '9294727a3638bb1c13f48ef8158bfc9d'
  },
  {
    key: 'Jefe',
    data: 'what do ya want for nothing?',
    hmac: '750c783e6ab0b503eaa86e310a5db738'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
    data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddddddd' +
                     'ddddddddddddddddddddddddddddddddddddddddddddddddddd',
                      'hex'),
    hmac: '56be34521d144c88dbb8c733f0e8b3f6'
  },
  {
    key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                     'hex'),
    data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                     'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                     'cdcdcdcdcd',
                      'hex'),
    hmac: '697eaf0aca3a3aea3a75164746ffaa79'
  },
  {
    key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
    data: 'Test With Truncation',
    hmac: '56461ef2342edc00f9bab995690efd4c'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data: 'Test Using Larger Than Block-Size Key - Hash Key First',
    hmac: '6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data:
        'Test Using Larger Than Block-Size Key and Larger Than One ' +
        'Block-Size Data',
    hmac: '6f630fad67cda0ee1fb1f562db3aa53e'
  },
];

for (const { key, data, hmac } of rfc2202_md5)
  testHmac('md5', key, data, hmac);

const rfc2202_sha1 = [
  {
    key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),
    data: 'Hi There',
    hmac: 'b617318655057264e28bc0b6fb378c8ef146be00'
  },
  {
    key: 'Jefe',
    data: 'what do ya want for nothing?',
    hmac: 'effcdf6ae5eb2fa2d27416d5f184df9c259a7c79'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'hex'),
    data: Buffer.from('ddddddddddddddddddddddddddddddddddddddddddddd' +
                     'ddddddddddddddddddddddddddddddddddddddddddddd' +
                     'dddddddddd',
                      'hex'),
    hmac: '125d7342b9ac11cd91a39af48aa17b4f63f175d3'
  },
  {
    key: Buffer.from('0102030405060708090a0b0c0d0e0f10111213141516171819',
                     'hex'),
    data: Buffer.from('cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdc' +
                     'dcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd' +
                     'cdcdcdcdcd',
                      'hex'),
    hmac: '4c9007f4026250c6bc8414f9bf50c86c2d7235da'
  },
  {
    key: Buffer.from('0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c', 'hex'),
    data: 'Test With Truncation',
    hmac: '4c1a03424b55e07fe7f27be1d58bb9324a9a5a04'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data: 'Test Using Larger Than Block-Size Key - Hash Key First',
    hmac: 'aa4ae5e15272d00e95705637ce8a3b55ed402112'
  },
  {
    key: Buffer.from('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
                    'aaaaaaaaaaaaaaaaaaaaaa',
                     'hex'),
    data:
        'Test Using Larger Than Block-Size Key and Larger Than One ' +
        'Block-Size Data',
    hmac: 'e8e99d0f45237d786d6bbaa7965c7808bbff1a91'
  },
];

for (const { key, data, hmac } of rfc2202_sha1)
  testHmac('sha1', key, data, hmac);

assert.strictEqual(
  crypto.createHmac('sha256', 'w00t').digest('ucs2'),
  crypto.createHmac('sha256', 'w00t').digest().toString('ucs2'));

// Check initialized -> uninitialized state transition after calling digest().
/*{
  const expected =
      '\u0010\u0041\u0052\u00c5\u00bf\u00dc\u00a0\u007b\u00c6\u0033' +
      '\u00ee\u00bd\u0046\u0019\u009f\u0002\u0055\u00c9\u00f4\u009d';
  {
    const h = crypto.createHmac('sha1', 'key').update('data');
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(expected, 'latin1'));
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(''));
  }
  {
    const h = crypto.createHmac('sha1', 'key').update('data');
    assert.strictEqual(h.digest('latin1'), expected);
    assert.strictEqual(h.digest('latin1'), '');
  }
}

// Check initialized -> uninitialized state transition after calling digest().
// Calls to update() omitted intentionally.
{
  const expected =
      '\u00f4\u002b\u00b0\u00ee\u00b0\u0018\u00eb\u00bd\u0045\u0097' +
      '\u00ae\u0072\u0013\u0071\u001e\u00c6\u0007\u0060\u0084\u003f';
  {
    const h = crypto.createHmac('sha1', 'key');
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(expected, 'latin1'));
    assert.deepStrictEqual(h.digest('buffer'), Buffer.from(''));
  }
  {
    const h = crypto.createHmac('sha1', 'key');
    assert.strictEqual(h.digest('latin1'), expected);
    assert.strictEqual(h.digest('latin1'), '');
  }
}

{
  assert.throws(
    () => crypto.createHmac('sha7', 'key'),
    /Invalid digest/);
}*/

{
  const buf = Buffer.alloc(0);
  const keyObject = crypto.createSecretKey(Buffer.alloc(0));
  assert.deepStrictEqual(
    crypto.createHmac('sha256', buf).update('foo').digest(),
    crypto.createHmac('sha256', keyObject).update('foo').digest(),
  );
}
"
modules/internal/fs/cp/cp-sync.js,"// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

'use strict';

// This file is a modified version of the fs-extra's copySync method.

import { areIdentical, isSrcSubdir } from ""./cp"";
import * as codes from ""../../errors"";
import { os } from ""../../../internal_binding/constants"";
const {
  errno: {
    EEXIST,
    EISDIR,
    EINVAL,
    ENOTDIR,
  }
} = os;
const {
  ERR_FS_CP_DIR_TO_NON_DIR,
  ERR_FS_CP_EEXIST,
  ERR_FS_CP_EINVAL,
  ERR_FS_CP_FIFO_PIPE,
  ERR_FS_CP_NON_DIR_TO_DIR,
  ERR_FS_CP_SOCKET,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
  ERR_FS_CP_UNKNOWN,
  ERR_FS_EISDIR,
  ERR_INVALID_RETURN_VALUE,
} = codes;
import {
  chmodSync,
  copyFileSync,
  existsSync,
  lstatSync,
  mkdirSync,
  opendirSync,
  readlinkSync,
  statSync,
  symlinkSync,
  unlinkSync,
  utimesSync
} from ""internal/fs"";
import { dirname, isAbsolute, join, parse, resolve } from 'path';
import { isPromise } from 'util/types';
import process from ""process"";

function cpSyncFn(src, dest, opts) {
  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    const warning = 'Using the preserveTimestamps option in 32-bit ' +
      'node is not recommended';
    process.emitWarning(warning, 'TimestampPrecisionWarning');
  }
  const { srcStat, destStat } = checkPathsSync(src, dest, opts);
  checkParentPathsSync(src, srcStat, dest);
  return handleFilterAndCopy(destStat, src, dest, opts);
}

function checkPathsSync(src, dest, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts);

  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL({
        message: 'src and dest cannot be the same',
        path: dest,
        syscall: 'cp',
        errno: EINVAL,
        code: 'EINVAL',
      });
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new ERR_FS_CP_DIR_TO_NON_DIR({
        message: `cannot overwrite directory ${src} ` +
          `with non-directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: EISDIR,
        code: 'EISDIR',
      });
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new ERR_FS_CP_NON_DIR_TO_DIR({
        message: `cannot overwrite non-directory ${src} ` +
          `with directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: ENOTDIR,
        code: 'ENOTDIR',
      });
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return { srcStat, destStat };
}

function getStatsSync(src, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ?
    (file) => statSync(file, { bigint: true }) :
    (file) => lstatSync(file, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}

function checkParentPathsSync(src, srcStat, dest) {
  const srcParent = resolve(dirname(src));
  const destParent = resolve(dirname(dest));
  // there is not root path in wasm32-wasi
  if (destParent === srcParent || destParent === parse(destParent).root || destParent === ""."") return;
  let destStat;
  try {  
    destStat = statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === 'ENOENT') return;
    throw err;
  }
  if (areIdentical(srcStat, destStat)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return checkParentPathsSync(src, srcStat, destParent);
}

function handleFilterAndCopy(destStat, src, dest, opts) {
  if (opts.filter) {
    const shouldCopy = opts.filter(src, dest);
    if (isPromise(shouldCopy)) {
      throw new ERR_INVALID_RETURN_VALUE('boolean', 'filter', shouldCopy);
    }
    if (!shouldCopy) return;
  }
  const destParent = dirname(dest);
  if (!existsSync(destParent)) mkdirSync(destParent, { recursive: true });
  return getStats(destStat, src, dest, opts);
}

function startCopy(destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return;
  return getStats(destStat, src, dest, opts);
}

function getStats(destStat, src, dest, opts) {
  const statSyncFn = opts.dereference ? statSync : lstatSync;
  const srcStat = statSyncFn(src);
  if (srcStat.isDirectory() && opts.recursive) {
    return onDir(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isDirectory()) {
    throw new ERR_FS_EISDIR({
      message: `${src} is a directory (not copied)`,
      path: src,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EISDIR',
    });
  } else if (srcStat.isFile() ||
    srcStat.isCharacterDevice() ||
    srcStat.isBlockDevice()) {
    return onFile(srcStat, destStat, src, dest, opts);
  } else if (srcStat.isSymbolicLink()) {
    return onLink(destStat, src, dest, opts);
  } else if (srcStat.isSocket()) {
    throw new ERR_FS_CP_SOCKET({
      message: `cannot copy a socket file: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  } else if (srcStat.isFIFO()) {
    throw new ERR_FS_CP_FIFO_PIPE({
      message: `cannot copy a FIFO pipe: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  throw new ERR_FS_CP_UNKNOWN({
    message: `cannot copy an unknown file type: ${dest}`,
    path: dest,
    syscall: 'cp',
    errno: EINVAL,
    code: 'EINVAL',
  });
}

function onFile(srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts);
  return mayCopyFile(srcStat, src, dest, opts);
}

function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.force) {
    unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new ERR_FS_CP_EEXIST({
      message: `${dest} already exists`,
      path: dest,
      syscall: 'cp',
      errno: EEXIST,
      code: 'EEXIST',
    });
  }
}

function copyFile(srcStat, src, dest, opts) {
  copyFileSync(src, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
  return setDestMode(dest, srcStat.mode);
}

function handleTimestamps(srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
  return setDestTimestamps(src, dest);
}

function fileIsNotWritable(srcMode) {
  return (srcMode & 0o200) === 0;
}

function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200);
}

function setDestMode(dest, srcMode) {
  return chmodSync(dest, srcMode);
}

function setDestTimestamps(src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = statSync(src);
  return utimesSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}

function onDir(srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
  return copyDir(src, dest, opts);
}

function mkDirAndCopy(srcMode, src, dest, opts) {
  mkdirSync(dest);
  copyDir(src, dest, opts);
  return setDestMode(dest, srcMode);
}

function copyDir(src, dest, opts) {
  const dir = opendirSync(src);

  try {
    let dirent;

    while ((dirent = dir.readSync()) !== null) {
      const { name } = dirent;
      const srcItem = join(src, name);
      const destItem = join(dest, name);
      const { destStat } = checkPathsSync(srcItem, destItem, opts);

      startCopy(destStat, srcItem, destItem, opts);
    }
  } finally {
    dir.closeSync();
  }
}

function onLink(destStat, src, dest, opts) {
  let resolvedSrc = readlinkSync(src);
  if (!opts.verbatimSymlinks && !isAbsolute(resolvedSrc)) {
    resolvedSrc = resolve(dirname(src), resolvedSrc);
  }
  if (!destStat) {
    return symlinkSync(resolvedSrc, dest);
  }
  let resolvedDest;
  try {
    resolvedDest = readlinkSync(dest);
  } catch (err) {
    // Dest exists and is a regular file or directory,
    // Windows may throw UNKNOWN error. If dest already exists,
    // fs throws error anyway, so no need to guard against it here.
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {
      return symlinkSync(resolvedSrc, dest);
    }
    throw err;
  }
  if (!isAbsolute(resolvedDest)) {
    resolvedDest = resolve(dirname(dest), resolvedDest);
  }
  if (isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +
        `${resolvedDest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  // Prevent copy if src is a subdir of dest since unlinking
  // dest in this case would result in removing src contents
  // and therefore a broken symlink would be created.
  if (statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
      code: 'EINVAL',
    });
  }
  return copyLink(resolvedSrc, dest);
}

function copyLink(resolvedSrc, dest) {
  unlinkSync(dest);
  return symlinkSync(resolvedSrc, dest);
}

export default cpSyncFn;
"
modules/internal/crypto/diffiehellman.js,"use strict';

const {
  ArrayBufferPrototypeSlice,
  FunctionPrototypeCall,
  MathCeil,
  ObjectDefineProperty,
  Promise,
  SafeSet,
} = primordials;

const { Buffer } = require('buffer');

const {
  DiffieHellman: _DiffieHellman,
  DiffieHellmanGroup: _DiffieHellmanGroup,
  ECDH: _ECDH,
  ECDHBitsJob,
  ECDHConvertKey: _ECDHConvertKey,
  statelessDH,
  kCryptoJobAsync,
} = internalBinding('crypto');

const {
  codes: {
    ERR_CRYPTO_ECDH_INVALID_FORMAT,
    ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY,
    ERR_CRYPTO_INCOMPATIBLE_KEY,
    ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE,
  }
} = require('internal/errors');

const {
  validateFunction,
  validateInt32,
  validateObject,
  validateString,
  validateUint32,
} = require('internal/validators');

const {
  isArrayBufferView,
  isAnyArrayBuffer,
} = require('internal/util/types');

const {
  lazyDOMException,
} = require('internal/util');

const {
  KeyObject,
  isCryptoKey,
} = require('internal/crypto/keys');

const {
  getArrayBufferOrView,
  getDefaultEncoding,
  toBuf,
  kHandle,
  kKeyObject,
} = require('internal/crypto/util');

const {
  crypto: {
    POINT_CONVERSION_COMPRESSED,
    POINT_CONVERSION_HYBRID,
    POINT_CONVERSION_UNCOMPRESSED,
  }
} = internalBinding('constants');

const DH_GENERATOR = 2;

function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {
  if (!(this instanceof DiffieHellman))
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);

  if (typeof sizeOrKey !== 'number' &&
      typeof sizeOrKey !== 'string' &&
      !isArrayBufferView(sizeOrKey) &&
      !isAnyArrayBuffer(sizeOrKey)) {
    throw new ERR_INVALID_ARG_TYPE(
      'sizeOrKey',
      ['number', 'string', 'ArrayBuffer', 'Buffer', 'TypedArray', 'DataView'],
      sizeOrKey
    );
  }

  // Sizes < 0 don't make sense but they _are_ accepted (and subsequently
  // rejected with ERR_OSSL_BN_BITS_TOO_SMALL) by OpenSSL. The glue code
  // in node_crypto.cc accepts values that are IsInt32() for that reason
  // and that's why we do that here too.
  if (typeof sizeOrKey === 'number')
    validateInt32(sizeOrKey, 'sizeOrKey');

  if (keyEncoding && !Buffer.isEncoding(keyEncoding) &&
      keyEncoding !== 'buffer') {
    genEncoding = generator;
    generator = keyEncoding;
    keyEncoding = false;
  }

  const encoding = getDefaultEncoding();
  keyEncoding = keyEncoding || encoding;
  genEncoding = genEncoding || encoding;

  if (typeof sizeOrKey !== 'number')
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);

  if (!generator) {
    generator = DH_GENERATOR;
  } else if (typeof generator === 'number') {
    validateInt32(generator, 'generator');
  } else if (typeof generator === 'string') {
    generator = toBuf(generator, genEncoding);
  } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer(generator)) {
    throw new ERR_INVALID_ARG_TYPE(
      'generator',
      ['number', 'string', 'ArrayBuffer', 'Buffer', 'TypedArray', 'DataView'],
      generator
    );
  }


  this[kHandle] = new _DiffieHellman(sizeOrKey, generator);
  ObjectDefineProperty(this, 'verifyError', {
    __proto__: null,
    enumerable: true,
    value: this[kHandle].verifyError,
    writable: false
  });
}


function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this[kHandle] = new _DiffieHellmanGroup(name);
  ObjectDefineProperty(this, 'verifyError', {
    __proto__: null,
    enumerable: true,
    value: this[kHandle].verifyError,
    writable: false
  });
}


DiffieHellmanGroup.prototype.generateKeys =
    DiffieHellman.prototype.generateKeys =
    dhGenerateKeys;

function dhGenerateKeys(encoding) {
  const keys = this[kHandle].generateKeys();
  encoding = encoding || getDefaultEncoding();
  return encode(keys, encoding);
}


DiffieHellmanGroup.prototype.computeSecret =
    DiffieHellman.prototype.computeSecret =
    dhComputeSecret;

function dhComputeSecret(key, inEnc, outEnc) {
  const encoding = getDefaultEncoding();
  inEnc = inEnc || encoding;
  outEnc = outEnc || encoding;
  key = getArrayBufferOrView(key, 'key', inEnc);
  const ret = this[kHandle].computeSecret(key);
  if (typeof ret === 'string')
    throw new ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY();
  return encode(ret, outEnc);
}


DiffieHellmanGroup.prototype.getPrime =
    DiffieHellman.prototype.getPrime =
    dhGetPrime;

function dhGetPrime(encoding) {
  const prime = this[kHandle].getPrime();
  encoding = encoding || getDefaultEncoding();
  return encode(prime, encoding);
}


DiffieHellmanGroup.prototype.getGenerator =
    DiffieHellman.prototype.getGenerator =
    dhGetGenerator;

function dhGetGenerator(encoding) {
  const generator = this[kHandle].getGenerator();
  encoding = encoding || getDefaultEncoding();
  return encode(generator, encoding);
}


DiffieHellmanGroup.prototype.getPublicKey =
    DiffieHellman.prototype.getPublicKey =
    dhGetPublicKey;

function dhGetPublicKey(encoding) {
  const key = this[kHandle].getPublicKey();
  encoding = encoding || getDefaultEncoding();
  return encode(key, encoding);
}


DiffieHellmanGroup.prototype.getPrivateKey =
    DiffieHellman.prototype.getPrivateKey =
    dhGetPrivateKey;

function dhGetPrivateKey(encoding) {
  const key = this[kHandle].getPrivateKey();
  encoding = encoding || getDefaultEncoding();
  return encode(key, encoding);
}


DiffieHellman.prototype.setPublicKey = function setPublicKey(key, encoding) {
  encoding = encoding || getDefaultEncoding();
  key = getArrayBufferOrView(key, 'key', encoding);
  this[kHandle].setPublicKey(key);
  return this;
};


DiffieHellman.prototype.setPrivateKey = function setPrivateKey(key, encoding) {
  encoding = encoding || getDefaultEncoding();
  key = getArrayBufferOrView(key, 'key', encoding);
  this[kHandle].setPrivateKey(key);
  return this;
};


function ECDH(curve) {
  if (!(this instanceof ECDH))
    return new ECDH(curve);

  validateString(curve, 'curve');
  this[kHandle] = new _ECDH(curve);
}

ECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret;
ECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey;
ECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey;
ECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey;

ECDH.prototype.generateKeys = function generateKeys(encoding, format) {
  this[kHandle].generateKeys();

  return this.getPublicKey(encoding, format);
};

ECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {
  const f = getFormat(format);
  const key = this[kHandle].getPublicKey(f);
  encoding = encoding || getDefaultEncoding();
  return encode(key, encoding);
};

ECDH.convertKey = function convertKey(key, curve, inEnc, outEnc, format) {
  validateString(curve, 'curve');
  const encoding = inEnc || getDefaultEncoding();
  key = getArrayBufferOrView(key, 'key', encoding);
  outEnc = outEnc || encoding;
  const f = getFormat(format);
  const convertedKey = _ECDHConvertKey(key, curve, f);
  return encode(convertedKey, outEnc);
};

function encode(buffer, encoding) {
  if (encoding && encoding !== 'buffer')
    buffer = buffer.toString(encoding);
  return buffer;
}

function getFormat(format) {
  if (format) {
    if (format === 'compressed')
      return POINT_CONVERSION_COMPRESSED;
    if (format === 'hybrid')
      return POINT_CONVERSION_HYBRID;
    if (format !== 'uncompressed')
      throw new ERR_CRYPTO_ECDH_INVALID_FORMAT(format);
  }
  return POINT_CONVERSION_UNCOMPRESSED;
}

const dhEnabledKeyTypes = new SafeSet(['dh', 'ec', 'x448', 'x25519']);

function diffieHellman(options) {
  validateObject(options, 'options');

  const { privateKey, publicKey } = options;
  if (!(privateKey instanceof KeyObject))
    throw new ERR_INVALID_ARG_VALUE('options.privateKey', privateKey);

  if (!(publicKey instanceof KeyObject))
    throw new ERR_INVALID_ARG_VALUE('options.publicKey', publicKey);

  if (privateKey.type !== 'private')
    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(privateKey.type, 'private');

  if (publicKey.type !== 'public' && publicKey.type !== 'private') {
    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(publicKey.type,
                                                 'private or public');
  }

  const privateType = privateKey.asymmetricKeyType;
  const publicType = publicKey.asymmetricKeyType;
  if (privateType !== publicType || !dhEnabledKeyTypes.has(privateType)) {
    throw new ERR_CRYPTO_INCOMPATIBLE_KEY('key types for Diffie-Hellman',
                                          `${privateType} and ${publicType}`);
  }

  return statelessDH(privateKey[kHandle], publicKey[kHandle]);
}

// The deriveBitsECDH function is part of the Web Crypto API and serves both
// deriveKeys and deriveBits functions.
function deriveBitsECDH(name, publicKey, privateKey, callback) {
  validateString(name, 'name');
  validateObject(publicKey, 'publicKey');
  validateObject(privateKey, 'privateKey');
  validateFunction(callback, 'callback');
  const job = new ECDHBitsJob(kCryptoJobAsync, name, publicKey, privateKey);
  job.ondone = (error, bits) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, bits);
  };
  job.run();
}

async function asyncDeriveBitsECDH(algorithm, baseKey, length) {
  const { 'public': key } = algorithm;

  // Null means that we're not asking for a specific number of bits, just
  // give us everything that is generated.
  if (length !== null)
    validateUint32(length, 'length');
  if (!isCryptoKey(key))
    throw new ERR_INVALID_ARG_TYPE('algorithm.public', 'CryptoKey', key);

  if (key.type !== 'public') {
    throw lazyDOMException(
      'algorithm.public must be a public key', 'InvalidAccessError');
  }
  if (baseKey.type !== 'private') {
    throw lazyDOMException(
      'baseKey must be a private key', 'InvalidAccessError');
  }

  if (
    key.algorithm.name !== 'ECDH' &&
    key.algorithm.name !== 'X25519' &&
    key.algorithm.name !== 'X448'
  ) {
    throw lazyDOMException('Keys must be ECDH, X25519, or X448 keys', 'InvalidAccessError');
  }

  if (key.algorithm.name !== baseKey.algorithm.name) {
    throw lazyDOMException(
      'The public and private keys must be of the same type',
      'InvalidAccessError');
  }

  if (
    key.algorithm.name === 'ECDH' &&
    key.algorithm.namedCurve !== baseKey.algorithm.namedCurve
  ) {
    throw lazyDOMException('Named curve mismatch', 'InvalidAccessError');
  }

  const bits = await new Promise((resolve, reject) => {
    deriveBitsECDH(
      key.algorithm.name === 'ECDH' ? baseKey.algorithm.namedCurve : baseKey.algorithm.name,
      key[kKeyObject][kHandle],
      baseKey[kKeyObject][kHandle], (err, bits) => {
        if (err) return reject(err);
        resolve(bits);
      });
  });

  // If a length is not specified, return the full derived secret
  if (length === null)
    return bits;

  // If the length is not a multiple of 8 the nearest ceiled
  // multiple of 8 is sliced.
  length = MathCeil(length / 8);
  const { byteLength } = bits;

  // If the length is larger than the derived secret, throw.
  // Otherwise, we either return the secret or a truncated
  // slice.
  if (byteLength < length)
    throw lazyDOMException('derived bit length is too small', 'OperationError');

  return length === byteLength ?
    bits :
    ArrayBufferPrototypeSlice(bits, 0, length);
}

module.exports = {
  DiffieHellman,
  DiffieHellmanGroup,
  ECDH,
  diffieHellman,
  deriveBitsECDH,
  asyncDeriveBitsECDH,
};
"
modules/internal/streams/duplex.js,"
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { createDeferredPromise } from ""../util.js"";
import { destroyer } from ""./destroy.js"";
import {
    AbortError,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_RETURN_VALUE,
} from ""../errors.js"";
import {
    isDuplexNodeStream,
    isIterable,
    isNodeStream,
    isReadable,
    isReadableNodeStream,
    isWritable,
    isWritableNodeStream,
} from ""./utils.js"";
import _from from ""./from.js"";
import eos from ""./end-of-stream.js"";
import Readable from ""./readable.js"";
import Writable from ""./writable.js"";

function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }

    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;

    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }

        if (options.writable === false) {
            this.writable = false;
        }

        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}

Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);

Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, ""writable""),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableHighWaterMark"",
    ),
    writableObjectMode: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableObjectMode"",
    ),
    writableBuffer: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableBuffer"",
    ),
    writableLength: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableLength"",
    ),
    writableFinished: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableFinished"",
    ),
    writableCorked: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableCorked"",
    ),
    writableEnded: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableEnded"",
    ),
    writableNeedDrain: Object.getOwnPropertyDescriptor(
        Writable.prototype,
        ""writableNeedDrain"",
    ),

    destroyed: {
        get() {
            if (
                this._readableState === undefined ||
                this._writableState === undefined
            ) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
            // Backward compatibility, the user is explicitly
            // managing destroyed.
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        },
    },
});


{
    // Allow the keys array to be GC'ed.
    for (const method of Object.keys(Writable.prototype)) {
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}


function isReadableStream(object) {
    return object instanceof ReadableStream;
}

function isWritableStream(object) {
    return object instanceof WritableStream;
}

Duplex.fromWeb = function (pair, options) { }

class Duplexify extends Duplex {
    constructor(options) {
        super(options);

        // https://github.com/nodejs/node/pull/34385

        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }

        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}


function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
        return body;
    }

    if (isReadableNodeStream(body)) {
        return _duplexify({ readable: body });
    }

    if (isWritableNodeStream(body)) {
        return _duplexify({ writable: body });
    }

    if (isNodeStream(body)) {
        return _duplexify({ writable: false, readable: false });
    }

    // TODO: Webstreams
    // if (isReadableStream(body)) {
    //   return _duplexify({ readable: Readable.fromWeb(body) });
    // }

    // TODO: Webstreams
    // if (isWritableStream(body)) {
    //   return _duplexify({ writable: Writable.fromWeb(body) });
    // }

    if (typeof body === ""function"") {
        const { value, write, final, destroy } = fromAsyncGen(body);

        if (isIterable(value)) {
            return _from(Duplexify, value, {
                // TODO (ronag): highWaterMark?
                objectMode: true,
                write,
                final,
                destroy,
            });
        }

        const then = value?.then;
        if (typeof then === ""function"") {
            let d;

            const promise = then.call(
                value,
                (val) => {
                    if (val != null) {
                        throw new ERR_INVALID_RETURN_VALUE(""nully"", ""body"", val);
                    }
                },
                (err) => {
                    destroyer(d, err);
                },
            );

            return d = new Duplexify({
                // TODO (ronag): highWaterMark?
                objectMode: true,
                readable: false,
                write,
                final(cb) {
                    final(async () => {
                        try {
                            await promise;
                            nextTick(cb, null);
                        } catch (err) {
                            nextTick(cb, err);
                        }
                    });
                },
                destroy,
            });
        }

        throw new ERR_INVALID_RETURN_VALUE(
            ""Iterable, AsyncIterable or AsyncFunction"",
            name,
            value,
        );
    }

    // if (isBlob(body)) {
    //     return duplexify(body.arrayBuffer());
    // }

    if (isIterable(body)) {
        return _from(Duplexify, body, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            writable: false,
        });
    }

    // TODO: Webstreams.
    // if (
    //   isReadableStream(body?.readable) &&
    //   isWritableStream(body?.writable)
    // ) {
    //   return Duplexify.fromWeb(body);
    // }

    if (
        typeof body?.writable === ""object"" ||
        typeof body?.readable === ""object""
    ) {
        const readable = body?.readable
            ? isReadableNodeStream(body?.readable)
                ? body?.readable
                : duplexify(body.readable)
            : undefined;

        const writable = body?.writable
            ? isWritableNodeStream(body?.writable)
                ? body?.writable
                : duplexify(body.writable)
            : undefined;

        return _duplexify({ readable, writable });
    }

    const then = body?.then;
    if (typeof then === ""function"") {
        let d;

        then.call(
            body,
            (val) => {
                if (val != null) {
                    d.push(val);
                }
                d.push(null);
            },
            (err) => {
                destroyer(d, err);
            },
        );

        return d = new Duplexify({
            objectMode: true,
            writable: false,
            read() { },
        });
    }

    throw new ERR_INVALID_ARG_TYPE(
        name,
        [
            // ""Blob"",
            // ""ReadableStream"",
            // ""WritableStream"",
            ""Stream"",
            ""Iterable"",
            ""AsyncIterable"",
            ""Function"",
            ""{ readable, writable } pair"",
            ""Promise"",
        ],
        body,
    );
}

function fromAsyncGen(fn) {
    let { promise, resolve } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(
        async function* () {
            while (true) {
                const _promise = promise;
                promise = null;
                const { chunk, done, cb } = await _promise;
                nextTick(cb);
                if (done) return;
                if (signal.aborted) throw new AbortError();
                ({ promise, resolve } = createDeferredPromise());
                yield chunk;
            }
        }(),
        { signal },
    );

    return {
        value,
        write(chunk, encoding, cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({ chunk, done: false, cb });
        },
        final(cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({ done: true, cb });
        },
        destroy(err, cb) {
            ac.abort();
            cb(err);
        },
    };
}


function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== ""function""
        ? Readable.wrap(pair.readable)
        : pair.readable;
    const w = pair.writable;

    let readable = !!isReadable(r);
    let writable = !!isWritable(w);

    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;

    function onfinished(err) {
        const cb = onclose;
        onclose = null;

        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }

    // TODO(ronag): Avoid double buffering.
    // Implement Writable/Readable/Duplex traits.
    // See, https://github.com/nodejs/node/pull/33515.
    d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable,
    });

    if (writable) {
        eos(w, (err) => {
            writable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });

        d._write = function (chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };

        d._final = function (callback) {
            w.end();
            onfinish = callback;
        };

        w.on(""drain"", function () {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });

        w.on(""finish"", function () {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }

    if (readable) {
        eos(r, (err) => {
            readable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });

        r.on(""readable"", function () {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });

        r.on(""end"", function () {
            d.push(null);
        });

        d._read = function () {
            while (true) {
                const buf = r.read();

                if (buf === null) {
                    onreadable = d._read;
                    return;
                }

                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }

    d._destroy = function (err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }

        onreadable = null;
        ondrain = null;
        onfinish = null;

        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
        }
    };

    return d;
}


function duplexFrom(body) {
    return duplexify(body, ""body"");
}

Duplex.from = duplexFrom;

export default Duplex;
export { duplexFrom as from, duplexify };"
modules/string_decoder.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

import {Buffer} from 'buffer';
var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
export function StringDecoder(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}"
test/common.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/* eslint-disable node-core/crypto-check */
'use strict';

import { inspect } from ""internal/util/inspect"";

import assert from ""assert"";
import process from ""process"";

const isWindows = process.platform === 'win32';
const isAIX = process.platform === 'aix';
const isSunOS = process.platform === 'sunos';
const isFreeBSD = process.platform === 'freebsd';
const isOpenBSD = process.platform === 'openbsd';
const isLinux = process.platform === 'linux';
const isOSX = process.platform === 'darwin';
const isPi = false;
const isMainThread = true;
const isDumbTerminal = process.env.TERM === 'dumb';
const hasOpenSSL3 = true;
const mustCallChecks = [];

function runCallChecks() {
  if (globalThis.assertPass === false) return;

  const failed = mustCallChecks.filter(function (context) {
    if ('minimum' in context) {
      context.messageSegment = `at least ${context.minimum}`;
      return context.actual < context.minimum;
    }
    context.messageSegment = `exactly ${context.exact}`;
    return context.actual !== context.exact;
  });

  failed.forEach(function (context) {
    print(`Mismatched ${context.name} function calls. Expected ${context.messageSegment}, actual ${context.actual}.`);
    print(context.stack.split('\n').slice(2).join('\n'));
  });

  assert.strictEqual(failed.length, 0);
}

const noop = () => { };

function _mustCallInner(fn, criteria = 1, field) {
  if (typeof fn === 'number') {
    criteria = fn;
    fn = noop;
  } else if (fn === undefined) {
    fn = noop;
  }

  if (typeof criteria !== 'number')
    throw new TypeError(`Invalid ${field} value: ${criteria}`);

  const context = {
    [field]: criteria,
    actual: 0,
    stack: inspect(new Error()),
    name: fn.name || '<anonymous>'
  };

  // Add the exit listener only once to avoid listener leak warnings
  if (mustCallChecks.length === 0) {
    globalThis.commonExitCheck = runCallChecks;
  };

  mustCallChecks.push(context);

  const _return = function () { // eslint-disable-line func-style
    context.actual++;
    return fn.apply(this, arguments);
  };
  // Function instances have own properties that may be relevant.
  // Let's replicate those properties to the returned function.
  // Refs: https://tc39.es/ecma262/#sec-function-instances
  Object.defineProperties(_return, {
    name: {
      value: fn.name,
      writable: false,
      enumerable: false,
      configurable: true,
    },
    length: {
      value: fn.length,
      writable: false,
      enumerable: false,
      configurable: true,
    },
  });
  return _return;
}

export function mustCall(fn, exact) {
  return _mustCallInner(fn, exact, 'exact');
}

export function mustSucceed(fn, exact) {
  return mustCall(function (err, ...args) {
    if (err) {
      print(""must succeed but got: "", err);
      print(err.stack);
    }
    assert.ifError(err);
    if (typeof fn === 'function')
      return fn.apply(this, args);
  }, exact);
}

export function mustCallAtLeast(fn, minimum) {
  return _mustCallInner(fn, minimum, 'minimum');
}

export function mustNotCall(msg) {
  const callSite = new Error().stack;
  return function mustNotCall(...args) {
    const argsInfo = args.length > 0 ?
      `\ncalled with arguments: ${args.map((arg) => inspect(arg)).join(', ')}` : '';
    assert.fail(
      `${msg || 'function should not have been called'} at ${callSite}` +
      argsInfo);
  };
}

const _mustNotMutateObjectDeepProxies = new WeakMap();

export function mustNotMutateObjectDeep(original) {
  // Return primitives and functions directly. Primitives are immutable, and
  // proxied functions are impossible to compare against originals, e.g. with
  // `assert.deepEqual()`.
  if (original === null || typeof original !== 'object') {
    return original;
  }

  const cachedProxy = _mustNotMutateObjectDeepProxies.get(original);
  if (cachedProxy) {
    return cachedProxy;
  }

  const _mustNotMutateObjectDeepHandler = {
    __proto__: null,
    defineProperty(target, property, descriptor) {
      assert.fail(`Expected no side effects, got ${inspect(property)} ` +
        'defined');
    },
    deleteProperty(target, property) {
      assert.fail(`Expected no side effects, got ${inspect(property)} ` +
        'deleted');
    },
    get(target, prop, receiver) {
      return mustNotMutateObjectDeep(Reflect.get(target, prop, receiver));
    },
    preventExtensions(target) {
      assert.fail('Expected no side effects, got extensions prevented on ' +
        inspect(target));
    },
    set(target, property, value, receiver) {
      assert.fail(`Expected no side effects, got ${inspect(value)} ` +
        `assigned to ${inspect(property)}`);
    },
    setPrototypeOf(target, prototype) {
      assert.fail(`Expected no side effects, got set prototype to ${prototype}`);
    }
  };

  const proxy = new Proxy(original, _mustNotMutateObjectDeepHandler);
  _mustNotMutateObjectDeepProxies.set(original, proxy);
  return proxy;
}

export function invalidArgTypeHelper(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === 'function' && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === 'object') {
    if (input.constructor?.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect(input, { depth: -1 })}`;
  }

  let inspected = inspect(input, { colors: false });
  if (inspected.length > 28) { inspected = `${inspected.slice(inspected, 0, 25)}...`; }

  return ` Received type ${typeof input} (${inspected})`;
}

export function skip(msg) {
  print(""skip, "", msg);
}

export function platformTimeout(ms) {
  return ms;
}

export function runWithInvalidFD(func) {
  let fd = 1 << 30;
  // Get first known bad file descriptor. 1 << 30 is usually unlikely to
  // be an valid one.
  try {
    while (fs.fstatSync(fd--) && fd > 0);
  } catch {
    return func(fd);
  }

  skip('Could not generate an invalid fd');
}

export function expectWarning() {
  // unsupported
}

// Useful for testing expected internal/error objects
export function expectsError(validator, exact) {
  return mustCall((...args) => {
    if (args.length !== 1) {
      // Do not use `assert.strictEqual()` to prevent `inspect` from
      // always being called.
      assert.fail(`Expected one argument, got ${inspect(args)}`);
    }
    const error = args.pop();
    const descriptor = Object.getOwnPropertyDescriptor(error, 'message');
    // The error message should be non-enumerable
    assert.strictEqual(descriptor.enumerable, false);

    assert.throws(() => { throw error; }, validator);
    return true;
  }, exact);
}
export function canCreateSymLink() {
  return true;
}

export function getArrayBufferViews(buf) {
  const { buffer, byteOffset, byteLength } = buf;

  const out = [];

  const arrayBufferViews = [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    BigInt64Array,
    BigUint64Array,
    DataView,
  ];

  for (const type of arrayBufferViews) {
    const { BYTES_PER_ELEMENT = 1 } = type;
    if (byteLength % BYTES_PER_ELEMENT === 0) {
      out.push(new type(buffer, byteOffset, byteLength / BYTES_PER_ELEMENT));
    }
  }
  return out;
}

export const hasCrypto = true;
export const hasFipsCrypto = true
const common = {
  isDumbTerminal,
  isFreeBSD,
  isLinux,
  isOpenBSD,
  isOSX,
  isPi,
  isSunOS,
  isWindows,
  isAIX,
  isMainThread,
  hasCrypto,
  hasOpenSSL3,
  hasFipsCrypto,
  mustCall,
  mustCallAtLeast,
  mustNotCall,
  mustNotMutateObjectDeep,
  skip,
  mustSucceed,
  invalidArgTypeHelper,
  platformTimeout,
  runWithInvalidFD,
  expectWarning,
  expectsError,
  canCreateSymLink,
  getArrayBufferViews
};

export default common;
"
modules/internal/crypto/cipher.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// TODO
const _privateDecrypt = () => { }
const _privateEncrypt = () => { }
const _publicDecrypt = () => { }
const _publicEncrypt = () => { }
const _getCipherInfo = () => { }

import { crypto as crypto_constants } from ""../../internal_binding/constants"";

const {
  RSA_PKCS1_OAEP_PADDING,
  RSA_PKCS1_PADDING,
} = crypto_constants;

import {
  ERR_CRYPTO_INVALID_STATE,
  ERR_CRYPTO_UNKNOWN_CIPHER,
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
} from '../errors';

import {
  validateEncoding,
  validateInt32,
  validateObject,
  validateString,
} from '../validators';

import {
  isKeyObject,
  preparePrivateKey,
  preparePublicOrPrivateKey,
  prepareSecretKey,
} from './keys';

import {
  getDefaultEncoding,
  getArrayBufferOrView,
  getStringOption,
  kHandle,
  getCiphers,
} from './util';

import {
  isArrayBufferView,
} from '../util/types';

import { assert } from '../assert';

import { LazyTransform } from '../streams/lazy_transform';

import { normalizeEncoding } from '../util';

import { StringDecoder } from 'string_decoder';

import { JsCipher as CipherBase } from ""_node:crypto"";

function rsaFunctionFor(method, defaultPadding, keyType) {
  return (options, buffer) => {
    const { format, type, data, passphrase } =
      keyType === 'private' ?
        preparePrivateKey(options) :
        preparePublicOrPrivateKey(options);
    const padding = options.padding || defaultPadding;
    const { oaepHash, encoding } = options;
    let { oaepLabel } = options;
    if (oaepHash !== undefined)
      validateString(oaepHash, 'key.oaepHash');
    if (oaepLabel !== undefined)
      oaepLabel = getArrayBufferOrView(oaepLabel, 'key.oaepLabel', encoding);
    buffer = getArrayBufferOrView(buffer, 'buffer', encoding);
    return method(data, format, type, passphrase, buffer, padding, oaepHash,
      oaepLabel);
  };
}

const publicEncrypt = rsaFunctionFor(_publicEncrypt, RSA_PKCS1_OAEP_PADDING,
  'public');
const publicDecrypt = rsaFunctionFor(_publicDecrypt, RSA_PKCS1_PADDING,
  'public');
const privateEncrypt = rsaFunctionFor(_privateEncrypt, RSA_PKCS1_PADDING,
  'private');
const privateDecrypt = rsaFunctionFor(_privateDecrypt, RSA_PKCS1_OAEP_PADDING,
  'private');

function getDecoder(decoder, encoding) {
  encoding = normalizeEncoding(encoding);
  decoder = decoder || new StringDecoder(encoding);
  assert(decoder.encoding === encoding, 'Cannot change encoding');
  return decoder;
}

function getUIntOption(options, key) {
  let value;
  if (options && (value = options[key]) != null) {
    if (value >>> 0 !== value)
      throw new ERR_INVALID_ARG_VALUE(`options.${key}`, value);
    return value;
  }
  return -1;
}

function createCipherBase(cipher, credential, options, decipher, iv) {
  const authTagLength = getUIntOption(options, 'authTagLength');
  if (iv === undefined) {
    // this[kHandle].init(cipher, credential, authTagLength);
  } else {
    this[kHandle] = new CipherBase(cipher, credential.buffer ?? credential, iv.buffer ?? iv, authTagLength, decipher);
  }
  this._decoder = null;

  Reflect.apply(LazyTransform, this, [options]);
}

function createCipher(cipher, password, options, decipher) {
  validateString(cipher, 'cipher');
  password = getArrayBufferOrView(password, 'password');

  Reflect.apply(createCipherBase, this, [cipher, password, options, decipher]);
}

function createCipherWithIV(cipher, key, options, decipher, iv) {
  validateString(cipher, 'cipher');
  const encoding = getStringOption(options, 'encoding');
  key = prepareSecretKey(key, encoding);
  if (isKeyObject(key)) {
    key = key.export();
  }
  iv = iv === null ? null : getArrayBufferOrView(iv, 'iv');
  if (!getCiphers().includes(cipher)) {
    throw new ERR_CRYPTO_UNKNOWN_CIPHER();
  }
  // Zero-sized IV should be rejected in GCM mode. 
  // Wasi-crypto current implemention only support GCM mode,
  // so always check
  if (iv.byteLength === 0) {
    throw new Error(""Invalid initialization vector"");
  }
  Reflect.apply(createCipherBase, this, [cipher, key, options, decipher, iv]);
}

// The Cipher class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Cipher class is defined using the legacy function syntax rather than
// ES6 classes.

function Cipher(cipher, password, options) {
  if (!(this instanceof Cipher))
    return new Cipher(cipher, password, options);

  Reflect.apply(createCipher, this, [cipher, password, options, true]);
}

Object.setPrototypeOf(Cipher.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Cipher, LazyTransform);

Cipher.prototype._transform = function _transform(chunk, encoding, callback) {
  this.push(this.update(chunk, encoding));
  callback();
};

Cipher.prototype._flush = function _flush(callback) {
  try {
    this.push(this.final());
  } catch (e) {
    callback(e);
    return;
  }
  callback();
};

Cipher.prototype.update = function update(data, inputEncoding, outputEncoding) {
  const encoding = getDefaultEncoding();
  inputEncoding = inputEncoding || encoding;
  outputEncoding = outputEncoding || encoding;

  if (typeof data === 'string') {
    validateEncoding(data, inputEncoding);
  } else if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data', ['string', 'Buffer', 'TypedArray', 'DataView'], data);
  }

  let buf = getArrayBufferOrView(data, ""data"", inputEncoding);
  const ret = this[kHandle].update(buf.buffer ?? buf);

  if (outputEncoding && outputEncoding !== 'buffer') {
    return """"; // current implemented doesn't return anything from update
    // this._decoder = getDecoder(this._decoder, outputEncoding);
    // return this._decoder.write(ret);
  }

  return ret;
};


Cipher.prototype.final = function final(outputEncoding) {
  outputEncoding = outputEncoding || getDefaultEncoding();
  const ret = this[kHandle].final();
  if (outputEncoding && outputEncoding !== 'buffer') {
    return Buffer.from(ret).toString(outputEncoding);
    // this._decoder = getDecoder(this._decoder, outputEncoding);
    // return this._decoder.end(ret);
  }

  return ret;
};


Cipher.prototype.setAutoPadding = function setAutoPadding(ap) {
  if (!this[kHandle].setAutoPadding(!!ap))
    throw new ERR_CRYPTO_INVALID_STATE('setAutoPadding');
  return this;
};

Cipher.prototype.getAuthTag = function getAuthTag() {
  const ret = this[kHandle].getAuthTag();
  if (ret === undefined)
    throw new ERR_CRYPTO_INVALID_STATE('getAuthTag');
  return ret;
};


function setAuthTag(tagbuf, encoding) {
  tagbuf = getArrayBufferOrView(tagbuf, 'buffer', encoding);
  if (!this[kHandle].setAuthTag(tagbuf.buffer ?? tagbuf))
    throw new ERR_CRYPTO_INVALID_STATE('setAuthTag');
  return this;
}

Cipher.prototype.setAAD = function setAAD(aadbuf, options) {
  const encoding = getStringOption(options, 'encoding');
  const plaintextLength = getUIntOption(options, 'plaintextLength');
  aadbuf = getArrayBufferOrView(aadbuf, 'aadbuf', encoding);
  if (!this[kHandle].setAAD(aadbuf.buffer ?? aadbuf, plaintextLength))
    throw new ERR_CRYPTO_INVALID_STATE('setAAD');
  return this;
};

// The Cipheriv class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Cipheriv class is defined using the legacy function syntax rather than
// ES6 classes.

function Cipheriv(cipher, key, iv, options) {
  if (!(this instanceof Cipheriv))
    return new Cipheriv(cipher, key, iv, options);

  Reflect.apply(createCipherWithIV, this, [cipher, key, options, true, iv]);
}

function addCipherPrototypeFunctions(constructor) {
  constructor.prototype._transform = Cipher.prototype._transform;
  constructor.prototype._flush = Cipher.prototype._flush;
  constructor.prototype.update = Cipher.prototype.update;
  constructor.prototype.final = Cipher.prototype.final;
  constructor.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;
  if (constructor === Cipheriv) {
    constructor.prototype.getAuthTag = Cipher.prototype.getAuthTag;
  } else {
    constructor.prototype.setAuthTag = setAuthTag;
  }
  constructor.prototype.setAAD = Cipher.prototype.setAAD;
}

Object.setPrototypeOf(Cipheriv.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Cipheriv, LazyTransform);
addCipherPrototypeFunctions(Cipheriv);

// The Decipher class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Decipher class is defined using the legacy function syntax rather than
// ES6 classes.

function Decipher(cipher, password, options) {
  if (!(this instanceof Decipher))
    return new Decipher(cipher, password, options);

  Reflect.apply(createCipher, this, [cipher, password, options, false]);
}

Object.setPrototypeOf(Decipher.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Decipher, LazyTransform);
addCipherPrototypeFunctions(Decipher);

// The Decipheriv class is part of the legacy Node.js crypto API. It exposes
// a stream-based encryption/decryption model. For backwards compatibility
// the Decipheriv class is defined using the legacy function syntax rather than
// ES6 classes.

function Decipheriv(cipher, key, iv, options) {
  if (!(this instanceof Decipheriv))
    return new Decipheriv(cipher, key, iv, options);

  Reflect.apply(createCipherWithIV, this, [cipher, key, options, false, iv]);
}

Object.setPrototypeOf(Decipheriv.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Decipheriv, LazyTransform);
addCipherPrototypeFunctions(Decipheriv);

function getCipherInfo(nameOrNid, options) {
  if (typeof nameOrNid !== 'string' && typeof nameOrNid !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(
      'nameOrNid',
      ['string', 'number'],
      nameOrNid);
  }
  if (typeof nameOrNid === 'number')
    validateInt32(nameOrNid, 'nameOrNid');
  let keyLength, ivLength;
  if (options !== undefined) {
    validateObject(options, 'options');
    ({ keyLength, ivLength } = options);
    if (keyLength !== undefined)
      validateInt32(keyLength, 'options.keyLength');
    if (ivLength !== undefined)
      validateInt32(ivLength, 'options.ivLength');
  }

  const ret = _getCipherInfo({}, nameOrNid, keyLength, ivLength);
  if (ret !== undefined) {
    if (ret.name) ret.name = String.prototype.toLowerCase.call(ret.name);
    if (ret.type) ret.type = String.prototype.toLowerCase.call(ret.type);
  }
  return ret;
}

export {
  // Cipher,
  Cipheriv,
  // Decipher,
  Decipheriv,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  getCipherInfo,
};
"
modules/timers.js,"import process from 'process';

var exports$2 = {},
    _dewExec$1 = false;

var _global$1 = typeof globalThis !== ""undefined"" ? globalThis : typeof self !== ""undefined"" ? self : global;

function dew$1() {
  if (_dewExec$1) { return exports$2; }
  _dewExec$1 = true;
  var process$1 = process;

  (function (global, undefined$1) {

    if (global.setImmediate) {
      return;
    }

    var nextHandle = 1; // Spec says greater than zero

    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      var arguments$1 = arguments;

      // Callback can either be a function or a string
      if (typeof callback !== ""function"") {
        callback = new Function("""" + callback);
      } // Copy function arguments


      var args = new Array(arguments.length - 1);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments$1[i + 1];
      } // Store and register the task


      var task = {
        callback: callback,
        args: args
      };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }

    function run(task) {
      var callback = task.callback;
      var args = task.args;

      switch (args.length) {
        case 0:
          callback();
          break;

        case 1:
          callback(args[0]);
          break;

        case 2:
          callback(args[0], args[1]);
          break;

        case 3:
          callback(args[0], args[1], args[2]);
          break;

        default:
          callback.apply(undefined$1, args);
          break;
      }
    }

    function runIfPresent(handle) {
      // From the spec: ""Wait until any invocations of this algorithm started before this one have completed.""
      // So if we're currently running a task, we'll need to delay this invocation.
      if (currentlyRunningATask) {
        // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
        // ""too much recursion"" error.
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];

        if (task) {
          currentlyRunningATask = true;

          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }

    function installNextTickImplementation() {
      registerImmediate = function (handle) {
        process$1.nextTick(function () {
          runIfPresent(handle);
        });
      };
    }

    function canUsePostMessage() {
      // The test against `importScripts` prevents this implementation from being installed inside a web worker,
      // where `global.postMessage` means something completely different and can't be used for this purpose.
      if (global.postMessage && !global.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global.onmessage;

        global.onmessage = function () {
          postMessageIsAsynchronous = false;
        };

        global.postMessage("""", ""*"");
        global.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }

    function installPostMessageImplementation() {
      // Installs an event handler on `global` for the `message` event: see
      // * https://developer.mozilla.org/en/DOM/window.postMessage
      // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
      var messagePrefix = ""setImmediate$"" + Math.random() + ""$"";

      var onGlobalMessage = function (event) {
        if (event.source === global && typeof event.data === ""string"" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };

      if (global.addEventListener) {
        global.addEventListener(""message"", onGlobalMessage, false);
      } else {
        global.attachEvent(""onmessage"", onGlobalMessage);
      }

      registerImmediate = function (handle) {
        global.postMessage(messagePrefix + handle, ""*"");
      };
    }

    function installMessageChannelImplementation() {
      var channel = new MessageChannel();

      channel.port1.onmessage = function (event) {
        var handle = event.data;
        runIfPresent(handle);
      };

      registerImmediate = function (handle) {
        channel.port2.postMessage(handle);
      };
    }

    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;

      registerImmediate = function (handle) {
        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
        var script = doc.createElement(""script"");

        script.onreadystatechange = function () {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };

        html.appendChild(script);
      };
    }

    function installSetTimeoutImplementation() {
      registerImmediate = function (handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

    if ({}.toString.call(global.process) === ""[object process]"") {
      // For Node.js before 0.9
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      // For non-IE10 modern browsers
      installPostMessageImplementation();
    } else if (global.MessageChannel) {
      // For web workers, where supported
      installMessageChannelImplementation();
    } else if (doc && ""onreadystatechange"" in doc.createElement(""script"")) {
      // For IE 68
      installReadyStateChangeImplementation();
    } else {
      // For older browsers
      installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === ""undefined"" ? typeof _global$1 === ""undefined"" ? exports$2 : _global$1 : self);

  return exports$2;
}

var exports$1 = {},
    _dewExec = false;

var _global = typeof globalThis !== ""undefined"" ? globalThis : typeof self !== ""undefined"" ? self : global;

function dew() {
  if (_dewExec) { return exports$1; }
  _dewExec = true;
  var scope = typeof _global !== ""undefined"" && _global || typeof self !== ""undefined"" && self || window;
  var apply = Function.prototype.apply; // DOM APIs, for completeness

  exports$1.setTimeout = function () {
    return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
  };

  exports$1.setInterval = function () {
    return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
  };

  exports$1.clearTimeout = exports$1.clearInterval = function (timeout) {
    if (timeout) {
      timeout.close();
    }
  };

  function Timeout(id, clearFn) {
    (this || _global)._id = id;
    (this || _global)._clearFn = clearFn;
  }

  Timeout.prototype.unref = Timeout.prototype.ref = function () {};

  Timeout.prototype.close = function () {
    (this || _global)._clearFn.call(scope, (this || _global)._id);
  }; // Does not start the time, just sets up the members needed.


  exports$1.enroll = function (item, msecs) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = msecs;
  };

  exports$1.unenroll = function (item) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = -1;
  };

  exports$1._unrefActive = exports$1.active = function (item) {
    clearTimeout(item._idleTimeoutId);
    var msecs = item._idleTimeout;

    if (msecs >= 0) {
      item._idleTimeoutId = setTimeout(function onTimeout() {
        if (item._onTimeout) { item._onTimeout(); }
      }, msecs);
    }
  }; // setimmediate attaches itself to the global object


  dew$1(); // On some exotic environments, it's not clear which object `setimmediate` was
  // able to install onto.  Search each possibility in the same order as the
  // `setimmediate` library.


  exports$1.setImmediate = typeof self !== ""undefined"" && self.setImmediate || typeof _global !== ""undefined"" && _global.setImmediate || exports$1 && exports$1.setImmediate;
  exports$1.clearImmediate = typeof self !== ""undefined"" && self.clearImmediate || typeof _global !== ""undefined"" && _global.clearImmediate || exports$1 && exports$1.clearImmediate;
  return exports$1;
}

var exports = dew();
exports['setTimeout']; exports['setInterval']; exports['clearTimeout']; exports['clearInterval']; exports['enroll']; exports['unenroll']; exports['_unrefActive']; exports['active']; exports['setImmediate']; exports['clearImmediate'];

var _unrefActive = exports._unrefActive;
var active = exports.active;
var clearImmediate = exports.clearImmediate;
var clearInterval$1 = exports.clearInterval;
var clearTimeout$1 = exports.clearTimeout;
var enroll = exports.enroll;
var setImmediate = exports.setImmediate;
var setInterval$1 = exports.setInterval;
var setTimeout$1 = exports.setTimeout;
var unenroll = exports.unenroll;

export { _unrefActive, active, clearImmediate, clearInterval$1 as clearInterval, clearTimeout$1 as clearTimeout, exports as default, enroll, setImmediate, setInterval$1 as setInterval, setTimeout$1 as setTimeout, unenroll };
"
modules/internal/crypto/keygen.js,"use strict';

const {
  FunctionPrototypeCall,
  ObjectDefineProperty,
  SafeArrayIterator,
} = primordials;

const {
  DhKeyPairGenJob,
  DsaKeyPairGenJob,
  EcKeyPairGenJob,
  NidKeyPairGenJob,
  RsaKeyPairGenJob,
  SecretKeyGenJob,
  kCryptoJobAsync,
  kCryptoJobSync,
  kKeyVariantRSA_PSS,
  kKeyVariantRSA_SSA_PKCS1_v1_5,
  EVP_PKEY_ED25519,
  EVP_PKEY_ED448,
  EVP_PKEY_X25519,
  EVP_PKEY_X448,
  OPENSSL_EC_NAMED_CURVE,
  OPENSSL_EC_EXPLICIT_CURVE,
} = internalBinding('crypto');

const {
  PublicKeyObject,
  PrivateKeyObject,
  SecretKeyObject,
  parsePublicKeyEncoding,
  parsePrivateKeyEncoding,
} = require('internal/crypto/keys');

const {
  kAesKeyLengths,
} = require('internal/crypto/util');

const {
  customPromisifyArgs,
  kEmptyObject,
} = require('internal/util');

const {
  validateFunction,
  validateBuffer,
  validateString,
  validateInteger,
  validateObject,
  validateOneOf,
  validateInt32,
  validateUint32,
} = require('internal/validators');

const {
  codes: {
    ERR_INCOMPATIBLE_OPTION_PAIR,
    ERR_INVALID_ARG_VALUE,
    ERR_MISSING_OPTION,
  }
} = require('internal/errors');

const { isArrayBufferView } = require('internal/util/types');

const { getOptionValue } = require('internal/options');

function isJwk(obj) {
  return obj != null && obj.kty !== undefined;
}

function wrapKey(key, ctor) {
  if (typeof key === 'string' ||
      isArrayBufferView(key) ||
      isJwk(key))
    return key;
  return new ctor(key);
}

function generateKeyPair(type, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }
  validateFunction(callback, 'callback');

  const job = createJob(kCryptoJobAsync, type, options);

  job.ondone = (error, result) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    // If no encoding was chosen, return key objects instead.
    let { 0: pubkey, 1: privkey } = result;
    pubkey = wrapKey(pubkey, PublicKeyObject);
    privkey = wrapKey(privkey, PrivateKeyObject);
    FunctionPrototypeCall(callback, job, null, pubkey, privkey);
  };

  job.run();
}

ObjectDefineProperty(generateKeyPair, customPromisifyArgs, {
  __proto__: null,
  value: ['publicKey', 'privateKey'],
  enumerable: false
});

function generateKeyPairSync(type, options) {
  return handleError(createJob(kCryptoJobSync, type, options).run());
}

function handleError(ret) {
  if (ret == null)
    return; // async

  const { 0: err, 1: keys } = ret;
  if (err !== undefined)
    throw err;

  const { 0: publicKey, 1: privateKey } = keys;

  // If no encoding was chosen, return key objects instead.
  return {
    publicKey: wrapKey(publicKey, PublicKeyObject),
    privateKey: wrapKey(privateKey, PrivateKeyObject)
  };
}

function parseKeyEncoding(keyType, options = kEmptyObject) {
  const { publicKeyEncoding, privateKeyEncoding } = options;

  let publicFormat, publicType;
  if (publicKeyEncoding == null) {
    publicFormat = publicType = undefined;
  } else if (typeof publicKeyEncoding === 'object') {
    ({
      format: publicFormat,
      type: publicType
    } = parsePublicKeyEncoding(publicKeyEncoding, keyType,
                               'publicKeyEncoding'));
  } else {
    throw new ERR_INVALID_ARG_VALUE('options.publicKeyEncoding',
                                    publicKeyEncoding);
  }

  let privateFormat, privateType, cipher, passphrase;
  if (privateKeyEncoding == null) {
    privateFormat = privateType = undefined;
  } else if (typeof privateKeyEncoding === 'object') {
    ({
      format: privateFormat,
      type: privateType,
      cipher,
      passphrase
    } = parsePrivateKeyEncoding(privateKeyEncoding, keyType,
                                'privateKeyEncoding'));
  } else {
    throw new ERR_INVALID_ARG_VALUE('options.privateKeyEncoding',
                                    privateKeyEncoding);
  }

  return [
    publicFormat,
    publicType,
    privateFormat,
    privateType,
    cipher,
    passphrase,
  ];
}

function createJob(mode, type, options) {
  validateString(type, 'type');

  const encoding = new SafeArrayIterator(parseKeyEncoding(type, options));

  if (options !== undefined)
    validateObject(options, 'options');

  switch (type) {
    case 'rsa':
    case 'rsa-pss':
    {
      validateObject(options, 'options');
      const { modulusLength } = options;
      validateUint32(modulusLength, 'options.modulusLength');

      let { publicExponent } = options;
      if (publicExponent == null) {
        publicExponent = 0x10001;
      } else {
        validateUint32(publicExponent, 'options.publicExponent');
      }

      if (type === 'rsa') {
        return new RsaKeyPairGenJob(
          mode,
          kKeyVariantRSA_SSA_PKCS1_v1_5,  // Used also for RSA-OAEP
          modulusLength,
          publicExponent,
          ...encoding);
      }

      const {
        hash, mgf1Hash, hashAlgorithm, mgf1HashAlgorithm, saltLength
      } = options;

      const pendingDeprecation = getOptionValue('--pending-deprecation');

      if (saltLength !== undefined)
        validateInt32(saltLength, 'options.saltLength', 0);
      if (hashAlgorithm !== undefined)
        validateString(hashAlgorithm, 'options.hashAlgorithm');
      if (mgf1HashAlgorithm !== undefined)
        validateString(mgf1HashAlgorithm, 'options.mgf1HashAlgorithm');
      if (hash !== undefined) {
        pendingDeprecation && process.emitWarning(
          '""options.hash"" is deprecated, ' +
          'use ""options.hashAlgorithm"" instead.',
          'DeprecationWarning',
          'DEP0154');
        validateString(hash, 'options.hash');
        if (hashAlgorithm && hash !== hashAlgorithm) {
          throw new ERR_INVALID_ARG_VALUE('options.hash', hash);
        }
      }
      if (mgf1Hash !== undefined) {
        pendingDeprecation && process.emitWarning(
          '""options.mgf1Hash"" is deprecated, ' +
          'use ""options.mgf1HashAlgorithm"" instead.',
          'DeprecationWarning',
          'DEP0154');
        validateString(mgf1Hash, 'options.mgf1Hash');
        if (mgf1HashAlgorithm && mgf1Hash !== mgf1HashAlgorithm) {
          throw new ERR_INVALID_ARG_VALUE('options.mgf1Hash', mgf1Hash);
        }
      }

      return new RsaKeyPairGenJob(
        mode,
        kKeyVariantRSA_PSS,
        modulusLength,
        publicExponent,
        hashAlgorithm || hash,
        mgf1HashAlgorithm || mgf1Hash,
        saltLength,
        ...encoding);
    }
    case 'dsa':
    {
      validateObject(options, 'options');
      const { modulusLength } = options;
      validateUint32(modulusLength, 'options.modulusLength');

      let { divisorLength } = options;
      if (divisorLength == null) {
        divisorLength = -1;
      } else
        validateInt32(divisorLength, 'options.divisorLength', 0);

      return new DsaKeyPairGenJob(
        mode,
        modulusLength,
        divisorLength,
        ...encoding);
    }
    case 'ec':
    {
      validateObject(options, 'options');
      const { namedCurve } = options;
      validateString(namedCurve, 'options.namedCurve');
      let { paramEncoding } = options;
      if (paramEncoding == null || paramEncoding === 'named')
        paramEncoding = OPENSSL_EC_NAMED_CURVE;
      else if (paramEncoding === 'explicit')
        paramEncoding = OPENSSL_EC_EXPLICIT_CURVE;
      else
        throw new ERR_INVALID_ARG_VALUE('options.paramEncoding', paramEncoding);

      return new EcKeyPairGenJob(
        mode,
        namedCurve,
        paramEncoding,
        ...encoding);
    }
    case 'ed25519':
    case 'ed448':
    case 'x25519':
    case 'x448':
    {
      let id;
      switch (type) {
        case 'ed25519':
          id = EVP_PKEY_ED25519;
          break;
        case 'ed448':
          id = EVP_PKEY_ED448;
          break;
        case 'x25519':
          id = EVP_PKEY_X25519;
          break;
        case 'x448':
          id = EVP_PKEY_X448;
          break;
      }
      return new NidKeyPairGenJob(mode, id, ...encoding);
    }
    case 'dh':
    {
      validateObject(options, 'options');
      const { group, primeLength, prime, generator } = options;
      if (group != null) {
        if (prime != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'prime');
        if (primeLength != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'primeLength');
        if (generator != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group', 'generator');

        validateString(group, 'options.group');

        return new DhKeyPairGenJob(mode, group, ...encoding);
      }

      if (prime != null) {
        if (primeLength != null)
          throw new ERR_INCOMPATIBLE_OPTION_PAIR('prime', 'primeLength');

        validateBuffer(prime, 'options.prime');
      } else if (primeLength != null) {
        validateInt32(primeLength, 'options.primeLength', 0);
      } else {
        throw new ERR_MISSING_OPTION(
          'At least one of the group, prime, or primeLength options');
      }

      if (generator != null) {
        validateInt32(generator, 'options.generator', 0);
      }
      return new DhKeyPairGenJob(
        mode,
        prime != null ? prime : primeLength,
        generator == null ? 2 : generator,
        ...encoding);
    }
    default:
      // Fall through
  }
  throw new ERR_INVALID_ARG_VALUE('type', type, 'must be a supported key type');
}

// Symmetric Key Generation

function generateKeyJob(mode, keyType, options) {
  validateString(keyType, 'type');
  validateObject(options, 'options');
  const { length } = options;
  switch (keyType) {
    case 'hmac':
      validateInteger(length, 'options.length', 8, 2 ** 31 - 1);
      break;
    case 'aes':
      validateOneOf(length, 'options.length', kAesKeyLengths);
      break;
    default:
      throw new ERR_INVALID_ARG_VALUE(
        'type',
        keyType,
        'must be a supported key type');
  }

  return new SecretKeyGenJob(mode, length);
}

function handleGenerateKeyError(ret) {
  if (ret === undefined)
    return; // async

  const { 0: err, 1: key } = ret;
  if (err !== undefined)
    throw err;

  return wrapKey(key, SecretKeyObject);
}

function generateKey(type, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }

  validateFunction(callback, 'callback');

  const job = generateKeyJob(kCryptoJobAsync, type, options);

  job.ondone = (error, key) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, wrapKey(key, SecretKeyObject));
  };

  handleGenerateKeyError(job.run());
}

function generateKeySync(type, options) {
  return handleGenerateKeyError(
    generateKeyJob(kCryptoJobSync, type, options).run());
}

module.exports = {
  generateKeyPair,
  generateKeyPairSync,
  generateKey,
  generateKeySync,
};
"
src/internal_module/encoding.rs,"use std::borrow::Cow;

use crate::quickjs_sys::*;
use encoding::{
    all::{
        whatwg::{ISO_8859_8_I, X_USER_DEFINED},
        *,
    },
    DecoderTrap, EncoderTrap, Encoding,
};

fn text_encode(ctx: &mut Context, _: JsValue, params: &[JsValue]) -> JsValue {
    let s = params.get(0);
    let utf_label = match params.get(1).clone() {
        Some(JsValue::String(s)) => s.as_str(),
        _ => """",
    };
    if s.is_none() {
        return JsValue::UnDefined;
    }
    if let JsValue::String(s) = ctx.value_to_string(s.unwrap()) {
        match utf_label {
            """" | ""utf8"" | ""utf-8"" => {
                let b = UTF_8.encode(s.as_str(), EncoderTrap::Replace);
                match b {
                    Ok(ret) => ctx.new_array_buffer(&ret).into(),
                    Err(e) => {
                        ctx.throw_type_error(&e);
                        JsValue::UnDefined
                    }
                }
            }
            _ => JsValue::UnDefined,
        }
    } else {
        JsValue::UnDefined
    }
}

const TAG_CONT: u8 = 0b1000_0000;
const TAG_TWO_B: u8 = 0b1100_0000;
const TAG_THREE_B: u8 = 0b1110_0000;
const TAG_FOUR_B: u8 = 0b1111_0000;
const MAX_ONE_B: u32 = 0x80;
const MAX_TWO_B: u32 = 0x800;
const MAX_THREE_B: u32 = 0x10000;

fn encode_utf8_raw(code: char, dst: &mut [u8]) -> Option<usize> {
    let len = char::len_utf8(code);
    let dst_len = dst.len();
    let code = code as u32;
    match (len, &mut dst[..]) {
        (1, [a, ..]) if dst_len >= 1 => {
            *a = code as u8;
        }
        (2, [a, b, ..]) if dst_len >= 2 => {
            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
            *b = (code & 0x3F) as u8 | TAG_CONT;
        }
        (3, [a, b, c, ..]) if dst_len >= 3 => {
            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;
            *c = (code & 0x3F) as u8 | TAG_CONT;
        }
        (4, [a, b, c, d, ..]) if dst_len >= 4 => {
            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;
            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;
            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;
            *d = (code & 0x3F) as u8 | TAG_CONT;
        }
        _ => return None,
    };
    Some(len)
}

fn text_encode_into(ctx: &mut Context, _: JsValue, params: &[JsValue]) -> JsValue {
    let src = params.get(0);
    let utf_label = match params.get(1).clone() {
        Some(JsValue::String(s)) => s.as_str(),
        _ => """",
    };
    let dest = params.get(2);
    let offset = params.get(3);

    if src.is_none() || dest.is_none() {
        return JsValue::UnDefined;
    }
    if let (
        JsValue::String(s),
        Some(JsValue::ArrayBuffer(ref mut dst_buff)),
        Some(JsValue::Int(offset)),
    ) = (ctx.value_to_string(src.unwrap()), dest.cloned(), offset)
    {
        let src = s.as_str();
        let dst = dst_buff.as_mut();
        let offset = dst.len().min(*offset as usize);

        match utf_label {
            """" | ""utf8"" | ""utf-8"" => {
                let mut read = 0;
                let mut written = 0;
                let mut ret = ctx.new_object();

                for c in src.chars() {
                    if let Some(n) = encode_utf8_raw(c, &mut dst[written + offset..]) {
                        written += n
                    } else {
                        break;
                    }
                    read += 1;
                }

                ret.set(""read"", JsValue::Int(read));
                ret.set(""written"", JsValue::Int(written as i32));
                ret.into()
            }
            _ => JsValue::UnDefined,
        }
    } else {
        JsValue::UnDefined
    }
}

fn text_decode(ctx: &mut Context, _: JsValue, params: &[JsValue]) -> JsValue {
    let s = params.get(0);
    let utf_label = match params.get(1).clone() {
        Some(JsValue::String(s)) => s.as_str(),
        _ => """",
    };
    let fatal = match params.get(2) {
        Some(JsValue::Bool(b)) => *b,
        _ => false,
    };

    if s.is_none() {
        return JsValue::UnDefined;
    }

    let trap = if fatal {
        DecoderTrap::Strict
    } else {
        DecoderTrap::Replace
    };

    fn ret_to_js(ctx: &mut Context, ret: Result<String, Cow<str>>) -> JsValue {
        match &ret {
            Ok(s) => ctx.new_string(s).into(),
            Err(e) => ctx.new_error(e).into(),
        }
    }

    if let JsValue::ArrayBuffer(s) = s.unwrap() {
        match utf_label {
            """" | ""utf8"" | ""utf-8"" => {
                let b = UTF_8.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""gbk"" => {
                let b = GBK.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""gb18030"" => {
                let b = GB18030.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""hz-gb-2312"" => {
                let b = HZ.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""big5"" => {
                let b = BIG5_2003.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""euc-jp"" => {
                let b = EUC_JP.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-2022-jp"" => {
                let b = ISO_2022_JP.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""utf-16be"" => {
                let b = UTF_16BE.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""utf-16le"" => {
                let b = UTF_16LE.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""x-user-defined"" => {
                let b = X_USER_DEFINED.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""ibm866"" => {
                let b = IBM866.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-2"" => {
                let b = ISO_8859_2.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-3"" => {
                let b = ISO_8859_3.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-4"" => {
                let b = ISO_8859_4.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-5"" => {
                let b = ISO_8859_5.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-6"" => {
                let b = ISO_8859_6.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-7"" => {
                let b = ISO_8859_7.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-8"" => {
                let b = ISO_8859_8.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-8i"" => {
                let b = ISO_8859_8_I.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-10"" => {
                let b = ISO_8859_10.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-13"" => {
                let b = ISO_8859_13.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-14"" => {
                let b = ISO_8859_14.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-15"" => {
                let b = ISO_8859_15.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""iso-8859-16"" => {
                let b = ISO_8859_16.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-874"" => {
                let b = WINDOWS_874.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1250"" => {
                let b = WINDOWS_1250.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1251"" => {
                let b = WINDOWS_1251.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1252"" => {
                let b = WINDOWS_1252.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1253"" => {
                let b = WINDOWS_1253.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1254"" => {
                let b = WINDOWS_1254.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1255"" => {
                let b = WINDOWS_1255.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1256"" => {
                let b = WINDOWS_1256.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1257"" => {
                let b = WINDOWS_1257.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            ""windows-1258"" => {
                let b = WINDOWS_1258.decode(s.as_ref(), trap);
                ret_to_js(ctx, b)
            }
            _ => JsValue::UnDefined,
        }
    } else {
        JsValue::UnDefined
    }
}

pub fn init_encoding_module(ctx: &mut Context) {
    ctx.register_fn_module(
        ""_encoding"",
        &[""text_encode"", ""text_decode"", ""text_encode_into""],
        |ctx: &mut Context, m: &mut JsModuleDef| {
            let text_encode = ctx.wrap_function(""text_encode"", text_encode);
            m.add_export(""text_encode"", text_encode.into());

            let text_encode_into = ctx.wrap_function(""text_encode_into"", text_encode_into);
            m.add_export(""text_encode_into"", text_encode_into.into());

            let text_decode = ctx.wrap_function(""text_decode"", text_decode);
            m.add_export(""text_decode"", text_decode.into());
        },
    );
}
"
src/internal_module/wasi_nn/generated.rs,"// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/witx-bindgen` command

use core::fmt;
use core::mem::MaybeUninit;
pub type BufferSize = u32;
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct NnErrno(u16);
pub const NN_ERRNO_SUCCESS: NnErrno = NnErrno(0);
pub const NN_ERRNO_INVALID_ARGUMENT: NnErrno = NnErrno(1);
pub const NN_ERRNO_INVALID_ENCODING: NnErrno = NnErrno(2);
pub const NN_ERRNO_MISSING_MEMORY: NnErrno = NnErrno(3);
pub const NN_ERRNO_BUSY: NnErrno = NnErrno(4);
pub const NN_ERRNO_RUNTIME_ERROR: NnErrno = NnErrno(5);
impl NnErrno {
    pub const fn raw(&self) -> u16 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => ""SUCCESS"",
            1 => ""INVALID_ARGUMENT"",
            2 => ""INVALID_ENCODING"",
            3 => ""MISSING_MEMORY"",
            4 => ""BUSY"",
            5 => ""RUNTIME_ERROR"",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => """",
            1 => """",
            2 => """",
            3 => """",
            4 => """",
            5 => """",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for NnErrno {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct(""NnErrno"")
            .field(""code"", &self.0)
            .field(""name"", &self.name())
            .field(""message"", &self.message())
            .finish()
    }
}
impl fmt::Display for NnErrno {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, ""{} (error {})"", self.name(), self.0)
    }
}

#[cfg(feature = ""std"")]
extern crate std;
#[cfg(feature = ""std"")]
impl std::error::Error for NnErrno {}

pub type TensorDimensions<'a> = &'a [u32];
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct TensorType(u8);
pub const TENSOR_TYPE_F16: TensorType = TensorType(0);
pub const TENSOR_TYPE_F32: TensorType = TensorType(1);
pub const TENSOR_TYPE_U8: TensorType = TensorType(2);
pub const TENSOR_TYPE_I32: TensorType = TensorType(3);
impl TensorType {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => ""F16"",
            1 => ""F32"",
            2 => ""U8"",
            3 => ""I32"",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => """",
            1 => """",
            2 => """",
            3 => """",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for TensorType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct(""TensorType"")
            .field(""code"", &self.0)
            .field(""name"", &self.name())
            .field(""message"", &self.message())
            .finish()
    }
}

pub type TensorData<'a> = &'a [u8];
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct Tensor<'a> {
    pub dimensions: TensorDimensions<'a>,
    pub type_: TensorType,
    pub data: TensorData<'a>,
}
pub type GraphBuilder<'a> = &'a [u8];
pub type GraphBuilderArray<'a> = &'a [GraphBuilder<'a>];
pub type Graph = u32;
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct GraphEncoding(u8);
pub const GRAPH_ENCODING_OPENVINO: GraphEncoding = GraphEncoding(0);
pub const GRAPH_ENCODING_ONNX: GraphEncoding = GraphEncoding(1);
pub const GRAPH_ENCODING_TENSORFLOW: GraphEncoding = GraphEncoding(2);
pub const GRAPH_ENCODING_PYTORCH: GraphEncoding = GraphEncoding(3);
pub const GRAPH_ENCODING_TENSORFLOWLITE: GraphEncoding = GraphEncoding(4);
impl GraphEncoding {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => ""OPENVINO"",
            1 => ""ONNX"",
            2 => ""TENSORFLOW"",
            3 => ""PYTORCH"",
            4 => ""TENSORFLOWLITE"",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => """",
            1 => """",
            2 => """",
            3 => """",
            4 => """",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for GraphEncoding {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct(""GraphEncoding"")
            .field(""code"", &self.0)
            .field(""name"", &self.name())
            .field(""message"", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct ExecutionTarget(u8);
pub const EXECUTION_TARGET_CPU: ExecutionTarget = ExecutionTarget(0);
pub const EXECUTION_TARGET_GPU: ExecutionTarget = ExecutionTarget(1);
pub const EXECUTION_TARGET_TPU: ExecutionTarget = ExecutionTarget(2);
impl ExecutionTarget {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => ""CPU"",
            1 => ""GPU"",
            2 => ""TPU"",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => """",
            1 => """",
            2 => """",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for ExecutionTarget {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct(""ExecutionTarget"")
            .field(""code"", &self.0)
            .field(""name"", &self.name())
            .field(""message"", &self.message())
            .finish()
    }
}

pub type GraphExecutionContext = u32;
pub unsafe fn load(
    builder: GraphBuilderArray<'_>,
    encoding: GraphEncoding,
    target: ExecutionTarget,
) -> Result<Graph, NnErrno> {
    let mut rp0 = MaybeUninit::<Graph>::uninit();
    let ret = wasi_ephemeral_nn::load(
        builder.as_ptr() as i32,
        builder.len() as i32,
        encoding.0 as i32,
        target.0 as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Graph)),
        _ => Err(NnErrno(ret as u16)),
    }
}

pub unsafe fn init_execution_context(graph: Graph) -> Result<GraphExecutionContext, NnErrno> {
    let mut rp0 = MaybeUninit::<GraphExecutionContext>::uninit();
    let ret = wasi_ephemeral_nn::init_execution_context(graph as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(
            rp0.as_mut_ptr() as i32 as *const GraphExecutionContext
        )),
        _ => Err(NnErrno(ret as u16)),
    }
}

pub unsafe fn set_input(
    context: GraphExecutionContext,
    index: u32,
    tensor: Tensor,
) -> Result<(), NnErrno> {
    let ret =
        wasi_ephemeral_nn::set_input(context as i32, index as i32, &tensor as *const _ as i32);
    match ret {
        0 => Ok(()),
        _ => Err(NnErrno(ret as u16)),
    }
}

pub unsafe fn get_output(
    context: GraphExecutionContext,
    index: u32,
    out_buffer: *mut u8,
    out_buffer_max_size: BufferSize,
) -> Result<BufferSize, NnErrno> {
    let mut rp0 = MaybeUninit::<BufferSize>::uninit();
    let ret = wasi_ephemeral_nn::get_output(
        context as i32,
        index as i32,
        out_buffer as i32,
        out_buffer_max_size as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const BufferSize)),
        _ => Err(NnErrno(ret as u16)),
    }
}

pub unsafe fn compute(context: GraphExecutionContext) -> Result<(), NnErrno> {
    let ret = wasi_ephemeral_nn::compute(context as i32);
    match ret {
        0 => Ok(()),
        _ => Err(NnErrno(ret as u16)),
    }
}

pub mod wasi_ephemeral_nn {
    #[link(wasm_import_module = ""wasi_ephemeral_nn"")]
    extern ""C"" {
        pub fn load(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        pub fn init_execution_context(arg0: i32, arg1: i32) -> i32;
        pub fn set_input(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn get_output(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        pub fn compute(arg0: i32) -> i32;
    }
}
"
test/crypto/test-crypto-fips.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const spawnSync = require('child_process').spawnSync;
const path = require('path');
const fixtures = require('../common/fixtures');
const { internalBinding } = require('internal/test/binding');
const { testFipsCrypto } = internalBinding('crypto');

const FIPS_ENABLED = 1;
const FIPS_DISABLED = 0;
const FIPS_ERROR_STRING2 =
  'Error [ERR_CRYPTO_FIPS_FORCED]: Cannot set FIPS mode, it was forced with ' +
  '--force-fips at startup.';
const FIPS_UNSUPPORTED_ERROR_STRING = 'fips mode not supported';
const FIPS_ENABLE_ERROR_STRING = 'OpenSSL error when trying to enable FIPS:';

const CNF_FIPS_ON = fixtures.path('openssl_fips_enabled.cnf');
const CNF_FIPS_OFF = fixtures.path('openssl_fips_disabled.cnf');

let num_children_ok = 0;

function sharedOpenSSL() {
  return process.config.variables.node_shared_openssl;
}

function testHelper(stream, args, expectedOutput, cmd, env) {
  const fullArgs = args.concat(['-e', `console.log(${cmd})`]);
  const child = spawnSync(process.execPath, fullArgs, {
    cwd: path.dirname(process.execPath),
    env: env
  });

  console.error(
    `Spawned child [pid:${child.pid}] with cmd '${cmd}' expect %j with args '${
      args}' OPENSSL_CONF=%j`, expectedOutput, env.OPENSSL_CONF);

  function childOk(child) {
    console.error(`Child #${++num_children_ok} [pid:${child.pid}] OK.`);
  }

  function responseHandler(buffer, expectedOutput) {
    const response = buffer.toString();
    assert.notStrictEqual(response.length, 0);
    if (FIPS_ENABLED !== expectedOutput && FIPS_DISABLED !== expectedOutput) {
      // In the case of expected errors just look for a substring.
      assert.ok(response.includes(expectedOutput));
    } else {
      const getFipsValue = Number(response);
      if (!Number.isNaN(getFipsValue))
        // Normal path where we expect either FIPS enabled or disabled.
        assert.strictEqual(getFipsValue, expectedOutput);
    }
    childOk(child);
  }

  responseHandler(child[stream], expectedOutput);
}

// --enable-fips should raise an error if OpenSSL is not FIPS enabled.
testHelper(
  testFipsCrypto() ? 'stdout' : 'stderr',
  ['--enable-fips'],
  testFipsCrypto() ? FIPS_ENABLED : FIPS_ENABLE_ERROR_STRING,
  'process.versions',
  process.env);

// --force-fips should raise an error if OpenSSL is not FIPS enabled.
testHelper(
  testFipsCrypto() ? 'stdout' : 'stderr',
  ['--force-fips'],
  testFipsCrypto() ? FIPS_ENABLED : FIPS_ENABLE_ERROR_STRING,
  'process.versions',
  process.env);

// By default FIPS should be off in both FIPS and non-FIPS builds.
testHelper(
  'stdout',
  [],
  FIPS_DISABLED,
  'require(""crypto"").getFips()',
  { ...process.env, 'OPENSSL_CONF': ' ' });

// Toggling fips with setFips should not be allowed from a worker thread
testHelper(
  'stderr',
  [],
  'Calling crypto.setFips() is not supported in workers',
  'new worker_threads.Worker(\'require(""crypto"").setFips(true);\', { eval: true })',
  process.env);

// This should succeed for both FIPS and non-FIPS builds in combination with
// OpenSSL 1.1.1 or OpenSSL 3.0
const test_result = testFipsCrypto();
assert.ok(test_result === 1 || test_result === 0);

// If Node was configured using --shared-openssl fips support might be
// available depending on how OpenSSL was built. If fips support is
// available the tests that toggle the fips_mode on/off using the config
// file option will succeed and return 1 instead of 0.
//
// Note that this case is different from when calling the fips setter as the
// configuration file is handled by OpenSSL, so it is not possible for us
// to try to call the fips setter, to try to detect this situation, as
// that would throw an error:
// (""Error: Cannot set FIPS mode in a non-FIPS build."").
// Due to this uncertainty the following tests are skipped when configured
// with --shared-openssl.
if (!sharedOpenSSL() && !common.hasOpenSSL3) {
  // OpenSSL config file should be able to turn on FIPS mode
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_ON}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_DISABLED,
    'require(""crypto"").getFips()',
    process.env);

  // OPENSSL_CONF should be able to turn on FIPS mode
  testHelper(
    'stdout',
    [],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_DISABLED,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_ON }));

  // --openssl-config option should override OPENSSL_CONF
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_ON}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_DISABLED,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_OFF }));
}

// OpenSSL 3.x has changed the configuration files so the following tests
// will not work as expected with that version.
// TODO(danbev) Revisit these test once FIPS support is available in
// OpenSSL 3.x.
if (!common.hasOpenSSL3) {
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_OFF}`],
    FIPS_DISABLED,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_ON }));

  // --enable-fips should take precedence over OpenSSL config file
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips', `--openssl-config=${CNF_FIPS_OFF}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);
  // --force-fips should take precedence over OpenSSL config file
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips', `--openssl-config=${CNF_FIPS_OFF}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);
  // --enable-fips should turn FIPS mode on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);

  // --force-fips should turn FIPS mode on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    process.env);

  // OPENSSL_CONF should _not_ make a difference to --enable-fips
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_OFF }));

  // Using OPENSSL_CONF should not make a difference to --force-fips
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").getFips()',
    Object.assign({}, process.env, { 'OPENSSL_CONF': CNF_FIPS_OFF }));

  // setFipsCrypto should be able to turn FIPS mode on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    [],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").getFips())',
    process.env);

  // setFipsCrypto should be able to turn FIPS mode on and off
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    [],
    testFipsCrypto() ? FIPS_DISABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").setFips(false),' +
    'require(""crypto"").getFips())',
    process.env);

  // setFipsCrypto takes precedence over OpenSSL config file, FIPS on
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    [`--openssl-config=${CNF_FIPS_OFF}`],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").getFips())',
    process.env);

  // setFipsCrypto takes precedence over OpenSSL config file, FIPS off
  testHelper(
    'stdout',
    [`--openssl-config=${CNF_FIPS_ON}`],
    FIPS_DISABLED,
    '(require(""crypto"").setFips(false),' +
    'require(""crypto"").getFips())',
    process.env);

  // --enable-fips does not prevent use of setFipsCrypto API
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--enable-fips'],
    testFipsCrypto() ? FIPS_DISABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(false),' +
    'require(""crypto"").getFips())',
    process.env);

  // --force-fips prevents use of setFipsCrypto API
  testHelper(
    'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ERROR_STRING2 : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").setFips(false)',
    process.env);

  // --force-fips makes setFipsCrypto enable a no-op (FIPS stays on)
  testHelper(
    testFipsCrypto() ? 'stdout' : 'stderr',
    ['--force-fips'],
    testFipsCrypto() ? FIPS_ENABLED : FIPS_UNSUPPORTED_ERROR_STRING,
    '(require(""crypto"").setFips(true),' +
    'require(""crypto"").getFips())',
    process.env);

  // --force-fips and --enable-fips order does not matter
  testHelper(
    'stderr',
    ['--force-fips', '--enable-fips'],
    testFipsCrypto() ? FIPS_ERROR_STRING2 : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").setFips(false)',
    process.env);

  // --enable-fips and --force-fips order does not matter
  testHelper(
    'stderr',
    ['--enable-fips', '--force-fips'],
    testFipsCrypto() ? FIPS_ERROR_STRING2 : FIPS_UNSUPPORTED_ERROR_STRING,
    'require(""crypto"").setFips(false)',
    process.env);
}
"
src/internal_module/img_module.rs,"use crate::*;
use image::imageops::FilterType;
use image::{Bgr, DynamicImage, ImageFormat, Rgba};
use imageproc::drawing::{draw_filled_rect_mut, draw_hollow_rect_mut, draw_text_mut, Canvas};
use imageproc::rect::Rect;
use std::path::Path;

struct JsImage(pub DynamicImage);

impl JsImage {
    pub fn resize(&self, w: u32, h: u32) -> JsImage {
        JsImage(self.0.resize_exact(w, h, FilterType::Nearest))
    }

    pub fn draw_filled_rect(&mut self, (x, y): (i32, i32), (w, h): (u32, u32), color: [u8; 4]) {
        let rect = Rect::at(x, y).of_size(w, h);
        draw_filled_rect_mut(&mut self.0, rect, Rgba::from(color))
    }

    pub fn draw_hollow_rect(&mut self, (x, y): (i32, i32), (w, h): (u32, u32), color: [u8; 4]) {
        let rect = Rect::at(x, y).of_size(w, h);
        draw_hollow_rect_mut(&mut self.0, rect, Rgba::from(color))
    }

    pub fn save_to_file<T: AsRef<Path>>(&self, path: T) -> Result<(), String> {
        self.0.save(path).map_err(|e| e.to_string())
    }

    pub fn save_to_buf(&self, form_str: &str) -> Result<Vec<u8>, String> {
        let mut buf = vec![];
        let form = match form_str {
            ""jpg"" | ""jpeg"" => ImageFormat::Jpeg,
            ""png"" => ImageFormat::Png,
            _ => return Err(format!(""no supper image format:{}"", form_str)),
        };
        self.0.write_to(&mut buf, form).map_err(|e| e.to_string())?;
        Ok(buf)
    }

    pub fn to_rgb(&self) -> Self {
        JsImage(DynamicImage::ImageRgb8(self.0.to_rgb8()))
    }

    pub fn to_bgr(&self) -> Self {
        JsImage(DynamicImage::ImageBgr8(self.0.to_bgr8()))
    }

    pub fn to_luma(&self) -> Self {
        JsImage(DynamicImage::ImageLuma8(self.0.to_luma8()))
    }

    pub fn pixels(&self) -> &[u8] {
        self.0.as_bytes()
    }
}

impl JsImage {
    fn js_save_to_file(
        &mut self,
        _: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let path = if let Some(JsValue::String(p)) = argv.get(0) {
            p.to_string()
        } else {
            return ctx.throw_type_error(""'path' must be of type string"").into();
        };

        let r = self.save_to_file(path);
        if let Err(e) = r {
            ctx.throw_internal_type_error(e.as_str()).into()
        } else {
            JsValue::UnDefined
        }
    }

    fn js_save_to_buf(&mut self, _: &mut JsObject, ctx: &mut Context, argv: &[JsValue]) -> JsValue {
        let fmt = if let Some(JsValue::String(p)) = argv.get(0) {
            p.to_string()
        } else {
            return ctx.throw_type_error(""'fmt' must be of type string"").into();
        };

        let r = self.save_to_buf(fmt.as_str());
        match r {
            Ok(d) => ctx.new_array_buffer(d.as_slice()).into(),
            Err(e) => ctx.throw_internal_type_error(e.as_str()).into(),
        }
    }

    fn js_resize(&mut self, _: &mut JsObject, ctx: &mut Context, argv: &[JsValue]) -> JsValue {
        let w = if let Some(JsValue::Int(w)) = argv.get(0) {
            *w
        } else {
            return ctx.throw_type_error(""'w' must be of type int"").into();
        };

        let h = if let Some(JsValue::Int(h)) = argv.get(1) {
            *h
        } else {
            return ctx.throw_type_error(""'h' must be of type int"").into();
        };

        let new_img = self.resize(w as u32, h as u32);
        Self::wrap_obj(ctx, new_img)
    }

    fn js_pixels(&mut self, _: &mut JsObject, ctx: &mut Context, _argv: &[JsValue]) -> JsValue {
        ctx.new_array_buffer(self.pixels()).into()
    }

    fn js_pixels_32f(&mut self, _: &mut JsObject, ctx: &mut Context, _argv: &[JsValue]) -> JsValue {
        let pixels = self.pixels();
        let mut pixels_32f = vec![0f32; pixels.len()];
        for (i, p) in pixels.iter().enumerate() {
            pixels_32f[i] = (*p as f32) / 255.;
        }

        ctx.new_array_buffer_t(pixels_32f.as_slice()).into()
    }

    fn js_to_rgb(&mut self, _: &mut JsObject, ctx: &mut Context, _argv: &[JsValue]) -> JsValue {
        let new_img = self.to_rgb();
        Self::wrap_obj(ctx, new_img)
    }

    fn js_to_bgr(&mut self, _: &mut JsObject, ctx: &mut Context, _argv: &[JsValue]) -> JsValue {
        let new_img = self.to_bgr();
        Self::wrap_obj(ctx, new_img)
    }

    fn js_to_luma(&mut self, _: &mut JsObject, ctx: &mut Context, _argv: &[JsValue]) -> JsValue {
        let new_img = self.to_luma();
        Self::wrap_obj(ctx, new_img)
    }

    fn js_draw_hollow_rect(
        &mut self,
        _: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let top_x = if let Some(JsValue::Int(v)) = argv.get(0) {
            *v
        } else {
            return ctx.throw_type_error(""'top_x' must be of type int"").into();
        };

        let top_y = if let Some(JsValue::Int(v)) = argv.get(1) {
            *v
        } else {
            return ctx.throw_type_error(""'top_y' must be of type int"").into();
        };

        let w = if let Some(JsValue::Int(v)) = argv.get(2) {
            *v as u32
        } else {
            return ctx.throw_type_error(""'w' must be of type int"").into();
        };

        let h = if let Some(JsValue::Int(v)) = argv.get(3) {
            *v as u32
        } else {
            return ctx.throw_type_error(""'h' must be of type int"").into();
        };

        let color = if let Some(JsValue::Int(v)) = argv.get(4) {
            *v as u32
        } else {
            return ctx.throw_type_error(""'color' must be of type int"").into();
        };

        let color_arr = [(color >> 16) as u8, (color >> 8) as u8, color as u8, 255u8];

        self.draw_hollow_rect((top_x, top_y), (w, h), color_arr);

        JsValue::UnDefined
    }

    fn js_draw_filled_rect(
        &mut self,
        _: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let top_x = if let Some(JsValue::Int(v)) = argv.get(0) {
            *v
        } else {
            return ctx.throw_type_error(""'top_x' must be of type int"").into();
        };

        let top_y = if let Some(JsValue::Int(v)) = argv.get(1) {
            *v
        } else {
            return ctx.throw_type_error(""'top_y' must be of type int"").into();
        };

        let w = if let Some(JsValue::Int(v)) = argv.get(2) {
            *v as u32
        } else {
            return ctx.throw_type_error(""'w' must be of type int"").into();
        };

        let h = if let Some(JsValue::Int(v)) = argv.get(3) {
            *v as u32
        } else {
            return ctx.throw_type_error(""'h' must be of type int"").into();
        };

        let color = if let Some(JsValue::Int(v)) = argv.get(4) {
            *v as u32
        } else {
            return ctx.throw_type_error(""'color' must be of type int"").into();
        };

        let color_arr = [(color >> 16) as u8, (color >> 8) as u8, color as u8, 255u8];

        self.draw_filled_rect((top_x, top_y), (w, h), color_arr);

        JsValue::UnDefined
    }
}

impl JsClassDef for JsImage {
    type RefType = Self;
    const CLASS_NAME: &'static str = ""Image"";
    const CONSTRUCTOR_ARGC: u8 = 1;

    fn constructor_fn(ctx: &mut Context, argv: &[JsValue]) -> Result<JsImage, JsValue> {
        let param = argv.get(0).ok_or(JsValue::UnDefined)?;
        match param {
            JsValue::String(path) => {
                let path = path.to_string();
                let img = image::open(path)
                    .map_err(|e| ctx.throw_internal_type_error(format!(""{}"", e).as_str()))?;
                Ok(JsImage(img))
            }
            JsValue::ArrayBuffer(data) => {
                let img = image::load_from_memory(data.as_ref())
                    .map_err(|e| ctx.throw_internal_type_error(format!(""{}"", e).as_str()))?;
                Ok(JsImage(img))
            }
            _ => Err(JsValue::UnDefined),
        }
    }

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];
    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[
        (""save_to_file"", 1, Self::js_save_to_file),
        (""save_to_buf"", 1, Self::js_save_to_buf),
        (""resize"", 2, Self::js_resize),
        (""pixels"", 0, Self::js_pixels),
        (""pixels_32f"", 0, Self::js_pixels_32f),
        (""to_rgb"", 0, Self::js_to_rgb),
        (""to_bgr"", 0, Self::js_to_bgr),
        (""to_luma"", 0, Self::js_to_luma),
        (""draw_hollow_rect"", 5, Self::js_draw_hollow_rect),
        (""draw_filled_rect"", 5, Self::js_draw_filled_rect),
    ];
}

struct ImageModule;

impl ModuleInit for ImageModule {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
        let class_ctor = register_class::<JsImage>(ctx);
        m.add_export(""Image\0"", class_ctor);
    }
}

pub fn init_module(ctx: &mut Context) {
    ctx.register_module(""image\0"", ImageModule, &[""Image\0""]);
}
"
modules/internal/streams/pipeline.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { isIterable, isNodeStream, isReadableNodeStream } from ""./utils.js"";
import { once } from ""../util.js"";
import { validateAbortSignal, validateCallback } from ""../validators.js"";
import {
    AbortError,
    aggregateTwoErrors,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED,
} from ""../errors.js"";
import destroyImpl from ""./destroy.js"";
import Duplex from ""./duplex.js"";
import eos from ""./end-of-stream.js"";
import Readable from ""./readable.js"";
import PassThrough from ""./passthrough.js"";

function destroyer(stream, reading, writing, callback) {
    callback = once(callback);

    let finished = false;
    stream.on(""close"", () => {
        finished = true;
    });

    eos(stream, { readable: reading, writable: writing }, (err) => {
        finished = !err;

        const rState = stream._readableState;
        if (
            err &&
            err.code === ""ERR_STREAM_PREMATURE_CLOSE"" &&
            reading &&
            (rState && rState.ended && !rState.errored && !rState.errorEmitted)
        ) {
            // Some readable streams will emit 'close' before 'end'. However, since
            // this is on the readable side 'end' should still be emitted if the
            // stream has been ended and no error emitted. This should be allowed in
            // favor of backwards compatibility. Since the stream is piped to a
            // destination this should not result in any observable difference.
            // We don't need to check if this is a writable premature close since
            // eos will only fail with premature close on the reading side for
            // duplex streams.
            stream
                .once(""end"", callback)
                .once(""error"", callback);
        } else {
            callback(err);
        }
    });

    return (err) => {
        if (finished) return;
        finished = true;
        destroyImpl.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED(""pipe""));
    };
}

function popCallback(streams) {
    // Streams should never be an empty array. It should always contain at least
    // a single stream. Therefore optimize for the average case instead of
    // checking for length === 0 as well.
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}

function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        // Legacy streams are not Iterable.
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE(
        ""val"",
        [""Readable"", ""Iterable"", ""AsyncIterable""],
        val,
    );
}

async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}

async function pump(iterable, writable, finish) {
    let error;
    let onresolve = null;

    const resume = (err) => {
        if (err) {
            error = err;
        }

        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };

    const wait = () =>
        new Promise((resolve, reject) => {
            if (error) {
                reject(error);
            } else {
                onresolve = () => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                };
            }
        });

    writable.on(""drain"", resume);
    const cleanup = eos(writable, { readable: false }, resume);

    try {
        if (writable.writableNeedDrain) {
            await wait();
        }

        for await (const chunk of iterable) {
            if (!writable.write(chunk)) {
                await wait();
            }
        }

        writable.end();

        await wait();

        finish();
    } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally {
        cleanup();
        writable.off(""drain"", resume);
    }
}

function pipeline(...streams) {
    const callback = once(popCallback(streams));

    // stream.pipeline(streams, callback)
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }

    return pipelineImpl(streams, callback);
}

function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS(""streams"");
    }

    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;

    validateAbortSignal(outerSignal, ""options.signal"");

    function abort() {
        finishImpl(new AbortError());
    }

    outerSignal?.addEventListener(""abort"", abort);

    let error;
    let value;
    const destroys = [];

    let finishCount = 0;

    function finish(err) {
        finishImpl(err, --finishCount === 0);
    }

    function finishImpl(err, final) {
        if (err && (!error || error.code === ""ERR_STREAM_PREMATURE_CLOSE"")) {
            error = err;
        }

        if (!error && !final) {
            return;
        }

        while (destroys.length) {
            destroys.shift()(error);
        }

        outerSignal?.removeEventListener(""abort"", abort);
        ac.abort();

        if (final) {
            callback(error, value);
        }
    }

    let ret;
    for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;

        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer(stream, reading, writing, finish));
        }

        if (i === 0) {
            if (typeof stream === ""function"") {
                ret = stream({ signal });
                if (!isIterable(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE(
                        ""Iterable, AsyncIterable or Stream"",
                        ""source"",
                        ret,
                    );
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret = stream;
            } else {
                ret = Duplex.from(stream);
            }
        } else if (typeof stream === ""function"") {
            ret = makeAsyncIterable(ret);
            ret = stream(ret, { signal });

            if (reading) {
                if (!isIterable(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE(
                        ""AsyncIterable"",
                        `transform[${i - 1}]`,
                        ret,
                    );
                }
            } else {
                // If the last argument to pipeline is not a stream
                // we must create a proxy stream so that pipeline(...)
                // always returns a stream which can be further
                // composed through `.pipe(stream)`.

                const pt = new PassThrough({
                    objectMode: true,
                });

                // Handle Promises/A+ spec, `then` could be a getter that throws on
                // second use.
                const then = ret?.then;
                if (typeof then === ""function"") {
                    then.call(ret, (val) => {
                        value = val;
                        pt.end(val);
                    }, (err) => {
                        pt.destroy(err);
                    });
                } else if (isIterable(ret, true)) {
                    finishCount++;
                    pump(ret, pt, finish);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE(
                        ""AsyncIterable or Promise"",
                        ""destination"",
                        ret,
                    );
                }

                ret = pt;

                finishCount++;
                destroys.push(destroyer(ret, false, true, finish));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
                ret.pipe(stream);

                // Compat. Before node v10.12.0 stdio used to throw an error so
                // pipe() did/does not end() stdio destinations.
                // Now they allow it but ""secretly"" don't close the underlying fd.
                // if (stream === stdio.stdout || stream === stdio.stderr) {
                //     ret.on(""end"", () => stream.end());
                // }
            } else {
                ret = makeAsyncIterable(ret);

                finishCount++;
                pump(ret, stream, finish);
            }
            ret = stream;
        } else {
            ret = Duplex.from(stream);
        }
    }

    if (signal?.aborted || outerSignal?.aborted) {
        nextTick(abort);
    }

    return ret;
}

export default { pipeline, pipelineImpl };
export { pipeline, pipelineImpl };"
test/fs/test-fs-truncate.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const tmp = tmpdir.path;
const filename = path.resolve(tmp, 'truncate-file.txt');
const data = Buffer.alloc(1024 * 16, 'x');

let onExit = [];
globalThis.commonExitCheck = () => {
  for (const fn of onExit) {
    fn();
  }
}

tmpdir.refresh();

let stat;

const msg = 'Using fs.truncate with a file descriptor is deprecated.' +
            ' Please use fs.ftruncate with a file descriptor instead.';

// Check truncateSync
fs.writeFileSync(filename, data);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024 * 16);

fs.truncateSync(filename, 1024);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024);

fs.truncateSync(filename);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 0);

// Check ftruncateSync
fs.writeFileSync(filename, data);
const fd = fs.openSync(filename, 'r+');

stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024 * 16);

fs.ftruncateSync(fd, 1024);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 1024);

fs.ftruncateSync(fd);
stat = fs.statSync(filename);
assert.strictEqual(stat.size, 0);

// truncateSync
common.expectWarning('DeprecationWarning', msg, 'DEP0081');
fs.truncateSync(fd);

fs.closeSync(fd);

// Async tests
testTruncate(common.mustSucceed(() => {
  testFtruncate(common.mustSucceed());
}));

function testTruncate(cb) {
  fs.writeFile(filename, data, function(er) {
    if (er) return cb(er);
    fs.stat(filename, function(er, stat) {
      if (er) return cb(er);
      assert.strictEqual(stat.size, 1024 * 16);

      fs.truncate(filename, 1024, function(er) {
        if (er) return cb(er);
        fs.stat(filename, function(er, stat) {
          if (er) return cb(er);
          assert.strictEqual(stat.size, 1024);

          fs.truncate(filename, function(er) {
            if (er) return cb(er);
            fs.stat(filename, function(er, stat) {
              if (er) return cb(er);
              assert.strictEqual(stat.size, 0);
              cb();
            });
          });
        });
      });
    });
  });
}

function testFtruncate(cb) {
  fs.writeFile(filename, data, function(er) {
    if (er) return cb(er);
    fs.stat(filename, function(er, stat) {
      if (er) return cb(er);
      assert.strictEqual(stat.size, 1024 * 16);

      fs.open(filename, 'w', function(er, fd) {
        if (er) return cb(er);
        fs.ftruncate(fd, 1024, function(er) {
          if (er) return cb(er);
          fs.stat(filename, function(er, stat) {
            if (er) return cb(er);
            assert.strictEqual(stat.size, 1024);

            fs.ftruncate(fd, function(er) {
              if (er) return cb(er);
              fs.stat(filename, function(er, stat) {
                if (er) return cb(er);
                assert.strictEqual(stat.size, 0);
                fs.close(fd, cb);
              });
            });
          });
        });
      });
    });
  });
}

// Make sure if the size of the file is smaller than the length then it is
// filled with zeroes.

{
  const file1 = path.resolve(tmp, 'truncate-file-1.txt');
  fs.writeFileSync(file1, 'Hi');
  fs.truncateSync(file1, 4);
  assert(fs.readFileSync(file1).equals(Buffer.from('Hi\u0000\u0000')));
}

{
  const file2 = path.resolve(tmp, 'truncate-file-2.txt');
  fs.writeFileSync(file2, 'Hi');
  const fd = fs.openSync(file2, 'r+');
  onExit.push(() => fs.closeSync(fd));
  fs.ftruncateSync(fd, 4);
  assert(fs.readFileSync(file2).equals(Buffer.from('Hi\u0000\u0000')));
}

{
  const file3 = path.resolve(tmp, 'truncate-file-3.txt');
  fs.writeFileSync(file3, 'Hi');
  fs.truncate(file3, 4, common.mustSucceed(() => {
    assert(fs.readFileSync(file3).equals(Buffer.from('Hi\u0000\u0000')));
  }));
}

{
  const file4 = path.resolve(tmp, 'truncate-file-4.txt');
  fs.writeFileSync(file4, 'Hi');
  const fd = fs.openSync(file4, 'r+');
  onExit.push(() => fs.closeSync(fd));
  fs.ftruncate(fd, 4, common.mustSucceed(() => {
    assert(fs.readFileSync(file4).equals(Buffer.from('Hi\u0000\u0000')));
  }));
}

{
  const file5 = path.resolve(tmp, 'truncate-file-5.txt');
  fs.writeFileSync(file5, 'Hi');
  const fd = fs.openSync(file5, 'r+');
  onExit.push(() => fs.closeSync(fd));

  ['', false, null, {}, []].forEach((input) => {
    const received = common.invalidArgTypeHelper(input);
    assert.throws(
      () => fs.truncate(file5, input, common.mustNotCall()),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""len"" argument must be of type number.${received}`
      }
    );

    assert.throws(
      () => fs.ftruncate(fd, input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""len"" argument must be of type number.${received}`
      }
    );
  });

  [-1.5, 1.5].forEach((input) => {
    assert.throws(
      () => fs.truncate(file5, input),
      {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""len"" is out of range. It must be ' +
                  `an integer. Received ${input}`
      }
    );

    assert.throws(
      () => fs.ftruncate(fd, input),
      {
        code: 'ERR_OUT_OF_RANGE',
        name: 'RangeError',
        message: 'The value of ""len"" is out of range. It must be ' +
                  `an integer. Received ${input}`
      }
    );
  });

  fs.ftruncate(fd, undefined, common.mustSucceed(() => {
    assert(fs.readFileSync(file5).equals(Buffer.from('')));
  }));
}

{
  const file6 = path.resolve(tmp, 'truncate-file-6.txt');
  fs.writeFileSync(file6, 'Hi');
  const fd = fs.openSync(file6, 'r+');
  onExit.push(() => fs.closeSync(fd));
  fs.ftruncate(fd, -1, common.mustSucceed(() => {
    assert(fs.readFileSync(file6).equals(Buffer.from('')));
  }));
}

{
  const file7 = path.resolve(tmp, 'truncate-file-7.txt');
  fs.writeFileSync(file7, 'Hi');
  fs.truncate(file7, undefined, common.mustSucceed(() => {
    assert(fs.readFileSync(file7).equals(Buffer.from('')));
  }));
}

{
  const file8 = path.resolve(tmp, 'non-existent-truncate-file.txt');
  const validateError = (err) => {
    assert.strictEqual(file8, err.path);
    /*assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, open '${file8}'`);*/
    assert.strictEqual(err.code, 'ENOENT');
    // assert.strictEqual(err.syscall, 'open');
    return true;
  };
  fs.truncate(file8, 0, common.mustCall(validateError));
}

['', false, null, {}, []].forEach((input) => {
  assert.throws(
    () => fs.truncate('/foo/bar', input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""len"" argument must be of type number.' +
               common.invalidArgTypeHelper(input)
    }
  );
});

['', false, null, undefined, {}, []].forEach((input) => {
  ['ftruncate', 'ftruncateSync'].forEach((fnName) => {
    assert.throws(
      () => fs[fnName](input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: 'The ""fd"" argument must be of type number.' +
                 common.invalidArgTypeHelper(input)
      }
    );
  });
});

{
  const file1 = path.resolve(tmp, 'truncate-file-1.txt');
  fs.writeFileSync(file1, 'Hi');
  fs.truncateSync(file1, -1);  // Negative coerced to 0, No error.
  assert(fs.readFileSync(file1).equals(Buffer.alloc(0)));
}

{
  const file1 = path.resolve(tmp, 'truncate-file-2.txt');
  fs.writeFileSync(file1, 'Hi');
  // Negative coerced to 0, No error.
  fs.truncate(file1, -1, common.mustSucceed(() => {
    assert(fs.readFileSync(file1).equals(Buffer.alloc(0)));
  }));
}
"
modules/internal/crypto/x509.js,"use strict';

const {
  ObjectSetPrototypeOf,
  SafeMap,
  Symbol,
} = primordials;

const {
  parseX509,
  X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT,
  X509_CHECK_FLAG_NEVER_CHECK_SUBJECT,
  X509_CHECK_FLAG_NO_WILDCARDS,
  X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS,
  X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS,
  X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS,
} = internalBinding('crypto');

const {
  PublicKeyObject,
  isKeyObject,
} = require('internal/crypto/keys');

const {
  customInspectSymbol: kInspect,
  kEmptyObject,
} = require('internal/util');

const {
  validateBoolean,
  validateObject,
  validateString,
} = require('internal/validators');

const { inspect } = require('internal/util/inspect');

const { Buffer } = require('buffer');

const {
  isArrayBufferView,
} = require('internal/util/types');

const {
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE,
  }
} = require('internal/errors');

const {
  JSTransferable,
  kClone,
  kDeserialize,
} = require('internal/worker/js_transferable');

const {
  kHandle,
} = require('internal/crypto/util');

let lazyTranslatePeerCertificate;

const kInternalState = Symbol('kInternalState');

function isX509Certificate(value) {
  return value[kInternalState] !== undefined;
}

function getFlags(options = kEmptyObject) {
  validateObject(options, 'options');
  const {
    subject = 'default',  // Can be 'default', 'always', or 'never'
    wildcards = true,
    partialWildcards = true,
    multiLabelWildcards = false,
    singleLabelSubdomains = false,
  } = { ...options };
  let flags = 0;
  validateString(subject, 'options.subject');
  validateBoolean(wildcards, 'options.wildcards');
  validateBoolean(partialWildcards, 'options.partialWildcards');
  validateBoolean(multiLabelWildcards, 'options.multiLabelWildcards');
  validateBoolean(singleLabelSubdomains, 'options.singleLabelSubdomains');
  switch (subject) {
    case 'default': /* Matches OpenSSL's default, no flags. */ break;
    case 'always': flags |= X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT; break;
    case 'never': flags |= X509_CHECK_FLAG_NEVER_CHECK_SUBJECT; break;
    default:
      throw new ERR_INVALID_ARG_VALUE('options.subject', subject);
  }
  if (!wildcards) flags |= X509_CHECK_FLAG_NO_WILDCARDS;
  if (!partialWildcards) flags |= X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;
  if (multiLabelWildcards) flags |= X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS;
  if (singleLabelSubdomains) flags |= X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS;
  return flags;
}

class InternalX509Certificate extends JSTransferable {
  [kInternalState] = new SafeMap();

  constructor(handle) {
    super();
    this[kHandle] = handle;
  }
}

class X509Certificate extends JSTransferable {
  [kInternalState] = new SafeMap();

  constructor(buffer) {
    if (typeof buffer === 'string')
      buffer = Buffer.from(buffer);
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE(
        'buffer',
        ['string', 'Buffer', 'TypedArray', 'DataView'],
        buffer);
    }
    super();
    this[kHandle] = parseX509(buffer);
  }

  [kInspect](depth, options) {
    if (depth < 0)
      return this;

    const opts = {
      ...options,
      depth: options.depth == null ? null : options.depth - 1
    };

    return `X509Certificate ${inspect({
      subject: this.subject,
      subjectAltName: this.subjectAltName,
      issuer: this.issuer,
      infoAccess: this.infoAccess,
      validFrom: this.validFrom,
      validTo: this.validTo,
      fingerprint: this.fingerprint,
      fingerprint256: this.fingerprint256,
      fingerprint512: this.fingerprint512,
      keyUsage: this.keyUsage,
      serialNumber: this.serialNumber,
    }, opts)}`;
  }

  [kClone]() {
    const handle = this[kHandle];
    return {
      data: { handle },
      deserializeInfo: 'internal/crypto/x509:InternalX509Certificate'
    };
  }

  [kDeserialize]({ handle }) {
    this[kHandle] = handle;
  }

  get subject() {
    let value = this[kInternalState].get('subject');
    if (value === undefined) {
      value = this[kHandle].subject();
      this[kInternalState].set('subject', value);
    }
    return value;
  }

  get subjectAltName() {
    let value = this[kInternalState].get('subjectAltName');
    if (value === undefined) {
      value = this[kHandle].subjectAltName();
      this[kInternalState].set('subjectAltName', value);
    }
    return value;
  }

  get issuer() {
    let value = this[kInternalState].get('issuer');
    if (value === undefined) {
      value = this[kHandle].issuer();
      this[kInternalState].set('issuer', value);
    }
    return value;
  }

  get issuerCertificate() {
    let value = this[kInternalState].get('issuerCertificate');
    if (value === undefined) {
      const cert = this[kHandle].getIssuerCert();
      if (cert)
        value = new InternalX509Certificate(this[kHandle].getIssuerCert());
      this[kInternalState].set('issuerCertificate', value);
    }
    return value;
  }

  get infoAccess() {
    let value = this[kInternalState].get('infoAccess');
    if (value === undefined) {
      value = this[kHandle].infoAccess();
      this[kInternalState].set('infoAccess', value);
    }
    return value;
  }

  get validFrom() {
    let value = this[kInternalState].get('validFrom');
    if (value === undefined) {
      value = this[kHandle].validFrom();
      this[kInternalState].set('validFrom', value);
    }
    return value;
  }

  get validTo() {
    let value = this[kInternalState].get('validTo');
    if (value === undefined) {
      value = this[kHandle].validTo();
      this[kInternalState].set('validTo', value);
    }
    return value;
  }

  get fingerprint() {
    let value = this[kInternalState].get('fingerprint');
    if (value === undefined) {
      value = this[kHandle].fingerprint();
      this[kInternalState].set('fingerprint', value);
    }
    return value;
  }

  get fingerprint256() {
    let value = this[kInternalState].get('fingerprint256');
    if (value === undefined) {
      value = this[kHandle].fingerprint256();
      this[kInternalState].set('fingerprint256', value);
    }
    return value;
  }

  get fingerprint512() {
    let value = this[kInternalState].get('fingerprint512');
    if (value === undefined) {
      value = this[kHandle].fingerprint512();
      this[kInternalState].set('fingerprint512', value);
    }
    return value;
  }

  get keyUsage() {
    let value = this[kInternalState].get('keyUsage');
    if (value === undefined) {
      value = this[kHandle].keyUsage();
      this[kInternalState].set('keyUsage', value);
    }
    return value;
  }

  get serialNumber() {
    let value = this[kInternalState].get('serialNumber');
    if (value === undefined) {
      value = this[kHandle].serialNumber();
      this[kInternalState].set('serialNumber', value);
    }
    return value;
  }

  get raw() {
    let value = this[kInternalState].get('raw');
    if (value === undefined) {
      value = this[kHandle].raw();
      this[kInternalState].set('raw', value);
    }
    return value;
  }

  get publicKey() {
    let value = this[kInternalState].get('publicKey');
    if (value === undefined) {
      value = new PublicKeyObject(this[kHandle].publicKey());
      this[kInternalState].set('publicKey', value);
    }
    return value;
  }

  toString() {
    let value = this[kInternalState].get('pem');
    if (value === undefined) {
      value = this[kHandle].pem();
      this[kInternalState].set('pem', value);
    }
    return value;
  }

  // There's no standardized JSON encoding for X509 certs so we
  // fallback to providing the PEM encoding as a string.
  toJSON() { return this.toString(); }

  get ca() {
    let value = this[kInternalState].get('ca');
    if (value === undefined) {
      value = this[kHandle].checkCA();
      this[kInternalState].set('ca', value);
    }
    return value;
  }

  checkHost(name, options) {
    validateString(name, 'name');
    return this[kHandle].checkHost(name, getFlags(options));
  }

  checkEmail(email, options) {
    validateString(email, 'email');
    return this[kHandle].checkEmail(email, getFlags(options));
  }

  checkIP(ip, options) {
    validateString(ip, 'ip');
    // The options argument is currently undocumented since none of the options
    // have any effect on the behavior of this function. However, we still parse
    // the options argument in case OpenSSL adds flags in the future that do
    // affect the behavior of X509_check_ip. This ensures that no invalid values
    // are passed as the second argument in the meantime.
    return this[kHandle].checkIP(ip, getFlags(options));
  }

  checkIssued(otherCert) {
    if (!isX509Certificate(otherCert))
      throw new ERR_INVALID_ARG_TYPE('otherCert', 'X509Certificate', otherCert);
    return this[kHandle].checkIssued(otherCert[kHandle]);
  }

  checkPrivateKey(pkey) {
    if (!isKeyObject(pkey))
      throw new ERR_INVALID_ARG_TYPE('pkey', 'KeyObject', pkey);
    if (pkey.type !== 'private')
      throw new ERR_INVALID_ARG_VALUE('pkey', pkey);
    return this[kHandle].checkPrivateKey(pkey[kHandle]);
  }

  verify(pkey) {
    if (!isKeyObject(pkey))
      throw new ERR_INVALID_ARG_TYPE('pkey', 'KeyObject', pkey);
    if (pkey.type !== 'public')
      throw new ERR_INVALID_ARG_VALUE('pkey', pkey);
    return this[kHandle].verify(pkey[kHandle]);
  }

  toLegacyObject() {
    // TODO(tniessen): do not depend on translatePeerCertificate here, return
    // the correct legacy representation from the binding
    lazyTranslatePeerCertificate ??=
      require('_tls_common').translatePeerCertificate;
    return lazyTranslatePeerCertificate(this[kHandle].toLegacy());
  }
}

InternalX509Certificate.prototype.constructor = X509Certificate;
ObjectSetPrototypeOf(
  InternalX509Certificate.prototype,
  X509Certificate.prototype);

module.exports = {
  X509Certificate,
  InternalX509Certificate,
  isX509Certificate,
};
"
test/path/test-path-parse-format.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';

const winPaths = [
  // [path, root]
  ['C:\\path\\dir\\index.html', 'C:\\'],
  ['C:\\another_path\\DIR\\1\\2\\33\\\\index', 'C:\\'],
  ['another_path\\DIR with spaces\\1\\2\\33\\index', ''],
  ['\\', '\\'],
  ['\\foo\\C:', '\\'],
  ['file', ''],
  ['file:stream', ''],
  ['.\\file', ''],
  ['C:', 'C:'],
  ['C:.', 'C:'],
  ['C:..', 'C:'],
  ['C:abc', 'C:'],
  ['C:\\', 'C:\\'],
  ['C:\\abc', 'C:\\' ],
  ['', ''],

  // unc
  ['\\\\server\\share\\file_path', '\\\\server\\share\\'],
  ['\\\\server two\\shared folder\\file path.zip',
   '\\\\server two\\shared folder\\'],
  ['\\\\teela\\admin$\\system32', '\\\\teela\\admin$\\'],
  ['\\\\?\\UNC\\server\\share', '\\\\?\\UNC\\'],
];

const winSpecialCaseParseTests = [
  ['t', { base: 't', name: 't', root: '', dir: '', ext: '' }],
  ['/foo/bar', { root: '/', dir: '/foo', base: 'bar', ext: '', name: 'bar' }],
];

const winSpecialCaseFormatTests = [
  [{ dir: 'some\\dir' }, 'some\\dir\\'],
  [{ base: 'index.html' }, 'index.html'],
  [{ root: 'C:\\' }, 'C:\\'],
  [{ name: 'index', ext: '.html' }, 'index.html'],
  [{ dir: 'some\\dir', name: 'index', ext: '.html' }, 'some\\dir\\index.html'],
  [{ root: 'C:\\', name: 'index', ext: '.html' }, 'C:\\index.html'],
  [{}, ''],
];

const unixPaths = [
  // [path, root]
  ['/home/user/dir/file.txt', '/'],
  ['/home/user/a dir/another File.zip', '/'],
  ['/home/user/a dir//another&File.', '/'],
  ['/home/user/a$$$dir//another File.zip', '/'],
  ['user/dir/another File.zip', ''],
  ['file', ''],
  ['.\\file', ''],
  ['./file', ''],
  ['C:\\foo', ''],
  ['/', '/'],
  ['', ''],
  ['.', ''],
  ['..', ''],
  ['/foo', '/'],
  ['/foo.', '/'],
  ['/foo.bar', '/'],
  ['/.', '/'],
  ['/.foo', '/'],
  ['/.foo.bar', '/'],
  ['/foo/bar.baz', '/'],
];

const unixSpecialCaseFormatTests = [
  [{ dir: 'some/dir' }, 'some/dir/'],
  [{ base: 'index.html' }, 'index.html'],
  [{ root: '/' }, '/'],
  [{ name: 'index', ext: '.html' }, 'index.html'],
  [{ dir: 'some/dir', name: 'index', ext: '.html' }, 'some/dir/index.html'],
  [{ root: '/', name: 'index', ext: '.html' }, '/index.html'],
  [{}, ''],
];

const errors = [
  { method: 'parse', input: [null] },
  { method: 'parse', input: [{}] },
  { method: 'parse', input: [true] },
  { method: 'parse', input: [1] },
  { method: 'parse', input: [] },
  { method: 'format', input: [null] },
  { method: 'format', input: [''] },
  { method: 'format', input: [true] },
  { method: 'format', input: [1] },
];

//checkParseFormat(path.win32, winPaths);
checkParseFormat(path.posix, unixPaths);
//checkSpecialCaseParseFormat(path.win32, winSpecialCaseParseTests);
//checkErrors(path.win32);
checkErrors(path.posix);
//checkFormat(path.win32, winSpecialCaseFormatTests);
checkFormat(path.posix, unixSpecialCaseFormatTests);

// Test removal of trailing path separators
const trailingTests = [
  /*[ path.win32.parse,
    [['.\\', { root: '', dir: '', base: '.', ext: '', name: '.' }],
     ['\\\\', { root: '\\', dir: '\\', base: '', ext: '', name: '' }],
     ['\\\\', { root: '\\', dir: '\\', base: '', ext: '', name: '' }],
     ['c:\\foo\\\\\\',
      { root: 'c:\\', dir: 'c:\\', base: 'foo', ext: '', name: 'foo' }],
     ['D:\\foo\\\\\\bar.baz',
      { root: 'D:\\',
        dir: 'D:\\foo\\\\',
        base: 'bar.baz',
        ext: '.baz',
        name: 'bar' },
     ],
    ],
  ],*/
  [ path.posix.parse,
    [['./', { root: '', dir: '', base: '.', ext: '', name: '.' }],
     ['//', { root: '/', dir: '/', base: '', ext: '', name: '' }],
     ['///', { root: '/', dir: '/', base: '', ext: '', name: '' }],
     ['/foo///', { root: '/', dir: '/', base: 'foo', ext: '', name: 'foo' }],
     ['/foo///bar.baz',
      { root: '/', dir: '/foo//', base: 'bar.baz', ext: '.baz', name: 'bar' },
     ],
    ],
  ],
];
const failures = [];
trailingTests.forEach((test) => {
  const parse = test[0];
  const os = /*parse === path.win32.parse ? 'win32' : */'posix';
  test[1].forEach((test) => {
    const actual = parse(test[0]);
    const expected = test[1];
    const message = `path.${os}.parse(${JSON.stringify(test[0])})\n  expect=${
      JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    const actualKeys = Object.keys(actual);
    const expectedKeys = Object.keys(expected);
    let failed = (actualKeys.length !== expectedKeys.length);
    if (!failed) {
      for (let i = 0; i < actualKeys.length; ++i) {
        const key = actualKeys[i];
        if (!expectedKeys.includes(key) || actual[key] !== expected[key]) {
          failed = true;
          break;
        }
      }
    }
    if (failed)
      failures.push(`\n${message}`);
  });
});
assert.strictEqual(failures.length, 0, failures.join(''));

function checkErrors(path) {
  errors.forEach(({ method, input }) => {
    assert.throws(() => {
      path[method].apply(path, input);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  });
}

function checkParseFormat(path, paths) {
  paths.forEach(([element, root]) => {
    const output = path.parse(element);
    assert.strictEqual(typeof output.root, 'string');
    assert.strictEqual(typeof output.dir, 'string');
    assert.strictEqual(typeof output.base, 'string');
    assert.strictEqual(typeof output.ext, 'string');
    assert.strictEqual(typeof output.name, 'string');
    assert.strictEqual(path.format(output), element);
    assert.strictEqual(output.root, root);
    assert(output.dir.startsWith(output.root));
    assert.strictEqual(output.dir, output.dir ? path.dirname(element) : '');
    assert.strictEqual(output.base, path.basename(element));
    assert.strictEqual(output.ext, path.extname(element));
  });
}

function checkSpecialCaseParseFormat(path, testCases) {
  testCases.forEach(([element, expect]) => {
    assert.deepStrictEqual(path.parse(element), expect);
  });
}

function checkFormat(path, testCases) {
  testCases.forEach(([element, expect]) => {
    assert.strictEqual(path.format(element), expect);
  });

  [null, undefined, 1, true, false, 'string'].forEach((pathObject) => {
    assert.throws(() => {
      path.format(pathObject);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""pathObject"" argument must be of type object.' +
               common.invalidArgTypeHelper(pathObject)
    });
  });
}
"
modules/internal/streams/destroy.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { aggregateTwoErrors, ERR_MULTIPLE_CALLBACK } from ""../errors.js"";

const kDestroy = Symbol(""kDestroy"");
const kConstruct = Symbol(""kConstruct"");

function checkError(err, w, r) {
    if (err) {
        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
        err.stack; // eslint-disable-line no-unused-expressions

        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}

// Backwards compat. cb() is undocumented and unused in core but
// unfortunately might be used by modules.
function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    // With duplex streams we use the writable side for state.
    const s = w || r;

    if ((w && w.destroyed) || (r && r.destroyed)) {
        if (typeof cb === ""function"") {
            cb();
        }

        return this;
    }

    // We set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    checkError(err, w, r);

    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }

    // If still constructing then defer calling _destroy.
    if (!s.constructed) {
        this.once(kDestroy, function (er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }

    return this;
}

function _destroy(self, err, cb) {
    let called = false;

    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;

        const r = self._readableState;
        const w = self._writableState;

        checkError(err, w, r);

        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }

        if (typeof cb === ""function"") {
            cb(err);
        }

        if (err) {
            nextTick(emitErrorCloseNT, self, err);
        } else {
            nextTick(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    function () {
                        nextTick(onDestroy, null);
                    },
                    function (err) {
                        nextTick(onDestroy, err);
                    },
                );
            }
        }
    } catch (err) {
        onDestroy(err);
    }
}

function emitErrorCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}

function emitCloseNT(self) {
    const r = self._readableState;
    const w = self._writableState;

    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }

    if ((w && w.emitClose) || (r && r.emitClose)) {
        self.emit(""close"");
    }
}

function emitErrorNT(self, err) {
    const r = self._readableState;
    const w = self._writableState;

    if ((w && w.errorEmitted) || (r && r.errorEmitted)) {
        return;
    }

    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }

    self.emit(""error"", err);
}

function undestroy() {
    const r = this._readableState;
    const w = this._writableState;

    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }

    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}

function errorOrDestroy(stream, err, sync) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.

    const r = stream._readableState;
    const w = stream._writableState;

    if ((w && w.destroyed) || (r && r.destroyed)) {
        return this;
    }

    if ((r && r.autoDestroy) || (w && w.autoDestroy)) {
        stream.destroy(err);
    } else if (err) {
        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
        err.stack; // eslint-disable-line no-unused-expressions

        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}

function construct(stream, cb) {
    if (typeof stream._construct !== ""function"") {
        return;
    }

    const r = stream._readableState;
    const w = stream._writableState;

    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }

    stream.once(kConstruct, cb);

    if (stream.listenerCount(kConstruct) > 1) {
        // Duplex
        return;
    }

    nextTick(constructNT, stream);
}

function constructNT(stream) {
    let called = false;

    function onConstruct(err) {
        if (called) {
            errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;

        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;

        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }

        if (s.destroyed) {
            stream.emit(kDestroy, err);
        } else if (err) {
            errorOrDestroy(stream, err, true);
        } else {
            nextTick(emitConstructNT, stream);
        }
    }

    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    function () {
                        nextTick(onConstruct, null);
                    },
                    function (err) {
                        nextTick(onConstruct, err);
                    },
                );
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}

function emitConstructNT(stream) {
    stream.emit(kConstruct);
}

function isRequest(stream) {
    return stream && stream.setHeader && typeof stream.abort === ""function"";
}

// Normalize destroy for legacy.
function destroyer(stream, err) {
    if (!stream) return;
    if (isRequest(stream)) return stream.abort();
    if (isRequest(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === ""function"") return stream.destroy(err);
    if (typeof stream.close === ""function"") return stream.close();
}

export default {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy,
};
export { construct, destroy, destroyer, errorOrDestroy, undestroy };"
modules/internal_binding/constants.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
export const os = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4,
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18,
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30, // TODO(uki00a): In Solaris, this should be `19`. Is there any way to address this difference?
    SIGSTKFLT: 16,
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20,
  },
};
export const fs = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4,
};
export const crypto = {
  OPENSSL_VERSION_NUMBER: 269488319,
  SSL_OP_ALL: 2147485780,
  SSL_OP_ALLOW_NO_DHE_KEX: 1024,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
  SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
  SSL_OP_CISCO_ANYCONNECT: 32768,
  SSL_OP_COOKIE_EXCHANGE: 8192,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
  SSL_OP_EPHEMERAL_RSA: 0,
  SSL_OP_LEGACY_SERVER_CONNECT: 4,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
  SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
  SSL_OP_NETSCAPE_CA_DN_BUG: 0,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NO_COMPRESSION: 131072,
  SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
  SSL_OP_NO_QUERY_MTU: 4096,
  SSL_OP_NO_RENEGOTIATION: 1073741824,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
  SSL_OP_NO_SSLv2: 0,
  SSL_OP_NO_SSLv3: 33554432,
  SSL_OP_NO_TICKET: 16384,
  SSL_OP_NO_TLSv1: 67108864,
  SSL_OP_NO_TLSv1_1: 268435456,
  SSL_OP_NO_TLSv1_2: 134217728,
  SSL_OP_NO_TLSv1_3: 536870912,
  SSL_OP_PKCS1_CHECK_1: 0,
  SSL_OP_PKCS1_CHECK_2: 0,
  SSL_OP_PRIORITIZE_CHACHA: 2097152,
  SSL_OP_SINGLE_DH_USE: 0,
  SSL_OP_SINGLE_ECDH_USE: 0,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
  SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
  SSL_OP_TLS_D5_BUG: 0,
  SSL_OP_TLS_ROLLBACK_BUG: 8388608,
  ENGINE_METHOD_RSA: 1,
  ENGINE_METHOD_DSA: 2,
  ENGINE_METHOD_DH: 4,
  ENGINE_METHOD_RAND: 8,
  ENGINE_METHOD_EC: 2048,
  ENGINE_METHOD_CIPHERS: 64,
  ENGINE_METHOD_DIGESTS: 128,
  ENGINE_METHOD_PKEY_METHS: 512,
  ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
  ENGINE_METHOD_ALL: 65535,
  ENGINE_METHOD_NONE: 0,
  DH_CHECK_P_NOT_SAFE_PRIME: 2,
  DH_CHECK_P_NOT_PRIME: 1,
  DH_UNABLE_TO_CHECK_GENERATOR: 4,
  DH_NOT_SUITABLE_GENERATOR: 8,
  ALPN_ENABLED: 1,
  RSA_PKCS1_PADDING: 1,
  RSA_SSLV23_PADDING: 2,
  RSA_NO_PADDING: 3,
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_X931_PADDING: 5,
  RSA_PKCS1_PSS_PADDING: 6,
  RSA_PSS_SALTLEN_DIGEST: -1,
  RSA_PSS_SALTLEN_MAX_SIGN: -2,
  RSA_PSS_SALTLEN_AUTO: -2,
  defaultCoreCipherList:
    ""TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"",
  TLS1_VERSION: 769,
  TLS1_1_VERSION: 770,
  TLS1_2_VERSION: 771,
  TLS1_3_VERSION: 772,
  POINT_CONVERSION_COMPRESSED: 2,
  POINT_CONVERSION_UNCOMPRESSED: 4,
  POINT_CONVERSION_HYBRID: 6,
};
export const zlib = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  ZLIB_VERNUM: 4784,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_PARAM_MODE: 0,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31,
};
export const trace = {
  TRACE_EVENT_PHASE_BEGIN: 66,
  TRACE_EVENT_PHASE_END: 69,
  TRACE_EVENT_PHASE_COMPLETE: 88,
  TRACE_EVENT_PHASE_INSTANT: 73,
  TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
  TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
  TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
  TRACE_EVENT_PHASE_ASYNC_END: 70,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
  TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
  TRACE_EVENT_PHASE_FLOW_STEP: 116,
  TRACE_EVENT_PHASE_FLOW_END: 102,
  TRACE_EVENT_PHASE_METADATA: 77,
  TRACE_EVENT_PHASE_COUNTER: 67,
  TRACE_EVENT_PHASE_SAMPLE: 80,
  TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
  TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
  TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
  TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
  TRACE_EVENT_PHASE_MARK: 82,
  TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
  TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
  TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
  TRACE_EVENT_PHASE_LINK_IDS: 61,
};
"
test/crypto/test-crypto-scrypt.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from'assert';
import crypto from 'crypto';

const good = [
  // Zero-length key is legal, functions as a parameter validation check.
  {
    pass: '',
    salt: '',
    keylen: 0,
    N: 16,
    p: 1,
    r: 1,
    expected: '',
  },
  // Test vectors from https://tools.ietf.org/html/rfc7914#page-13 that
  // should pass.  Note that the test vector with N=1048576 is omitted
  // because it takes too long to complete and uses over 1 GiB of memory.
  {
    pass: '',
    salt: '',
    keylen: 64,
    N: 16,
    p: 1,
    r: 1,
    expected:
        '77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442' +
        'fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906',
  },
  {
    pass: 'password',
    salt: 'NaCl',
    keylen: 64,
    N: 1024,
    p: 16,
    r: 8,
    expected:
        'fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b373162' +
        '2eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640',
  },
  {
    pass: 'pleaseletmein',
    salt: 'SodiumChloride',
    keylen: 64,
    N: 16384,
    p: 1,
    r: 8,
    expected:
        '7023bdcb3afd7348461c06cd81fd38ebfda8fbba904f8e3ea9b543f6545da1f2' +
        'd5432955613f0fcf62d49705242a9af9e61e85dc0d651e40dfcf017b45575887',
  },
  {
    pass: '',
    salt: '',
    keylen: 64,
    cost: 16,
    parallelization: 1,
    blockSize: 1,
    expected:
        '77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442' +
        'fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906',
  },
  {
    pass: 'password',
    salt: 'NaCl',
    keylen: 64,
    cost: 1024,
    parallelization: 16,
    blockSize: 8,
    expected:
        'fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b373162' +
        '2eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640',
  },
  {
    pass: 'pleaseletmein',
    salt: 'SodiumChloride',
    keylen: 64,
    cost: 16384,
    parallelization: 1,
    blockSize: 8,
    expected:
        '7023bdcb3afd7348461c06cd81fd38ebfda8fbba904f8e3ea9b543f6545da1f2' +
        'd5432955613f0fcf62d49705242a9af9e61e85dc0d651e40dfcf017b45575887',
  },
];

// Test vectors that should fail.
const bad = [
  { N: 1, p: 1, r: 1 },         // N < 2
  { N: 3, p: 1, r: 1 },         // Not power of 2.
  { N: 1, cost: 1 },            // Both N and cost
  { p: 1, parallelization: 1 }, // Both p and parallelization
  { r: 1, blockSize: 1 },        // Both r and blocksize
];

// Test vectors where 128*N*r exceeds maxmem.
const toobig = [
  { N: 2 ** 16, p: 1, r: 1 },   // N >= 2**(r*16)
  { N: 2, p: 2 ** 30, r: 1 },   // p > (2**30-1)/r
  { N: 2 ** 20, p: 1, r: 8 },
  { N: 2 ** 10, p: 1, r: 8, maxmem: 2 ** 20 },
];

const badargs = [
  {
    args: [],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""password""/ },
  },
  {
    args: [null],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""password""/ },
  },
  {
    args: [''],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""salt""/ },
  },
  {
    args: ['', null],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""salt""/ },
  },
  {
    args: ['', ''],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""keylen""/ },
  },
  {
    args: ['', '', null],
    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /""keylen""/ },
  },
  {
    args: ['', '', .42],
    expected: { code: 'ERR_OUT_OF_RANGE', message: /""keylen""/ },
  },
  {
    args: ['', '', -42],
    expected: { code: 'ERR_OUT_OF_RANGE', message: /""keylen""/ },
  },
  {
    args: ['', '', 2147485780],
    expected: { code: 'ERR_OUT_OF_RANGE', message: /""keylen""/ },
  },
];

for (const options of good) {
  const { pass, salt, keylen, expected } = options;
  const actual = crypto.scryptSync(pass, salt, keylen, options);
  assert.strictEqual(actual.toString('hex'), expected);
  crypto.scrypt(pass, salt, keylen, options, common.mustSucceed((actual) => {
    assert.strictEqual(actual.toString('hex'), expected);
  }));
}

for (const options of bad) {
  const expected = {
    message: /Invalid scrypt param/,
  };
  assert.throws(() => crypto.scrypt('pass', 'salt', 1, options, () => {}),
                expected);
  assert.throws(() => crypto.scryptSync('pass', 'salt', 1, options),
                expected);
}

for (const options of toobig) {
  const expected = {
    message: /Invalid scrypt param/
  };
  assert.throws(() => crypto.scrypt('pass', 'salt', 1, options, () => {}),
                expected);
  assert.throws(() => crypto.scryptSync('pass', 'salt', 1, options),
                expected);
}

{
  const defaults = { N: 16384, p: 1, r: 8 };
  const expected = crypto.scryptSync('pass', 'salt', 1, defaults);
  const actual = crypto.scryptSync('pass', 'salt', 1);
  assert.deepStrictEqual(actual.toString('hex'), expected.toString('hex'));
  crypto.scrypt('pass', 'salt', 1, common.mustSucceed((actual) => {
    assert.deepStrictEqual(actual.toString('hex'), expected.toString('hex'));
  }));
}
/* deprecated
{
  const defaultEncoding = crypto.DEFAULT_ENCODING;
  const defaults = { N: 16384, p: 1, r: 8 };
  const expected = crypto.scryptSync('pass', 'salt', 1, defaults);

  const testEncoding = 'latin1';
  crypto.DEFAULT_ENCODING = testEncoding;
  const actual = crypto.scryptSync('pass', 'salt', 1);
  assert.deepStrictEqual(actual, expected.toString(testEncoding));

  crypto.scrypt('pass', 'salt', 1, common.mustSucceed((actual) => {
    assert.deepStrictEqual(actual, expected.toString(testEncoding));
  }));

  crypto.DEFAULT_ENCODING = defaultEncoding;
}
*/
for (const { args, expected } of badargs) {
  assert.throws(() => crypto.scrypt(...args), expected);
  assert.throws(() => crypto.scryptSync(...args), expected);
}

{
  const expected = { code: 'ERR_INVALID_ARG_TYPE' };
  assert.throws(() => crypto.scrypt('', '', 42, null), expected);
  assert.throws(() => crypto.scrypt('', '', 42, {}, null), expected);
  assert.throws(() => crypto.scrypt('', '', 42, {}), expected);
  assert.throws(() => crypto.scrypt('', '', 42, {}, {}), expected);
}

{
  // Values for maxmem that do not fit in 32 bits but that are still safe
  // integers should be allowed.
  crypto.scrypt('', '', 4, { maxmem: 2 ** 52 },
                common.mustSucceed((actual) => {
                  assert.strictEqual(actual.toString('hex'), 'd72c87d0');
                }));

  // Values that exceed Number.isSafeInteger should not be allowed.
  assert.throws(() => crypto.scryptSync('', '', 0, { maxmem: 2 ** 53 }), {
    code: 'ERR_OUT_OF_RANGE'
  });
}

{
  // Regression test for https://github.com/nodejs/node/issues/28836.

  function testParameter(name, value) {
    let accessCount = 0;

    // Find out how often the value is accessed.
    crypto.scryptSync('', '', 1, {
      get [name]() {
        accessCount++;
        return value;
      }
    });

    // Try to crash the process on the last access.
    assert.throws(() => {
      crypto.scryptSync('', '', 1, {
        get [name]() {
          if (--accessCount === 0)
            return '';
          return value;
        }
      });
    }, {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  }

  [
    ['N', 16384], ['cost', 16384],
    ['r', 8], ['blockSize', 8],
    ['p', 1], ['parallelization', 1],
  ].forEach((arg) => testParameter(...arg));
}
"
test/crypto/test-crypto-prime.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const {
  generatePrime,
  generatePrimeSync,
  checkPrime,
  checkPrimeSync,
} = require('crypto');

const { promisify } = require('util');
const pgeneratePrime = promisify(generatePrime);
const pCheckPrime = promisify(checkPrime);

['hello', false, {}, []].forEach((i) => {
  assert.throws(() => generatePrime(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

['hello', false, 123].forEach((i) => {
  assert.throws(() => generatePrime(80, i, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(80, i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

['hello', false, 123].forEach((i) => {
  assert.throws(() => generatePrime(80, {}), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

[-1, 0, 2 ** 31, 2 ** 31 + 1, 2 ** 32 - 1, 2 ** 32].forEach((size) => {
  assert.throws(() => generatePrime(size, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: />= 1 && <= 2147483647/
  });
  assert.throws(() => generatePrimeSync(size), {
    code: 'ERR_OUT_OF_RANGE',
    message: />= 1 && <= 2147483647/
  });
});

['test', -1, {}, []].forEach((i) => {
  assert.throws(() => generatePrime(8, { safe: i }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrime(8, { rem: i }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrime(8, { add: i }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(8, { safe: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(8, { rem: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => generatePrimeSync(8, { add: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

{
  // Negative BigInts should not be converted to 0 silently.

  assert.throws(() => generatePrime(20, { add: -1n }, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""options.add"" is out of range. It must be >= 0. ' +
             'Received -1n'
  });

  assert.throws(() => generatePrime(20, { rem: -1n }, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""options.rem"" is out of range. It must be >= 0. ' +
             'Received -1n'
  });

  assert.throws(() => checkPrime(-1n, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""candidate"" is out of range. It must be >= 0. ' +
             'Received -1n'
  });
}

generatePrime(80, common.mustSucceed((prime) => {
  assert(checkPrimeSync(prime));
  checkPrime(prime, common.mustSucceed((result) => {
    assert(result);
  }));
}));

assert(checkPrimeSync(generatePrimeSync(80)));

generatePrime(80, {}, common.mustSucceed((prime) => {
  assert(checkPrimeSync(prime));
}));

assert(checkPrimeSync(generatePrimeSync(80, {})));

generatePrime(32, { safe: true }, common.mustSucceed((prime) => {
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  const check = (val - 1) / 2;
  buf.writeUInt32BE(check);
  assert(checkPrimeSync(buf));
}));

{
  const prime = generatePrimeSync(32, { safe: true });
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  const check = (val - 1) / 2;
  buf.writeUInt32BE(check);
  assert(checkPrimeSync(buf));
}

const add = 12;
const rem = 11;
const add_buf = Buffer.from([add]);
const rem_buf = Buffer.from([rem]);
generatePrime(
  32,
  { add: add_buf, rem: rem_buf },
  common.mustSucceed((prime) => {
    assert(checkPrimeSync(prime));
    const buf = Buffer.from(prime);
    const val = buf.readUInt32BE();
    assert.strictEqual(val % add, rem);
  }));

{
  const prime = generatePrimeSync(32, { add: add_buf, rem: rem_buf });
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  assert.strictEqual(val % add, rem);
}

{
  const prime = generatePrimeSync(32, { add: BigInt(add), rem: BigInt(rem) });
  assert(checkPrimeSync(prime));
  const buf = Buffer.from(prime);
  const val = buf.readUInt32BE();
  assert.strictEqual(val % add, rem);
}

{
  // The behavior when specifying only add without rem should depend on the
  // safe option.

  if (process.versions.openssl >= '1.1.1f') {
    generatePrime(128, {
      bigint: true,
      add: 5n
    }, common.mustSucceed((prime) => {
      assert(checkPrimeSync(prime));
      assert.strictEqual(prime % 5n, 1n);
    }));

    generatePrime(128, {
      bigint: true,
      safe: true,
      add: 5n
    }, common.mustSucceed((prime) => {
      assert(checkPrimeSync(prime));
      assert.strictEqual(prime % 5n, 3n);
    }));
  }
}

{
  // This is impossible because it implies (prime % 2**64) == 1 and
  // prime < 2**64, meaning prime = 1, but 1 is not prime.
  for (const add of [2n ** 64n, 2n ** 65n]) {
    assert.throws(() => {
      generatePrimeSync(64, { add });
    }, {
      code: 'ERR_OUT_OF_RANGE',
      message: 'invalid options.add'
    });
  }

  // Any parameters with rem >= add lead to an impossible condition.
  for (const rem of [7n, 8n, 3000n]) {
    assert.throws(() => {
      generatePrimeSync(64, { add: 7n, rem });
    }, {
      code: 'ERR_OUT_OF_RANGE',
      message: 'invalid options.rem'
    });
  }

  // This is possible, but not allowed. It implies prime == 7, which means that
  // we did not actually generate a random prime.
  assert.throws(() => {
    generatePrimeSync(3, { add: 8n, rem: 7n });
  }, {
    code: 'ERR_OUT_OF_RANGE'
  });

  if (process.versions.openssl >= '1.1.1f') {
    // This is possible and allowed (but makes little sense).
    assert.strictEqual(generatePrimeSync(4, {
      add: 15n,
      rem: 13n,
      bigint: true
    }), 13n);
  }
}

[1, 'hello', {}, []].forEach((i) => {
  assert.throws(() => checkPrime(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

['hello', {}, []].forEach((i) => {
  assert.throws(() => checkPrime(2, { checks: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  }, common.mustNotCall());
  assert.throws(() => checkPrimeSync(2, { checks: i }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

assert(!checkPrimeSync(Buffer.from([0x1])));
assert(checkPrimeSync(Buffer.from([0x2])));
assert(checkPrimeSync(Buffer.from([0x3])));
assert(!checkPrimeSync(Buffer.from([0x4])));

assert(
  !checkPrimeSync(
    Buffer.from([0x1]),
    {
      fast: true,
      trialDivision: true,
      checks: 10
    }));

(async function() {
  const prime = await pgeneratePrime(36);
  assert(await pCheckPrime(prime));
})().then(common.mustCall());

assert.throws(() => {
  generatePrimeSync(32, { bigint: '' });
}, { code: 'ERR_INVALID_ARG_TYPE' });

assert.throws(() => {
  generatePrime(32, { bigint: '' }, common.mustNotCall());
}, { code: 'ERR_INVALID_ARG_TYPE' });

{
  const prime = generatePrimeSync(3, { bigint: true });
  assert.strictEqual(typeof prime, 'bigint');
  assert.strictEqual(prime, 7n);
  assert(checkPrimeSync(prime));
  checkPrime(prime, common.mustSucceed(assert));
}

{
  generatePrime(3, { bigint: true }, common.mustSucceed((prime) => {
    assert.strictEqual(typeof prime, 'bigint');
    assert.strictEqual(prime, 7n);
    assert(checkPrimeSync(prime));
    checkPrime(prime, common.mustSucceed(assert));
  }));
}
"
test/fs/test-fs-read-stream.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

import child_process from 'child_process';
import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const fn = fixtures.path('elipses.txt');
const rangeFile = fixtures.path('x.txt');

function test1(options) {
  let paused = false;
  let bytesRead = 0;

  const file = fs.createReadStream(fn, options);
  const fileSize = fs.statSync(fn).size;

  assert.strictEqual(file.bytesRead, 0);

  file.on('open', common.mustCall(function(fd) {
    file.length = 0;
    assert.strictEqual(typeof fd, 'number');
    assert.strictEqual(file.bytesRead, 0);
    assert.ok(file.readable);

    // GH-535
    file.pause();
    file.resume();
    file.pause();
    file.resume();
  }));

  file.on('data', function(data) {
    assert.ok(data instanceof Buffer);
    assert.ok(data.byteOffset % 8 === 0);
    assert.ok(!paused);
    file.length += data.length;

    bytesRead += data.length;
    assert.strictEqual(file.bytesRead, bytesRead);

    paused = true;
    file.pause();

    setTimeout(function() {
      paused = false;
      file.resume();
    }, 10);
  });


  file.on('end', common.mustCall(function(chunk) {
    assert.strictEqual(bytesRead, fileSize);
    assert.strictEqual(file.bytesRead, fileSize);
  }));


  file.on('close', common.mustCall(function() {
    assert.strictEqual(bytesRead, fileSize);
    assert.strictEqual(file.bytesRead, fileSize);
  }));

  process.on('exit', function() {
    assert.strictEqual(file.length, 30000);
  });
}

test1({});
test1({
  fs: {
    open: common.mustCall(fs.open),
    read: common.mustCallAtLeast(fs.read, 1),
    close: common.mustCall(fs.close),
  }
});

{
  const file = fs.createReadStream(fn, common.mustNotMutateObjectDeep({ encoding: 'utf8' }));
  file.length = 0;
  file.on('data', function(data) {
    assert.strictEqual(typeof data, 'string');
    file.length += data.length;

    for (let i = 0; i < data.length; i++) {
      // http://www.fileformat.info/info/unicode/char/2026/index.htm
      assert.strictEqual(data[i], '\u2026');
    }
  });

  file.on('close', common.mustCall());

  process.on('exit', function() {
    assert.strictEqual(file.length, 10000);
  });
}

{
  const file =
    fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ bufferSize: 1, start: 1, end: 2 }));
  let contentRead = '';
  file.on('data', function(data) {
    contentRead += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function(data) {
    assert.strictEqual(contentRead, 'yz');
  }));
}

{
  const file = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ bufferSize: 1, start: 1 }));
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

{
  // Ref: https://github.com/nodejs/node-v0.x-archive/issues/2320
  const file = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ bufferSize: 1.23, start: 1 }));
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

assert.throws(
  () => {
    fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ start: 10, end: 2 }));
  },
  {
    code: 'ERR_OUT_OF_RANGE',
    message: 'The value of ""start"" is out of range. It must be <= ""end""' +
             ' (here: 2). Received 10',
    name: 'RangeError'
  });

{
  const stream = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ start: 0, end: 0 }));
  stream.data = '';

  stream.on('data', function(chunk) {
    stream.data += chunk;
  });

  stream.on('end', common.mustCall(function() {
    assert.strictEqual(stream.data, 'x');
  }));
}

{
  // Verify that end works when start is not specified.
  const stream = new fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ end: 1 }));
  stream.data = '';

  stream.on('data', function(chunk) {
    stream.data += chunk;
  });

  stream.on('end', common.mustCall(function() {
    assert.strictEqual(stream.data, 'xy');
  }));
}

if (!common.isWindows) {
  // Verify that end works when start is not specified, and we do not try to
  // use positioned reads. This makes sure that this keeps working for
  // non-seekable file descriptors.
  tmpdir.refresh();
  const filename = `${tmpdir.path}/foo.pipe`;
  const mkfifoResult = child_process.spawnSync('mkfifo', [filename]);
  if (!mkfifoResult.error) {
    child_process.exec(`echo ""xyz foobar"" > '${filename}'`);
    const stream = new fs.createReadStream(filename, common.mustNotMutateObjectDeep({ end: 1 }));
    stream.data = '';

    stream.on('data', function(chunk) {
      stream.data += chunk;
    });

    stream.on('end', common.mustCall(function() {
      assert.strictEqual(stream.data, 'xy');
      fs.unlinkSync(filename);
    }));
  } else {
    common.printSkipMessage('mkfifo not available');
  }
}

{
  // Pause and then resume immediately.
  const pauseRes = fs.createReadStream(rangeFile);
  pauseRes.pause();
  pauseRes.resume();
}

{
  let file = fs.createReadStream(rangeFile, common.mustNotMutateObjectDeep({ autoClose: false }));
  let data = '';
  file.on('data', function(chunk) { data += chunk; });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(data, 'xyz\n');
    process.nextTick(function() {
      assert(!file.closed);
      assert(!file.destroyed);
      fileNext();
    });
  }));

  function fileNext() {
    // This will tell us if the fd is usable again or not.
    file = fs.createReadStream(null, common.mustNotMutateObjectDeep({ fd: file.fd, start: 0 }));
    file.data = '';
    file.on('data', function(data) {
      file.data += data;
    });
    file.on('end', common.mustCall(function(err) {
      assert.strictEqual(file.data, 'xyz\n');
    }));
    process.on('exit', function() {
      assert(file.closed);
      assert(file.destroyed);
    });
  }
}

{
  // Just to make sure autoClose won't close the stream because of error.
  const file = fs.createReadStream(null, common.mustNotMutateObjectDeep({ fd: 13337, autoClose: false }));
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());
  process.on('exit', function() {
    assert(!file.closed);
    assert(!file.destroyed);
    assert(file.fd);
  });
}

{
  // Make sure stream is destroyed when file does not exist.
  const file = fs.createReadStream('/path/to/file/that/does/not/exist');
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());

  process.on('exit', function() {
    assert(file.closed);
    assert(file.destroyed);
  });
}
"
test/crypto/test-crypto-cipher-decipher.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

if (common.hasFipsCrypto)
  common.skip('not supported in FIPS mode');

const crypto = require('crypto');
const assert = require('assert');

common.expectWarning({
  Warning: [
    ['Use Cipheriv for counter mode of aes-256-gcm'],
  ],
  DeprecationWarning: [
    ['crypto.createCipher is deprecated.', 'DEP0106'],
  ]
});

function testCipher1(key) {
  // Test encryption and decryption
  const plaintext = 'Keep this a secret? No! Tell everyone about node.js!';
  const cipher = crypto.createCipher('aes192', key);

  // Encrypt plaintext which is in utf8 format
  // to a ciphertext which will be in hex
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  // Only use binary or hex, not base64.
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipher('aes192', key);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);

  // Streaming cipher interface
  // NB: In real life, it's not guaranteed that you can get all of it
  // in a single read() like this.  But in this case, we know it's
  // quite small, so there's no harm.
  const cStream = crypto.createCipher('aes192', key);
  cStream.end(plaintext);
  ciph = cStream.read();

  const dStream = crypto.createDecipher('aes192', key);
  dStream.end(ciph);
  txt = dStream.read().toString('utf8');

  assert.strictEqual(txt, plaintext);
}


function testCipher2(key) {
  // Encryption and decryption with Base64.
  // Reported in https://github.com/joyent/node/issues/738
  const plaintext =
      '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
      'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
      'jAfaFg**';
  const cipher = crypto.createCipher('aes256', key);

  // Encrypt plaintext which is in utf8 format to a ciphertext which will be in
  // Base64.
  let ciph = cipher.update(plaintext, 'utf8', 'base64');
  ciph += cipher.final('base64');

  const decipher = crypto.createDecipher('aes256', key);
  let txt = decipher.update(ciph, 'base64', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext);
}

testCipher1('MySecretKey123');
testCipher1(Buffer.from('MySecretKey123'));

testCipher2('0123456789abcdef');
testCipher2(Buffer.from('0123456789abcdef'));

{
  const Cipher = crypto.Cipher;
  const instance = crypto.Cipher('aes-256-cbc', 'secret');
  assert(instance instanceof Cipher, 'Cipher is expected to return a new ' +
                                     'instance when called without `new`');

  assert.throws(
    () => crypto.createCipher(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createCipher('aes-256-cbc', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });

  assert.throws(
    () => crypto.createCipher('aes-256-cbc', 'secret').update(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createCipher('aes-256-cbc', 'secret').setAAD(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

{
  const Decipher = crypto.Decipher;
  const instance = crypto.Decipher('aes-256-cbc', 'secret');
  assert(instance instanceof Decipher, 'Decipher is expected to return a new ' +
                                       'instance when called without `new`');

  assert.throws(
    () => crypto.createDecipher(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createDecipher('aes-256-cbc', 'secret').setAuthTag(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createDecipher('aes-256-cbc', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

// Base64 padding regression test, see
// https://github.com/nodejs/node-v0.x-archive/issues/4837.
{
  const c = crypto.createCipher('aes-256-cbc', 'secret');
  const s = c.update('test', 'utf8', 'base64') + c.final('base64');
  assert.strictEqual(s, '375oxUQCIocvxmC5At+rvA==');
}

// Calling Cipher.final() or Decipher.final() twice should error but
// not assert. See https://github.com/nodejs/node-v0.x-archive/issues/4886.
{
  const c = crypto.createCipher('aes-256-cbc', 'secret');
  try { c.final('xxx'); } catch { /* Ignore. */ }
  try { c.final('xxx'); } catch { /* Ignore. */ }
  try { c.final('xxx'); } catch { /* Ignore. */ }
  const d = crypto.createDecipher('aes-256-cbc', 'secret');
  try { d.final('xxx'); } catch { /* Ignore. */ }
  try { d.final('xxx'); } catch { /* Ignore. */ }
  try { d.final('xxx'); } catch { /* Ignore. */ }
}

// Regression test for https://github.com/nodejs/node-v0.x-archive/issues/5482:
// string to Cipher#update() should not assert.
{
  const c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update');
  c.final();
}

// https://github.com/nodejs/node-v0.x-archive/issues/5655 regression tests,
// 'utf-8' and 'utf8' are identical.
{
  let c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update', '');  // Defaults to ""utf8"".
  c.final('utf-8');  // Should not throw.

  c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update', 'utf8');
  c.final('utf-8');  // Should not throw.

  c = crypto.createCipher('aes192', '0123456789abcdef');
  c.update('update', 'utf-8');
  c.final('utf8');  // Should not throw.
}

// Regression tests for https://github.com/nodejs/node/issues/8236.
{
  const key = '0123456789abcdef';
  const plaintext = 'Top secret!!!';
  const c = crypto.createCipher('aes192', key);
  let ciph = c.update(plaintext, 'utf16le', 'base64');
  ciph += c.final('base64');

  let decipher = crypto.createDecipher('aes192', key);

  let txt;
  txt = decipher.update(ciph, 'base64', 'ucs2');
  txt += decipher.final('ucs2');
  assert.strictEqual(txt, plaintext);

  decipher = crypto.createDecipher('aes192', key);
  txt = decipher.update(ciph, 'base64', 'ucs-2');
  txt += decipher.final('ucs-2');
  assert.strictEqual(txt, plaintext);

  decipher = crypto.createDecipher('aes192', key);
  txt = decipher.update(ciph, 'base64', 'utf-16le');
  txt += decipher.final('utf-16le');
  assert.strictEqual(txt, plaintext);
}

// setAutoPadding/setAuthTag/setAAD should return `this`
{
  const key = '0123456789';
  const tagbuf = Buffer.from('auth_tag');
  const aadbuf = Buffer.from('aadbuf');
  const decipher = crypto.createDecipher('aes-256-gcm', key);
  assert.strictEqual(decipher.setAutoPadding(), decipher);
  assert.strictEqual(decipher.setAuthTag(tagbuf), decipher);
  assert.strictEqual(decipher.setAAD(aadbuf), decipher);
}

// Error throwing in setAAD/setAuthTag/getAuthTag/setAutoPadding
{
  const key = '0123456789';
  const aadbuf = Buffer.from('aadbuf');
  const data = Buffer.from('test-crypto-cipher-decipher');

  const cipher = crypto.createCipher('aes-256-gcm', key);
  cipher.setAAD(aadbuf);
  cipher.setAutoPadding();

  assert.throws(
    () => cipher.getAuthTag(),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation getAuthTag'
    }
  );

  const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);

  const decipher = crypto.createDecipher('aes-256-gcm', key);
  decipher.setAAD(aadbuf);
  decipher.setAuthTag(cipher.getAuthTag());
  decipher.setAutoPadding();
  decipher.update(encrypted);
  decipher.final();

  assert.throws(
    () => decipher.setAAD(aadbuf),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation setAAD'
    });

  assert.throws(
    () => decipher.setAuthTag(cipher.getAuthTag()),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation setAuthTag'
    });

  assert.throws(
    () => decipher.setAutoPadding(),
    {
      code: 'ERR_CRYPTO_INVALID_STATE',
      name: 'Error',
      message: 'Invalid state for operation setAutoPadding'
    }
  );
}
"
test/crypto/test-crypto-cipheriv-decipheriv.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

function testCipher1(key, iv) {
  return; // unsupport des-ebe3-cbc
  // Test encryption and decryption with explicit key and iv
  const plaintext =
          '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
          'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
          'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  ciph += cipher.final('hex');

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext,
                     `encryption/decryption with key ${key} and iv ${iv}`);

  // Streaming cipher interface
  // NB: In real life, it's not guaranteed that you can get all of it
  // in a single read() like this.  But in this case, we know it's
  // quite small, so there's no harm.
  const cStream = crypto.createCipheriv('des-ede3-cbc', key, iv);
  cStream.end(plaintext);
  ciph = cStream.read();

  const dStream = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  dStream.end(ciph);
  txt = dStream.read().toString('utf8');

  assert.strictEqual(txt, plaintext,
                     `streaming cipher with key ${key} and iv ${iv}`);
}


function testCipher2(key, iv) {
  return; // unsupport des-ebe3-cbc
  // Test encryption and decryption with explicit key and iv
  const plaintext =
          '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
          'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
          'jAfaFg**';
  const cipher = crypto.createCipheriv('des-ede3-cbc', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);

  const decipher = crypto.createDecipheriv('des-ede3-cbc', key, iv);
  let txt = decipher.update(ciph, 'buffer', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext,
                     `encryption/decryption with key ${key} and iv ${iv}`);
}


function testCipher3(key, iv) {
  return; // unsupport id-aes128-wrap
  // Test encryption and decryption with explicit key and iv.
  // AES Key Wrap test vector comes from RFC3394
  const plaintext = Buffer.from('00112233445566778899AABBCCDDEEFF', 'hex');

  const cipher = crypto.createCipheriv('id-aes128-wrap', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'buffer');
  ciph = Buffer.concat([ciph, cipher.final('buffer')]);
  const ciph2 = Buffer.from('1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5',
                            'hex');
  assert(ciph.equals(ciph2));
  const decipher = crypto.createDecipheriv('id-aes128-wrap', key, iv);
  let deciph = decipher.update(ciph, 'buffer');
  deciph = Buffer.concat([deciph, decipher.final()]);

  assert(deciph.equals(plaintext),
         `encryption/decryption with key ${key} and iv ${iv}`);
}

// copy from testCipher1 but used aes-128-gcm
function testCipher4(key, iv) {
  // Test encryption and decryption with explicit key and iv
  const plaintext =
          '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBGWWELw' +
          'eCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZUJ' +
          'jAfaFg**';
  
  const cipher = crypto.createCipheriv('aes-128-gcm', key, iv);
  let ciph = cipher.update(plaintext, 'utf8', 'hex');
  ciph += cipher.final('hex');
  let tag = cipher.getAuthTag();

  const decipher = crypto.createDecipheriv('aes-128-gcm', key, iv);
  decipher.setAuthTag(tag);
  let txt = decipher.update(ciph, 'hex', 'utf8');
  txt += decipher.final('utf8');

  assert.strictEqual(txt, plaintext,
                     `encryption/decryption with key ${key} and iv ${iv}`);
}

{
  const Cipheriv = crypto.Cipheriv;
  const key = '1234567890123456';
  const iv = '123456789012';

  const instance = Cipheriv('aes-128-gcm', key, iv);
  assert(instance instanceof Cipheriv, 'Cipheriv is expected to return a new ' +
                                       'instance when called without `new`');

  assert.throws(
    () => crypto.createCipheriv(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createCipheriv('aes-128-gcm', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createCipheriv('aes-128-gcm', key, 10),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

{
  const Decipheriv = crypto.Decipheriv;
  const key = '1234567890123456';
  const iv = '123456789012';

  const instance = Decipheriv('aes-128-gcm', key, iv);
  assert(instance instanceof Decipheriv, 'Decipheriv expected to return a new' +
                                         ' instance when called without `new`');

  assert.throws(
    () => crypto.createDecipheriv(null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""cipher"" argument must be of type string. ' +
               'Received null'
    });

  assert.throws(
    () => crypto.createDecipheriv('aes-128-gcm', null),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => crypto.createDecipheriv('aes-128-gcm', key, 10),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

testCipher4('0123456789abcdef', '0123456789ab');
testCipher4('0123456789abcdef', Buffer.from('0123456789ab'));
testCipher4(Buffer.from('0123456789abcdef'), '0123456789ab');
testCipher4(Buffer.from('0123456789abcdef'), Buffer.from('0123456789ab'));

/*
testCipher1('0123456789abcd0123456789', '12345678');
testCipher1('0123456789abcd0123456789', Buffer.from('12345678'));
testCipher1(Buffer.from('0123456789abcd0123456789'), '12345678');
testCipher1(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));
testCipher2(Buffer.from('0123456789abcd0123456789'), Buffer.from('12345678'));

if (!common.hasFipsCrypto) {
  testCipher3(Buffer.from('000102030405060708090A0B0C0D0E0F', 'hex'),
              Buffer.from('A6A6A6A6A6A6A6A6', 'hex'));
}

// Zero-sized IV or null should be accepted in ECB mode.
crypto.createCipheriv('aes-128-ecb', Buffer.alloc(16), Buffer.alloc(0));
crypto.createCipheriv('aes-128-ecb', Buffer.alloc(16), null);
*/
const errMessage = /Invalid initialization vector/;
/*
// But non-empty IVs should be rejected.
for (let n = 1; n < 256; n += 1) {
  assert.throws(
    () => crypto.createCipheriv('aes-128-ecb', Buffer.alloc(16),
                                Buffer.alloc(n)),
    errMessage);
}

// Correctly sized IV should be accepted in CBC mode.
crypto.createCipheriv('aes-128-cbc', Buffer.alloc(16), Buffer.alloc(16));

// But all other IV lengths should be rejected.
for (let n = 0; n < 256; n += 1) {
  if (n === 16) continue;
  assert.throws(
    () => crypto.createCipheriv('aes-128-cbc', Buffer.alloc(16),
                                Buffer.alloc(n)),
    errMessage);
}

// And so should null be.
assert.throws(() => {
  crypto.createCipheriv('aes-128-cbc', Buffer.alloc(16), null);
}, /Invalid initialization vector/);
*/
// Zero-sized IV should be rejected in GCM mode.
assert.throws(
  () => crypto.createCipheriv('aes-128-gcm', Buffer.alloc(16),
                              Buffer.alloc(0)),
  errMessage);

// But all other IV lengths should be accepted.
/* Unsupported
const minIvLength = common.hasOpenSSL3 ? 8 : 1;
const maxIvLength = common.hasOpenSSL3 ? 64 : 256;
for (let n = minIvLength; n < maxIvLength; n += 1) {
  if (common.hasFipsCrypto && n < 12) continue;
  crypto.createCipheriv('aes-128-gcm', Buffer.alloc(16), Buffer.alloc(n));
}*/

{
  // Passing an invalid cipher name should throw.
  assert.throws(
    () => crypto.createCipheriv('aes-127', Buffer.alloc(16), null),
    {
      name: 'Error',
      code: 'ERR_CRYPTO_UNKNOWN_CIPHER',
      message: 'Unknown cipher'
    });

  // Passing a key with an invalid length should throw.
  /*assert.throws(
    () => crypto.createCipheriv('aes-128-ecb', Buffer.alloc(17), null),
    /Invalid key length/);*/
}
"
test/fs/test-fs-opendir.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const testDir = tmpdir.path;
const files = ['empty', 'files', 'for', 'just', 'testing'];

const __filename = args[0];

// Make sure tmp directory is clean
tmpdir.refresh();

// Create the necessary files
files.forEach(function (filename) {
  fs.closeSync(fs.openSync(path.join(testDir, filename), 'w'));
});

function assertDirent(dirent) {
  assert(dirent instanceof fs.Dirent);
  assert.strictEqual(dirent.isFile(), true);
  assert.strictEqual(dirent.isDirectory(), false);
  assert.strictEqual(dirent.isSocket(), false);
  assert.strictEqual(dirent.isBlockDevice(), false);
  assert.strictEqual(dirent.isCharacterDevice(), false);
  assert.strictEqual(dirent.isFIFO(), false);
  assert.strictEqual(dirent.isSymbolicLink(), false);
}

const dirclosedError = {
  code: 'ERR_DIR_CLOSED'
};

const dirconcurrentError = {
  code: 'ERR_DIR_CONCURRENT_OPERATION'
};

const invalidCallbackObj = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
};

// Check the opendir Sync version
{
  const dir = fs.opendirSync(testDir);
  const entries = files.map(() => {
    const dirent = dir.readSync();
    assertDirent(dirent);
    return dirent.name;
  });
  assert.deepStrictEqual(files, entries.sort());

  // dir.read should return null when no more entries exist
  assert.strictEqual(dir.readSync(), null);

  // check .path
  assert.strictEqual(dir.path, testDir);

  dir.closeSync();

  assert.throws(() => dir.readSync(), dirclosedError);
  assert.throws(() => dir.closeSync(), dirclosedError);
}

// Check the opendir async version
fs.opendir(testDir, common.mustSucceed((dir) => {
  let sync = true;
  dir.read(common.mustSucceed((dirent) => {
    assert(!sync);

    // Order is operating / file system dependent
    assert(files.includes(dirent.name), `'files' should include ${dirent}`);
    assertDirent(dirent);

    let syncInner = true;
    dir.read(common.mustSucceed((dirent) => {
      assert(!syncInner);

      dir.close(common.mustSucceed());
    }));
    syncInner = false;
  }));
  sync = false;
}));

// opendir() on file should throw ENOTDIR
assert.throws(function () {
  fs.opendirSync(__filename);
}, /Error: ENOTDIR: not a directory/);

assert.throws(function () {
  fs.opendir(__filename);
}, /TypeError( \[ERR_INVALID_ARG_TYPE\])?: The ""callback"" argument must be of type function/);

fs.opendir(__filename, common.mustCall(function (e) {
  assert.strictEqual(e.code, 'ENOTDIR');
}));

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.opendir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.opendirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Promise-based tests
async function doPromiseTest() {
  // Check the opendir Promise version
  const dir = await fs.promises.opendir(testDir);
  const entries = [];

  let i = files.length;
  while (i--) {
    const dirent = await dir.read();
    entries.push(dirent.name);
    assertDirent(dirent);
  }

  assert.deepStrictEqual(files, entries.sort());

  // dir.read should return null when no more entries exist
  assert.strictEqual(await dir.read(), null);

  await dir.close();
}
doPromiseTest().then(common.mustCall());

// Async iterator
async function doAsyncIterTest() {
  const entries = [];
  for await (const dirent of await fs.promises.opendir(testDir)) {
    entries.push(dirent.name);
    assertDirent(dirent);
  }

  assert.deepStrictEqual(files, entries.sort());

  // Automatically closed during iterator
}
doAsyncIterTest().then(common.mustCall());

// Async iterators should do automatic cleanup

async function doAsyncIterBreakTest() {
  const dir = await fs.promises.opendir(testDir);
  for await (const dirent of dir) { // eslint-disable-line no-unused-vars
    break;
  }
  
  await assert.rejects(async () => dir.read(), dirclosedError);
}
doAsyncIterBreakTest().then(common.mustCall());

async function doAsyncIterReturnTest() {
  const dir = await fs.promises.opendir(testDir);
  await (async function () {
    for await (const dirent of dir) {
      return;
    }
  })();

  await assert.rejects(async () => dir.read(), dirclosedError);
}
doAsyncIterReturnTest().then(common.mustCall());

async function doAsyncIterThrowTest() {
  const dir = await fs.promises.opendir(testDir);
  try {
    for await (const dirent of dir) { // eslint-disable-line no-unused-vars
      throw new Error('oh no');
    }
  } catch (err) {
    if (err.message !== 'oh no') {
      throw err;
    }
  }

  await assert.rejects(async () => dir.read(), dirclosedError);
}
doAsyncIterThrowTest().then(common.mustCall());

// Check error thrown on invalid values of bufferSize
for (const bufferSize of [-1, 0, 0.5, 1.5, Infinity, NaN]) {
  assert.throws(
    () => fs.opendirSync(testDir, common.mustNotMutateObjectDeep({ bufferSize })),
    {
      code: 'ERR_OUT_OF_RANGE'
    });
}
for (const bufferSize of ['', '1', null]) {
  assert.throws(
    () => fs.opendirSync(testDir, common.mustNotMutateObjectDeep({ bufferSize })),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    });
}

// Check that passing a positive integer as bufferSize works
{
  const dir = fs.opendirSync(testDir, common.mustNotMutateObjectDeep({ bufferSize: 1024 }));
  assertDirent(dir.readSync());
  dir.close();
}

// Check that when passing a string instead of function - throw an exception
async function doAsyncIterInvalidCallbackTest() {
  const dir = await fs.promises.opendir(testDir);
  assert.throws(() => dir.close('not function'), invalidCallbackObj);
}
doAsyncIterInvalidCallbackTest().then(common.mustCall());

// Check first call to close() - should not report an error.
async function doAsyncIterDirClosedTest() {
  const dir = await fs.promises.opendir(testDir);
  await dir.close();
  await assert.rejects(() => dir.close(), dirclosedError);
}
doAsyncIterDirClosedTest().then(common.mustCall());

// Check that readSync() and closeSync() during read() throw exceptions
async function doConcurrentAsyncAndSyncOps() {
  const dir = await fs.promises.opendir(testDir);
  const promise = dir.read();

  assert.throws(() => dir.closeSync(), dirconcurrentError);
  assert.throws(() => dir.readSync(), dirconcurrentError);

  await promise;
  dir.closeSync();
}
doConcurrentAsyncAndSyncOps().then(common.mustCall());

// Check read throw exceptions on invalid callback
{
  const dir = fs.opendirSync(testDir);
  assert.throws(() => dir.read('INVALID_CALLBACK'), { code: /ERR_INVALID_ARG_TYPE/ });
}

// Check that concurrent read() operations don't do weird things.
async function doConcurrentAsyncOps() {
  const dir = await fs.promises.opendir(testDir);
  const promise1 = dir.read();
  const promise2 = dir.read();

  assertDirent(await promise1);
  assertDirent(await promise2);
  dir.closeSync();
}
doConcurrentAsyncOps().then(common.mustCall());

// Check that concurrent read() + close() operations don't do weird things.
async function doConcurrentAsyncMixedOps() {
  const dir = await fs.promises.opendir(testDir);
  const promise1 = dir.read();
  const promise2 = dir.close();

  assertDirent(await promise1);
  await promise2;
}
doConcurrentAsyncMixedOps().then(common.mustCall());

// Check if directory already closed - the callback should pass an error.
{
  const dir = fs.opendirSync(testDir);
  dir.closeSync();
  dir.close(common.mustCall((error) => {
    assert.strictEqual(error.code, dirclosedError.code);
  }));
}

// Check if directory already closed - throw an promise exception.
{
  const dir = fs.opendirSync(testDir);
  dir.closeSync();
  assert.rejects(dir.close(), dirclosedError).then(common.mustCall());
}
"
test/fs/test-fs-rmdir-recursive.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import { validateRmdirOptions } from 'internal/fs/utils';

common.expectWarning(
  'DeprecationWarning',
  'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
  'DEP0147'
);

tmpdir.refresh();

let count = 0;
const nextDirPath = (name = 'rmdir-recursive') =>
  path.join(tmpdir.path, `${name}-${count++}`);

function makeNonEmptyDirectory(depth, files, folders, dirname, createSymLinks) {
  fs.mkdirSync(dirname, { recursive: true });
  fs.writeFileSync(path.join(dirname, 'text.txt'), 'hello', 'utf8');

  const options = { flag: 'wx' };

  for (let f = files; f > 0; f--) {
    fs.writeFileSync(path.join(dirname, `f-${depth}-${f}`), '', options);
  }

  if (createSymLinks) {
    // Valid symlink
    fs.symlinkSync(
      `f-${depth}-1`,
      path.join(dirname, `link-${depth}-good`),
      'file'
    );

    // Invalid symlink
    fs.symlinkSync(
      'does-not-exist',
      path.join(dirname, `link-${depth}-bad`),
      'file'
    );
  }

  // File with a name that looks like a glob
  fs.writeFileSync(path.join(dirname, '[a-z0-9].txt'), '', options);

  depth--;
  if (depth <= 0) {
    return;
  }

  for (let f = folders; f > 0; f--) {
    fs.mkdirSync(
      path.join(dirname, `folder-${depth}-${f}`),
      { recursive: true }
    );
    makeNonEmptyDirectory(
      depth,
      files,
      folders,
      path.join(dirname, `d-${depth}-${f}`),
      createSymLinks
    );
  }
}

function removeAsync(dir) {
  // Removal should fail without the recursive option.
  fs.rmdir(dir, common.mustCall((err) => {
    assert.strictEqual(err.syscall, 'rmdir');

    // Removal should fail without the recursive option set to true.
    fs.rmdir(dir, { recursive: false }, common.mustCall((err) => {
      assert.strictEqual(err.syscall, 'rmdir');

      // Recursive removal should succeed.
      fs.rmdir(dir, { recursive: true }, common.mustSucceed(() => {
        // An error should occur if recursive and the directory does not exist.
        fs.rmdir(dir, { recursive: true }, common.mustCall((err) => {
          assert.strictEqual(err.code, 'ENOENT');
          // Attempted removal should fail now because the directory is gone.
          fs.rmdir(dir, common.mustCall((err) => {
            assert.strictEqual(err.syscall, 'rmdir');
          }));
        }));
      }));
    }));
  }));
}

// Test the asynchronous version
{
  // Create a 4-level folder hierarchy including symlinks
  let dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  removeAsync(dir);

  // Create a 2-level folder hierarchy without symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(dir);

  // Create a flat folder including symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(1, 10, 2, dir, true);
  removeAsync(dir);
}

// Test the synchronous version.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  assert.throws(() => {
    fs.rmdirSync(dir);
  }, { syscall: 'rmdir' });
  assert.throws(() => {
    fs.rmdirSync(dir, { recursive: false });
  }, { syscall: 'rmdir' });

  // Recursive removal should succeed.
  fs.rmdirSync(dir, { recursive: true });

  // An error should occur if recursive and the directory does not exist.
  assert.throws(() => fs.rmdirSync(dir, { recursive: true }),
                { code: 'ENOENT' });

  // Attempted removal should fail now because the directory is gone.
  assert.throws(() => fs.rmdirSync(dir), { syscall: 'rmdir' });
}

// Test the Promises based version.
(async () => {
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  await assert.rejects(fs.promises.rmdir(dir), { syscall: 'rmdir' });
  await assert.rejects(fs.promises.rmdir(dir, { recursive: false }), {
    syscall: 'rmdir'
  });

  // Recursive removal should succeed.
  await fs.promises.rmdir(dir, { recursive: true });

  // An error should occur if recursive and the directory does not exist.
  await assert.rejects(fs.promises.rmdir(dir, { recursive: true }),
                       { code: 'ENOENT' });

  // Attempted removal should fail now because the directory is gone.
  await assert.rejects(fs.promises.rmdir(dir), { syscall: 'rmdir' });
})().then(common.mustCall());

// Test input validation.
{
  const defaults = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false
  };
  const modified = {
    retryDelay: 953,
    maxRetries: 5,
    recursive: true
  };

  assert.deepStrictEqual(validateRmdirOptions(), defaults);
  assert.deepStrictEqual(validateRmdirOptions({}), defaults);
  assert.deepStrictEqual(validateRmdirOptions(modified), modified);
  assert.deepStrictEqual(validateRmdirOptions({
    maxRetries: 99
  }), {
    retryDelay: 100,
    maxRetries: 99,
    recursive: false
  });

  [null, 'foo', 5, NaN].forEach((bad) => {
    assert.throws(() => {
      validateRmdirOptions(bad);
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options"" argument must be of type object\./
    });
  });

  [undefined, null, 'foo', Infinity, function() {}].forEach((bad) => {
    assert.throws(() => {
      validateRmdirOptions({ recursive: bad });
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /^The ""options\.recursive"" property must be of type boolean\./
    });
  });

  assert.throws(() => {
    validateRmdirOptions({ retryDelay: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.retryDelay"" is out of range\./
  });

  assert.throws(() => {
    validateRmdirOptions({ maxRetries: -1 });
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: /^The value of ""options\.maxRetries"" is out of range\./
  });
}

// It should not pass recursive option to rmdirSync, when called from
// rimraf (see: #35566)
/*{
  // Make a non-empty directory:
  const original = fs.rmdirSync;
  const dir = `${nextDirPath()}/foo/bar`;
  fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(`${dir}/foo.txt`, 'hello world', 'utf8');

  // When called the second time from rimraf, the recursive option should
  // not be set for rmdirSync:
  let callCount = 0;
  let rmdirSyncOptionsFromRimraf;
  fs.rmdirSync = (path, options) => {
    if (callCount > 0) {
      rmdirSyncOptionsFromRimraf = { ...options };
    }
    callCount++;
    return original(path, options);
  };
  fs.rmdirSync(dir, { recursive: true });
  fs.rmdirSync = original;
  assert.strictEqual(rmdirSyncOptionsFromRimraf.recursive, undefined);
}*/
"
src/internal_module/wasi_nn/mod.rs,"mod generated;
use generated as wasi_nn;

use wasi_nn::NnErrno;

use crate::{register_class, Context, JsClassDef, JsClassTool, JsObject, JsValue};

#[derive(Debug, Clone, Copy)]
struct NnGraph(wasi_nn::Graph);
impl NnGraph {
    pub fn load(
        weights: &[&[u8]],
        encoding: wasi_nn::GraphEncoding,
        execution_target: wasi_nn::ExecutionTarget,
    ) -> Result<Self, NnErrno> {
        unsafe {
            let graph = wasi_nn::load(weights, encoding, execution_target)?;
            Ok(Self(graph))
        }
    }
}

struct NnContext {
    ctx: wasi_nn::GraphExecutionContext,
}

impl NnContext {
    pub fn init(graph: &NnGraph) -> Result<Self, NnErrno> {
        unsafe {
            Ok(NnContext {
                ctx: wasi_nn::init_execution_context(graph.0)?,
            })
        }
    }

    pub fn set_input(&mut self, index: u32, tensor: wasi_nn::Tensor) -> Result<(), NnErrno> {
        unsafe { wasi_nn::set_input(self.ctx, index, tensor) }
    }

    pub fn compute(&mut self) -> Result<(), NnErrno> {
        unsafe { wasi_nn::compute(self.ctx) }
    }

    pub fn get_output(&mut self, index: u32, output: &mut [u8]) -> Result<u32, NnErrno> {
        unsafe {
            let out_buffer = output.as_mut_ptr();
            let out_buffer_max_size = output.len();
            wasi_nn::get_output(self.ctx, index, out_buffer, out_buffer_max_size as u32)
        }
    }
}

impl JsClassDef for NnGraph {
    type RefType = NnGraph;

    const CLASS_NAME: &'static str = ""NnGraph"";

    const CONSTRUCTOR_ARGC: u8 = 3;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] = &[];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(
        ctx: &mut crate::Context,
        argv: &[crate::JsValue],
    ) -> Result<Self::RefType, crate::JsValue> {
        if let Some(
            [JsValue::Array(weights), JsValue::String(encoding), JsValue::String(execution_target)],
        ) = argv.get(0..3)
        {
            let weights = weights.to_vec().map_err(|e| JsValue::Exception(e))?;
            let mut weights_vec = Vec::with_capacity(weights.len());

            for weight in &weights {
                if let JsValue::ArrayBuffer(buffer) = weight {
                    weights_vec.push(buffer.as_ref());
                }
            }

            let encoding = match encoding.as_str() {
                ""openvino"" => wasi_nn::GRAPH_ENCODING_OPENVINO,
                ""onnx"" => wasi_nn::GRAPH_ENCODING_ONNX,
                ""pytorch"" => wasi_nn::GRAPH_ENCODING_PYTORCH,
                ""tensorflow"" => wasi_nn::GRAPH_ENCODING_TENSORFLOW,
                ""tensorflowlite"" | ""tensorflow_lite"" | ""tensorflow-lite"" => {
                    wasi_nn::GRAPH_ENCODING_TENSORFLOWLITE
                }
                _ => return Err(JsValue::UnDefined),
            };
            let execution_target = match execution_target.as_str() {
                ""cpu"" => wasi_nn::EXECUTION_TARGET_CPU,
                ""gpu"" => wasi_nn::EXECUTION_TARGET_GPU,
                ""tpu"" => wasi_nn::EXECUTION_TARGET_TPU,
                _ => return Err(JsValue::UnDefined),
            };
            NnGraph::load(&weights_vec, encoding, execution_target)
                .map_err(|e| ctx.throw_internal_type_error(e.message()).into())
        } else {
            Err(JsValue::UnDefined)
        }
    }
}

impl NnContext {
    fn js_set_input(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let index = if let Some(JsValue::Int(index)) = argv.get(0) {
            *index
        } else {
            return ctx.throw_type_error(""'index' must be of type int"").into();
        };

        let tensor_buf = if let Some(JsValue::ArrayBuffer(buf)) = argv.get(1) {
            buf.as_ref()
        } else {
            return ctx
                .throw_type_error(""'tensor_buf' must be of type buffer"")
                .into();
        };

        let dimensions = if let Some(JsValue::Array(arr)) = argv.get(2) {
            match arr.to_vec() {
                Ok(dimensions) => {
                    let mut dimension_arr = Vec::with_capacity(dimensions.len());

                    for i in dimensions {
                        let v = match i {
                            JsValue::Int(i) => i as u32,
                            JsValue::Float(i) => i as u32,
                            _ => {
                                return ctx
                                    .throw_type_error(""'dimensions' must be of type number array"")
                                    .into()
                            }
                        };
                        dimension_arr.push(v);
                    }
                    dimension_arr
                }
                Err(e) => return e.into(),
            }
        } else {
            return ctx
                .throw_type_error(""'dimensions' must be of type array"")
                .into();
        };

        let input_type = if let Some(JsValue::Int(input_type)) = argv.get(3) {
            let input_type = *input_type;
            match input_type {
                0 => wasi_nn::TENSOR_TYPE_F16,
                1 => wasi_nn::TENSOR_TYPE_F32,
                2 => wasi_nn::TENSOR_TYPE_U8,
                3 => wasi_nn::TENSOR_TYPE_I32,
                _ => {
                    return ctx
                        .throw_type_error(&format!(""undefined `input_type` {}"", input_type))
                        .into();
                }
            }
        } else {
            return ctx.throw_type_error(""'index' must be of type int"").into();
        };

        let tensor = wasi_nn::Tensor {
            dimensions: &dimensions,
            type_: input_type,
            data: tensor_buf,
        };

        if let Err(e) = self.set_input(index as u32, tensor) {
            return ctx.throw_internal_type_error(e.message()).into();
        } else {
            JsValue::UnDefined
        }
    }

    fn js_compute(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        if let Err(e) = self.compute() {
            ctx.throw_internal_type_error(e.message()).into()
        } else {
            JsValue::UnDefined
        }
    }

    fn js_get_output(
        &mut self,
        _this_obj: &mut JsObject,
        ctx: &mut Context,
        argv: &[JsValue],
    ) -> JsValue {
        let index = if let Some(JsValue::Int(index)) = argv.get(0) {
            *index
        } else {
            return ctx.throw_type_error(""'index' must be of type int"").into();
        };

        let mut output = if let Some(JsValue::ArrayBuffer(buf)) = argv.get(1) {
            buf.clone()
        } else {
            return ctx
                .throw_type_error(""'output' must be of type buffer"")
                .into();
        };

        match self.get_output(index as u32, output.as_mut()) {
            Ok(n) => JsValue::Int(n as i32),
            Err(e) => ctx.throw_internal_type_error(e.message()).into(),
        }
    }
}

impl JsClassDef for NnContext {
    type RefType = Self;

    const CLASS_NAME: &'static str = ""NnContext"";

    const CONSTRUCTOR_ARGC: u8 = 1;

    const FIELDS: &'static [crate::JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [crate::JsClassMethod<Self::RefType>] = &[
        (""setInput"", 4, Self::js_set_input),
        (""compute"", 0, Self::js_compute),
        (""getOutput"", 2, Self::js_get_output),
    ];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(
        ctx: &mut crate::Context,
        argv: &[JsValue],
    ) -> Result<Self::RefType, JsValue> {
        if let Some(graph) = argv.get(0) {
            if let Some(graph) = NnGraph::opaque(graph) {
                Self::init(graph).map_err(|e| ctx.throw_internal_type_error(e.message()).into())
            } else {
                return Err(ctx
                    .throw_type_error(""'graph' must be of type 'NnGraph'"")
                    .into());
            }
        } else {
            Err(JsValue::UnDefined)
        }
    }
}

pub fn init_module(ctx: &mut Context) {
    ctx.register_fn_module(
        ""wasi_nn\0"",
        &[
            NnGraph::CLASS_NAME,
            NnContext::CLASS_NAME,
            ""TENSOR_TYPE_F16"",
            ""TENSOR_TYPE_F32"",
            ""TENSOR_TYPE_U8"",
            ""TENSOR_TYPE_I32"",
        ],
        |ctx, m| {
            let class_ctor = register_class::<NnGraph>(ctx);
            m.add_export(NnGraph::CLASS_NAME, class_ctor);

            let class_ctor = register_class::<NnContext>(ctx);
            m.add_export(NnContext::CLASS_NAME, class_ctor);

            m.add_export(
                ""TENSOR_TYPE_F16"",
                JsValue::Int(wasi_nn::TENSOR_TYPE_F16.raw() as i32),
            );
            m.add_export(
                ""TENSOR_TYPE_F32"",
                JsValue::Int(wasi_nn::TENSOR_TYPE_F32.raw() as i32),
            );
            m.add_export(
                ""TENSOR_TYPE_U8"",
                JsValue::Int(wasi_nn::TENSOR_TYPE_U8.raw() as i32),
            );
            m.add_export(
                ""TENSOR_TYPE_I32"",
                JsValue::Int(wasi_nn::TENSOR_TYPE_I32.raw() as i32),
            );
        },
    )
}
"
modules/internal/streams/end-of-stream.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { AbortError, ERR_STREAM_PREMATURE_CLOSE } from ""../errors.js"";
import { once } from ""../util.js"";
import {
    validateAbortSignal,
    validateFunction,
    validateObject,
} from ""../validators.js"";

function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === ""function"";
}

function isServerResponse(stream) {
    return (
        typeof stream._sent100 === ""boolean"" &&
        typeof stream._removedConnection === ""boolean"" &&
        typeof stream._removedContLen === ""boolean"" &&
        typeof stream._removedTE === ""boolean"" &&
        typeof stream._closed === ""boolean""
    );
}


function isReadable(stream) {
    return typeof stream.readable === ""boolean"" ||
        typeof stream.readableEnded === ""boolean"" ||
        !!stream._readableState;
}

function isWritable(stream) {
    return typeof stream.writable === ""boolean"" ||
        typeof stream.writableEnded === ""boolean"" ||
        !!stream._writableState;
}

function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || (wState.ended && wState.length === 0);
}

const nop = () => { };

function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || (rState.ended && rState.length === 0);
}


export function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, ""options"");
    }
    validateFunction(callback, ""callback"");
    validateAbortSignal(options.signal, ""options.signal"");

    callback = once(callback);

    const readable = options.readable ||
        (options.readable !== false && isReadable(stream));
    const writable = options.writable ||
        (options.writable !== false && isWritable(stream));

    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;

    const onlegacyfinish = () => {
        if (!stream.writable) onfinish();
    };

    // TODO (ronag): Improve soft detection to include core modules and
    // common ecosystem modules that do properly emit 'close' but fail
    // this generic check.
    let willEmitClose = isServerResponse(stream) || (
        state &&
        state.autoDestroy &&
        state.emitClose &&
        state.closed === false &&
        isReadable(stream) === readable &&
        isWritable(stream) === writable
    );

    let writableFinished = stream.writableFinished ||
        (wState && wState.finished);
    const onfinish = () => {
        writableFinished = true;
        // Stream should not be destroyed here. If it is that
        // means that user space is doing something differently and
        // we cannot trust willEmitClose.
        if (stream.destroyed) willEmitClose = false;

        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };

    let readableEnded = stream.readableEnded ||
        (rState && rState.endEmitted);
    const onend = () => {
        readableEnded = true;
        // Stream should not be destroyed here. If it is that
        // means that user space is doing something differently and
        // we cannot trust willEmitClose.
        if (stream.destroyed) willEmitClose = false;

        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };

    const onerror = (err) => {
        callback.call(stream, err);
    };

    const onclose = () => {
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };

    const onrequest = () => {
        stream.req.on(""finish"", onfinish);
    };

    if (isRequest(stream)) {
        stream.on(""complete"", onfinish);
        if (!willEmitClose) {
            stream.on(""abort"", onclose);
        }
        if (stream.req) onrequest();
        else stream.on(""request"", onrequest);
    } else if (writable && !wState) { // legacy streams
        stream.on(""end"", onlegacyfinish);
        stream.on(""close"", onlegacyfinish);
    }

    // Not all streams will emit 'close' after 'aborted'.
    if (!willEmitClose && typeof stream.aborted === ""boolean"") {
        stream.on(""aborted"", onclose);
    }

    stream.on(""end"", onend);
    stream.on(""finish"", onfinish);
    if (options.error !== false) stream.on(""error"", onerror);
    stream.on(""close"", onclose);

    // _closed is for OutgoingMessage which is not a proper Writable.
    const closed = (!wState && !rState && stream._closed === true) || (
        (wState && wState.closed) ||
        (rState && rState.closed) ||
        (wState && wState.errorEmitted) ||
        (rState && rState.errorEmitted) ||
        (rState && stream.req && stream.aborted) ||
        (
            (!wState || !willEmitClose || typeof wState.closed !== ""boolean"") &&
            (!rState || !willEmitClose || typeof rState.closed !== ""boolean"") &&
            (!writable || (wState && wState.finished)) &&
            (!readable || (rState && rState.endEmitted))
        )
    );

    if (closed) {
        // TODO(ronag): Re-throw error if errorEmitted?
        // TODO(ronag): Throw premature close as if finished was called?
        // before being closed? i.e. if closed but not errored, ended or finished.
        // TODO(ronag): Throw some kind of error? Does it make sense
        // to call finished() on a ""finished"" stream?
        // TODO(ronag): willEmitClose?
        nextTick(() => {
            callback();
        });
    }

    const cleanup = () => {
        callback = nop;
        stream.removeListener(""aborted"", onclose);
        stream.removeListener(""complete"", onfinish);
        stream.removeListener(""abort"", onclose);
        stream.removeListener(""request"", onrequest);
        if (stream.req) stream.req.removeListener(""finish"", onfinish);
        stream.removeListener(""end"", onlegacyfinish);
        stream.removeListener(""close"", onlegacyfinish);
        stream.removeListener(""finish"", onfinish);
        stream.removeListener(""end"", onend);
        stream.removeListener(""error"", onerror);
        stream.removeListener(""close"", onclose);
    };

    if (options.signal && !closed) {
        const abort = () => {
            // Keep it because cleanup removes it.
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args) => {
                options.signal.removeEventListener(""abort"", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener(""abort"", abort);
        }
    }

    return cleanup;
}

export default eos;
"
test/fs/test-fs-utimes.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import { inspect } from '../../modules/internal/util/inspect';
import fs from 'fs';
import url from 'url';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const lpath = `${tmpdir.path}/symlink`;
fs.symlinkSync('unoent-entry', lpath);

function stat_resource(resource, statSync = fs.statSync) {
  if (typeof resource === 'string') {
    return statSync(resource);
  }
  const stats = fs.fstatSync(resource);
  // Ensure mtime has been written to disk
  // except for directories on AIX where it cannot be synced
  if (common.isAIX && stats.isDirectory())
    return stats;
  fs.fsyncSync(resource);
  return fs.fstatSync(resource);
}

function check_mtime(resource, mtime, statSync) {
  mtime = mtime.getTime();
  const stats = stat_resource(resource, statSync);
  const real_mtime = stats.mtime.getTime();
  return mtime - real_mtime;
}

function expect_errno(syscall, resource, err, errno) {
  assert(
    err && (err.code === errno || err.code === 'ENOSYS'),
    `FAILED: expect_errno ${inspect(arguments)}`
  );
}

function expect_ok(syscall, resource, err, atime, mtime, statSync) {
  const mtime_diff = check_mtime(resource, mtime, statSync);
  assert(
    // Check up to single-second precision.
    // Sub-second precision is OS and fs dependant.
    !err && (mtime_diff < 2) || err && err.code === 'ENOSYS',
    `FAILED: expect_ok ${inspect(arguments)}
     check_mtime: ${mtime_diff}`
  );
}

const stats = fs.statSync(tmpdir.path);

const asPath = (path) => path;
const asUrl = (path) => url.pathToFileURL(path);

const cases = [
  //[asPath, new Date('1982-09-10 13:37')],
  [asPath, new Date()],
  [asPath, 123456.789],
  [asPath, stats.mtime],
  [asPath, '123456'], // [asPath, '123456', -1], nodejs api doc didn't indicate how to deal with -1
  [asPath, new Date('2017-04-08T17:59:38.008Z')],
  [asUrl, new Date()],
];

runTests(cases.values());

function runTests(iter) {
  const { value, done } = iter.next();
  if (done) return;

  // Support easy setting same or different atime / mtime values.
  const [pathType, atime, mtime = atime] = value;

  let fd;
  //
  // test async code paths
  //
  fs.utimes(pathType(tmpdir.path), atime, mtime, common.mustCall((err) => {
    expect_ok('utimes', tmpdir.path, err, atime, mtime);

    fs.lutimes(pathType(lpath), atime, mtime, common.mustCall((err) => {
      expect_ok('lutimes', lpath, err, atime, mtime, fs.lstatSync);

      fs.utimes(pathType('foobarbaz'), atime, mtime, common.mustCall((err) => {
        expect_errno('utimes', 'foobarbaz', err, 'ENOENT');

        // don't close this fd
        if (common.isWindows) {
          fd = fs.openSync(tmpdir.path, 'r+');
        } else {
          fd = fs.openSync(tmpdir.path, 'r');
        }

        fs.futimes(fd, atime, mtime, common.mustCall((err) => {
          expect_ok('futimes', fd, err, atime, mtime);

          syncTests();

          setImmediate(common.mustCall(runTests), iter);
        }));
      }));
    }));
  }));

  //
  // test synchronized code paths, these functions throw on failure
  //
  function syncTests() {
    fs.utimesSync(pathType(tmpdir.path), atime, mtime);
    expect_ok('utimesSync', tmpdir.path, undefined, atime, mtime);

    fs.lutimesSync(pathType(lpath), atime, mtime);
    expect_ok('lutimesSync', lpath, undefined, atime, mtime, fs.lstatSync);

    // Some systems don't have futimes
    // if there's an error, it should be ENOSYS
    try {
      fs.futimesSync(fd, atime, mtime);
      expect_ok('futimesSync', fd, undefined, atime, mtime);
    } catch (ex) {
      expect_errno('futimesSync', fd, ex, 'ENOSYS');
    }

    let err;
    try {
      fs.utimesSync(pathType('foobarbaz'), atime, mtime);
    } catch (ex) {
      err = ex;
    }
    expect_errno('utimesSync', 'foobarbaz', err, 'ENOENT');

    err = undefined;
  }
}

const expectTypeError = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
};
// utimes-only error cases
{
  assert.throws(
    () => fs.utimes(0, new Date(), new Date(), common.mustNotCall()),
    expectTypeError
  );
  assert.throws(
    () => fs.utimesSync(0, new Date(), new Date()),
    expectTypeError
  );
}

// shared error cases
[false, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.utimes(i, new Date(), new Date(), common.mustNotCall()),
    expectTypeError
  );
  assert.throws(
    () => fs.utimesSync(i, new Date(), new Date()),
    expectTypeError
  );
  assert.throws(
    () => fs.futimes(i, new Date(), new Date(), common.mustNotCall()),
    expectTypeError
  );
  assert.throws(
    () => fs.futimesSync(i, new Date(), new Date()),
    expectTypeError
  );
});

const expectRangeError = {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""fd"" is out of range. ' +
           'It must be an integer >= 0 && <= 2147483647. Received -1'
};
// futimes-only error cases
{
  assert.throws(
    () => fs.futimes(-1, new Date(), new Date(), common.mustNotCall()),
    expectRangeError
  );
  assert.throws(
    () => fs.futimesSync(-1, new Date(), new Date()),
    expectRangeError
  );
}
"
modules/internal/util/types.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
//
// Adapted from Node.js. Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const _toString = Object.prototype.toString;

const _isObjectLike = (value) =>
    value !== null && typeof value === ""object"";

const _isFunctionLike = (value) =>
    value !== null && typeof value === ""function"";

export function isAnyArrayBuffer(value) {
    return (
        _isObjectLike(value) &&
        (_toString.call(value) === ""[object ArrayBuffer]"" ||
            _toString.call(value) === ""[object SharedArrayBuffer]"")
    );
}

export function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Arguments]"";
}

export function isArrayBuffer(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object ArrayBuffer]""
    );
}

export function isAsyncFunction(value) {
    return (
        _isFunctionLike(value) && _toString.call(value) === ""[object AsyncFunction]""
    );
}

export function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Boolean]"";
}

export function isBoxedPrimitive(value) {
    return (
        isBooleanObject(value) ||
        isStringObject(value) ||
        isNumberObject(value) ||
        isSymbolObject(value) ||
        isBigIntObject(value)
    );
}

export function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object DataView]"";
}

export function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Date]"";
}

export function isGeneratorFunction(value) {
    return (
        _isFunctionLike(value) &&
        _toString.call(value) === ""[object GeneratorFunction]""
    );
}

export function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Generator]"";
}

export function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Map]"";
}

export function isMapIterator(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Map Iterator]""
    );
}

export function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Module]"";
}

export function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Error]"";
}

export function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Number]"";
}

export function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object BigInt]"";
}

export function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Promise]"";
}

export function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object RegExp]"";
}

export function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Set]"";
}

export function isSetIterator(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Set Iterator]""
    );
}

export function isSharedArrayBuffer(value) {
    return (
        _isObjectLike(value) &&
        _toString.call(value) === ""[object SharedArrayBuffer]""
    );
}

export function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object String]"";
}

export function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Symbol]"";
}

export function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object WeakMap]"";
}

export function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object WeakSet]"";
}

export function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}

export function isBigInt64Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object BigInt64Array]""
    );
}

export function isBigUint64Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object BigUint64Array]""
    );
}

export function isFloat32Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Float32Array]""
    );
}

export function isFloat64Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Float64Array]""
    );
}

export function isInt8Array(value) {
    return _isObjectLike(value) && _toString.call(value) === ""[object Int8Array]"";
}

export function isInt16Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Int16Array]""
    );
}

export function isInt32Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Int32Array]""
    );
}

// Adapted from Lodash
export function isTypedArray(value) {
    /** Used to match `toStringTag` values of typed arrays. */
    const reTypedTag =
        /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike(value) && reTypedTag.test(_toString.call(value));
}

export function isUint8Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Uint8Array]""
    );
}

export function isUint8ClampedArray(value) {
    return (
        _isObjectLike(value) &&
        _toString.call(value) === ""[object Uint8ClampedArray]""
    );
}

export function isUint16Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Uint16Array]""
    );
}

export function isUint32Array(value) {
    return (
        _isObjectLike(value) && _toString.call(value) === ""[object Uint32Array]""
    );
}"
modules/process.js,"function unimplemented(name) {
  throw new Error('Node.js process ' + name + ' is not supported');
}

var title = 'wasmedge_quickjs';
var arch = 'wasm';
var platform = 'wasi';
var env = globalThis.env;
var argv = globalThis.argv || globalThis.args;
var execArgv = [];
var version = 'v16.8.0';
var versions = {};

var emitWarning = function (message, type) {
  console.warn((type ? (type + ': ') : '') + message);
};

var binding = function (name) { unimplemented('binding'); };

var umask = function (mask) { return 0; };

var cwd = function () { return './'; };
var chdir = function (dir) { unimplemented('chdir'); };

var release = {
  name: 'wasmedge_quickjs',
  sourceUrl: '',
  headersUrl: '',
  libUrl: '',
};

function noop() { }

var _rawDebug = noop;
var moduleLoadList = [];
function _linkedBinding(name) { unimplemented('_linkedBinding'); }
var domain = {};
var _exiting = false;
var config = {};
function dlopen(name) { unimplemented('dlopen'); }
function _getActiveRequests() { return []; }
function _getActiveHandles() { return []; }
var reallyExit = noop;
var _kill = noop;
var cpuUsage = function () { return {}; };
var resourceUsage = cpuUsage;
var memoryUsage = cpuUsage;
var kill = noop;
var exit = globalThis.exit;
var openStdin = noop;
var allowedNodeEnvironmentFlags = {};
function assert(condition, message) {
  if (!condition) { throw new Error(message || 'assertion error'); }
}
var features = {
  inspector: false,
  debug: false,
  uv: false,
  ipv6: false,
  tls_alpn: false,
  tls_sni: false,
  tls_ocsp: false,
  tls: false,
  cached_builtins: true,
};
var _fatalExceptions = noop;
var setUncaughtExceptionCaptureCallback = noop;
function hasUncaughtExceptionCaptureCallback() { return false; } var _tickCallback = noop;
var _debugProcess = noop;
var _debugEnd = noop;
var _startProfilerIdleNotifier = noop;
var _stopProfilerIdleNotifier = noop;
var stdout = undefined;
var stderr = undefined;
var stdin = undefined;
var abort = noop;
var pid = 2;
var ppid = 1;
var execPath = 'wasmedge-quickjs';
var debugPort = 9229;
var argv0 = 'wasmedge-quickjs';
var _preload_modules = [];
var setSourceMapsEnabled = noop;

var _performance = {
  now: undefined,
  timing: undefined,
};
if (_performance.now === undefined) {
  var nowOffset = Date.now();

  if (_performance.timing && _performance.timing.navigationStart) {
    nowOffset = _performance.timing.navigationStart;
  }
  _performance.now = function () { return Date.now() - nowOffset; };
}

function uptime() {
  return _performance.now() / 1000;
}

var nanoPerSec = 1000000000;
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor((clocktime % 1) * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}

hrtime.bigint = function (time) {
  var diff = hrtime(time);
  if (typeof BigInt === 'undefined') {
    return diff[0] * nanoPerSec + diff[1];
  }
  return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
};

var _maxListeners = 10;
var _events = {};
var _eventsCount = 0;
function on() { return process } var addListener = on;
var once = on;
var off = on;
var removeListener = on;
var removeAllListeners = on;
var emit = noop;
var prependListener = on;
var prependOnceListener = on;
function listeners(name) { return []; }
var process = {
  version: version,
  versions: versions,
  arch: arch,
  platform: platform,
  release: release,
  _rawDebug: _rawDebug,
  moduleLoadList: moduleLoadList,
  binding: binding,
  _linkedBinding: _linkedBinding,
  _events: _events,
  _eventsCount: _eventsCount,
  _maxListeners: _maxListeners,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  prependListener: prependListener,
  prependOnceListener: prependOnceListener,
  listeners: listeners,
  domain: domain,
  _exiting: _exiting,
  config: config,
  dlopen: dlopen,
  uptime: uptime,
  _getActiveRequests: _getActiveRequests,
  _getActiveHandles: _getActiveHandles,
  reallyExit: reallyExit,
  _kill: _kill,
  cpuUsage: cpuUsage,
  resourceUsage: resourceUsage,
  memoryUsage: memoryUsage,
  kill: kill,
  exit: exit,
  openStdin: openStdin,
  allowedNodeEnvironmentFlags: allowedNodeEnvironmentFlags,
  assert: assert,
  features: features,
  _fatalExceptions: _fatalExceptions,
  setUncaughtExceptionCaptureCallback: setUncaughtExceptionCaptureCallback,
  hasUncaughtExceptionCaptureCallback: hasUncaughtExceptionCaptureCallback,
  emitWarning: emitWarning,
  nextTick: globalThis.nextTick,
  _tickCallback: _tickCallback,
  _debugProcess: _debugProcess,
  _debugEnd: _debugEnd,
  _startProfilerIdleNotifier: _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier: _stopProfilerIdleNotifier,
  stdout: stdout,
  stdin: stdin,
  stderr: stderr,
  abort: abort,
  umask: umask,
  chdir: chdir,
  cwd: cwd,
  env: env,
  title: title,
  argv: argv,
  execArgv: execArgv,
  pid: pid,
  ppid: ppid,
  execPath: execPath,
  debugPort: debugPort,
  hrtime: hrtime,
  argv0: argv0,
  _preload_modules: _preload_modules,
  setSourceMapsEnabled: setSourceMapsEnabled,
};

const nextTick = globalThis.nextTick;

export { _debugEnd, _debugProcess, _events, _eventsCount, _exiting, _fatalExceptions, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _maxListeners, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, assert, binding, chdir, config, cpuUsage, cwd, debugPort, process as default, dlopen, domain, emit, emitWarning, env, execArgv, execPath, exit, features, hasUncaughtExceptionCaptureCallback, hrtime, kill, listeners, memoryUsage, moduleLoadList, nextTick, off, on, once, openStdin, pid, platform, ppid, prependListener, prependOnceListener, reallyExit, release, removeAllListeners, removeListener, resourceUsage, setSourceMapsEnabled, setUncaughtExceptionCaptureCallback, stderr, stdin, stdout, title, umask, uptime, version, versions };
"
test/crypto/test-crypto-hash.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from'../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert  from 'assert';
import crypto from 'crypto';
import fs from 'fs';

import fixtures from '../common/fixtures';

let cryptoType;
let digest;

// Test hashing
//const a1 = crypto.createHash('sha1').update('Test123').digest('hex');
const a2 = crypto.createHash('sha256').update('Test123').digest('base64');
const a3 = crypto.createHash('sha512').update('Test123').digest(); // buffer
//const a4 = crypto.createHash('sha1').update('Test123').digest('buffer');

// stream interface
let a5 = crypto.createHash('sha512');
a5.end('Test123');
a5 = a5.read();

let a6 = crypto.createHash('sha512');
a6.write('Te');
a6.write('st');
a6.write('123');
a6.end();
a6 = a6.read();

let a7 = crypto.createHash('sha512');
a7.end();
a7 = a7.read();

let a8 = crypto.createHash('sha512');
a8.write('');
a8.end();
a8 = a8.read();
/*
if (!common.hasFipsCrypto) {
  cryptoType = 'md5';
  digest = 'latin1';
  const a0 = crypto.createHash(cryptoType).update('Test123').digest(digest);
  assert.strictEqual(
    a0,
    'h\u00ea\u00cb\u0097\u00d8o\fF!\u00fa+\u000e\u0017\u00ca\u00bd\u008c',
    `${cryptoType} with ${digest} digest failed to evaluate to expected hash`
  );
}
cryptoType = 'md5';
digest = 'hex';
assert.strictEqual(
  a1,
  '8308651804facb7b9af8ffc53a33a22d6a1c8ac2',
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`);*/
cryptoType = 'sha256';
digest = 'base64';
assert.strictEqual(
  a2,
  '2bX1jws4GYKTlxhloUB09Z66PoJZW+y+hq5R8dnx9l4=',
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`);
cryptoType = 'sha512';
digest = 'latin1';
assert.deepStrictEqual(
  a3,
  Buffer.from(
    '\u00c1(4\u00f1\u0003\u001fd\u0097!O\'\u00d4C/&Qz\u00d4' +
    '\u0094\u0015l\u00b8\u008dQ+\u00db\u001d\u00c4\u00b5}\u00b2' +
    '\u00d6\u0092\u00a3\u00df\u00a2i\u00a1\u009b\n\n*\u000f' +
    '\u00d7\u00d6\u00a2\u00a8\u0085\u00e3<\u0083\u009c\u0093' +
    '\u00c2\u0006\u00da0\u00a1\u00879(G\u00ed\'',
    'latin1'),
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`);
/*cryptoType = 'sha1';
digest = 'hex';
assert.deepStrictEqual(
  a4,
  Buffer.from('8308651804facb7b9af8ffc53a33a22d6a1c8ac2', 'hex'),
  `${cryptoType} with ${digest} digest failed to evaluate to expected hash`
);*/

// Stream interface should produce the same result.
assert.deepStrictEqual(a5, a3);
assert.deepStrictEqual(a6, a3);
assert.notStrictEqual(a7, undefined);
assert.notStrictEqual(a8, undefined);

// Test multiple updates to same hash
/*const h1 = crypto.createHash('sha1').update('Test123').digest('hex');
const h2 = crypto.createHash('sha1').update('Test').update('123').digest('hex');
assert.strictEqual(h1, h2);*/

// Test hashing for binary files
/*const fn = fixtures.path('sample.png');
const sha1Hash = crypto.createHash('sha1');
const fileStream = fs.createReadStream(fn);
fileStream.on('data', function(data) {
  sha1Hash.update(data);
});
fileStream.on('close', common.mustCall(function() {
  // Test SHA1 of sample.png
  assert.strictEqual(sha1Hash.digest('hex'),
                     '22723e553129a336ad96e10f6aecdf0f45e4149e');
}));*/

// Issue https://github.com/nodejs/node-v0.x-archive/issues/2227: unknown digest
// method should throw an error.
assert.throws(function() {
  crypto.createHash('xyzzy');
}, /Digest method not supported/);

// Issue https://github.com/nodejs/node/issues/9819: throwing encoding used to
// segfault.
assert.throws(
  () => crypto.createHash('sha256').digest({
    toString: () => { throw new Error('boom'); },
  }),
  {
    name: 'Error',
    message: 'boom'
  });

// Issue https://github.com/nodejs/node/issues/25487: error message for invalid
// arg type to update method should include all possible types
assert.throws(
  () => crypto.createHash('sha256').update(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });

// Default UTF-8 encoding
const hutf8 = crypto.createHash('sha512').update('-8 text').digest('hex');
assert.strictEqual(
  hutf8,
  '4b21bbd1a68e690a730ddcb5a8bc94ead9879ffe82580767ad7ec6fa8ba2dea6' +
        '43a821af66afa9a45b6a78c712fecf0e56dc7f43aef4bcfc8eb5b4d8dca6ea5b');

assert.notStrictEqual(
  hutf8,
  crypto.createHash('sha512').update('-8 text', 'latin1').digest('hex'));

const h3 = crypto.createHash('sha256');
h3.digest();

assert.throws(
  () => h3.digest(),
  {
    code: 'ERR_CRYPTO_HASH_FINALIZED',
    name: 'Error'
  });

assert.throws(
  () => h3.update('foo'),
  {
    code: 'ERR_CRYPTO_HASH_FINALIZED',
    name: 'Error'
  });

assert.strictEqual(
  crypto.createHash('sha256').update('test').digest('ucs2'),
  crypto.createHash('sha256').update('test').digest().toString('ucs2'));

assert.throws(
  () => crypto.createHash(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""algorithm"" argument must be of type string. ' +
             'Received undefined'
  }
);

{
  const Hash = crypto.Hash;
  const instance = crypto.Hash('sha256');
  assert(instance instanceof Hash, 'Hash is expected to return a new instance' +
                                   ' when called without `new`');
}

// Test XOF hash functions and the outputLength option.
{
  // Default outputLengths.
  /*assert.strictEqual(crypto.createHash('shake128').digest('hex'),
                     '7f9c2ba4e88f827d616045507605853e');
  assert.strictEqual(crypto.createHash('shake128', null).digest('hex'),
                     '7f9c2ba4e88f827d616045507605853e');
  assert.strictEqual(crypto.createHash('shake256').digest('hex'),
                     '46b9dd2b0ba88d13233b3feb743eeb24' +
                     '3fcd52ea62b81b82b50c27646ed5762f');
  assert.strictEqual(crypto.createHash('shake256', { outputLength: 0 })
                           .copy()  // Default outputLength.
                           .digest('hex'),
                     '46b9dd2b0ba88d13233b3feb743eeb24' +
                     '3fcd52ea62b81b82b50c27646ed5762f');

  // Short outputLengths.
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 0 })
                           .digest('hex'),
                     '');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 5 })
                           .copy({ outputLength: 0 })
                           .digest('hex'),
                     '');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 5 })
                           .digest('hex'),
                     '7f9c2ba4e8');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 0 })
                           .copy({ outputLength: 5 })
                           .digest('hex'),
                     '7f9c2ba4e8');
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 15 })
                           .digest('hex'),
                     '7f9c2ba4e88f827d61604550760585');
  assert.strictEqual(crypto.createHash('shake256', { outputLength: 16 })
                           .digest('hex'),
                     '46b9dd2b0ba88d13233b3feb743eeb24');

  // Large outputLengths.
  assert.strictEqual(crypto.createHash('shake128', { outputLength: 128 })
                           .digest('hex'),
                     '7f9c2ba4e88f827d616045507605853e' +
                     'd73b8093f6efbc88eb1a6eacfa66ef26' +
                     '3cb1eea988004b93103cfb0aeefd2a68' +
                     '6e01fa4a58e8a3639ca8a1e3f9ae57e2' +
                     '35b8cc873c23dc62b8d260169afa2f75' +
                     'ab916a58d974918835d25e6a435085b2' +
                     'badfd6dfaac359a5efbb7bcc4b59d538' +
                     'df9a04302e10c8bc1cbf1a0b3a5120ea');
  const superLongHash = crypto.createHash('shake256', {
    outputLength: 1024 * 1024
  }).update('The message is shorter than the hash!')
    .digest('hex');
  assert.strictEqual(superLongHash.length, 2 * 1024 * 1024);
  assert.ok(superLongHash.endsWith('193414035ddba77bf7bba97981e656ec'));
  assert.ok(superLongHash.startsWith('a2a28dbc49cfd6e5d6ceea3d03e77748'));

  // Non-XOF hash functions should accept valid outputLength options as well.
  assert.strictEqual(crypto.createHash('sha224', { outputLength: 28 })
                           .digest('hex'),
                     'd14a028c2a3a2bc9476102bb288234c4' +
                     '15a2b01f828ea62ac5b3e42f');
  
  // Passing invalid sizes should throw during creation.
  assert.throws(() => {
    crypto.createHash('sha256', { outputLength: 28 });
  }, {
    code: 'ERR_OSSL_EVP_NOT_XOF_OR_INVALID_LENGTH'
  });*/

  for (const outputLength of [null, {}, 'foo', false]) {
    assert.throws(() => crypto.createHash('sha256', { outputLength }),
                  { code: 'ERR_INVALID_ARG_TYPE' });
  }

  for (const outputLength of [-1, .5, Infinity, 2 ** 90]) {
    assert.throws(() => crypto.createHash('sha256', { outputLength }),
                  { code: 'ERR_OUT_OF_RANGE' });
  }
}

{
  const h = crypto.createHash('sha512');
  h.digest();
  assert.throws(() => h.copy(), { code: 'ERR_CRYPTO_HASH_FINALIZED' });
  assert.throws(() => h.digest(), { code: 'ERR_CRYPTO_HASH_FINALIZED' });
}

{
  const a = crypto.createHash('sha512').update('abc');
  const b = a.copy();
  const c = b.copy().update('def');
  const d = crypto.createHash('sha512').update('abcdef');
  assert.strictEqual(a.digest('hex'), b.digest('hex'));
  assert.strictEqual(c.digest('hex'), d.digest('hex'));
}
"
test/fs/test-fs-write.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Flags: --expose_externalize_string
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const fn = path.join(tmpdir.path, 'write.txt');
const fn2 = path.join(tmpdir.path, 'write2.txt');
const fn3 = path.join(tmpdir.path, 'write3.txt');
const fn4 = path.join(tmpdir.path, 'write4.txt');
const fn5 = path.join(tmpdir.path, 'write5.txt');
const expected = 'mlaut.';
const constants = fs.constants;
/*
const { externalizeString, isOneByteString } = global;

// Account for extra globals exposed by --expose_externalize_string.
common.allowGlobals(externalizeString, isOneByteString, global.x);

{
  const expected = 'mlaut sechzig';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), true);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'latin1');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'latin1'), expected);
}

{
  const expected = 'mlaut neunzig';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), true);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'utf8');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'utf8'), expected);
}

{
  const expected = 'Zhngwn 1';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), false);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'ucs2');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'ucs2'), expected);
}

{
  const expected = 'Zhngwn 2';  // Must be a unique string.
  externalizeString(expected);
  assert.strictEqual(isOneByteString(expected), false);
  const fd = fs.openSync(fn, 'w');
  fs.writeSync(fd, expected, 0, 'utf8');
  fs.closeSync(fd);
  assert.strictEqual(fs.readFileSync(fn, 'utf8'), expected);
}
*/
fs.open(fn, 'w', 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
    const found = fs.readFileSync(fn, 'utf8');
    fs.unlinkSync(fn);
    assert.strictEqual(found, expected);
  });

  const written = common.mustSucceed((written) => {
    assert.strictEqual(written, 0);
    fs.write(fd, expected, 0, 'utf8', done);
  });

  fs.write(fd, '', 0, 'utf8', written);
}));

const args = constants.O_CREAT | constants.O_WRONLY | constants.O_TRUNC;
fs.open(fn2, args, 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
    const found = fs.readFileSync(fn2, 'utf8');
    fs.unlinkSync(fn2);
    assert.strictEqual(found, expected);
  });

  const written = common.mustSucceed((written) => {
    assert.strictEqual(written, 0);
    fs.write(fd, expected, 0, 'utf8', done);
  });

  fs.write(fd, '', 0, 'utf8', written);
}));

fs.open(fn3, 'w', 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
  });

  fs.write(fd, expected, done);
}));

/* It's deprecated, so I don't decide to implement.
// Test write with an object with an own toString function
// Runtime deprecated by DEP0162
common.expectWarning('DeprecationWarning',
                     'Implicit coercion of objects with own toString property is deprecated.',
                     'DEP0162');
fs.open(fn4, 'w', 0o644, common.mustSucceed((fd) => {
  const done = common.mustSucceed((written) => {
    assert.strictEqual(written, Buffer.byteLength(expected));
    fs.closeSync(fd);
  });

  const data = {
    toString() { return expected; }
  };
  fs.write(fd, data, done);
}));
*/
[false, 'test', {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.write(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.writeSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

[
  false, 5, {}, [], null, undefined,
  new String('notPrimitive'),
  { [Symbol.toPrimitive]: (hint) => 'amObject' },
].forEach((data) => {
  assert.throws(
    () => fs.write(1, data, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""buffer""/
    }
  );
  assert.throws(
    () => fs.writeSync(1, data),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""buffer""/
    }
  );
});

{
  // Regression test for https://github.com/nodejs/node/issues/38168
  const fd = fs.openSync(fn5, 'w');

  assert.throws(
    () => fs.writeSync(fd, 'abc', 0, 'hex'),
    {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /'encoding' is invalid for data of length 3/
    }
  );

  assert.throws(
    () => fs.writeSync(fd, 'abc', 0, 'hex', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /'encoding' is invalid for data of length 3/
    }
  );

  assert.strictEqual(fs.writeSync(fd, 'abcd', 0, 'hex'), 2);

  fs.write(fd, 'abcd', 0, 'hex', common.mustSucceed((written) => {
    assert.strictEqual(written, 2);
    fs.closeSync(fd);
  }));
}
"
test/crypto/test-crypto-hkdf.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import { kMaxLength } from 'buffer';
import assert from 'assert';
import {
  createSecretKey,
  hkdf,
  hkdfSync,
  getHashes
} from 'crypto';

{
  assert.throws(() => hkdf(), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""digest"" argument must be of type string/
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf(i, 'a'), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""digest"" argument must be of type string/
    });
    assert.throws(() => hkdfSync(i, 'a'), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""digest"" argument must be of type string/
    });
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf('sha256', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""ikm"" argument must be /
    });
    assert.throws(() => hkdfSync('sha256', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""ikm"" argument must be /
    });
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf('sha256', 'secret', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""salt"" argument must be /
    });
    assert.throws(() => hkdfSync('sha256', 'secret', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""salt"" argument must be /
    });
  });

  [1, {}, [], false, Infinity].forEach((i) => {
    assert.throws(() => hkdf('sha256', 'secret', 'salt', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""info"" argument must be /
    });
    assert.throws(() => hkdfSync('sha256', 'secret', 'salt', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""info"" argument must be /
    });
  });

  ['test', {}, [], false].forEach((i) => {
    assert.throws(() => hkdf('sha256', 'secret', 'salt', 'info', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""length"" argument must be of type number/
    });
    assert.throws(() => hkdfSync('sha256', 'secret', 'salt', 'info', i), {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /^The ""length"" argument must be of type number/
    });
  });

  assert.throws(() => hkdf('sha256', 'secret', 'salt', 'info', -1), {
    code: 'ERR_OUT_OF_RANGE'
  });
  assert.throws(() => hkdfSync('sha256', 'secret', 'salt', 'info', -1), {
    code: 'ERR_OUT_OF_RANGE'
  });
  assert.throws(() => hkdf('sha256', 'secret', 'salt', 'info',
                           kMaxLength + 1), {
    code: 'ERR_OUT_OF_RANGE'
  });
  assert.throws(() => hkdfSync('sha256', 'secret', 'salt', 'info',
                               kMaxLength + 1), {
    code: 'ERR_OUT_OF_RANGE'
  });

  assert.throws(() => hkdfSync('unknown', 'a', '', '', 10), {
    code: 'ERR_CRYPTO_INVALID_DIGEST'
  });

  assert.throws(() => hkdf('unknown', 'a', '', '', 10, common.mustNotCall()), {
    code: 'ERR_CRYPTO_INVALID_DIGEST'
  });

  assert.throws(() => hkdf('unknown', 'a', '', Buffer.alloc(1025), 10,
                           common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE'
  });

  assert.throws(() => hkdfSync('unknown', 'a', '', Buffer.alloc(1025), 10), {
    code: 'ERR_OUT_OF_RANGE'
  });

  assert.throws(
    () => hkdf('sha512', 'a', '', '', 64 * 255 + 1, common.mustNotCall()), {
      code: 'ERR_CRYPTO_INVALID_KEYLEN'
    });

  assert.throws(
    () => hkdfSync('sha512', 'a', '', '', 64 * 255 + 1), {
      code: 'ERR_CRYPTO_INVALID_KEYLEN'
    });
}

const algorithms = [
  ['sha256', 'secret', 'salt', 'info', 10],
  ['sha256', '', '', '', 10],
  ['sha256', '', 'salt', '', 10],
  ['sha512', 'secret', 'salt', '', 15],
];
if (!common.hasOpenSSL3)
  algorithms.push(['whirlpool', 'secret', '', 'info', 20]);

algorithms.forEach(([ hash, secret, salt, info, length ]) => {
  {
    const syncResult = hkdfSync(hash, secret, salt, info, length);
    assert(syncResult instanceof ArrayBuffer);
    let is_async = false;
    hkdf(hash, secret, salt, info, length,
         common.mustSucceed((asyncResult) => {
           assert(is_async);
           assert(asyncResult instanceof ArrayBuffer);
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
    // Keep this after the hkdf call above. This verifies
    // that the callback is invoked asynchronously.
    is_async = true;
  }

  {
    const buf_secret = Buffer.from(secret);
    const buf_salt = Buffer.from(salt);
    const buf_info = Buffer.from(info);

    const syncResult = hkdfSync(hash, buf_secret, buf_salt, buf_info, length);
    hkdf(hash, buf_secret, buf_salt, buf_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const key_secret = createSecretKey(Buffer.from(secret));
    const buf_salt = Buffer.from(salt);
    const buf_info = Buffer.from(info);

    const syncResult = hkdfSync(hash, key_secret, buf_salt, buf_info, length);
    hkdf(hash, key_secret, buf_salt, buf_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const ta_secret = new Uint8Array(Buffer.from(secret));
    const ta_salt = new Uint16Array(Buffer.from(salt));
    const ta_info = new Uint32Array(Buffer.from(info));

    const syncResult = hkdfSync(hash, ta_secret, ta_salt, ta_info, length);
    hkdf(hash, ta_secret, ta_salt, ta_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const ta_secret = new Uint8Array(Buffer.from(secret));
    const ta_salt = new Uint16Array(Buffer.from(salt));
    const ta_info = new Uint32Array(Buffer.from(info));

    const syncResult = hkdfSync(
      hash,
      ta_secret.buffer,
      ta_salt.buffer,
      ta_info.buffer,
      length);
    hkdf(hash, ta_secret, ta_salt, ta_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }

  {
    const ta_secret = new Uint8Array(Buffer.from(secret));
    const sa_salt = new SharedArrayBuffer(0);
    const sa_info = new SharedArrayBuffer(1);

    const syncResult = hkdfSync(
      hash,
      ta_secret.buffer,
      sa_salt,
      sa_info,
      length);
    hkdf(hash, ta_secret, sa_salt, sa_info, length,
         common.mustSucceed((asyncResult) => {
           assert.deepStrictEqual(syncResult, asyncResult);
         }));
  }
});


if (!common.hasOpenSSL3) {
  const kKnownUnsupported = ['shake128', 'shake256'];
  getHashes()
    .filter((hash) => !kKnownUnsupported.includes(hash))
    .forEach((hash) => {
      assert(hkdfSync(hash, 'key', 'salt', 'info', 5));
    });
}
"
test/fs/test-fs-access.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';

// This tests that fs.access and fs.accessSync works as expected
// and the errors thrown from these APIs include the desired properties

import process from 'process';
import common from '../common';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import { internalBinding } from 'internal/test/binding';
const { UV_ENOENT } = internalBinding('uv');

import tmpdir from '../common/tmpdir';
const doesNotExist = path.join(tmpdir.path, '__this_should_not_exist');
const readOnlyFile = path.join(tmpdir.path, 'read_only_file');
const readWriteFile = path.join(tmpdir.path, 'read_write_file');

function createFileWithPerms(file, mode) {
  fs.writeFileSync(file, '');
  fs.chmodSync(file, mode);
}

tmpdir.refresh();
createFileWithPerms(readOnlyFile, 0o444);
createFileWithPerms(readWriteFile, 0o666);

// On non-Windows supported platforms, fs.access(readOnlyFile, W_OK, ...)
// always succeeds if node runs as the super user, which is sometimes the
// case for tests running on our continuous testing platform agents.
//
// In this case, this test tries to change its process user id to a
// non-superuser user so that the test that checks for write access to a
// read-only file can be more meaningful.
//
// The change of user id is done after creating the fixtures files for the same
// reason: the test may be run as the superuser within a directory in which
// only the superuser can create files, and thus it may need superuser
// privileges to create them.
//
// There's not really any point in resetting the process' user id to 0 after
// changing it to 'nobody', since in the case that the test runs without
// superuser privilege, it is not possible to change its process user id to
// superuser.
//
// It can prevent the test from removing files created before the change of user
// id, but that's fine. In this case, it is the responsibility of the
// continuous integration platform to take care of that.
let hasWriteAccessForReadonlyFile = false;

assert.strictEqual(typeof fs.F_OK, 'number');
assert.strictEqual(typeof fs.R_OK, 'number');
assert.strictEqual(typeof fs.W_OK, 'number');
assert.strictEqual(typeof fs.X_OK, 'number');

const throwNextTick = (e) => { process.nextTick(() => { throw e; }); };

let __filename = args[0];

fs.access(__filename, common.mustCall(function (...args) {
  assert.deepStrictEqual(args, [null]);
}));
fs.promises.access(__filename)
  .then(common.mustCall())
  .catch(throwNextTick);
fs.access(__filename, fs.R_OK, common.mustCall(function (...args) {
  assert.deepStrictEqual(args, [null]);
}));
fs.promises.access(__filename, fs.R_OK)
  .then(common.mustCall())
  .catch(throwNextTick);
fs.access(readOnlyFile, fs.R_OK, common.mustCall(function (...args) {
  assert.deepStrictEqual(args, [null]);
}));
fs.promises.access(readOnlyFile, fs.R_OK)
  .then(common.mustCall())
  .catch(throwNextTick);

{
  const expectedError = (err) => {
    assert.notStrictEqual(err, null);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.path, doesNotExist);
  };
  fs.access(doesNotExist, common.mustCall(expectedError));
  fs.promises.access(doesNotExist)
    .then(common.mustNotCall(), common.mustCall(expectedError))
    .catch(throwNextTick);
}
/* require chmod
{
  function expectedError(err) {
    assert.strictEqual(this, undefined);
    if (hasWriteAccessForReadonlyFile) {
      assert.ifError(err);
    } else {
      assert.notStrictEqual(err, null);
      assert.strictEqual(err.path, readOnlyFile);
    }
  }
  fs.access(readOnlyFile, fs.W_OK, common.mustCall(expectedError));
  fs.promises.access(readOnlyFile, fs.W_OK)
    .then(common.mustNotCall(), common.mustCall(expectedError))
    .catch(throwNextTick);
}
*/
{
  const expectedError = (err) => {
    assert.strictEqual(err.code, 'ERR_INVALID_ARG_TYPE');
    assert.ok(err instanceof TypeError);
    return true;
  };
  assert.throws(
    () => { fs.access(100, fs.F_OK, common.mustNotCall()); },
    expectedError
  );

  fs.promises.access(100, fs.F_OK)
    .then(common.mustNotCall(), common.mustCall(expectedError))
    .catch(throwNextTick);
}

assert.throws(
  () => {
    fs.access(__filename, fs.F_OK);
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.access(__filename, fs.F_OK, common.mustNotMutateObjectDeep({}));
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

// Regular access should not throw.
fs.accessSync(__filename);
const mode = fs.R_OK | fs.W_OK;
fs.accessSync(readWriteFile, mode);

// Invalid modes should throw.
[
  false,
  1n,
  { [Symbol.toPrimitive]() { return fs.R_OK; } },
  [1],
  'r',
].forEach((mode, i) => {
  console.log(mode, i);
  assert.throws(
    () => fs.access(readWriteFile, mode, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""mode"" argument.+integer/
    }
  );
  assert.throws(
    () => fs.accessSync(readWriteFile, mode),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /""mode"" argument.+integer/
    }
  );
});

// Out of range modes should throw
[
  -1,
  8,
  Infinity,
  NaN,
].forEach((mode, i) => {
  console.log(mode, i);
  assert.throws(
    () => fs.access(readWriteFile, mode, common.mustNotCall()),
    {
      code: 'ERR_OUT_OF_RANGE',
      message: /""mode"".+It must be an integer >= 0 && <= 7/
    }
  );
  assert.throws(
    () => fs.accessSync(readWriteFile, mode),
    {
      code: 'ERR_OUT_OF_RANGE',
      message: /""mode"".+It must be an integer >= 0 && <= 7/
    }
  );
});


assert.throws(
  () => { fs.accessSync(doesNotExist); },
  (err) => {
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.path, doesNotExist);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, access '${doesNotExist}'`
    );
    assert.strictEqual(err.constructor, Error);
    assert.strictEqual(err.syscall, 'access');
    assert.strictEqual(err.errno, UV_ENOENT);
    return true;
  }
);

assert.throws(
  () => { fs.accessSync(Buffer.from(doesNotExist)); },
  (err) => {
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.path, doesNotExist);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, access '${doesNotExist}'`
    );
    assert.strictEqual(err.constructor, Error);
    assert.strictEqual(err.syscall, 'access');
    assert.strictEqual(err.errno, UV_ENOENT);
    return true;
  }
);
"
modules/internal/streams/utils.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

const kIsDisturbed = Symbol(""kIsDisturbed"");

function isReadableNodeStream(obj) {
    return !!(
        obj &&
        typeof obj.pipe === ""function"" &&
        typeof obj.on === ""function"" &&
        (!obj._writableState || obj._readableState?.readable !== false) && // Duplex
        (!obj._writableState || obj._readableState) // Writable has .pipe.
    );
}

function isWritableNodeStream(obj) {
    return !!(
        obj &&
        typeof obj.write === ""function"" &&
        typeof obj.on === ""function"" &&
        (!obj._readableState || obj._writableState?.writable !== false) // Duplex
    );
}

function isDuplexNodeStream(obj) {
    return !!(
        obj &&
        (typeof obj.pipe === ""function"" && obj._readableState) &&
        typeof obj.on === ""function"" &&
        typeof obj.write === ""function""
    );
}

function isNodeStream(obj) {
    return (
        obj &&
        (
            obj._readableState ||
            obj._writableState ||
            (typeof obj.write === ""function"" && typeof obj.on === ""function"") ||
            (typeof obj.pipe === ""function"" && typeof obj.on === ""function"")
        )
    );
}

function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === ""function"";
    if (isAsync === false) return typeof obj[Symbol.iterator] === ""function"";
    return typeof obj[Symbol.asyncIterator] === ""function"" ||
        typeof obj[Symbol.iterator] === ""function"";
}

function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}

// Have been end():d.
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== ""boolean"") return null;
    return wState.ended;
}

// Have emitted 'finish'.
function isWritableFinished(stream, strict) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableFinished === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.finished !== ""boolean"") return null;
    return !!(
        wState.finished ||
        (strict === false && wState.ended === true && wState.length === 0)
    );
}

// Have been push(null):d.
function isReadableEnded(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== ""boolean"") return null;
    return rState.ended;
}

// Have emitted 'end'.
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== ""boolean"") return null;
    return !!(
        rState.endEmitted ||
        (strict === false && rState.ended === true && rState.length === 0)
    );
}

function isDisturbed(stream) {
    return !!(stream && (
        stream.readableDidRead ||
        stream.readableAborted ||
        stream[kIsDisturbed]
    ));
}

function isReadable(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== ""boolean"") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}

function isWritable(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== ""boolean"") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}

function isFinished(stream, opts) {
    if (!isNodeStream(stream)) {
        return null;
    }

    if (isDestroyed(stream)) {
        return true;
    }

    if (opts?.readable !== false && isReadable(stream)) {
        return false;
    }

    if (opts?.writable !== false && isWritable(stream)) {
        return false;
    }

    return true;
}

function isClosed(stream) {
    if (!isNodeStream(stream)) {
        return null;
    }

    const wState = stream._writableState;
    const rState = stream._readableState;

    if (
        typeof wState?.closed === ""boolean"" ||
        typeof rState?.closed === ""boolean""
    ) {
        return wState?.closed || rState?.closed;
    }

    if (typeof stream._closed === ""boolean"" && isOutgoingMessage(stream)) {
        return stream._closed;
    }

    return null;
}

function isOutgoingMessage(stream) {
    return (
        typeof stream._closed === ""boolean"" &&
        typeof stream._defaultKeepAlive === ""boolean"" &&
        typeof stream._removedConnection === ""boolean"" &&
        typeof stream._removedContLen === ""boolean""
    );
}

function isServerResponse(stream) {
    return (
        typeof stream._sent100 === ""boolean"" &&
        isOutgoingMessage(stream)
    );
}

function isServerRequest(stream) {
    return (
        typeof stream._consuming === ""boolean"" &&
        typeof stream._dumped === ""boolean"" &&
        stream.req?.upgradeOrConnect === undefined
    );
}

function willEmitClose(stream) {
    if (!isNodeStream(stream)) return null;

    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;

    return (!state && isServerResponse(stream)) || !!(
        state &&
        state.autoDestroy &&
        state.emitClose &&
        state.closed === false
    );
}

export default {
    isDisturbed,
    kIsDisturbed,
    isClosed,
    isDestroyed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isReadable,
    isReadableNodeStream,
    isReadableEnded,
    isReadableFinished,
    isNodeStream,
    isWritable,
    isWritableNodeStream,
    isWritableEnded,
    isWritableFinished,
    isServerRequest,
    isServerResponse,
    willEmitClose,
};
export {
    isClosed,
    isDestroyed,
    isDisturbed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isNodeStream,
    isReadable,
    isReadableEnded,
    isReadableFinished,
    isReadableNodeStream,
    isServerRequest,
    isServerResponse,
    isWritable,
    isWritableEnded,
    isWritableFinished,
    isWritableNodeStream,
    kIsDisturbed,
    willEmitClose,
};"
test/crypto/test-crypto-dh-stateless.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

assert.throws(() => crypto.diffieHellman(), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_TYPE',
  message: 'The ""options"" argument must be of type object. Received undefined'
});

assert.throws(() => crypto.diffieHellman(null), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_TYPE',
  message: 'The ""options"" argument must be of type object. Received null'
});

assert.throws(() => crypto.diffieHellman([]), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_TYPE',
  message:
    'The ""options"" argument must be of type object. ' +
    'Received an instance of Array',
});

function test({ publicKey: alicePublicKey, privateKey: alicePrivateKey },
              { publicKey: bobPublicKey, privateKey: bobPrivateKey },
              expectedValue) {
  const buf1 = crypto.diffieHellman({
    privateKey: alicePrivateKey,
    publicKey: bobPublicKey
  });
  const buf2 = crypto.diffieHellman({
    privateKey: bobPrivateKey,
    publicKey: alicePublicKey
  });
  assert.deepStrictEqual(buf1, buf2);

  if (expectedValue !== undefined)
    assert.deepStrictEqual(buf1, expectedValue);
}

const alicePrivateKey = crypto.createPrivateKey({
  key: '-----BEGIN PRIVATE KEY-----\n' +
       'MIIBoQIBADCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKL\n' +
       'gNwc0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVt\n' +
       'bVHCReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR\n' +
       '7ORbPcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkH\n' +
       'cJaWbWcMNU5KvJgE8XRsCMojcyf//////////wIBAgSBwwKBwEh82IAVnYNf0Kjb\n' +
       'qYSImDFyg9sH6CJ0GzRK05e6hM3dOSClFYi4kbA7Pr7zyfdn2SH6wSlNS14Jyrtt\n' +
       'HePrRSeYl1T+tk0AfrvaLmyM56F+9B3jwt/nzqr5YxmfVdXb2aQV53VS/mm3pB2H\n' +
       'iIt9FmvFaaOVe2DupqSr6xzbf/zyON+WF5B5HNVOWXswgpgdUsCyygs98hKy/Xje\n' +
       'TGzJUoWInW39t0YgMXenJrkS0m6wol8Rhxx81AGgELNV7EHZqg==\n' +
       '-----END PRIVATE KEY-----',
  format: 'pem'
});
const alicePublicKey = crypto.createPublicKey({
  key: '-----BEGIN PUBLIC KEY-----\n' +
       'MIIBnzCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKLgNwc\n' +
       '0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHC\n' +
       'ReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7ORb\n' +
       'PcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkHcJaW\n' +
       'bWcMNU5KvJgE8XRsCMojcyf//////////wIBAgOBxAACgcBR7+iL5qx7aOb9K+aZ\n' +
       'y2oLt7ST33sDKT+nxpag6cWDDWzPBKFDCJ8fr0v7yW453px8N4qi4R7SYYxFBaYN\n' +
       'Y3JvgDg1ct2JC9sxSuUOLqSFn3hpmAjW7cS0kExIVGfdLlYtIqbhhuo45cTEbVIM\n' +
       'rDEz8mjIlnvbWpKB9+uYmbjfVoc3leFvUBqfG2In2m23Md1swsPxr3n7g68H66JX\n' +
       'iBJKZLQMqNdbY14G9rdKmhhTJrQjC+i7Q/wI8JPhOFzHIGA=\n' +
       '-----END PUBLIC KEY-----',
  format: 'pem'
});

const bobPrivateKey = crypto.createPrivateKey({
  key: '-----BEGIN PRIVATE KEY-----\n' +
       'MIIBoQIBADCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKL\n' +
       'gNwc0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVt\n' +
       'bVHCReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR\n' +
       '7ORbPcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkH\n' +
       'cJaWbWcMNU5KvJgE8XRsCMojcyf//////////wIBAgSBwwKBwHxnT7Zw2Ehh1vyw\n' +
       'eolzQFHQzyuT0y+3BF+FxK2Ox7VPguTp57wQfGHbORJ2cwCdLx2mFM7gk4tZ6COS\n' +
       'E3Vta85a/PuhKXNLRdP79JgLnNtVtKXB+ePDS5C2GgXH1RHvqEdJh7JYnMy7Zj4P\n' +
       'GagGtIy3dV5f4FA0B/2C97jQ1pO16ah8gSLQRKsNpTCw2rqsZusE0rK6RaYAef7H\n' +
       'y/0tmLIsHxLIn+WK9CANqMbCWoP4I178BQaqhiOBkNyNZ0ndqA==\n' +
       '-----END PRIVATE KEY-----',
  format: 'pem'
});

const bobPublicKey = crypto.createPublicKey({
  key: '-----BEGIN PUBLIC KEY-----\n' +
       'MIIBoDCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKLgNwc\n' +
       '0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHC\n' +
       'ReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7ORb\n' +
       'PcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkHcJaW\n' +
       'bWcMNU5KvJgE8XRsCMojcyf//////////wIBAgOBxQACgcEAi26oq8z/GNSBm3zi\n' +
       'gNt7SA7cArUBbTxINa9iLYWp6bxrvCKwDQwISN36/QUw8nUAe8aRyMt0oYn+y6vW\n' +
       'Pw5OlO+TLrUelMVFaADEzoYomH0zVGb0sW4aBN8haC0mbrPt9QshgCvjr1hEPEna\n' +
       'QFKfjzNaJRNMFFd4f2Dn8MSB4yu1xpA1T2i0JSk24vS2H55jx24xhUYtfhT2LJgK\n' +
       'JvnaODey/xtY4Kql10ZKf43Lw6gdQC3G8opC9OxVxt9oNR7Z\n' +
       '-----END PUBLIC KEY-----',
  format: 'pem'
});

assert.throws(() => crypto.diffieHellman({ privateKey: alicePrivateKey }), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_VALUE',
  message: ""The property 'options.publicKey' is invalid. Received undefined""
});

assert.throws(() => crypto.diffieHellman({ publicKey: alicePublicKey }), {
  name: 'TypeError',
  code: 'ERR_INVALID_ARG_VALUE',
  message: ""The property 'options.privateKey' is invalid. Received undefined""
});

const privateKey = Buffer.from(
  '487CD880159D835FD0A8DBA9848898317283DB07E822741B344AD397BA84CDDD3920A51588' +
  'B891B03B3EBEF3C9F767D921FAC1294D4B5E09CABB6D1DE3EB4527989754FEB64D007EBBDA' +
  '2E6C8CE7A17EF41DE3C2DFE7CEAAF963199F55D5DBD9A415E77552FE69B7A41D87888B7D16' +
  '6BC569A3957B60EEA6A4ABEB1CDB7FFCF238DF961790791CD54E597B3082981D52C0B2CA0B' +
  '3DF212B2FD78DE4C6CC95285889D6DFDB746203177A726B912D26EB0A25F11871C7CD401A0' +
  '10B355EC41D9AA', 'hex');
const publicKey = Buffer.from(
  '8b6ea8abccff18d4819b7ce280db7b480edc02b5016d3c4835af622d85a9e9bc6bbc22b00d' +
  '0c0848ddfafd0530f275007bc691c8cb74a189fecbabd63f0e4e94ef932eb51e94c5456800' +
  'c4ce8628987d335466f4b16e1a04df21682d266eb3edf50b21802be3af58443c49da40529f' +
  '8f335a25134c1457787f60e7f0c481e32bb5c690354f68b4252936e2f4b61f9e63c76e3185' +
  '462d7e14f62c980a26f9da3837b2ff1b58e0aaa5d7464a7f8dcbc3a81d402dc6f28a42f4ec' +
  '55c6df68351ed9', 'hex');

const group = crypto.getDiffieHellman('modp5');
const dh = crypto.createDiffieHellman(group.getPrime(), group.getGenerator());
dh.setPrivateKey(privateKey);

// Test simple Diffie-Hellman, no curves involved.
test({ publicKey: alicePublicKey, privateKey: alicePrivateKey },
     { publicKey: bobPublicKey, privateKey: bobPrivateKey },
     dh.computeSecret(publicKey));

test(crypto.generateKeyPairSync('dh', { group: 'modp5' }),
     crypto.generateKeyPairSync('dh', { group: 'modp5' }));

test(crypto.generateKeyPairSync('dh', { group: 'modp5' }),
     crypto.generateKeyPairSync('dh', { prime: group.getPrime() }));

const list = [
  // Same generator, but different primes.
  [{ group: 'modp5' }, { group: 'modp18' }]];

// TODO(danbev): Take a closer look if there should be a check in OpenSSL3
// when the dh parameters differ.
if (!common.hasOpenSSL3) {
  // Same primes, but different generator.
  list.push([{ group: 'modp5' }, { prime: group.getPrime(), generator: 5 }]);
  // Same generator, but different primes.
  list.push([{ primeLength: 1024 }, { primeLength: 1024 }]);
}

for (const [params1, params2] of list) {
  assert.throws(() => {
    test(crypto.generateKeyPairSync('dh', params1),
         crypto.generateKeyPairSync('dh', params2));
  }, common.hasOpenSSL3 ? {
    name: 'Error',
    code: 'ERR_OSSL_MISMATCHING_DOMAIN_PARAMETERS'
  } : {
    name: 'Error',
    code: 'ERR_OSSL_EVP_DIFFERENT_PARAMETERS'
  });
}
{
  const privateKey = crypto.createPrivateKey({
    key: '-----BEGIN PRIVATE KEY-----\n' +
         'MIIBoQIBADCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKL\n' +
         'gNwc0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVt\n' +
         'bVHCReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR\n' +
         '7ORbPcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkH\n' +
         'cJaWbWcMNU5KvJgE8XRsCMojcyf//////////wIBAgSBwwKBwHu9fpiqrfJJ+tl9\n' +
         'ujFtEWv4afub6A/1/7sgishOYN3YQ+nmWQlmPpveIY34an5dG82CTrixHwUzQTMF\n' +
         'JaiCW3ax9+qk31f2jTNKrQznmKgopVKXF0FEJC6H79W/8Y0U14gsI9sHpovKhfou\n' +
         'RQD0QogW7ejSwMG8hCYibfrvMm0b5PHlwimISyEKh7VtDQ1frYN/Wr9ZbiV+FePJ\n' +
         '2j6RUKYNj1Pv+B4zdMgiLLjILAs8WUfbHciU21KSJh1izVQaUQ==\n' +
         '-----END PRIVATE KEY-----'
  });
  const publicKey = crypto.createPublicKey({
    key: '-----BEGIN PUBLIC KEY-----\n' +
         'MIIBoDCB1QYJKoZIhvcNAQMBMIHHAoHBAP//////////yQ/aoiFowjTExmKLgNwc\n' +
         '0SkCTgiKZ8x0Agu+pjsTmyJRSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHC\n' +
         'ReSFtXZiXn7G9ExC6aY37WsL/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7ORb\n' +
         'PcIAfLihY78FmNpINhxV05ppFj+o/STPX4NlXSPco62WHGLzViCFUrue1SkHcJaW\n' +
         'bWcMNU5KvJgE8XRsCMojcyf//////////wIBAgOBxQACgcEAmG9LpD8SAA6/W7oK\n' +
         'E4MCuuQtf5E8bqtcEAfYTOOvKyCS+eiX3TtZRsvHJjUBEyeO99PR/KrGVlkSuW52\n' +
         'ZOSXUOFu1L/0tqHrvRVHo+QEq3OvZ3EAyJkdtSEUTztxuUrMOyJXHDc1OUdNSnk0\n' +
         'taGX4mP3247golVx2DS4viDYs7UtaMdx03dWaP6y5StNUZQlgCIUzL7MYpC16V5y\n' +
         'KkFrE+Kp/Z77gEjivaG6YuxVj4GPLxJYbNFVTel42oSVeKuq\n' +
         '-----END PUBLIC KEY-----',
    format: 'pem'
  });

  // This key combination will result in an unusually short secret, and should
  // not cause an assertion failure.
  const secret = crypto.diffieHellman({ publicKey, privateKey });
  assert.strictEqual(secret.toString('hex'),
                     '0099d0fa242af5db9ea7330e23937a27db041f79c581500fc7f9976' +
                     '554d59d5b9ced934778d72e19a1fefc81e9d981013198748c0b5c6c' +
                     '762985eec687dc5bec5c9367b05837daee9d0bcc29024ed7f3abba1' +
                     '2794b65a745117fb0d87bc5b1b2b68c296c3f686cc29e450e4e1239' +
                     '21f56a5733fe58aabf71f14582954059c2185d342b9b0fa10c2598a' +
                     '5426c2baee7f9a686fc1e16cd4757c852bf7225a2732250548efe28' +
                     'debc26f1acdec51efe23d20786a6f8a14d360803bbc71972e87fd3');
}

// Test ECDH.

test(crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' }),
     crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' }));

const not256k1 = crypto.getCurves().find((c) => /^sec.*(224|384|512)/.test(c));
assert.throws(() => {
  test(crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' }),
       crypto.generateKeyPairSync('ec', { namedCurve: not256k1 }));
}, common.hasOpenSSL3 ? {
  name: 'Error',
  code: 'ERR_OSSL_MISMATCHING_DOMAIN_PARAMETERS'
} : {
  name: 'Error',
  code: 'ERR_OSSL_EVP_DIFFERENT_PARAMETERS'
});

// Test ECDH-ES.

test(crypto.generateKeyPairSync('x448'),
     crypto.generateKeyPairSync('x448'));

test(crypto.generateKeyPairSync('x25519'),
     crypto.generateKeyPairSync('x25519'));

assert.throws(() => {
  test(crypto.generateKeyPairSync('x448'),
       crypto.generateKeyPairSync('x25519'));
}, {
  name: 'Error',
  code: 'ERR_CRYPTO_INCOMPATIBLE_KEY',
  message: 'Incompatible key types for Diffie-Hellman: x448 and x25519'
});
"
modules/internal/crypto/sig.js,"use strict';

const {
  FunctionPrototypeCall,
  ObjectSetPrototypeOf,
  ReflectApply,
} = primordials;

const {
  codes: {
    ERR_CRYPTO_SIGN_KEY_REQUIRED,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE,
  }
} = require('internal/errors');

const {
  validateFunction,
  validateEncoding,
  validateString,
} = require('internal/validators');

const {
  Sign: _Sign,
  SignJob,
  Verify: _Verify,
  kCryptoJobAsync,
  kCryptoJobSync,
  kSigEncDER,
  kSigEncP1363,
  kSignJobModeSign,
  kSignJobModeVerify,
} = internalBinding('crypto');

const {
  getArrayBufferOrView,
  getDefaultEncoding,
  kHandle,
} = require('internal/crypto/util');

const {
  preparePrivateKey,
  preparePublicOrPrivateKey,
} = require('internal/crypto/keys');

const { Writable } = require('stream');

const { Buffer } = require('buffer');

const {
  isArrayBufferView,
} = require('internal/util/types');

function Sign(algorithm, options) {
  if (!(this instanceof Sign))
    return new Sign(algorithm, options);
  validateString(algorithm, 'algorithm');
  this[kHandle] = new _Sign();
  this[kHandle].init(algorithm);

  ReflectApply(Writable, this, [options]);
}

ObjectSetPrototypeOf(Sign.prototype, Writable.prototype);
ObjectSetPrototypeOf(Sign, Writable);

Sign.prototype._write = function _write(chunk, encoding, callback) {
  this.update(chunk, encoding);
  callback();
};

Sign.prototype.update = function update(data, encoding) {
  encoding = encoding || getDefaultEncoding();

  if (typeof data === 'string') {
    validateEncoding(data, encoding);
  } else if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data', ['string', 'Buffer', 'TypedArray', 'DataView'], data);
  }

  this[kHandle].update(data, encoding);
  return this;
};

function getPadding(options) {
  return getIntOption('padding', options);
}

function getSaltLength(options) {
  return getIntOption('saltLength', options);
}

function getDSASignatureEncoding(options) {
  if (typeof options === 'object') {
    const { dsaEncoding = 'der' } = options;
    if (dsaEncoding === 'der')
      return kSigEncDER;
    else if (dsaEncoding === 'ieee-p1363')
      return kSigEncP1363;
    throw new ERR_INVALID_ARG_VALUE('options.dsaEncoding', dsaEncoding);
  }

  return kSigEncDER;
}

function getIntOption(name, options) {
  const value = options[name];
  if (value !== undefined) {
    if (value === value >> 0) {
      return value;
    }
    throw new ERR_INVALID_ARG_VALUE(`options.${name}`, value);
  }
  return undefined;
}

Sign.prototype.sign = function sign(options, encoding) {
  if (!options)
    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();

  const { data, format, type, passphrase } = preparePrivateKey(options, true);

  // Options specific to RSA
  const rsaPadding = getPadding(options);
  const pssSaltLength = getSaltLength(options);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(options);

  const ret = this[kHandle].sign(data, format, type, passphrase, rsaPadding,
                                 pssSaltLength, dsaSigEnc);

  encoding = encoding || getDefaultEncoding();
  if (encoding && encoding !== 'buffer')
    return ret.toString(encoding);

  return ret;
};

function signOneShot(algorithm, data, key, callback) {
  if (algorithm != null)
    validateString(algorithm, 'algorithm');

  if (callback !== undefined)
    validateFunction(callback, 'callback');

  data = getArrayBufferOrView(data, 'data');

  if (!key)
    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();

  // Options specific to RSA
  const rsaPadding = getPadding(key);
  const pssSaltLength = getSaltLength(key);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(key);

  const {
    data: keyData,
    format: keyFormat,
    type: keyType,
    passphrase: keyPassphrase
  } = preparePrivateKey(key);

  const job = new SignJob(
    callback ? kCryptoJobAsync : kCryptoJobSync,
    kSignJobModeSign,
    keyData,
    keyFormat,
    keyType,
    keyPassphrase,
    data,
    algorithm,
    pssSaltLength,
    rsaPadding,
    dsaSigEnc);

  if (!callback) {
    const { 0: err, 1: signature } = job.run();
    if (err !== undefined)
      throw err;

    return Buffer.from(signature);
  }

  job.ondone = (error, signature) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, Buffer.from(signature));
  };
  job.run();
}

function Verify(algorithm, options) {
  if (!(this instanceof Verify))
    return new Verify(algorithm, options);
  validateString(algorithm, 'algorithm');
  this[kHandle] = new _Verify();
  this[kHandle].init(algorithm);

  ReflectApply(Writable, this, [options]);
}

ObjectSetPrototypeOf(Verify.prototype, Writable.prototype);
ObjectSetPrototypeOf(Verify, Writable);

Verify.prototype._write = Sign.prototype._write;
Verify.prototype.update = Sign.prototype.update;

Verify.prototype.verify = function verify(options, signature, sigEncoding) {
  const {
    data,
    format,
    type,
    passphrase
  } = preparePublicOrPrivateKey(options, true);

  sigEncoding = sigEncoding || getDefaultEncoding();

  // Options specific to RSA
  const rsaPadding = getPadding(options);
  const pssSaltLength = getSaltLength(options);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(options);

  signature = getArrayBufferOrView(signature, 'signature', sigEncoding);

  return this[kHandle].verify(data, format, type, passphrase, signature,
                              rsaPadding, pssSaltLength, dsaSigEnc);
};

function verifyOneShot(algorithm, data, key, signature, callback) {
  if (algorithm != null)
    validateString(algorithm, 'algorithm');

  if (callback !== undefined)
    validateFunction(callback, 'callback');

  data = getArrayBufferOrView(data, 'data');

  if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data',
      ['Buffer', 'TypedArray', 'DataView'],
      data
    );
  }

  // Options specific to RSA
  const rsaPadding = getPadding(key);
  const pssSaltLength = getSaltLength(key);

  // Options specific to (EC)DSA
  const dsaSigEnc = getDSASignatureEncoding(key);

  if (!isArrayBufferView(signature)) {
    throw new ERR_INVALID_ARG_TYPE(
      'signature',
      ['Buffer', 'TypedArray', 'DataView'],
      signature
    );
  }

  const {
    data: keyData,
    format: keyFormat,
    type: keyType,
    passphrase: keyPassphrase
  } = preparePublicOrPrivateKey(key);

  const job = new SignJob(
    callback ? kCryptoJobAsync : kCryptoJobSync,
    kSignJobModeVerify,
    keyData,
    keyFormat,
    keyType,
    keyPassphrase,
    data,
    algorithm,
    pssSaltLength,
    rsaPadding,
    dsaSigEnc,
    signature);

  if (!callback) {
    const { 0: err, 1: result } = job.run();
    if (err !== undefined)
      throw err;

    return result;
  }

  job.ondone = (error, result) => {
    if (error) return FunctionPrototypeCall(callback, job, error);
    FunctionPrototypeCall(callback, job, null, result);
  };
  job.run();
}

module.exports = {
  Sign,
  signOneShot,
  Verify,
  verifyOneShot,
};
"
modules/internal/fs/stream.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

import { Writable, Readable } from ""stream"";
import { validateEncoding } from ""./utils"";
import { URL } from ""url"";
import { toPathIfFileURL } from ""../url"";
import fs, { open, write, close, statSync } from ""../../fs"";
import { validateInteger, validateObject } from ""../validators"";
import { nextTick } from ""../../process"";

const kIsPerformingIO = Symbol('kIsPerformingIO');

const kFs = Symbol('kFs');

function notImplemented(msg) {
    throw new Error(msg);
}

export class WriteStreamClass extends Writable {
    fd = null;
    bytesWritten = 0;
    pos = 0;
    [kFs] = {
        open: fs.open,
        write: fs.write
    };
    [kIsPerformingIO] = false;
    constructor(path, opts) {
        super(opts);
        if (typeof (opts) === ""string"") {
            validateEncoding(opts, ""encoding"");
            opts = {};
        }
        if (opts === null || opts === undefined) {
            opts = {};
        }
        validateObject(opts, ""options"");
        if (opts.encoding) {
            validateEncoding(opts.encoding, ""encoding"");
            this.setDefaultEncoding(opts.encoding);
        }
        if (opts.start) {
            validateInteger(opts.start, ""start"");
        }
        this.pending = true;
        this.path = toPathIfFileURL(path);
        this.flags = opts.flags || ""w"";
        this.mode = opts.mode || 0o666;
        this[kFs] = opts.fs ?? {
            open: fs.open, write: fs.write, close: fs.close
        };
    }

    _construct(callback) {
        this[kFs].open(
            this.path.toString(),
            this.flags,
            this.mode,
            (err, fd) => {
                if (err) {
                    callback(err);
                    return;
                }
                this.pending = false;
                this.fd = fd;
                callback();
                this.emit(""open"", this.fd);
                this.emit(""ready"");
            },
        );
    }

    _write(
        data,
        _encoding,
        cb,
    ) {
        this[kIsPerformingIO] = true;
        this[kFs].write(
            this.fd,
            data,
            0,
            data.length,
            this.pos,
            (er) => {
                this[kIsPerformingIO] = false;
                if (this.destroyed) {
                    // Tell ._destroy() that it's safe to close the fd now.
                    cb(er);
                    return this.emit(kIoDone, er);
                }

                if (er) {
                    return cb(er);
                }

                this.bytesWritten += bytes;
                cb();
            },
        );

        if (this.pos !== undefined) {
            this.pos += data.length;
        }
    }

    _destroy(err, cb) {
        if (this[kIsPerformingIO]) {
            this.once(kIoDone, (er) => closeStream(this, err || er, cb));
        } else {
            closeStream(this, err, cb);
        }
    }
}

function closeStream(
    stream,
    err,
    cb,
) {
    if (!stream.fd) {
        cb(err);
    } else {
        stream[kFs].close(stream.fd, (er) => {
            cb(er || err);
        });
        stream.fd = null;
    }
}

export function WriteStream(
    path,
    opts,
) {
    return new WriteStreamClass(path, opts);
}

WriteStream.prototype = WriteStreamClass.prototype;

export function createWriteStream(
    path,
    opts,
) {
    return new WriteStreamClass(path, opts);
}

export class ReadStream extends Readable {
    constructor(path, opts) {
        path = path instanceof URL ? fromFileUrl(path) : path;
        if (opts && opts.start) {
            validateInteger(opts.start, ""start"");
        }
        if (opts && opts.end) {
            validateInteger(opts.end, ""end"");
        }
        const hasBadOptions = opts && (
            opts.start || opts.end || opts.fs
        );
        if (opts === null || typeof (opts) === ""undefined"") {
            opts = ""utf8"";
        }
        if (typeof (opts) === ""string"") {
            validateEncoding(opts, ""encoding"");
        } else {
            validateEncoding(opts.encoding || ""utf8"", ""encoding"");
        }
        // skip
        if (hasBadOptions && false) {
            notImplemented(
                `fs.ReadStream.prototype.constructor with unsupported options (${JSON.stringify(opts)
                })`,
            );
        }
        const buffer = Buffer.alloc(16 * 1024);
        let curPos = 0;
        let notClose = true;
        if (opts.fd) {
            setTimeout(() => {
                if (this.file === undefined) {
                    this.file = opts.fd;
                    this.pending = false;
                    this.emit(""ready"");
                }
            }, 0);
        } else {
            fs.promises.open(path, fs.constants.O_RDONLY).then(f => {
                if (this.file === undefined) {
                    notClose = false;
                    this.file = f;
                    this.pending = false;
                    this.emit(""ready"");
                }
            });
        }
        super({
            autoDestroy: true,
            emitClose: true,
            objectMode: false,
            read: async function (_size) {
                try {
                    if (this.file === undefined) {
                        if (opts.fd) {
                            if (opts.fd instanceof fs.FileHandle) {
                                this.file = opts.fd;
                            } else {
                                this.file = new fs.FileHandle(opts.fd, path);
                            }
                        } else {
                            this.file = new fs.FileHandle(fs.openSync(path, fs.constants.O_RDONLY), path);
                            notClose = false;
                        }
                        this.pending = false;
                        this.emit(""ready"");
                    }
                    opts.end = opts.end ?? fs.fstatSync(this.file.fd).size;
                    opts.start = opts.start ?? 0;
                    const { bytesRead: n } = await this.file.read(buffer, 0, opts.end - opts.start - curPos + 1, curPos === 0 ? opts.start : -1);
                    curPos += n;
                    if (n === 0) {
                        this.emit(""end"");
                    } else {
                        this.push(n ? Buffer.from(buffer.slice(0, n)) : null);
                        if (curPos >= opts.end) {
                            this.emit(""end"");
                        }
                    }
                } catch (err) {
                    this.destroy(err);
                }
            },
            destroy: (err, cb) => {
                try {
                    if (!notClose) {
                        this.file.close();
                    }
                    // deno-lint-ignore no-empty
                } catch { }
                cb(err);
            },
        });
        this.pending = true;
        this.path = path;
    }
}

export function createReadStream(
    path,
    options,
) {
    return new ReadStream(path, options);
}

"
test/fs/test-fs-null-bytes.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { URL } from ""url"";

function check(async, sync) {
  const argsSync = Array.prototype.slice.call(arguments, 2);
  const argsAsync = argsSync.concat(common.mustNotCall());

  if (sync) {
    assert.throws(
      () => {
        sync.apply(null, argsSync);
      },
      {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError',
      });
  }

  if (async) {
    assert.throws(
      () => {
        async.apply(null, argsAsync);
      },
      {
        code: 'ERR_INVALID_ARG_VALUE',
        name: 'TypeError'
      });
  }
}

check(fs.access, fs.accessSync, 'foo\u0000bar');
check(fs.access, fs.accessSync, 'foo\u0000bar', fs.F_OK);
check(fs.appendFile, fs.appendFileSync, 'foo\u0000bar', 'abc');
// check(fs.chmod, fs.chmodSync, 'foo\u0000bar', '0644');
// check(fs.chown, fs.chownSync, 'foo\u0000bar', 12, 34);
check(fs.copyFile, fs.copyFileSync, 'foo\u0000bar', 'abc');
check(fs.copyFile, fs.copyFileSync, 'abc', 'foo\u0000bar');
// check(fs.lchown, fs.lchownSync, 'foo\u0000bar', 12, 34);
check(fs.link, fs.linkSync, 'foo\u0000bar', 'foobar');
check(fs.link, fs.linkSync, 'foobar', 'foo\u0000bar');
check(fs.lstat, fs.lstatSync, 'foo\u0000bar');
check(fs.mkdir, fs.mkdirSync, 'foo\u0000bar', '0755');
check(fs.open, fs.openSync, 'foo\u0000bar', 'r');
check(fs.readFile, fs.readFileSync, 'foo\u0000bar');
check(fs.readdir, fs.readdirSync, 'foo\u0000bar');
check(fs.readlink, fs.readlinkSync, 'foo\u0000bar');
check(fs.realpath, fs.realpathSync, 'foo\u0000bar');
check(fs.rename, fs.renameSync, 'foo\u0000bar', 'foobar');
check(fs.rename, fs.renameSync, 'foobar', 'foo\u0000bar');
check(fs.rmdir, fs.rmdirSync, 'foo\u0000bar');
check(fs.stat, fs.statSync, 'foo\u0000bar');
check(fs.symlink, fs.symlinkSync, 'foo\u0000bar', 'foobar');
check(fs.symlink, fs.symlinkSync, 'foobar', 'foo\u0000bar');
check(fs.truncate, fs.truncateSync, 'foo\u0000bar');
check(fs.unlink, fs.unlinkSync, 'foo\u0000bar');
// check(null, fs.unwatchFile, 'foo\u0000bar', common.mustNotCall());
check(fs.utimes, fs.utimesSync, 'foo\u0000bar', 0, 0);
// check(null, fs.watch, 'foo\u0000bar', common.mustNotCall());
// check(null, fs.watchFile, 'foo\u0000bar', common.mustNotCall());
// check(fs.writeFile, fs.writeFileSync, 'foo\u0000bar', 'abc');

// null bytes will lost in this url module
/*
const fileUrl = new URL('file:///C:/foo\u0000bar');
const fileUrl2 = new URL('file:///C:/foo%00bar');

check(fs.access, fs.accessSync, fileUrl);
check(fs.access, fs.accessSync, fileUrl, fs.F_OK);
check(fs.appendFile, fs.appendFileSync, fileUrl, 'abc');
// check(fs.chmod, fs.chmodSync, fileUrl, '0644');
// check(fs.chown, fs.chownSync, fileUrl, 12, 34);
check(fs.copyFile, fs.copyFileSync, fileUrl, 'abc');
check(fs.copyFile, fs.copyFileSync, 'abc', fileUrl);
// check(fs.lchown, fs.lchownSync, fileUrl, 12, 34);
check(fs.link, fs.linkSync, fileUrl, 'foobar');
check(fs.link, fs.linkSync, 'foobar', fileUrl);
check(fs.lstat, fs.lstatSync, fileUrl);
check(fs.mkdir, fs.mkdirSync, fileUrl, '0755');
check(fs.open, fs.openSync, fileUrl, 'r');
check(fs.readFile, fs.readFileSync, fileUrl);
check(fs.readdir, fs.readdirSync, fileUrl);
check(fs.readlink, fs.readlinkSync, fileUrl);
check(fs.realpath, fs.realpathSync, fileUrl);
check(fs.rename, fs.renameSync, fileUrl, 'foobar');
check(fs.rename, fs.renameSync, 'foobar', fileUrl);
check(fs.rmdir, fs.rmdirSync, fileUrl);
check(fs.stat, fs.statSync, fileUrl);
check(fs.symlink, fs.symlinkSync, fileUrl, 'foobar');
check(fs.symlink, fs.symlinkSync, 'foobar', fileUrl);
check(fs.truncate, fs.truncateSync, fileUrl);
check(fs.unlink, fs.unlinkSync, fileUrl);
// check(null, fs.unwatchFile, fileUrl, assert.fail);
check(fs.utimes, fs.utimesSync, fileUrl, 0, 0);
// check(null, fs.watch, fileUrl, assert.fail);
// check(null, fs.watchFile, fileUrl, assert.fail);
check(fs.writeFile, fs.writeFileSync, fileUrl, 'abc');

check(fs.access, fs.accessSync, fileUrl2);
check(fs.access, fs.accessSync, fileUrl2, fs.F_OK);
check(fs.appendFile, fs.appendFileSync, fileUrl2, 'abc');
// check(fs.chmod, fs.chmodSync, fileUrl2, '0644');
// check(fs.chown, fs.chownSync, fileUrl2, 12, 34);
check(fs.copyFile, fs.copyFileSync, fileUrl2, 'abc');
check(fs.copyFile, fs.copyFileSync, 'abc', fileUrl2);
// check(fs.lchown, fs.lchownSync, fileUrl2, 12, 34);
check(fs.link, fs.linkSync, fileUrl2, 'foobar');
check(fs.link, fs.linkSync, 'foobar', fileUrl2);
check(fs.lstat, fs.lstatSync, fileUrl2);
check(fs.mkdir, fs.mkdirSync, fileUrl2, '0755');
check(fs.open, fs.openSync, fileUrl2, 'r');
check(fs.readFile, fs.readFileSync, fileUrl2);
check(fs.readdir, fs.readdirSync, fileUrl2);
check(fs.readlink, fs.readlinkSync, fileUrl2);
check(fs.realpath, fs.realpathSync, fileUrl2);
check(fs.rename, fs.renameSync, fileUrl2, 'foobar');
check(fs.rename, fs.renameSync, 'foobar', fileUrl2);
check(fs.rmdir, fs.rmdirSync, fileUrl2);
check(fs.stat, fs.statSync, fileUrl2);
check(fs.symlink, fs.symlinkSync, fileUrl2, 'foobar');
check(fs.symlink, fs.symlinkSync, 'foobar', fileUrl2);
check(fs.truncate, fs.truncateSync, fileUrl2);
check(fs.unlink, fs.unlinkSync, fileUrl2);
// check(null, fs.unwatchFile, fileUrl2, assert.fail);
check(fs.utimes, fs.utimesSync, fileUrl2, 0, 0);
// check(null, fs.watch, fileUrl2, assert.fail);
// check(null, fs.watchFile, fileUrl2, assert.fail);
// check(fs.writeFile, fs.writeFileSync, fileUrl2, 'abc');
*/

// An 'error' for exists means that it doesn't exist.
// One of many reasons why this file is the absolute worst.
fs.exists('foo\u0000bar', common.mustCall((exists) => {
  assert(!exists);
}));
assert(!fs.existsSync('foo\u0000bar'));
"
modules/internal/util.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
import { validateFunction, validateString } from ""./validators.js"";
import { normalizeEncoding, slowCases } from ""./normalize_encoding.js"";
export { normalizeEncoding, slowCases };

export const customInspectSymbol = Symbol.for(""nodejs.util.inspect.custom"");
export const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;

export function once(callback) {
    let called = false;
    return function (...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}

export function createDeferredPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });

    return { promise, resolve, reject };
}

// Keep a list of deprecation codes that have been warned on so we only warn on
// each one once.
const codesWarned = new Set();

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
export function deprecate(fn, msg, code) {
    // TODO(kt3k): Uncomment this
    // if (process.noDeprecation === true) {
    //  return fn;
    // }

    if (code !== undefined) {
        validateString(code, ""code"");
    }

    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code !== undefined) {
                if (!codesWarned.has(code)) {
                    process.emitWarning(msg, ""DeprecationWarning"", code, deprecated);
                    codesWarned.add(code);
                }
            } else {
                process.emitWarning(msg, ""DeprecationWarning"", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }

    // The wrapper will keep the same prototype as fn to maintain prototype chain
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        // Setting this (rather than using Object.setPrototype, as above) ensures
        // that calling the unwrapped constructor gives an instanceof the wrapped
        // constructor.
        deprecated.prototype = fn.prototype;
    }

    return deprecated;
}

// In addition to being accessible through util.promisify.custom,
// this symbol is registered globally and can be accessed in any environment as
// Symbol.for('nodejs.util.promisify.custom').
export const kCustomPromisifiedSymbol = Symbol.for(""nodejs.util.promisify.custom"");
// This is an internal Node symbol used by functions returning multiple
// arguments, e.g. ['bytesRead', 'buffer'] for fs.read().
const kCustomPromisifyArgsSymbol = Symbol.for(
    ""nodejs.util.promisify.customArgs"",
);

export const customPromisifyArgs = kCustomPromisifyArgsSymbol;

export function promisify(
    original,
) {
    validateFunction(original, ""original"");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];

        validateFunction(fn, ""util.promisify.custom"");

        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true,
        });
    }

    // Names to create an object from in case the callback receives multiple
    // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve, reject) => {
            args.push((err, ...values) => {
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for (let i = 0; i < argumentNames.length; i++) {
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            try {
                Reflect.apply(original, this, args);
            } catch (err) {
                return reject(err);
            }
        });
    }

    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true,
    });
    return Object.defineProperties(
        fn,
        Object.getOwnPropertyDescriptors(original),
    );
}

promisify.custom = kCustomPromisifiedSymbol;

const colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

export function removeColors(str) {
    return String.prototype.replace(str, colorRegExp, '');
}

export function isError(e) {
    // An error could be an instance of Error while not being a native error
    // or could be from a different realm and not be instance of Error but still
    // be a native error.
    return e instanceof Error;
}

export const kEmptyObject = Object.freeze(Object.create(null));

export function lazyDOMException(msg, name) {
    let e = new Error(msg)
    e.name = name;
    return e;
}

export function filterDuplicateStrings(items, low) {
    const map = new SafeMap();
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const key = String.prototype.toLowerCase.call(item);
        if (low) {
            map.set(key, key);
        } else {
            map.set(key, item);
        }
    }
    return Array.prototype.sort.call(Array.from(map.values()));
}

export function cachedResult(fn) {
    let result;
    return () => {
        if (result === undefined)
            result = fn();
        return Array.prototype.slice.call(result);
    };
}

export default {
    createDeferredPromise,
    customInspectSymbol,
    kEnumerableProperty,
    normalizeEncoding,
    once,
    deprecate,
    promisify,
    removeColors,
    isError,
    kEmptyObject,
    cachedResult,
    filterDuplicateStrings
};"
test/crypto/test-crypto-dh-curves.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

// Second OAKLEY group, see
// https://github.com/nodejs/node-v0.x-archive/issues/2338 and
// https://xml2rfc.tools.ietf.org/public/rfc/html/rfc2412.html#anchor49
const p = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +
          '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +
          '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +
          'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF';
crypto.createDiffieHellman(p, 'hex');

// Confirm DH_check() results are exposed for optional examination.
const bad_dh = crypto.createDiffieHellman('02', 'hex');
assert.notStrictEqual(bad_dh.verifyError, 0);

const availableCurves = new Set(crypto.getCurves());
const availableHashes = new Set(crypto.getHashes());

// Oakley curves do not clean up ERR stack, it was causing unexpected failure
// when accessing other OpenSSL APIs afterwards.
if (availableCurves.has('Oakley-EC2N-3')) {
  crypto.createECDH('Oakley-EC2N-3');
  crypto.createHash('sha256');
}

// Test ECDH
if (availableCurves.has('prime256v1') && availableCurves.has('secp256k1')) {
  const ecdh1 = crypto.createECDH('prime256v1');
  const ecdh2 = crypto.createECDH('prime256v1');
  const key1 = ecdh1.generateKeys();
  const key2 = ecdh2.generateKeys('hex');
  const secret1 = ecdh1.computeSecret(key2, 'hex', 'base64');
  const secret2 = ecdh2.computeSecret(key1, 'latin1', 'buffer');

  assert.strictEqual(secret1, secret2.toString('base64'));

  // Point formats
  assert.strictEqual(ecdh1.getPublicKey('buffer', 'uncompressed')[0], 4);
  let firstByte = ecdh1.getPublicKey('buffer', 'compressed')[0];
  assert(firstByte === 2 || firstByte === 3);
  firstByte = ecdh1.getPublicKey('buffer', 'hybrid')[0];
  assert(firstByte === 6 || firstByte === 7);
  // Format value should be string

  assert.throws(
    () => ecdh1.getPublicKey('buffer', 10),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_FORMAT',
      name: 'TypeError',
      message: 'Invalid ECDH format: 10'
    });

  // ECDH should check that point is on curve
  const ecdh3 = crypto.createECDH('secp256k1');
  const key3 = ecdh3.generateKeys();

  assert.throws(
    () => ecdh2.computeSecret(key3, 'latin1', 'buffer'),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY',
      name: 'Error',
      message: 'Public key is not valid for specified curve'
    });

  // ECDH should allow .setPrivateKey()/.setPublicKey()
  const ecdh4 = crypto.createECDH('prime256v1');

  ecdh4.setPrivateKey(ecdh1.getPrivateKey());
  ecdh4.setPublicKey(ecdh1.getPublicKey());

  assert.throws(() => {
    ecdh4.setPublicKey(ecdh3.getPublicKey());
  }, { message: 'Failed to convert Buffer to EC_POINT' });

  // Verify that we can use ECDH without having to use newly generated keys.
  const ecdh5 = crypto.createECDH('secp256k1');

  // Verify errors are thrown when retrieving keys from an uninitialized object.
  assert.throws(() => {
    ecdh5.getPublicKey();
  }, /^Error: Failed to get ECDH public key$/);

  assert.throws(() => {
    ecdh5.getPrivateKey();
  }, /^Error: Failed to get ECDH private key$/);

  // A valid private key for the secp256k1 curve.
  const cafebabeKey = 'cafebabe'.repeat(8);
  // Associated compressed and uncompressed public keys (points).
  const cafebabePubPtComp =
  '03672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3';
  const cafebabePubPtUnComp =
  '04672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3' +
  '2e02c7f93d13dc2732b760ca377a5897b9dd41a1c1b29dc0442fdce6d0a04d1d';
  ecdh5.setPrivateKey(cafebabeKey, 'hex');
  assert.strictEqual(ecdh5.getPrivateKey('hex'), cafebabeKey);
  // Show that the public point (key) is generated while setting the
  // private key.
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);

  // Compressed and uncompressed public points/keys for other party's
  // private key.
  // 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF
  const peerPubPtComp =
  '02c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae';
  const peerPubPtUnComp =
  '04c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae' +
  'b651944a574a362082a77e3f2b5d9223eb54d7f2f76846522bf75f3bedb8178e';

  const sharedSecret =
  '1da220b5329bbe8bfd19ceef5a5898593f411a6f12ea40f2a8eead9a5cf59970';

  assert.strictEqual(ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex'),
                     sharedSecret);
  assert.strictEqual(ecdh5.computeSecret(peerPubPtUnComp, 'hex', 'hex'),
                     sharedSecret);

  // Verify that we still have the same key pair as before the computation.
  assert.strictEqual(ecdh5.getPrivateKey('hex'), cafebabeKey);
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);

  // Verify setting and getting compressed and non-compressed serializations.
  ecdh5.setPublicKey(cafebabePubPtComp, 'hex');
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
  assert.strictEqual(
    ecdh5.getPublicKey('hex', 'compressed'),
    cafebabePubPtComp
  );
  ecdh5.setPublicKey(cafebabePubPtUnComp, 'hex');
  assert.strictEqual(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
  assert.strictEqual(
    ecdh5.getPublicKey('hex', 'compressed'),
    cafebabePubPtComp
  );

  // Show why allowing the public key to be set on this type
  // does not make sense.
  ecdh5.setPublicKey(peerPubPtComp, 'hex');
  assert.strictEqual(ecdh5.getPublicKey('hex'), peerPubPtUnComp);
  assert.throws(() => {
    // Error because the public key does not match the private key anymore.
    ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex');
  }, /Invalid key pair/);

  // Set to a valid key to show that later attempts to set an invalid key are
  // rejected.
  ecdh5.setPrivateKey(cafebabeKey, 'hex');

  // Some invalid private keys for the secp256k1 curve.
  const errMessage = /Private key is not valid for specified curve/;
  ['0000000000000000000000000000000000000000000000000000000000000000',
   'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141',
   'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',
  ].forEach((element) => {
    assert.throws(() => {
      ecdh5.setPrivateKey(element, 'hex');
    }, errMessage);
    // Verify object state did not change.
    assert.strictEqual(ecdh5.getPrivateKey('hex'), cafebabeKey);
  });
}

// Use of invalid keys was not cleaning up ERR stack, and was causing
// unexpected failure in subsequent signing operations.
if (availableCurves.has('prime256v1') && availableHashes.has('sha256')) {
  const curve = crypto.createECDH('prime256v1');
  const invalidKey = Buffer.alloc(65);
  invalidKey.fill('\0');
  curve.generateKeys();
  assert.throws(
    () => curve.computeSecret(invalidKey),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY',
      name: 'Error',
      message: 'Public key is not valid for specified curve'
    });
  // Check that signing operations are not impacted by the above error.
  const ecPrivateKey =
    '-----BEGIN EC PRIVATE KEY-----\n' +
    'MHcCAQEEIF+jnWY1D5kbVYDNvxxo/Y+ku2uJPDwS0r/VuPZQrjjVoAoGCCqGSM49\n' +
    'AwEHoUQDQgAEurOxfSxmqIRYzJVagdZfMMSjRNNhB8i3mXyIMq704m2m52FdfKZ2\n' +
    'pQhByd5eyj3lgZ7m7jbchtdgyOF8Io/1ng==\n' +
    '-----END EC PRIVATE KEY-----';
  crypto.createSign('SHA256').sign(ecPrivateKey);
}
"
tests/test-crypto.rs,"#![allow(dead_code, unused_imports, unused_must_use)]

use std::borrow::{Borrow, BorrowMut};
use wasmedge_quickjs::*;

fn test_js_file(file_path: &str) {
    use wasmedge_quickjs as q;

    env_logger::builder()
        // .filter_level(log::LevelFilter::Trace)
        .is_test(true)
        .try_init();

    let tokio_rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();

    tokio_rt.block_on(async {
        let mut rt = q::Runtime::new();
        let file_path = file_path.to_string();
        rt.async_run_with_context(Box::new(move |ctx| {
            let code = std::fs::read_to_string(&file_path);
            match code {
                Ok(code) => {
                    ctx.put_args(vec![file_path.clone()]);
                    ctx.eval_module_str(code, &file_path);
                }
                Err(e) => {
                    eprintln!(""{}"", e.to_string());
                    assert!(false, ""run js test file fail"");
                }
            }
            JsValue::UnDefined
        }))
        .await;
        rt.async_run_with_context(Box::new(|ctx| {
            log::trace!(""try _onExit"");
            if let JsValue::Function(func) = ctx.get_global().get(""_onExit"") {
                func.call(&[]);
            };
            JsValue::UnDefined
        }))
        .await;
        rt.async_run_with_context(Box::new(|ctx| {
            log::trace!(""try commonExitCheck"");
            if let JsValue::Function(func) = ctx.get_global().get(""commonExitCheck"") {
                func.call(&[]);
            };
            JsValue::UnDefined
        }))
        .await;
        rt.async_run_with_context(Box::new(|ctx| {
            log::trace!(""try assertPass"");
            if let JsValue::Function(func) = ctx.get_global().get(""assertPass"") {
                func.call(&[]);
            };
            JsValue::UnDefined
        }))
        .await;
    });
}

#[ignore = ""unsupported, aes-wrap""]
fn test_crypto_aes_wrap() {
    test_js_file(""test/crypto/test-crypto-aes-wrap.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_async_sign_verify() {
    test_js_file(""test/crypto/test-crypto-async-sign-verify.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_authenticated() {
    test_js_file(""test/crypto/test-crypto-authenticated.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_authenticated_stream() {
    test_js_file(""test/crypto/test-crypto-authenticated-stream.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_binary_default() {
    test_js_file(""test/crypto/test-crypto-binary-default.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_certificate() {
    test_js_file(""test/crypto/test-crypto-certificate.js"");
}
#[ignore = ""unsupported, md5""]
fn test_crypto_cipher_decipher() {
    test_js_file(""test/crypto/test-crypto-cipher-decipher.js"");
}
#[test]
fn test_crypto_cipheriv_decipheriv() {
    test_js_file(""test/crypto/test-crypto-cipheriv-decipheriv.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_classes() {
    test_js_file(""test/crypto/test-crypto-classes.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_des3_wrap() {
    test_js_file(""test/crypto/test-crypto-des3-wrap.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_constructor() {
    test_js_file(""test/crypto/test-crypto-dh-constructor.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_curves() {
    test_js_file(""test/crypto/test-crypto-dh-curves.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh() {
    test_js_file(""test/crypto/test-crypto-dh.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_leak() {
    test_js_file(""test/crypto/test-crypto-dh-leak.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_modp2() {
    test_js_file(""test/crypto/test-crypto-dh-modp2.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_modp2_views() {
    test_js_file(""test/crypto/test-crypto-dh-modp2-views.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_odd_key() {
    test_js_file(""test/crypto/test-crypto-dh-odd-key.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_padding() {
    test_js_file(""test/crypto/test-crypto-dh-padding.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_shared() {
    test_js_file(""test/crypto/test-crypto-dh-shared.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_dh_stateless() {
    test_js_file(""test/crypto/test-crypto-dh-stateless.js"");
}
#[ignore = ""unsupported, domain""]
fn test_crypto_domain() {
    test_js_file(""test/crypto/test-crypto-domain.js"");
}
#[ignore = ""unsupported, domain""]
fn test_crypto_domains() {
    test_js_file(""test/crypto/test-crypto-domains.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_ecb() {
    test_js_file(""test/crypto/test-crypto-ecb.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_ecdh_convert_key() {
    test_js_file(""test/crypto/test-crypto-ecdh-convert-key.js"");
}
#[ignore = ""unsupported""]
fn test_crypto_fips() {
    test_js_file(""test/crypto/test-crypto-fips.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_from_binary() {
    test_js_file(""test/crypto/test-crypto-from-binary.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_getcipherinfo() {
    test_js_file(""test/crypto/test-crypto-getcipherinfo.js"");
}
#[test]
fn test_crypto_hash() {
    test_js_file(""test/crypto/test-crypto-hash.js"");
}
#[ignore = ""unsupported, sha3-512""]
fn test_crypto_hash_stream_pipe() {
    test_js_file(""test/crypto/test-crypto-hash-stream-pipe.js"");
}
#[test]
fn test_crypto_hkdf() {
    test_js_file(""test/crypto/test-crypto-hkdf.js"");
}
#[test]
fn test_crypto_hmac() {
    test_js_file(""test/crypto/test-crypto-hmac.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto() {
    test_js_file(""test/crypto/test-crypto.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_keygen_deprecation() {
    test_js_file(""test/crypto/test-crypto-keygen-deprecation.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_keygen() {
    test_js_file(""test/crypto/test-crypto-keygen.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_key_objects() {
    test_js_file(""test/crypto/test-crypto-key-objects.js"");
}
#[ignore = ""unsupported, work_thread""]
fn test_crypto_key_objects_messageport() {
    test_js_file(""test/crypto/test-crypto-key-objects-messageport.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_lazy_transform_writable() {
    test_js_file(""test/crypto/test-crypto-lazy-transform-writable.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_modp1_error() {
    test_js_file(""test/crypto/test-crypto-modp1-error.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_op_during_process_exit() {
    test_js_file(""test/crypto/test-crypto-op-during-process-exit.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_padding_aes256() {
    test_js_file(""test/crypto/test-crypto-padding-aes256.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_padding() {
    test_js_file(""test/crypto/test-crypto-padding.js"");
}
#[test]
fn test_crypto_pbkdf2() {
    test_js_file(""test/crypto/test-crypto-pbkdf2.js"");
}

#[ignore = ""unsupported, prime""]
fn test_crypto_prime() {
    test_js_file(""test/crypto/test-crypto-prime.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_private_decrypt_gh32240() {
    test_js_file(""test/crypto/test-crypto-private-decrypt-gh32240.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_psychic_signatures() {
    test_js_file(""test/crypto/test-crypto-psychic-signatures.js"");
}
#[test]
fn test_crypto_randomfillsync_regression() {
    test_js_file(""test/crypto/test-crypto-randomfillsync-regression.js"");
}
#[test]
fn test_crypto_random() {
    test_js_file(""test/crypto/test-crypto-random.js"");
}
#[test]
fn test_crypto_randomuuid() {
    test_js_file(""test/crypto/test-crypto-randomuuid.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_rsa_dsa() {
    test_js_file(""test/crypto/test-crypto-rsa-dsa.js"");
}
#[test]
fn test_crypto_scrypt() {
    test_js_file(""test/crypto/test-crypto-scrypt.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_secret_keygen() {
    test_js_file(""test/crypto/test-crypto-secret-keygen.js"");
}

#[ignore = ""unsupported, child_process""]
fn test_crypto_secure_heap() {
    test_js_file(""test/crypto/test-crypto-secure-heap.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_sign_verify() {
    test_js_file(""test/crypto/test-crypto-sign-verify.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_stream() {
    test_js_file(""test/crypto/test-crypto-stream.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_subtle_zero_length() {
    test_js_file(""test/crypto/test-crypto-subtle-zero-length.js"");
}
#[test]
fn test_crypto_timing_safe_equal() {
    test_js_file(""test/crypto/test-crypto-timing-safe-equal.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_update_encoding() {
    test_js_file(""test/crypto/test-crypto-update-encoding.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_verify_failure() {
    test_js_file(""test/crypto/test-crypto-verify-failure.js"");
}

#[ignore = ""unsupport, webcrypto""]
fn test_crypto_webcrypto_aes_decrypt_tag_too_small() {
    test_js_file(""test/crypto/test-crypto-webcrypto-aes-decrypt-tag-too-small.js"");
}

#[ignore = ""unsupport, worker thread""]
fn test_crypto_worker_thread() {
    test_js_file(""test/crypto/test-crypto-worker-thread.js"");
}
#[test]
#[ignore = ""working""]
fn test_crypto_x509() {
    test_js_file(""test/crypto/test-crypto-x509.js"");
}
"
test/fs/test-fs-stat-bigint.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import promiseFs from 'fs/promises';
import path from 'path';
import tmpdir from '../common/tmpdir';
import { isDate } from 'internal/util/types';
import { inspect } from 'internal/util/inspect';

import process from ""process"";

tmpdir.refresh();

let testIndex = 0;

function getFilename() {
  const filename = path.join(tmpdir.path, `test-file-${++testIndex}`);
  fs.writeFileSync(filename, 'test');
  return filename;
}

function verifyStats(bigintStats, numStats, allowableDelta) {
  // allowableDelta: It's possible that the file stats are updated between the
  // two stat() calls so allow for a small difference.
  for (const key of Object.keys(numStats)) {
    const val = numStats[key];
    if (isDate(val)) {
      const time = val.getTime();
      const time2 = bigintStats[key].getTime();
      assert(
        time - time2 <= allowableDelta,
        `difference of ${key}.getTime() should <= ${allowableDelta}.\n` +
        `Number version ${time}, BigInt version ${time2}n`);
    } else if (key === 'mode') {
      assert.strictEqual(bigintStats[key], BigInt(val));
      assert.strictEqual(
        bigintStats.isBlockDevice(),
        numStats.isBlockDevice()
      );
      assert.strictEqual(
        bigintStats.isCharacterDevice(),
        numStats.isCharacterDevice()
      );
      assert.strictEqual(
        bigintStats.isDirectory(),
        numStats.isDirectory()
      );
      assert.strictEqual(
        bigintStats.isFIFO(),
        numStats.isFIFO()
      );
      assert.strictEqual(
        bigintStats.isFile(),
        numStats.isFile()
      );
      assert.strictEqual(
        bigintStats.isSocket(),
        numStats.isSocket()
      );
      assert.strictEqual(
        bigintStats.isSymbolicLink(),
        numStats.isSymbolicLink()
      );
    } else if (key.endsWith('Ms')) {
      const nsKey = key.replace('Ms', 'Ns');
      const msFromBigInt = bigintStats[key];
      const nsFromBigInt = bigintStats[nsKey];
      const msFromBigIntNs = Number(nsFromBigInt / (10n ** 6n));
      const msFromNum = numStats[key];

      assert(
        msFromNum - Number(msFromBigInt) <= allowableDelta,
        `Number version ${key} = ${msFromNum}, ` +
        `BigInt version ${key} = ${msFromBigInt}n, ` +
        `Allowable delta = ${allowableDelta}`);

      assert(
        msFromNum - Number(msFromBigIntNs) <= allowableDelta,
        `Number version ${key} = ${msFromNum}, ` +
        `BigInt version ${nsKey} = ${nsFromBigInt}n` +
        ` = ${msFromBigIntNs}ms, Allowable delta = ${allowableDelta}`);
    } else if (Number.isSafeInteger(val)) {
      assert.strictEqual(
        bigintStats[key], BigInt(val),
        `${inspect(bigintStats[key])} !== ${inspect(BigInt(val))}\n` +
        `key=${key}, val=${val}`
      );
    } else {
      assert(
        Number(bigintStats[key]) - val < 1,
        `${key} is not a safe integer, difference should < 1.\n` +
        `Number version ${val}, BigInt version ${bigintStats[key]}n`);
    }
  }
}

const runSyncTest = (func, arg) => {
  const startTime = process.hrtime.bigint();
  const bigintStats = func(arg, common.mustNotMutateObjectDeep({ bigint: true }));
  const numStats = func(arg);
  const endTime = process.hrtime.bigint();
  const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
  verifyStats(bigintStats, numStats, allowableDelta);
};

{
  const filename = getFilename();
  runSyncTest(fs.statSync, filename);
}

if (!common.isWindows) {
  const filename = getFilename();
  const link = `${filename}-link`;
  fs.symlinkSync(filename, link);
  runSyncTest(fs.lstatSync, link);
}

{
  const filename = getFilename();
  const fd = fs.openSync(filename, 'r');
  runSyncTest(fs.fstatSync, fd);
  fs.closeSync(fd);
}

{
  assert.throws(
    () => fs.statSync('does_not_exist'),
    { code: 'ENOENT' });
  assert.strictEqual(
    fs.statSync('does_not_exist', common.mustNotMutateObjectDeep({ throwIfNoEntry: false })),
    undefined);
}

{
  assert.throws(
    () => fs.lstatSync('does_not_exist'),
    { code: 'ENOENT' });
  assert.strictEqual(
    fs.lstatSync('does_not_exist', common.mustNotMutateObjectDeep({ throwIfNoEntry: false })),
    undefined);
}

{
  assert.throws(
    () => fs.fstatSync(9999),
    { code: 'EBADF' });
  assert.throws(
    () => fs.fstatSync(9999, common.mustNotMutateObjectDeep({ throwIfNoEntry: false })),
    { code: 'EBADF' });
}

const runCallbackTest = (func, arg, done) => {
  const startTime = process.hrtime.bigint();
  func(arg, common.mustNotMutateObjectDeep({ bigint: true }), common.mustCall((err, bigintStats) => {
    func(arg, common.mustCall((err, numStats) => {
      const endTime = process.hrtime.bigint();
      const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
      verifyStats(bigintStats, numStats, allowableDelta);
      if (done) {
        done();
      }
    }));
  }));
};

{
  const filename = getFilename();
  runCallbackTest(fs.stat, filename);
}

if (!common.isWindows) {
  const filename = getFilename();
  const link = `${filename}-link`;
  fs.symlinkSync(filename, link);
  runCallbackTest(fs.lstat, link);
}

{
  const filename = getFilename();
  const fd = fs.openSync(filename, 'r');
  runCallbackTest(fs.fstat, fd, () => { fs.closeSync(fd); });
}

const runPromiseTest = async (func, arg) => {
  const startTime = process.hrtime.bigint();
  const bigintStats = await func(arg, common.mustNotMutateObjectDeep({ bigint: true }));
  const numStats = await func(arg);
  const endTime = process.hrtime.bigint();
  const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
  verifyStats(bigintStats, numStats, allowableDelta);
};

{
  const filename = getFilename();
  runPromiseTest(promiseFs.stat, filename);
}

if (!common.isWindows) {
  const filename = getFilename();
  const link = `${filename}-link`;
  fs.symlinkSync(filename, link);
  runPromiseTest(promiseFs.lstat, link);
}

(async function() {
  const filename = getFilename();
  const handle = await promiseFs.open(filename, 'r');
  const startTime = process.hrtime.bigint();
  const bigintStats = await handle.stat(common.mustNotMutateObjectDeep({ bigint: true }));
  const numStats = await handle.stat();
  const endTime = process.hrtime.bigint();
  const allowableDelta = Math.ceil(Number(endTime - startTime) / 1e6);
  verifyStats(bigintStats, numStats, allowableDelta);
  await handle.close();
})().then(common.mustCall());
"
test/fs/test-fs-append-file.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';

const currentFileData = 'ABCD';

const s = '203111' +
          '' +
          '203' +
          '196179112' +
          '11193' +
          '' +
          '##\n';

tmpdir.refresh();

const throwNextTick = (e) => { process.nextTick(() => { throw e; }); };

// Test that empty file will be created and have content added (callback API).
{
  const filename = join(tmpdir.path, 'append.txt');
  fs.appendFile(filename, s, common.mustSucceed(() => {
    fs.readFile(filename, common.mustSucceed((buffer) => {
      assert.strictEqual(Buffer.byteLength(s), buffer.length);
    }));
  }));
}

// Test that empty file will be created and have content added (promise API).
{
  const filename = join(tmpdir.path, 'append-promise.txt');
  fs.promises.appendFile(filename, s)
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then((buffer) => {
      assert.strictEqual(Buffer.byteLength(s), buffer.length);
    })
    .catch(throwNextTick);
}

// Test that appends data to a non-empty file (callback API).
{
  const filename = join(tmpdir.path, 'append-non-empty.txt');
  fs.writeFileSync(filename, currentFileData);
  fs.appendFile(filename, s, common.mustSucceed(() => {
    fs.readFile(filename, common.mustSucceed((buffer) => {
      assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                         buffer.length);
    }));
  }));
}

// Test that appends data to a non-empty file (promise API).
{
  const filename = join(tmpdir.path, 'append-non-empty-promise.txt');
  fs.writeFileSync(filename, currentFileData);

  fs.promises.appendFile(filename, s)
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then((buffer) => {
      assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                         buffer.length);
    })
    .catch(throwNextTick);
}

// Test that appendFile accepts buffers (callback API).
{
  const filename = join(tmpdir.path, 'append-buffer.txt');
  fs.writeFileSync(filename, currentFileData);

  const buf = Buffer.from(s, 'utf8');

  fs.appendFile(filename, buf, common.mustSucceed(() => {
    fs.readFile(filename, common.mustSucceed((buffer) => {
      assert.strictEqual(buf.length + currentFileData.length, buffer.length);
    }));
  }));
}

// Test that appendFile accepts buffers (promises API).
{
  const filename = join(tmpdir.path, 'append-buffer-promises.txt');
  fs.writeFileSync(filename, currentFileData);

  const buf = Buffer.from(s, 'utf8');

  fs.promises.appendFile(filename, buf)
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then((buffer) => {
      assert.strictEqual(buf.length + currentFileData.length, buffer.length);
    })
    .catch(throwNextTick);
}

// Test that appendFile does not accept invalid data type (callback API).
[false, 5, {}, null, undefined].forEach(async (data) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /""data""|""buffer""/
  };
  const filename = join(tmpdir.path, 'append-invalid-data.txt');

  assert.throws(
    () => fs.appendFile(filename, data, common.mustNotCall()),
    errObj
  );

  assert.throws(
    () => fs.appendFileSync(filename, data),
    errObj
  );

  await assert.rejects(
    fs.promises.appendFile(filename, data),
    errObj
  );
  // The filename shouldn't exist if throwing error.
  assert.throws(
    () => fs.statSync(filename),
    {
      code: 'ENOENT',
      message: /no such file or directory/
    }
  );
});

// Test that appendFile accepts file descriptors (callback API).
{
  const filename = join(tmpdir.path, 'append-descriptors.txt');
  fs.writeFileSync(filename, currentFileData);

  fs.open(filename, 'a+', common.mustSucceed((fd) => {
    fs.appendFile(fd, s, common.mustSucceed(() => {
      fs.close(fd, common.mustSucceed(() => {
        fs.readFile(filename, common.mustSucceed((buffer) => {
          assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                             buffer.length);
        }));
      }));
    }));
  }));
}

// Test that appendFile accepts file descriptors (promises API).
{
  const filename = join(tmpdir.path, 'append-descriptors-promises.txt');
  fs.writeFileSync(filename, currentFileData);

  let fd;
  fs.promises.open(filename, 'a+')
    .then(common.mustCall((fileDescriptor) => {
      fd = fileDescriptor;
      return fs.promises.appendFile(fd, s);
    }))
    .then(common.mustCall(() => fd.close()))
    .then(common.mustCall(() => fs.promises.readFile(filename)))
    .then(common.mustCall((buffer) => {
      assert.strictEqual(Buffer.byteLength(s) + currentFileData.length,
                         buffer.length);
    }))
    .catch(throwNextTick);
}

assert.throws(
  () => fs.appendFile(join(tmpdir.path, 'append6.txt'), console.log),
  { code: 'ERR_INVALID_ARG_TYPE' });

"
test/crypto/test-crypto-pbkdf2.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

function runPBKDF2(password, salt, iterations, keylen, hash) {
  const syncResult =
    crypto.pbkdf2Sync(password, salt, iterations, keylen, hash);

  crypto.pbkdf2(password, salt, iterations, keylen, hash,
                common.mustSucceed((asyncResult) => {
                  assert.deepStrictEqual(asyncResult, syncResult);
                }));

  return syncResult;
}

function testPBKDF2(password, salt, iterations, keylen, expected, encoding) {
  const actual = runPBKDF2(password, salt, iterations, keylen, 'sha256');
  assert.strictEqual(actual.toString(encoding || 'latin1'), expected);
}

//
// Test PBKDF2 with RFC 6070 test vectors (except #4)
//

testPBKDF2('password', 'salt', 1, 20,
           '\x12\x0f\xb6\xcf\xfc\xf8\xb3\x2c\x43\xe7\x22\x52' +
           '\x56\xc4\xf8\x37\xa8\x65\x48\xc9');

testPBKDF2('password', 'salt', 2, 20,
           '\xae\x4d\x0c\x95\xaf\x6b\x46\xd3\x2d\x0a\xdf\xf9' +
           '\x28\xf0\x6d\xd0\x2a\x30\x3f\x8e');

testPBKDF2('password', 'salt', 4096, 20,
           '\xc5\xe4\x78\xd5\x92\x88\xc8\x41\xaa\x53\x0d\xb6' +
           '\x84\x5c\x4c\x8d\x96\x28\x93\xa0');

testPBKDF2('passwordPASSWORDpassword',
           'saltSALTsaltSALTsaltSALTsaltSALTsalt',
           4096,
           25,
           '\x34\x8c\x89\xdb\xcb\xd3\x2b\x2f\x32\xd8\x14\xb8\x11' +
           '\x6e\x84\xcf\x2b\x17\x34\x7e\xbc\x18\x00\x18\x1c');

testPBKDF2('pass\0word', 'sa\0lt', 4096, 16,
           '\x89\xb6\x9d\x05\x16\xf8\x29\x89\x3c\x69\x62\x26\x65' +
           '\x0a\x86\x87');

testPBKDF2('password', 'salt', 32, 32,
           '64c486c55d30d4c5a079b8823b7d7cb37ff0556f537da8410233bcec330ed956',
           'hex');

// Error path should not leak memory (check with valgrind).
assert.throws(
  () => crypto.pbkdf2('password', 'salt', 1, 20, 'sha1'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  }
);

for (const iterations of [-1, 0]) {
  assert.throws(
    () => crypto.pbkdf2Sync('password', 'salt', iterations, 20, 'sha1'),
    {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
    }
  );
}

['str', null, undefined, [], {}].forEach((notNumber) => {
  assert.throws(
    () => {
      crypto.pbkdf2Sync('password', 'salt', 1, notNumber, 'sha256');
    }, {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""keylen"" argument must be of type number.' +
               `${common.invalidArgTypeHelper(notNumber)}`
    });
});

[Infinity, -Infinity, NaN].forEach((input) => {
  assert.throws(
    () => {
      crypto.pbkdf2('password', 'salt', 1, input, 'sha256',
                    common.mustNotCall());
    }, {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""keylen"" is out of range. It ' +
               `must be an integer. Received ${input}`
    });
});

[-1, 4294967297].forEach((input) => {
  assert.throws(
    () => {
      crypto.pbkdf2('password', 'salt', 1, input, 'sha256',
                    common.mustNotCall());
    }, {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
    });
});

// Should not get FATAL ERROR with empty password and salt
// https://github.com/nodejs/node/issues/8571
crypto.pbkdf2('', '', 1, 32, 'sha256', common.mustSucceed());

assert.throws(
  () => crypto.pbkdf2('password', 'salt', 8, 8, common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""digest"" argument must be of type string. ' +
             'Received undefined'
  });

assert.throws(
  () => crypto.pbkdf2Sync('password', 'salt', 8, 8),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""digest"" argument must be of type string. ' +
             'Received undefined'
  });

assert.throws(
  () => crypto.pbkdf2Sync('password', 'salt', 8, 8, null),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""digest"" argument must be of type string. ' +
             'Received null'
  });
[1, {}, [], true, undefined, null].forEach((input) => {
  assert.throws(
    () => crypto.pbkdf2(input, 'salt', 8, 8, 'sha256', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );

  assert.throws(
    () => crypto.pbkdf2('pass', input, 8, 8, 'sha256', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );

  assert.throws(
    () => crypto.pbkdf2Sync(input, 'salt', 8, 8, 'sha256'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );

  assert.throws(
    () => crypto.pbkdf2Sync('pass', input, 8, 8, 'sha256'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );
});

['test', {}, [], true, undefined, null].forEach((i) => {
  const received = common.invalidArgTypeHelper(i);
  assert.throws(
    () => crypto.pbkdf2('pass', 'salt', i, 8, 'sha256', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""iterations"" argument must be of type number.${received}`
    }
  );

  assert.throws(
    () => crypto.pbkdf2Sync('pass', 'salt', i, 8, 'sha256'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""iterations"" argument must be of type number.${received}`
    }
  );
});

// Any TypedArray should work for password and salt.
for (const SomeArray of [Uint8Array, Uint16Array, Uint32Array, Float32Array,
                         Float64Array, ArrayBuffer, SharedArrayBuffer]) {
  runPBKDF2(new SomeArray(10), 'salt', 8, 8, 'sha256');
  runPBKDF2('pass', new SomeArray(10), 8, 8, 'sha256');
}

assert.throws(
  () => crypto.pbkdf2('pass', 'salt', 8, 8, 'md55', common.mustNotCall()),
  {
    code: 'ERR_CRYPTO_INVALID_DIGEST',
    name: 'TypeError',
    message: 'Invalid digest: md55'
  }
);

assert.throws(
  () => crypto.pbkdf2Sync('pass', 'salt', 8, 8, 'md55'),
  {
    code: 'ERR_CRYPTO_INVALID_DIGEST',
    name: 'TypeError',
    message: 'Invalid digest: md55'
  }
);

/*if (!common.hasOpenSSL3) {
  const kNotPBKDF2Supported = ['shake128', 'shake256'];
  crypto.getHashes()
    .filter((hash) => !kNotPBKDF2Supported.includes(hash))
    .forEach((hash) => {
      runPBKDF2(new Uint8Array(10), 'salt', 8, 8, hash);
    });
}*/

{
  // This should not crash.
  assert.throws(
    () => crypto.pbkdf2Sync('1', '2', 1, 1, '%'),
    {
      code: 'ERR_CRYPTO_INVALID_DIGEST',
      name: 'TypeError',
      message: 'Invalid digest: %'
    }
  );
}
"
.github/workflows/examples.yml,"name: examples

on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'info'
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:

    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v2
      
    - name: Install apt-get packages
      run: |
        sudo ACCEPT_EULA=Y apt-get update
        sudo ACCEPT_EULA=Y apt-get upgrade
        sudo apt-get install wget git curl software-properties-common build-essential

    - name: Install Rust target
      run: |
        rustup target add wasm32-wasi

    - name: Install WasmEdge
      run: |
        VERSION=0.13.5
        curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | sudo bash -s -- -e all --version=$VERSION --plugins wasi_nn-tensorflowlite wasi_crypto -p /usr/local        
        wget https://github.com/WasmEdge/WasmEdge/releases/download/$VERSION/WasmEdge-plugin-wasmedge_rustls-$VERSION-ubuntu20.04_x86_64.tar.gz
        sudo chmod +x /usr/local/lib/wasmedge

        tar -zxf WasmEdge-plugin-wasmedge_rustls-*-ubuntu20.04_x86_64.tar.gz
        sudo mv libwasmedge_rustls.so /usr/local/lib/wasmedge/

    - uses: actions/setup-node@v2
      with:
        node-version: '14'

    - name: Regular examples
      run: |
        cargo build --target wasm32-wasi --release
        wasmedge --env 'a=1' --env 'b=1' --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
    
    - name: Image examples
      run: |
        cargo build --target wasm32-wasi --release --features=img
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/image.js

    - name: Modules examples
      run: |
        cargo build --target wasm32-wasi --release
        cp example_js/module_demo/modules/* modules/
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/module_demo/demo.js
      
    - name: Network example
      run: |
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/wasi_net_echo.js

    - name: Http fetch example
      run: |
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/wasi_http_fetch.js
        
    - name: Http server example
      run: |
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/wasi_http_echo.js &
        
    - name: Https fetch example
      run: |
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/wasi_https_fetch.js

    - name: ES6 module
      run: |
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js

    - name: CommonJs with rollup.js
      run: |
        cargo build --target wasm32-wasi --release
        cd example_js/simple_common_js_demo
        npm install
        npm run build
        echo '> wasmedge aot'
        cd ../..
        wasmedgec target/wasm32-wasi/release/wasmedge_quickjs.wasm  wasmedge_quickjs.wasm
        echo '> start wasmedge'
        time wasmedge --dir .:. wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs

    - name: React SSR
      run: |
        cargo build --target wasm32-wasi --release
        cd example_js/react_ssr
        npm install
        npm run build
        cp -r ../../modules .
        echo '> start wasmedge'
        wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.js
        
    - name: React Stream SSR
      run: |
        cargo build --target wasm32-wasi --release
        cd example_js/react_ssr_stream
        npm install
        npm run build
        cp -r ../../modules .
        echo '> start wasmedge'
        nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.mjs &
        sleep 15
        resp=$(curl http://localhost:8001)
        echo ""Server response is $resp""
        
    - name: React18 Stream SSR example
      run: |
        cargo build --target wasm32-wasi --release
        cd example_js/react18_ssr
        npm install
        npm run build
        cp -r ../../modules .
        echo '> start wasmedge'
        nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.mjs &
        sleep 15
        resp=$(curl http://localhost:8002)
        echo ""$resp""

    - name: Create-react-app SSR example
      run: |
        cargo build --target wasm32-wasi --release
        cd example_js/create-react-app-ssr
        npm install
        npm run build
        cp -r ../../modules .
        # Use webpack
        npm run webpack:build-server
        echo '> start wasmedge server transpiled by Webpack'
        nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm server-build/index.js &
        echo $! > wasmedge.pid
        sleep 15
        resp=$(curl http://localhost:8003)
        echo ""$resp""
        kill -9 `cat wasmedge.pid`
        rm wasmedge.pid
        # Use rollup.js
        npm run rollup:build-server
        echo '> start wasmedge server transpiled by rollup'
        nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm server-build/index.js &
        sleep 15
        resp=$(curl http://localhost:8003)
        echo ""$resp""

    - name: WASI-NN example (TensorflowLite)
      run: |
        cargo build --target wasm32-wasi --release --features=wasi_nn
        wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/tensorflow_lite_demo/wasi_nn_main.js

    - name: Embed JS in Rust
      run: |
        cd examples/embed_js
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm

    - name: Embed JS module in Rust
      run: |
        cd examples/embed_js_module
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/embed_js_module.wasm

    - name: Use Rust to implement JS APIs
      run: |
        cd examples/embed_rust_module
        cargo build --target wasm32-wasi --release
        wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm

    - name: Use Rust to extends JS Class
      run: |
        cargo build --target wasm32-wasi --release --example=js_extend
        wasmedge --dir .:. target/wasm32-wasi/release/examples/js_extend.wasm

    - name: Node fs module test
      timeout-minutes: 60
      run: |
        cargo test test_fs --target=wasm32-wasi --release

    - name: Node crypto module test
      #timeout-minutes: 10
      run: |
        cargo test test_crypto --target=wasm32-wasi --release --features=nodejs_crypto
"
modules/internal_binding/util.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// This module ports:
// - https://github.com/nodejs/node/blob/master/src/util-inl.h
// - https://github.com/nodejs/node/blob/master/src/util.cc
// - https://github.com/nodejs/node/blob/master/src/util.h

/**
 * 
 * @param {string} msg 
 * @return {never}
 */
export function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : ""Not implemented"";
    throw new Error(message);
}

/**
 * 
 * @param {number} _fd 
 * @return {string}
 */
export function guessHandleType(_fd) {
    notImplemented(""util.guessHandleType"");
}

export const ALL_PROPERTIES = 0;
export const ONLY_WRITABLE = 1;
export const ONLY_ENUMERABLE = 2;
export const ONLY_CONFIGURABLE = 4;
export const ONLY_ENUM_WRITABLE = 6;
export const SKIP_STRINGS = 8;
export const SKIP_SYMBOLS = 16;

/**
 * Efficiently determine whether the provided property key is numeric
 * (and thus could be an array indexer) or not.
 *
 * Always returns true for values of type `'number'`.
 *
 * Otherwise, only returns true for strings that consist only of positive integers.
 *
 * Results are cached.
 * 
 * @type {Record<string, boolean>}
 */
const isNumericLookup = {};

/**
 * 
 * @param {unknown} value 
 * @returns {boolean}
 */
export function isArrayIndex(value) {
    switch (typeof value) {
        case ""number"":
            return value >= 0 && (value | 0) === value;
        case ""string"": {
            const result = isNumericLookup[value];
            if (result !== void 0) {
                return result;
            }
            const length = value.length;
            if (length === 0) {
                return isNumericLookup[value] = false;
            }
            let ch = 0;
            let i = 0;
            for (; i < length; ++i) {
                ch = value.charCodeAt(i);
                if (
                    i === 0 && ch === 0x30 && length > 1 /* must not start with 0 */ ||
                    ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */
                ) {
                    return isNumericLookup[value] = false;
                }
            }
            return isNumericLookup[value] = true;
        }
        default:
            return false;
    }
}

/**
 * 
 * @param {object} obj 
 * @param {number} filter 
 * @returns {(string | symbol)[]}
 */
export function getOwnNonIndexProperties(
    // deno-lint-ignore ban-types
    obj,
    filter,
) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj),
    ];

    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k) => !isArrayIndex(k));
    }

    if (filter === ALL_PROPERTIES) {
        return allProperties;
    }

    /**
     * @type {(string | symbol)[]}
     */
    const result = [];
    for (const key of allProperties) {
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & ONLY_WRITABLE && !desc.writable) {
            continue;
        }
        if (filter & ONLY_ENUMERABLE && !desc.enumerable) {
            continue;
        }
        if (filter & ONLY_CONFIGURABLE && !desc.configurable) {
            continue;
        }
        if (filter & SKIP_STRINGS && typeof key === ""string"") {
            continue;
        }
        if (filter & SKIP_SYMBOLS && typeof key === ""symbol"") {
            continue;
        }
        result.push(key);
    }
    return result;
}
"
src/internal_module/httpx/core/response.rs,"use super::ParseError;
use super::Version;
use std::collections::HashMap;
use std::fmt::Display;
use std::io::BufRead;

#[derive(Debug, PartialEq, Clone)]
pub enum BodyLen {
    Length(usize),
    Chunked,
}

#[derive(Debug, PartialEq, Clone)]
pub struct HttpResponse {
    pub version: Version,
    pub status_code: u16,
    pub status_text: String,
    pub headers: HashMap<String, String>,
    pub body_len: BodyLen,
}

impl Default for HttpResponse {
    fn default() -> Self {
        Self {
            version: Version::V1_0,
            status_code: 200,
            status_text: ""OK"".to_string(),
            headers: HashMap::default(),
            body_len: BodyLen::Length(0),
        }
    }
}

impl HttpResponse {
    #[deprecated]
    pub fn new(status_code: u16, headers: Option<HashMap<String, String>>) -> HttpResponse {
        let mut response = HttpResponse::default();
        response.status_code = status_code;
        if let Some(headers) = headers {
            response.headers = headers;
        }
        response.status_text = match response.status_code {
            200 => ""OK"",
            400 => ""Bad Request"",
            404 => ""Not Found"",
            500 => ""Internal Server Error"",
            _ => """",
        }
        .to_string();

        response
    }
}

impl From<HttpResponse> for String {
    #[inline(always)]
    fn from(res: HttpResponse) -> String {
        String::from(&res)
    }
}

impl From<&HttpResponse> for String {
    fn from(res: &HttpResponse) -> String {
        let mut header_string = String::new();
        for (k, v) in &res.headers {
            header_string.push_str(k);
            header_string.push_str("": "");
            header_string.push_str(v);
            header_string.push_str(""\r\n"");
        }

        match res.body_len {
            BodyLen::Length(0) => {}
            BodyLen::Length(len) => {
                header_string.push_str(&format!(""Content-Length: {}\r\n"", len));
            }
            BodyLen::Chunked => {
                header_string.push_str(&format!(""Transfer-Encoding: chunked\r\n""));
            }
        }

        format!(
            ""{} {} {}\r\n{}\r\n"",
            res.version, res.status_code, res.status_text, header_string,
        )
    }
}

impl Display for HttpResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", String::from(self))
    }
}

impl HttpResponse {
    pub fn from_status(
        headers: Option<HashMap<String, String>>,
        status_code: u16,
        status_text: &str,
    ) -> Self {
        let mut response = HttpResponse::default();

        response.status_code = status_code;
        if let Some(headers) = headers {
            response.headers = headers;
        }

        response.status_text = status_text.to_string();
        response
    }

    pub fn parse(mut req: &[u8]) -> Result<(Self, usize), ParseError> {
        let parsed_version;
        let parsed_status;
        let parsed_status_text;
        let mut parsed_headers = HashMap::new();
        let mut parsed_body_len = BodyLen::Length(0);

        let mut total = 0;

        {
            let mut line = String::new();
            let n = req
                .read_line(&mut line)
                .map_err(|_| ParseError::OtherParseError)?;
            if n == 0 {
                return Err(ParseError::Pending);
            }
            let line = line.trim_end();
            total += n;

            let (version, status, status_text) = process_resp_line(line)?;
            parsed_version = version;
            parsed_status = status;
            parsed_status_text = status_text;
        }

        'exit: loop {
            let mut line = String::new();
            let n = req
                .read_line(&mut line)
                .map_err(|_| ParseError::OtherParseError)?;
            if n == 0 {
                return Err(ParseError::Pending);
            }
            let line = line.trim_end();
            total += n;

            {
                if line.is_empty() {
                    break 'exit;
                } else if line.contains(':') {
                    let (key, value) = process_header_line(line);
                    let header_key = key.to_lowercase();
                    if header_key.as_str() == ""content-length"" {
                        let len = value.parse().map_err(|_| ParseError::InvalidHeaders)?;
                        parsed_body_len = BodyLen::Length(len);
                    } else if header_key.as_str() == ""transfer-encoding""
                        && value.as_str() == ""chunked""
                    {
                        parsed_body_len = BodyLen::Chunked;
                    }
                    parsed_headers.insert(key, value);
                } else {
                    return Err(ParseError::InvalidHeaders);
                }
            }
        }

        if let BodyLen::Length(n) = parsed_body_len {
            if req.len() < n {
                return Err(ParseError::Pending);
            }
        }

        Ok((
            HttpResponse {
                version: parsed_version,
                status_code: parsed_status,
                status_text: parsed_status_text,
                headers: parsed_headers,
                body_len: parsed_body_len,
            },
            total,
        ))
    }
}

fn process_resp_line(s: &str) -> Result<(Version, u16, String), ParseError> {
    let mut words = s.split_whitespace();
    let version = words.next().ok_or(ParseError::InvalidStatusLine)?;
    let status = words.next().ok_or(ParseError::InvalidStatusLine)?;
    let resource = words.next().unwrap_or_default();

    Ok((
        version.parse()?,
        status.parse().map_err(|_| ParseError::InvalidStatusCode)?,
        resource.to_string(),
    ))
}
fn process_header_line(s: &str) -> (String, String) {
    let mut header_items = s.split(':');
    let mut key = String::from("""");
    let mut value = String::from("""");

    if let Some(k) = header_items.next() {
        key = k.to_string();
    }

    if let Some(v) = header_items.next() {
        value = v.to_string().trim_start().to_string()
    }

    (key, value)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_response_struct_creation_200() {
        let response_expected = HttpResponse {
            version: Version::V1_0,
            status_code: 200,
            status_text: ""OK"".to_string(),
            headers: {
                let mut h = HashMap::new();
                h.insert(""Content-Type"".to_string(), ""text/html"".to_string());
                h
            },
            body_len: BodyLen::Length(10),
        };

        assert_eq!(
            ""HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nContent-Length: 10\r\n\r\n"",
            format!(""{}"", response_expected)
        );
    }

    #[test]
    fn test_response_struct_parse() {
        let data = ""HTTP/1.0 200 OK\r\nContent-Length: 4\r\nContent-Type: text/html\r\n\r\nhaha"";
        let (resp, n) = HttpResponse::parse(data.as_bytes()).unwrap();
        assert_eq!(Version::V1_0, resp.version);
        assert_eq!(200, resp.status_code);
        assert_eq!(""OK"", resp.status_text);
        assert_eq!(BodyLen::Length(4), resp.body_len);
        assert_eq!(""haha"", data.split_at(n).1)
    }
}
"
test/fs/test-fs-stat.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

fs.stat('.', common.mustSucceed(function(stats) {
  assert.ok(stats.mtime instanceof Date);
  assert.ok(Object.prototype.hasOwnProperty.call(stats, 'blksize'));
  assert.ok(Object.prototype.hasOwnProperty.call(stats, 'blocks'));
  // Confirm that we are not running in the context of the internal binding
  // layer.
  // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
  assert.strictEqual(this, undefined);
}));

fs.lstat('.', common.mustSucceed(function(stats) {
  assert.ok(stats.mtime instanceof Date);
  // Confirm that we are not running in the context of the internal binding
  // layer.
  // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
  assert.strictEqual(this, undefined);
}));

// fstat
fs.open('.', 'r', undefined, common.mustSucceed(function(fd) {
  assert.ok(fd);

  fs.fstat(-0, common.mustSucceed());

  fs.fstat(fd, common.mustSucceed(function(stats) {
    assert.ok(stats.mtime instanceof Date);
    fs.close(fd, assert.ifError);
    // Confirm that we are not running in the context of the internal binding
    // layer.
    // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
    assert.strictEqual(this, undefined);
  }));

  // Confirm that we are not running in the context of the internal binding
  // layer.
  // Ref: https://github.com/nodejs/node/commit/463d6bac8b349acc462d345a6e298a76f7d06fb1
  assert.strictEqual(this, undefined);
}));

// fstatSync
fs.open('.', 'r', undefined, common.mustCall(function(err, fd) {
  const stats = fs.fstatSync(fd);
  assert.ok(stats.mtime instanceof Date);
  fs.close(fd, common.mustSucceed());
}));

fs.stat(__filename, common.mustSucceed((s) => {
  assert.strictEqual(s.isDirectory(), false);
  assert.strictEqual(s.isFile(), true);
  assert.strictEqual(s.isSocket(), false);
  assert.strictEqual(s.isBlockDevice(), false);
  assert.strictEqual(s.isCharacterDevice(), false);
  assert.strictEqual(s.isFIFO(), false);
  assert.strictEqual(s.isSymbolicLink(), false);

  const jsonString = JSON.stringify(s);
  const parsed = JSON.parse(jsonString);
  [
    'dev', 'mode', 'nlink', 'uid',
    'gid', 'rdev', 'blksize', 'ino', 'size', 'blocks',
    'atime', 'mtime', 'ctime', 'birthtime',
    'atimeMs', 'mtimeMs', 'ctimeMs', 'birthtimeMs',
  ].forEach(function(k) {
    assert.ok(k in s, `${k} should be in Stats`);
    assert.notStrictEqual(s[k], undefined, `${k} should not be undefined`);
    assert.notStrictEqual(s[k], null, `${k} should not be null`);
    assert.notStrictEqual(parsed[k], undefined, `${k} should not be undefined`);
    assert.notStrictEqual(parsed[k], null, `${k} should not be null`);
  });
  [
    'dev', 'mode', 'nlink', 'uid', 'gid', 'rdev', 'blksize', 'ino', 'size',
    'blocks', 'atimeMs', 'mtimeMs', 'ctimeMs', 'birthtimeMs',
  ].forEach((k) => {
    assert.strictEqual(typeof s[k], 'number', `${k} should be a number`);
    assert.strictEqual(typeof parsed[k], 'number', `${k} should be a number`);
  });
  ['atime', 'mtime', 'ctime', 'birthtime'].forEach((k) => {
    assert.ok(s[k] instanceof Date, `${k} should be a Date`);
    assert.strictEqual(typeof parsed[k], 'string', `${k} should be a string`);
  });
}));

['', false, null, undefined, {}, []].forEach((input) => {
  ['fstat', 'fstatSync'].forEach((fnName) => {
    assert.throws(
      () => fs[fnName](input),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });
});

[false, 1, {}, [], null, undefined].forEach((input) => {
  assert.throws(
    () => fs.lstat(input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.lstatSync(input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.stat(input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.statSync(input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Should not throw an error
fs.stat(__filename, undefined, common.mustCall(() => {}));

fs.open(__filename, 'r', undefined, common.mustCall((err, fd) => {
  // Should not throw an error
  fs.fstat(fd, undefined, common.mustCall(() => {}));
}));

// Should not throw an error
fs.lstat(__filename, undefined, common.mustCall(() => {}));
"
src/event_loop/mod.rs,"mod poll;
pub mod wasi_fs;
mod wasi_sock;
mod certs;

use crate::{quickjs_sys as qjs, Context, JsClassTool, JsValue};
use std::borrow::BorrowMut;
use std::cell::RefCell;
use std::collections::{HashMap, LinkedList};
use std::convert::TryInto;
use std::io::{self, Read, Write};
use std::mem::ManuallyDrop;
use std::net::{SocketAddr, SocketAddrV4};
use std::ops::Add;
use std::os::fd::{AsRawFd, FromRawFd};
use std::sync::atomic::AtomicUsize;
use std::sync::Arc;

use rustls::OwnedTrustAnchor;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
pub use wasi_sock::nslookup;

pub(crate) enum NetPollEvent {
    Accept,
    Read,
    Connect,
}

pub struct AsyncTcpServer(pub(crate) tokio::net::TcpListener);
impl AsyncTcpServer {
    pub fn bind(port: u16) -> io::Result<Self> {
        let listener = wasmedge_wasi_socket::TcpListener::bind((""0.0.0.0"", port), true)?;
        let async_listener = tokio::net::TcpListener::from_std(listener)?;
        Ok(AsyncTcpServer(async_listener))
    }

    pub async fn accept(
        &mut self,
        ctx: &mut Context,
        timeout: Option<std::time::Duration>,
    ) -> Result<JsValue, JsValue> {
        if let Some(duration) = timeout {
            match tokio::time::timeout(duration, self.0.accept()).await {
                Ok(Ok((conn, addr))) => {
                    log::trace!(""tcp accept a socket[{addr}]"");
                    Ok(AsyncTcpConn::wrap_obj(ctx, AsyncTcpConn(conn)))
                }
                Ok(Err(e)) => {
                    log::trace!(""tcp accept error: {e}"");
                    Err(ctx.new_error(e.to_string().as_str()))
                }
                Err(e) => {
                    let err = std::io::Error::new(std::io::ErrorKind::TimedOut, e.to_string());
                    Err(ctx.new_error(err.to_string().as_str()).into())
                }
            }
        } else {
            match self.0.accept().await {
                Ok((conn, addr)) => {
                    log::trace!(""tcp accept a socket[{addr}]"");
                    Ok(AsyncTcpConn::wrap_obj(ctx, AsyncTcpConn(conn)))
                }
                Err(e) => {
                    log::trace!(""tcp accept error: {e}"");
                    Err(ctx.new_error(e.to_string().as_str()))
                }
            }
        }
    }
}

pub struct AsyncTcpConn(pub(crate) tokio::net::TcpStream);
impl AsyncTcpConn {
    pub async fn async_connect<R: tokio::net::ToSocketAddrs>(addr: R) -> io::Result<Self> {
        tokio::net::TcpStream::connect(addr)
            .await
            .map(|conn| AsyncTcpConn(conn))
    }

    pub async fn async_read_all(&mut self) -> io::Result<Vec<u8>> {
        let mut data = vec![];
        let mut buff = [0u8; 1024 * 4];

        log::trace!(""tcp read_all"");

        loop {
            match self.0.read(&mut buff).await {
                Ok(0) => {
                    log::trace!(""tcp read: 0"");
                    return Ok(data);
                }
                Ok(n) => {
                    log::trace!(""tcp read: {n}"");
                    data.extend_from_slice(&buff[0..n]);
                    if n < buff.len() {
                        return Ok(data);
                    }
                }
                Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
                    log::trace!(""tcp read: WouldBlock"");
                    return Ok(data);
                }
                Err(e) => {
                    log::trace!(""tcp read: {e}"");
                    return Err(e);
                }
            }
        }
    }

    pub async fn async_write_all(&mut self, buf: &[u8]) -> io::Result<()> {
        self.0.write_all(buf).await
    }

    pub fn local(&self) -> io::Result<SocketAddr> {
        self.0.local_addr()
    }

    pub fn peer(&self) -> io::Result<SocketAddr> {
        self.0.peer_addr()
    }
}

#[cfg(feature = ""tls"")]
pub struct AsyncTlsConn(pub(crate) tokio_rustls::client::TlsStream<tokio::net::TcpStream>);

#[cfg(feature = ""tls"")]
impl AsyncTlsConn {
    pub async fn async_connect<R: tokio::net::ToSocketAddrs, S: AsRef<str>>(
        addr: R,
        domain: S,
    ) -> io::Result<Self> {
        use rustls::ClientConfig;
        use tokio_rustls::client::TlsStream;

        let io = tokio::net::TcpStream::connect(addr).await?;
        let mut root_store = rustls::RootCertStore::empty();
        if let Ok(custom_certs) = certs::load_certs_from_env() {
            log::info!(""using custom certs"");
            for cert in custom_certs {
                root_store.add(&cert).unwrap();
            }
        } else {
            log::info!(""falling back to webpki certs"");
            root_store.add_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| {
                OwnedTrustAnchor::from_subject_spki_name_constraints(
                    ta.subject,
                    ta.spki,
                    ta.name_constraints,
                )
            }));
        }

        let config = rustls::ClientConfig::builder()
            .with_safe_defaults()
            .with_root_certificates(root_store)
            .with_no_client_auth();

        let connector = tokio_rustls::TlsConnector::from(Arc::new(config));
        let domain: rustls::ServerName = domain
            .as_ref()
            .try_into()
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

        let conn = connector.connect(domain, io).await?;

        Ok(Self(conn))
    }

    pub async fn async_read_all(&mut self) -> io::Result<Vec<u8>> {
        let mut data = vec![];
        let mut buff = [0u8; 1024 * 4];

        log::trace!(""tls read_all"");

        loop {
            match self.0.read(&mut buff).await {
                Ok(0) => {
                    log::trace!(""tls read: 0"");
                    return Ok(data);
                }
                Ok(n) => {
                    log::trace!(""tls read: {n}"");
                    data.extend_from_slice(&buff[0..n]);
                    if n < buff.len() {
                        return Ok(data);
                    }
                }
                Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
                    log::trace!(""tls read: WouldBlock"");
                    return Ok(data);
                }
                Err(e) => {
                    log::trace!(""tls read: {e}"");
                    return Err(e);
                }
            }
        }
    }

    pub async fn async_write_all(&mut self, buf: &[u8]) -> io::Result<()> {
        self.0.write_all(buf).await
    }

    pub fn local(&self) -> io::Result<SocketAddr> {
        self.0.get_ref().0.local_addr()
    }

    pub fn peer(&self) -> io::Result<SocketAddr> {
        self.0.get_ref().0.peer_addr()
    }
}

#[derive(Default)]
pub struct EventLoop {
    next_tick_queue: LinkedList<Box<dyn FnOnce()>>,
    immediate_queue: LinkedList<Box<dyn FnOnce()>>,
    pub(crate) waker: Option<std::task::Waker>,
    pub(crate) sub_tasks: LinkedList<tokio::task::JoinHandle<()>>,
}

impl EventLoop {
    pub fn add_immediate_task(&mut self, callback: Box<dyn FnOnce()>) {
        self.immediate_queue.push_back(callback);
    }

    pub fn run_tick_task(&mut self) -> usize {
        let mut i = 0;
        let mut cb_vec = LinkedList::new();
        while let Some(f) = self.next_tick_queue.pop_front() {
            cb_vec.push_back(f);
        }
        while let Some(f) = self.immediate_queue.pop_front() {
            cb_vec.push_back(f);
        }
        while let Some(f) = cb_vec.pop_front() {
            f();
            i += 1;
        }
        i
    }

    pub fn set_next_tick(&mut self, callback: Box<dyn FnOnce()>) {
        self.next_tick_queue.push_back(callback);
    }
}
"
test/crypto/test-crypto-dh.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
const dh1 = crypto.createDiffieHellman(size);
const p1 = dh1.getPrime('buffer');
const dh2 = crypto.createDiffieHellman(p1, 'buffer');
const key1 = dh1.generateKeys();
const key2 = dh2.generateKeys('hex');
const secret1 = dh1.computeSecret(key2, 'hex', 'base64');
const secret2 = dh2.computeSecret(key1, 'latin1', 'buffer');

// Test Diffie-Hellman with two parties sharing a secret,
// using various encodings as we go along
assert.strictEqual(secret2.toString('base64'), secret1);
assert.strictEqual(dh1.verifyError, 0);
assert.strictEqual(dh2.verifyError, 0);

// https://github.com/nodejs/node/issues/32738
// XXX(bnoordhuis) validateInt32() throwing ERR_OUT_OF_RANGE and RangeError
// instead of ERR_INVALID_ARG_TYPE and TypeError is questionable, IMO.
assert.throws(() => crypto.createDiffieHellman(13.37), {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""sizeOrKey"" is out of range. ' +
           'It must be an integer. Received 13.37',
});

assert.throws(() => crypto.createDiffieHellman('abcdef', 13.37), {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""generator"" is out of range. ' +
           'It must be an integer. Received 13.37',
});

for (const bits of [-1, 0, 1]) {
  if (common.hasOpenSSL3) {
    assert.throws(() => crypto.createDiffieHellman(bits), {
      code: 'ERR_OSSL_DH_MODULUS_TOO_SMALL',
      name: 'Error',
      message: /modulus too small/,
    });
  } else {
    assert.throws(() => crypto.createDiffieHellman(bits), {
      code: 'ERR_OSSL_BN_BITS_TOO_SMALL',
      name: 'Error',
      message: /bits too small/,
    });
  }
}

// Through a fluke of history, g=0 defaults to DH_GENERATOR (2).
{
  const g = 0;
  crypto.createDiffieHellman('abcdef', g);
  crypto.createDiffieHellman('abcdef', 'hex', g);
}

for (const g of [-1, 1]) {
  const ex = {
    code: 'ERR_OSSL_DH_BAD_GENERATOR',
    name: 'Error',
    message: /bad generator/,
  };
  assert.throws(() => crypto.createDiffieHellman('abcdef', g), ex);
  assert.throws(() => crypto.createDiffieHellman('abcdef', 'hex', g), ex);
}

crypto.createDiffieHellman('abcdef', Buffer.from([2]));  // OK

for (const g of [Buffer.from([]),
                 Buffer.from([0]),
                 Buffer.from([1])]) {
  const ex = {
    code: 'ERR_OSSL_DH_BAD_GENERATOR',
    name: 'Error',
    message: /bad generator/,
  };
  assert.throws(() => crypto.createDiffieHellman('abcdef', g), ex);
  assert.throws(() => crypto.createDiffieHellman('abcdef', 'hex', g), ex);
}

[
  [0x1, 0x2],
  () => { },
  /abc/,
  {},
].forEach((input) => {
  assert.throws(
    () => crypto.createDiffieHellman(input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    }
  );
});

// Create ""another dh1"" using generated keys from dh1,
// and compute secret again
const dh3 = crypto.createDiffieHellman(p1, 'buffer');
const privkey1 = dh1.getPrivateKey();
dh3.setPublicKey(key1);
dh3.setPrivateKey(privkey1);

assert.deepStrictEqual(dh1.getPrime(), dh3.getPrime());
assert.deepStrictEqual(dh1.getGenerator(), dh3.getGenerator());
assert.deepStrictEqual(dh1.getPublicKey(), dh3.getPublicKey());
assert.deepStrictEqual(dh1.getPrivateKey(), dh3.getPrivateKey());
assert.strictEqual(dh3.verifyError, 0);

const secret3 = dh3.computeSecret(key2, 'hex', 'base64');

assert.strictEqual(secret1, secret3);

// computeSecret works without a public key set at all.
const dh4 = crypto.createDiffieHellman(p1, 'buffer');
dh4.setPrivateKey(privkey1);

assert.deepStrictEqual(dh1.getPrime(), dh4.getPrime());
assert.deepStrictEqual(dh1.getGenerator(), dh4.getGenerator());
assert.deepStrictEqual(dh1.getPrivateKey(), dh4.getPrivateKey());
assert.strictEqual(dh4.verifyError, 0);

const secret4 = dh4.computeSecret(key2, 'hex', 'base64');

assert.strictEqual(secret1, secret4);

let wrongBlockLength;
if (common.hasOpenSSL3) {
  wrongBlockLength = {
    message: 'error:1C80006B:Provider routines::wrong final block length',
    code: 'ERR_OSSL_WRONG_FINAL_BLOCK_LENGTH',
    library: 'Provider routines',
    reason: 'wrong final block length'
  };
} else {
  wrongBlockLength = {
    message: 'error:0606506D:digital envelope' +
      ' routines:EVP_DecryptFinal_ex:wrong final block length',
    code: 'ERR_OSSL_EVP_WRONG_FINAL_BLOCK_LENGTH',
    library: 'digital envelope routines',
    reason: 'wrong final block length'
  };
}

// Run this one twice to make sure that the dh3 clears its error properly
{
  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
  assert.throws(() => {
    c.final('utf8');
  }, wrongBlockLength);
}

{
  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
  assert.throws(() => {
    c.final('utf8');
  }, wrongBlockLength);
}

assert.throws(() => {
  dh3.computeSecret('');
}, { message: common.hasOpenSSL3 ?
  'error:02800080:Diffie-Hellman routines::invalid secret' :
  'Supplied key is too small' });

// Invalid test: curve argument is undefined
assert.throws(
  () => crypto.createECDH(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""curve"" argument must be of type string. ' +
            'Received undefined'
  });

assert.throws(
  function() {
    crypto.getDiffieHellman('unknown-group');
  },
  {
    name: 'Error',
    code: 'ERR_CRYPTO_UNKNOWN_DH_GROUP',
    message: 'Unknown DH group'
  },
  'crypto.getDiffieHellman(\'unknown-group\') ' +
  'failed to throw the expected error.'
);

assert.throws(
  () => crypto.createDiffieHellman('', true),
  {
    code: 'ERR_INVALID_ARG_TYPE'
  }
);
[true, Symbol(), {}, () => {}, []].forEach((generator) => assert.throws(
  () => crypto.createDiffieHellman('', 'base64', generator),
  { code: 'ERR_INVALID_ARG_TYPE' }
));
"
test/fs/test-fs-write-buffer.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
const expected = Buffer.from('hello');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// fs.write with all parameters provided:
{
  const filename = path.join(tmpdir.path, 'write1.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    fs.write(fd, expected, 0, expected.length, null, cb);
  }));
}

// fs.write with a buffer, without the length parameter:
{
  const filename = path.join(tmpdir.path, 'write2.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, 2);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, 'lo');
    });

    fs.write(fd, Buffer.from('hello'), 3, cb);
  }));
}

// fs.write with a buffer, without the offset and length parameters:
{
  const filename = path.join(tmpdir.path, 'write3.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.deepStrictEqual(expected.toString(), found);
    });

    fs.write(fd, expected, cb);
  }));
}

// fs.write with the offset passed as undefined followed by the callback:
{
  const filename = path.join(tmpdir.path, 'write4.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.deepStrictEqual(expected.toString(), found);
    });

    fs.write(fd, expected, undefined, cb);
  }));
}

// fs.write with offset and length passed as undefined followed by the callback:
{
  const filename = path.join(tmpdir.path, 'write5.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    fs.write(fd, expected, undefined, undefined, cb);
  }));
}

// fs.write with a Uint8Array, without the offset and length parameters:
{
  const filename = path.join(tmpdir.path, 'write6.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    fs.write(fd, Uint8Array.from(expected), cb);
  }));
}

// fs.write with invalid offset type
{
  const filename = path.join(tmpdir.path, 'write7.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    assert.throws(() => {
      fs.write(fd,
               Buffer.from('abcd'),
               NaN,
               expected.length,
               0,
               common.mustNotCall());
    }, {
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""offset"" is out of range. ' +
               'It must be an integer. Received NaN'
    });

    fs.closeSync(fd);
  }));
}

// fs.write with a DataView, without the offset and length parameters:
{
  const filename = path.join(tmpdir.path, 'write8.txt');
  fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
    const cb = common.mustSucceed((written) => {
      assert.strictEqual(written, expected.length);
      fs.closeSync(fd);

      const found = fs.readFileSync(filename, 'utf8');
      assert.strictEqual(found, expected.toString());
    });

    const uint8 = Uint8Array.from(expected);
    fs.write(fd, new DataView(uint8.buffer), cb);
  }));
}
"
modules/util.js,"import { promisify, deprecate } from ""./internal/util.js"";
import { debuglog } from ""./internal/util/debuglog.js"";
import types from ""util/types"";
import { Buffer } from ""buffer"";
import { ERR_INVALID_ARG_TYPE } from ""./internal/errors.js"";
import * as encoding from 'encoding';

export const debuglog = debuglog
export const promisify = promisify;
export const deprecate = deprecate;

class NodeFalsyValueRejectionError extends Error {
    reason;
    code = ""ERR_FALSY_VALUE_REJECTION"";
    constructor(reason) {
        super(""Promise was rejected with falsy value"");
        this.reason = reason;
    }
}

class NodeInvalidArgTypeError extends TypeError {
    code = ""ERR_INVALID_ARG_TYPE"";
    constructor(argumentName) {
        super(`The ${argumentName} argument must be of type function.`);
    }
}

function callbackify(original) {
    if (typeof original !== ""function"") {
        throw new NodeInvalidArgTypeError('""original""');
    }

    const callbackified = function (_this, ...args) {
        const maybeCb = args.pop();
        if (typeof maybeCb !== ""function"") {
            throw new NodeInvalidArgTypeError(""last"");
        }
        const cb = (...args) => {
            maybeCb.apply(_this, args);
        };
        original.apply(_this, args).then(
            (ret) => {
                nextTick(cb.bind(_this, null, ret));
            },
            (rej) => {
                rej = rej || new NodeFalsyValueRejectionError(rej);
                nextTick(cb.bind(_this, rej));
            },
        );
    };

    const descriptors = Object.getOwnPropertyDescriptors(original);
    // It is possible to manipulate a functions `length` or `name` property. This
    // guards against the manipulation.
    if (typeof descriptors.length.value === ""number"") {
        descriptors.length.value++;
    }
    if (typeof descriptors.name.value === ""string"") {
        descriptors.name.value += ""Callbackified"";
    }
    Object.defineProperties(callbackified, descriptors);
    return callbackified;
}

export function isArray(value) {
    return Array.isArray(value);
}

export function isBoolean(value) {
    return typeof value === ""boolean"" || value instanceof Boolean;
}

export function isNull(value) {
    return value === null;
}

export function isNullOrUndefined(value) {
    return value === null || value === undefined;
}

export function isNumber(value) {
    return typeof value === ""number"" || value instanceof Number;
}

export function isString(value) {
    return typeof value === ""string"" || value instanceof String;
}

export function isSymbol(value) {
    return typeof value === ""symbol"";
}

export function isUndefined(value) {
    return value === undefined;
}

export function isObject(value) {
    return value !== null && typeof value === ""object"";
}

export function isError(e) {
    return e instanceof Error;
}

export function isFunction(value) {
    return typeof value === ""function"";
}

export function isRegExp(value) {
    return types.isRegExp(value);
}

export function isDate(value) {
    return types.isDate(value);
}

export function isPrimitive(value) {
    return (
        value === null || (typeof value !== ""object"" && typeof value !== ""function"")
    );
}

export function isBuffer(value) {
    return Buffer.isBuffer(value);
}

export function _extend(target, source) {
    // Don't do anything if source isn't an object
    if (source === null || typeof source !== ""object"") return target;

    const keys = Object.keys(source);
    let i = keys.length;
    while (i--) {
        target[keys[i]] = source[keys[i]];
    }
    return target;
}

export function inherits(ctor, superCtor) {
    if (ctor === undefined || ctor === null) {
        throw new ERR_INVALID_ARG_TYPE(""ctor"", ""Function"", ctor);
    }

    if (superCtor === undefined || superCtor === null) {
        throw new ERR_INVALID_ARG_TYPE(""superCtor"", ""Function"", superCtor);
    }

    if (superCtor.prototype === undefined) {
        throw new ERR_INVALID_ARG_TYPE(
            ""superCtor.prototype"",
            ""Object"",
            superCtor.prototype,
        );
    }
    Object.defineProperty(ctor, ""super_"", {
        value: superCtor,
        writable: true,
        configurable: true,
    });
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}

export const TextDecoder = encoding.TextDecoder;
export const TextEncoder = encoding.TextEncoder;

function pad(n) {
    return n.toString().padStart(2, ""0"");
}

const months = [
    ""Jan"",
    ""Feb"",
    ""Mar"",
    ""Apr"",
    ""May"",
    ""Jun"",
    ""Jul"",
    ""Aug"",
    ""Sep"",
    ""Oct"",
    ""Nov"",
    ""Dec"",
];

function timestamp() {
    const d = new Date();
    const t = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds()),
    ].join("":"");
    return `${(d.getDate())} ${months[(d).getMonth()]} ${t}`;
}

export function log(...args) {
    console.log(timestamp(), '-', ...args);
}

export default {
    isArray,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isSymbol,
    isUndefined,
    isObject,
    isError,
    isFunction,
    isRegExp,
    isDate,
    isPrimitive,
    isBuffer,
    _extend,
    deprecate,
    callbackify,
    promisify,
    inherits,
    types,
    TextDecoder,
    TextEncoder,
    log,
    debuglog,
};
"
test/fs/test-fs-promises-file-handle-writeFile.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.writeFile method.

import fs from 'fs';
const { open, writeFile } = fs.promises;
import path from 'path';
import { Readable } from 'stream';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateWriteFile() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-write-file2.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  try {
    const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

    await fileHandle.writeFile(buffer);
    const readFileData = fs.readFileSync(filePathForHandle);
    assert.deepStrictEqual(buffer, readFileData);
  } finally {
    await fileHandle.close();
  }
}

// Signal aborted while writing file
async function doWriteAndCancel() {
  const filePathForHandle = path.resolve(tmpDir, 'dogs-running.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  try {
    const buffer = Buffer.from('dogs running'.repeat(512 * 1024), 'utf8');
    const controller = new AbortController();
    const { signal } = controller;
    process.nextTick(() => controller.abort());
    await assert.rejects(writeFile(fileHandle, buffer, { signal }), {
      name: 'AbortError'
    });
  } finally {
    await fileHandle.close();
  }
}

const dest = path.resolve(tmpDir, 'tmp.txt');
const otherDest = path.resolve(tmpDir, 'tmp-2.txt');
const stream = Readable.from(['a', 'b', 'c']);
const stream2 = Readable.from(['mlaut', ' ', 'sechzig']);
const iterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};
function iterableWith(value) {
  return {
    *[Symbol.iterator]() {
      yield value;
    }
  };
}
const bufferIterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield Buffer.from('a');
    yield Buffer.from('b');
    yield Buffer.from('c');
  }
};
const asyncIterable = {
  expected: 'abc',
  async* [Symbol.asyncIterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};

async function doWriteStream() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(stream);
    const expected = 'abc';
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteStreamWithCancel() {
  const controller = new AbortController();
  const { signal } = controller;
  process.nextTick(() => controller.abort());
  const fileHandle = await open(otherDest, 'w+');
  try {
    await assert.rejects(
      fileHandle.writeFile(stream, { signal }),
      { name: 'AbortError' }
    );
  } finally {
    await fileHandle.close();
  }
}

async function doWriteIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(iterable);
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, iterable.expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteInvalidIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await Promise.all(
      [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
        assert.rejects(
          fileHandle.writeFile(iterableWith(value)),
          { code: 'ERR_INVALID_ARG_TYPE' }
        )
      )
    );
  } finally {
    await fileHandle.close();
  }
}

async function doWriteIterableWithEncoding() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(stream2, 'latin1');
    const expected = 'mlaut sechzig';
    const data = fs.readFileSync(dest, 'latin1');
    assert.deepStrictEqual(data, expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteBufferIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(bufferIterable);
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, bufferIterable.expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteAsyncIterable() {
  const fileHandle = await open(dest, 'w+');
  try {
    await fileHandle.writeFile(asyncIterable);
    const data = fs.readFileSync(dest, 'utf-8');
    assert.deepStrictEqual(data, asyncIterable.expected);
  } finally {
    await fileHandle.close();
  }
}

async function doWriteInvalidValues() {
  const fileHandle = await open(dest, 'w+');
  try {
    await Promise.all(
      [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
        assert.rejects(
          fileHandle.writeFile(value),
          { code: 'ERR_INVALID_ARG_TYPE' }
        )
      )
    );
  } finally {
    await fileHandle.close();
  }
}

(async () => {
  await validateWriteFile();
  //await doWriteAndCancel();
  await doWriteStream();
  //await doWriteStreamWithCancel();
  await doWriteIterable();
  await doWriteInvalidIterable();
  await doWriteIterableWithEncoding();
  await doWriteBufferIterable();
  await doWriteAsyncIterable();
  await doWriteInvalidValues();
})().then(common.mustCall());
"
test/crypto/test-crypto-x509.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-internals
'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const {
  X509Certificate,
  createPrivateKey,
} = require('crypto');

const {
  isX509Certificate
} = require('internal/crypto/x509');

const assert = require('assert');
const fixtures = require('../common/fixtures');
const { readFileSync } = require('fs');

const cert = readFileSync(fixtures.path('keys', 'agent1-cert.pem'));
const key = readFileSync(fixtures.path('keys', 'agent1-key.pem'));
const ca = readFileSync(fixtures.path('keys', 'ca1-cert.pem'));

const privateKey = createPrivateKey(key);

[1, {}, false, null].forEach((i) => {
  assert.throws(() => new X509Certificate(i), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

const subjectCheck = `C=US
ST=CA
L=SF
O=Joyent
OU=Node.js
CN=agent1
emailAddress=ry@tinyclouds.org`;

const issuerCheck = `C=US
ST=CA
L=SF
O=Joyent
OU=Node.js
CN=ca1
emailAddress=ry@tinyclouds.org`;

let infoAccessCheck = `OCSP - URI:http://ocsp.nodejs.org/
CA Issuers - URI:http://ca.nodejs.org/ca.cert`;
if (!common.hasOpenSSL3)
  infoAccessCheck += '\n';

const der = Buffer.from(
  '308202d830820241a003020102020900ecc9b856270da9a830' +
  '0d06092a864886f70d01010b0500307a310b30090603550406' +
  '13025553310b300906035504080c024341310b300906035504' +
  '070c025346310f300d060355040a0c064a6f79656e74311030' +
  '0e060355040b0c074e6f64652e6a73310c300a06035504030c' +
  '036361313120301e06092a864886f70d010901161172794074' +
  '696e79636c6f7564732e6f72673020170d3138313131363138' +
  '343232315a180f32323932303833303138343232315a307d31' +
  '0b3009060355040613025553310b300906035504080c024341' +
  '310b300906035504070c025346310f300d060355040a0c064a' +
  '6f79656e743110300e060355040b0c074e6f64652e6a73310f' +
  '300d06035504030c066167656e74313120301e06092a864886' +
  'f70d010901161172794074696e79636c6f7564732e6f726730' +
  '819f300d06092a864886f70d010101050003818d0030818902' +
  '818100ef5440701637e28abb038e5641f828d834c342a9d25e' +
  'dbb86a2bf6fbd809cb8e037a98b71708e001242e4deb54c616' +
  '4885f599dd87a23215745955be20417e33c4d0d1b80c9da3de' +
  '419a2607195d2fb75657b0bbfb5eb7d0bba5122d1b6964c7b5' +
  '70d50b8ec001eeb68dfb584437508f3129928d673b30a3e0bf' +
  '4f50609e63710203010001a361305f305d06082b0601050507' +
  '01010451304f302306082b060105050730018617687474703a' +
  '2f2f6f6373702e6e6f64656a732e6f72672f302806082b0601' +
  '0505073002861c687474703a2f2f63612e6e6f64656a732e6f' +
  '72672f63612e63657274300d06092a864886f70d01010b0500' +
  '038181007acabf1d99e1fb05edbdd54608886dd6c509fc5820' +
  '2be8274f8139b60f8ea219666f7eff9737e92a732b318ef423' +
  '7da94123dcac4f9a28e76fe663b26d42482ac6d66d380bbdfe' +
  '0230083e743e7966671752b82f692e1034e9bfc9d0cd829888' +
  '6c6c996e7c3d231e02ad5399a170b525b74f11d7ed13a7a815' +
  'f4b974253a8d66', 'hex');

{
  const x509 = new X509Certificate(cert);

  assert(isX509Certificate(x509));

  assert(!x509.ca);
  assert.strictEqual(x509.subject, subjectCheck);
  assert.strictEqual(x509.subjectAltName, undefined);
  assert.strictEqual(x509.issuer, issuerCheck);
  assert.strictEqual(x509.infoAccess, infoAccessCheck);
  assert.strictEqual(x509.validFrom, 'Nov 16 18:42:21 2018 GMT');
  assert.strictEqual(x509.validTo, 'Aug 30 18:42:21 2292 GMT');
  assert.strictEqual(
    x509.fingerprint,
    'D7:FD:F6:42:92:A8:83:51:8E:80:48:62:66:DA:85:C2:EE:A6:A1:CD');
  assert.strictEqual(
    x509.fingerprint256,
    'B0:BE:46:49:B8:29:63:E0:6F:63:C8:8A:57:9C:3F:9B:72:C6:F5:89:E3:0D:' +
    '84:AC:5B:08:9A:20:89:B6:8F:D6'
  );
  assert.strictEqual(
    x509.fingerprint512,
    'D0:05:01:82:2C:D8:09:BE:27:94:E7:83:F1:88:BC:7A:8B:D0:39:97:54:B6:' +
    'D0:B4:46:5B:DE:13:5B:68:86:B6:F2:A8:95:22:D5:6E:8B:35:DA:89:29:CA:' +
    'A3:06:C5:CE:43:C1:7F:2D:7E:5F:44:A5:EE:A3:CB:97:05:A3:E3:68'
  );
  assert.strictEqual(x509.keyUsage, undefined);
  assert.strictEqual(x509.serialNumber, 'ECC9B856270DA9A8');

  assert.deepStrictEqual(x509.raw, der);

  assert(x509.publicKey);
  assert.strictEqual(x509.publicKey.type, 'public');

  assert.strictEqual(x509.toString().replaceAll('\r\n', '\n'),
                     cert.toString().replaceAll('\r\n', '\n'));
  assert.strictEqual(x509.toJSON(), x509.toString());

  assert(x509.checkPrivateKey(privateKey));
  assert.throws(() => x509.checkPrivateKey(x509.publicKey), {
    code: 'ERR_INVALID_ARG_VALUE'
  });

  assert.strictEqual(x509.checkIP('127.0.0.1'), undefined);
  assert.strictEqual(x509.checkIP('::'), undefined);
  assert.strictEqual(x509.checkHost('agent1'), 'agent1');
  assert.strictEqual(x509.checkHost('agent2'), undefined);
  assert.strictEqual(x509.checkEmail('ry@tinyclouds.org'), 'ry@tinyclouds.org');
  assert.strictEqual(x509.checkEmail('sally@example.com'), undefined);
  assert.throws(() => x509.checkHost('agent\x001'), {
    code: 'ERR_INVALID_ARG_VALUE'
  });
  assert.throws(() => x509.checkIP('[::]'), {
    code: 'ERR_INVALID_ARG_VALUE'
  });
  assert.throws(() => x509.checkEmail('not\x00hing'), {
    code: 'ERR_INVALID_ARG_VALUE'
  });

  [1, false, null].forEach((i) => {
    assert.throws(() => x509.checkHost('agent1', i), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
    assert.throws(() => x509.checkHost('agent1', { subject: i }), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  });

  [
    'wildcards',
    'partialWildcards',
    'multiLabelWildcards',
    'singleLabelSubdomains',
  ].forEach((key) => {
    [1, '', null, {}].forEach((i) => {
      assert.throws(() => x509.checkHost('agent1', { [key]: i }), {
        code: 'ERR_INVALID_ARG_TYPE'
      });
    });
  });

  const ca_cert = new X509Certificate(ca);

  assert(x509.checkIssued(ca_cert));
  assert(!x509.checkIssued(x509));
  assert(x509.verify(ca_cert.publicKey));
  assert(!x509.verify(x509.publicKey));

  assert.throws(() => x509.checkIssued({}), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.checkIssued(''), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.verify({}), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.verify(''), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
  assert.throws(() => x509.verify(privateKey), {
    code: 'ERR_INVALID_ARG_VALUE'
  });

  // X509Certificate can be cloned via MessageChannel/MessagePort
  const mc = new MessageChannel();
  mc.port1.onmessage = common.mustCall(({ data }) => {
    assert(isX509Certificate(data));
    assert.deepStrictEqual(data.raw, x509.raw);
    mc.port1.close();
  });
  mc.port2.postMessage(x509);

  // Verify that legacy encoding works
  const legacyObjectCheck = {
    subject: Object.assign(Object.create(null), {
      C: 'US',
      ST: 'CA',
      L: 'SF',
      O: 'Joyent',
      OU: 'Node.js',
      CN: 'agent1',
      emailAddress: 'ry@tinyclouds.org',
    }),
    issuer: Object.assign(Object.create(null), {
      C: 'US',
      ST: 'CA',
      L: 'SF',
      O: 'Joyent',
      OU: 'Node.js',
      CN: 'ca1',
      emailAddress: 'ry@tinyclouds.org',
    }),
    infoAccess: Object.assign(Object.create(null), {
      'OCSP - URI': ['http://ocsp.nodejs.org/'],
      'CA Issuers - URI': ['http://ca.nodejs.org/ca.cert']
    }),
    modulus: 'EF5440701637E28ABB038E5641F828D834C342A9D25EDBB86A2BF' +
             '6FBD809CB8E037A98B71708E001242E4DEB54C6164885F599DD87' +
             'A23215745955BE20417E33C4D0D1B80C9DA3DE419A2607195D2FB' +
             '75657B0BBFB5EB7D0BBA5122D1B6964C7B570D50B8EC001EEB68D' +
             'FB584437508F3129928D673B30A3E0BF4F50609E6371',
    bits: 1024,
    exponent: '0x10001',
    valid_from: 'Nov 16 18:42:21 2018 GMT',
    valid_to: 'Aug 30 18:42:21 2292 GMT',
    fingerprint: 'D7:FD:F6:42:92:A8:83:51:8E:80:48:62:66:DA:85:C2:EE:A6:A1:CD',
    fingerprint256:
      'B0:BE:46:49:B8:29:63:E0:6F:63:C8:8A:57:9C:3F:9B:72:' +
      'C6:F5:89:E3:0D:84:AC:5B:08:9A:20:89:B6:8F:D6',
    fingerprint512:
      'D0:05:01:82:2C:D8:09:BE:27:94:E7:83:F1:88:BC:7A:8B:' +
      'D0:39:97:54:B6:D0:B4:46:5B:DE:13:5B:68:86:B6:F2:A8:' +
      '95:22:D5:6E:8B:35:DA:89:29:CA:A3:06:C5:CE:43:C1:7F:' +
      '2D:7E:5F:44:A5:EE:A3:CB:97:05:A3:E3:68',
    serialNumber: 'ECC9B856270DA9A8'
  };

  const legacyObject = x509.toLegacyObject();

  assert.deepStrictEqual(legacyObject.raw, x509.raw);
  assert.deepStrictEqual(legacyObject.subject, legacyObjectCheck.subject);
  assert.deepStrictEqual(legacyObject.issuer, legacyObjectCheck.issuer);
  assert.deepStrictEqual(legacyObject.infoAccess, legacyObjectCheck.infoAccess);
  assert.strictEqual(legacyObject.modulus, legacyObjectCheck.modulus);
  assert.strictEqual(legacyObject.bits, legacyObjectCheck.bits);
  assert.strictEqual(legacyObject.exponent, legacyObjectCheck.exponent);
  assert.strictEqual(legacyObject.valid_from, legacyObjectCheck.valid_from);
  assert.strictEqual(legacyObject.valid_to, legacyObjectCheck.valid_to);
  assert.strictEqual(legacyObject.fingerprint, legacyObjectCheck.fingerprint);
  assert.strictEqual(
    legacyObject.fingerprint256,
    legacyObjectCheck.fingerprint256);
  assert.strictEqual(
    legacyObject.serialNumber,
    legacyObjectCheck.serialNumber);
}
"
test/fs/test-fs-read-type.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');
const expected = 'xyz\n';

/* Undocumented api call way
// Error must be thrown with string
assert.throws(
  () => fs.read(fd, expected.length, 0, 'utf-8', common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""buffer"" argument must be an instance of Buffer, ' +
             'TypedArray, or DataView. Received type number (4)'
  }
);
*/
[true, null, undefined, () => {}, {}].forEach((value) => {
  assert.throws(() => {
    fs.read(value,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            0,
            common.mustNotCall());
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

assert.throws(() => {
  fs.read(fd,
          Buffer.allocUnsafe(expected.length),
          -1,
          expected.length,
          0,
          common.mustNotCall());
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
});

assert.throws(() => {
  fs.read(fd,
          Buffer.allocUnsafe(expected.length),
          NaN,
          expected.length,
          0,
          common.mustNotCall());
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""offset"" is out of range. It must be an integer. ' +
           'Received NaN'
});

assert.throws(() => {
  fs.read(fd,
          Buffer.allocUnsafe(expected.length),
          0,
          -1,
          0,
          common.mustNotCall());
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: /""length"".*-1/
});

[true, () => {}, {}, ''].forEach((value) => {
  assert.throws(() => {
    fs.read(fd,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            value,
            common.mustNotCall());
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

[0.5, 2 ** 53, 2n ** 63n].forEach((value) => {
  assert.throws(() => {
    fs.read(fd,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            value,
            common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError'
  });
});

fs.read(fd,
        Buffer.allocUnsafe(expected.length),
        0,
        expected.length,
        0n,
        common.mustSucceed());

fs.read(fd,
        Buffer.allocUnsafe(expected.length),
        0,
        expected.length,
        2n ** 53n - 1n,
        common.mustCall((err) => {
          if (err) {
            if (common.isIBMi)
              assert.strictEqual(err.code, 'EOVERFLOW');
            else
              assert.strictEqual(err.code, 'EFBIG');
          }
        }));
/* Undocumented api call way
assert.throws(
  () => fs.readSync(fd, expected.length, 0, 'utf-8'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""buffer"" argument must be an instance of Buffer, ' +
             'TypedArray, or DataView. Received type number (4)'
  }
);
*/
[true, null, undefined, () => {}, {}].forEach((value) => {
  assert.throws(() => {
    fs.readSync(value,
                Buffer.allocUnsafe(expected.length),
                0,
                expected.length,
                0);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              -1,
              expected.length,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              NaN,
              expected.length,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""offset"" is out of range. It must be an integer. ' +
           'Received NaN'
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              0,
              -1,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: /""length"".*-1/
});

assert.throws(() => {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              0,
              expected.length + 1,
              0);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: /""length"".*5/
});

[true, () => {}, {}, ''].forEach((value) => {
  assert.throws(() => {
    fs.readSync(fd,
                Buffer.allocUnsafe(expected.length),
                0,
                expected.length,
                value);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
});

[0.5, 2 ** 53, 2n ** 63n].forEach((value) => {
  assert.throws(() => {
    fs.readSync(fd,
                Buffer.allocUnsafe(expected.length),
                0,
                expected.length,
                value);
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError'
  });
});

fs.readSync(fd,
            Buffer.allocUnsafe(expected.length),
            0,
            expected.length,
            0n);

try {
  fs.readSync(fd,
              Buffer.allocUnsafe(expected.length),
              0,
              expected.length,
              2n ** 53n - 1n);
} catch (err) {
  // On systems where max file size is below 2^53-1, we'd expect a EFBIG error.
  // This is not using `assert.throws` because the above call should not raise
  // any error on systems that allows file of that size.
  if (err.code !== 'EFBIG' && !(common.isIBMi && err.code === 'EOVERFLOW'))
    throw err;
}"
modules/crypto.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.

import { ERR_CRYPTO_FIPS_FORCED, ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH, ERR_INVALID_ARG_TYPE } from ""./internal/errors"";
import { crypto as constants } from ""./internal_binding/constants"";
import { getOptionValue } from ""./internal/options"";
import { isAnyArrayBuffer, isArrayBufferView } from ""./internal/util/types"";
import {
  timing_safe_equal,
} from ""_node:crypto"";
function timingSafeEqual(a, b) {
  if (!isAnyArrayBuffer(a) && !isArrayBufferView(a)) {
    throw new ERR_INVALID_ARG_TYPE(""buf1"", [""ArrayBuffer"", ""Buffer"", ""TypedArray"", ""DataView""], a);
  }
  if (!isAnyArrayBuffer(b) && !isArrayBufferView(b)) {
    throw new ERR_INVALID_ARG_TYPE(""buf2"", [""ArrayBuffer"", ""Buffer"", ""TypedArray"", ""DataView""], b);
  }
  if (a.byteLength != b.byteLength) {
    throw new ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH();
  }
  return timing_safe_equal(a.buffer, b.buffer);
}

import {
  checkPrime,
  checkPrimeSync,
  generatePrime,
  generatePrimeSync,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
} from ""./internal/crypto/random"";
import { pbkdf2, pbkdf2Sync } from ""./internal/crypto/pbkdf2"";
import { scrypt, scryptSync } from ""./internal/crypto/scrypt"";
import { hkdf, hkdfSync } from ""./internal/crypto/hkdf"";
/*import {
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,
} from ""./internal/crypto/keygen"";*/
import {
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  KeyObject,
} from ""./internal/crypto/keys"";/*
import {
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
} from ""./internal/crypto/diffiehellman"";*/
import {
  Cipheriv,
  Decipheriv,
  getCipherInfo,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
} from ""./internal/crypto/cipher"";
/*
import {
  Sign,
  signOneShot,
  Verify,
  verifyOneShot,
} from ""./internal/crypto/sig"";*/
import { Hash, Hmac } from ""./internal/crypto/hash"";/*
import { X509Certificate } from ""./internal/crypto/x509"";
*/import {
  getCiphers,
  getCurves,
  getHashes,
  secureHeapUsed,
  setEngine,
} from ""./internal/crypto/util"";/*
import Certificate from ""./internal/crypto/certificate"";
*/
const webcrypto = undefined;
const fipsForced = getOptionValue(""--force-fips"");

function createCipheriv(cipher, key, iv, options) {
  return new Cipheriv(cipher, key, iv, options);
}

function createDecipheriv(algorithm, key, iv, options) {
  return new Decipheriv(algorithm, key, iv, options);
}
/*
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
  return new DiffieHellman(
    sizeOrKey,
    keyEncoding,
    generator,
    generatorEncoding,
  );
}

function createDiffieHellmanGroup(name) {
  return new DiffieHellmanGroup(name);
}

function createECDH(curve) {
  return new ECDH(curve);
}
*/
function createHash(hash, options) {
  return new Hash(hash, options);
}

function createHmac(hmac, key, options) {
  return new Hmac(hmac, key, options);
}
/*
function createSign(algorithm, options) {
  return new Sign(algorithm, options);
}

function createVerify(algorithm, options) {
  return new Verify(algorithm, options);
}
*/
function setFipsForced(val) {
  if (val) {
    return;
  }

  throw new ERR_CRYPTO_FIPS_FORCED();
}

function getFipsForced() {
  return 1;
}

Object.defineProperty(constants, ""defaultCipherList"", {
  value: getOptionValue(""--tls-cipher-list""),
});
/*
const getDiffieHellman = createDiffieHellmanGroup;
*/
function getFipsCrypto() {
  throw new Error(""crypto.getFipsCrypto is unimplemented"")
}
function setFipsCrypto(_val) {
  throw new Error(""crypto.setFipsCrypto is unimplemented"")
}
const getFips = fipsForced ? getFipsForced : getFipsCrypto;
const setFips = fipsForced ? setFipsForced : setFipsCrypto;
/*
const sign = signOneShot;
const verify = verifyOneShot;
*/
export default {
  /*Certificate,*/
  checkPrime,
  checkPrimeSync,
  Cipheriv,
  constants,
  createCipheriv,
  createDecipheriv,/*
  createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,*/
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,/*
  createSign,
  createVerify,*/
  Decipheriv,/*
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,*/
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,/*
  getDiffieHellman,*/
  getFips,
  getHashes,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,/*
  KeyObject,*/
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,/*
  Sign,
  sign,*/
  timingSafeEqual,
  /*Verify,
  verify,
  webcrypto,
  X509Certificate,*/
};

export {
  /*Certificate,*/
  checkPrime,
  checkPrimeSync,
  Cipheriv,
  constants,
  createCipheriv,
  createDecipheriv,
  /*createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,*/
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,/*
  createSign,
  createVerify,*/
  Decipheriv,/*
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,*/
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,/*
  getDiffieHellman,*/
  getFips,
  getHashes,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,/*
  KeyObject,*/
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,
  /*Sign,
  sign,*/
  timingSafeEqual,
  /*Verify,
  verify,*/
  webcrypto,
  /*X509Certificate,*/
};
"
test/fs/test-fs-write-file-sync.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

if (!common.isMainThread)
  common.skip('Setting process.umask is not supported in Workers');

import assert from 'assert';
import path from 'path';
import fs from 'fs';
import process from 'process';

// On Windows chmod is only able to manipulate read-only bit. Test if creating
// the file in read-only mode works.
const mode = common.isWindows ? 0o444 : 0o755;

// Reset the umask for testing
process.umask(0o000);

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test writeFileSync
{
  const file = path.join(tmpdir.path, 'testWriteFileSync.txt');

  fs.writeFileSync(file, '123', { mode });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, '123');
  // assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
}

// Test appendFileSync
{
  const file = path.join(tmpdir.path, 'testAppendFileSync.txt');

  fs.appendFileSync(file, 'abc', { mode });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, 'abc');
  // assert.strictEqual(fs.statSync(file).mode & mode, mode);
}

// Test writeFileSync with file descriptor
{
  // Need to hijack fs.open/close to make sure that things
  // get closed once they're opened.
  const _openSync = fs.openSync;
  const _closeSync = fs.closeSync;
  let openCount = 0;

  fs.openSync = (...args) => {
    openCount++;
    return _openSync(...args);
  };

  fs.closeSync = (...args) => {
    openCount--;
    return _closeSync(...args);
  };

  const file = path.join(tmpdir.path, 'testWriteFileSyncFd.txt');
  const fd = fs.openSync(file, 'w+', mode);

  fs.writeFileSync(fd, '123');
  fs.closeSync(fd);
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, '123');
  // assert.strictEqual(fs.statSync(file).mode & 0o777, mode);

  // Verify that all opened files were closed.
  assert.strictEqual(openCount, 0);
  fs.openSync = _openSync;
  fs.closeSync = _closeSync;
}

// Test writeFileSync with flags
{
  const file = path.join(tmpdir.path, 'testWriteFileSyncFlags.txt');

  fs.writeFileSync(file, 'hello ', { encoding: 'utf8', flag: 'a' });
  fs.writeFileSync(file, 'world!', { encoding: 'utf8', flag: 'a' });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, 'hello world!');
}

// Test writeFileSync with an object with an own toString function
{
  // Runtime deprecated by DEP0162
  common.expectWarning('DeprecationWarning',
                       'Implicit coercion of objects with own toString property is deprecated.',
                       'DEP0162');
  const file = path.join(tmpdir.path, 'testWriteFileSyncStringify.txt');
  const data = {
    toString() {
      return 'hello world!';
    }
  };

  fs.writeFileSync(file, data, { encoding: 'utf8', flag: 'a' });
  const content = fs.readFileSync(file, { encoding: 'utf8' });
  assert.strictEqual(content, String(data));
}
"
modules/internal/streams/buffer_list.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { Buffer } from ""buffer"";

class BufferList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }

    push(v) {
        const entry = { data: v, next: null };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }

    unshift(v) {
        const entry = { data: v, next: this.head };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }

    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }

    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }

    join(s) {
        if (this.length === 0) {
            return """";
        }
        let p = this.head;
        let ret = """" + p.data;
        while (p = p.next) {
            ret += s + p.data;
        }
        return ret;
    }

    concat(n) {
        if (this.length === 0) {
            return Buffer.alloc(0);
        }
        const ret = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
            ret.set(p.data, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
    consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
            // `slice` is the same for buffers and strings.
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
        }
        if (n === data.length) {
            // First chunk is a perfect match.
            return this.shift();
        }
        // Result spans more than one buffer.
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    first() {
        return this.head.data;
    }

    *[Symbol.iterator]() {
        for (let p = this.head; p; p = p.next) {
            yield p.data;
        }
    }

    // Consumes a specified amount of characters from the buffered data.
    _getString(n) {
        let ret = """";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        } while (p = p.next);
        this.length -= c;
        return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
    _getBuffer(n) {
        const ret = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(
                        new Uint8Array(buf.buffer, buf.byteOffset, n),
                        retLen - n,
                    );
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        } while (p = p.next);
        this.length -= c;
        return ret;
    }
}

export default BufferList;"
test/fs/test-fs-chmod.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

let mode_async;
let mode_sync;

// Need to hijack fs.open/close to make sure that things
// get closed once they're opened.
fs._open = fs.open;
fs._openSync = fs.openSync;
fs.open = open;
fs.openSync = openSync;
fs._close = fs.close;
fs._closeSync = fs.closeSync;
fs.close = close;
fs.closeSync = closeSync;

let openCount = 0;

function open() {
  openCount++;
  return fs._open.apply(fs, arguments);
}

function openSync() {
  openCount++;
  return fs._openSync.apply(fs, arguments);
}

function close() {
  openCount--;
  return fs._close.apply(fs, arguments);
}

function closeSync() {
  openCount--;
  return fs._closeSync.apply(fs, arguments);
}


// On Windows chmod is only able to manipulate write permission
if (common.isWindows) {
  mode_async = 0o400;   // read-only
  mode_sync = 0o600;    // read-write
} else {
  mode_async = 0o777;
  mode_sync = 0o644;
}

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const file1 = path.join(tmpdir.path, 'a.js');
const file2 = path.join(tmpdir.path, 'a1.js');

// Create file1.
fs.closeSync(fs.openSync(file1, 'w'));

fs.chmod(file1, mode_async.toString(8), common.mustSucceed(() => {
  if (common.isWindows) {
    assert.ok((fs.statSync(file1).mode & 0o777) & mode_async);
  } else {
    assert.strictEqual(fs.statSync(file1).mode & 0o777, mode_async);
  }

  fs.chmodSync(file1, mode_sync);
  if (common.isWindows) {
    assert.ok((fs.statSync(file1).mode & 0o777) & mode_sync);
  } else {
    assert.strictEqual(fs.statSync(file1).mode & 0o777, mode_sync);
  }
}));

fs.open(file2, 'w', common.mustSucceed((fd) => {
  fs.fchmod(fd, mode_async.toString(8), common.mustSucceed(() => {
    if (common.isWindows) {
      assert.ok((fs.fstatSync(fd).mode & 0o777) & mode_async);
    } else {
      assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode_async);
    }

    assert.throws(
      () => fs.fchmod(fd, {}),
      {
        code: 'ERR_INVALID_ARG_TYPE',
      }
    );

    fs.fchmodSync(fd, mode_sync);
    if (common.isWindows) {
      assert.ok((fs.fstatSync(fd).mode & 0o777) & mode_sync);
    } else {
      assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode_sync);
    }

    fs.close(fd, assert.ifError);
  }));
}));

// lchmod
if (fs.lchmod) {
  const link = path.join(tmpdir.path, 'symbolic-link');

  fs.symlinkSync(file2, link);

  fs.lchmod(link, mode_async, common.mustSucceed(() => {
    assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode_async);

    fs.lchmodSync(link, mode_sync);
    assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode_sync);

  }));
}

[false, 1, {}, [], null, undefined].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""path"" argument must be of type string or an instance ' +
             'of Buffer or URL.' +
             common.invalidArgTypeHelper(input)
  };
  assert.throws(() => fs.chmod(input, 1, common.mustNotCall()), errObj);
  assert.throws(() => fs.chmodSync(input, 1), errObj);
});

process.on('exit', function() {
  assert.strictEqual(openCount, 0);
});
"
src/internal_module/httpx/core/request.rs,"use super::Method;
use super::ParseError;
use super::Version;
use std::collections::HashMap;
use std::fmt::{Display, Formatter};
use std::io::BufRead;

/// Resource requested
#[derive(Debug, PartialEq, Clone)]
pub enum Resource {
    /// A path for a subpage
    Path(String),
}

impl Display for Resource {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let Resource::Path(s) = self;
        write!(f, ""{}"", s)
    }
}

#[derive(Debug, Clone)]
pub struct HttpRequest {
    pub method: Method,
    pub version: Version,
    pub resource: Resource,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

impl HttpRequest {
    pub fn parse(req: &[u8]) -> Result<Self, ParseError> {
        let mut req_header = req;
        let parsed_method;
        let parsed_version;
        let parsed_resource;
        let mut parsed_headers = HashMap::new();
        let mut body_len = 0;

        let mut total = 0;

        {
            let mut line = String::new();
            let n = req_header
                .read_line(&mut line)
                .map_err(|_| ParseError::OtherParseError)?;
            if n == 0 {
                return Err(ParseError::Pending);
            }
            let line = line.trim_end();
            total += n;

            let (method, resource, version) = process_req_line(line)?;
            parsed_method = method;
            parsed_version = version;
            parsed_resource = resource;
        }

        'exit: loop {
            let mut line = String::new();
            let n = req_header
                .read_line(&mut line)
                .map_err(|_| ParseError::OtherParseError)?;
            if n == 0 {
                return Err(ParseError::Pending);
            }
            let line = line.trim_end();
            total += n;

            {
                if line.is_empty() {
                    break 'exit;
                } else if line.contains(':') {
                    let (key, value) = process_header_line(line);
                    if key.to_lowercase().as_str() == ""content-length"" {
                        body_len = value
                            .as_str()
                            .parse()
                            .map_err(|_| ParseError::InvalidHeaders)?;
                    }
                    parsed_headers.insert(key, value);
                } else {
                    return Err(ParseError::InvalidHeaders);
                }
            }
        }

        let body = req
            .get(total..total + body_len)
            .ok_or(ParseError::Pending)?;

        Ok(HttpRequest {
            method: parsed_method,
            version: parsed_version,
            resource: parsed_resource,
            headers: parsed_headers,
            body: body.to_vec(),
        })
    }
}

fn process_req_line(s: &str) -> Result<(Method, Resource, Version), ParseError> {
    let mut words = s.split_whitespace();
    let method = words.next().ok_or(ParseError::InvalidMethod)?;
    let resource = words.next().ok_or(ParseError::InvalidUrl)?;
    let version = words.next().ok_or(ParseError::InvalidVersion)?;

    Ok((
        method.parse()?,
        Resource::Path(resource.to_string()),
        version.parse()?,
    ))
}

fn process_header_line(s: &str) -> (String, String) {
    let mut header_items = s.split(':');
    let mut key = String::from("""");
    let mut value = String::from("""");

    if let Some(k) = header_items.next() {
        key = k.to_lowercase();
    }

    if let Some(v) = header_items.next() {
        value = v.to_string().trim_start().to_string()
    }

    (key, value)
}

impl From<HttpRequest> for String {
    #[inline(always)]
    fn from(res: HttpRequest) -> String {
        String::from(&res)
    }
}

impl From<&HttpRequest> for String {
    fn from(req: &HttpRequest) -> Self {
        let mut header_string = String::new();
        let mut length = false;
        for (k, v) in &req.headers {
            if k.to_lowercase().as_str() == ""content-length"" {
                length = true;
            }
            header_string.push_str(k);
            header_string.push_str("": "");
            header_string.push_str(v);
            header_string.push_str(""\r\n"");
        }
        if !req.body.is_empty() && !length {
            header_string.push_str(&format!(""Content-Length: {}\r\n"", req.body.len()));
        }

        format!(
            ""{} {} {}\r\n{}\r\n"",
            req.method, req.resource, req.version, header_string
        )
    }
}

impl Display for HttpRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", String::from(self))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_read_http() {
        let s: String = String::from(""POST /greeting HTTP/1.1\r\nHost: localhost:3000\r\nUser-Agent: curl/7.64.1\r\nContent-Length: 11\r\nAccept: */*\r\n\r\ntestbody123"");
        let mut headers_expected = HashMap::new();
        headers_expected.insert(""Host"".into(), ""localhost"".into());
        headers_expected.insert(""Accept"".into(), ""*/*"".into());
        headers_expected.insert(""User-Agent"".into(), ""curl/7.64.1"".into());
        headers_expected.insert(""Content-Length"".into(), ""11"".into());
        let r = HttpRequest::parse(s.as_bytes());
        println!(""{:?}"", r);
        let req = r.unwrap();
        assert_eq!(Method::Post, req.method);
        assert_eq!(Version::V1_1, req.version);
        assert_eq!(Resource::Path(""/greeting"".to_string()), req.resource);
        assert_eq!(headers_expected, req.headers);
        assert_eq!(req.body.as_slice(), b""testbody123"");
    }

    #[test]
    fn test_display_http() {
        let req = HttpRequest {
            method: Method::Get,
            version: Version::V1_0,
            resource: Resource::Path(""/abc"".to_string()),
            headers: {
                let mut h = HashMap::new();
                h.insert(""Content-Type"".to_string(), ""text/html"".to_string());
                h
            },
            body: b""abcd"".to_vec(),
        };
        assert_eq!(
            ""GET /abc HTTP/1.0\r\nContent-Type: text/html\r\nContent-Length: 4\r\n\r\n"",
            String::from(&req)
        )
    }
}
"
test/path/test-path-join.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import path from 'path';

const failures = [];
const backslashRE = /\\/g;

const joinTests = [
  [ [path.posix.join, /*path.win32.join*/],
    // Arguments                     result
    [[['.', 'x/b', '..', '/b/c.js'], 'x/b/c.js'],
     [[], '.'],
     [['/.', 'x/b', '..', '/b/c.js'], '/x/b/c.js'],
     [['/foo', '../../../bar'], '/bar'],
     [['foo', '../../../bar'], '../../bar'],
     [['foo/', '../../../bar'], '../../bar'],
     [['foo/x', '../../../bar'], '../bar'],
     [['foo/x', './bar'], 'foo/x/bar'],
     [['foo/x/', './bar'], 'foo/x/bar'],
     [['foo/x/', '.', 'bar'], 'foo/x/bar'],
     [['./'], './'],
     [['.', './'], './'],
     [['.', '.', '.'], '.'],
     [['.', './', '.'], '.'],
     [['.', '/./', '.'], '.'],
     [['.', '/////./', '.'], '.'],
     [['.'], '.'],
     [['', '.'], '.'],
     [['', 'foo'], 'foo'],
     [['foo', '/bar'], 'foo/bar'],
     [['', '/foo'], '/foo'],
     [['', '', '/foo'], '/foo'],
     [['', '', 'foo'], 'foo'],
     [['foo', ''], 'foo'],
     [['foo/', ''], 'foo/'],
     [['foo', '', '/bar'], 'foo/bar'],
     [['./', '..', '/foo'], '../foo'],
     [['./', '..', '..', '/foo'], '../../foo'],
     [['.', '..', '..', '/foo'], '../../foo'],
     [['', '..', '..', '/foo'], '../../foo'],
     [['/'], '/'],
     [['/', '.'], '/'],
     [['/', '..'], '/'],
     [['/', '..', '..'], '/'],
     [[''], '.'],
     [['', ''], '.'],
     [[' /foo'], ' /foo'],
     [[' ', 'foo'], ' /foo'],
     [[' ', '.'], ' '],
     [[' ', '/'], ' /'],
     [[' ', ''], ' '],
     [['/', 'foo'], '/foo'],
     [['/', '/foo'], '/foo'],
     [['/', '//foo'], '/foo'],
     [['/', '', '/foo'], '/foo'],
     [['', '/', 'foo'], '/foo'],
     [['', '/', '/foo'], '/foo'],
    ],
  ],
];
/*
// Windows-specific join tests
joinTests.push([
  path.win32.join,
  joinTests[0][1].slice(0).concat(
    [// Arguments                     result
      // UNC path expected
      [['//foo/bar'], '\\\\foo\\bar\\'],
      [['\\/foo/bar'], '\\\\foo\\bar\\'],
      [['\\\\foo/bar'], '\\\\foo\\bar\\'],
      // UNC path expected - server and share separate
      [['//foo', 'bar'], '\\\\foo\\bar\\'],
      [['//foo/', 'bar'], '\\\\foo\\bar\\'],
      [['//foo', '/bar'], '\\\\foo\\bar\\'],
      // UNC path expected - questionable
      [['//foo', '', 'bar'], '\\\\foo\\bar\\'],
      [['//foo/', '', 'bar'], '\\\\foo\\bar\\'],
      [['//foo/', '', '/bar'], '\\\\foo\\bar\\'],
      // UNC path expected - even more questionable
      [['', '//foo', 'bar'], '\\\\foo\\bar\\'],
      [['', '//foo/', 'bar'], '\\\\foo\\bar\\'],
      [['', '//foo/', '/bar'], '\\\\foo\\bar\\'],
      // No UNC path expected (no double slash in first component)
      [['\\', 'foo/bar'], '\\foo\\bar'],
      [['\\', '/foo/bar'], '\\foo\\bar'],
      [['', '/', '/foo/bar'], '\\foo\\bar'],
      // No UNC path expected (no non-slashes in first component -
      // questionable)
      [['//', 'foo/bar'], '\\foo\\bar'],
      [['//', '/foo/bar'], '\\foo\\bar'],
      [['\\\\', '/', '/foo/bar'], '\\foo\\bar'],
      [['//'], '\\'],
      // No UNC path expected (share name missing - questionable).
      [['//foo'], '\\foo'],
      [['//foo/'], '\\foo\\'],
      [['//foo', '/'], '\\foo\\'],
      [['//foo', '', '/'], '\\foo\\'],
      // No UNC path expected (too many leading slashes - questionable)
      [['///foo/bar'], '\\foo\\bar'],
      [['////foo', 'bar'], '\\foo\\bar'],
      [['\\\\\\/foo/bar'], '\\foo\\bar'],
      // Drive-relative vs drive-absolute paths. This merely describes the
      // status quo, rather than being obviously right
      [['c:'], 'c:.'],
      [['c:.'], 'c:.'],
      [['c:', ''], 'c:.'],
      [['', 'c:'], 'c:.'],
      [['c:.', '/'], 'c:.\\'],
      [['c:.', 'file'], 'c:file'],
      [['c:', '/'], 'c:\\'],
      [['c:', 'file'], 'c:\\file'],
    ]
  ),
]);
*/
joinTests.forEach((test) => {
  if (!Array.isArray(test[0]))
    test[0] = [test[0]];
  test[0].forEach((join) => {
    test[1].forEach((test) => {
      const actual = join.apply(null, test[0]);
      const expected = test[1];
      // For non-Windows specific tests with the Windows join(), we need to try
      // replacing the slashes since the non-Windows specific tests' `expected`
      // use forward slashes
      let actualAlt;
      let os;
      if (false /*join === path.win32.join*/) {
        actualAlt = actual.replace(backslashRE, '/');
        os = 'win32';
      } else {
        os = 'posix';
      }
      if (actual !== expected && actualAlt !== expected) {
        const delimiter = test[0].map(JSON.stringify).join(',');
        const message = `path.${os}.join(${delimiter})\n  expect=${
          JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
        failures.push(`\n${message}`);
      }
    });
  });
});

assert.strictEqual(failures.length, 0, failures.join(''));
"
test/crypto/test-crypto-padding.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

// Input data.
const ODD_LENGTH_PLAIN = 'Hello node world!';
const EVEN_LENGTH_PLAIN = 'Hello node world!AbC09876dDeFgHi';

const KEY_PLAIN = 'S3c.r.e.t.K.e.Y!';
const IV_PLAIN = 'blahFizz2011Buzz';

const CIPHER_NAME = 'aes-128-cbc';

// Expected result data.

// echo -n 'Hello node world!' | \
// openssl enc -aes-128-cbc -e -K 5333632e722e652e742e4b2e652e5921 \
// -iv 626c616846697a7a3230313142757a7a | xxd -p -c256
const ODD_LENGTH_ENCRYPTED =
    '7f57859550d4d2fdb9806da2a750461a9fe77253cd1cbd4b07beee4e070d561f';

// echo -n 'Hello node world!AbC09876dDeFgHi' | \
// openssl enc -aes-128-cbc -e -K 5333632e722e652e742e4b2e652e5921 \
// -iv 626c616846697a7a3230313142757a7a | xxd -p -c256
const EVEN_LENGTH_ENCRYPTED =
    '7f57859550d4d2fdb9806da2a750461ab46e71b3d78ebe2d9684dfc87f7575b988' +
    '6119866912cb8c7bcaf76c5ebc2378';

// echo -n 'Hello node world!AbC09876dDeFgHi' | \
// openssl enc -aes-128-cbc -e -K 5333632e722e652e742e4b2e652e5921 \
// -iv 626c616846697a7a3230313142757a7a -nopad | xxd -p -c256
const EVEN_LENGTH_ENCRYPTED_NOPAD =
    '7f57859550d4d2fdb9806da2a750461ab46e71b3d78ebe2d9684dfc87f7575b9';


// Helper wrappers.
function enc(plain, pad) {
  const encrypt = crypto.createCipheriv(CIPHER_NAME, KEY_PLAIN, IV_PLAIN);
  encrypt.setAutoPadding(pad);
  let hex = encrypt.update(plain, 'ascii', 'hex');
  hex += encrypt.final('hex');
  return hex;
}

function dec(encd, pad) {
  const decrypt = crypto.createDecipheriv(CIPHER_NAME, KEY_PLAIN, IV_PLAIN);
  decrypt.setAutoPadding(pad);
  let plain = decrypt.update(encd, 'hex');
  plain += decrypt.final('latin1');
  return plain;
}

// Test encryption
assert.strictEqual(enc(ODD_LENGTH_PLAIN, true), ODD_LENGTH_ENCRYPTED);
assert.strictEqual(enc(EVEN_LENGTH_PLAIN, true), EVEN_LENGTH_ENCRYPTED);

assert.throws(function() {
  // Input must have block length %.
  enc(ODD_LENGTH_PLAIN, false);
}, common.hasOpenSSL3 ? {
  message: 'error:1C80006B:Provider routines::wrong final block length',
  code: 'ERR_OSSL_WRONG_FINAL_BLOCK_LENGTH',
  reason: 'wrong final block length',
} : {
  message: 'error:0607F08A:digital envelope routines:EVP_EncryptFinal_ex:' +
    'data not multiple of block length',
  code: 'ERR_OSSL_EVP_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH',
  reason: 'data not multiple of block length',
}
);

assert.strictEqual(
  enc(EVEN_LENGTH_PLAIN, false), EVEN_LENGTH_ENCRYPTED_NOPAD
);

// Test decryption.
assert.strictEqual(dec(ODD_LENGTH_ENCRYPTED, true), ODD_LENGTH_PLAIN);
assert.strictEqual(dec(EVEN_LENGTH_ENCRYPTED, true), EVEN_LENGTH_PLAIN);

// Returns including original padding.
assert.strictEqual(dec(ODD_LENGTH_ENCRYPTED, false).length, 32);
assert.strictEqual(dec(EVEN_LENGTH_ENCRYPTED, false).length, 48);

assert.throws(function() {
  // Must have at least 1 byte of padding (PKCS):
  assert.strictEqual(dec(EVEN_LENGTH_ENCRYPTED_NOPAD, true), EVEN_LENGTH_PLAIN);
}, common.hasOpenSSL3 ? {
  message: 'error:1C800064:Provider routines::bad decrypt',
  reason: 'bad decrypt',
  code: 'ERR_OSSL_BAD_DECRYPT',
} : {
  message: 'error:06065064:digital envelope routines:EVP_DecryptFinal_ex:' +
    'bad decrypt',
  reason: 'bad decrypt',
  code: 'ERR_OSSL_EVP_BAD_DECRYPT',
});

// No-pad encrypted string should return the same:
assert.strictEqual(
  dec(EVEN_LENGTH_ENCRYPTED_NOPAD, false), EVEN_LENGTH_PLAIN
);
"
src/internal_module/core.rs,"use crate::quickjs_sys::*;
use crate::EventLoop;
use std::string::FromUtf8Error;
use std::sync::Arc;

#[derive(Debug, Clone)]
struct TimeoutId(Arc<tokio::sync::Notify>);
impl TimeoutId {
    pub fn new() -> Self {
        TimeoutId(Arc::new(tokio::sync::Notify::new()))
    }
}

impl JsClassDef for TimeoutId {
    type RefType = TimeoutId;

    const CLASS_NAME: &'static str = ""TimeoutId"";

    const CONSTRUCTOR_ARGC: u8 = 0;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(_ctx: &mut Context, _argv: &[JsValue]) -> Result<Self::RefType, JsValue> {
        Err(JsValue::UnDefined)
    }
}

fn set_timeout(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let callback = argv.get(0);
    let timeout = argv.get(1);
    let rest_args = argv.get(2..).map(|args| args.to_vec());
    if let (Some(JsValue::Function(callback)), Some(JsValue::Int(timeout))) = (callback, timeout) {
        let timeout = *timeout as u64;
        let callback = callback.clone();

        if timeout == 0 {
            ctx.event_loop().map(|event_loop| {
                event_loop.add_immediate_task(Box::new(move || {
                    if let Some(rest_args) = rest_args {
                        callback.call(&rest_args);
                    } else {
                        callback.call(&[]);
                    }
                }))
            });
            JsValue::UnDefined
        } else {
            let timeout = std::time::Duration::from_millis(timeout);

            let id = TimeoutId::new();
            let id_ = id.clone();

            ctx.future_to_promise(async move {
                log::trace!(""async wait timeout {timeout:?}"");
                match tokio::time::timeout(timeout, id_.0.notified()).await {
                    Ok(_) => {
                        log::trace!(""timer cancel"");
                        Err(JsValue::UnDefined)
                    }
                    Err(_) => {
                        log::trace!(""timer timeout"");
                        if let Some(rest_args) = rest_args {
                            callback.call(&rest_args);
                        } else {
                            callback.call(&[]);
                        };
                        Ok(JsValue::UnDefined)
                    }
                }
            });
            TimeoutId::wrap_obj(ctx, id)
        }
    } else {
        JsValue::UnDefined
    }
}

fn set_immediate(ctx: &mut Context, this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let callback = argv.get(0);
    let rest_args = argv.get(1..).map(|v| v.to_vec());
    if let Some(JsValue::Function(callback)) = callback {
        let callback = callback.clone();
        let mut argv = vec![JsValue::Function(callback), JsValue::Int(0)];
        argv.extend(rest_args.unwrap_or_default());
        set_timeout(ctx, this_val, &argv)
    } else {
        JsValue::UnDefined
    }
}

fn next_tick(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let callback = argv.get(0);
    let args = argv.get(1..).map(|v| v.to_vec());
    if let (Some(JsValue::Function(callback)), Some(event_loop)) = (callback, ctx.event_loop()) {
        let callback = callback.clone();
        event_loop.set_next_tick(Box::new(move || {
            match args {
                Some(args) => callback.call(&args),
                None => callback.call(&[]),
            };
        }));
    }
    JsValue::UnDefined
}

fn sleep(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let callback = argv.get(0).cloned();
    let timeout = argv.get(1);
    let rest_args = argv.get(2..).map(|args| args.to_vec());
    if let (Some(JsValue::Function(callback)), Some(JsValue::Int(timeout))) = (callback, timeout) {
        let timeout = *timeout;
        ctx.future_to_promise(async move {
            tokio::time::sleep(std::time::Duration::from_millis(timeout as u64)).await;
            if let Some(rest_args) = rest_args {
                callback.call(&rest_args);
            } else {
                callback.call(&[]);
            };

            Ok(JsValue::UnDefined)
        })
    } else {
        JsValue::UnDefined
    }
}

fn os_exit(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let code = if let Some(JsValue::Int(c)) = argv.get(0) {
        *c
    } else {
        0
    };

    std::process::exit(code)
}

fn clear_timeout(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
    let timeout_id = argv.get(0);
    if let Some(timeout_id) = timeout_id {
        let id = TimeoutId::opaque(&timeout_id);
        if let Some(id) = id {
            id.0.notify_one()
        }
    }
    JsValue::UnDefined
}

pub fn init_ext_function(_ctx: &mut Context) {}

pub fn init_global_function(ctx: &mut Context) {
    register_class::<TimeoutId>(ctx);

    let mut global = ctx.get_global();
    global.set(
        ""clearTimeout"",
        ctx.wrap_function(""clearTimeout"", clear_timeout).into(),
    );
    global.set(
        ""setTimeout"",
        ctx.wrap_function(""setTimeout"", set_timeout).into(),
    );
    global.set(
        ""setImmediate"",
        ctx.wrap_function(""setImmediate"", set_immediate).into(),
    );
    global.set(""sleep"", ctx.wrap_function(""sleep"", sleep).into());
    global.set(""nextTick"", ctx.wrap_function(""nextTick"", next_tick).into());
    global.set(""exit"", ctx.wrap_function(""exit"", os_exit).into());
    global.set(""env"", env_object(ctx).into());
}

fn env_object(ctx: &mut Context) -> JsObject {
    let mut env_obj = ctx.new_object();
    let env = std::env::vars();
    for (k, v) in env {
        env_obj.set(&k, ctx.new_string(&v).into());
    }
    env_obj
}
"
modules/internal/streams/transform.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { ERR_METHOD_NOT_IMPLEMENTED } from ""../errors.js"";
import Duplex from ""./duplex.js"";

const kCallback = Symbol(""kCallback"");

function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }

    Duplex.call(this, options);

    // We have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;

    this[kCallback] = null;

    if (options) {
        if (typeof options.transform === ""function"") {
            this._transform = options.transform;
        }

        if (typeof options.flush === ""function"") {
            this._flush = options.flush;
        }
    }

    // When the writable side finishes, then flush out anything remaining.
    // Backwards compat. Some Transform streams incorrectly implement _final
    // instead of or in addition to _flush. By using 'prefinish' instead of
    // implementing _final we continue supporting this unfortunate use case.
    this.on(""prefinish"", prefinish);
}

Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);

function final(cb) {
    let called = false;
    if (typeof this._flush === ""function"" && !this.destroyed) {
        const result = this._flush((er, data) => {
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }

            if (data != null) {
                this.push(data);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === ""function"") {
                    then.call(
                        result,
                        (data) => {
                            if (called) {
                                return;
                            }
                            if (data != null) {
                                this.push(data);
                            }
                            this.push(null);
                            if (cb) {
                                nextTick(cb);
                            }
                        },
                        (err) => {
                            if (cb) {
                                nextTick(cb, err);
                            } else {
                                nextTick(() => this.destroy(err));
                            }
                        },
                    );
                }
            } catch (err) {
                nextTick(() => this.destroy(err));
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}

function prefinish() {
    if (this._final !== final) {
        final.call(this);
    }
}

Transform.prototype._final = final;

Transform.prototype._transform = function (chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED(""_transform()"");
};

Transform.prototype._write = function (chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;

    let called = false;
    const result = this._transform(chunk, encoding, (err, val) => {
        called = true;
        if (err) {
            callback(err);
            return;
        }

        if (val != null) {
            this.push(val);
        }

        if (
            wState.ended || // Backwards compat.
            length === rState.length || // Backwards compat.
            rState.length < rState.highWaterMark ||
            rState.length === 0
        ) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === ""function"") {
                then.call(
                    result,
                    (val) => {
                        if (called) {
                            return;
                        }

                        if (val != null) {
                            this.push(val);
                        }

                        if (
                            wState.ended ||
                            length === rState.length ||
                            rState.length < rState.highWaterMark ||
                            rState.length === 0
                        ) {
                            nextTick(callback);
                        } else {
                            this[kCallback] = callback;
                        }
                    },
                    (err) => {
                        nextTick(callback, err);
                    },
                );
            }
        } catch (err) {
            nextTick(callback, err);
        }
    }
};

Transform.prototype._read = function () {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};

export default Transform;"
modules/internal_binding/uv.js,"export const UV_EOF = (-4095);
export const UV_UNKNOWN = (-4094);
export const UV_EAI_ADDRFAMILY = (-3000);
export const UV_EAI_AGAIN = (-3001);
export const UV_EAI_BADFLAGS = (-3002);
export const UV_EAI_CANCELED = (-3003);
export const UV_EAI_FAIL = (-3004);
export const UV_EAI_FAMILY = (-3005);
export const UV_EAI_MEMORY = (-3006);
export const UV_EAI_NODATA = (-3007);
export const UV_EAI_NONAME = (-3008);
export const UV_EAI_OVERFLOW = (-3009);
export const UV_EAI_SERVICE = (-3010);
export const UV_EAI_SOCKTYPE = (-3011);
export const UV_EAI_BADHINTS = (-3013);
export const UV_EAI_PROTOCOL = (-3014);
export const UV_E2BIG = (-4093);
export const UV_EACCES = (-4092);
export const UV_EADDRINUSE = (-4091);
export const UV_EADDRNOTAVAIL = (-4090);
export const UV_EAFNOSUPPORT = (-4089);
export const UV_EAGAIN = (-4088);
export const UV_EALREADY = (-4084);
export const UV_EBADF = (-4083);
export const UV_EBUSY = (-4082);
export const UV_ECANCELED = (-4081);
export const UV_ECHARSET = (-4080);
export const UV_ECONNABORTED = (-4079);
export const UV_ECONNREFUSED = (-4078);
export const UV_ECONNRESET = (-4077);
export const UV_EDESTADDRREQ = (-4076);
export const UV_EEXIST = (-4075);
export const UV_EFAULT = (-4074);
export const UV_EHOSTUNREACH = (-4073);
export const UV_EINTR = (-4072);
export const UV_EINVAL = (-4071);
export const UV_EIO = (-4070);
export const UV_EISCONN = (-4069);
export const UV_EISDIR = (-4068);
export const UV_ELOOP = (-4067);
export const UV_EMFILE = (-4066);
export const UV_EMSGSIZE = (-4065);
export const UV_ENAMETOOLONG = (-4064);
export const UV_ENETDOWN = (-4063);
export const UV_ENETUNREACH = (-4062);
export const UV_ENFILE = (-4061);
export const UV_ENOBUFS = (-4060);
export const UV_ENODEV = (-4059);
export const UV_ENOENT = (-4058);
export const UV_ENOMEM = (-4057);
export const UV_ENONET = (-4056);
export const UV_ENOSPC = (-4055);
export const UV_ENOSYS = (-4054);
export const UV_ENOTCONN = (-4053);
export const UV_ENOTDIR = (-4052);
export const UV_ENOTEMPTY = (-4051);
export const UV_ENOTSOCK = (-4050);
export const UV_ENOTSUP = (-4049);
export const UV_EPERM = (-4048);
export const UV_EPIPE = (-4047);
export const UV_EPROTO = (-4046);
export const UV_EPROTONOSUPPORT = (-4045);
export const UV_EPROTOTYPE = (-4044);
export const UV_EROFS = (-4043);
export const UV_ESHUTDOWN = (-4042);
export const UV_ESPIPE = (-4041);
export const UV_ESRCH = (-4040);
export const UV_ETIMEDOUT = (-4039);
export const UV_ETXTBSY = (-4038);
export const UV_EXDEV = (-4037);
export const UV_EFBIG = (-4036);
export const UV_ENOPROTOOPT = (-4035);
export const UV_ERANGE = (-4034);
export const UV_ENXIO = (-4033);
export const UV_EMLINK = (-4032);
export const UV_EHOSTDOWN = (-4031);
export const UV_EREMOTEIO = (-4030);
export const UV_ENOTTY = (-4029);
export const UV_EFTYPE = (-4028);
export const UV_EILSEQ = (-4027);
export const UV_EOVERFLOW = (-4026);
export const UV_ESOCKTNOSUPPORT = (-4025);

export default {
    UV_EOF,
    UV_UNKNOWN,
    UV_EAI_ADDRFAMILY,
    UV_EAI_AGAIN,
    UV_EAI_BADFLAGS,
    UV_EAI_CANCELED,
    UV_EAI_FAIL,
    UV_EAI_FAMILY,
    UV_EAI_MEMORY,
    UV_EAI_NODATA,
    UV_EAI_NONAME,
    UV_EAI_OVERFLOW,
    UV_EAI_SERVICE,
    UV_EAI_SOCKTYPE,
    UV_EAI_BADHINTS,
    UV_EAI_PROTOCOL,
    UV_E2BIG,
    UV_EACCES,
    UV_EADDRINUSE,
    UV_EADDRNOTAVAIL,
    UV_EAFNOSUPPORT,
    UV_EAGAIN,
    UV_EALREADY,
    UV_EBADF,
    UV_EBUSY,
    UV_ECANCELED,
    UV_ECHARSET,
    UV_ECONNABORTED,
    UV_ECONNREFUSED,
    UV_ECONNRESET,
    UV_EDESTADDRREQ,
    UV_EEXIST,
    UV_EFAULT,
    UV_EHOSTUNREACH,
    UV_EINTR,
    UV_EINVAL,
    UV_EIO,
    UV_EISCONN,
    UV_EISDIR,
    UV_ELOOP,
    UV_EMFILE,
    UV_EMSGSIZE,
    UV_ENAMETOOLONG,
    UV_ENETDOWN,
    UV_ENETUNREACH,
    UV_ENFILE,
    UV_ENOBUFS,
    UV_ENODEV,
    UV_ENOENT,
    UV_ENOMEM,
    UV_ENONET,
    UV_ENOSPC,
    UV_ENOSYS,
    UV_ENOTCONN,
    UV_ENOTDIR,
    UV_ENOTEMPTY,
    UV_ENOTSOCK,
    UV_ENOTSUP,
    UV_EPERM,
    UV_EPIPE,
    UV_EPROTO,
    UV_EPROTONOSUPPORT,
    UV_EPROTOTYPE,
    UV_EROFS,
    UV_ESHUTDOWN,
    UV_ESPIPE,
    UV_ESRCH,
    UV_ETIMEDOUT,
    UV_ETXTBSY,
    UV_EXDEV,
    UV_EFBIG,
    UV_ENOPROTOOPT,
    UV_ERANGE,
    UV_ENXIO,
    UV_EMLINK,
    UV_EHOSTDOWN,
    UV_EREMOTEIO,
    UV_ENOTTY,
    UV_EFTYPE,
    UV_EILSEQ,
    UV_EOVERFLOW,
    UV_ESOCKTNOSUPPORT,
}"
test/fs/test-fs-read-stream-inherit.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const fn = fixtures.path('elipses.txt');
const rangeFile = fixtures.path('x.txt');

{
  let paused = false;

  const file = fs.ReadStream(fn);

  file.on('open', common.mustCall(function(fd) {
    file.length = 0;
    assert.strictEqual(typeof fd, 'number');
    assert.ok(file.readable);

    // GH-535
    file.pause();
    file.resume();
    file.pause();
    file.resume();
  }));

  file.on('data', common.mustCallAtLeast(function(data) {
    assert.ok(data instanceof Buffer);
    assert.ok(!paused);
    file.length += data.length;

    paused = true;
    file.pause();

    setTimeout(function() {
      paused = false;
      file.resume();
    }, 10);
  }));


  file.on('end', common.mustCall());


  file.on('close', common.mustCall(function() {
    assert.strictEqual(file.length, 30000);
  }));
}

{
  const file = fs.createReadStream(fn, Object.create({ encoding: 'utf8' }));
  file.length = 0;
  file.on('data', function(data) {
    assert.strictEqual(typeof data, 'string');
    file.length += data.length;

    for (let i = 0; i < data.length; i++) {
      // http://www.fileformat.info/info/unicode/char/2026/index.htm
      assert.strictEqual(data[i], '\u2026');
    }
  });

  file.on('close', common.mustCall(function() {
    assert.strictEqual(file.length, 10000);
  }));
}

{
  const options = Object.create({ bufferSize: 1, start: 1, end: 2 });
  const file = fs.createReadStream(rangeFile, options);
  assert.strictEqual(file.start, 1);
  assert.strictEqual(file.end, 2);
  let contentRead = '';
  file.on('data', function(data) {
    contentRead += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(contentRead, 'yz');
  }));
}

{
  const options = Object.create({ bufferSize: 1, start: 1 });
  const file = fs.createReadStream(rangeFile, options);
  assert.strictEqual(file.start, 1);
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

// https://github.com/joyent/node/issues/2320
{
  const options = Object.create({ bufferSize: 1.23, start: 1 });
  const file = fs.createReadStream(rangeFile, options);
  assert.strictEqual(file.start, 1);
  file.data = '';
  file.on('data', function(data) {
    file.data += data.toString('utf-8');
  });
  file.on('end', common.mustCall(function() {
    assert.strictEqual(file.data, 'yz\n');
  }));
}

{
  const message =
    'The value of ""start"" is out of range. It must be <= ""end"" (here: 2).' +
    ' Received 10';

  assert.throws(
    () => {
      fs.createReadStream(rangeFile, Object.create({ start: 10, end: 2 }));
    },
    {
      code: 'ERR_OUT_OF_RANGE',
      message,
      name: 'RangeError'
    });
}

{
  const options = Object.create({ start: 0, end: 0 });
  const stream = fs.createReadStream(rangeFile, options);
  assert.strictEqual(stream.start, 0);
  assert.strictEqual(stream.end, 0);
  stream.data = '';

  stream.on('data', function(chunk) {
    stream.data += chunk;
  });

  stream.on('end', common.mustCall(function() {
    assert.strictEqual(stream.data, 'x');
  }));
}

// Pause and then resume immediately.
{
  const pauseRes = fs.createReadStream(rangeFile);
  pauseRes.pause();
  pauseRes.resume();
}

{
  let data = '';
  let file =
    fs.createReadStream(rangeFile, Object.create({ autoClose: false }));
  assert.strictEqual(file.autoClose, false);
  file.on('data', (chunk) => { data += chunk; });
  file.on('end', common.mustCall(function() {
    process.nextTick(common.mustCall(function() {
      assert(!file.closed);
      assert(!file.destroyed);
      assert.strictEqual(data, 'xyz\n');
      fileNext();
    }));
  }));

  function fileNext() {
    // This will tell us if the fd is usable again or not.
    file = fs.createReadStream(null, Object.create({ fd: file.fd, start: 0 }));
    file.data = '';
    file.on('data', function(data) {
      file.data += data;
    });
    file.on('end', common.mustCall(function() {
      assert.strictEqual(file.data, 'xyz\n');
    }));
  }
  process.on('exit', function() {
    assert(file.closed);
    assert(file.destroyed);
  });
}

// Just to make sure autoClose won't close the stream because of error.
{
  const options = Object.create({ fd: 13337, autoClose: false });
  const file = fs.createReadStream(null, options);
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());
  process.on('exit', function() {
    assert(!file.closed);
    assert(!file.destroyed);
    assert(file.fd);
  });
}

// Make sure stream is destroyed when file does not exist.
{
  const file = fs.createReadStream('/path/to/file/that/does/not/exist');
  file.on('data', common.mustNotCall());
  file.on('error', common.mustCall());

  process.on('exit', function() {
    assert(file.closed);
    assert(file.destroyed);
  });
}
"
test/fs/test-fs-promises-writefile.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
const fsPromises = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;
import { Readable } from 'stream';

tmpdir.refresh();

const dest = path.resolve(tmpDir, 'tmp.txt');
const otherDest = path.resolve(tmpDir, 'tmp-2.txt');
const buffer = Buffer.from('abc'.repeat(1000));
const buffer2 = Buffer.from('xyz'.repeat(1000));
const stream = Readable.from(['a', 'b', 'c']);
const stream2 = Readable.from(['mlaut', ' ', 'sechzig']);
const iterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};

const veryLargeBuffer = {
  expected: 'dogs running'.repeat(512 * 1024),
  *[Symbol.iterator]() {
    yield Buffer.from('dogs running'.repeat(512 * 1024), 'utf8');
  }
};

function iterableWith(value) {
  return {
    *[Symbol.iterator]() {
      yield value;
    }
  };
}
const bufferIterable = {
  expected: 'abc',
  *[Symbol.iterator]() {
    yield Buffer.from('a');
    yield Buffer.from('b');
    yield Buffer.from('c');
  }
};
const asyncIterable = {
  expected: 'abc',
  async* [Symbol.asyncIterator]() {
    yield 'a';
    yield 'b';
    yield 'c';
  }
};

async function doWrite() {
  await fsPromises.writeFile(dest, buffer);
  const data = fs.readFileSync(dest);
  assert.deepStrictEqual(data, buffer);
}

async function doWriteStream() {
  await fsPromises.writeFile(dest, stream);
  const expected = 'abc';
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, expected);
}

async function doWriteStreamWithCancel() {
  const controller = new AbortController();
  const { signal } = controller;
  process.nextTick(() => controller.abort());
  await assert.rejects(
    fsPromises.writeFile(otherDest, stream, { signal }),
    { name: 'AbortError' }
  );
}

async function doWriteIterable() {
  await fsPromises.writeFile(dest, iterable);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, iterable.expected);
}

async function doWriteInvalidIterable() {
  await Promise.all(
    [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
      assert.rejects(fsPromises.writeFile(dest, iterableWith(value)), {
        code: 'ERR_INVALID_ARG_TYPE',
      })
    )
  );
}

async function doWriteIterableWithEncoding() {
  await fsPromises.writeFile(dest, stream2, 'latin1');
  const expected = 'mlaut sechzig';
  const data = fs.readFileSync(dest, 'latin1');
  assert.deepStrictEqual(data, expected);
}

async function doWriteBufferIterable() {
  await fsPromises.writeFile(dest, bufferIterable);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, bufferIterable.expected);
}

async function doWriteAsyncIterable() {
  await fsPromises.writeFile(dest, asyncIterable);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, asyncIterable.expected);
}

async function doWriteAsyncLargeIterable() {
  await fsPromises.writeFile(dest, veryLargeBuffer);
  const data = fs.readFileSync(dest, 'utf-8');
  assert.deepStrictEqual(data, veryLargeBuffer.expected);
}

async function doWriteInvalidValues() {
  await Promise.all(
    [42, 42n, {}, Symbol('42'), true, undefined, null, NaN].map((value) =>
      assert.rejects(fsPromises.writeFile(dest, value), {
        code: 'ERR_INVALID_ARG_TYPE',
      })
    )
  );
}

async function doWriteWithCancel() {
  const controller = new AbortController();
  const { signal } = controller;
  process.nextTick(() => controller.abort());
  await assert.rejects(
    fsPromises.writeFile(otherDest, buffer, { signal }),
    { name: 'AbortError' }
  );
}

async function doAppend() {
  await fsPromises.appendFile(dest, buffer2, { flag: null });
  const data = fs.readFileSync(dest);
  const buf = Buffer.concat([buffer, buffer2]);
  assert.deepStrictEqual(buf, data);
}

async function doRead() {
  const data = await fsPromises.readFile(dest);
  const buf = fs.readFileSync(dest);
  assert.deepStrictEqual(buf, data);
}

async function doReadWithEncoding() {
  const data = await fsPromises.readFile(dest, 'utf-8');
  const syncData = fs.readFileSync(dest, 'utf-8');
  assert.strictEqual(typeof data, 'string');
  assert.deepStrictEqual(data, syncData);
}

(async () => {
  await doWrite();
  // await doWriteWithCancel();
  await doAppend();
  await doRead();
  await doReadWithEncoding();
  await doWriteStream();
  // await doWriteStreamWithCancel(); signal is unsupported
  await doWriteIterable();
  await doWriteInvalidIterable();
  await doWriteIterableWithEncoding();
  await doWriteBufferIterable();
  await doWriteAsyncIterable();
  // await doWriteAsyncLargeIterable(); cost to much time
  await doWriteInvalidValues();
})().then(common.mustCall());
"
modules/internal/streams/compose.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { destroyer } from ""./destroy.js"";
import { isNodeStream, isReadable, isWritable } from ""./utils.js"";
import { pipeline } from ""./pipeline.js"";
import {
    AbortError,
    ERR_INVALID_ARG_VALUE,
    ERR_MISSING_ARGS,
} from ""../errors.js"";
import Duplex from ""./duplex.js"";

// This is needed for pre node 17.
class ComposeDuplex extends Duplex {
    constructor(options) {
        super(options);

        // https://github.com/nodejs/node/pull/34385

        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }

        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}

function compose(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS(""streams"");
    }

    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }

    const orgStreams = [...streams];

    if (typeof streams[0] === ""function"") {
        streams[0] = Duplex.from(streams[0]);
    }

    if (typeof streams[streams.length - 1] === ""function"") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }

    for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n])) {
            // TODO(ronag): Add checks for non streams.
            continue;
        }
        if (n < streams.length - 1 && !isReadable(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(
                `streams[${n}]`,
                orgStreams[n],
                ""must be readable"",
            );
        }
        if (n > 0 && !isWritable(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(
                `streams[${n}]`,
                orgStreams[n],
                ""must be writable"",
            );
        }
    }

    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;

    function onfinished(err) {
        const cb = onclose;
        onclose = null;

        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }

    const head = streams[0];
    const tail = pipeline(streams, onfinished);

    const writable = !!isWritable(head);
    const readable = !!isReadable(tail);

    // TODO(ronag): Avoid double buffering.
    // Implement Writable/Readable/Duplex traits.
    // See, https://github.com/nodejs/node/pull/33515.
    d = new ComposeDuplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable,
    });

    if (writable) {
        d._write = function (chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };

        d._final = function (callback) {
            head.end();
            onfinish = callback;
        };

        head.on(""drain"", function () {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });

        tail.on(""finish"", function () {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }

    if (readable) {
        tail.on(""readable"", function () {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });

        tail.on(""end"", function () {
            d.push(null);
        });

        d._read = function () {
            while (true) {
                const buf = tail.read();

                if (buf === null) {
                    onreadable = d._read;
                    return;
                }

                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }

    d._destroy = function (err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }

        onreadable = null;
        ondrain = null;
        onfinish = null;

        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(tail, err);
        }
    };

    return d;
}

export default compose;"
modules/internal/crypto/scrypt.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import { Buffer } from 'buffer';

import {
  validateFunction,
  validateInteger,
  validateInt32,
  validateUint32,
} from '../validators';

import {
  ERR_CRYPTO_SCRYPT_INVALID_PARAMETER,
  ERR_CRYPTO_SCRYPT_NOT_SUPPORTED,
} from '../errors';

import {
  getArrayBufferOrView,
  getDefaultEncoding,
} from './util';

import { scrypt_sync } from ""_node:crypto"";

const defaults = {
  N: 16384,
  r: 8,
  p: 1,
  maxmem: 32 << 20,  // 32 MiB, matches SCRYPT_MAX_MEM.
};

function scrypt(password, salt, keylen, options, callback = defaults) {
  if (callback === defaults) {
    callback = options;
    options = defaults;
  }

  options = check(password, salt, keylen, options);
  const { N, r, p, maxmem } = options;
  ({ password, salt, keylen } = options);

  validateFunction(callback, 'callback');
  const encoding = getDefaultEncoding();
  setTimeout(() => {
    let result = scrypt_sync(password.buffer ?? password, salt.buffer ?? salt, N, r, p, keylen);
    const buf = Buffer.from(result);
    if (encoding === 'buffer') {
      callback(null, buf);
    } else {
      callback(null, buf.toString(encoding));
    }
  }, 0);
}

function scryptSync(password, salt, keylen, options = defaults) {
  options = check(password, salt, keylen, options);
  const { N, r, p, maxmem } = options;
  ({ password, salt, keylen } = options);

  let result = scrypt_sync(password.buffer ?? password, salt.buffer ?? salt, N, r, p, keylen);

  const buf = Buffer.from(result);
  const encoding = getDefaultEncoding();
  return encoding === 'buffer' ? buf : buf.toString(encoding);
}

function check(password, salt, keylen, options) {
  /*if (ScryptJob === undefined)
    throw new ERR_CRYPTO_SCRYPT_NOT_SUPPORTED();*/

  password = getArrayBufferOrView(password, 'password');
  salt = getArrayBufferOrView(salt, 'salt');
  validateInt32(keylen, 'keylen', 0);

  let { N, r, p, maxmem } = defaults;
  if (options && options !== defaults) {
    const has_N = options.N !== undefined;
    if (has_N) {
      N = options.N;
      validateUint32(N, 'N');
    }
    if (options.cost !== undefined) {
      if (has_N) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
      N = options.cost;
      validateUint32(N, 'cost');
    }
    const has_r = (options.r !== undefined);
    if (has_r) {
      r = options.r;
      validateUint32(r, 'r');
    }
    if (options.blockSize !== undefined) {
      if (has_r) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
      r = options.blockSize;
      validateUint32(r, 'blockSize');
    }
    const has_p = options.p !== undefined;
    if (has_p) {
      p = options.p;
      validateUint32(p, 'p');
    }
    if (options.parallelization !== undefined) {
      if (has_p) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
      p = options.parallelization;
      validateUint32(p, 'parallelization');
    }
    if (options.maxmem !== undefined) {
      maxmem = options.maxmem;
      validateInteger(maxmem, 'maxmem', 0);
    }
    if (N === 0) N = defaults.N;
    if (r === 0) r = defaults.r;
    if (p === 0) p = defaults.p;
    if (maxmem === 0) maxmem = defaults.maxmem;
  }

  if (Math.log2(N) % 1 !== 0 || N <= 1) {
    throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
  }

  let blen = p * 128 * r
  let vlen = 32 * r * (N + 2) * 4
  if (vlen + blen > maxmem || 128 * N * r > maxmem || N >= 2 ** (r * 16) || p > (2 ** 30 - 1) / r) {
    throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();
  }

  return { password, salt, keylen, N, r, p, maxmem };
}

export {
  scrypt,
  scryptSync,
};
"
test/fs/test-fs-copyfile.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import { internalBinding } from 'internal/test/binding';
const {
  UV_ENOENT,
  UV_EEXIST
} = internalBinding('uv');
import path from 'path';
const src = fixtures.path('a.js');
const dest = path.join(tmpdir.path, 'copyfile.out');
const {
  COPYFILE_EXCL,
  COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE,
  UV_FS_COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE
} = fs.constants;

function verify(src, dest) {
  const srcData = fs.readFileSync(src, 'utf8');
  const srcStat = fs.statSync(src);
  const destData = fs.readFileSync(dest, 'utf8');
  const destStat = fs.statSync(dest);

  assert.strictEqual(srcData, destData);
  assert.strictEqual(srcStat.mode, destStat.mode);
  assert.strictEqual(srcStat.size, destStat.size);
}

tmpdir.refresh();

// Verify that flags are defined.
assert.strictEqual(typeof COPYFILE_EXCL, 'number');
assert.strictEqual(typeof COPYFILE_FICLONE, 'number');
assert.strictEqual(typeof COPYFILE_FICLONE_FORCE, 'number');
assert.strictEqual(typeof UV_FS_COPYFILE_EXCL, 'number');
assert.strictEqual(typeof UV_FS_COPYFILE_FICLONE, 'number');
assert.strictEqual(typeof UV_FS_COPYFILE_FICLONE_FORCE, 'number');
assert.strictEqual(COPYFILE_EXCL, UV_FS_COPYFILE_EXCL);
assert.strictEqual(COPYFILE_FICLONE, UV_FS_COPYFILE_FICLONE);
assert.strictEqual(COPYFILE_FICLONE_FORCE, UV_FS_COPYFILE_FICLONE_FORCE);

// Verify that files are overwritten when no flags are provided.
fs.writeFileSync(dest, '', 'utf8');
const result = fs.copyFileSync(src, dest);
assert.strictEqual(result, undefined);
verify(src, dest);

// Verify that files are overwritten with default flags.
fs.copyFileSync(src, dest, 0);
verify(src, dest);

// Verify that UV_FS_COPYFILE_FICLONE can be used.
fs.unlinkSync(dest);
fs.copyFileSync(src, dest, UV_FS_COPYFILE_FICLONE);
verify(src, dest);

// Verify that COPYFILE_FICLONE_FORCE can be used.
try {
  fs.unlinkSync(dest);
  fs.copyFileSync(src, dest, COPYFILE_FICLONE_FORCE);
  verify(src, dest);
} catch (err) {
  assert.strictEqual(err.syscall, 'copyfile');
  assert(err.code === 'ENOTSUP' || err.code === 'ENOTTY' ||
    err.code === 'ENOSYS' || err.code === 'EXDEV');
  assert.strictEqual(err.path, src);
  assert.strictEqual(err.dest, dest);
}

// Copies asynchronously.
tmpdir.refresh(); // Don't use unlinkSync() since the last test may fail.
fs.copyFile(src, dest, common.mustSucceed(() => {
  verify(src, dest);

  // Copy asynchronously with flags.
  fs.copyFile(src, dest, COPYFILE_EXCL, common.mustCall((err) => {
    if (err.code === 'ENOENT') {  // Could be ENOENT or EEXIST
      assert.strictEqual(err.message,
                         'ENOENT: no such file or directory, copyfile ' +
                         `'${src}' -> '${dest}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
      assert.strictEqual(err.syscall, 'copyfile');
    } else {
      assert.strictEqual(err.message,
                         'EEXIST: file already exists, copyfile ' +
                         `'${src}' -> '${dest}'`);
      assert.strictEqual(err.errno, UV_EEXIST);
      assert.strictEqual(err.code, 'EEXIST');
      assert.strictEqual(err.syscall, 'copyfile');
    }
  }));
}));

// Throws if callback is not a function.
assert.throws(() => {
  fs.copyFile(src, dest, 0, 0);
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
});

// Throws if the source path is not a string.
[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.copyFile(i, dest, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /src/
    }
  );
  assert.throws(
    () => fs.copyFile(src, i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /dest/
    }
  );
  assert.throws(
    () => fs.copyFileSync(i, dest),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /src/
    }
  );
  assert.throws(
    () => fs.copyFileSync(src, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: /dest/
    }
  );
});

assert.throws(() => {
  fs.copyFileSync(src, dest, 'r');
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: /mode/
});

assert.throws(() => {
  fs.copyFileSync(src, dest, 8);
}, {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError',
  message: 'The value of ""mode"" is out of range. It must be an integer ' +
           '>= 0 && <= 7. Received 8'
});

assert.throws(() => {
  fs.copyFile(src, dest, 'r', common.mustNotCall());
}, {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError',
  message: /mode/
});
"
test/fs/test-fs-open-flags.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Flags: --expose-internals
'use strict';
import common from '../common';

import fixtures from '../common/fixtures';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

// 0 if not found in fs.constants
const { O_APPEND = 0,
        O_CREAT = 0,
        O_EXCL = 0,
        O_RDONLY = 0,
        O_RDWR = 0,
        O_SYNC = 0,
        O_DSYNC = 0,
        O_TRUNC = 0,
        O_WRONLY = 0 } = fs.constants;

import { stringToFlags } from 'internal/fs/utils';

assert.strictEqual(stringToFlags('r'), O_RDONLY);
assert.strictEqual(stringToFlags('r+'), O_RDWR);
assert.strictEqual(stringToFlags('rs+'), O_RDWR | O_SYNC);
assert.strictEqual(stringToFlags('sr+'), O_RDWR | O_SYNC);
assert.strictEqual(stringToFlags('w'), O_TRUNC | O_CREAT | O_WRONLY);
assert.strictEqual(stringToFlags('w+'), O_TRUNC | O_CREAT | O_RDWR);
assert.strictEqual(stringToFlags('a'), O_APPEND | O_CREAT | O_WRONLY);
assert.strictEqual(stringToFlags('a+'), O_APPEND | O_CREAT | O_RDWR);

assert.strictEqual(stringToFlags('wx'), O_TRUNC | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('xw'), O_TRUNC | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('wx+'), O_TRUNC | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('xw+'), O_TRUNC | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('ax'), O_APPEND | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('xa'), O_APPEND | O_CREAT | O_WRONLY | O_EXCL);
assert.strictEqual(stringToFlags('as'), O_APPEND | O_CREAT | O_WRONLY | O_SYNC);
assert.strictEqual(stringToFlags('sa'), O_APPEND | O_CREAT | O_WRONLY | O_SYNC);
assert.strictEqual(stringToFlags('ax+'), O_APPEND | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('xa+'), O_APPEND | O_CREAT | O_RDWR | O_EXCL);
assert.strictEqual(stringToFlags('as+'), O_APPEND | O_CREAT | O_RDWR | O_SYNC);
assert.strictEqual(stringToFlags('sa+'), O_APPEND | O_CREAT | O_RDWR | O_SYNC);

('+ +a +r +w rw wa war raw r++ a++ w++ x +x x+ rx rx+ wxx wax xwx xxx')
  .split(' ')
  .forEach(function(flags) {
    assert.throws(
      () => stringToFlags(flags),
      { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
    );
  });

assert.throws(
  () => stringToFlags({}),
  { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
);

assert.throws(
  () => stringToFlags(true),
  { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
);

import tmpdir from '../common/tmpdir';

if (common.isLinux || common.isOSX) {
  tmpdir.refresh();
  const file = path.join(tmpdir.path, 'a.js');
  fs.copyFileSync(fixtures.path('a.js'), file);
  fs.open(file, O_DSYNC, common.mustSucceed((fd) => {
    fs.closeSync(fd);
  }));
}
"
test/fs/test-fs-promises-file-handle-read.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.read method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

async function read(fileHandle, buffer, offset, length, position, options) {
  return options.useConf ?
    fileHandle.read({ buffer, offset, length, position }) :
    fileHandle.read(buffer, offset, length, position);
}

async function validateRead(data, file, options) {
  const filePath = path.resolve(tmpDir, file);
  const buffer = Buffer.from(data, 'utf8');

  const fd = fs.openSync(filePath, 'w+');
  const fileHandle = await open(filePath, 'w+');
  const streamFileHandle = await open(filePath, 'w+');

  fs.writeSync(fd, buffer, 0, buffer.length);
  fs.closeSync(fd);

  fileHandle.on('close', common.mustCall());
  const readAsyncHandle =
    await read(fileHandle, Buffer.alloc(11), 0, 11, 0, options);
  assert.deepStrictEqual(data.length, readAsyncHandle.bytesRead);
  if (data.length)
    assert.deepStrictEqual(buffer, readAsyncHandle.buffer);
  await fileHandle.close();

  const stream = fs.createReadStream(null, { fd: streamFileHandle });
  let streamData = Buffer.alloc(0);
  for await (const chunk of stream)
    streamData = Buffer.from(chunk);
  assert.deepStrictEqual(buffer, streamData);
  if (data.length)
    assert.deepStrictEqual(streamData, readAsyncHandle.buffer);
  await streamFileHandle.close();
}

async function validateLargeRead(options) {
  // Reading beyond file length (3 in this case) should return no data.
  // This is a test for a bug where reads > uint32 would return data
  // from the current position in the file.
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  const pos = 0xffffffff + 1; // max-uint32 + 1
  const readHandle =
    await read(fileHandle, Buffer.alloc(1), 0, 1, pos, options);

  assert.strictEqual(readHandle.bytesRead, 0);
}

async function validateReadNoParams() {
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  // Should not throw
  await fileHandle.read();
}

// Validates that the zero position is respected after the position has been
// moved. The test iterates over the xyz chars twice making sure that the values
// are read from the correct position.
async function validateReadWithPositionZero() {
  const opts = { useConf: true };
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  const expectedSequence = ['x', 'y', 'z'];

  for (let i = 0; i < expectedSequence.length * 2; i++) {
    const len = 1;
    const pos = i % 3;
    const buf = Buffer.alloc(len);
    const { bytesRead } = await read(fileHandle, buf, 0, len, pos, opts);
    assert.strictEqual(bytesRead, len);
    assert.strictEqual(buf.toString(), expectedSequence[pos]);
  }
}

async function validateReadLength(len) {
  const buf = Buffer.alloc(4);
  const opts = { useConf: true };
  const filePath = fixtures.path('x.txt');
  const fileHandle = await open(filePath, 'r');
  const { bytesRead } = await read(fileHandle, buf, 0, len, 0, opts);
  assert.strictEqual(bytesRead, len);
}


(async function () {
  tmpdir.refresh();
  await validateRead('Hello world', 'read-file', { useConf: false });
  await validateRead('', 'read-empty-file', { useConf: false });
  await validateRead('Hello world', 'read-file-conf', { useConf: true });
  await validateRead('', 'read-empty-file-conf', { useConf: true });
  await validateLargeRead({ useConf: false });
  await validateLargeRead({ useConf: true });
  await validateReadNoParams();
  await validateReadWithPositionZero();
  await validateReadLength(0);
  await validateReadLength(1);
})().then(common.mustCall());
"
examples/embed_js/src/main.rs,"use wasmedge_quickjs::*;

fn main() {
    let mut ctx = Context::new();
    js_hello(&mut ctx);
    run_js_code(&mut ctx);
    run_js_function(&mut ctx);
    run_rust_function(&mut ctx);
    rust_new_object_and_js_call(&mut ctx);
    js_new_object_and_rust_call(&mut ctx);
    js_promise(&mut ctx);
}

fn js_hello(ctx: &mut Context) {
    println!(""\n<----run_simple_js---->"");
    let code = r#""print('hello quickjs')""#;
    let r = ctx.eval_global_str(code);
    println!(""return value:{:?}"", r);
}

fn run_js_code(ctx: &mut Context) {
    println!(""\n<----run_js_code---->"");
    let code = r#""
    let a = 1+1;
    print('js print: 1+1=',a);
    'hello'; // eval_return
    ""#;
    let r = ctx.eval_global_str(code);
    println!(""return value:{:?}"", r);
}

fn run_js_function(ctx: &mut Context) {
    println!(""\n<----run_js_function---->"");
    let code = r#""
    (x)=>{
        print(""js print: x="",x)
    }
    ""#;
    let r = ctx.eval_global_str(code);
    println!(""return value:{:?}"", r);
    if let JsValue::Function(f) = r {
        let hello_str = ctx.new_string(""hello"");
        let mut argv = vec![hello_str.into()];
        let r = f.call(&mut argv);
        println!(""return value:{:?}"", r);
    }

    let code = r#""
    (x)=>{
        print(""\nx="",x)
        let old_value = x[0]
        x[0] = 1
        return old_value
    }
    ""#;
    let r = ctx.eval_global_str(code);
    if let JsValue::Function(f) = r {
        let mut x = ctx.new_array();
        x.set(0, 0.into());
        x.set(1, 1.into());
        x.set(2, 2.into());

        let mut argv = vec![x.into()];
        println!(""argv = {:?}"", argv);
        let r = f.call(&mut argv);
        println!(""return value:{:?}"", r);
    }
}

fn run_rust_function(ctx: &mut Context) {
    println!(""\n<----run_rust_function---->"");

    struct HelloFn;
    impl JsFn for HelloFn {
        fn call(_ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
            println!(""hello from rust"");
            println!(""argv={:?}"", argv);
            JsValue::UnDefined
        }
    }
    let f = ctx.new_function::<HelloFn>(""hello"");
    ctx.get_global().set(""hi"", f.into());
    let code = r#""hi(1,2,3)""#;
    let r = ctx.eval_global_str(code);
    println!(""return value:{:?}"", r);
}

fn rust_new_object_and_js_call(ctx: &mut Context) {
    println!(""\n<----rust_new_object_and_js_call---->"");
    let mut obj = ctx.new_object();
    obj.set(""a"", 1.into());
    obj.set(""b"", ctx.new_string(""abc"").into());

    struct ObjectFn;
    impl JsFn for ObjectFn {
        fn call(_ctx: &mut Context, this_val: JsValue, argv: &[JsValue]) -> JsValue {
            println!(""hello from rust"");
            println!(""argv={:?}"", argv);
            if let JsValue::Object(obj) = this_val {
                let obj_map = obj.to_map();
                println!(""this={:#?}"", obj_map);
            }
            JsValue::UnDefined
        }
    }

    let f = ctx.new_function::<ObjectFn>(""anything"");
    obj.set(""f"", f.into());

    ctx.get_global().set(""test_obj"", obj.into());

    let code = r#""
    print('test_obj keys=',Object.keys(test_obj))
    print('test_obj.a=',test_obj.a)
    print('test_obj.b=',test_obj.b)
    test_obj.f(1,2,3,""hi"")
    ""#;

    ctx.eval_global_str(code);
}

fn js_new_object_and_rust_call(ctx: &mut Context) {
    println!(""\n<----js_new_object_and_rust_call---->"");
    let code = r#""
    let obj = {
        a:1,
        b:""abc"",
        f(x){
            print('this=',Object.keys(this))
            print('x=',x)
            print('something_from_rust=',this.something_from_rust)
        }
    }
    obj
    ""#;
    if let JsValue::Object(mut obj) = ctx.eval_global_str(code) {
        let mut args = vec![ctx.new_string(""rust_args_string"").into()];

        let obj_map = obj.to_map();
        println!(""{:#?}"", obj_map);

        if let Ok(o) = obj_map {
            println!(""---call function---"");
            if let Some(JsValue::Function(f)) = o.get(""f"") {
                f.call(&mut args);
            }
        }
        obj.set(""something_from_rust"", 255.into());
        println!(""---call function from obj---"");
        obj.invoke(""f"", &mut args);
    }
}

fn js_promise(ctx: &mut Context) {
    println!(""\n<----promise---->"");
    let code = r#""
    async function f1(){
        print(""f1 running"")
        return 1
    }
    async function f(){
        print(""f running"")
        let f1_result = await f1();
        print(""await f1"")
        return f1_result
    };
    f
    ""#;

    let r = ctx.eval_global_str(code);
    println!(""{:?}"", r);
    if let JsValue::Function(f) = r {
        let mut args = vec![];
        let r = f.call(&mut args);
        println!(""{:?}"", r);
        if let JsValue::Promise(p) = r {
            let result = p.get_result();
            println!(""promise result:{:?}"", result);
            println!(""poll promise"");
            ctx.promise_loop_poll();
            let result = p.get_result();
            println!(""promise result:{:?}"", result);
        }
    }
}
"
test/crypto/test-crypto-secret-keygen.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const {
  generateKey,
  generateKeySync
} = require('crypto');

[1, true, [], {}, Infinity, null, undefined].forEach((i) => {
  assert.throws(() => generateKey(i, 1, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""type"" argument must be /
  });
  assert.throws(() => generateKeySync(i, 1), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""type"" argument must be /
  });
});

['', true, [], null, undefined].forEach((i) => {
  assert.throws(() => generateKey('aes', i, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options"" argument must be /
  });
  assert.throws(() => generateKeySync('aes', i), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options"" argument must be /
  });
});

['', true, {}, [], null, undefined].forEach((length) => {
  assert.throws(() => generateKey('hmac', { length }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options\.length"" property must be /
  });
  assert.throws(() => generateKeySync('hmac', { length }), {
    code: 'ERR_INVALID_ARG_TYPE',
    message: /The ""options\.length"" property must be /
  });
});

assert.throws(() => generateKey('aes', { length: 256 }), {
  code: 'ERR_INVALID_ARG_TYPE'
});

assert.throws(() => generateKey('hmac', { length: -1 }, common.mustNotCall()), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKey('hmac', { length: 4 }, common.mustNotCall()), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKey('hmac', { length: 7 }, common.mustNotCall()), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(
  () => generateKey('hmac', { length: 2 ** 31 }, common.mustNotCall()), {
    code: 'ERR_OUT_OF_RANGE'
  });

assert.throws(() => generateKeySync('hmac', { length: -1 }), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKeySync('hmac', { length: 4 }), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(() => generateKeySync('hmac', { length: 7 }), {
  code: 'ERR_OUT_OF_RANGE'
});

assert.throws(
  () => generateKeySync('hmac', { length: 2 ** 31 }), {
    code: 'ERR_OUT_OF_RANGE'
  });

assert.throws(() => generateKeySync('aes', { length: 123 }), {
  code: 'ERR_INVALID_ARG_VALUE',
  message: /The property 'options\.length' must be one of: 128, 192, 256/
});

{
  const key = generateKeySync('aes', { length: 128 });
  assert(key);
  const keybuf = key.export();
  assert.strictEqual(keybuf.byteLength, 128 / 8);

  generateKey('aes', { length: 128 }, common.mustSucceed((key) => {
    assert(key);
    const keybuf = key.export();
    assert.strictEqual(keybuf.byteLength, 128 / 8);
  }));
}

{
  const key = generateKeySync('aes', { length: 256 });
  assert(key);
  const keybuf = key.export();
  assert.strictEqual(keybuf.byteLength, 256 / 8);

  generateKey('aes', { length: 256 }, common.mustSucceed((key) => {
    assert(key);
    const keybuf = key.export();
    assert.strictEqual(keybuf.byteLength, 256 / 8);
  }));
}

{
  const key = generateKeySync('hmac', { length: 123 });
  assert(key);
  const keybuf = key.export();
  assert.strictEqual(keybuf.byteLength, Math.floor(123 / 8));

  generateKey('hmac', { length: 123 }, common.mustSucceed((key) => {
    assert(key);
    const keybuf = key.export();
    assert.strictEqual(keybuf.byteLength, Math.floor(123 / 8));
  }));
}

assert.throws(
  () => generateKey('unknown', { length: 123 }, common.mustNotCall()), {
    code: 'ERR_INVALID_ARG_VALUE',
    message: /The argument 'type' must be a supported key type/
  });

assert.throws(() => generateKeySync('unknown', { length: 123 }), {
  code: 'ERR_INVALID_ARG_VALUE',
  message: /The argument 'type' must be a supported key type/
});
"
test/fs/test-fs-promises-watch.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import { watch } from 'fs/promises';
import fs from 'fs';
import assert from 'assert';
import { join } from 'path';
import tmpdir from '../common/tmpdir';

class WatchTestCase {
  constructor(shouldInclude, dirName, fileName, field) {
    this.dirName = dirName;
    this.fileName = fileName;
    this.field = field;
    this.shouldSkip = !shouldInclude;
  }
  get dirPath() { return join(tmpdir.path, this.dirName); }
  get filePath() { return join(this.dirPath, this.fileName); }
}

const kCases = [
  // Watch on a directory should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows || common.isAIX,
    'watch1',
    'foo',
    'filePath'
  ),
  // Watch on a file should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows,
    'watch2',
    'bar',
    'dirPath'
  ),
];

tmpdir.refresh();

for (const testCase of kCases) {
  if (testCase.shouldSkip) continue;
  fs.mkdirSync(testCase.dirPath);
  // Long content so it's actually flushed.
  const content1 = Date.now() + testCase.fileName.toLowerCase().repeat(1e4);
  fs.writeFileSync(testCase.filePath, content1);

  let interval;
  async function test() {
    const watcher = watch(testCase[testCase.field]);
    for await (const { eventType, filename } of watcher) {
      clearInterval(interval);
      assert.strictEqual(['rename', 'change'].includes(eventType), true);
      assert.strictEqual(filename, testCase.fileName);
      break;
    }

    // Waiting on it again is a non-op
    // eslint-disable-next-line no-unused-vars
    for await (const p of watcher) {
      assert.fail('should not run');
    }
  }

  // Long content so it's actually flushed. toUpperCase so there's real change.
  const content2 = Date.now() + testCase.fileName.toUpperCase().repeat(1e4);
  interval = setInterval(() => {
    fs.writeFileSync(testCase.filePath, '');
    fs.writeFileSync(testCase.filePath, content2);
  }, 100);

  test().then(common.mustCall());
}

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch(1)) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch(__filename, 1)) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { persistent: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { recursive: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { encoding: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_VALUE' });

assert.rejects(
  async () => {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch('', { signal: 1 })) { }
  },
  { code: 'ERR_INVALID_ARG_TYPE' });

(async () => {
  const ac = new AbortController();
  const { signal } = ac;
  setImmediate(() => ac.abort());
  try {
    // eslint-disable-next-line no-unused-vars, no-empty
    for await (const _ of watch(__filename, { signal })) { }
  } catch (err) {
    assert.strictEqual(err.name, 'AbortError');
  }
})().then(common.mustCall());
"
test/crypto/test-crypto-certificate.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { Certificate } = crypto;
const fixtures = require('../common/fixtures');

// Test Certificates
const spkacValid = fixtures.readKey('rsa_spkac.spkac');
const spkacChallenge = 'this-is-a-challenge';
const spkacFail = fixtures.readKey('rsa_spkac_invalid.spkac');
const spkacPublicPem = fixtures.readKey('rsa_public.pem');

function copyArrayBuffer(buf) {
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

function checkMethods(certificate) {

  assert.strictEqual(certificate.verifySpkac(spkacValid), true);
  assert.strictEqual(certificate.verifySpkac(spkacFail), false);

  assert.strictEqual(
    stripLineEndings(certificate.exportPublicKey(spkacValid).toString('utf8')),
    stripLineEndings(spkacPublicPem.toString('utf8'))
  );
  assert.strictEqual(certificate.exportPublicKey(spkacFail), '');

  assert.strictEqual(
    certificate.exportChallenge(spkacValid).toString('utf8'),
    spkacChallenge
  );
  assert.strictEqual(certificate.exportChallenge(spkacFail), '');

  const ab = copyArrayBuffer(spkacValid);
  assert.strictEqual(certificate.verifySpkac(ab), true);
  assert.strictEqual(certificate.verifySpkac(new Uint8Array(ab)), true);
  assert.strictEqual(certificate.verifySpkac(new DataView(ab)), true);
}

{
  // Test maximum size of input buffer
  let buf;
  let skip = false;
  try {
    buf = Buffer.alloc(2 ** 31);
  } catch {
    // The allocation may fail on some systems. That is expected due
    // to architecture and memory constraints. If it does, go ahead
    // and skip this test.
    skip = true;
  }
  if (!skip) {
    assert.throws(
      () => Certificate.verifySpkac(buf), {
        code: 'ERR_OUT_OF_RANGE'
      });
    assert.throws(
      () => Certificate.exportChallenge(buf), {
        code: 'ERR_OUT_OF_RANGE'
      });
    assert.throws(
      () => Certificate.exportPublicKey(buf), {
        code: 'ERR_OUT_OF_RANGE'
      });
  }
}

{
  // Test instance methods
  checkMethods(new Certificate());
}

{
  // Test static methods
  checkMethods(Certificate);
}

function stripLineEndings(obj) {
  return obj.replace(/\n/g, '');
}

// Direct call Certificate() should return instance
assert(Certificate() instanceof Certificate);

[1, {}, [], Infinity, true, undefined, null].forEach((val) => {
  assert.throws(
    () => Certificate.verifySpkac(val),
    { code: 'ERR_INVALID_ARG_TYPE' }
  );
});

[1, {}, [], Infinity, true, undefined, null].forEach((val) => {
  const errObj = { code: 'ERR_INVALID_ARG_TYPE' };
  assert.throws(() => Certificate.exportPublicKey(val), errObj);
  assert.throws(() => Certificate.exportChallenge(val), errObj);
});
"
modules/internal/crypto/hash.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import {
  getArrayBufferOrView,
  getDefaultEncoding,
  getStringOption,
  jobPromise,
  normalizeAlgorithm,
  normalizeHashName,
  validateMaxBufferLength,
  kHandle,
  getHashes,
} from '../crypto/util';

import {
  prepareSecretKey,
} from '../crypto/keys';

import {
  lazyDOMException,
} from '../util';

import {
  Buffer,
} from '../../buffer';

import {
  ERR_CRYPTO_HASH_FINALIZED,
  ERR_CRYPTO_HASH_UPDATE_FAILED,
  ERR_INVALID_ARG_TYPE,
} from '../errors';

import {
  validateEncoding,
  validateString,
  validateUint32,
} from '../validators';

import {
  isArrayBufferView,
} from '../util/types';

import { LazyTransform } from '../streams/lazy_transform';

const kState = Symbol('kState');
const kFinalized = Symbol('kFinalized');

import {
  JsHash as _Hash,
  JsHmac as _Hmac,
} from ""_node:crypto"";

function Hash(algorithm, options) {
  if (!(this instanceof Hash))
    return new Hash(algorithm, options);
  if (!(algorithm instanceof _Hash)) {
    validateString(algorithm, 'algorithm');
    if (!getHashes().includes(algorithm.toLowerCase())) {
      throw new Error(""Digest method not supported"");
    }
  }
  const xofLen = typeof options === 'object' && options !== null ?
    options.outputLength : undefined;
  if (xofLen !== undefined)
    validateUint32(xofLen, 'options.outputLength');
  this[kHandle] = new _Hash(algorithm, xofLen);
  this[kState] = {
    [kFinalized]: false
  };
  Reflect.apply(LazyTransform, this, [options]);
}

Object.setPrototypeOf(Hash.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Hash, LazyTransform);

Hash.prototype.copy = function copy(options) {
  const state = this[kState];
  if (state[kFinalized])
    throw new ERR_CRYPTO_HASH_FINALIZED();

  return new Hash(this[kHandle], options);
};

Hash.prototype._transform = function _transform(chunk, encoding, callback) {
  this.update(chunk, encoding);
  callback();
};

Hash.prototype._flush = function _flush(callback) {
  this.push(this.digest());
  callback();
};

Hash.prototype.update = function update(data, encoding) {
  encoding = encoding || getDefaultEncoding();

  const state = this[kState];
  if (state[kFinalized])
    throw new ERR_CRYPTO_HASH_FINALIZED();

  if (typeof data === 'string') {
    validateEncoding(data, encoding);
  } else if (!isArrayBufferView(data)) {
    throw new ERR_INVALID_ARG_TYPE(
      'data', ['string', 'Buffer', 'TypedArray', 'DataView'], data);
  }
  let buffer = getArrayBufferOrView(data, ""data"", encoding);
  if (!this[kHandle].update(buffer.buffer ?? buffer))
    throw new ERR_CRYPTO_HASH_UPDATE_FAILED();
  return this;
};


Hash.prototype.digest = function digest(outputEncoding) {
  const state = this[kState];
  if (state[kFinalized])
    throw new ERR_CRYPTO_HASH_FINALIZED();
  outputEncoding = outputEncoding || getDefaultEncoding();

  // Explicit conversion for backward compatibility.
  const ret = Buffer.from(this[kHandle].digest());
  state[kFinalized] = true;
  return outputEncoding === 'buffer' ? ret : ret.toString(outputEncoding);
};

function Hmac(hmac, key, options) {
  if (!(this instanceof Hmac))
    return new Hmac(hmac, key, options);
  validateString(hmac, 'hmac');
  if (!getHashes().includes(hmac.toLowerCase())) {
    throw new Error(""Digest method not supported"");
  }
  const encoding = getStringOption(options, 'encoding');
  key = prepareSecretKey(key, encoding);
  if (key.export !== undefined) {
    key = key.export();
  }
  this[kHandle] = new _Hmac(hmac, key.buffer ?? key);
  this[kState] = {
    [kFinalized]: false
  };
  Reflect.apply(LazyTransform, this, [options]);
}

Object.setPrototypeOf(Hmac.prototype, LazyTransform.prototype);
Object.setPrototypeOf(Hmac, LazyTransform);

Hmac.prototype.update = Hash.prototype.update;

Hmac.prototype.digest = function digest(outputEncoding) {
  const state = this[kState];
  outputEncoding = outputEncoding || getDefaultEncoding();

  if (state[kFinalized]) {
    const buf = Buffer.from('');
    return outputEncoding === 'buffer' ? buf : buf.toString(outputEncoding);
  }

  // Explicit conversion for backward compatibility.
  const ret = Buffer.from(this[kHandle].digest());
  state[kFinalized] = true;
  return outputEncoding === 'buffer' ? ret : ret.toString(outputEncoding);;
};

Hmac.prototype._flush = Hash.prototype._flush;
Hmac.prototype._transform = Hash.prototype._transform;

// Implementation for WebCrypto subtle.digest()

export {
  Hash,
  Hmac,
};
"
test/fs/test-fs-write-optional-params.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// This test ensures that fs.write accepts ""named parameters"" object
// and doesn't interpret objects as strings

import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';
import util from 'util';

tmpdir.refresh();

const destInvalid = path.resolve(tmpdir.path, 'rwopt_invalid');
const buffer = Buffer.from('zyx');

function testInvalidCb(fd, expectedCode, buffer, options, callback) {
  assert.throws(
    () => fs.write(fd, buffer, common.mustNotMutateObjectDeep(options), common.mustNotCall()),
    { code: expectedCode }
  );
  callback(0);
}

function testValidCb(buffer, options, index, callback) {
  options = common.mustNotMutateObjectDeep(options);
  const length = options?.length;
  const offset = options?.offset;
  const dest = path.resolve(tmpdir.path, `rwopt_valid_${index}`);
  fs.open(dest, 'w+', common.mustSucceed((fd) => {
    fs.write(fd, buffer, options, common.mustSucceed((bytesWritten, bufferWritten) => {
      bufferWritten = new Uint8Array(bufferWritten);
      const writeBufCopy = Uint8Array.prototype.slice.call(bufferWritten);

      fs.read(fd, buffer, options, common.mustSucceed((bytesRead, bufferRead) => {
        bufferRead = new Uint8Array(bufferRead);
        const readBufCopy = Uint8Array.prototype.slice.call(bufferRead);

        assert.ok(bytesWritten >= bytesRead);
        if (length !== undefined && length !== null) {
          assert.strictEqual(bytesWritten, length);
        }
        if (offset === undefined || offset === 0) {
          assert.deepStrictEqual(writeBufCopy, readBufCopy);
        }
        assert.deepStrictEqual(bufferWritten, bufferRead);
        fs.close(fd, common.mustSucceed(callback));
      }));
    }));
  }));
}

// Promisify to reduce flakiness
const testInvalid = util.promisify(testInvalidCb);
const testValid = util.promisify(testValidCb);

async function runTests(fd) {
  // Test if first argument is not wrongly interpreted as ArrayBufferView|string
  for (const badBuffer of [
    undefined, null, true, 42, 42n, Symbol('42'), NaN, [], () => { },
    Promise.resolve(new Uint8Array(1)),
    common.mustNotCall(),
    common.mustNotMutateObjectDeep({}),
    {},
    { buffer: 'amNotParam' },
    { string: 'amNotParam' },
    { buffer: new Uint8Array(1).buffer },
    new Date(),
    new String('notPrimitive'),
    { [Symbol.toPrimitive]: (hint) => 'amObject' },

    // TODO(LiviaMedeiros): add the following after DEP0162 EOL
    // { toString() { return 'amObject'; } },
  ]) {
    await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', badBuffer, {});
  }

  // First argument (buffer or string) is mandatory
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', undefined, undefined);

  // Various invalid options
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { length: 5 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { offset: 5 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { length: 1, offset: 3 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { length: -1 });
  await testInvalid(fd, 'ERR_OUT_OF_RANGE', buffer, { offset: -1 });
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, { offset: false });
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, { offset: true });
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, true);
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, '42');
  await testInvalid(fd, 'ERR_INVALID_ARG_TYPE', buffer, Symbol('42'));

  // Test compatibility with fs.read counterpart
  for (const [index, options] of [
    null,
    {},
    { length: 1 },
    { position: 5 },
    { length: 1, position: 5 },
    { length: 1, position: -1, offset: 2 },
    { length: null },
    { position: null },
    { offset: 1 },
  ].entries()) {
    await testValid(buffer, options, index);
  }
}

fs.open(destInvalid, 'w+', common.mustSucceed(async (fd) => {
  runTests(fd).then(common.mustCall(() => fs.close(fd, common.mustSucceed())));
}));
"
test/fs/test-fs-append-file-sync.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import { join } from 'path';
import fs from 'fs';

const currentFileData = 'ABCD';
const m = 0o600;
const num = 220;
const data = '203111' +
             '' +
             '203' +
             '196179112' +
             '11193' +
             '' +
             '##\n';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test that empty file will be created and have content added.
const filename = join(tmpdir.path, 'append-sync.txt');

fs.appendFileSync(filename, data);

const fileData = fs.readFileSync(filename);

assert.strictEqual(Buffer.byteLength(data), fileData.length);

// Test that appends data to a non empty file.
const filename2 = join(tmpdir.path, 'append-sync2.txt');
fs.writeFileSync(filename2, currentFileData);

fs.appendFileSync(filename2, data);

const fileData2 = fs.readFileSync(filename2);

assert.strictEqual(Buffer.byteLength(data) + currentFileData.length,
                   fileData2.length);

// Test that appendFileSync accepts buffers.
const filename3 = join(tmpdir.path, 'append-sync3.txt');
fs.writeFileSync(filename3, currentFileData);

const buf = Buffer.from(data, 'utf8');
fs.appendFileSync(filename3, buf);

const fileData3 = fs.readFileSync(filename3);

assert.strictEqual(buf.length + currentFileData.length, fileData3.length);

const filename4 = join(tmpdir.path, 'append-sync4.txt');
fs.writeFileSync(filename4, currentFileData, common.mustNotMutateObjectDeep({ mode: m }));

[
  true, false, 0, 1, Infinity, () => {}, {}, [], undefined, null,
].forEach((value) => {
  assert.throws(
    () => fs.appendFileSync(filename4, value, common.mustNotMutateObjectDeep({ mode: m })),
    { message: /data/, code: 'ERR_INVALID_ARG_TYPE' }
  );
});
fs.appendFileSync(filename4, `${num}`, common.mustNotMutateObjectDeep({ mode: m }));

// Windows permissions aren't Unix.
if (!common.isWindows) {
  const st = fs.statSync(filename4);
  assert.strictEqual(st.mode & 0o700, m);
}

const fileData4 = fs.readFileSync(filename4);

assert.strictEqual(Buffer.byteLength(String(num)) + currentFileData.length,
                   fileData4.length);

// Test that appendFile accepts file descriptors.
const filename5 = join(tmpdir.path, 'append-sync5.txt');
fs.writeFileSync(filename5, currentFileData);

const filename5fd = fs.openSync(filename5, 'a+', 0o600);
fs.appendFileSync(filename5fd, data);
fs.closeSync(filename5fd);

const fileData5 = fs.readFileSync(filename5);

assert.strictEqual(Buffer.byteLength(data) + currentFileData.length,
                   fileData5.length);
"
test/fs/test-fs-write-file.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = join(tmpdir.path, 'test.txt');

const s = '203111' +
          '' +
          '203' +
          '196179112' +
          '11193' +
          '' +
          '##\n';

fs.writeFile(filename, s, common.mustSucceed(() => {
  fs.readFile(filename, common.mustSucceed((buffer) => {
    assert.strictEqual(Buffer.byteLength(s), buffer.length);
  }));
}));

// Test that writeFile accepts buffers.
const filename2 = join(tmpdir.path, 'test2.txt');
const buf = Buffer.from(s, 'utf8');

fs.writeFile(filename2, buf, common.mustSucceed(() => {
  fs.readFile(filename2, common.mustSucceed((buffer) => {
    assert.strictEqual(buf.length, buffer.length);
  }));
}));

// Test that writeFile accepts file descriptors.
const filename4 = join(tmpdir.path, 'test4.txt');

fs.open(filename4, 'w+', common.mustSucceed((fd) => {
  fs.writeFile(fd, s, common.mustSucceed(() => {
    fs.close(fd, common.mustSucceed(() => {
      fs.readFile(filename4, common.mustSucceed((buffer) => {
        assert.strictEqual(Buffer.byteLength(s), buffer.length);
      }));
    }));
  }));
}));

/* unsupport AbortController
{
  // Test that writeFile is cancellable with an AbortSignal.
  // Before the operation has started
  const controller = new AbortController();
  const signal = controller.signal;
  const filename3 = join(tmpdir.path, 'test3.txt');

  fs.writeFile(filename3, s, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));

  controller.abort();
}

{
  // Test that writeFile is cancellable with an AbortSignal.
  // After the operation has started
  const controller = new AbortController();
  const signal = controller.signal;
  const filename4 = join(tmpdir.path, 'test5.txt');

  fs.writeFile(filename4, s, { signal }, common.mustCall((err) => {
    assert.strictEqual(err.name, 'AbortError');
  }));

  process.nextTick(() => controller.abort());
}

{
  // Test read-only mode
  const filename = join(tmpdir.path, 'test6.txt');
  fs.writeFileSync(filename, '');
  fs.writeFile(filename, s, { flag: 'r' }, common.expectsError(/EBADF/));
}
*/"
test/crypto/test-crypto-authenticated-stream.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
// Refs: https://github.com/nodejs/node/issues/31733
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const stream = require('stream');
const tmpdir = require('../common/tmpdir');

class Sink extends stream.Writable {
  constructor() {
    super();
    this.chunks = [];
  }

  _write(chunk, encoding, cb) {
    this.chunks.push(chunk);
    cb();
  }
}

function direct(config) {
  const { cipher, key, iv, aad, authTagLength, plaintextLength } = config;
  const expected = Buffer.alloc(plaintextLength);

  const c = crypto.createCipheriv(cipher, key, iv, { authTagLength });
  c.setAAD(aad, { plaintextLength });
  const ciphertext = Buffer.concat([c.update(expected), c.final()]);

  const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
  d.setAAD(aad, { plaintextLength });
  d.setAuthTag(c.getAuthTag());
  const actual = Buffer.concat([d.update(ciphertext), d.final()]);

  assert.deepStrictEqual(expected, actual);
}

function mstream(config) {
  const { cipher, key, iv, aad, authTagLength, plaintextLength } = config;
  const expected = Buffer.alloc(plaintextLength);

  const c = crypto.createCipheriv(cipher, key, iv, { authTagLength });
  c.setAAD(aad, { plaintextLength });

  const plain = new stream.PassThrough();
  const crypt = new Sink();
  const chunks = crypt.chunks;
  plain.pipe(c).pipe(crypt);
  plain.end(expected);

  crypt.on('close', common.mustCall(() => {
    const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
    d.setAAD(aad, { plaintextLength });
    d.setAuthTag(c.getAuthTag());

    const crypt = new stream.PassThrough();
    const plain = new Sink();
    crypt.pipe(d).pipe(plain);
    for (const chunk of chunks) crypt.write(chunk);
    crypt.end();

    plain.on('close', common.mustCall(() => {
      const actual = Buffer.concat(plain.chunks);
      assert.deepStrictEqual(expected, actual);
    }));
  }));
}

function fstream(config) {
  const count = fstream.count++;
  const filename = (name) => path.join(tmpdir.path, `${name}${count}`);

  const { cipher, key, iv, aad, authTagLength, plaintextLength } = config;
  const expected = Buffer.alloc(plaintextLength);
  fs.writeFileSync(filename('a'), expected);

  const c = crypto.createCipheriv(cipher, key, iv, { authTagLength });
  c.setAAD(aad, { plaintextLength });

  const plain = fs.createReadStream(filename('a'));
  const crypt = fs.createWriteStream(filename('b'));
  plain.pipe(c).pipe(crypt);

  // Observation: 'close' comes before 'end' on |c|, which definitely feels
  // wrong. Switching to `c.on('end', ...)` doesn't fix the test though.
  crypt.on('close', common.mustCall(() => {
    // Just to drive home the point that decryption does actually work:
    // reading the file synchronously, then decrypting it, works.
    {
      const ciphertext = fs.readFileSync(filename('b'));
      const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
      d.setAAD(aad, { plaintextLength });
      d.setAuthTag(c.getAuthTag());
      const actual = Buffer.concat([d.update(ciphertext), d.final()]);
      assert.deepStrictEqual(expected, actual);
    }

    const d = crypto.createDecipheriv(cipher, key, iv, { authTagLength });
    d.setAAD(aad, { plaintextLength });
    d.setAuthTag(c.getAuthTag());

    const crypt = fs.createReadStream(filename('b'));
    const plain = fs.createWriteStream(filename('c'));
    crypt.pipe(d).pipe(plain);

    plain.on('close', common.mustCall(() => {
      const actual = fs.readFileSync(filename('c'));
      assert.deepStrictEqual(expected, actual);
    }));
  }));
}
fstream.count = 0;

function test(config) {
  direct(config);
  mstream(config);
  fstream(config);
}

tmpdir.refresh();

test({
  cipher: 'aes-128-ccm',
  aad: Buffer.alloc(1),
  iv: Buffer.alloc(8),
  key: Buffer.alloc(16),
  authTagLength: 16,
  plaintextLength: 32768,
});

test({
  cipher: 'aes-128-ccm',
  aad: Buffer.alloc(1),
  iv: Buffer.alloc(8),
  key: Buffer.alloc(16),
  authTagLength: 16,
  plaintextLength: 32769,
});
"
test/fs/test-fs-watchfile.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

// Basic usage tests.
assert.throws(
  () => {
    fs.watchFile('./some-file');
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.watchFile('./another-file', {}, 'bad listener');
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(() => {
  fs.watchFile(new Object(), common.mustNotCall());
}, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });

const enoentFile = path.join(tmpdir.path, 'non-existent-file');
const expectedStatObject = new fs.Stats(
  0,                                        // dev
  0,                                        // mode
  0,                                        // nlink
  0,                                        // uid
  0,                                        // gid
  0,                                        // rdev
  0,                                        // blksize
  0,                                        // ino
  0,                                        // size
  0,                                        // blocks
  Date.UTC(1970, 0, 1, 0, 0, 0),            // atime
  Date.UTC(1970, 0, 1, 0, 0, 0),            // mtime
  Date.UTC(1970, 0, 1, 0, 0, 0),            // ctime
  Date.UTC(1970, 0, 1, 0, 0, 0)             // birthtime
);

tmpdir.refresh();

// If the file initially didn't exist, and gets created at a later point of
// time, the callback should be invoked again with proper values in stat object
let fileExists = false;

const watcher =
  fs.watchFile(enoentFile, { interval: 0 }, common.mustCall((curr, prev) => {
    if (!fileExists) {
      // If the file does not exist, all the fields should be zero and the date
      // fields should be UNIX EPOCH time
      assert.deepStrictEqual(curr, expectedStatObject);
      assert.deepStrictEqual(prev, expectedStatObject);
      // Create the file now, so that the callback will be called back once the
      // event loop notices it.
      fs.closeSync(fs.openSync(enoentFile, 'w'));
      fileExists = true;
    } else {
      // If the ino (inode) value is greater than zero, it means that the file
      // is present in the filesystem and it has a valid inode number.
      assert(curr.ino > 0);
      // As the file just got created, previous ino value should be lesser than
      // or equal to zero (non-existent file).
      assert(prev.ino <= 0);
      // Stop watching the file
      fs.unwatchFile(enoentFile);
      watcher.stop();  // Stopping a stopped watcher should be a noop
    }
  }, 2));

// 'stop' should only be emitted once - stopping a stopped watcher should
// not trigger a 'stop' event.
watcher.on('stop', common.mustCall(function onStop() {}));

// Watch events should callback with a filename on supported systems.
// Omitting AIX. It works but not reliably.
if (common.isLinux || common.isOSX || common.isWindows) {
  const dir = path.join(tmpdir.path, 'watch');

  fs.mkdir(dir, common.mustCall(function(err) {
    if (err) assert.fail(err);

    fs.watch(dir, common.mustCall(function(eventType, filename) {
      clearInterval(interval);
      this._handle.close();
      assert.strictEqual(filename, 'foo.txt');
    }));

    const interval = setInterval(() => {
      fs.writeFile(path.join(dir, 'foo.txt'), 'foo', common.mustCall((err) => {
        if (err) assert.fail(err);
      }));
    }, 1);
  }));
}
"
test/crypto/test-crypto-dh-padding.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('node compiled without OpenSSL.');

const assert = require('assert');
const crypto = require('crypto');

// This test verifies padding with leading zeroes for shared
// secrets that are strictly smaller than the modulus (prime).
// See:
//  RFC 4346: https://www.ietf.org/rfc/rfc4346.txt
//  https://github.com/nodejs/node-v0.x-archive/issues/7906
//  https://github.com/nodejs/node-v0.x-archive/issues/5239
//
// In FIPS mode OPENSSL_DH_FIPS_MIN_MODULUS_BITS = 1024, meaning we need
// a FIPS-friendly >= 1024 bit prime, we can use MODP 14 from RFC 3526:
// https://www.ietf.org/rfc/rfc3526.txt
//
// We can generate appropriate values with this code:
//
// crypto = require('crypto');
//
// for (;;) {
//   var a = crypto.getDiffieHellman('modp14'),
//   var b = crypto.getDiffieHellman('modp14');
//
//   a.generateKeys();
//   b.generateKeys();
//
//   var aSecret = a.computeSecret(b.getPublicKey()).toString('hex');
//   console.log(""A public: "" + a.getPublicKey().toString('hex'));
//   console.log(""A private: "" + a.getPrivateKey().toString('hex'));
//   console.log(""B public: "" + b.getPublicKey().toString('hex'));
//   console.log(""B private: "" + b.getPrivateKey().toString('hex'));
//   console.log(""A secret: "" + aSecret);
//   console.log('-------------------------------------------------');
//   if(aSecret.substring(0,2) === ""00"") {
//     console.log(""found short key!"");
//     return;
//   }
// }

const apub =
'5484455905d3eff34c70980e871f27f05448e66f5a6efbb97cbcba4e927196c2bd9ea272cded91\
10a4977afa8d9b16c9139a444ed2d954a794650e5d7cb525204f385e1af81530518563822ecd0f9\
524a958d02b3c269e79d6d69850f0968ad567a4404fbb0b19efc8bc73e267b6136b88cafb33299f\
f7c7cace3ffab1a88c2c9ee841f88b4c3679b4efc465f5c93cca11d487be57373e4c5926f634c4e\
efee6721d01db91cd66321615b2522f96368dbc818875d422140d0edf30bdb97d9721feddcb9ff6\
453741a4f687ee46fc54bf1198801f1210ac789879a5ee123f79e2d2ce1209df2445d32166bc9e4\
8f89e944ec9c3b2e16c8066cd8eebd4e33eb941';
const bpub =
'3fca64510e36bc7da8a3a901c7b74c2eabfa25deaf7cbe1d0c50235866136ad677317279e1fb0\
06e9c0a07f63e14a3363c8e016fbbde2b2c7e79fed1cc3e08e95f7459f547a8cd0523ee9dc744d\
e5a956d92b937db4448917e1f6829437f05e408ee7aea70c0362b37370c7c75d14449d8b2d2133\
04ac972302d349975e2265ca7103cfebd019d9e91234d638611abd049014f7abf706c1c5da6c88\
788a1fdc6cdf17f5fffaf024ce8711a2ebde0b52e9f1cb56224483826d6e5ac6ecfaae07b75d20\
6e8ac97f5be1a5b68f20382f2a7dac189cf169325c4cf845b26a0cd616c31fec905c5d9035e5f7\
8e9880c812374ac0f3ca3d365f06e4be526b5affd4b79';
const apriv =
'62411e34704637d99c6c958a7db32ac22fcafafbe1c33d2cfdb76e12ded41f38fc16b792b9041\
2e4c82755a3815ba52f780f0ee296ad46e348fc4d1dcd6b64f4eea1b231b2b7d95c5b1c2e26d34\
83520558b9860a6eb668f01422a54e6604aa7702b4e67511397ef3ecb912bff1a83899c5a5bfb2\
0ee29249a91b8a698e62486f7009a0e9eaebda69d77ecfa2ca6ba2db6c8aa81759c8c90c675979\
08c3b3e6fc60668f7be81cce6784482af228dd7f489005253a165e292802cfd0399924f6c56827\
7012f68255207722355634290acc7fddeefbba75650a85ece95b6a12de67eac016ba78960108dd\
5dbadfaa43cc9fed515a1f307b7d90ae0623bc7b8cefb';
const secret =
'00c37b1e06a436d6717816a40e6d72907a6f255638b93032267dcb9a5f0b4a9aa0236f3dce63b\
1c418c60978a00acd1617dfeecf1661d8a3fafb4d0d8824386750f4853313400e7e4afd22847e4\
fa56bc9713872021265111906673b38db83d10cbfa1dea3b6b4c97c8655f4ae82125281af7f234\
8916a15c6f95649367d169d587697480df4d10b381479e86d5518b520d9d8fb764084eab518224\
dc8fe984ddaf532fc1531ce43155fa0ab32532bf1ece5356b8a3447b5267798a904f16f3f4e635\
597adc0179d011132dcffc0bbcb0dd2c8700872f8663ec7ddd897c659cc2efebccc73f38f0ec96\
8612314311231f905f91c63a1aea52e0b60cead8b57df';

/* FIPS-friendly 2048 bit prime */
const p = crypto.createDiffieHellman(
  crypto.getDiffieHellman('modp14').getPrime());

p.setPublicKey(apub, 'hex');
p.setPrivateKey(apriv, 'hex');

assert.strictEqual(
  p.computeSecret(bpub, 'hex', 'hex').toString('hex'),
  secret
);
"
test/fs/test-fs-read.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');

const expected = Buffer.from('xyz\n');

function test(bufferAsync, bufferSync, expected) {
  fs.read(fd,
          bufferAsync,
          0,
          expected.length,
          0,
          common.mustSucceed((bytesRead) => {
            assert.strictEqual(bytesRead, expected.length);
            assert.deepStrictEqual(bufferAsync, expected);
          }));

  const r = fs.readSync(fd, bufferSync, 0, expected.length, 0);
  assert.deepStrictEqual(bufferSync, expected);
  assert.strictEqual(r, expected.length);
}

test(Buffer.allocUnsafe(expected.length),
     Buffer.allocUnsafe(expected.length),
     expected);

test(new Uint8Array(expected.length),
     new Uint8Array(expected.length),
     Uint8Array.from(expected));

{
  // Reading beyond file length (3 in this case) should return no data.
  // This is a test for a bug where reads > uint32 would return data
  // from the current position in the file.
  const pos = 0xffffffff + 1; // max-uint32 + 1
  const nRead = fs.readSync(fd, Buffer.alloc(1), 0, 1, pos);
  assert.strictEqual(nRead, 0);

  fs.read(fd, Buffer.alloc(1), 0, 1, pos, common.mustSucceed((nRead) => {
    assert.strictEqual(nRead, 0);
  }));
}
/* non-public in api doc
assert.throws(() => new fs.Dir(), {
  code: 'ERR_MISSING_ARGS',
});
*/
assert.throws(
  () => fs.read(fd, Buffer.alloc(1), 0, 1, 0),
  {
    code: 'ERR_INVALID_ARG_TYPE',
  }
);

assert.throws(
  () => fs.read(fd, { buffer: null }, common.mustNotCall()),
  /TypeError: cannot read property 'byteLength' of null/,
  'throws when options.buffer is null'
);

assert.throws(
  () => fs.readSync(fd, { buffer: null }),
  /TypeError/,
  'throws when options.buffer is null'
);

assert.throws(
  () => fs.read(null, Buffer.alloc(1), 0, 1, 0),
  {
    message: 'The ""fd"" argument must be of type number. Received null',
    code: 'ERR_INVALID_ARG_TYPE',
  }
);
"
test/crypto/test-crypto-async-sign-verify.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const util = require('util');
const crypto = require('crypto');
const fixtures = require('../common/fixtures');

function test(
  publicFixture,
  privateFixture,
  algorithm,
  deterministic,
  options
) {
  let publicPem = fixtures.readKey(publicFixture);
  let privatePem = fixtures.readKey(privateFixture);
  let privateKey = crypto.createPrivateKey(privatePem);
  let publicKey = crypto.createPublicKey(publicPem);
  const privateDer = {
    key: privateKey.export({ format: 'der', type: 'pkcs8' }),
    format: 'der',
    type: 'pkcs8',
    ...options
  };
  const publicDer = {
    key: publicKey.export({ format: 'der', type: 'spki' }),
    format: 'der',
    type: 'spki',
    ...options
  };

  if (options) {
    publicPem = { ...options, key: publicPem };
    privatePem = { ...options, key: privatePem };
    privateKey = { ...options, key: privateKey };
    publicKey = { ...options, key: publicKey };
  }

  const data = Buffer.from('Hello world');
  const expected = crypto.sign(algorithm, data, privateKey);

  for (const key of [privatePem, privateKey, privateDer]) {
    crypto.sign(algorithm, data, key, common.mustSucceed((actual) => {
      if (deterministic) {
        assert.deepStrictEqual(actual, expected);
      }

      assert.strictEqual(
        crypto.verify(algorithm, data, key, actual), true);
    }));
  }

  const verifyInputs = [
    publicPem, publicKey, publicDer, privatePem, privateKey, privateDer];
  for (const key of verifyInputs) {
    crypto.verify(algorithm, data, key, expected, common.mustSucceed(
      (verified) => assert.strictEqual(verified, true)));

    crypto.verify(algorithm, data, key, Buffer.from(''), common.mustSucceed(
      (verified) => assert.strictEqual(verified, false)));
  }
}

// RSA w/ default padding
test('rsa_public.pem', 'rsa_private.pem', 'sha256', true);
test('rsa_public.pem', 'rsa_private.pem', 'sha256', true,
     { padding: crypto.constants.RSA_PKCS1_PADDING });

// RSA w/ PSS_PADDING and default saltLength
test('rsa_public.pem', 'rsa_private.pem', 'sha256', false,
     { padding: crypto.constants.RSA_PKCS1_PSS_PADDING });
test('rsa_public.pem', 'rsa_private.pem', 'sha256', false,
     {
       padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
       saltLength: crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN
     });

// RSA w/ PSS_PADDING and PSS_SALTLEN_DIGEST
test('rsa_public.pem', 'rsa_private.pem', 'sha256', false,
     {
       padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
       saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
     });

// ED25519
test('ed25519_public.pem', 'ed25519_private.pem', undefined, true);
// ED448
test('ed448_public.pem', 'ed448_private.pem', undefined, true);

// ECDSA w/ der signature encoding
test('ec_secp256k1_public.pem', 'ec_secp256k1_private.pem', 'sha384',
     false);
test('ec_secp256k1_public.pem', 'ec_secp256k1_private.pem', 'sha384',
     false, { dsaEncoding: 'der' });

// ECDSA w/ ieee-p1363 signature encoding
test('ec_secp256k1_public.pem', 'ec_secp256k1_private.pem', 'sha384', false,
     { dsaEncoding: 'ieee-p1363' });

// DSA w/ der signature encoding
test('dsa_public.pem', 'dsa_private.pem', 'sha256',
     false);
test('dsa_public.pem', 'dsa_private.pem', 'sha256',
     false, { dsaEncoding: 'der' });

// DSA w/ ieee-p1363 signature encoding
test('dsa_public.pem', 'dsa_private.pem', 'sha256', false,
     { dsaEncoding: 'ieee-p1363' });

// Test Parallel Execution w/ KeyObject is threadsafe in openssl3
{
  const publicKey = {
    key: crypto.createPublicKey(
      fixtures.readKey('ec_p256_public.pem')),
    dsaEncoding: 'ieee-p1363',
  };
  const privateKey = {
    key: crypto.createPrivateKey(
      fixtures.readKey('ec_p256_private.pem')),
    dsaEncoding: 'ieee-p1363',
  };

  const sign = util.promisify(crypto.sign);
  const verify = util.promisify(crypto.verify);

  const data = Buffer.from('hello world');

  Promise.all([
    sign('sha256', data, privateKey),
    sign('sha256', data, privateKey),
    sign('sha256', data, privateKey),
  ]).then(([signature]) => {
    return Promise.all([
      verify('sha256', data, publicKey, signature),
      verify('sha256', data, publicKey, signature),
      verify('sha256', data, publicKey, signature),
    ]).then(common.mustCall());
  })
  .catch(common.mustNotCall());
}
"
modules/internal/crypto/hkdf.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import {
  validateFunction,
  validateInteger,
  validateString,
  validateUint32,
} from '../validators';

import { kMaxLength } from '../../buffer';

import {
  getArrayBufferOrView,
  normalizeHashName,
  toBuf,
  validateByteSource,
  kKeyObject,
  getHashes,
} from '../crypto/util';

import {
  createSecretKey,
  isKeyObject,
} from './keys';

import {
  lazyDOMException,
} from '../util';

import {
  isAnyArrayBuffer,
  isArrayBufferView,
} from '../util/types';

import {
  ERR_INVALID_ARG_TYPE,
  ERR_OUT_OF_RANGE,
  ERR_MISSING_OPTION,
  hideStackFrames,
  ERR_CRYPTO_INVALID_DIGEST,
  ERR_CRYPTO_INVALID_KEYLEN,
} from '../errors';

import { hkdf_sync } from ""_node:crypto"";

const validateParameters = hideStackFrames((hash, key, salt, info, length) => {
  validateString(hash, 'digest');

  key = prepareKey(key).export();
  salt = validateByteSource(salt, 'salt');
  info = validateByteSource(info, 'info');

  validateInteger(length, 'length', 0, kMaxLength);
  if (info.byteLength > 1024) {
    throw new ERR_OUT_OF_RANGE(
      'info',
      'must not contain more than 1024 bytes',
      info.byteLength);
  }

  if (!getHashes().includes(hash)) {
    throw new ERR_CRYPTO_INVALID_DIGEST(hash);
  }

  if (hash === ""sha256"" && length > 255 * 32) {
    throw new ERR_CRYPTO_INVALID_KEYLEN()
  } else if (hash === ""sha512"" && length > 255 * 64) {
    throw new ERR_CRYPTO_INVALID_KEYLEN()
  }

  return {
    hash,
    key,
    salt,
    info,
    length,
  };
});

function prepareKey(key) {
  if (isKeyObject(key))
    return key;

  if (isAnyArrayBuffer(key))
    return createSecretKey(key);

  key = toBuf(key);

  if (!isArrayBufferView(key)) {
    throw new ERR_INVALID_ARG_TYPE(
      'ikm',
      [
        'string',
        'SecretKeyObject',
        'ArrayBuffer',
        'TypedArray',
        'DataView',
        'Buffer',
      ],
      key);
  }

  return createSecretKey(key);
}

function hkdf(hash, key, salt, info, length, callback) {
  ({
    hash,
    key,
    salt,
    info,
    length,
  } = validateParameters(hash, key, salt, info, length));

  validateFunction(callback, 'callback');

  setTimeout(() => {
    let result = hkdf_sync(key.buffer ?? key, salt.buffer ?? salt, info.buffer ?? info, length, hash.toUpperCase());
    callback(null, result);
  }, 0);
}

function hkdfSync(hash, key, salt, info, length) {
  ({
    hash,
    key,
    salt,
    info,
    length,
  } = validateParameters(hash, key, salt, info, length));
  let result = hkdf_sync(key.buffer ?? key, salt.buffer ?? salt, info.buffer ?? info, length, hash.toUpperCase());
  return result;
}

async function hkdfDeriveBits(algorithm, baseKey, length) {
  const { hash } = algorithm;
  const salt = getArrayBufferOrView(algorithm.salt, 'algorithm.salt');
  const info = getArrayBufferOrView(algorithm.info, 'algorithm.info');
  if (hash === undefined)
    throw new ERR_MISSING_OPTION('algorithm.hash');

  let byteLength = 512 / 8;
  if (length !== undefined) {
    if (length === 0)
      throw lazyDOMException('length cannot be zero', 'OperationError');
    if (length === null)
      throw lazyDOMException('length cannot be null', 'OperationError');
    validateUint32(length, 'length');
    if (length % 8) {
      throw lazyDOMException(
        'length must be a multiple of 8',
        'OperationError');
    }
    byteLength = length / 8;
  }

  return new Promise((resolve, reject) => {
    hkdf(
      normalizeHashName(hash.name),
      baseKey[kKeyObject],
      salt,
      info,
      byteLength,
      (err, bits) => {
        if (err) return reject(err);
        resolve(bits);
      });
  });
}

export {
  hkdf,
  hkdfSync,
  hkdfDeriveBits,
};
"
test/fs/test-fs-open.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

let caughtException = false;

try {
  // Should throw ENOENT, not EBADF
  // see https://github.com/joyent/node/pull/1228
  fs.openSync('/8hvftyuncxrt/path/to/file/that/does/not/exist', 'r');
} catch (e) {
  assert.strictEqual(e.code, 'ENOENT');
  caughtException = true;
}
assert.strictEqual(caughtException, true);

fs.openSync(__filename);

fs.open(__filename, common.mustSucceed());

fs.open(__filename, 'r', common.mustSucceed());

fs.open(__filename, 'rs', common.mustSucceed());

fs.open(__filename, 'r', 0, common.mustSucceed());

fs.open(__filename, 'r', null, common.mustSucceed());

async function promise() {
  await fs.promises.open(__filename);
  await fs.promises.open(__filename, 'r');
}

promise().then(common.mustCall()).catch(common.mustNotCall());

assert.throws(
  () => fs.open(__filename, 'r', 'boom', common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    name: 'TypeError'
  }
);

for (const extra of [[], ['r'], ['r', 0], ['r', 0, 'bad callback']]) {
  assert.throws(
    () => fs.open(__filename, ...extra),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
}

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.open(i, 'r', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.openSync(i, 'r', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.rejects(
    fs.promises.open(i, 'r'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Check invalid modes.
[false, [], {}].forEach((mode) => {
  assert.throws(
    () => fs.open(__filename, 'r', mode, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    }
  );
  assert.throws(
    () => fs.openSync(__filename, 'r', mode, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    }
  );
  assert.rejects(
    fs.promises.open(__filename, 'r', mode),
    {
      code: 'ERR_INVALID_ARG_TYPE'
    }
  );
});
"
examples/js_extend.rs,"use wasmedge_quickjs::js_class;
use wasmedge_quickjs::{
    AsObject, Context, ExtendsJsClassDef, JsClassDef, JsClassField, JsClassMethod, JsClassTool,
    JsObject, JsValue, Runtime,
};

#[derive(Debug)]
struct ClassA(i32);

impl ClassA {
    pub fn get_val(&self, _ctx: &mut Context) -> JsValue {
        JsValue::Int(self.0)
    }

    pub fn inc(
        &mut self,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        self.0 += 1;
        JsValue::Int(self.0)
    }
}

impl JsClassDef for ClassA {
    type RefType = ClassA;

    const CLASS_NAME: &'static str = ""ClassA"";

    const CONSTRUCTOR_ARGC: u8 = 1;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[(""val"", ClassA::get_val, None)];

    const METHODS: &'static [JsClassMethod<Self::RefType>] = &[(""inc"", 0, ClassA::inc)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(
        _ctx: &mut wasmedge_quickjs::Context,
        argv: &[wasmedge_quickjs::JsValue],
    ) -> Result<Self::RefType, wasmedge_quickjs::JsValue> {
        match argv.get(0) {
            Some(JsValue::Int(v)) => Ok(ClassA(*v)),
            _ => Ok(ClassA(0)),
        }
    }
}

#[derive(Debug)]
struct ClassB(ClassA, i32);

impl AsRef<ClassA> for ClassB {
    fn as_ref(&self) -> &ClassA {
        &self.0
    }
}

impl AsMut<ClassA> for ClassB {
    fn as_mut(&mut self) -> &mut ClassA {
        &mut self.0
    }
}

impl ClassB {
    pub fn get_val_b(&self, _ctx: &mut Context) -> JsValue {
        JsValue::Int(self.1)
    }

    pub fn inc_b(
        &mut self,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        self.1 += 1;
        JsValue::Int(self.1)
    }

    pub fn display(
        &mut self,
        _this_obj: &mut JsObject,
        _ctx: &mut Context,
        _argv: &[JsValue],
    ) -> JsValue {
        println!(""display=> {:?}"", self);
        JsValue::UnDefined
    }
}

impl ExtendsJsClassDef for ClassB {
    type RefType = ClassB;

    type BaseDef = ClassA;

    const EXT_CLASS_NAME: &'static str = ""ClassB"";

    const CONSTRUCTOR_ARGC: u8 = 1;

    const FIELDS: &'static [JsClassField<Self::RefType>] = &[(""val_b"", ClassB::get_val_b, None)];

    const METHODS: &'static [JsClassMethod<Self::RefType>] =
        &[(""inc_b"", 0, ClassB::inc_b), (""display"", 0, ClassB::display)];

    unsafe fn mut_class_id_ptr() -> &'static mut u32 {
        static mut CLASS_ID: u32 = 0;
        &mut CLASS_ID
    }

    fn constructor_fn(
        ctx: &mut wasmedge_quickjs::Context,
        argv: &[JsValue],
    ) -> Result<Self::RefType, JsValue> {
        let a = ClassA::constructor_fn(ctx, argv)?;
        Ok(ClassB(a, 1))
    }
}

fn main() {
    let mut rt = Runtime::new();
    rt.run_with_context(|ctx| {
        let a_ctor = js_class::register_class::<ClassA>(ctx);
        let b_ctor = js_class::register_class::<ClassB>(ctx);

        let a_proto = ClassA::proto(ctx);
        let b_proto = ClassB::proto(ctx);

        js_class::class_extends(ctx, b_proto, a_proto);

        let mut global = ctx.get_global();
        global.set(""ClassA"", a_ctor);
        global.set(""ClassB"", b_ctor);

        let code = r#""
        let a = new ClassA(1)
        print('a.val =',a.val)
        print('a.inc() =',a.inc())
        print('a.val =',a.val)
        print()

        let b = new ClassB()
        print('b.val =',b.val)
        print('b.inc() =',b.inc())
        print('b.val =',b.val)
        print()

        print('b.val_b =',b.val_b)
        print('b.inc_b() =',b.inc_b())
        print('b.val_b =',b.val_b)
        print()

        b.display()
        print()

        print('b instanceof ClassA =',b instanceof ClassA)
        ""#;
        ctx.eval_global_str(code.to_string());
    })
}
"
test/fs/test-fs-stat-date.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import * as common from '../common';

// Test timestamps returned by fsPromises.stat and fs.statSync

import fs from 'fs';
import fsPromises from 'fs/promises';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir.js';

(async () => {

  // On some platforms (for example, ppc64) boundaries are tighter
  // than usual. If we catch these errors, skip corresponding test.
  const ignoredErrors = new Set(['EINVAL', 'EOVERFLOW']);

  tmpdir.refresh();
  const filepath = path.resolve(tmpdir.path, 'timestamp');

  await (await fsPromises.open(filepath, 'w')).close();

  // Perform a trivial check to determine if filesystem supports setting
  // and retrieving atime and mtime. If it doesn't, skip the test.
  await fsPromises.utimes(filepath, 2, 2);
  const { atimeMs, mtimeMs } = await fsPromises.stat(filepath);
  if (atimeMs !== 2000 || mtimeMs !== 2000) {
    common.skip(`Unsupported filesystem (atime=${atimeMs}, mtime=${mtimeMs})`);
  }

  // Date might round down timestamp
  function closeEnough(actual, expected, margin) {
    // On ppc64, value is rounded to seconds
    if (process.arch === 'ppc64') {
      margin += 1000;
    }
    assert.ok(Math.abs(Number(actual - expected)) < margin,
      `expected ${expected}  ${margin}, got ${actual}`);
  }

  async function runTest(atime, mtime, margin = 0) {
    margin += Number.EPSILON;
    try {
      await fsPromises.utimes(filepath, new Date(atime), new Date(mtime));
    } catch (e) {
      if (ignoredErrors.has(e.code)) return;
      throw e;
    }

    const stats = await fsPromises.stat(filepath);
    closeEnough(stats.atimeMs, atime, margin);
    closeEnough(stats.mtimeMs, mtime, margin);
    closeEnough(stats.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(stats.mtime.getTime(), new Date(mtime).getTime(), margin);

    const statsBigint = await fsPromises.stat(filepath, { bigint: true });
    closeEnough(statsBigint.atimeMs, BigInt(atime), margin);
    closeEnough(statsBigint.mtimeMs, BigInt(mtime), margin);
    closeEnough(statsBigint.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(statsBigint.mtime.getTime(), new Date(mtime).getTime(), margin);

    const statsSync = fs.statSync(filepath);
    closeEnough(statsSync.atimeMs, atime, margin);
    closeEnough(statsSync.mtimeMs, mtime, margin);
    closeEnough(statsSync.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(statsSync.mtime.getTime(), new Date(mtime).getTime(), margin);

    const statsSyncBigint = fs.statSync(filepath, { bigint: true });
    closeEnough(statsSyncBigint.atimeMs, BigInt(atime), margin);
    closeEnough(statsSyncBigint.mtimeMs, BigInt(mtime), margin);
    closeEnough(statsSyncBigint.atime.getTime(), new Date(atime).getTime(), margin);
    closeEnough(statsSyncBigint.mtime.getTime(), new Date(mtime).getTime(), margin);
  }

  // Too high/low numbers produce too different results on different platforms
  {
    // TODO(LiviaMedeiros): investigate outdated stat time on FreeBSD.
    // On Windows, filetime is stored and handled differently. Supporting dates
    // after Y2038 is preferred over supporting dates before 1970-01-01.
    if (!common.isFreeBSD && !common.isWindows) {
      await runTest(-40691, -355, 1); // Potential precision loss on 32bit
      await runTest(-355, -40691, 1);  // Potential precision loss on 32bit
      await runTest(-1, -1);
    }
    await runTest(0, 0);
    await runTest(1, 1);
    await runTest(355, 40691, 1); // Precision loss on 32bit
    await runTest(40691, 355, 1); // Precision loss on 32bit
    await runTest(1713037251360, 1713037251360, 1); // Precision loss
  }

})();"
test/fs/test-fs-promises-write-optional-params.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// This test ensures that filehandle.write accepts ""named parameters"" object
// and doesn't interpret objects as strings

import assert from 'assert';
import fsPromises from 'fs/promises';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const dest = path.resolve(tmpdir.path, 'tmp.txt');
const buffer = Buffer.from('zyx');

async function testInvalid(dest, expectedCode, ...params) {
  if (params.length >= 2) {
    params[1] = common.mustNotMutateObjectDeep(params[1]);
  }
  let fh;
  try {
    fh = await fsPromises.open(dest, 'w+');
    await assert.rejects(
      fh.write(...params),
      { code: expectedCode });
  } finally {
    await fh?.close();
  }
}

async function testValid(dest, buffer, options) {
  const length = options?.length;
  const offset = options?.offset;
  let fh;
  try {
    fh = await fsPromises.open(dest, 'w+');
    const writeResult = await fh.write(buffer, options);
    writeResult.buffer = new Uint8Array(writeResult.buffer);
    const writeBufCopy = Uint8Array.prototype.slice.call(writeResult.buffer);

    const readResult = await fh.read(buffer, options);
    readResult.buffer = new Uint8Array(readResult.buffer);
    const readBufCopy = Uint8Array.prototype.slice.call(readResult.buffer);

    assert.ok(writeResult.bytesWritten >= readResult.bytesRead);
    if (length !== undefined && length !== null) {
      assert.strictEqual(writeResult.bytesWritten, length);
    }
    if (offset === undefined || offset === 0) {
      assert.deepStrictEqual(writeBufCopy, readBufCopy);
    }
    assert.deepStrictEqual(writeResult.buffer, readResult.buffer);
  } finally {
    await fh?.close();
  }
}

(async () => {
  // Test if first argument is not wrongly interpreted as ArrayBufferView|string
  for (const badBuffer of [
    undefined, null, true, 42, 42n, Symbol('42'), NaN, [], () => {},
    common.mustNotCall(),
    common.mustNotMutateObjectDeep({}),
    Promise.resolve(new Uint8Array(1)),
    {},
    { buffer: 'amNotParam' },
    { string: 'amNotParam' },
    { buffer: new Uint8Array(1).buffer },
    new Date(),
    new String('notPrimitive'),
    { toString() { return 'amObject'; } },
    { [Symbol.toPrimitive]: (hint) => 'amObject' },
  ]) {
    await testInvalid(dest, 'ERR_INVALID_ARG_TYPE', common.mustNotMutateObjectDeep(badBuffer), {});
  }

  // First argument (buffer or string) is mandatory
  await testInvalid(dest, 'ERR_INVALID_ARG_TYPE');

  // Various invalid options
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 5 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: 5 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 1, offset: 3 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: -1 });
  await testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: -1 });
  await testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: false });
  await testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: true });

  // Test compatibility with filehandle.read counterpart
  for (const options of [
    undefined,
    null,
    {},
    { length: 1 },
    { position: 5 },
    { length: 1, position: 5 },
    { length: 1, position: -1, offset: 2 },
    { length: null },
    { position: null },
    { offset: 1 },
  ]) {
    await testValid(dest, buffer, common.mustNotMutateObjectDeep(options));
  }
})().then(common.mustCall());
"
test/fs/test-fs-promises-file-handle-readFile.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.readFile method.

import fs from 'fs';
const {
  open,
  readFile,
  writeFile,
  truncate,
} = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
// import tick from '../common/tick';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateReadFile() {
  const filePath = path.resolve(tmpDir, 'tmp-read-file.txt');
  const fileHandle = await open(filePath, 'w+');
  const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

  const fd = fs.openSync(filePath, 'w+');
  fs.writeSync(fd, buffer, 0, buffer.length);
  fs.closeSync(fd);

  const readFileData = await fileHandle.readFile();
  assert.deepStrictEqual(buffer, readFileData);

  await fileHandle.close();
}

async function validateReadFileProc() {
  // Test to make sure reading a file under the /proc directory works. Adapted
  // from test-fs-read-file-sync-hostname.js.
  // Refs:
  // - https://groups.google.com/forum/#!topic/nodejs-dev/rxZ_RoH1Gn0
  // - https://github.com/nodejs/node/issues/21331

  // Test is Linux-specific.
  if (!common.isLinux)
    return;

  const fileHandle = await open('/proc/sys/kernel/hostname', 'r');
  const hostname = await fileHandle.readFile();
  assert.ok(hostname.length > 0);
}

async function doReadAndCancel() {
  // unsupport AbortController
  /*
  // Signal aborted from the start
  {
    const filePathForHandle = path.resolve(tmpDir, 'dogs-running.txt');
    const fileHandle = await open(filePathForHandle, 'w+');
    try {
      const buffer = Buffer.from('Dogs running'.repeat(10000), 'utf8');
      fs.writeFileSync(filePathForHandle, buffer);
      const signal = AbortSignal.abort();
      await assert.rejects(readFile(fileHandle, common.mustNotMutateObjectDeep({ signal })), {
        name: 'AbortError'
      });
    } finally {
      await fileHandle.close();
    }
  }

  // Signal aborted on first tick
  {
    const filePathForHandle = path.resolve(tmpDir, 'dogs-running1.txt');
    const fileHandle = await open(filePathForHandle, 'w+');
    const buffer = Buffer.from('Dogs running'.repeat(10000), 'utf8');
    fs.writeFileSync(filePathForHandle, buffer);
    const controller = new AbortController();
    const { signal } = controller;
    process.nextTick(() => controller.abort());
    await assert.rejects(readFile(fileHandle, common.mustNotMutateObjectDeep({ signal })), {
      name: 'AbortError'
    }, 'tick-0');
    await fileHandle.close();
  }

  // Signal aborted right before buffer read
  {
    const newFile = path.resolve(tmpDir, 'dogs-running2.txt');
    const buffer = Buffer.from('Dogs running'.repeat(1000), 'utf8');
    fs.writeFileSync(newFile, buffer);

    const fileHandle = await open(newFile, 'r');

    const controller = new AbortController();
    const { signal } = controller;
    tick(1, () => controller.abort());
    await assert.rejects(fileHandle.readFile(common.mustNotMutateObjectDeep({ signal, encoding: 'utf8' })), {
      name: 'AbortError'
    }, 'tick-1');

    await fileHandle.close();
  }*/

  // Validate file size is within range for reading
  {
    // Variable taken from https://github.com/nodejs/node/blob/1377163f3351/lib/internal/fs/promises.js#L5
    const kIoMaxLength = 2 ** 31 - 1;

    const newFile = path.resolve(tmpDir, 'dogs-running3.txt');
    await writeFile(newFile, Buffer.from('0'));
    await truncate(newFile, kIoMaxLength + 1);

    const fileHandle = await open(newFile, 'r');

    await assert.rejects(fileHandle.readFile(), {
      name: 'RangeError',
      code: 'ERR_FS_FILE_TOO_LARGE'
    });
    await fileHandle.close();
  }
}

validateReadFile()
  .then(validateReadFileProc)
  .then(doReadAndCancel)
  .then(common.mustCall());
"
test/fs/test-fs-symlink.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
if (!common.canCreateSymLink())
  common.skip('insufficient privileges');

import assert from 'assert';
import path from 'path';
import fs from 'fs';

let linkTime;
let fileTime;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test creating and reading symbolic link
const linkData = fixtures.path('/cycles/root.js');
const linkPath = path.join(tmpdir.path, 'symlink1.js');

fs.symlink(linkData, linkPath, common.mustSucceed(() => {
  fs.lstat(linkPath, common.mustSucceed((stats) => {
    linkTime = stats.mtime.getTime();
  }));

  fs.stat(linkPath, common.mustSucceed((stats) => {
    fileTime = stats.mtime.getTime();
  }));

  /*fs.readlink(linkPath, common.mustSucceed((destination) => {
    assert.strictEqual(destination, linkData);
  }));*/
}));

// Test invalid symlink
{
  const linkData = fixtures.path('/not/exists/file');
  const linkPath = path.join(tmpdir.path, 'symlink2.js');

  fs.symlink(linkData, linkPath, common.mustSucceed(() => {
    assert(!fs.existsSync(linkPath));
  }));
}

[false, 1, {}, [], null, undefined].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: /target|path/
  };
  assert.throws(() => fs.symlink(input, '', common.mustNotCall()), errObj);
  assert.throws(() => fs.symlinkSync(input, ''), errObj);

  assert.throws(() => fs.symlink('', input, common.mustNotCall()), errObj);
  assert.throws(() => fs.symlinkSync('', input), errObj);
});

const errObj = {
  code: 'ERR_FS_INVALID_SYMLINK_TYPE',
  name: 'Error',
  message:
    'Symlink type must be one of ""dir"", ""file"", or ""junction"". Received """"'
};
assert.throws(() => fs.symlink('', '', '', common.mustNotCall()), errObj);
assert.throws(() => fs.symlinkSync('', '', ''), errObj);

globalThis.commonExitCheck = () => {
  assert.notStrictEqual(linkTime, fileTime);
};
"
modules/os.js,"import process from 'process';
import { Buffer } from 'buffer';
import { text_encode } from '_encoding';
import { _memorySize } from '_node:os';

export * from 'qjs:os';

function unimplemented(name) {
  throw new Error('Node.js os ' + name + ' is not supported');
}

var EOL = '\n';

function arch() {
  return process.arch;
}

var constants = [];

function cpus() {
  unimplemented('cpus');
}

var devNull = '/dev/null';

function endianness() {
  return 'LE';
}

function freemem() {
  // memory.size instruction will return the current 
  // memory size in units of pages. 
  // A page size is 65536 bytes.
  return totalmem() - _memorySize() * 65536;
}

function getPriority(pid) {
  if (pid === undefined) {
    pid = 0;
  }
  return 0;
}

function homedir() {
  return process.env['HOME'] || '.';
}

function hostname() {
  return process.title;
}

function loadavg() {
  return [0, 0, 0];
}

function networkInterfaces() {
  return [];
}

function platform() {
  return process.platform;
}

function release() {
  return process.version;
}

function setPriority(pid, priority) {
  if (priority === undefined) {
    priority = pid;
    pid = 0;
  }
}

function tmpdir() {
  let path = process.env['TMPDIR'] || process.env['TMP'] || process.env['TEMP'] || '/tmp';
  if (path.length > 1 && path.endsWith('/')) {
    path = path.slice(0, -1);
  }
  return path;
}

function totalmem() {
  return 2 ** 32;
}

function type() {
  return 'wasmedge';
}

function uptime() {
  return process.uptime();
}

function userInfo(options) {
  const encoding = (options && options.encoding) || 'utf8';
  let username = 'wasmedge';
  let _homedir = homedir();
  if (encoding === 'Buffer' || encoding === 'buffer') {
    username = Buffer.from(username, 'utf8');
    _homedir = Buffer.from(_homedir, 'utf8');
  } else if (encoding !== 'utf-8' && encoding !== 'utf8') {
    let exist = [
      'utf8', 'utf-8', 'gbk', 'gb18030', 'hz-gb-2312', 'big5', 'euc-jp', 'iso-2022-jp',
      'utf-16be', 'utf-16le', 'x-user-defined', 'ibm866',
      'iso-8859-2', 'iso-8859-3', 'iso-8859-4', 'iso-8859-5', 'iso-8859-6', 'iso-8859-7', 'iso-8859-8',
      'iso-8859-8i', 'iso-8859-10', 'iso-8859-13', 'iso-8859-14', 'iso-8859-15', 'iso-8859-16',
      'windows-874', 'windows-1250', 'windows-1251', 'windows-1252', 'windows-1253', 'windows-1254',
      'windows-1255', 'windows-1256', 'windows-1257', 'windows-1258', ''
    ].indexOf(encoding);
    if (exist >= 0) {
      const decoder = new TextDecoder();
      username = text_encode(encoding, decoder.decode(username));
      _homedir = text_encode(encoding, decoder.decode(_homedir));
    }
  }
  return {
    uid: -1,
    pid: -1,
    username,
    homedir: _homedir,
    shell: null
  }
}

function version() {
  return process.version;
}

export {
  EOL,
  arch,
  constants,
  cpus,
  devNull,
  endianness,
  freemem,
  getPriority,
  homedir,
  hostname,
  loadavg,
  networkInterfaces,
  platform,
  release,
  setPriority,
  tmpdir,
  totalmem,
  type,
  uptime,
  userInfo,
  version
}"
test/fs/test-fs-readfile.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// This test ensures that fs.readFile correctly returns the
// contents of varying-sized files.

import tmpdir from '../../test/common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import process from 'process';

const prefix = `.removeme-fs-readfile-${process.pid}`;

tmpdir.refresh();

const fileInfo = [
  { name: path.join(tmpdir.path, `${prefix}-1K.txt`),
    len: 1024 },
  { name: path.join(tmpdir.path, `${prefix}-64K.txt`),
    len: 64 * 1024 },
  { name: path.join(tmpdir.path, `${prefix}-64KLessOne.txt`),
    len: (64 * 1024) - 1 },
  /*{ name: path.join(tmpdir.path, `${prefix}-1M.txt`),
    len: 1 * 1024 * 1024 },
  { name: path.join(tmpdir.path, `${prefix}-1MPlusOne.txt`),
    len: (1 * 1024 * 1024) + 1 },*/
];

// Populate each fileInfo (and file) with unique fill.
const sectorSize = 512;
for (const e of fileInfo) {
  e.contents = Buffer.allocUnsafe(e.len);

  // This accounts for anything unusual in Node's implementation of readFile.
  // Using e.g. 'aa...aa' would miss bugs like Node re-reading
  // the same section twice instead of two separate sections.
  for (let offset = 0; offset < e.len; offset += sectorSize) {
    const fillByte = 256 * Math.random();
    const nBytesToFill = Math.min(sectorSize, e.len - offset);
    e.contents.fill(fillByte, offset, offset + nBytesToFill);
  }

  fs.writeFileSync(e.name, e.contents);
}
// All files are now populated.

// Test readFile on each size.
for (const e of fileInfo) {
  fs.readFile(e.name, common.mustCall((err, buf) => {
    console.log(`Validating readFile on file ${e.name} of length ${e.len}`);
    assert.ifError(err);
    assert.deepStrictEqual(buf, e.contents);
  }));
}
// Test readFile size too large
{
  const kIoMaxLength = 2 ** 31 - 1;

  const file = path.join(tmpdir.path, `${prefix}-too-large.txt`);
  fs.writeFileSync(file, Buffer.from('0'));
  fs.truncateSync(file, kIoMaxLength + 1);

  fs.readFile(file, common.expectsError({
    code: 'ERR_FS_FILE_TOO_LARGE',
    name: 'RangeError',
  }));
  assert.throws(() => {
    fs.readFileSync(file);
  }, { code: 'ERR_FS_FILE_TOO_LARGE', name: 'RangeError' });
}
/*
{
  // Test cancellation, before
  const signal = AbortSignal.abort();
  fs.readFile(fileInfo[0].name, { signal }, common.mustCall((err, buf) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
}
{
  // Test cancellation, during read
  const controller = new AbortController();
  const signal = controller.signal;
  fs.readFile(fileInfo[0].name, { signal }, common.mustCall((err, buf) => {
    assert.strictEqual(err.name, 'AbortError');
  }));
  process.nextTick(() => controller.abort());
}
{
  // Verify that if something different than Abortcontroller.signal
  // is passed, ERR_INVALID_ARG_TYPE is thrown
  assert.throws(() => {
    const callback = common.mustNotCall(() => {});
    fs.readFile(fileInfo[0].name, { signal: 'hello' }, callback);
  }, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });
}
*/"
src/quickjs_sys/js_module.rs,"use super::qjs as q;
use crate::quickjs_sys::qjs::{JSContext, JSModuleDef};
use crate::{Context, JsValue};
use std::marker::PhantomData;
use std::ops::DerefMut;

pub struct JsModuleDef {
    ctx: *mut q::JSContext,
    m: *mut q::JSModuleDef,
}

impl JsModuleDef {
    pub fn add_export<S: ToString>(&mut self, name: S, val: JsValue) {
        unsafe {
            let mut name = name.to_string();
            if !name.ends_with('\0') {
                name.push('\0')
            }
            let v = val.into_qjs_value();
            q::JS_SetModuleExport(self.ctx, self.m, name.as_ptr().cast(), v);
        }
    }
}

pub trait ModuleInit {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef);
}

struct ModuleInitFnTrampoline<F: ModuleInit> {
    _f: PhantomData<F>,
}

impl<F: ModuleInit> ModuleInitFnTrampoline<F> {
    unsafe extern ""C"" fn init_module(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
    ) -> ::std::os::raw::c_int {
        let mut m = JsModuleDef { ctx, m };
        let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });
        let nctx = n_ctx.deref_mut();
        F::init_module(nctx, &mut m);
        0
    }
}

struct FnModuleInitFnTrampoline<F: Fn(&mut Context, &mut JsModuleDef)> {
    _f: PhantomData<F>,
}

impl<F: Fn(&mut Context, &mut JsModuleDef)> FnModuleInitFnTrampoline<F> {
    unsafe extern ""C"" fn init_module(
        ctx: *mut JSContext,
        m: *mut JSModuleDef,
    ) -> ::std::os::raw::c_int {
        let mut m = JsModuleDef { ctx, m };
        let mut n_ctx = std::mem::ManuallyDrop::new(Context { ctx });
        let nctx = n_ctx.deref_mut();
        let init_module = std::mem::zeroed::<F>();
        init_module(nctx, &mut m);
        0
    }
}

fn register_fn_module<F: Fn(&mut Context, &mut JsModuleDef), S: ToString>(
    ctx: &mut Context,
    name: S,
    exports: &[&str],
    _f: F,
) {
    unsafe {
        let mut name = name.to_string();
        if !name.ends_with('\0') {
            name.push('\0');
        }

        let ctx = ctx.ctx;
        let js_module_init = FnModuleInitFnTrampoline::<F>::init_module;
        let m = q::JS_NewCModule(ctx, name.as_ptr().cast(), Some(js_module_init));

        let mut export_string = String::new();

        for s in exports {
            export_string.clear();
            export_string.push_str(*s);
            if !export_string.ends_with('\0') {
                export_string.push('\0');
            }
            q::JS_AddModuleExport(ctx, m, export_string.as_ptr().cast());
        }
    }
}

fn register_module<F: ModuleInit, S: ToString>(ctx: &mut Context, name: S, exports: &[&str]) {
    unsafe {
        let mut name = name.to_string();
        if !name.ends_with('\0') {
            name.push('\0');
        }

        let ctx = ctx.ctx;
        let js_module_init = ModuleInitFnTrampoline::<F>::init_module;
        let m = q::JS_NewCModule(ctx, name.as_ptr().cast(), Some(js_module_init));

        let mut export_string = String::new();

        for s in exports {
            export_string.clear();
            export_string.push_str(*s);
            if !export_string.ends_with('\0') {
                export_string.push('\0');
            }
            q::JS_AddModuleExport(ctx, m, export_string.as_ptr().cast());
        }
    }
}

impl Context {
    pub fn register_module<T: ModuleInit, S: ToString>(&mut self, name: S, _: T, exports: &[&str]) {
        register_module::<T, S>(self, name, exports)
    }

    pub fn register_fn_module<F: Fn(&mut Context, &mut JsModuleDef), S: ToString>(
        &mut self,
        name: S,
        exports: &[&str],
        f: F,
    ) {
        assert_size_zero!(@module, F);
        register_fn_module::<F, S>(self, name, exports, f)
    }
}
"
modules/internal/crypto/pbkdf2.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';


import { Buffer } from 'buffer';

import { validateFunction, validateInteger, validateString, validateUint32 } from '../validators';

import { ERR_CRYPTO_INVALID_DIGEST, ERR_MISSING_OPTION } from '../errors';

import { getArrayBufferOrView, getDefaultEncoding, normalizeHashName, kKeyObject } from './util';

import { lazyDOMException } from '../util';

import { pbkdf2_sync } from ""_node:crypto"";

export function pbkdf2(password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest;
    digest = undefined;
  }

  ({ password, salt, iterations, keylen, digest } =
    check(password, salt, iterations, keylen, digest));

  validateFunction(callback, 'callback');

  if (![""SHA256"", ""SHA512""].includes(digest.toUpperCase())) {
    throw new ERR_CRYPTO_INVALID_DIGEST(digest);
  }

  const encoding = getDefaultEncoding();

  setTimeout(() => {
    let result = pbkdf2_sync(password.buffer ?? password, salt.buffer ?? salt, iterations, keylen, digest.toUpperCase());
    const buf = Buffer.from(result);
    if (encoding === 'buffer') {
      callback(null, buf);
    } else {
      callback(null, buf.toString(encoding));
    }
  }, 0);
}

export function pbkdf2Sync(password, salt, iterations, keylen, digest) {
  ({ password, salt, iterations, keylen, digest } =
    check(password, salt, iterations, keylen, digest));

  if (![""SHA256"", ""SHA512""].includes(digest.toUpperCase())) {
    throw new ERR_CRYPTO_INVALID_DIGEST(digest);
  }

  let result = pbkdf2_sync(password.buffer ?? password, salt.buffer ?? salt, iterations, keylen, digest.toUpperCase());

  const buf = Buffer.from(result);
  const encoding = getDefaultEncoding();
  return encoding === 'buffer' ? buf : buf.toString(encoding);
}

function check(password, salt, iterations, keylen, digest) {
  validateString(digest, 'digest');

  password = getArrayBufferOrView(password, 'password');
  salt = getArrayBufferOrView(salt, 'salt');
  validateUint32(iterations, 'iterations', true);
  validateUint32(keylen, 'keylen');

  return { password, salt, iterations, keylen, digest };
}

export async function pbkdf2DeriveBits(algorithm, baseKey, length) {
  const { iterations } = algorithm;
  let { hash } = algorithm;
  const salt = getArrayBufferOrView(algorithm.salt, 'algorithm.salt');
  if (hash === undefined)
    throw new ERR_MISSING_OPTION('algorithm.hash');
  validateInteger(iterations, 'algorithm.iterations');
  if (iterations === 0)
    throw lazyDOMException(
      'iterations cannot be zero',
      'OperationError');

  hash = normalizeHashName(hash.name);

  const raw = baseKey[kKeyObject].export();

  let byteLength = 64;  // the default
  if (length !== undefined) {
    if (length === 0)
      throw lazyDOMException('length cannot be zero', 'OperationError');
    if (length === null)
      throw lazyDOMException('length cannot be null', 'OperationError');
    validateUint32(length, 'length');
    if (length % 8) {
      throw lazyDOMException(
        'length must be a multiple of 8',
        'OperationError');
    }
    byteLength = length / 8;
  }

  return new Promise((resolve, reject) => {
    pbkdf2(raw, salt, iterations, byteLength, hash, (err, result) => {
      if (err) return reject(err);
      resolve(result.buffer);
    });
  });
}

export default {
  pbkdf2,
  pbkdf2Sync,
  pbkdf2DeriveBits,
};
"
test/fs/test-fs-sir-writes-alot.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import fs from 'fs';
import assert from 'assert';
import { join } from 'path';

import tmpdir from '../common/tmpdir';

const filename = join(tmpdir.path, 'out.txt');

tmpdir.refresh();

const fd = fs.openSync(filename, 'w');

const line = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa\n';

const N = 10240;
let complete = 0;

for (let i = 0; i < N; i++) {
  // Create a new buffer for each write. Before the write is actually
  // executed by the thread pool, the buffer will be collected.
  const buffer = Buffer.from(line);
  fs.write(fd, buffer, 0, buffer.length, null, function(er, written) {
    complete++;
    if (complete === N) {
      fs.closeSync(fd);
      const s = fs.createReadStream(filename);
      s.on('data', testBuffer);
    }
  });
}

let bytesChecked = 0;

function testBuffer(b) {
  for (let i = 0; i < b.length; i++) {
    bytesChecked++;
    if (b[i] !== 'a'.charCodeAt(0) && b[i] !== '\n'.charCodeAt(0)) {
      throw new Error(`invalid char ${i},${b[i]}`);
    }
  }
}

process.on('exit', function() {
  // Probably some of the writes are going to overlap, so we can't assume
  // that we get (N * line.length). Let's just make sure we've checked a
  // few...
  assert.ok(bytesChecked > 1000);
});
"
test/crypto/test-crypto-stream.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const stream = require('stream');
const crypto = require('crypto');

if (!common.hasFipsCrypto) {
  // Small stream to buffer converter
  class Stream2buffer extends stream.Writable {
    constructor(callback) {
      super();

      this._buffers = [];
      this.once('finish', function() {
        callback(null, Buffer.concat(this._buffers));
      });
    }

    _write(data, encoding, done) {
      this._buffers.push(data);
      return done(null);
    }
  }

  // Create an md5 hash of ""Hallo world""
  const hasher1 = crypto.createHash('md5');
  hasher1.pipe(new Stream2buffer(common.mustCall(function end(err, hash) {
    assert.strictEqual(err, null);
    assert.strictEqual(
      hash.toString('hex'), '06460dadb35d3d503047ce750ceb2d07'
    );
  })));
  hasher1.end('Hallo world');

  // Simpler check for unpipe, setEncoding, pause and resume
  crypto.createHash('md5').unpipe({});
  crypto.createHash('md5').setEncoding('utf8');
  crypto.createHash('md5').pause();
  crypto.createHash('md5').resume();
}

// Decipher._flush() should emit an error event, not an exception.
const key = Buffer.from('48fb56eb10ffeb13fc0ef551bbca3b1b', 'hex');
const badkey = Buffer.from('12341234123412341234123412341234', 'hex');
const iv = Buffer.from('6d358219d1f488f5f4eb12820a66d146', 'hex');
const cipher = crypto.createCipheriv('aes-128-cbc', key, iv);
const decipher = crypto.createDecipheriv('aes-128-cbc', badkey, iv);

cipher.pipe(decipher)
  .on('error', common.expectsError(common.hasOpenSSL3 ? {
    message: /bad decrypt/,
    library: 'Provider routines',
    reason: 'bad decrypt',
  } : {
    message: /bad decrypt/,
    function: 'EVP_DecryptFinal_ex',
    library: 'digital envelope routines',
    reason: 'bad decrypt',
  }));

cipher.end('Papaya!');  // Should not cause an unhandled exception.
"
test/fs/test-fs-readdir-types.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

// import { internalBinding } from 'internal/test/binding';
// const binding = internalBinding('fs');

const __filename = args[0];

const readdirDir = tmpdir.path;
const files = ['empty', 'files', 'for', 'just', 'testing'];
import { constants } from 'fs';
const types = {
  isDirectory: constants.UV_DIRENT_DIR,
  isFile: constants.UV_DIRENT_FILE,
  isBlockDevice: constants.UV_DIRENT_BLOCK,
  isCharacterDevice: constants.UV_DIRENT_CHAR,
  isSymbolicLink: constants.UV_DIRENT_LINK,
  isFIFO: constants.UV_DIRENT_FIFO,
  isSocket: constants.UV_DIRENT_SOCKET
};
const typeMethods = Object.keys(types);

// Make sure tmp directory is clean
tmpdir.refresh();

// Create the necessary files
files.forEach(function(currentFile) {
  fs.closeSync(fs.openSync(`${readdirDir}/${currentFile}`, 'w'));
});


function assertDirents(dirents) {
  assert.strictEqual(files.length, dirents.length);
  // dirent is not order by name in this platform
  dirents.sort((a, b) => a.name > b.name);
  for (const [i, dirent] of dirents.entries()) {
    assert(dirent instanceof fs.Dirent);
    assert.strictEqual(dirent.name, files[i]);
    assert.strictEqual(dirent.isFile(), true);
    assert.strictEqual(dirent.isDirectory(), false);
    assert.strictEqual(dirent.isSocket(), false);
    assert.strictEqual(dirent.isBlockDevice(), false);
    assert.strictEqual(dirent.isCharacterDevice(), false);
    assert.strictEqual(dirent.isFIFO(), false);
    assert.strictEqual(dirent.isSymbolicLink(), false);
  }
}

// Check the readdir Sync version
assertDirents(fs.readdirSync(readdirDir, { withFileTypes: true }));

fs.readdir(__filename, {
  withFileTypes: true
}, common.mustCall((err) => {
  assert.throws(
    () => { throw err; },
    {
      code: 'ENOTDIR',
      name: 'Error',
      message: `ENOTDIR: not a directory, scandir '${__filename}'`
    }
  );
}));

// Check the readdir async version
fs.readdir(readdirDir, {
  withFileTypes: true
}, common.mustSucceed((dirents) => {
  assertDirents(dirents);
}));

(async () => {
  const dirents = await fs.promises.readdir(readdirDir, {
    withFileTypes: true
  });
  assertDirents(dirents);
})().then(common.mustCall());

/* nodejs implement specific
// Check for correct types when the binding returns unknowns
const UNKNOWN = constants.UV_DIRENT_UNKNOWN;
const oldReaddir = binding.readdir;
process.on('beforeExit', () => { binding.readdir = oldReaddir; });
binding.readdir = common.mustCall((path, encoding, types, req, ctx) => {
  if (req) {
    const oldCb = req.oncomplete;
    req.oncomplete = (err, results) => {
      if (err) {
        oldCb(err);
        return;
      }
      results[1] = results[1].map(() => UNKNOWN);
      oldCb(null, results);
    };
    oldReaddir(path, encoding, types, req);
  } else {
    const results = oldReaddir(path, encoding, types, req, ctx);
    results[1] = results[1].map(() => UNKNOWN);
    return results;
  }
}, 2);
assertDirents(fs.readdirSync(readdirDir, { withFileTypes: true }));
fs.readdir(readdirDir, {
  withFileTypes: true
}, common.mustSucceed((dirents) => {
  assertDirents(dirents);
}));

// Dirent types
for (const method of typeMethods) {
  const dirent = new fs.Dirent('foo', types[method]);
  for (const testMethod of typeMethods) {
    assert.strictEqual(dirent[testMethod](), testMethod === method);
  }
}
*/
"
modules/internal/assert/calltracker.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const {
  ArrayPrototypePush,
  ArrayPrototypeSlice,
  FunctionPrototype,
  ObjectFreeze,
  ReflectApply,
  SafeSet,
  SafeWeakMap,
} = {
  ArrayPrototypePush: Array.prototype.push,
  ArrayPrototypeSlice: Array.prototype.slice,
  FunctionPrototype: Function.prototype,
  ObjectFreeze: Object.freeze,
  ReflectApply: Reflect.apply,
  SafeSet: Set,
  SafeWeakMap: WeakMap,
};

import { ERR_UNAVAILABLE_DURING_EXIT, ERR_INVALID_ARG_VALUE } from 'internal/errors';

import AssertionError from 'internal/assert/assertion_error';
import { validateUint32 } from 'internal/validators';

const noop = FunctionPrototype;

class CallTrackerContext {
  #expected;
  #calls;
  #name;
  #stackTrace;
  constructor({ expected, stackTrace, name }) {
    this.#calls = [];
    this.#expected = expected;
    this.#stackTrace = stackTrace;
    this.#name = name;
  }

  track(thisArg, args) {
    const argsClone = ObjectFreeze(ArrayPrototypeSlice(args));
    ArrayPrototypePush(this.#calls, ObjectFreeze({ thisArg, arguments: argsClone }));
  }

  get delta() {
    return this.#calls.length - this.#expected;
  }

  reset() {
    this.#calls = [];
  }
  getCalls() {
    return ObjectFreeze(ArrayPrototypeSlice(this.#calls));
  }

  report() {
    if (this.delta !== 0) {
      const message = `Expected the ${this.#name} function to be ` +
        `executed ${this.#expected} time(s) but was ` +
        `executed ${this.#calls.length} time(s).`;
      return {
        message,
        actual: this.#calls.length,
        expected: this.#expected,
        operator: this.#name,
        stack: this.#stackTrace
      };
    }
  }
}

class CallTracker {

  #callChecks = new SafeSet();
  #trackedFunctions = new SafeWeakMap();

  #getTrackedFunction(tracked) {
    if (!this.#trackedFunctions.has(tracked)) {
      throw new ERR_INVALID_ARG_VALUE('tracked', tracked, 'is not a tracked function');
    }
    return this.#trackedFunctions.get(tracked);
  }

  reset(tracked) {
    if (tracked === undefined) {
      this.#callChecks.forEach((check) => check.reset());
      return;
    }

    this.#getTrackedFunction(tracked).reset();
  }

  getCalls(tracked) {
    return this.#getTrackedFunction(tracked).getCalls();
  }

  calls(fn, expected = 1) {
    if (process._exiting)
      throw new ERR_UNAVAILABLE_DURING_EXIT();
    if (typeof fn === 'number') {
      expected = fn;
      fn = noop;
    } else if (fn === undefined) {
      fn = noop;
    }

    validateUint32(expected, 'expected', true);

    const context = new CallTrackerContext({
      expected,
      // eslint-disable-next-line no-restricted-syntax
      stackTrace: new Error(),
      name: fn.name || 'calls'
    });
    const tracked = new Proxy(fn, {
      __proto__: null,
      apply(fn, thisArg, argList) {
        context.track(thisArg, argList);
        return ReflectApply(fn, thisArg, argList);
      },
    });
    this.#callChecks.add(context);
    this.#trackedFunctions.set(tracked, context);
    return tracked;
  }

  report() {
    const errors = [];
    for (const context of this.#callChecks) {
      const message = context.report();
      if (message !== undefined) {
        ArrayPrototypePush(errors, message);
      }
    }
    return errors;
  }

  verify() {
    const errors = this.report();
    if (errors.length === 0) {
      return;
    }
    const message = errors.length === 1 ?
      errors[0].message :
      'Functions were not called the expected number of times';
    throw new AssertionError({
      message,
      details: errors,
    });
  }
}

export default CallTracker;
"
modules/internal/util/debuglog.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import { sprintf } from ""fmt/printf"";

// `debugImpls` and `testEnabled` are deliberately not initialized so any call
// to `debuglog()` before `initializeDebugEnv()` is called will throw.
let debugImpls;
let testEnabled;

// `debugEnv` is initial value of process.env.NODE_DEBUG
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        // This is run before any user code, it's OK not to use primordials.
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, ""\\$&"")
            .replaceAll(""*"", "".*"")
            .replaceAll("","", ""$|^"");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, ""i"");
        testEnabled = (str) => debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled = () => false;
    }
}

// Emits warning when user sets
// NODE_DEBUG=http or NODE_DEBUG=http2.
function emitWarningIfNeeded(set) {
    if (""HTTP"" === set || ""HTTP2"" === set) {
        console.warn(
            ""Setting the NODE_DEBUG environment variable "" +
            ""to '"" + set.toLowerCase() + ""' can expose sensitive "" +
            ""data (such as passwords, tokens and authentication headers) "" +
            ""in the resulting log."",
        );
    }
}

const noop = () => { };

function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg) => JSON.stringify(arg)).join("" "");
                console.error(sprintf(""%s %s: %s"", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }

    return debugImpls[set];
}

// debuglogImpl depends on process.pid and process.env.NODE_DEBUG,
// so it needs to be called lazily in top scopes of internal modules
// that may be loaded before these run time states are allowed to
// be accessed.
export function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }

    let debug = (...args) => {
        init();
        // Only invokes debuglogImpl() when the debug function is
        // called for the first time.
        debug = debuglogImpl(enabled, set);

        if (typeof cb === ""function"") {
            cb(debug);
        }

        return debug(...args);
    };

    let enabled;
    let test = () => {
        init();
        test = () => enabled;
        return enabled;
    };

    const logger = (...args) => debug(...args);

    Object.defineProperty(logger, ""enabled"", {
        get() {
            return test();
        },
        configurable: true,
        enumerable: true,
    });

    return logger;
}

let debugEnv = env[""NODE_DEBUG""] ?? """";

initializeDebugEnv(debugEnv);

export default { debuglog };"
test/fs/test-fs-write-sync-optional-params.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

// This test ensures that fs.writeSync accepts ""named parameters"" object
// and doesn't interpret objects as strings

import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const dest = path.resolve(tmpdir.path, 'tmp.txt');
const buffer = Buffer.from('zyx');

function testInvalid(dest, expectedCode, ...bufferAndOptions) {
  if (bufferAndOptions.length >= 2) {
    bufferAndOptions[1] = common.mustNotMutateObjectDeep(bufferAndOptions[1]);
  }
  let fd;
  try {
    fd = fs.openSync(dest, 'w+');
    assert.throws(
      () => fs.writeSync(fd, ...bufferAndOptions),
      { code: expectedCode });
  } finally {
    if (fd != null) fs.closeSync(fd);
  }
}

function testValid(dest, buffer, options) {
  const length = options?.length;
  let fd;
  try {
    fd = fs.openSync(dest, 'w+');
    const bytesWritten = fs.writeSync(fd, buffer, options);
    const bytesRead = fs.readSync(fd, buffer, options);

    assert.ok(bytesWritten >= bytesRead);
    if (length !== undefined && length !== null) {
      assert.strictEqual(bytesWritten, length);
    }
  } finally {
    if (fd != null) fs.closeSync(fd);
  }
}

{
  // Test if second argument is not wrongly interpreted as string or options
  for (const badBuffer of [
    undefined, null, true, 42, 42n, Symbol('42'), NaN, [], () => {},
    common.mustNotCall(),
    common.mustNotMutateObjectDeep({}),
    {},
    { buffer: 'amNotParam' },
    { string: 'amNotParam' },
    { buffer: new Uint8Array(1) },
    { buffer: new Uint8Array(1).buffer },
    Promise.resolve(new Uint8Array(1)),
    new Date(),
    new String('notPrimitive'),
    { toString() { return 'amObject'; } },
    { [Symbol.toPrimitive]: (hint) => 'amObject' },
  ]) {
    testInvalid(dest, 'ERR_INVALID_ARG_TYPE', common.mustNotMutateObjectDeep(badBuffer));
  }

  // First argument (buffer or string) is mandatory
  testInvalid(dest, 'ERR_INVALID_ARG_TYPE');

  // Various invalid options
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 5 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: 5 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: 1, offset: 3 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { length: -1 });
  testInvalid(dest, 'ERR_OUT_OF_RANGE', buffer, { offset: -1 });
  testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: false });
  testInvalid(dest, 'ERR_INVALID_ARG_TYPE', buffer, { offset: true });

  // Test compatibility with fs.readSync counterpart with reused options
  for (const options of [
    undefined,
    null,
    {},
    { length: 1 },
    { position: 5 },
    { length: 1, position: 5 },
    { length: 1, position: -1, offset: 2 },
    { length: null },
    { position: null },
    { offset: 1 },
  ]) {
    testValid(dest, buffer, common.mustNotMutateObjectDeep(options));
  }
}
"
test/fs/test-fs-readfile-error.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fs from 'fs';

// Test that fs.readFile fails correctly on a non-existent file.

// `fs.readFile('/')` does not fail on AIX and FreeBSD because you can open
// and read the directory there.
if (common.isAIX || common.isFreeBSD)
  common.skip('platform not supported.');

import assert from 'assert';
import { exec } from 'child_process';
import fixtures from '../common/fixtures';

function test(env, cb) {
  const filename = fixtures.path('test-fs-readfile-error.js');
  const execPath = `""${process.execPath}"" ""${filename}""`;
  const options = { env: { ...process.env, ...env } };
  exec(execPath, options, (err, stdout, stderr) => {
    assert(err);
    assert.strictEqual(stdout, '');
    assert.notStrictEqual(stderr, '');
    cb(String(stderr));
  });
}

test({ NODE_DEBUG: '' }, common.mustCall((data) => {
  assert.match(data, /EISDIR/);
  assert.match(data, /test-fs-readfile-error/);
}));

test({ NODE_DEBUG: 'fs' }, common.mustCall((data) => {
  assert.match(data, /EISDIR/);
  assert.match(data, /test-fs-readfile-error/);
}));

assert.throws(
  () => { fs.readFile(() => {}, common.mustNotCall()); },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    message: 'The ""path"" argument must be of type string or an instance of ' +
             'Buffer or URL. Received type function ([Function (anonymous)])',
    name: 'TypeError'
  }
);
"
test/crypto/test-crypto-padding-aes256.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const iv = Buffer.from('00000000000000000000000000000000', 'hex');
const key = Buffer.from('0123456789abcdef0123456789abcdef' +
                        '0123456789abcdef0123456789abcdef', 'hex');

function encrypt(val, pad) {
  const c = crypto.createCipheriv('aes256', key, iv);
  c.setAutoPadding(pad);
  return c.update(val, 'utf8', 'latin1') + c.final('latin1');
}

function decrypt(val, pad) {
  const c = crypto.createDecipheriv('aes256', key, iv);
  c.setAutoPadding(pad);
  return c.update(val, 'latin1', 'utf8') + c.final('utf8');
}

// echo 0123456789abcdef0123456789abcdef \
// | openssl enc -e -aes256 -nopad -K <key> -iv <iv> \
// | openssl enc -d -aes256 -nopad -K <key> -iv <iv>
let plaintext = '0123456789abcdef0123456789abcdef'; // Multiple of block size
let encrypted = encrypt(plaintext, false);
let decrypted = decrypt(encrypted, false);
assert.strictEqual(decrypted, plaintext);

// echo 0123456789abcdef0123456789abcde \
// | openssl enc -e -aes256 -K <key> -iv <iv> \
// | openssl enc -d -aes256 -K <key> -iv <iv>
plaintext = '0123456789abcdef0123456789abcde'; // not a multiple
encrypted = encrypt(plaintext, true);
decrypted = decrypt(encrypted, true);
assert.strictEqual(decrypted, plaintext);
"
test/fs/test-fs-read-stream-throw-type-error.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';

// This test ensures that appropriate TypeError is thrown by createReadStream
// when an argument with invalid type is passed

const example = fixtures.path('x.txt');
// Should not throw.
fs.createReadStream(example, undefined);
fs.createReadStream(example, null);
fs.createReadStream(example, 'utf8');
fs.createReadStream(example, { encoding: 'utf8' });

const createReadStreamErr = (path, opt, error) => {
  assert.throws(() => {
    fs.createReadStream(path, opt);
  }, error);
};

const typeError = {
  code: 'ERR_INVALID_ARG_TYPE',
  name: 'TypeError'
};

const rangeError = {
  code: 'ERR_OUT_OF_RANGE',
  name: 'RangeError'
};

[123, 0, true, false].forEach((opts) =>
  createReadStreamErr(example, opts, typeError)
);

// Case 0: Should not throw if either start or end is undefined
[{}, { start: 0 }, { end: Infinity }].forEach((opts) =>
  fs.createReadStream(example, opts)
);

// Case 1: Should throw TypeError if either start or end is not of type 'number'
[
  { start: 'invalid' },
  { end: 'invalid' },
  { start: 'invalid', end: 'invalid' },
].forEach((opts) => createReadStreamErr(example, opts, typeError));

// Case 2: Should throw RangeError if either start or end is NaN
[{ start: NaN }, { end: NaN }, { start: NaN, end: NaN }].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);

// Case 3: Should throw RangeError if either start or end is negative
[{ start: -1 }, { end: -1 }, { start: -1, end: -1 }].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);

// Case 4: Should throw RangeError if either start or end is fractional
[{ start: 0.1 }, { end: 0.1 }, { start: 0.1, end: 0.1 }].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);

// Case 5: Should not throw if both start and end are whole numbers
fs.createReadStream(example, { start: 1, end: 5 });

// Case 6: Should throw RangeError if start is greater than end
createReadStreamErr(example, { start: 5, end: 1 }, rangeError);

// Case 7: Should throw RangeError if start or end is not safe integer
const NOT_SAFE_INTEGER = 2 ** 53;
[
  { start: NOT_SAFE_INTEGER, end: Infinity },
  { start: 0, end: NOT_SAFE_INTEGER },
].forEach((opts) =>
  createReadStreamErr(example, opts, rangeError)
);
"
modules/internal/streams/legacy.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import EE from ""events"";

function Stream(opts) {
    EE.call(this, opts);
}

Object.setPrototypeOf(Stream.prototype, EE.prototype);
Object.setPrototypeOf(Stream, EE);

Stream.prototype.pipe = function (dest, options) {
    // deno-lint-ignore no-this-alias
    const source = this;

    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }

    source.on(""data"", ondata);

    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }

    dest.on(""drain"", ondrain);

    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on(""end"", onend);
        source.on(""close"", onclose);
    }

    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;

        dest.end();
    }

    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;

        if (typeof dest.destroy === ""function"") dest.destroy();
    }

    // Don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, ""error"") === 0) {
            this.emit(""error"", er);
        }
    }

    prependListener(source, ""error"", onerror);
    prependListener(dest, ""error"", onerror);

    // Remove all the event listeners that were added.
    function cleanup() {
        source.removeListener(""data"", ondata);
        dest.removeListener(""drain"", ondrain);

        source.removeListener(""end"", onend);
        source.removeListener(""close"", onclose);

        source.removeListener(""error"", onerror);
        dest.removeListener(""error"", onerror);

        source.removeListener(""end"", cleanup);
        source.removeListener(""close"", cleanup);

        dest.removeListener(""close"", cleanup);
    }

    source.on(""end"", cleanup);
    source.on(""close"", cleanup);

    dest.on(""close"", cleanup);
    dest.emit(""pipe"", source);

    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === ""function"") {
        return emitter.prependListener(event, fn);
    }

    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [fn, emitter._events[event]];
    }
}

export { prependListener, Stream };"
test/crypto/test-crypto-ecdh-convert-key.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const { ECDH, createSign, getCurves } = require('crypto');

// A valid private key for the secp256k1 curve.
const cafebabeKey = 'cafebabe'.repeat(8);
// Associated compressed and uncompressed public keys (points).
const cafebabePubPtComp =
    '03672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3';
const cafebabePubPtUnComp =
    '04672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3' +
    '2e02c7f93d13dc2732b760ca377a5897b9dd41a1c1b29dc0442fdce6d0a04d1d';

// Invalid test: key argument is undefined.
assert.throws(
  () => ECDH.convertKey(),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });

// Invalid test: curve argument is undefined.
assert.throws(
  () => ECDH.convertKey(cafebabePubPtComp),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });

// Invalid test: curve argument is invalid.
assert.throws(
  () => ECDH.convertKey(cafebabePubPtComp, 'badcurve'),
  {
    name: 'TypeError',
    message: 'Invalid EC curve name'
  });

if (getCurves().includes('secp256k1')) {
  // Invalid test: format argument is undefined.
  assert.throws(
    () => ECDH.convertKey(cafebabePubPtComp, 'secp256k1', 'hex', 'hex', 10),
    {
      code: 'ERR_CRYPTO_ECDH_INVALID_FORMAT',
      name: 'TypeError',
      message: 'Invalid ECDH format: 10'
    });

  // Point formats.
  let uncompressed = ECDH.convertKey(cafebabePubPtComp,
                                     'secp256k1',
                                     'hex',
                                     'buffer',
                                     'uncompressed');
  let compressed = ECDH.convertKey(cafebabePubPtComp,
                                   'secp256k1',
                                   'hex',
                                   'buffer',
                                   'compressed');
  let hybrid = ECDH.convertKey(cafebabePubPtComp,
                               'secp256k1',
                               'hex',
                               'buffer',
                               'hybrid');
  assert.strictEqual(uncompressed[0], 4);
  let firstByte = compressed[0];
  assert(firstByte === 2 || firstByte === 3);
  firstByte = hybrid[0];
  assert(firstByte === 6 || firstByte === 7);

  // Format conversion from hex to hex
  uncompressed = ECDH.convertKey(cafebabePubPtComp,
                                 'secp256k1',
                                 'hex',
                                 'hex',
                                 'uncompressed');
  compressed = ECDH.convertKey(cafebabePubPtComp,
                               'secp256k1',
                               'hex',
                               'hex',
                               'compressed');
  hybrid = ECDH.convertKey(cafebabePubPtComp,
                           'secp256k1',
                           'hex',
                           'hex',
                           'hybrid');
  assert.strictEqual(uncompressed, cafebabePubPtUnComp);
  assert.strictEqual(compressed, cafebabePubPtComp);

  // Compare to getPublicKey.
  const ecdh1 = ECDH('secp256k1');
  ecdh1.generateKeys();
  ecdh1.setPrivateKey(cafebabeKey, 'hex');
  assert.strictEqual(ecdh1.getPublicKey('hex', 'uncompressed'), uncompressed);
  assert.strictEqual(ecdh1.getPublicKey('hex', 'compressed'), compressed);
  assert.strictEqual(ecdh1.getPublicKey('hex', 'hybrid'), hybrid);
}

// See https://github.com/nodejs/node/issues/26133, failed ConvertKey
// operations should not leave errors on OpenSSL's error stack because
// that's observable by subsequent operations.
{
  const privateKey =
    '-----BEGIN EC PRIVATE KEY-----\n' +
    'MHcCAQEEIF+jnWY1D5kbVYDNvxxo/Y+ku2uJPDwS0r/VuPZQrjjVoAoGCCqGSM49\n' +
    'AwEHoUQDQgAEurOxfSxmqIRYzJVagdZfMMSjRNNhB8i3mXyIMq704m2m52FdfKZ2\n' +
    'pQhByd5eyj3lgZ7m7jbchtdgyOF8Io/1ng==\n' +
    '-----END EC PRIVATE KEY-----';

  const sign = createSign('sha256').update('plaintext');

  // TODO(bnoordhuis) This should really bubble up the specific OpenSSL error
  // rather than Node's generic error message.
  const badKey = 'f'.repeat(128);
  assert.throws(
    () => ECDH.convertKey(badKey, 'secp521r1', 'hex', 'hex', 'compressed'),
    /Failed to convert Buffer to EC_POINT/);

  // Next statement should not throw an exception.
  sign.sign(privateKey);
}
"
test/fs/test-fs-watch-encoding.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This test is a bit more complicated than it ideally needs to be to work
// around issues on OS X and SmartOS.
//
// On OS X, watch events are subject to peculiar timing oddities such that an
// event might fire out of order. The synchronous refreshing of the tmp
// directory might trigger an event on the watchers that are instantiated after
// it!
//
// On SmartOS, the watch events fire but the filename is null.

import common from '../common';

// fs-watch on folders have limited capability in AIX.
// The testcase makes use of folder watching, and causes
// hang. This behavior is documented. Skip this for AIX.

if (common.isAIX)
  common.skip('folder watch capability is limited in AIX.');

import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = '.txt';
const a = path.join(tmpdir.path, fn);

const watchers = new Set();

function registerWatcher(watcher) {
  watchers.add(watcher);
}

function unregisterWatcher(watcher) {
  watcher.close();
  watchers.delete(watcher);
  if (watchers.size === 0) {
    clearInterval(interval);
  }
}

{
  // Test that using the `encoding` option has the expected result.
  const watcher = fs.watch(
    tmpdir.path,
    { encoding: 'hex' },
    (event, filename) => {
      if (['e696b0e5bbbae69687e5a4b9e4bbb62e747874', null].includes(filename))
        done(watcher);
    }
  );
  registerWatcher(watcher);
}

{
  // Test that in absence of `encoding` option has the expected result.
  const watcher = fs.watch(
    tmpdir.path,
    (event, filename) => {
      if ([fn, null].includes(filename))
        done(watcher);
    }
  );
  registerWatcher(watcher);
}

{
  // Test that using the `encoding` option has the expected result.
  const watcher = fs.watch(
    tmpdir.path,
    { encoding: 'buffer' },
    (event, filename) => {
      if (filename instanceof Buffer && filename.toString('utf8') === fn)
        done(watcher);
      else if (filename === null)
        done(watcher);
    }
  );
  registerWatcher(watcher);
}

const done = common.mustCall(unregisterWatcher, watchers.size);

// OS X and perhaps other systems can have surprising race conditions with
// file events. So repeat the operation in case it is missed the first time.
const interval = setInterval(() => {
  const fd = fs.openSync(a, 'w+');
  fs.closeSync(fd);
  fs.unlinkSync(a);
}, common.platformTimeout(100));
"
src/quickjs_sys/macros.rs,"#[macro_export]
macro_rules! CFUNC_DEF {
    ($name:expr,$func:ident,$len:expr) => {
        JSCFunctionListEntry {
            name: $name.as_ptr() as *const i8,
            prop_flags: (JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE) as u8,
            def_type: JS_DEF_CFUNC as u8,
            magic: 0,
            u: JSCFunctionListEntry__bindgen_ty_1 {
                func: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1 {
                    length: $len,
                    cproto: JSCFunctionEnum_JS_CFUNC_generic as u8,
                    cfunc: JSCFunctionType {
                        generic: Some($func),
                    },
                },
            },
        }
    };
}

#[macro_export]
macro_rules! CFUNC_MAGIC_DEF {
    ($name:expr,$func:ident,$len:expr,$magic:expr) => {
        JSCFunctionListEntry {
            name: $name.as_ptr() as *const i8,
            prop_flags: (JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE) as u8,
            def_type: JS_DEF_CFUNC as u8,
            magic: $magic,
            u: JSCFunctionListEntry__bindgen_ty_1 {
                func: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_1 {
                    length: $len,
                    cproto: JSCFunctionEnum_JS_CFUNC_generic_magic as u8,
                    cfunc: JSCFunctionType {
                        generic_magic: Some($func),
                    },
                },
            },
        }
    };
}

#[macro_export]
macro_rules! JS_CGETSET_DEF {
    ($name:expr,$get:ident,$set:ident) => {
        JSCFunctionListEntry {
            name: $name.as_ptr() as *const i8,
            prop_flags: JS_PROP_CONFIGURABLE as u8,
            def_type: JS_DEF_CGETSET as u8,
            magic: 0,
            u: JSCFunctionListEntry__bindgen_ty_1 {
                getset: JSCFunctionListEntry__bindgen_ty_1__bindgen_ty_2 {
                    get: JSCFunctionType { getter: Some($get) },
                    set: JSCFunctionType { setter: Some($set) },
                },
            },
        }
    };
}

#[macro_export]
macro_rules! assert_size_zero {
    ($t:tt) => {{
        struct AssertSize<F: Fn(&mut Context, JsValue, &[JsValue]) -> JsValue>(PhantomData<F>);
        impl<F: Fn(&mut Context, JsValue, &[JsValue]) -> JsValue> AssertSize<F> {
            const ASSERT: [(); 1] = [()];
            const F_SIZE_MUST_ZERO: () = Self::ASSERT[std::mem::size_of::<F>()];
        }

        let _ = AssertSize::<$t>::F_SIZE_MUST_ZERO;
    }};
    ($d:tt,$t:tt) => {{
        struct AssertSize<D: Sized, F: Fn(&mut D, &mut Context, &[JsValue]) -> JsValue>(
            PhantomData<D>,
            PhantomData<F>,
        );
        impl<D: Sized, F: Fn(&mut D, &mut Context, &[JsValue]) -> JsValue> AssertSize<D, F> {
            const ASSERT: [(); 1] = [()];
            const F_SIZE_MUST_ZERO: () = Self::ASSERT[std::mem::size_of::<F>()];
        }

        let _ = AssertSize::<$d, $t>::F_SIZE_MUST_ZERO;
    }};
    ($d:tt,$getter:tt,$setter:tt) => {{
        struct AssertSize<
            D: Sized,
            Getter: Fn(&D, &mut Context) -> JsValue,
            Setter: Fn(&mut D, &mut Context, JsValue),
        >(PhantomData<(D, Getter, Setter)>);
        impl<D: Sized, Getter, Setter> AssertSize<D, Getter, Setter>
        where
            Getter: Fn(&D, &mut Context) -> JsValue,
            Setter: Fn(&mut D, &mut Context, JsValue),
        {
            const ASSERT: [(); 1] = [()];
            const GETTER_SETTER_SIZE_MUST_ZERO: () =
                Self::ASSERT[std::mem::size_of::<Getter>() + std::mem::size_of::<Setter>()];
        }

        let _ = AssertSize::<$d, $getter, $setter>::GETTER_SETTER_SIZE_MUST_ZERO;
    }};
    (@module,$t:tt) => {{
        struct AssertSize<F: Fn(&mut Context, &mut JsModuleDef)>(PhantomData<F>);
        impl<F: Fn(&mut Context, &mut JsModuleDef)> AssertSize<F> {
            const ASSERT: [(); 1] = [()];
            const F_SIZE_MUST_ZERO: () = Self::ASSERT[std::mem::size_of::<F>()];
        }

        let _ = AssertSize::<$t>::F_SIZE_MUST_ZERO;
    }};
}
"
test/fs/test-fs-read-position-validation.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import * as common from '../common';
import * as fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';

// This test ensures that ""position"" argument is correctly validated

const filepath = fixtures.path('x.txt');

const buffer = Buffer.from('xyz\n');
const offset = 0;
const length = buffer.byteLength;

// allowedErrors is an array of acceptable internal errors
// For example, on some platforms read syscall might return -EFBIG or -EOVERFLOW
async function testValid(position, allowedErrors = []) {
  return new Promise((resolve, reject) => {
    fs.open(filepath, 'r', common.mustSucceed((fd) => {
      let callCount = 3;
      const handler = common.mustCall((err) => {
        callCount--;
        if (err && !allowedErrors.includes(err.code)) {
          fs.close(fd, common.mustSucceed());
          reject(err);
        } else if (callCount === 0) {
          fs.close(fd, common.mustSucceed(resolve));
        }
      }, callCount);
      fs.read(fd, buffer, offset, length, position, handler);
      fs.read(fd, { buffer, offset, length, position }, handler);
      fs.read(fd, buffer, common.mustNotMutateObjectDeep({ offset, length, position }), handler);
    }));
  });
}

async function testInvalid(code, position) {
  return new Promise((resolve, reject) => {
    fs.open(filepath, 'r', common.mustSucceed((fd) => {
      try {
        assert.throws(
          () => fs.read(fd, buffer, offset, length, position, common.mustNotCall()),
          { code }
        );
        assert.throws(
          () => fs.read(fd, { buffer, offset, length, position }, common.mustNotCall()),
          { code }
        );
        assert.throws(
          () => fs.read(fd, buffer, common.mustNotMutateObjectDeep({ offset, length, position }), common.mustNotCall()),
          { code }
        );
        resolve();
      } catch (err) {
        reject(err);
      } finally {
        fs.close(fd, common.mustSucceed());
      }
    }));
  });
}

(async () => {
  await testValid(undefined);
  await testValid(null);
  await testValid(-1);
  await testValid(-1n);

  await testValid(0);
  await testValid(0n);
  await testValid(1);
  await testValid(1n);
  await testValid(9);
  await testValid(9n);
  await testValid(Number.MAX_SAFE_INTEGER, ['EFBIG', 'EOVERFLOW']);

  await testValid(2n ** 63n - 1n - BigInt(length), ['EFBIG', 'EOVERFLOW']);
  await testInvalid('ERR_OUT_OF_RANGE', 2n ** 63n);

  // TODO(LiviaMedeiros): test `2n ** 63n - BigInt(length)`

  await testInvalid('ERR_OUT_OF_RANGE', NaN);
  await testInvalid('ERR_OUT_OF_RANGE', -Infinity);
  await testInvalid('ERR_OUT_OF_RANGE', Infinity);
  await testInvalid('ERR_OUT_OF_RANGE', -0.999);
  await testInvalid('ERR_OUT_OF_RANGE', -(2n ** 64n));
  await testInvalid('ERR_OUT_OF_RANGE', Number.MAX_SAFE_INTEGER + 1);
  await testInvalid('ERR_OUT_OF_RANGE', Number.MAX_VALUE);

  for (const badTypeValue of [
    false, true, '1', Symbol(1), {}, [], () => { }, Promise.resolve(1),
  ]) {
    await testInvalid('ERR_INVALID_ARG_TYPE', badTypeValue);
  }
})();
"
modules/fs.js,"import promises from ""./fs/promises""

import {
    stat,
    statSync,
    lstat,
    lstatSync,
    fstat,
    fstatSync,
    access,
    accessSync,
    exists,
    existsSync,
    mkdir,
    mkdirSync,
    fchown,
    fchownSync,
    chown,
    chownSync,
    lchown,
    lchownSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    fchmod,
    fchmodSync,
    lchmod,
    lchmodSync,
    chmod,
    chmodSync,
    futimes,
    futimesSync,
    lutimes,
    lutimesSync,
    utimes,
    utimesSync,
    rename,
    renameSync,
    unlink,
    unlinkSync,
    truncate,
    truncateSync,
    ftruncate,
    ftruncateSync,
    realpath,
    realpathSync,
    mkdtemp,
    mkdtempSync,
    copyFile,
    copyFileSync,
    link,
    linkSync,
    symlink,
    symlinkSync,
    close,
    closeSync,
    fdatasync,
    fdatasyncSync,
    fsync,
    fsyncSync,
    read,
    readSync,
    open,
    openSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    readv,
    readvSync,
    write,
    writeSync,
    writeFile,
    writeFileSync,
    appendFile,
    appendFileSync,
    writev,
    writevSync,
    opendir,
    opendirSync,
    Dir,
    Dirent,
    readdir,
    readdirSync,
    watch,
    watchFile,
    unwatch,
    cp,
    cpSync,
    createWriteStream,
    WriteStream,
    createReadStream,
    ReadStream,
    FileHandle,
    constants
} from ""./internal/fs"";

export default {
    F_OK: constants.F_OK,
    R_OK: constants.R_OK,
    W_OK: constants.W_OK,
    X_OK: constants.X_OK,
    promises,
    stat,
    statSync,
    lstat,
    lstatSync,
    fstat,
    fstatSync,
    access,
    accessSync,
    exists,
    existsSync,
    mkdir,
    mkdirSync,
    fchown,
    fchownSync,
    chown,
    chownSync,
    lchown,
    lchownSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    fchmod,
    fchmodSync,
    lchmod,
    lchmodSync,
    chmod,
    chmodSync,
    futimes,
    futimesSync,
    lutimes,
    lutimesSync,
    utimes,
    utimesSync,
    rename,
    renameSync,
    unlink,
    unlinkSync,
    truncate,
    truncateSync,
    ftruncate,
    ftruncateSync,
    realpath,
    realpathSync,
    mkdtemp,
    mkdtempSync,
    copyFile,
    copyFileSync,
    link,
    linkSync,
    symlink,
    symlinkSync,
    close,
    closeSync,
    fdatasync,
    fdatasyncSync,
    fsync,
    fsyncSync,
    read,
    readSync,
    open,
    openSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    readv,
    readvSync,
    write,
    writeSync,
    writeFile,
    writeFileSync,
    appendFile,
    appendFileSync,
    writev,
    writevSync,
    opendir,
    opendirSync,
    Dir,
    Dirent,
    readdir,
    readdirSync,
    watch,
    watchFile,
    unwatch,
    cp,
    cpSync,
    createWriteStream,
    WriteStream,
    createReadStream,
    ReadStream,
    FileHandle,
    constants
}

const F_OK = constants.F_OK;
const R_OK = constants.R_OK;
const W_OK = constants.W_OK;
const X_OK = constants.X_OK;

export {
    F_OK,
    R_OK,
    W_OK,
    X_OK,
    promises,
    stat,
    statSync,
    lstat,
    lstatSync,
    fstat,
    fstatSync,
    access,
    accessSync,
    exists,
    existsSync,
    mkdir,
    mkdirSync,
    fchown,
    fchownSync,
    chown,
    chownSync,
    lchown,
    lchownSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    fchmod,
    fchmodSync,
    lchmod,
    lchmodSync,
    chmod,
    chmodSync,
    futimes,
    futimesSync,
    lutimes,
    lutimesSync,
    utimes,
    utimesSync,
    rename,
    renameSync,
    unlink,
    unlinkSync,
    truncate,
    truncateSync,
    ftruncate,
    ftruncateSync,
    realpath,
    realpathSync,
    mkdtemp,
    mkdtempSync,
    copyFile,
    copyFileSync,
    link,
    linkSync,
    symlink,
    symlinkSync,
    close,
    closeSync,
    fdatasync,
    fdatasyncSync,
    fsync,
    fsyncSync,
    read,
    readSync,
    open,
    openSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    readv,
    readvSync,
    write,
    writeSync,
    writeFile,
    writeFileSync,
    appendFile,
    appendFileSync,
    writev,
    writevSync,
    opendir,
    opendirSync,
    Dir,
    Dirent,
    readdir,
    readdirSync,
    watch,
    watchFile,
    unwatch,
    cp,
    cpSync,
    createWriteStream,
    WriteStream,
    createReadStream,
    ReadStream,
    FileHandle,
    constants
}"
test/fs/test-fs-utimes-y2K38.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

import assert from 'assert';
import fs from 'fs';

import { spawnSync } from 'child_process';

// Check for Y2K38 support. For Windows, assume it's there. Windows
// doesn't have `touch` and `date -r` which are used in the check for support.
if (!common.isWindows) {
  const testFilePath = `${tmpdir.path}/y2k38-test`;
  const testFileDate = '204001020304';
  
  const touchResult = spawnSync('touch',
                                ['-t', testFileDate, testFilePath],
                                { encoding: 'utf8' });
  if (touchResult.status !== 0) {
    common.skip('File system appears to lack Y2K38 support (touch failed)');
  }

  // On some file systems that lack Y2K38 support, `touch` will succeed but
  // the time will be incorrect.
  const dateResult = spawnSync('date',
                               ['-r', testFilePath, '+%Y%m%d%H%M'],
                               { encoding: 'utf8' });
  if (dateResult.status === 0) {
    if (dateResult.stdout.trim() !== testFileDate) {
      common.skip('File system appears to lack Y2k38 support (date failed)');
    }
  } else {
    // On some platforms `date` may not support the `-r` option. Usually
    // this will result in a non-zero status and usage information printed.
    // In this case optimistically proceed -- the earlier `touch` succeeded
    // but validation that the file has the correct time is not easily possible.
    assert.match(dateResult.stderr, /[Uu]sage:/);
  }
}

// Ref: https://github.com/nodejs/node/issues/13255
const path = `${tmpdir.path}/test-utimes-precision`;
fs.writeFileSync(path, '');

const Y2K38_mtime = 2 ** 31;
fs.utimesSync(path, Y2K38_mtime, Y2K38_mtime);
const Y2K38_stats = fs.statSync(path);
assert.strictEqual(Y2K38_stats.mtime.getTime() / 1000, Y2K38_mtime);

if (common.isWindows) {
  // This value would get converted to (double)1713037251359.9998
  const truncate_mtime = 1713037251360;
  fs.utimesSync(path, truncate_mtime / 1000, truncate_mtime / 1000);
  const truncate_stats = fs.statSync(path);
  assert.strictEqual(truncate_stats.mtime.getTime(), truncate_mtime);

  // test Y2K38 for windows
  // This value if treaded as a `signed long` gets converted to -2135622133469.
  // POSIX systems stores timestamps in {long t_sec, long t_usec}.
  // NTFS stores times in nanoseconds in a single `uint64_t`, so when libuv
  // calculates (long)`uv_timespec_t.tv_sec` we get 2's complement.
  const overflow_mtime = 2159345162531;
  fs.utimesSync(path, overflow_mtime / 1000, overflow_mtime / 1000);
  const overflow_stats = fs.statSync(path);
  assert.strictEqual(overflow_stats.mtime.getTime(), overflow_mtime);
}
"
test/path/test-path-makelong.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';

if (common.isWindows) {
  const file = fixtures.path('a.js');
  const resolvedFile = path.resolve(file);

  assert.strictEqual(path.toNamespacedPath(file),
                     `\\\\?\\${resolvedFile}`);
  assert.strictEqual(path.toNamespacedPath(`\\\\?\\${file}`),
                     `\\\\?\\${resolvedFile}`);
  assert.strictEqual(path.toNamespacedPath(
    '\\\\someserver\\someshare\\somefile'),
                     '\\\\?\\UNC\\someserver\\someshare\\somefile');
  assert.strictEqual(path.toNamespacedPath(
    '\\\\?\\UNC\\someserver\\someshare\\somefile'),
                     '\\\\?\\UNC\\someserver\\someshare\\somefile');
  assert.strictEqual(path.toNamespacedPath('\\\\.\\pipe\\somepipe'),
                     '\\\\.\\pipe\\somepipe');
}

assert.strictEqual(path.toNamespacedPath(''), '');
assert.strictEqual(path.toNamespacedPath(null), null);
assert.strictEqual(path.toNamespacedPath(100), 100);
assert.strictEqual(path.toNamespacedPath(path), path);
assert.strictEqual(path.toNamespacedPath(false), false);
assert.strictEqual(path.toNamespacedPath(true), true);

const emptyObj = {};
assert.strictEqual(path.posix.toNamespacedPath('/foo/bar'), '/foo/bar');
assert.strictEqual(path.posix.toNamespacedPath('foo/bar'), 'foo/bar');
assert.strictEqual(path.posix.toNamespacedPath(null), null);
assert.strictEqual(path.posix.toNamespacedPath(true), true);
assert.strictEqual(path.posix.toNamespacedPath(1), 1);
assert.strictEqual(path.posix.toNamespacedPath(), undefined);
assert.strictEqual(path.posix.toNamespacedPath(emptyObj), emptyObj);
if (common.isWindows) {
  // These tests cause resolve() to insert the cwd, so we cannot test them from
  // non-Windows platforms (easily)
  assert.strictEqual(path.toNamespacedPath(''), '');
  assert.strictEqual(path.win32.toNamespacedPath('foo\\bar').toLowerCase(),
                     `\\\\?\\${process.cwd().toLowerCase()}\\foo\\bar`);
  assert.strictEqual(path.win32.toNamespacedPath('foo/bar').toLowerCase(),
                     `\\\\?\\${process.cwd().toLowerCase()}\\foo\\bar`);
  const currentDeviceLetter = path.parse(process.cwd()).root.substring(0, 2);
  assert.strictEqual(
    path.win32.toNamespacedPath(currentDeviceLetter).toLowerCase(),
    `\\\\?\\${process.cwd().toLowerCase()}`);
  assert.strictEqual(path.win32.toNamespacedPath('C').toLowerCase(),
                     `\\\\?\\${process.cwd().toLowerCase()}\\c`);
}
/*
assert.strictEqual(path.win32.toNamespacedPath('C:\\foo'), '\\\\?\\C:\\foo');
assert.strictEqual(path.win32.toNamespacedPath('C:/foo'), '\\\\?\\C:\\foo');
assert.strictEqual(path.win32.toNamespacedPath('\\\\foo\\bar'),
                   '\\\\?\\UNC\\foo\\bar\\');
assert.strictEqual(path.win32.toNamespacedPath('//foo//bar'),
                   '\\\\?\\UNC\\foo\\bar\\');
assert.strictEqual(path.win32.toNamespacedPath('\\\\?\\foo'), '\\\\?\\foo');
assert.strictEqual(path.win32.toNamespacedPath(null), null);
assert.strictEqual(path.win32.toNamespacedPath(true), true);
assert.strictEqual(path.win32.toNamespacedPath(1), 1);
assert.strictEqual(path.win32.toNamespacedPath(), undefined);
assert.strictEqual(path.win32.toNamespacedPath(emptyObj), emptyObj);
*/"
test/fs/test-fs-sync-fd-leak.js,"// Flags: --expose-internals
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import fs from 'fs';
import { internalBinding } from 'internal/test/binding';
const { UV_EBADF } = internalBinding('uv');

// Ensure that (read|write|append)FileSync() closes the file descriptor
fs.openSync = function() {
  return 42;
};
fs.closeSync = function(fd) {
  assert.strictEqual(fd, 42);
  close_called++;
};
fs.readSync = function() {
  throw new Error('BAM');
};
fs.writeSync = function() {
  throw new Error('BAM');
};

internalBinding('fs').fstat = function(fd, bigint, _, ctx) {
  ctx.errno = UV_EBADF;
  ctx.syscall = 'fstat';
};

let close_called = 0;
ensureThrows(function() {
  fs.readFileSync('dummy');
}, 'EBADF: bad file descriptor, fstat');
ensureThrows(function() {
  fs.writeFileSync('dummy', 'xxx');
}, 'BAM');
ensureThrows(function() {
  fs.appendFileSync('dummy', 'xxx');
}, 'BAM');

function ensureThrows(cb, message) {
  let got_exception = false;

  close_called = 0;
  try {
    cb();
  } catch (e) {
    assert.strictEqual(e.message, message);
    got_exception = true;
  }

  assert.strictEqual(close_called, 1);
  assert.strictEqual(got_exception, true);
}
"
test/path/test-path.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';

// Test thrown TypeErrors
const typeErrorTests = [true, false, 7, null, {}, undefined, [], NaN];

function fail(fn) {
  const args = Array.from(arguments).slice(1);

  assert.throws(() => {
    fn.apply(null, args);
  }, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });
}

typeErrorTests.forEach((test) => {
  [path.posix, /*path.win32*/].forEach((namespace) => {
    fail(namespace.join, test);
    fail(namespace.resolve, test);
    fail(namespace.normalize, test);
    fail(namespace.isAbsolute, test);
    fail(namespace.relative, test, 'foo');
    fail(namespace.relative, 'foo', test);
    fail(namespace.parse, test);
    fail(namespace.dirname, test);
    fail(namespace.basename, test);
    fail(namespace.extname, test);

    // Undefined is a valid value as the second argument to basename
    if (test !== undefined) {
      fail(namespace.basename, 'foo', test);
    }
  });
});

// path.sep tests
// windows
// assert.strictEqual(path.win32.sep, '\\');
// posix
assert.strictEqual(path.posix.sep, '/');

// path.delimiter tests
// windows
// assert.strictEqual(path.win32.delimiter, ';');
// posix
assert.strictEqual(path.posix.delimiter, ':');

if (common.isWindows)
  assert.strictEqual(path, path.win32);
else
  assert.strictEqual(path, path.posix);
"
modules/internal/streams/from.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { Buffer } from ""buffer"";
import { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } from ""../errors.js"";

function _from(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === ""string"" || iterable instanceof Buffer) {
        return new Readable({
            objectMode: true,
            ...opts,
            read() {
                this.push(iterable);
                this.push(null);
            },
        });
    }

    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE(""iterable"", [""Iterable""], iterable);
    }

    const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts,
    });

    // Flag to protect against _read
    // being called before last iteration completion.
    let reading = false;

    readable._read = function () {
        if (!reading) {
            reading = true;
            next();
        }
    };

    readable._destroy = function (error, cb) {
        close(error).then(
            () => nextTick(cb, error), // nextTick is here in case cb throws
            (e) => nextTick(cb, e || error),
        );
    };

    async function close(error) {
        const hadError = (error !== undefined) && (error !== null);
        const hasThrow = typeof iterator.throw === ""function"";
        if (hadError && hasThrow) {
            const { value, done } = await iterator.throw(error);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === ""function"") {
            const { value } = await iterator.return();
            await value;
        }
    }

    async function next() {
        for (; ;) {
            try {
                const { value, done } = isAsync
                    ? await iterator.next()
                    : iterator.next();

                if (done) {
                    readable.push(null);
                } else {
                    const res = (value &&
                        typeof value.then === ""function"")
                        ? await value
                        : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}

export default _from;"
test/fs/test-fs-write-stream-err.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const stream = fs.createWriteStream(`${tmpdir.path}/out`, {
  highWaterMark: 10
});
const err = new Error('BAM');

const write = fs.write;
let writeCalls = 0;
fs.write = function() {
  switch (writeCalls++) {
    case 0:
      console.error('first write');
      // First time is ok.
      return write.apply(fs, arguments);
    case 1: {
      // Then it breaks.
      console.error('second write');
      const cb = arguments[arguments.length - 1];
      return process.nextTick(function() {
        cb(err);
      });
    }
    default:
      // It should not be called again!
      throw new Error('BOOM!');
  }
};

fs.close = common.mustCall(function(fd_, cb) {
  console.error('fs.close', fd_, stream.fd);
  assert.strictEqual(fd_, stream.fd);
  fs.closeSync(fd_);
  process.nextTick(cb);
});

stream.on('error', common.mustCall(function(err_) {
  console.error('error handler');
  assert.strictEqual(stream.fd, null);
  assert.strictEqual(err_, err);
}));


stream.write(Buffer.allocUnsafe(256), function() {
  console.error('first cb');
  stream.write(Buffer.allocUnsafe(256), common.mustCall(function(err_) {
    console.error('second cb');
    assert.strictEqual(err_, err);
  }));
});
"
test/fs/test-fs-watch.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

// Tests if `filename` is provided to watcher on supported platforms

import fs from 'fs';
import assert from 'assert';
import { join } from 'path';

class WatchTestCase {
  constructor(shouldInclude, dirName, fileName, field) {
    this.dirName = dirName;
    this.fileName = fileName;
    this.field = field;
    this.shouldSkip = !shouldInclude;
  }
  get dirPath() { return join(tmpdir.path, this.dirName); }
  get filePath() { return join(this.dirPath, this.fileName); }
}

const cases = [
  // Watch on a file should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows || common.isAIX,
    'watch1',
    'foo',
    'filePath'
  ),
  // Watch on a directory should callback with a filename on supported systems
  new WatchTestCase(
    common.isLinux || common.isOSX || common.isWindows,
    'watch2',
    'bar',
    'dirPath'
  ),
];

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

for (const testCase of cases) {
  if (testCase.shouldSkip) continue;
  fs.mkdirSync(testCase.dirPath);
  // Long content so it's actually flushed.
  const content1 = Date.now() + testCase.fileName.toLowerCase().repeat(1e4);
  fs.writeFileSync(testCase.filePath, content1);

  let interval;
  const pathToWatch = testCase[testCase.field];
  const watcher = fs.watch(pathToWatch);
  watcher.on('error', (err) => {
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
    assert.fail(err);
  });
  watcher.on('close', common.mustCall(() => {
    watcher.close(); // Closing a closed watcher should be a noop
  }));
  watcher.on('change', common.mustCall(function(eventType, argFilename) {
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
    if (common.isOSX)
      assert.strictEqual(['rename', 'change'].includes(eventType), true);
    else
      assert.strictEqual(eventType, 'change');
    assert.strictEqual(argFilename, testCase.fileName);

    watcher.close();

    // We document that watchers cannot be used anymore when it's closed,
    // here we turn the methods into noops instead of throwing
    watcher.close(); // Closing a closed watcher should be a noop
  }));

  // Long content so it's actually flushed. toUpperCase so there's real change.
  const content2 = Date.now() + testCase.fileName.toUpperCase().repeat(1e4);
  interval = setInterval(() => {
    fs.writeFileSync(testCase.filePath, '');
    fs.writeFileSync(testCase.filePath, content2);
  }, 100);
}

[false, 1, {}, [], null, undefined].forEach((input) => {
  assert.throws(
    () => fs.watch(input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fs/test-fs-whatwg-url.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import os from 'os';

function pathToFileURL(p) {
  if (!path.isAbsolute(p))
    throw new Error('Path must be absolute');
  if (common.isWindows && p.startsWith('\\\\'))
    p = p.slice(2);
  return new URL(`file://${p}`);
}

const p = path.resolve(fixtures.fixturesDir, 'a.js');
const url = pathToFileURL(p);

assert(url instanceof URL);

// Check that we can pass in a URL object successfully
fs.readFile(url, common.mustSucceed((data) => {
  assert(Buffer.isBuffer(data));
}));

// Check that using a non file:// URL reports an error
const httpUrl = new URL('http://example.org');

assert.throws(
  () => {
    fs.readFile(httpUrl, common.mustNotCall());
  },
  {
    code: 'ERR_INVALID_URL_SCHEME',
    name: 'TypeError',
    message: 'The URL must be of scheme file'
  });

// pct-encoded characters in the path will be decoded and checked
if (common.isWindows) {
  // Encoded back and forward slashes are not permitted on windows
  ['%2f', '%2F', '%5c', '%5C'].forEach((i) => {
    assert.throws(
      () => {
        fs.readFile(new URL(`file:///c:/tmp/${i}`), common.mustNotCall());
      },
      {
        code: 'ERR_INVALID_FILE_URL_PATH',
        name: 'TypeError',
        message: 'File URL path must not include encoded \\ or / characters'
      }
    );
  });
  assert.throws(
    () => {
      fs.readFile(new URL('file:///c:/tmp/%00test'), common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_ARG_VALUE',
      name: 'TypeError',
      message: 'The argument \'path\' must be a string or Uint8Array without ' +
               ""null bytes. Received 'c:\\\\tmp\\\\\\x00test'""
    }
  );
} else {
  // Encoded forward slashes are not permitted on other platforms
  ['%2f', '%2F'].forEach((i) => {
    assert.throws(
      () => {
        fs.readFile(new URL(`file:///c:/tmp/${i}`), common.mustNotCall());
      },
      {
        code: 'ERR_INVALID_FILE_URL_PATH',
        name: 'TypeError',
        message: 'File URL path must not include encoded / characters'
      });
  });
  assert.throws(
    () => {
      fs.readFile(new URL('file://hostname/a/b/c'), common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_FILE_URL_HOST',
      name: 'TypeError',
      message: `File URL host must be ""localhost"" or empty on ${os.platform()}`
    }
  );
  assert.throws(
    () => {
      fs.readFile(new URL('file:///tmp/%00test'), common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_ARG_VALUE',
      name: 'TypeError',
      message: ""The argument 'path' must be a string or Uint8Array without "" +
               ""null bytes. Received '/tmp/\\x00test'""
    }
  );
}
"
test/fs/test-fs-fchmod.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

// This test ensures that input for fchmod is valid, testing for valid
// inputs for fd and mode

// Check input type
[false, null, undefined, {}, [], ''].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""fd"" argument must be of type number.' +
             common.invalidArgTypeHelper(input)
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
});


[false, null, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
  };
  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});

assert.throws(() => fs.fchmod(1, '123x'), {
  code: 'ERR_INVALID_ARG_VALUE'
});

[-1, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be >= 0 && <= ' +
             `2147483647. Received ${input}`
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
});

[-1, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""mode"" is out of range. It must be >= 0 && <= ' +
             `4294967295. Received ${input}`
  };

  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});

[NaN, Infinity].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be an integer. ' +
             `Received ${input}`
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
  errObj.message = errObj.message.replace('fd', 'mode');
  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});

[1.5].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be an integer. ' +
             `Received ${input}`
  };
  assert.throws(() => fs.fchmod(input), errObj);
  assert.throws(() => fs.fchmodSync(input), errObj);
  errObj.message = errObj.message.replace('fd', 'mode');
  assert.throws(() => fs.fchmod(1, input), errObj);
  assert.throws(() => fs.fchmodSync(1, input), errObj);
});
"
test/crypto/test-crypto-from-binary.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// This is the same as test/simple/test-crypto, but from before the shift
// to use buffers by default.


const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const EXTERN_APEX = 0xFBEE9;

// Manually controlled string for checking binary output
let ucs2_control = 'a\u0000';

// Grow the strings to proper length
while (ucs2_control.length <= EXTERN_APEX) {
  ucs2_control = ucs2_control.repeat(2);
}


// Check resultant buffer and output string
const b = Buffer.from(ucs2_control + ucs2_control, 'ucs2');

//
// Test updating from birant data
//
{
  const datum1 = b.slice(700000);
  const hash1_converted = crypto.createHash('sha1')
    .update(datum1.toString('base64'), 'base64')
    .digest('hex');
  const hash1_direct = crypto.createHash('sha1').update(datum1).digest('hex');
  assert.strictEqual(hash1_direct, hash1_converted);

  const datum2 = b;
  const hash2_converted = crypto.createHash('sha1')
    .update(datum2.toString('base64'), 'base64')
    .digest('hex');
  const hash2_direct = crypto.createHash('sha1').update(datum2).digest('hex');
  assert.strictEqual(hash2_direct, hash2_converted);
}
"
test/fs/test-fs-watchfile-bigint.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Flags: --expose-internals

import common from '../common';

import assert from 'assert';
import { BigIntStats } from 'internal/fs/utils';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const enoentFile = path.join(tmpdir.path, 'non-existent-file');
const expectedStatObject = new BigIntStats(
  0n,                                        // dev
  0n,                                        // mode
  0n,                                        // nlink
  0n,                                        // uid
  0n,                                        // gid
  0n,                                        // rdev
  0n,                                        // blksize
  0n,                                        // ino
  0n,                                        // size
  0n,                                        // blocks
  0n,                                        // atimeMs
  0n,                                        // mtimeMs
  0n,                                        // ctimeMs
  0n,                                        // birthtimeMs
  0n,                                        // atimeNs
  0n,                                        // mtimeNs
  0n,                                        // ctimeNs
  0n                                         // birthtimeNs
);

tmpdir.refresh();

// If the file initially didn't exist, and gets created at a later point of
// time, the callback should be invoked again with proper values in stat object
let fileExists = false;
const options = { interval: 0, bigint: true };

const watcher =
  fs.watchFile(enoentFile, options, common.mustCall((curr, prev) => {
    if (!fileExists) {
      // If the file does not exist, all the fields should be zero and the date
      // fields should be UNIX EPOCH time
      assert.deepStrictEqual(curr, expectedStatObject);
      assert.deepStrictEqual(prev, expectedStatObject);
      // Create the file now, so that the callback will be called back once the
      // event loop notices it.
      fs.closeSync(fs.openSync(enoentFile, 'w'));
      fileExists = true;
    } else {
      // If the ino (inode) value is greater than zero, it means that the file
      // is present in the filesystem and it has a valid inode number.
      assert(curr.ino > 0n);
      // As the file just got created, previous ino value should be lesser than
      // or equal to zero (non-existent file).
      assert(prev.ino <= 0n);
      // Stop watching the file
      fs.unwatchFile(enoentFile);
      watcher.stop();  // Stopping a stopped watcher should be a noop
    }
  }, 2));

// 'stop' should only be emitted once - stopping a stopped watcher should
// not trigger a 'stop' event.
watcher.on('stop', common.mustCall(function onStop() {}));
"
example_js/create-react-app-ssr/server/index.js,"import * as React from 'react';
import ReactDOMServer from 'react-dom/server';
import * as std from 'std';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import App from '../src/App.js';

async function handle_client(cs) {
    print('open:', cs.peer());
    let buffer = new http.Buffer();

    while (true) {
        try {
            let d = await cs.read();
            if (d == undefined || d.byteLength <= 0) {
                return;
            }
            buffer.append(d);
            let req = buffer.parseRequest();
            if (req instanceof http.WasiRequest) {
                handle_req(cs, req);
                break;
            }
        } catch (e) {
            print(e);
        }
    }
    print('end:', cs.peer());
}

function enlargeArray(oldArr, newLength) {
    let newArr = new Uint8Array(newLength);
    oldArr && newArr.set(oldArr, 0);
    return newArr;
}

async function handle_req(s, req) {
    print('uri:', req.uri)

    let resp = new http.WasiResponse();
    let content = '';
    if (req.uri == '/') {
        const app = ReactDOMServer.renderToString(<App />);
        content = std.loadFile('./build/index.html');
        content = content.replace('<div id=""root""></div>', `<div id=""root"">${app}</div>`);
    } else {
        let chunk = 1000; // Chunk size of each reading
        let length = 0; // The whole length of the file
        let byteArray = null; // File content as Uint8Array
        
        // Read file into byteArray by chunk
        let file = std.open('./build' + req.uri, 'r');
        while (true) {
            byteArray = enlargeArray(byteArray, length + chunk);
            let readLen = file.read(byteArray.buffer, length, chunk);
            length += readLen;
            if (readLen < chunk) {
                break;
            }
        }
        content = byteArray.slice(0, length).buffer;
        file.close();
    }
    let contentType = 'text/html; charset=utf-8';
    if (req.uri.endsWith('.css')) {
        contentType = 'text/css; charset=utf-8';
    } else if (req.uri.endsWith('.js')) {
        contentType = 'text/javascript; charset=utf-8';
    } else if (req.uri.endsWith('.json')) {
        contentType = 'text/json; charset=utf-8';
    } else if (req.uri.endsWith('.ico')) {
        contentType = 'image/vnd.microsoft.icon';
    } else if (req.uri.endsWith('.png')) {
        contentType = 'image/png';
    }
    resp.headers = {
        'Content-Type': contentType
    };

    let r = resp.encode(content);
    s.write(r);
}

async function server_start() {
    print('listen 8003...');
    try {
        let s = new net.WasiTcpServer(8003);
        for (var i = 0; ; i++) {
            let cs = await s.accept();
            handle_client(cs);
        }
    } catch (e) {
        print(e);
    }
}

server_start();
"
test/fs/test-fs-write-sync.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const filename = path.join(tmpdir.path, 'write.txt');

tmpdir.refresh();

{
  const parameters = [Buffer.from('br'), 0, Buffer.byteLength('br')];

  // The first time fs.writeSync is called with all parameters provided.
  // After that, each pop in the cycle removes the final parameter. So:
  // - The 2nd time fs.writeSync with a buffer, without the length parameter.
  // - The 3rd time fs.writeSync with a buffer, without the offset and length
  //   parameters.
  while (parameters.length > 0) {
    const fd = fs.openSync(filename, 'w');

    let written = fs.writeSync(fd, '');
    assert.strictEqual(written, 0);

    fs.writeSync(fd, 'foo');

    written = fs.writeSync(fd, ...parameters);
    assert.ok(written > 3);
    fs.closeSync(fd);

    assert.strictEqual(fs.readFileSync(filename, 'utf-8'), 'foobr');

    parameters.pop();
  }
}
"
examples/embed_rust_module/src/main.rs,"mod point {
    use wasmedge_quickjs::*;

    #[derive(Debug)]
    struct Point(i32, i32);

    struct PointDef;

    impl JsClassDef<Point> for PointDef {
        const CLASS_NAME: &'static str = ""Point\0"";
        const CONSTRUCTOR_ARGC: u8 = 2;

        fn constructor(_: &mut Context, argv: &[JsValue]) -> Option<Point> {
            println!(""rust-> new Point {:?}"", argv);
            let x = argv.get(0);
            let y = argv.get(1);
            if let (Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y))) = (x, y) {
                Some(Point(*x, *y))
            } else {
                None
            }
        }

        fn proto_init(p: &mut JsClassProto<Point, PointDef>) {
            struct X;
            impl JsClassGetterSetter<Point> for X {
                const NAME: &'static str = ""x\0"";

                fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {
                    println!(""rust-> get x"");
                    this_val.0.into()
                }

                fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {
                    println!(""rust-> set x:{:?}"", val);
                    if let JsValue::Int(x) = val {
                        this_val.0 = x
                    }
                }
            }

            struct Y;
            impl JsClassGetterSetter<Point> for Y {
                const NAME: &'static str = ""y\0"";

                fn getter(_: &mut Context, this_val: &mut Point) -> JsValue {
                    println!(""rust-> get y"");
                    this_val.1.into()
                }

                fn setter(_: &mut Context, this_val: &mut Point, val: JsValue) {
                    println!(""rust-> set y:{:?}"", val);
                    if let JsValue::Int(y) = val {
                        this_val.1 = y
                    }
                }
            }

            struct FnPrint;
            impl JsMethod<Point> for FnPrint {
                const NAME: &'static str = ""pprint\0"";
                const LEN: u8 = 0;

                fn call(_: &mut Context, this_val: &mut Point, _argv: &[JsValue]) -> JsValue {
                    println!(""rust-> pprint: {:?}"", this_val);
                    JsValue::Int(1)
                }
            }

            p.add_getter_setter(X);
            p.add_getter_setter(Y);
            p.add_function(FnPrint);
        }
    }

    struct PointModule;
    impl ModuleInit for PointModule {
        fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
            m.add_export(""Point\0"", PointDef::class_value(ctx));
        }
    }

    pub fn init_point_module(ctx: &mut Context) {
        ctx.register_class(PointDef);
        ctx.register_module(""point\0"", PointModule, &[""Point\0""]);
    }
}

use wasmedge_quickjs::*;
fn main() {
    let mut ctx = Context::new();
    point::init_point_module(&mut ctx);

    let code = r#""
    import('point').then((point)=>{
        let p0 = new point.Point(1,2)
        print(""js->"",p0.x,p0.y)
        p0.pprint()

        try{
            let p = new point.Point()
            print(""js-> p:"",p)
            print(""js->"",p.x,p.y)
            p.x=2
            p.pprint()
        } catch(e) {
            print(""An error has been caught"");
            print(e)
        }
        
    })
    ""#;

    ctx.eval_global_str(code);
    ctx.promise_loop_poll();
}
"
test/fs/test-fs-read-stream-err.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const stream = fs.createReadStream(__filename, {
  bufferSize: 64
});
const err = new Error('BAM');

stream.on('error', common.mustCall((err_) => {
  process.nextTick(common.mustCall(() => {
    assert.strictEqual(stream.fd, null);
    assert.strictEqual(err_, err);
  }));
}));

fs.close = common.mustCall((fd_, cb) => {
  assert.strictEqual(fd_, stream.fd);
  process.nextTick(cb);
});

const read = fs.read;
fs.read = function() {
  // First time is ok.
  read.apply(fs, arguments);
  // Then it breaks.
  fs.read = common.mustCall(function() {
    const cb = arguments[arguments.length - 1];
    process.nextTick(() => {
      cb(err);
    });
    // It should not be called again!
    fs.read = () => {
      throw new Error('BOOM!');
    };
  });
};

stream.on('data', (buf) => {
  stream.on('data', common.mustNotCall(""no more 'data' events should follow""));
});
"
test/fs/test-fs-write-stream.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const file = path.join(tmpdir.path, 'write.txt');

tmpdir.refresh();

{
  const stream = fs.WriteStream(file);
  const _fs_close = fs.close;

  fs.close = function(fd) {
    assert.ok(fd, 'fs.close must not be called without an undefined fd.');
    fs.close = _fs_close;
    fs.closeSync(fd);
  };
  stream.destroy();
}

{
  const stream = fs.createWriteStream(file);

  stream.on('drain', function() {
    assert.fail('\'drain\' event must not be emitted before ' +
                'stream.write() has been called at least once.');
  });
  stream.destroy();
}

// Throws if data is not of type Buffer.
{
  const stream = fs.createWriteStream(file);
  stream.on('error', common.mustNotCall());
  assert.throws(() => {
    stream.write(42);
  }, {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });
  stream.destroy();
}
"
modules/fs/promises.js,"import * as fs from ""../internal/fs"";
import { promisify } from ""../internal/util""

export const access = promisify(fs.access);
export const appendFile = (file, data, opts) => {
    if (file instanceof fs.FileHandle) {
        return file.appendFile(data, opts);
    } else {
        return promisify(fs.appendFile)(file, data, opts);
    }
};
export const chmod = promisify(fs.chmod);
export const chown = promisify(fs.chown);
export const copyFile = promisify(fs.copyFile);
export const cp = promisify(fs.cp);
export const lchmod = promisify(fs.lchmod);
export const lchown = promisify(fs.lchown);
export const lutimes = promisify(fs.lutimes);
export const link = promisify(fs.link);
export const lstat = promisify(fs.lstat);
export const mkdir = promisify(fs.mkdir);
export const mkdtemp = promisify(fs.mkdtemp);
export const open = (path, flag, mode) => {
    return new Promise((res, rej) => {
        fs.open(path, flag, mode, (err, fd) => {
            if (err !== null) {
                return rej(err);
            }
            res(new fs.FileHandle(fd, path));
        })
    })
};
export const opendir = promisify(fs.opendir);
export const readdir = promisify(fs.readdir);
export const readFile = async (path, ...args) => {
    let file = await open(path, ""r"");
    let res = await file.readFile(...args);
    await file.close();
    return res;
}

export const readlink = promisify(fs.readlink);
export const realpath = promisify(fs.realpath);
export const rename = promisify(fs.rename);
export const rmdir = promisify(fs.rmdir);
export const rm = promisify(fs.rm);
export const stat = promisify(fs.stat);
export const symlink = promisify(fs.symlink);
export const truncate = async (path, len) => {
    let file = await open(path, ""r+"");
    await file.truncate(len);
    await file.close();
};

export const unlink = promisify(fs.unlink);
export const utimes = promisify(fs.utimes);
export const watch = promisify(fs.watch);
export const writeFile = async (path, ...args) => {
    let file = await open(path, ""w"");
    await file.writeFile(...args);
    await file.close();
};

export const constants = fs.constants;

const promises = {
    access,
    appendFile,
    chmod,
    chown,
    copyFile,
    cp,
    lchmod,
    lchown,
    lutimes,
    link,
    lstat,
    mkdir,
    mkdtemp,
    open,
    opendir,
    readdir,
    readFile,
    readlink,
    realpath,
    rename,
    rmdir,
    rm,
    stat,
    symlink,
    truncate,
    unlink,
    utimes,
    watch,
    writeFile,
    constants
}

export default promises;
"
test/fs/test-fs-writefile-with-fd.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// This test makes sure that `writeFile()` always writes from the current
// position of the file, instead of truncating the file, when used with file
// descriptors.

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  /* writeFileSync() test. */
  const filename = join(tmpdir.path, 'test.txt');

  /* Open the file descriptor. */
  const fd = fs.openSync(filename, 'w');
  try {
    /* Write only five characters, so that the position moves to five. */
    assert.strictEqual(fs.writeSync(fd, 'Hello'), 5);
    assert.strictEqual(fs.readFileSync(filename).toString(), 'Hello');

    /* Write some more with writeFileSync(). */
    fs.writeFileSync(fd, 'World');

    /* New content should be written at position five, instead of zero. */
    assert.strictEqual(fs.readFileSync(filename).toString(), 'HelloWorld');
  } finally {
    fs.closeSync(fd);
  }
}

const fdsToCloseOnExit = [];
globalThis.commonExitCheck = common.mustCall(() => {
  for (const fd of fdsToCloseOnExit) {
    try {
      fs.closeSync(fd);
    } catch {
      // Failed to close, ignore
    }
  }
});

{
  /* writeFile() test. */
  const file = join(tmpdir.path, 'test1.txt');

  /* Open the file descriptor. */
  fs.open(file, 'w', common.mustSucceed((fd) => {
    fdsToCloseOnExit.push(fd);
    /* Write only five characters, so that the position moves to five. */
    fs.write(fd, 'Hello', common.mustSucceed((bytes) => {
      assert.strictEqual(bytes, 5);
      assert.strictEqual(fs.readFileSync(file).toString(), 'Hello');

      /* Write some more with writeFile(). */
      fs.writeFile(fd, 'World', common.mustSucceed(() => {
        /* New content should be written at position five, instead of zero. */
        assert.strictEqual(fs.readFileSync(file).toString(), 'HelloWorld');
      }));
    }));
  }));
}


// Test read-only file descriptor
{
  const file = join(tmpdir.path, 'test.txt');

  fs.open(file, 'r', common.mustSucceed((fd) => {
    fdsToCloseOnExit.push(fd);
    fs.writeFile(fd, 'World', common.expectsError(/EBADF/));
  }));
}
/*
// Test with an AbortSignal
{
  const controller = new AbortController();
  const signal = controller.signal;
  const file = join(tmpdir.path, 'test.txt');

  fs.open(file, 'w', common.mustSucceed((fd) => {
    fdsToCloseOnExit.push(fd);
    fs.writeFile(fd, 'World', { signal }, common.expectsError({
      name: 'AbortError'
    }));
  }));

  controller.abort();
}
*/"
modules/querystring.js,"function e(e, n) { return Object.prototype.hasOwnProperty.call(e, n) } var n = function (n, r, t, o) { r = r || ""&"", t = t || ""=""; var a = {}; if (""string"" != typeof n || 0 === n.length) { return a; } var u = /\+/g; n = n.split(r); var c = 1e3; o && ""number"" == typeof o.maxKeys && (c = o.maxKeys); var i = n.length; c > 0 && i > c && (i = c); for (var s = 0; s < i; ++s) { var p, f, d, y, m = n[s].replace(u, ""%20""), l = m.indexOf(t); l >= 0 ? (p = m.substr(0, l), f = m.substr(l + 1)) : (p = m, f = """"), d = decodeURIComponent(p), y = decodeURIComponent(f), e(a, d) ? Array.isArray(a[d]) ? a[d].push(y) : a[d] = [a[d], y] : a[d] = y; } return a }, r = function (e) { switch (typeof e) { case ""string"": return e; case ""boolean"": return e ? ""true"" : ""false""; case ""number"": return isFinite(e) ? e : """"; default: return """" } }, t = function (e, n, t, o) { return n = n || ""&"", t = t || ""="", null === e && (e = void 0), ""object"" == typeof e ? Object.keys(e).map((function (o) { var a = encodeURIComponent(r(o)) + t; return Array.isArray(e[o]) ? e[o].map((function (e) { return a + encodeURIComponent(r(e)) })).join(n) : a + encodeURIComponent(r(e[o])) })).join(n) : o ? encodeURIComponent(r(o)) + t + encodeURIComponent(r(e)) : """" }, o = {}; o.decode = o.parse = n, o.encode = o.stringify = t; o.decode; o.encode; o.parse; o.stringify;

o.decode;
o.encode;
o.parse;
o.stringify;

var decode = o.decode;
var encode = o.encode;
var parse = o.parse;
var stringify = o.stringify;

export { decode, o as default, encode, parse, stringify };
"
test/fs/test-fs-readfile-pipe.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Simulate `cat readfile.js | node readfile.js`

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';
import fs from 'fs';

if (process.argv[2] === 'child') {
  fs.readFile('/dev/stdin', common.mustSucceed((data) => {
    process.stdout.write(data);
  }));
  return;
}

import fixtures from '../common/fixtures';

const filename = fixtures.path('readfile_pipe_test.txt');
const dataExpected = fs.readFileSync(filename).toString();

import { exec } from 'child_process';
const f = JSON.stringify(__filename);
const node = JSON.stringify(process.execPath);
const cmd = `cat ${filename} | ${node} ${f} child`;
exec(cmd, common.mustSucceed((stdout, stderr) => {
  assert.strictEqual(
    stdout,
    dataExpected,
    `expected to read: '${dataExpected}' but got: '${stdout}'`);
  assert.strictEqual(
    stderr,
    '',
    `expected not to read anything from stderr but got: '${stderr}'`);
  console.log('ok');
}));
"
test/fs/test-fs-write-stream-change-open.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const file = path.join(tmpdir.path, 'write.txt');

tmpdir.refresh();

const stream = fs.WriteStream(file);
const _fs_close = fs.close;
const _fs_open = fs.open;

// Change the fs.open with an identical function after the WriteStream
// has pushed it onto its internal action queue, but before it's
// returned.  This simulates AOP-style extension of the fs lib.
fs.open = function() {
  return _fs_open.apply(fs, arguments);
};

fs.close = function(fd) {
  assert.ok(fd, 'fs.close must not be called with an undefined fd.');
  fs.close = _fs_close;
  fs.open = _fs_open;
  fs.closeSync(fd);
};

stream.write('foo');
stream.end();

process.on('exit', function() {
  assert.strictEqual(fs.open, _fs_open);
});
"
test/fs/test-fs-exists.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { URL } from ""url""

let __filename = args[0];

const f = __filename;

assert.throws(() => fs.exists(f), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.exists(), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.exists(f, {}), { code: 'ERR_INVALID_ARG_TYPE' });

fs.exists(f, common.mustCall(function(y) {
  assert.strictEqual(y, true);
}));

fs.exists(`${f}-NO`, common.mustCall(function(y) {
  assert.strictEqual(y, false);
}));

// If the path is invalid, fs.exists will still invoke the callback with false
// instead of throwing errors
fs.exists(new URL('https://foo'), common.mustCall(function(y) {
  assert.strictEqual(y, false);
}));

fs.exists({}, common.mustCall(function(y) {
  assert.strictEqual(y, false);
}));

assert(fs.existsSync(f));
assert(!fs.existsSync(`${f}-NO`));

// fs.existsSync() never throws
assert(!fs.existsSync());
assert(!fs.existsSync({}));
assert(!fs.existsSync(new URL('https://foo')));
"
modules/encoding.js,"import { text_encode, text_decode, text_encode_into } from '_encoding'

function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
    return arg === void 0;
}

export class TextEncoder {

    get encoding() {
        return 'utf-8'
    }

    encode(input) {
        let arr = text_encode(input, 'utf-8');
        if (isUndefined(arr)) {
            return new Uint8Array()
        } else {
            return new Uint8Array(arr)
        }
    }

    encodeInto(src, dest) {
        if (dest instanceof Uint8Array) {
            return text_encode_into(src, 'utf8', dest.buffer, dest.byteOffset)
        } else {
            throw new TypeError('The ""dest"" argument must be an instance of Uint8Array.')
        }
    }
}

export class TextDecoder {
    #encoding = 'utf-8';
    #fatal = undefined;
    #ignoreBOM = undefined;

    constructor(encoding, options) {
        let { fatal, ignoreBOM } = options || {};
        this.#fatal = fatal ? true : false;
        this.#ignoreBOM = ignoreBOM;
        encoding = encoding || 'utf-8';

        let exist = [
            'utf8', 'utf-8', 'gbk', 'gb18030', 'hz-gb-2312', 'big5', 'euc-jp', 'iso-2022-jp',
            'utf-16be', 'utf-16le', 'x-user-defined', 'ibm866',
            'iso-8859-2', 'iso-8859-3', 'iso-8859-4', 'iso-8859-5', 'iso-8859-6', 'iso-8859-7', 'iso-8859-8',
            'iso-8859-8i', 'iso-8859-10', 'iso-8859-13', 'iso-8859-14', 'iso-8859-15', 'iso-8859-16',
            'windows-874', 'windows-1250', 'windows-1251', 'windows-1252', 'windows-1253', 'windows-1254',
            'windows-1255', 'windows-1256', 'windows-1257', 'windows-1258', ''
        ].indexOf(encoding);

        if (exist < 0) {
            throw new RangeError(`The ""${encoding}"" encoding is not supported`);
        } else {
            this.#encoding = encoding
        }
    }

    get encoding() {
        return this.#encoding
    }

    get fatal() {
        return this.#fatal
    }

    decode(input) {
        if (typeof input != 'undefined') {
            let ret;
            if (input.buffer instanceof ArrayBuffer) {
                ret = text_decode(input.buffer, this.encoding, this.fatal)
            } else if (input instanceof ArrayBuffer) {
                ret = text_decode(input, this.encoding, this.fatal)
            }
            if (isError(ret)) {
                throw new TypeError(`The encoded data was not valid for encoding ${this.encoding}`)
            }
            return ret
        }
        throw new TypeError('The ""input"" argument must be an instance of ArrayBuffer or ArrayBufferView.')

    }
}

globalThis.TextDecoder = TextDecoder;
globalThis.TextEncoder = TextEncoder;"
test/fs/test-fs-readfile-zero-byte-liar.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Test that readFile works even when stat returns size 0.

import assert from 'assert';
import fs from 'fs';

const __filename = args[0];

const dataExpected = fs.readFileSync(__filename, 'utf8');

// Sometimes stat returns size=0, but it's a lie.
fs._fstat = fs.fstat;
fs._fstatSync = fs.fstatSync;

fs.fstat = (fd, cb) => {
  fs._fstat(fd, (er, st) => {
    if (er) return cb(er);
    st.size = 0;
    return cb(er, st);
  });
};

fs.fstatSync = (fd) => {
  const st = fs._fstatSync(fd);
  st.size = 0;
  return st;
};

const d = fs.readFileSync(__filename, 'utf8');
assert.strictEqual(d, dataExpected);

fs.readFile(__filename, 'utf8', common.mustCall((er, d) => {
  assert.strictEqual(d, dataExpected);
}));
"
test/fs/test-fs-util-validateoffsetlength.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

import common from '../common';

import assert from 'assert';
const {
  validateOffsetLengthRead,
  validateOffsetLengthWrite,
} = require('internal/fs/utils');

{
  const offset = -1;
  assert.throws(
    () => validateOffsetLengthRead(offset, 0, 0),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""offset"" is out of range. ' +
                 `It must be >= 0. Received ${offset}`
    })
  );
}

{
  const length = -1;
  assert.throws(
    () => validateOffsetLengthRead(0, length, 0),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""length"" is out of range. ' +
                 `It must be >= 0. Received ${length}`
    })
  );
}

{
  const offset = 1;
  const length = 1;
  const byteLength = offset + length - 1;
  assert.throws(
    () => validateOffsetLengthRead(offset, length, byteLength),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""length"" is out of range. ' +
                 `It must be <= ${byteLength - offset}. Received ${length}`
    })
  );
}

// Most platforms don't allow reads or writes >= 2 GiB.
// See https://github.com/libuv/libuv/pull/1501.
const kIoMaxLength = 2 ** 31 - 1;

// RangeError when offset > byteLength
{
  const offset = 100;
  const length = 100;
  const byteLength = 50;
  assert.throws(
    () => validateOffsetLengthWrite(offset, length, byteLength),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""offset"" is out of range. ' +
               `It must be <= ${byteLength}. Received ${offset}`
    })
  );
}

// RangeError when byteLength < kIoMaxLength, and length > byteLength - offset.
{
  const offset = kIoMaxLength - 150;
  const length = 200;
  const byteLength = kIoMaxLength - 100;
  assert.throws(
    () => validateOffsetLengthWrite(offset, length, byteLength),
    common.expectsError({
      code: 'ERR_OUT_OF_RANGE',
      name: 'RangeError',
      message: 'The value of ""length"" is out of range. ' +
               `It must be <= ${byteLength - offset}. Received ${length}`
    })
  );
}
"
test/fs/test-fs-symlink-dir-junction.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

// Test creating and reading symbolic link
const linkData = fixtures.path('cycles/');
const linkPath = path.join(tmpdir.path, 'cycles_link');

tmpdir.refresh();

fs.symlink(linkData, linkPath, 'junction', common.mustSucceed(() => {
  fs.lstat(linkPath, common.mustSucceed((stats) => {
    assert.ok(stats.isSymbolicLink());

    // fs.readlink(linkPath, common.mustSucceed((destination) => {
    //   assert.strictEqual(destination, linkData);

      fs.unlink(linkPath, common.mustSucceed(() => {
        assert(!fs.existsSync(linkPath));
        assert(fs.existsSync(linkData));
      }));
    // }));
  }));
}));

// Test invalid symlink
{
  const linkData = fixtures.path('/not/exists/dir');
  const linkPath = path.join(tmpdir.path, 'invalid_junction_link');

  fs.symlink(linkData, linkPath, 'junction', common.mustSucceed(() => {
    assert(!fs.existsSync(linkPath));

    fs.unlink(linkPath, common.mustSucceed(() => {
      assert(!fs.existsSync(linkPath));
    }));
  }));
}
"
test/fs/test-fs-watch-file-enoent-after-deletion.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Make sure the deletion event gets reported in the following scenario:
// 1. Watch a file.
// 2. The initial stat() goes okay.
// 3. Something deletes the watched file.
// 4. The second stat() fails with ENOENT.

// The second stat() translates into the first 'change' event but a logic error
// stopped it from getting emitted.
// https://github.com/nodejs/node-v0.x-archive/issues/4027

import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = path.join(tmpdir.path, 'watched');
fs.writeFileSync(filename, 'quis custodiet ipsos custodes');

fs.watchFile(filename, { interval: 50 }, common.mustCall(function(curr, prev) {
  fs.unwatchFile(filename);
}));

fs.unlinkSync(filename);
"
test/path/test-path-resolve.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
// import child from 'child_process';
import path from 'path';
import process from 'process';

const failures = [];
const slashRE = /\//g;
const backslashRE = /\\/g;

const posixyCwd = common.isWindows ?
  (() => {
    const _ = process.cwd()
      .replaceAll(path.sep, path.posix.sep);
    return _.slice(_.indexOf(path.posix.sep));
  })() :
  "".""; //process.cwd();

const resolveTests = [
  /*[ path.win32.resolve,
    // Arguments                               result
    [[['c:/blah\\blah', 'd:/games', 'c:../a'], 'c:\\blah\\a'],
     [['c:/ignore', 'd:\\a/b\\c/d', '\\e.exe'], 'd:\\e.exe'],
     [['c:/ignore', 'c:/some/file'], 'c:\\some\\file'],
     [['d:/ignore', 'd:some/dir//'], 'd:\\ignore\\some\\dir'],
     [['.'], process.cwd()],
     [['//server/share', '..', 'relative\\'], '\\\\server\\share\\relative'],
     [['c:/', '//'], 'c:\\'],
     [['c:/', '//dir'], 'c:\\dir'],
     [['c:/', '//server/share'], '\\\\server\\share\\'],
     [['c:/', '//server//share'], '\\\\server\\share\\'],
     [['c:/', '///some//dir'], 'c:\\some\\dir'],
     [['C:\\foo\\tmp.3\\', '..\\tmp.3\\cycles\\root.js'],
      'C:\\foo\\tmp.3\\cycles\\root.js'],
    ],
  ],*/
  [ path.posix.resolve,
    // Arguments                    result
    [[['/var/lib', '../', 'file/'], '/var/file'],
     [['/var/lib', '/../', 'file/'], '/file'],
     [['a/b/c/', '../../..'], posixyCwd],
     [['.'], posixyCwd],
     [['/some/dir', '.', '/absolute/'], '/absolute'],
     [['/foo/tmp.3/', '../tmp.3/cycles/root.js'], '/foo/tmp.3/cycles/root.js'],
    ],
  ],
];
resolveTests.forEach(([resolve, tests]) => {
  tests.forEach(([test, expected]) => {
    const actual = resolve.apply(null, test);
    let actualAlt;
    const os = /*resolve === path.win32.resolve ? 'win32' : */'posix';
    if (false /*resolve === path.win32.resolve*/ && !common.isWindows)
      actualAlt = actual.replace(backslashRE, '/');
    else if (true /*resolve !== path.win32.resolve*/ && common.isWindows)
      actualAlt = actual.replace(slashRE, '\\');

    const message =
      `path.${os}.resolve(${test.map(JSON.stringify).join(',')})\n  expect=${
        JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    if (actual !== expected && actualAlt !== expected)
      failures.push(message);
  });
});
assert.strictEqual(failures.length, 0, failures.join('\n'));

if (common.isWindows) {
  // Test resolving the current Windows drive letter from a spawned process.
  // See https://github.com/nodejs/node/issues/7215
  const currentDriveLetter = path.parse(process.cwd()).root.substring(0, 2);
  const resolveFixture = fixtures.path('path-resolve.js');
  const spawnResult = child.spawnSync(
    process.argv[0], [resolveFixture, currentDriveLetter]);
  const resolvedPath = spawnResult.stdout.toString().trim();
  assert.strictEqual(resolvedPath.toLowerCase(), process.cwd().toLowerCase());
}

if (!common.isWindows) {
  // Test handling relative paths to be safe when process.cwd() fails.
  process.cwd = () => '';
  assert.strictEqual(process.cwd(), '');
  const resolved = path.resolve();
  const expected = '.';
  assert.strictEqual(resolved, expected);
}
"
example_js/fs.js,"import { mkdirSync, statSync, lstatSync, rmdirSync, accessSync, existsSync, rmSync, renameSync, openSync, read, readFile, readFileSync } from ""fs"";


print(""\nfs.statSync\nExisted File:"");

try {
    let s = statSync(""README.md"");
    print(JSON.stringify(s));
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nExisted File with BigInt:"");

try {
    let s = statSync(""README.md"", { bigint: true });
    for (const [key, val] of Object.entries(s)) {
        print(key, "": "", typeof (val) === ""function"" ? val() : val);
    }
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nNon-existed File"");

try {
    let s = statSync(""non-exist.file"");
    print(JSON.stringify(s));
} catch (err) {
    print(err.name);
    print(err.stack);
    print(err.message);
}

print(""\nNon-existed File No Throw"");

{
    let s = statSync(""non-exist.file"", { throwIfNoEntry: false });
    print(s);
}

import { constants } from ""fs"";

print(""\nfs.constants:"");

const { F_OK, O_WRONLY } = constants;
print(""F_OK: "", F_OK);
print(""O_WRONLY: "", O_WRONLY);

print(""\nfs.lstatSync\nExisted File:"");

try {
    let s = lstatSync(""README.md"");
    print(JSON.stringify(s));
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nExisted File with BigInt:"");

try {
    let s = lstatSync(""README.md"", { bigint: true });
    for (const [key, val] of Object.entries(s)) {
        print(key, "": "", typeof (val) === ""function"" ? val() : val);
    }
} catch (err) {
    print(JSON.stringify(err));
}

print(""\nNon-existed File:"");

try {
    let s = lstatSync(""non-exist.file"");
    print(JSON.stringify(s));
} catch (err) {
    print(err.name);
    print(err.stack);
    print(err.message);
}

print(""\nNon-existed File with No Throw:"");

{
    let s = lstatSync(""non-exist.file"", { throwIfNoEntry: false });
    print(s);
}

function assert(fn) {
    if (!fn) {
        throw new Error();
    }
}

print(""\nmkdir: ./tmpdir"");
mkdirSync(""./tmpdir"");
print(""access: ./tmpdir"");
accessSync(""./tmpdir"");
print(""rmdir: ./tmpdir"");
rmdirSync(""./tmpdir"");
print(""exist: ./tmpdir"");
print(existsSync(""./tmpdir""));

print(""\nmkdir recursive: ./tmpdir/subdir"");
mkdirSync(""./tmpdir/subdir"", { recursive: true });
print(""access: ./tmpdir/subdir"");
accessSync(""./tmpdir/subdir"");
print(""rm recursive: ./tmpdir"");
rmSync(""./tmpdir"", { recursive: true });
print(""exist: ./tmpdir"");
print(existsSync(""./tmpdir""));

print(""\nrename README.md to test.md"")
renameSync(""./README.md"", ""./test.md"");
print(""exist: ./test.md"");
print(existsSync(""./test.md""));
renameSync(""./test.md"", ""./README.md"");

let fd = openSync(""./README.md"");
print(fd);
read(fd, { length: 20 }, (err, len, buf) => {
    print(err);
    print(len);
    print(buf.toString())
});

print(readFileSync(""./Cargo.toml"", ""utf-8""))
"
src/quickjs_sys/js_promise.rs,"use std::{future::Future, sync::atomic::Ordering, task::Poll};

use crate::{quickjs_sys::qjs::JS_ExecutePendingJob, Context, EventLoop, JsValue, Runtime};

use super::{
    qjs::{js_std_dump_error, JSContext, JS_GetRuntimeOpaque},
    RuntimeResult,
};

impl Context {
    pub fn future_to_promise(
        &mut self,
        f: impl Future<Output = Result<JsValue, JsValue>> + std::marker::Send + 'static,
    ) -> JsValue {
        let waker = self
            .event_loop()
            .and_then(|event_loop| event_loop.waker.clone());

        let (promise, resolve, reject) = self.new_promise();

        let handle = tokio::task::spawn(async move {
            match f.await {
                Ok(value) => {
                    if let JsValue::Function(f) = resolve {
                        f.call(&[value]);
                    }
                }
                Err(err) => {
                    if let JsValue::Function(f) = reject {
                        f.call(&[err]);
                    }
                }
            }
            log::trace!(""rt {:?} wake"", waker);
            waker.map(|waker| waker.wake());
            tokio::task::spawn(tokio::task::yield_now());
        });

        self.event_loop().map(|event_loop| {
            event_loop.sub_tasks.push_back(handle);
        });
        promise
    }
}
impl Future for Runtime {
    type Output = ();

    fn poll(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> Poll<Self::Output> {
        unsafe {
            log::trace!(""Runtime poll"");

            let rt = self.rt.0;
            let event_loop = { (JS_GetRuntimeOpaque(rt) as *mut EventLoop).as_mut() };
            if let Some(event_loop) = event_loop {
                let waker = cx.waker().clone();
                event_loop.waker.insert(waker);

                if self.run_loop_without_io() < 0 {
                    log::trace!(""Runtime Ready io < 0"");
                    return Poll::Ready(());
                }
                loop {
                    match event_loop.sub_tasks.pop_front() {
                        Some(task) => {
                            if task.is_finished() {
                                continue;
                            } else {
                                event_loop.sub_tasks.push_front(task);
                                log::trace!(""Runtime Pending"");
                                return Poll::Pending;
                            }
                        }
                        None => {
                            log::trace!(""Runtime Ready sub_tasks empty"");
                            return Poll::Ready(());
                        }
                    }
                }
            } else {
                log::trace!(""Runtime Ready sub_tasks empty"");
                Poll::Ready(())
            }
        }
    }
}

impl<'rt> Future for RuntimeResult<'rt> {
    type Output = Result<JsValue, ()>;

    fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> Poll<Self::Output> {
        let me = self.get_mut();
        if me.result.is_none() && me.box_fn.is_some() {
            unsafe {
                let rt = me.rt.rt.0;
                let event_loop = { (JS_GetRuntimeOpaque(rt) as *mut EventLoop).as_mut() };
                if let Some(event_loop) = event_loop {
                    event_loop.waker.insert(cx.waker().clone());
                } else {
                    return Poll::Ready(Err(()));
                }
                let f = me.box_fn.take().unwrap();
                me.result = Some(f(&mut me.rt.ctx));
            }
        }
        let rt = &mut me.rt;
        tokio::pin!(rt);
        std::task::ready!(rt.poll(cx));
        Poll::Ready(me.result.take().ok_or(()))
    }
}
"
test/fs/test-fs-symlink-dir-junction-relative.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
// Test creating and resolving relative junction or symbolic link

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const linkPath1 = path.join(tmpdir.path, 'junction1');
const linkPath2 = path.join(tmpdir.path, 'junction2');
const linkTarget = fixtures.fixturesDir;
const linkData = fixtures.fixturesDir;

tmpdir.refresh();

// Test fs.symlink()
fs.symlink(linkData, linkPath1, 'junction', common.mustSucceed(() => {
  verifyLink(linkPath1);
}));

// Test fs.symlinkSync()
fs.symlinkSync(linkData, linkPath2, 'junction');
verifyLink(linkPath2);

function verifyLink(linkPath) {
  const stats = fs.lstatSync(linkPath);
  assert.ok(stats.isSymbolicLink());

  const data1 = fs.readFileSync(`${linkPath}/x.txt`, 'ascii');
  const data2 = fs.readFileSync(`${linkTarget}/x.txt`, 'ascii');
  assert.strictEqual(data1, data2);

  // Clean up.
  fs.unlinkSync(linkPath);
}
"
test/crypto/test-crypto-key-objects-messageport.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const { createSecretKey, generateKeyPairSync, randomBytes } = require('crypto');
const { createContext } = require('vm');
const {
  MessageChannel,
  Worker,
  moveMessagePortToContext,
  parentPort
} = require('worker_threads');

function keyToString(key) {
  let ret;
  if (key.type === 'secret') {
    ret = key.export().toString('hex');
  } else {
    ret = key.export({ type: 'pkcs1', format: 'pem' });
  }
  return ret;
}

// Worker threads simply reply with their representation of the received key.
if (process.env.HAS_STARTED_WORKER) {
  return parentPort.once('message', ({ key }) => {
    parentPort.postMessage(keyToString(key));
  });
}

// Don't use isMainThread to allow running this test inside a worker.
process.env.HAS_STARTED_WORKER = 1;

// The main thread generates keys and passes them to worker threads.
const secretKey = createSecretKey(randomBytes(32));
const { publicKey, privateKey } = generateKeyPairSync('rsa', {
  modulusLength: 1024
});

// Get immutable representations of all keys.
const keys = [secretKey, publicKey, privateKey]
             .map((key) => [key, keyToString(key)]);

for (const [key, repr] of keys) {
  {
    // Test 1: No context change.
    const { port1, port2 } = new MessageChannel();

    port1.postMessage({ key });
    assert.strictEqual(keyToString(key), repr);

    port2.once('message', common.mustCall(({ key }) => {
      assert.strictEqual(keyToString(key), repr);
    }));
  }

  {
    // Test 2: Across threads.
    const worker = new Worker(__filename);
    worker.once('message', common.mustCall((receivedRepresentation) => {
      assert.strictEqual(receivedRepresentation, repr);
    }));
    worker.on('disconnect', () => console.log('disconnect'));
    worker.postMessage({ key });
  }

  {
    // Test 3: Across contexts (should not work).
    const { port1, port2 } = new MessageChannel();
    const context = createContext();
    const port2moved = moveMessagePortToContext(port2, context);
    assert(!(port2moved instanceof Object));

    // TODO(addaleax): Switch this to a 'messageerror' event once MessagePort
    // implements EventTarget fully and in a cross-context manner.
    port2moved.onmessageerror = common.mustCall((event) => {
      assert.strictEqual(event.data.code,
                         'ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE');
    });

    port2moved.start();
    port1.postMessage({ key });
    port1.close();
  }
}
"
test/fs/test-fs-fsync.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';

import fs from 'fs';
import path from 'path';

const fileFixture = fixtures.path('a.js');
const fileTemp = path.join(tmpdir.path, 'a.js');

// Copy fixtures to temp.
tmpdir.refresh();
fs.copyFileSync(fileFixture, fileTemp);

fs.open(fileTemp, 'a', 0o777, common.mustSucceed((fd) => {
  fs.fdatasyncSync(fd);

  fs.fsyncSync(fd);

  fs.fdatasync(fd, common.mustSucceed(() => {
    fs.fsync(fd, common.mustSucceed(() => {
      fs.closeSync(fd);
    }));
  }));
}));

['', false, null, undefined, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  };
  assert.throws(() => fs.fdatasync(input), errObj);
  assert.throws(() => fs.fdatasyncSync(input), errObj);
  assert.throws(() => fs.fsync(input), errObj);
  assert.throws(() => fs.fsyncSync(input), errObj);
});
"
test/fs/test-fs-writev.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = 'mlaut.       ';

const getFileName = (i) => path.join(tmpdir.path, `writev_${i}.txt`);

/**
 * Testing with a array of buffers input
 */

// fs.writev with array of buffers with all parameters
{
  const filename = getFileName(1);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer];

  const done = common.mustSucceed((written, buffers) => {
    assert.deepStrictEqual(bufferArr, buffers);
    const expectedLength = bufferArr.length * buffer.byteLength;
    assert.deepStrictEqual(written, expectedLength);
    fs.closeSync(fd);

    assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
  });

  fs.writev(fd, bufferArr, null, done);
}

// fs.writev with array of buffers without position
{
  const filename = getFileName(2);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer];

  const done = common.mustSucceed((written, buffers) => {
    assert.deepStrictEqual(bufferArr, buffers);

    const expectedLength = bufferArr.length * buffer.byteLength;
    assert.deepStrictEqual(written, expectedLength);
    fs.closeSync(fd);

    assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
  });

  fs.writev(fd, bufferArr, done);
}


// fs.writev with empty array of buffers
{
  const filename = getFileName(3);
  const fd = fs.openSync(filename, 'w');
  const bufferArr = [];
  let afterSyncCall = false;

  const done = common.mustSucceed((written, buffers) => {
    assert.strictEqual(buffers.length, 0);
    assert.strictEqual(written, 0);
    assert(afterSyncCall);
    fs.closeSync(fd);
  });

  fs.writev(fd, bufferArr, done);
  afterSyncCall = true;
}

/**
 * Testing with wrong input types
 */
{
  const filename = getFileName(4);
  const fd = fs.openSync(filename, 'w');

  [false, 'test', {}, [{}], ['sdf'], null, undefined].forEach((i) => {
    assert.throws(
      () => fs.writev(fd, i, null, common.mustNotCall()), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

// fs.writev with wrong fd types
[false, 'test', {}, [{}], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.writev(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fs/test-fs-write-stream-end.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');
  const stream = fs.createWriteStream(file);
  stream.end();
  stream.on('close', common.mustCall());
}

{
  const file = path.join(tmpdir.path, 'write-end-test1.txt');
  const stream = fs.createWriteStream(file);
  stream.end('a\n', 'utf8');
  stream.on('close', common.mustCall(function() {
    const content = fs.readFileSync(file, 'utf8');
    assert.strictEqual(content, 'a\n');
  }));
}

{
  const file = path.join(tmpdir.path, 'write-end-test2.txt');
  const stream = fs.createWriteStream(file);
  stream.end();

  let calledOpen = false;
  stream.on('open', () => {
    calledOpen = true;
  });
  stream.on('finish', common.mustCall(() => {
    assert.strictEqual(calledOpen, true);
  }));
}
"
test/crypto/test-crypto-ecb.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

if (common.hasFipsCrypto)
  common.skip('BF-ECB is not FIPS 140-2 compatible');

if (common.hasOpenSSL3)
  common.skip('Blowfish is only available with the legacy provider in ' +
    'OpenSSl 3.x');

const assert = require('assert');
const crypto = require('crypto');

// Testing whether EVP_CipherInit_ex is functioning correctly.
// Reference: bug#1997

{
  const encrypt =
    crypto.createCipheriv('BF-ECB', 'SomeRandomBlahz0c5GZVnR', '');
  let hex = encrypt.update('Hello World!', 'ascii', 'hex');
  hex += encrypt.final('hex');
  assert.strictEqual(hex.toUpperCase(), '6D385F424AAB0CFBF0BB86E07FFB7D71');
}

{
  const decrypt =
    crypto.createDecipheriv('BF-ECB', 'SomeRandomBlahz0c5GZVnR', '');
  let msg = decrypt.update('6D385F424AAB0CFBF0BB86E07FFB7D71', 'hex', 'ascii');
  msg += decrypt.final('ascii');
  assert.strictEqual(msg, 'Hello World!');
}
"
example_js/create-react-app-ssr/src/logo.svg,"<svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 841.9 595.3""><g fill=""#61DAFB""><path d=""M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z""/><circle cx=""420.9"" cy=""296.5"" r=""45.7""/><path d=""M520.5 78.1z""/></g></svg>"
test/fs/test-fs-symlink-buffer-path.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
if (!common.canCreateSymLink())
  common.skip('insufficient privileges');

import fixtures from '../common/fixtures';

import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test creating and reading symbolic link
const linkData = fixtures.path('/cycles/root.js');
const linkPath = path.join(tmpdir.path, 'symlink1.js');

let linkTime;
let fileTime;

// Refs: https://github.com/nodejs/node/issues/34514
fs.symlinkSync(Buffer.from(linkData), linkPath);

fs.lstat(linkPath, common.mustSucceed((stats) => {
  linkTime = stats.mtime.getTime();
}));

fs.stat(linkPath, common.mustSucceed((stats) => {
  fileTime = stats.mtime.getTime();
}));
/*
fs.readlink(linkPath, common.mustSucceed((destination) => {
  assert.strictEqual(destination, linkData);
}));
*/
globalThis.commonExitCheck = () => {
  assert.notStrictEqual(linkTime, fileTime);
};
"
test/crypto/test-crypto-timing-safe-equal.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

// 'should consider equal strings to be equal'
assert.strictEqual(
  crypto.timingSafeEqual(Buffer.from('foo'), Buffer.from('foo')),
  true
);

// 'should consider unequal strings to be unequal'
assert.strictEqual(
  crypto.timingSafeEqual(Buffer.from('foo'), Buffer.from('bar')),
  false
);

{
  // Test TypedArrays with different lengths but equal byteLengths.
  const buf = crypto.randomBytes(16).buffer;
  const a1 = new Uint8Array(buf);
  const a2 = new Uint16Array(buf);
  const a3 = new Uint32Array(buf);

  for (const left of [a1, a2, a3]) {
    for (const right of [a1, a2, a3]) {
      assert.strictEqual(crypto.timingSafeEqual(left, right), true);
    }
  }
}

{
  // When the inputs are floating-point numbers, timingSafeEqual neither has
  // equality nor SameValue semantics. It just compares the underlying bytes,
  // ignoring the TypedArray type completely.

  const cmp = (fn) => (a, b) => a.every((x, i) => fn(x, b[i]));
  const eq = cmp((a, b) => a === b);
  const is = cmp(Object.is);

  function test(a, b, { equal, sameValue, timingSafeEqual }) {
    assert.strictEqual(eq(a, b), equal);
    assert.strictEqual(is(a, b), sameValue);
    assert.strictEqual(crypto.timingSafeEqual(a, b), timingSafeEqual);
  }

  test(new Float32Array([NaN]), new Float32Array([NaN]), {
    equal: false,
    sameValue: true,
    timingSafeEqual: true
  });

  test(new Float64Array([0]), new Float64Array([-0]), {
    equal: true,
    sameValue: false,
    timingSafeEqual: false
  });

  const x = new BigInt64Array([0x7ff0000000000001n, 0xfff0000000000001n]);
  test(new Float64Array(x.buffer), new Float64Array([NaN, NaN]), {
    equal: false,
    sameValue: true,
    timingSafeEqual: false
  });
}

assert.throws(
  () => crypto.timingSafeEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 2])),
  {
    code: 'ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH',
    name: 'RangeError',
    message: 'Input buffers must have the same byte length'
  }
);

assert.throws(
  () => crypto.timingSafeEqual('not a buffer', Buffer.from([1, 2])),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  }
);

assert.throws(
  () => crypto.timingSafeEqual(Buffer.from([1, 2]), 'not a buffer'),
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  }
);
"
test/crypto/test-crypto-verify-failure.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const crypto = require('crypto');
const tls = require('tls');
const fixtures = require('../common/fixtures');

const certPem = fixtures.readKey('rsa_cert.crt');

const options = {
  key: fixtures.readKey('agent1-key.pem'),
  cert: fixtures.readKey('agent1-cert.pem')
};

const server = tls.Server(options, (socket) => {
  setImmediate(() => {
    verify();
    setImmediate(() => {
      socket.destroy();
    });
  });
});

function verify() {
  crypto.createVerify('SHA1')
    .update('Test')
    .verify(certPem, 'asdfasdfas', 'base64');
}

server.listen(0, common.mustCall(() => {
  tls.connect({
    port: server.address().port,
    rejectUnauthorized: false
  }, common.mustCall(() => {
    verify();
  }))
    .on('error', common.mustNotCall())
    .on('close', common.mustCall(() => {
      server.close();
    })).resume();
}));

server.unref();
"
modules/internal/normalize_encoding.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.

export function normalizeEncoding(enc) {
    if (enc == null || enc === ""utf8"" || enc === ""utf-8"") return ""utf8"";
    return slowCases(enc);
}

export function slowCases(enc) {
    switch (enc.length) {
        case 4:
            if (enc === ""UTF8"") return ""utf8"";
            if (enc === ""ucs2"" || enc === ""UCS2"") return ""utf16le"";
            enc = `${enc}`.toLowerCase();
            if (enc === ""utf8"") return ""utf8"";
            if (enc === ""ucs2"") return ""utf16le"";
            break;
        case 3:
            if (
                enc === ""hex"" || enc === ""HEX"" ||
                `${enc}`.toLowerCase() === ""hex""
            ) {
                return ""hex"";
            }
            break;
        case 5:
            if (enc === ""ascii"") return ""ascii"";
            if (enc === ""ucs-2"") return ""utf16le"";
            if (enc === ""UTF-8"") return ""utf8"";
            if (enc === ""ASCII"") return ""ascii"";
            if (enc === ""UCS-2"") return ""utf16le"";
            enc = `${enc}`.toLowerCase();
            if (enc === ""utf-8"") return ""utf8"";
            if (enc === ""ascii"") return ""ascii"";
            if (enc === ""ucs-2"") return ""utf16le"";
            break;
        case 6:
            if (enc === ""base64"") return ""base64"";
            if (enc === ""latin1"" || enc === ""binary"") return ""latin1"";
            if (enc === ""BASE64"") return ""base64"";
            if (enc === ""LATIN1"" || enc === ""BINARY"") return ""latin1"";
            enc = `${enc}`.toLowerCase();
            if (enc === ""base64"") return ""base64"";
            if (enc === ""latin1"" || enc === ""binary"") return ""latin1"";
            break;
        case 7:
            if (
                enc === ""utf16le"" || enc === ""UTF16LE"" ||
                `${enc}`.toLowerCase() === ""utf16le""
            ) {
                return ""utf16le"";
            }
            break;
        case 8:
            if (
                enc === ""utf-16le"" || enc === ""UTF-16LE"" ||
                `${enc}`.toLowerCase() === ""utf-16le""
            ) {
                return ""utf16le"";
            }
            break;
        case 9:
            if (
                enc === ""base64url"" || enc === ""BASE64URL"" ||
                `${enc}`.toLowerCase() === ""base64url""
            ) {
                return ""base64url"";
            }
            break;
        default:
            if (enc === """") return ""utf8"";
    }
}"
test/fs/test-fs-truncate-clear-file-zero.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

// This test ensures that `fs.truncate` opens the file with `r+` and not `w`,
// which had earlier resulted in the target file's content getting zeroed out.
// https://github.com/nodejs/node-v0.x-archive/issues/6233

import assert from 'assert';
import fs from 'fs';

const filename = `${tmpdir.path}/truncate-file.txt`;

tmpdir.refresh();

// Synchronous test.
{
  fs.writeFileSync(filename, '0123456789');
  assert.strictEqual(fs.readFileSync(filename).toString(), '0123456789');
  fs.truncateSync(filename, 5);
  assert.strictEqual(fs.readFileSync(filename).toString(), '01234');
}

// Asynchronous test.
{
  fs.writeFileSync(filename, '0123456789');
  assert.strictEqual(fs.readFileSync(filename).toString(), '0123456789');
  fs.truncate(
    filename,
    5,
    common.mustSucceed(() => {
      assert.strictEqual(fs.readFileSync(filename).toString(), '01234');
    })
  );
}
"
test/fs/test-fs-utils-get-dirents.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

import common from '../common';
import { getDirents, getDirent } from 'internal/fs/utils';
import assert from 'assert';
import { internalBinding } from 'internal/test/binding';
const { UV_DIRENT_UNKNOWN } = internalBinding('constants').fs;
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
const filename = 'foo';

{
  // setup
  tmpdir.refresh();
  fs.writeFileSync(path.join(tmpdir.path, filename), '');
}
// getDirents
{
  // string + string
  getDirents(
    tmpdir.path,
    [[filename], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err, names) => {
      assert.strictEqual(err, null);
      assert.strictEqual(names.length, 1);
    },
    ));
}
{
  // string + Buffer
  getDirents(
    tmpdir.path,
    [[Buffer.from(filename)], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err, names) => {
      assert.strictEqual(err, null);
      assert.strictEqual(names.length, 1);
    },
    ));
}
{
  // Buffer + Buffer
  getDirents(
    Buffer.from(tmpdir.path),
    [[Buffer.from(filename)], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err, names) => {
      assert.strictEqual(err, null);
      assert.strictEqual(names.length, 1);
    },
    ));
}
{
  // wrong combination
  getDirents(
    42,
    [[Buffer.from(filename)], [UV_DIRENT_UNKNOWN]],
    common.mustCall((err) => {
      assert.strictEqual(
        err.message,
        [
          'The ""path"" argument must be of type string or an ' +
          'instance of Buffer. Received type number (42)',
        ].join(''));
    },
    ));
}
// getDirent
{
  // string + string
  getDirent(
    tmpdir.path,
    filename,
    UV_DIRENT_UNKNOWN,
    common.mustCall((err, dirent) => {
      assert.strictEqual(err, null);
      assert.strictEqual(dirent.name, filename);
    },
    ));
}
{
  // string + Buffer
  const filenameBuffer = Buffer.from(filename);
  getDirent(
    tmpdir.path,
    filenameBuffer,
    UV_DIRENT_UNKNOWN,
    common.mustCall((err, dirent) => {
      assert.strictEqual(err, null);
      assert.strictEqual(dirent.name, filenameBuffer);
    },
    ));
}
{
  // Buffer + Buffer
  const filenameBuffer = Buffer.from(filename);
  getDirent(
    Buffer.from(tmpdir.path),
    filenameBuffer,
    UV_DIRENT_UNKNOWN,
    common.mustCall((err, dirent) => {
      assert.strictEqual(err, null);
      assert.strictEqual(dirent.name, filenameBuffer);
    },
    ));
}
{
  // wrong combination
  getDirent(
    42,
    Buffer.from(filename),
    UV_DIRENT_UNKNOWN,
    common.mustCall((err) => {
      assert.strictEqual(
        err.message,
        [
          'The ""path"" argument must be of type string or an ' +
          'instance of Buffer. Received type number (42)',
        ].join(''));
    },
    ));
}
"
test/crypto/test-crypto-domains.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const domain = require('domain');
const assert = require('assert');
const crypto = require('crypto');

const d = domain.create();
const expect = ['pbkdf2', 'randomBytes', 'pseudoRandomBytes'];

d.on('error', common.mustCall(function(e) {
  assert.strictEqual(e.message, expect.shift());
}, 3));

d.run(function() {
  one();

  function one() {
    crypto.pbkdf2('a', 'b', 1, 8, 'sha1', function() {
      two();
      throw new Error('pbkdf2');
    });
  }

  function two() {
    crypto.randomBytes(4, function() {
      three();
      throw new Error('randomBytes');
    });
  }

  function three() {
    crypto.pseudoRandomBytes(4, function() {
      throw new Error('pseudoRandomBytes');
    });
  }
});
"
test/fs/test-fs-readfile-unlink.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

// Test that unlink succeeds immediately after readFile completes.

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const fileName = path.resolve(tmpdir.path, 'test.bin');
const buf = Buffer.alloc(512 * 1024, 42);

tmpdir.refresh();

fs.writeFileSync(fileName, buf);

fs.readFile(fileName, common.mustSucceed((data) => {
  assert.strictEqual(data.length, buf.length);
  assert.strictEqual(buf[0], 42);

  // Unlink should not throw. This is part of the test. It used to throw on
  // Windows due to a bug.
  fs.unlinkSync(fileName);
}));
"
test/fs/test-fs-readfile-fd.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Test fs.readFile using a file descriptor.

import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const fn = fixtures.path('empty.txt');
import { join } from 'path';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

tempFd(function(fd, close) {
  fs.readFile(fd, function(err, data) {
    assert.ok(data);
    close();
  });
});

tempFd(function(fd, close) {
  fs.readFile(fd, 'utf8', function(err, data) {
    assert.strictEqual(data, '');
    close();
  });
});

tempFdSync(function(fd) {
  assert.ok(fs.readFileSync(fd));
});

tempFdSync(function(fd) {
  assert.strictEqual(fs.readFileSync(fd, 'utf8'), '');
});

function tempFd(callback) {
  fs.open(fn, 'r', function(err, fd) {
    assert.ifError(err);
    callback(fd, function() {
      fs.close(fd, function(err) {
        assert.ifError(err);
      });
    });
  });
}

function tempFdSync(callback) {
  const fd = fs.openSync(fn, 'r');
  callback(fd);
  fs.closeSync(fd);
}

{
  // This test makes sure that `readFile()` always reads from the current
  // position of the file, instead of reading from the beginning of the file,
  // when used with file descriptors.

  const filename = join(tmpdir.path, 'test.txt');
  fs.writeFileSync(filename, 'Hello World');

  {
    // Tests the fs.readFileSync().
    const fd = fs.openSync(filename, 'r');

    // Read only five bytes, so that the position moves to five.
    const buf = Buffer.alloc(5);
    assert.strictEqual(fs.readSync(fd, buf, 0, 5), 5);
    assert.strictEqual(buf.toString(), 'Hello');

    // readFileSync() should read from position five, instead of zero.
    assert.strictEqual(fs.readFileSync(fd).toString(), ' World');

    fs.closeSync(fd);
  }

  {
    // Tests the fs.readFile().
    fs.open(filename, 'r', common.mustSucceed((fd) => {
      const buf = Buffer.alloc(5);

      // Read only five bytes, so that the position moves to five.
      fs.read(fd, buf, 0, 5, null, common.mustSucceed((bytes) => {
        assert.strictEqual(bytes, 5);
        assert.strictEqual(buf.toString(), 'Hello');

        fs.readFile(fd, common.mustSucceed((data) => {
          // readFile() should read from position five, instead of zero.
          assert.strictEqual(data.toString(), ' World');

          fs.closeSync(fd);
        }));
      }));
    }));
  }
}
"
test/fs/test-fs-empty-readStream.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const emptyFile = fixtures.path('empty.txt');

fs.open(emptyFile, 'r', common.mustSucceed((fd) => {
  const read = fs.createReadStream(emptyFile, { fd });

  read.once('data', common.mustNotCall('data event should not emit'));

  read.once('end', common.mustCall());
}));

fs.open(emptyFile, 'r', common.mustSucceed((fd) => {
  const read = fs.createReadStream(emptyFile, { fd });

  read.pause();

  read.once('data', common.mustNotCall('data event should not emit'));

  read.once('end', common.mustNotCall('end event should not emit'));

  setTimeout(common.mustCall(() => {
    assert.strictEqual(read.isPaused(), true);
  }), common.platformTimeout(50));
}));
"
test/fs/test-fs-read-stream-fd.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, '/read_stream_fd_test.txt');
const input = 'hello world';

let output = '';
tmpdir.refresh();
fs.writeFileSync(file, input);

const fd = fs.openSync(file, 'r');
const stream = fs.createReadStream(null, { fd: fd, encoding: 'utf8' });

assert.strictEqual(stream.path, undefined);

stream.on('data', common.mustCallAtLeast((data) => {
  output += data;
}));

process.on('exit', () => {
  assert.strictEqual(output, input);
});
"
test/crypto/test-crypto-hash-stream-pipe.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import crypto from 'crypto';

import stream from 'stream';
const s = new stream.PassThrough();
const h = crypto.createHash('sha3-512');
const expect = '36a38a2a35e698974d4e5791a3f05b05' +
               '198235381e864f91a0e8cd6a26b677ec' +
               'dcde8e2b069bd7355fabd68abd6fc801' +
               '19659f25e92f8efc961ee3a7c815c758';

s.pipe(h).on('data', common.mustCall(function(c) {
  assert.strictEqual(c, expect);
  // Calling digest() after piping into a stream with SHA3 should not cause
  // a segmentation fault, see https://github.com/nodejs/node/issues/28245.
  assert.strictEqual(h.digest('hex'), expect);
})).setEncoding('hex');

s.end('aoeu');
"
test/fs/test-fs-long-path.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
if (!common.isWindows)
  common.skip('this test is Windows-specific.');

import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

// Make a path that will be at least 260 chars long.
const fileNameLen = Math.max(260 - tmpdir.path.length - 1, 1);
const fileName = path.join(tmpdir.path, 'x'.repeat(fileNameLen));
const fullPath = path.resolve(fileName);

tmpdir.refresh();

console.log({
  filenameLength: fileName.length,
  fullPathLength: fullPath.length
});

fs.writeFile(fullPath, 'ok', common.mustSucceed(() => {
  fs.stat(fullPath, common.mustSucceed());
}));
"
test/fs/test-fs-readv.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = 'mlaut.       ';

let cnt = 0;
const getFileName = () => path.join(tmpdir.path, `readv_${++cnt}.txt`);
const exptectedBuff = Buffer.from(expected);

const allocateEmptyBuffers = (combinedLength) => {
  const bufferArr = [];
  // Allocate two buffers, each half the size of exptectedBuff
  bufferArr[0] = Buffer.alloc(Math.floor(combinedLength / 2));
  bufferArr[1] = Buffer.alloc(combinedLength - bufferArr[0].length);

  return bufferArr;
};

const getCallback = (fd, bufferArr) => {
  return common.mustSucceed((bytesRead, buffers) => {
    assert.deepStrictEqual(bufferArr, buffers);
    const expectedLength = exptectedBuff.length;
    assert.deepStrictEqual(bytesRead, expectedLength);
    fs.closeSync(fd);

    assert(Buffer.concat(bufferArr).equals(exptectedBuff));
  });
};

// fs.readv with array of buffers with all parameters
{
  const filename = getFileName();
  const fd = fs.openSync(filename, 'w+');
  fs.writeSync(fd, exptectedBuff);

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
  const callback = getCallback(fd, bufferArr);

  fs.readv(fd, bufferArr, 0, callback);
}

// fs.readv with array of buffers without position
{
  const filename = getFileName();
  fs.writeFileSync(filename, exptectedBuff);
  const fd = fs.openSync(filename, 'r');

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
  const callback = getCallback(fd, bufferArr);

  fs.readv(fd, bufferArr, callback);
}

/**
 * Testing with incorrect arguments
 */
const wrongInputs = [false, 'test', {}, [{}], ['sdf'], null, undefined];

{
  const filename = getFileName(2);
  fs.writeFileSync(filename, exptectedBuff);
  const fd = fs.openSync(filename, 'r');


  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readv(fd, wrongInput, null, common.mustNotCall()), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

{
  // fs.readv with wrong fd argument
  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readv(wrongInput, common.mustNotCall()),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });
}
"
test/path/test-path-extname.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

const __filename = args[0];

const failures = [];
const slashRE = /\//g;

[
  [__filename, '.js'],
  ['', ''],
  ['/path/to/file', ''],
  ['/path/to/file.ext', '.ext'],
  ['/path.to/file.ext', '.ext'],
  ['/path.to/file', ''],
  ['/path.to/.file', ''],
  ['/path.to/.file.ext', '.ext'],
  ['/path/to/f.ext', '.ext'],
  ['/path/to/..ext', '.ext'],
  ['/path/to/..', ''],
  ['file', ''],
  ['file.ext', '.ext'],
  ['.file', ''],
  ['.file.ext', '.ext'],
  ['/file', ''],
  ['/file.ext', '.ext'],
  ['/.file', ''],
  ['/.file.ext', '.ext'],
  ['.path/file.ext', '.ext'],
  ['file.ext.ext', '.ext'],
  ['file.', '.'],
  ['.', ''],
  ['./', ''],
  ['.file.ext', '.ext'],
  ['.file', ''],
  ['.file.', '.'],
  ['.file..', '.'],
  ['..', ''],
  ['../', ''],
  ['..file.ext', '.ext'],
  ['..file', '.file'],
  ['..file.', '.'],
  ['..file..', '.'],
  ['...', '.'],
  ['...ext', '.ext'],
  ['....', '.'],
  ['file.ext/', '.ext'],
  ['file.ext//', '.ext'],
  ['file/', ''],
  ['file//', ''],
  ['file./', '.'],
  ['file.//', '.'],
].forEach((test) => {
  const expected = test[1];
  [path.posix.extname, /*path.win32.extname*/].forEach((extname) => {
    let input = test[0];
    let os;
    if (false /*extname === path.win32.extname*/) {
      input = input.replace(slashRE, '\\');
      os = 'win32';
    } else {
      os = 'posix';
    }
    const actual = extname(input);
    const message = `path.${os}.extname(${JSON.stringify(input)})\n  expect=${
      JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    if (actual !== expected)
      failures.push(`\n${message}`);
  });
  /*{
    const input = `C:${test[0].replace(slashRE, '\\')}`;
    const actual = path.win32.extname(input);
    const message = `path.win32.extname(${JSON.stringify(input)})\n  expect=${
      JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
    if (actual !== expected)
      failures.push(`\n${message}`);
  }*/
});
assert.strictEqual(failures.length, 0, failures.join(''));

/*
// On Windows, backslash is a path separator.
assert.strictEqual(path.win32.extname('.\\'), '');
assert.strictEqual(path.win32.extname('..\\'), '');
assert.strictEqual(path.win32.extname('file.ext\\'), '.ext');
assert.strictEqual(path.win32.extname('file.ext\\\\'), '.ext');
assert.strictEqual(path.win32.extname('file\\'), '');
assert.strictEqual(path.win32.extname('file\\\\'), '');
assert.strictEqual(path.win32.extname('file.\\'), '.');
assert.strictEqual(path.win32.extname('file.\\\\'), '.');
*/

// On *nix, backslash is a valid name component like any other character.
assert.strictEqual(path.posix.extname('.\\'), '');
assert.strictEqual(path.posix.extname('..\\'), '.\\');
assert.strictEqual(path.posix.extname('file.ext\\'), '.ext\\');
assert.strictEqual(path.posix.extname('file.ext\\\\'), '.ext\\\\');
assert.strictEqual(path.posix.extname('file\\'), '');
assert.strictEqual(path.posix.extname('file\\\\'), '');
assert.strictEqual(path.posix.extname('file.\\'), '.\\');
assert.strictEqual(path.posix.extname('file.\\\\'), '.\\\\');
"
test/crypto/test-crypto-domain.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const domain = require('domain');

const test = (fn) => {
  const ex = new Error('BAM');
  const d = domain.create();
  d.on('error', common.mustCall(function(err) {
    assert.strictEqual(err, ex);
  }));
  const cb = common.mustCall(function() {
    throw ex;
  });
  d.run(cb);
};

test(function(cb) {
  crypto.pbkdf2('password', 'salt', 1, 8, cb);
});

test(function(cb) {
  crypto.randomBytes(32, cb);
});
"
test/fs/test-fs-writev-sync.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = 'mlaut.       ';

const getFileName = (i) => path.join(tmpdir.path, `writev_sync_${i}.txt`);

/**
 * Testing with a array of buffers input
 */

// fs.writevSync with array of buffers with all parameters
{
  const filename = getFileName(1);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer];
  const expectedLength = bufferArr.length * buffer.byteLength;

  let written = fs.writevSync(fd, [Buffer.from('')], null);
  assert.strictEqual(written, 0);

  written = fs.writevSync(fd, bufferArr, null);
  assert.strictEqual(written, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

// fs.writevSync with array of buffers without position
{
  const filename = getFileName(2);
  const fd = fs.openSync(filename, 'w');

  const buffer = Buffer.from(expected);
  const bufferArr = [buffer, buffer, buffer];
  const expectedLength = bufferArr.length * buffer.byteLength;

  let written = fs.writevSync(fd, [Buffer.from('')]);
  assert.strictEqual(written, 0);

  written = fs.writevSync(fd, bufferArr);
  assert.strictEqual(written, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

// fs.writevSync with empty array of buffers
{
  const filename = getFileName(3);
  const fd = fs.openSync(filename, 'w');
  const written = fs.writevSync(fd, []);
  assert.strictEqual(written, 0);
  fs.closeSync(fd);

}

/**
 * Testing with wrong input types
 */
{
  const filename = getFileName(4);
  const fd = fs.openSync(filename, 'w');

  [false, 'test', {}, [{}], ['sdf'], null, undefined].forEach((i) => {
    assert.throws(
      () => fs.writevSync(fd, i, null), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

// fs.writevSync with wrong fd types
[false, 'test', {}, [{}], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.writevSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fs/test-fs-read-stream-resume.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';

import fs from 'fs';

const file = fixtures.path('x.txt');
let data = '';
let first = true;

const stream = fs.createReadStream(file);
stream.setEncoding('utf8');
stream.on('data', common.mustCallAtLeast(function(chunk) {
  data += chunk;
  if (first) {
    first = false;
    stream.resume();
  }
}));

process.nextTick(function() {
  stream.pause();
  setTimeout(function() {
    stream.resume();
  }, 100);
});

process.on('exit', function() {
  assert.strictEqual(data, 'xyz\n');
});
"
test/fs/test-fs-read-offset-null.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';


// Test to assert the desired functioning of fs.read
// when {offset:null} is passed as options parameter

import common from '../common';
import assert from 'assert';
import fs from 'fs';
const fsPromises = fs.promises;
import fixtures from '../common/fixtures';
const filepath = fixtures.path('x.txt');

const buf = Buffer.alloc(1);
// Reading only one character, hence buffer of one byte is enough.

// Tests are done by making sure the first letter in buffer is
// same as first letter in file.
// 120 is the ascii code of letter x.

// Tests for callback API.
fs.open(filepath, 'r', common.mustSucceed((fd) => {
  fs.read(fd, { offset: null, buffer: buf },
    common.mustSucceed((bytesRead, buffer) => {
      assert.strictEqual(buffer[0], 120);
      fs.close(fd, common.mustSucceed(() => { }));
    }));
}));

fs.open(filepath, 'r', common.mustSucceed((fd) => {
  fs.read(fd, buf, { offset: null },
    common.mustSucceed((bytesRead, buffer) => {
      assert.strictEqual(buffer[0], 120);
      fs.close(fd, common.mustSucceed(() => { }));
    }));
}));

let filehandle = null;
(async () => {
  // Tests for promises api
  await (async () => {
    filehandle = await fsPromises.open(filepath, 'r');
    const readObject = await filehandle.read(buf, { offset: null });
    assert.strictEqual(readObject.buffer[0], 120);
  })()
    .finally(() => filehandle?.close())
    .then(common.mustCall());

  // Undocumented: omitted position works the same as position === null
  await (async () => {
    filehandle = await fsPromises.open(filepath, 'r');
    const readObject = await filehandle.read(buf, null, buf.length);
    assert.strictEqual(readObject.buffer[0], 120);
  })()
    .finally(() => filehandle?.close())
    .then(common.mustCall());

  await (async () => {
    filehandle = await fsPromises.open(filepath, 'r');
    const readObject = await filehandle.read(buf, null, buf.length, 0);
    assert.strictEqual(readObject.buffer[0], 120);
  })()
    .finally(() => filehandle?.close())
    .then(common.mustCall());
})();"
test/fs/test-fs-chmod-mask.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that the lower bits of mode > 0o777 still works in fs APIs.

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

let mode;
// On Windows chmod is only able to manipulate write permission
if (common.isWindows) {
  mode = 0o444;  // read-only
} else {
  mode = 0o777;
}

const maskToIgnore = 0o10000;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function test(mode, asString) {
  const suffix = asString ? 'str' : 'num';
  const input = asString ?
    (mode | maskToIgnore).toString(8) : (mode | maskToIgnore);

  {
    const file = path.join(tmpdir.path, `chmod-async-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');

    fs.chmod(file, input, common.mustSucceed(() => {
      assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
    }));
  }

  {
    const file = path.join(tmpdir.path, `chmodSync-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');

    fs.chmodSync(file, input);
    assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
  }

  {
    const file = path.join(tmpdir.path, `fchmod-async-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');
    fs.open(file, 'w', common.mustSucceed((fd) => {
      fs.fchmod(fd, input, common.mustSucceed(() => {
        assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);
        fs.close(fd, assert.ifError);
      }));
    }));
  }

  {
    const file = path.join(tmpdir.path, `fchmodSync-${suffix}.txt`);
    fs.writeFileSync(file, 'test', 'utf-8');
    const fd = fs.openSync(file, 'w');

    fs.fchmodSync(fd, input);
    assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);

    fs.close(fd, assert.ifError);
  }

  if (fs.lchmod) {
    const link = path.join(tmpdir.path, `lchmod-src-${suffix}`);
    const file = path.join(tmpdir.path, `lchmod-dest-${suffix}`);
    fs.writeFileSync(file, 'test', 'utf-8');
    fs.symlinkSync(file, link);

    fs.lchmod(link, input, common.mustSucceed(() => {
      assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode);
    }));
  }

  if (fs.lchmodSync) {
    const link = path.join(tmpdir.path, `lchmodSync-src-${suffix}`);
    const file = path.join(tmpdir.path, `lchmodSync-dest-${suffix}`);
    fs.writeFileSync(file, 'test', 'utf-8');
    fs.symlinkSync(file, link);

    fs.lchmodSync(link, input);
    assert.strictEqual(fs.lstatSync(link).mode & 0o777, mode);
  }
}

test(mode, true);
test(mode, false);
"
test/fs/test-fs-readfile-empty.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// Trivial test of fs.readFile on an empty file.
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

const fn = fixtures.path('empty.txt');

fs.readFile(fn, common.mustCall((err, data) => {
  assert.ok(data);
}));

fs.readFile(fn, 'utf8', common.mustCall((err, data) => {
  assert.strictEqual(data, '');
}));

fs.readFile(fn, { encoding: 'utf8' }, common.mustCall((err, data) => {
  assert.strictEqual(data, '');
}));

assert.ok(fs.readFileSync(fn));
assert.strictEqual(fs.readFileSync(fn, 'utf8'), '');
"
test/crypto/test-crypto-dh-odd-key.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

function test() {
  const odd = Buffer.alloc(39, 'A');

  const c = crypto.createDiffieHellman(common.hasOpenSSL3 ? 1024 : 32);
  c.setPrivateKey(odd);
  c.generateKeys();
}

// FIPS requires a length of at least 1024
if (!common.hasFipsCrypto) {
  test();
} else {
  assert.throws(function() { test(); }, /key size too small/);
}
"
test/fs/test-fs-promises-readfile.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import assert from 'assert';
import path from 'path';
import { writeFile, readFile } from 'fs/promises';
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = path.join(tmpdir.path, 'large-file');

// Creating large buffer with random content
const largeBuffer = Buffer.from(
  Array.apply(null, { length: 16834 * 2 })
    .map(Math.random)
    .map((number) => (number * (1 << 8)))
);

async function createLargeFile() {
  // Writing buffer to a file then try to read it
  await writeFile(fn, largeBuffer);
}

async function validateReadFile() {
  const readBuffer = await readFile(fn);
  assert.strictEqual(readBuffer.equals(largeBuffer), true);
}

async function validateReadFileProc() {
  // Test to make sure reading a file under the /proc directory works. Adapted
  // from test-fs-read-file-sync-hostname.js.
  // Refs:
  // - https://groups.google.com/forum/#!topic/nodejs-dev/rxZ_RoH1Gn0
  // - https://github.com/nodejs/node/issues/21331

  // Test is Linux-specific.
  if (!common.isLinux)
    return;

  const hostname = await readFile('/proc/sys/kernel/hostname');
  assert.ok(hostname.length > 0);
}

function validateReadFileAbortLogicBefore() {
  const signal = AbortSignal.abort();
  assert.rejects(readFile(fn, { signal }), {
    name: 'AbortError'
  });
}

function validateReadFileAbortLogicDuring() {
  const controller = new AbortController();
  const signal = controller.signal;
  process.nextTick(() => controller.abort());
  assert.rejects(readFile(fn, { signal }), {
    name: 'AbortError'
  });
}

async function validateWrongSignalParam() {
  // Verify that if something different than Abortcontroller.signal
  // is passed, ERR_INVALID_ARG_TYPE is thrown

  await assert.rejects(async () => {
    const callback = common.mustNotCall(() => {});
    await readFile(fn, { signal: 'hello' }, callback);
  }, { code: 'ERR_INVALID_ARG_TYPE', name: 'TypeError' });

}

(async () => {
  await createLargeFile();
  await validateReadFile();
  await validateReadFileProc();
  //await validateReadFileAbortLogicBefore();
  //await validateReadFileAbortLogicDuring();
  //await validateWrongSignalParam();
})().then(common.mustCall());
"
test/fs/test-fs-readSync-position-validation.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';

// This test ensures that ""position"" argument is correctly validated

const filepath = fixtures.path('x.txt');

const buffer = Buffer.from('xyz\n');
const offset = 0;
const length = buffer.byteLength;

// allowedErrors is an array of acceptable internal errors
// For example, on some platforms read syscall might return -EFBIG or -EOVERFLOW
function testValid(position, allowedErrors = []) {
  let fdSync;
  try {
    fdSync = fs.openSync(filepath, 'r');
    fs.readSync(fdSync, buffer, offset, length, position);
    fs.readSync(fdSync, buffer, common.mustNotMutateObjectDeep({ offset, length, position }));
  } catch (err) {
    if (!allowedErrors.includes(err.code)) {
      assert.fail(err);
    }
  } finally {
    if (fdSync) fs.closeSync(fdSync);
  }
}

function testInvalid(code, position, internalCatch = false) {
  let fdSync;
  try {
    fdSync = fs.openSync(filepath, 'r');
    assert.throws(
      () => fs.readSync(fdSync, buffer, offset, length, position),
      { code }
    );
    assert.throws(
      () => fs.readSync(fdSync, buffer, common.mustNotMutateObjectDeep({ offset, length, position })),
      { code }
    );
  } finally {
    if (fdSync) fs.closeSync(fdSync);
  }
}

{
  testValid(undefined);
  testValid(null);
  testValid(-1);
  testValid(-1n);

  testValid(0);
  testValid(0n);
  testValid(1);
  testValid(1n);
  testValid(9);
  testValid(9n);
  testValid(Number.MAX_SAFE_INTEGER, [ 'EFBIG', 'EOVERFLOW' ]);
  testValid(2n ** 63n - 1n - BigInt(length), [ 'EFBIG', 'EOVERFLOW' ]);
  testInvalid('ERR_OUT_OF_RANGE', 2n ** 63n);

  // TODO(LiviaMedeiros): test `2n ** 63n - BigInt(length)`

  testInvalid('ERR_OUT_OF_RANGE', NaN);
  testInvalid('ERR_OUT_OF_RANGE', -Infinity);
  testInvalid('ERR_OUT_OF_RANGE', Infinity);
  testInvalid('ERR_OUT_OF_RANGE', -0.999);
  testInvalid('ERR_OUT_OF_RANGE', -(2n ** 64n));
  testInvalid('ERR_OUT_OF_RANGE', Number.MAX_SAFE_INTEGER + 1);
  testInvalid('ERR_OUT_OF_RANGE', Number.MAX_VALUE);

  for (const badTypeValue of [
    false, true, '1', Symbol(1), {}, [], () => {}, Promise.resolve(1),
  ]) {
    testInvalid('ERR_INVALID_ARG_TYPE', badTypeValue);
  }
}
"
test/fs/test-fs-stream-fs-options.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

require('../common');
import fixtures from '../common/fixtures';
import path from 'path';
import fs from 'fs';
import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const streamOpts = ['open', 'close'];
const writeStreamOptions = [...streamOpts, 'write'];
const readStreamOptions = [...streamOpts, 'read'];
const originalFs = { fs };

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');

  writeStreamOptions.forEach((fn) => {
    const overrideFs = Object.assign({}, originalFs.fs, { [fn]: null });
    if (fn === 'write') overrideFs.writev = null;

    const opts = {
      fs: overrideFs
    };
    assert.throws(
      () => fs.createWriteStream(file, opts), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""options.fs.${fn}"" property must be of type function. ` +
        'Received null'
      },
      `createWriteStream options.fs.${fn} should throw if isn't a function`
    );
  });
}

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');
  const overrideFs = Object.assign({}, originalFs.fs, { writev: 'not a fn' });
  const opts = {
    fs: overrideFs
  };
  assert.throws(
    () => fs.createWriteStream(file, opts), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: 'The ""options.fs.writev"" property must be of type function. ' +
        'Received type string (\'not a fn\')'
    },
    'createWriteStream options.fs.writev should throw if isn\'t a function'
  );
}

{
  const file = fixtures.path('x.txt');
  readStreamOptions.forEach((fn) => {
    const overrideFs = Object.assign({}, originalFs.fs, { [fn]: null });
    const opts = {
      fs: overrideFs
    };
    assert.throws(
      () => fs.createReadStream(file, opts), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
        message: `The ""options.fs.${fn}"" property must be of type function. ` +
        'Received null'
      },
      `createReadStream options.fs.${fn} should throw if isn't a function`
    );
  });
}
"
test/fs/test-fs-write-file-buffer.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import util from 'util';
import fs from 'fs';
import { join } from 'path';

let data = [
  '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcH',
  'Bw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/',
  '2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4e',
  'Hh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAAQABADASIAAhEBAxEB/8QA',
  'HwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUF',
  'BAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkK',
  'FhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1',
  'dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG',
  'x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEB',
  'AQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAEC',
  'AxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRom',
  'JygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOE',
  'hYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU',
  '1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDhfBUFl/wk',
  'OmPqKJJZw3aiZFBw4z93jnkkc9u9dj8XLfSI/EBt7DTo7ea2Ox5YXVo5FC7g',
  'Tjq24nJPXNVtO0KATRvNHCIg3zoWJWQHqp+o4pun+EtJ0zxBq8mnLJa2d1L5',
  '0NvnKRjJBUE5PAx3NYxxUY0pRtvYHSc5Ka2X9d7H/9k='];

data = data.join('\n');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const buf = Buffer.from(data, 'base64');
fs.writeFileSync(join(tmpdir.path, 'test.jpg'), buf);

util.log('Done!');
"
modules/internal/crypto/hashnames.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

const kHashContextNode = 1;
const kHashContextWebCrypto = 2;
const kHashContextJwkRsa = 3;
const kHashContextJwkRsaPss = 4;
const kHashContextJwkRsaOaep = 5;
const kHashContextJwkHmac = 6;

// WebCrypto and JWK use a bunch of different names for the
// standard set of SHA-* digest algorithms... which is ... fun.
// Here we provide a utility for mapping between them in order
// make it easier in the code.

const kHashNames = {
  sha1: {
    [kHashContextNode]: 'sha1',
    [kHashContextWebCrypto]: 'SHA-1',
    [kHashContextJwkRsa]: 'RS1',
    [kHashContextJwkRsaPss]: 'PS1',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP',
    [kHashContextJwkHmac]: 'HS1',
  },
  sha256: {
    [kHashContextNode]: 'sha256',
    [kHashContextWebCrypto]: 'SHA-256',
    [kHashContextJwkRsa]: 'RS256',
    [kHashContextJwkRsaPss]: 'PS256',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP-256',
    [kHashContextJwkHmac]: 'HS256',
  },
  sha384: {
    [kHashContextNode]: 'sha384',
    [kHashContextWebCrypto]: 'SHA-384',
    [kHashContextJwkRsa]: 'RS384',
    [kHashContextJwkRsaPss]: 'PS384',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP-384',
    [kHashContextJwkHmac]: 'HS384',
  },
  sha512: {
    [kHashContextNode]: 'sha512',
    [kHashContextWebCrypto]: 'SHA-512',
    [kHashContextJwkRsa]: 'RS512',
    [kHashContextJwkRsaPss]: 'PS512',
    [kHashContextJwkRsaOaep]: 'RSA-OAEP-512',
    [kHashContextJwkHmac]: 'HS512',
  }
};

{
  // Index the aliases
  const keys = Object.keys(kHashNames);
  for (let n = 0; n < keys.length; n++) {
    const contexts = Object.keys(kHashNames[keys[n]]);
    for (let i = 0; i < contexts.length; i++) {
      const alias =
        String.prototype.toLowerCase.call(kHashNames[keys[n]][contexts[i]]);
      if (kHashNames[alias] === undefined)
        kHashNames[alias] = kHashNames[keys[n]];
    }
  }
}

function normalizeHashName(name, context = kHashContextNode) {
  if (typeof name !== 'string')
    return name;
  name = String.prototype.toLowerCase.call(name);
  const alias = kHashNames[name] && kHashNames[name][context];
  return alias || name;
}

normalizeHashName.kContextNode = kHashContextNode;
normalizeHashName.kContextWebCrypto = kHashContextWebCrypto;
normalizeHashName.kContextJwkRsa = kHashContextJwkRsa;
normalizeHashName.kContextJwkRsaPss = kHashContextJwkRsaPss;
normalizeHashName.kContextJwkRsaOaep = kHashContextJwkRsaOaep;
normalizeHashName.kContextJwkHmac = kHashContextJwkHmac;

export default normalizeHashName;
"
modules/internal/options.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

function getCLIOptions() {
  let options = new Map();
  let aliases = new Map();
  return { options, aliases };
}
function getEmbedderOptionsFromBinding() {
  return new Map();
}

let warnOnAllowUnauthorized = true;

let optionsMap;
let aliasesMap;
let embedderOptions;

// getCLIOptions() would serialize the option values from C++ land.
// It would error if the values are queried before bootstrap is
// complete so that we don't accidentally include runtime-dependent
// states into a runtime-independent snapshot.
function getCLIOptionsFromBinding() {
  if (!optionsMap) {
    ({ options: optionsMap } = getCLIOptions());
  }
  return optionsMap;
}

function getAliasesFromBinding() {
  if (!aliasesMap) {
    ({ aliases: aliasesMap } = getCLIOptions());
  }
  return aliasesMap;
}

function getEmbedderOptions() {
  if (!embedderOptions) {
    embedderOptions = getEmbedderOptionsFromBinding();
  }
  return embedderOptions;
}

function refreshOptions() {
  optionsMap = undefined;
  aliasesMap = undefined;
}

function getOptionValue(optionName) {
  const options = getCLIOptionsFromBinding();
  if (optionName.startsWith('--no-')) {
    const option = options.get('--' + optionName.slice(5));
    return option && !option.value;
  }
  return options.get(optionName)?.value;
}

function getAllowUnauthorized() {
  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';

  if (allowUnauthorized && warnOnAllowUnauthorized) {
    warnOnAllowUnauthorized = false;
    process.emitWarning(
      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +
      'environment variable to \'0\' makes TLS connections ' +
      'and HTTPS requests insecure by disabling ' +
      'certificate verification.');
  }
  return allowUnauthorized;
}

export default {
  get options() {
    return getCLIOptionsFromBinding();
  },
  get aliases() {
    return getAliasesFromBinding();
  },
  getOptionValue,
  getAllowUnauthorized,
  getEmbedderOptions,
  refreshOptions
};

export {
  getOptionValue,
  getAllowUnauthorized,
  getEmbedderOptions,
  refreshOptions
}
"
test/fs/test-fs-promises-file-handle-write.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.write method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

  await fileHandle.write(buffer, 0, buffer.length);
  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(buffer, readFileData);

  await fileHandle.close();
}

async function validateEmptyWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-empty-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const buffer = Buffer.from(''); // empty buffer

  await fileHandle.write(buffer, 0, buffer.length);
  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(buffer, readFileData);

  await fileHandle.close();
}

async function validateNonUint8ArrayWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-data-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const buffer = Buffer.from('Hello world', 'utf8').toString('base64');

  await fileHandle.write(buffer, 0, buffer.length);
  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(Buffer.from(buffer, 'utf8'), readFileData);

  await fileHandle.close();
}

async function validateNonStringValuesWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-non-string-write.txt');
  const fileHandle = await open(filePathForHandle, 'w+');
  const nonStringValues = [
    123, {}, new Map(), null, undefined, 0n, () => {}, Symbol(), true,
    new String('notPrimitive'),
    { toString() { return 'amObject'; } },
    { [Symbol.toPrimitive]: (hint) => 'amObject' },
  ];
  for (const nonStringValue of nonStringValues) {
    await assert.rejects(
      fileHandle.write(nonStringValue),
      { message: /""buffer""/, code: 'ERR_INVALID_ARG_TYPE' }
    );
  }

  await fileHandle.close();
}

Promise.all([
  validateWrite(),
  validateEmptyWrite(),
  validateNonUint8ArrayWrite(),
  validateNonStringValuesWrite(),
]).then(common.mustCall()).catch(err => print(err, err.stack));
"
test/fs/test-fs-stream-construct-compat-old-node.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat with old node.

  function ReadStream(...args) {
    fs.ReadStream.call(this, ...args);
  }
  Object.setPrototypeOf(ReadStream.prototype, fs.ReadStream.prototype);
  Object.setPrototypeOf(ReadStream, fs.ReadStream);

  ReadStream.prototype.open = common.mustCall(function() {
    fs.open(this.path, this.flags, this.mode, (er, fd) => {
      if (er) {
        if (this.autoClose) {
          this.destroy();
        }
        this.emit('error', er);
        return;
      }

      this.fd = fd;
      this.emit('open', fd);
      this.emit('ready');
    });
  });

  let readyCalled = false;
  let ticked = false;
  const r = new ReadStream(fixtures.path('x.txt'))
    .on('ready', common.mustCall(() => {
      readyCalled = true;
      // Make sure 'ready' is emitted in same tick as 'open'.
      assert.strictEqual(ticked, false);
    }))
    .on('error', common.mustNotCall())
    .on('open', common.mustCall((fd) => {
      process.nextTick(() => {
        ticked = true;
        r.destroy();
      });
      assert.strictEqual(readyCalled, false);
      assert.strictEqual(fd, r.fd);
    }));
}

{
  // Compat with old node.

  function WriteStream(...args) {
    fs.WriteStream.call(this, ...args);
  }
  Object.setPrototypeOf(WriteStream.prototype, fs.WriteStream.prototype);
  Object.setPrototypeOf(WriteStream, fs.WriteStream);

  WriteStream.prototype.open = common.mustCall(function() {
    fs.open(this.path, this.flags, this.mode, (er, fd) => {
      if (er) {
        if (this.autoClose) {
          this.destroy();
        }
        this.emit('error', er);
        return;
      }

      this.fd = fd;
      this.emit('open', fd);
      this.emit('ready');
    });
  });

  let readyCalled = false;
  let ticked = false;
  const w = new WriteStream(`${tmpdir.path}/dummy`)
    .on('ready', common.mustCall(() => {
      readyCalled = true;
      // Make sure 'ready' is emitted in same tick as 'open'.
      assert.strictEqual(ticked, false);
    }))
    .on('error', common.mustNotCall())
    .on('open', common.mustCall((fd) => {
      process.nextTick(() => {
        ticked = true;
        w.destroy();
      });
      assert.strictEqual(readyCalled, false);
      assert.strictEqual(fd, w.fd);
    }));
}
"
test/fs/test-fs-stream-double-close.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

test1(fs.createReadStream(__filename));
test2(fs.createReadStream(__filename));
test3(fs.createReadStream(__filename));

test1(fs.createWriteStream(`${tmpdir.path}/dummy1`));
test2(fs.createWriteStream(`${tmpdir.path}/dummy2`));
test3(fs.createWriteStream(`${tmpdir.path}/dummy3`));

function test1(stream) {
  stream.destroy();
  stream.destroy();
}

function test2(stream) {
  stream.destroy();
  stream.on('open', common.mustCall(function(fd) {
    stream.destroy();
  }));
}

function test3(stream) {
  stream.on('open', common.mustCall(function(fd) {
    stream.destroy();
    stream.destroy();
  }));
}
"
test/fixtures/a.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const c = require('./b/c');

console.error('load fixtures/a.js');

var string = 'A';

exports.SomeClass = c.SomeClass;

exports.A = function() {
  return string;
};

exports.C = function() {
  return c.C();
};

exports.D = function() {
  return c.D();
};

exports.number = 42;

process.on('exit', function() {
  string = 'A done';
});
"
src/internal_module/httpx/core/mod.rs,"// from https://github.com/Squioole/http
use std::fmt::{Display, Formatter};
use std::str::FromStr;

pub mod chunk;
pub mod request;
pub mod response;

/// Http method
#[derive(Debug, PartialEq, Clone)]
pub enum Method {
    Get,
    Post,
    Head,
    Put,
    Delete,
    Connect,
    Options,
    Trace,
    Patch,
}

impl Display for Method {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&format!(""{:?}"", self).to_uppercase())
    }
}

impl FromStr for Method {
    type Err = ParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            ""GET"" => Ok(Method::Get),
            ""POST"" => Ok(Method::Post),
            ""PUT"" => Ok(Method::Put),
            ""DELETE"" => Ok(Method::Delete),
            ""CONNECT"" => Ok(Method::Connect),
            ""HEAD"" => Ok(Method::Head),
            ""OPTIONS"" => Ok(Method::Options),
            ""TRACE"" => Ok(Method::Trace),
            ""PATCH"" => Ok(Method::Patch),
            _ => Err(ParseError::InvalidMethod),
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Version {
    V1_0,
    V1_1,
}

impl Display for Version {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match *self {
            Version::V1_0 => f.write_str(""HTTP/1.0""),
            Version::V1_1 => f.write_str(""HTTP/1.1""),
        }
    }
}

impl FromStr for Version {
    type Err = ParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            ""HTTP/1.0"" => Ok(Version::V1_0),
            ""HTTP/1.1"" => Ok(Version::V1_1),
            _ => Err(ParseError::InvalidVersion),
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum ParseError {
    /// Any parse error not part of this list.
    OtherParseError,
    /// Invalid HTTP method.
    InvalidMethod,
    /// Invalid URL.
    InvalidUrl,
    /// Invalid HTTP version.
    InvalidVersion,
    /// Invalid request line.
    InvalidRequestLine,
    /// Invalid status code.
    InvalidStatusCode,
    /// Invalid status line.
    InvalidStatusLine,
    /// Invalid header section.
    InvalidHeaders,
    /// Invalid chunk data.
    InvalidChunk,
    /// Pending
    Pending,
}
"
test/fs/test-fs-read-file-sync-hostname.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
import common from '../common';
if (!common.isLinux)
  common.skip('Test is linux specific.');

import assert from 'assert';
import fs from 'fs';

// Test to make sure reading a file under the /proc directory works. See:
// https://groups.google.com/forum/#!topic/nodejs-dev/rxZ_RoH1Gn0
const hostname = fs.readFileSync('/proc/sys/kernel/hostname');
assert.ok(hostname.length > 0);
"
modules/internal/constants.js,"use strict';

const isWindows = false;

export const CHAR_UPPERCASE_A = 65;
export const CHAR_LOWERCASE_A = 97;
export const CHAR_UPPERCASE_Z = 90;
export const CHAR_LOWERCASE_Z = 122;
export const CHAR_UPPERCASE_C = 67;
export const CHAR_LOWERCASE_B = 98;
export const CHAR_LOWERCASE_E = 101;
export const CHAR_LOWERCASE_N = 110;
export const CHAR_DOT = 46;
export const CHAR_FORWARD_SLASH = 47;
export const CHAR_BACKWARD_SLASH = 92;
export const CHAR_VERTICAL_LINE = 124;
export const CHAR_COLON = 58;
export const CHAR_QUESTION_MARK = 63;
export const CHAR_UNDERSCORE = 95;
export const CHAR_LINE_FEED = 10;
export const CHAR_CARRIAGE_RETURN = 13;
export const CHAR_TAB = 9;
export const CHAR_FORM_FEED = 12;
export const CHAR_EXCLAMATION_MARK = 33;
export const CHAR_HASH = 35;
export const CHAR_SPACE = 32;
export const CHAR_NO_BREAK_SPACE = 160;
export const CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279;
export const CHAR_LEFT_SQUARE_BRACKET = 91;
export const CHAR_RIGHT_SQUARE_BRACKET = 93;
export const CHAR_LEFT_ANGLE_BRACKET = 60;
export const CHAR_RIGHT_ANGLE_BRACKET = 62;
export const CHAR_LEFT_CURLY_BRACKET = 123;
export const CHAR_RIGHT_CURLY_BRACKET = 125;
export const CHAR_HYPHEN_MINUS = 45;
export const CHAR_PLUS = 43;
export const CHAR_DOUBLE_QUOTE = 34;
export const CHAR_SINGLE_QUOTE = 39;
export const CHAR_PERCENT = 37;
export const CHAR_SEMICOLON = 59;
export const CHAR_CIRCUMFLEX_ACCENT = 94;
export const CHAR_GRAVE_ACCENT = 96;
export const CHAR_AT = 64;
export const CHAR_AMPERSAND = 38;
export const CHAR_EQUAL = 61;
export const CHAR_0 = 48;
export const CHAR_9 = 57;
export const EOL = isWindows ? '\r\n' : '\n';
"
test/fs/test-fs-realpath-buffer-encoding.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';

const string_dir = fs.realpathSync(fixtures.fixturesDir);
const buffer_dir = Buffer.from(string_dir);

const encodings = ['ascii', 'utf8', 'utf16le', 'ucs2',
                   'base64', 'binary', 'hex'];
const expected = {};
encodings.forEach((encoding) => {
  expected[encoding] = buffer_dir.toString(encoding);
});


// test sync version
let encoding;
for (encoding in expected) {
  const expected_value = expected[encoding];
  let result;

  result = fs.realpathSync(string_dir, { encoding });
  assert.strictEqual(result, expected_value);

  result = fs.realpathSync(string_dir, encoding);
  assert.strictEqual(result, expected_value);

  result = fs.realpathSync(buffer_dir, { encoding });
  assert.strictEqual(result, expected_value);

  result = fs.realpathSync(buffer_dir, encoding);
  assert.strictEqual(result, expected_value);
}

let buffer_result;
buffer_result = fs.realpathSync(string_dir, { encoding: 'buffer' });
assert.deepStrictEqual(buffer_result, buffer_dir);

buffer_result = fs.realpathSync(string_dir, 'buffer');
assert.deepStrictEqual(buffer_result, buffer_dir);

buffer_result = fs.realpathSync(buffer_dir, { encoding: 'buffer' });
assert.deepStrictEqual(buffer_result, buffer_dir);

buffer_result = fs.realpathSync(buffer_dir, 'buffer');
assert.deepStrictEqual(buffer_result, buffer_dir);

// test async version
for (encoding in expected) {
  const expected_value = expected[encoding];

  fs.realpath(
    string_dir,
    { encoding },
    common.mustSucceed((res) => {
      assert.strictEqual(res, expected_value);
    })
  );
  fs.realpath(string_dir, encoding, common.mustSucceed((res) => {
    assert.strictEqual(res, expected_value);
  }));
  fs.realpath(
    buffer_dir,
    { encoding },
    common.mustSucceed((res) => {
      assert.strictEqual(res, expected_value);
    })
  );
  fs.realpath(buffer_dir, encoding, common.mustSucceed((res) => {
    assert.strictEqual(res, expected_value);
  }));
}

fs.realpath(string_dir, { encoding: 'buffer' }, common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));

fs.realpath(string_dir, 'buffer', common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));

fs.realpath(buffer_dir, { encoding: 'buffer' }, common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));

fs.realpath(buffer_dir, 'buffer', common.mustSucceed((res) => {
  assert.deepStrictEqual(res, buffer_dir);
}));
"
Cargo.toml,"[package]
name = ""wasmedge_quickjs""
version = ""0.6.0-alpha""
authors = [""csh <458761603@qq.com>"", ""Michael Yuan <michael@secondstate.io>""]
description = ""Create your own JavaScript runtime and extension APIs for WasmEdge.""
repository = ""https://github.com/second-state/wasmedge-quickjs""
license = ""MIT OR Apache-2.0""
readme = ""README.md""
documentation = ""https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/""
homepage = ""https://www.secondstate.io/""
edition = ""2018""
exclude = [""example_js/*"", ""examples/*""]

[dependencies]
argparse = ""0.2.2""
image = { version = ""0.23.6"", default-features = false, features = [
    ""jpeg"",
    ""png"",
], optional = true }
imageproc = { version = ""0.22.0"", optional = true }
libc = ""0.2""
url = ""2.2.2""
lazy_static = ""1.4""
encoding = ""0.2""
wasmedge_wasi_socket = { version = ""0.5"", features = [""wasi_poll""] }
tokio_wasi = { version = ""1.25.2"", features = [""full""] }
log = ""0.4.19""
env_logger = ""0.10.0""

rustls = { version = ""0.21.0"", optional = true }
tokio-rustls-wasi = { version = ""0.24.1"", optional = true }
webpki-roots = { version = ""0.25.0"", optional = true }
crypto-wasi = { version = ""0.1.1"", optional = true }

chat-prompts = { version = ""0.3"", optional = true }
wasi-nn = { git = ""https://github.com/second-state/wasmedge-wasi-nn"", branch = ""ggml"", optional = true }
endpoints = { version = ""0.2"", optional = true }
rustls-pemfile = ""1.0.4""

[features]
default = [""tls""]
tls = [""rustls"", ""tokio-rustls-wasi"", ""webpki-roots""]
img = [""image"", ""imageproc""]
tensorflow = [""img""]
wasi_nn = [""img""]
ggml = [""chat-prompts"", ""dep:wasi-nn"", ""endpoints""]
cjs = []
nodejs_crypto = [""crypto-wasi""]
"
modules/stream.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import { addAbortSignal } from ""./internal/streams/add-abort-signal.js"";
import { destroyer } from ""./internal/streams/destroy.js"";
import { isDisturbed } from ""./internal/streams/utils.js"";
import { isUint8Array } from ""./internal/util/types.js"";
import { pipeline } from ""./internal/streams/pipeline.js"";
import { promisify } from ""./internal/util.js"";
import { Stream } from ""./internal/streams/legacy.js"";
import compose from ""./internal/streams/compose.js"";
import Duplex from ""./internal/streams/duplex.js"";
import eos from ""./internal/streams/end-of-stream.js"";
import PassThrough from ""./internal/streams/passthrough.js"";
import promises from ""./stream/promises.js"";
import Readable from ""./internal/streams/readable.js"";
import Transform from ""./internal/streams/transform.js"";
import Writable from ""./internal/streams/writable.js"";
import { Buffer } from ""buffer"";

const { custom: customPromisify } = promisify;

function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(
        chunk.buffer,
        chunk.byteOffset,
        chunk.byteLength,
    );
}

Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;

Object.defineProperty(Stream, ""promises"", {
    configurable: true,
    enumerable: true,
    get() {
        return promises;
    },
});

Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get() {
        return promises.pipeline;
    },
});

Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get() {
        return promises.finished;
    },
});

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;

export default Stream;
export {
    _uint8ArrayToBuffer,
    addAbortSignal,
    compose,
    destroyer as destroy,
    Duplex,
    eos as finished,
    isDisturbed,
    isUint8Array as _isUint8Array,
    PassThrough,
    pipeline,
    Readable,
    Stream,
    Transform,
    Writable,
};"
test/fs/test-fs-read-file-sync.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

const fn = fixtures.path('elipses.txt');

const s = fs.readFileSync(fn, 'utf8');
for (let i = 0; i < s.length; i++) {
  assert.strictEqual(s[i], '\u2026');
}
assert.strictEqual(s.length, 10000);
"
test/fs/test-fs-read-stream-file-handle.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'read_stream_filehandle_test.txt');
const input = 'hello world';

tmpdir.refresh();
fs.writeFileSync(file, input);

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });

  let output = '';
  stream.on('data', common.mustCallAtLeast((data) => {
    output += data;
  }));

  stream.on('end', common.mustCall(() => {
    assert.strictEqual(output, input);
  }));

  stream.on('close', common.mustCall());
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });
  stream.on('data', common.mustNotCall());
  stream.on('close', common.mustCall());

  return handle.close();
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });
  stream.on('close', common.mustCall());

  stream.on('data', common.mustCall(() => {
    handle.close();
  }));
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });
  stream.on('close', common.mustCall());

  stream.close();
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  assert.throws(() => {
    fs.createReadStream(null, { fd: handle, fs });
  }, {
    code: 'ERR_METHOD_NOT_IMPLEMENTED',
    name: 'Error',
    message: 'The FileHandle with fs method is not implemented'
  });
  return handle.close();
}).then(common.mustCall());

fs.promises.open(file, 'r').then((handle) => {
  const { read: originalReadFunction } = handle;
  handle.read = common.mustCallAtLeast(function read() {
    return Reflect.apply(originalReadFunction, this, arguments);
  });

  const stream = fs.createReadStream(null, { fd: handle });

  let output = '';
  stream.on('data', common.mustCallAtLeast((data) => {
    output += data;
  }));

  stream.on('end', common.mustCall(() => {
    assert.strictEqual(output, input);
  }));
}).then(common.mustCall());
"
test/fs/test-fs-readv-sync.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = 'mlaut.       ';

const exptectedBuff = Buffer.from(expected);
const expectedLength = exptectedBuff.length;

const filename = path.join(tmpdir.path, 'readv_sync.txt');
fs.writeFileSync(filename, exptectedBuff);

const allocateEmptyBuffers = (combinedLength) => {
  const bufferArr = [];
  // Allocate two buffers, each half the size of exptectedBuff
  bufferArr[0] = Buffer.alloc(Math.floor(combinedLength / 2));
  bufferArr[1] = Buffer.alloc(combinedLength - bufferArr[0].length);

  return bufferArr;
};

// fs.readvSync with array of buffers with all parameters
{
  const fd = fs.openSync(filename, 'r');

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);

  let read = fs.readvSync(fd, [Buffer.from('')], 0);
  assert.strictEqual(read, 0);

  read = fs.readvSync(fd, bufferArr, 0);
  assert.strictEqual(read, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

// fs.readvSync with array of buffers without position
{
  const fd = fs.openSync(filename, 'r');

  const bufferArr = allocateEmptyBuffers(exptectedBuff.length);

  let read = fs.readvSync(fd, [Buffer.from('')]);
  assert.strictEqual(read, 0);

  read = fs.readvSync(fd, bufferArr);
  assert.strictEqual(read, expectedLength);

  fs.closeSync(fd);

  assert(Buffer.concat(bufferArr).equals(fs.readFileSync(filename)));
}

/**
 * Testing with incorrect arguments
 */
const wrongInputs = [false, 'test', {}, [{}], ['sdf'], null, undefined];

{
  const fd = fs.openSync(filename, 'r');

  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readvSync(fd, wrongInput, null), {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });

  fs.closeSync(fd);
}

{
  // fs.readv with wrong fd argument
  wrongInputs.forEach((wrongInput) => {
    assert.throws(
      () => fs.readvSync(wrongInput),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError'
      }
    );
  });
}
"
test/fs/test-fs-mkdir-recursive-eaccess.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Test that mkdir with recursive option returns appropriate error
// when executed on folder it does not have permission to access.
// Ref: https://github.com/nodejs/node/issues/31481

import common from '../common';
import process from 'process';

if (!common.isWindows && process.getuid() === 0)
  common.skip('as this test should not be run as `root`');

if (common.isIBMi)
  common.skip('IBMi has a different access permission mechanism');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

import assert from 'assert';
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

let n = 0;

function makeDirectoryReadOnly(dir) {
  let accessErrorCode = 'EACCES';
  if (common.isWindows) {
    accessErrorCode = 'EPERM';
    execSync(`icacls ${dir} /deny ""everyone:(OI)(CI)(DE,DC,AD,WD)""`);
  } else {
    fs.chmodSync(dir, '444');
  }
  return accessErrorCode;
}

function makeDirectoryWritable(dir) {
  if (common.isWindows) {
    execSync(`icacls ${dir} /remove:d ""everyone""`);
  }
}

// Synchronous API should return an EACCESS error with path populated.
{
  const dir = path.join(tmpdir.path, `mkdirp_${n++}`);
  fs.mkdirSync(dir);
  const codeExpected = makeDirectoryReadOnly(dir);
  let err = null;
  try {
    fs.mkdirSync(path.join(dir, '/foo'), { recursive: true });
  } catch (_err) {
    err = _err;
  }
  makeDirectoryWritable(dir);
  assert(err);
  assert.strictEqual(err.code, codeExpected);
  assert(err.path);
}

// Asynchronous API should return an EACCESS error with path populated.
{
  const dir = path.join(tmpdir.path, `mkdirp_${n++}`);
  fs.mkdirSync(dir);
  const codeExpected = makeDirectoryReadOnly(dir);
  fs.mkdir(path.join(dir, '/bar'), { recursive: true }, (err) => {
    makeDirectoryWritable(dir);
    assert(err);
    assert.strictEqual(err.code, codeExpected);
    assert(err.path);
  });
}
"
test/fs/test-fs-read-stream-pos.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Refs: https://github.com/nodejs/node/issues/33940

import common from '../common';
import tmpdir from '../common/tmpdir';
import fs from 'fs';
import assert from 'assert';
import path from 'path';

tmpdir.refresh();

const file = path.join(tmpdir.path, '/read_stream_pos_test.txt');

fs.writeFileSync(file, '');

let counter = 0;

const writeInterval = setInterval(() => {
  counter = counter + 1;
  const line = `hello at ${counter}\n`;
  fs.writeFileSync(file, line, { flag: 'a' });
}, 1);

const hwm = 10;
let bufs = [];
let isLow = false;
let cur = 0;
let stream;

const readInterval = setInterval(() => {
  if (stream) return;

  stream = fs.createReadStream(file, {
    highWaterMark: hwm,
    start: cur
  });
  stream.on('data', common.mustCallAtLeast((chunk) => {
    cur += chunk.length;
    bufs.push(chunk);
    if (isLow) {
      const brokenLines = Buffer.concat(bufs).toString()
        .split('\n')
        .filter((line) => {
          const s = 'hello at'.slice(0, line.length);
          if (line && !line.startsWith(s)) {
            return true;
          }
          return false;
        });
      assert.strictEqual(brokenLines.length, 0);
      exitTest();
      return;
    }
    if (chunk.length !== hwm) {
      isLow = true;
    }
  }));
  stream.on('end', () => {
    stream = null;
    isLow = false;
    bufs = [];
  });
}, 10);

// Time longer than 90 seconds to exit safely
const endTimer = setTimeout(() => {
  exitTest();
}, 90000);

const exitTest = () => {
  clearInterval(readInterval);
  clearInterval(writeInterval);
  clearTimeout(endTimer);
  if (stream && !stream.destroyed) {
    stream.on('close', () => {
      process.exit();
    });
    stream.destroy();
  } else {
    process.exit();
  }
};
"
test/crypto/test-crypto-psychic-signatures.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');

const crypto = require('crypto');

// Tests for CVE-2022-21449
// https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/
// Dubbed ""Psychic Signatures"", these signatures bypassed the ECDSA signature
// verification implementation in Java in 15, 16, 17, and 18. OpenSSL is not
// (and was not) vulnerable so these are a precaution.

const vectors = {
  'ieee-p1363': [
    Buffer.from('0000000000000000000000000000000000000000000000000000000000000000' +
      '0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
    Buffer.from('ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551' +
      'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551', 'hex'),
  ],
  'der': [
    Buffer.from('3046022100' +
      '0000000000000000000000000000000000000000000000000000000000000000' +
      '022100' +
      '0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
    Buffer.from('3046022100' +
      'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551' +
      '022100' +
      'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551', 'hex'),
  ],
};

const keyPair = crypto.generateKeyPairSync('ec', {
  namedCurve: 'P-256',
  publicKeyEncoding: {
    format: 'der',
    type: 'spki'
  },
});

const data = Buffer.from('Hello!');

for (const [encoding, signatures] of Object.entries(vectors)) {
  for (const signature of signatures) {
    const key = {
      key: keyPair.publicKey,
      format: 'der',
      type: 'spki',
      dsaEncoding: encoding,
    };

    // one-shot sync
    assert.strictEqual(
      crypto.verify(
        'sha256',
        data,
        key,
        signature,
      ),
      false,
    );

    // one-shot async
    crypto.verify(
      'sha256',
      data,
      key,
      signature,
      common.mustSucceed((verified) => assert.strictEqual(verified, false)),
    );

    // stream
    assert.strictEqual(
      crypto.createVerify('sha256')
        .update(data)
        .verify(key, signature),
      false,
    );

    // webcrypto
    crypto.webcrypto.subtle.importKey(
      'spki',
      keyPair.publicKey,
      { name: 'ECDSA', namedCurve: 'P-256' },
      false,
      ['verify'],
    ).then((publicKey) => {
      return crypto.webcrypto.subtle.verify(
        { name: 'ECDSA', hash: 'SHA-256' },
        publicKey,
        signature,
        data,
      );
    }).then(common.mustCall((verified) => {
      assert.strictEqual(verified, false);
    }));
  }
}
"
test/fs/test-fs-lchmod.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
const { promises } = fs;
const f = __filename;

// This test ensures that input for lchmod is valid, testing for valid
// inputs for path, mode and callback

if (!common.isOSX) {
  common.skip('lchmod is only available on macOS');
}

// Check callback
assert.throws(() => fs.lchmod(f), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.lchmod(), { code: 'ERR_INVALID_ARG_TYPE' });
assert.throws(() => fs.lchmod(f, {}), { code: 'ERR_INVALID_ARG_TYPE' });

// Check path
[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.lchmod(i, 0o777, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.lchmodSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

// Check mode
[false, null, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
  };

  assert.rejects(promises.lchmod(f, input, () => {}), errObj);
  assert.throws(() => fs.lchmodSync(f, input), errObj);
});

assert.throws(() => fs.lchmod(f, '123x', common.mustNotCall()), {
  code: 'ERR_INVALID_ARG_VALUE'
});
assert.throws(() => fs.lchmodSync(f, '123x'), {
  code: 'ERR_INVALID_ARG_VALUE'
});

[-1, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""mode"" is out of range. It must be >= 0 && <= ' +
             `4294967295. Received ${input}`
  };

  assert.rejects(promises.lchmod(f, input, () => {}), errObj);
  assert.throws(() => fs.lchmodSync(f, input), errObj);
});
"
examples/host_function/wasmedge_c/demo_wasmedge.c,"#include <stdio.h>
#include ""wasmedge/wasmedge.h""

WasmEdge_Result HostInc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  printf(""Runtime(c)=> host_inc call : %d\n"",Val1 + 1);
  Out[0] = WasmEdge_ValueGenI32(Val1 + 1);
  return WasmEdge_Result_Success;
}

// mapping dirs
const char* dirs = "".:..\0"";

int main(int Argc, const char* Argv[]) {
	/* Create the configure context and add the WASI support. */
	/* This step is not necessary unless you need WASI support. */
	WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
	WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
	/* The configure and store context to the VM creation can be NULL. */
	WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
	WasmEdge_ImportObjectContext *WasiObject = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
    WasmEdge_ImportObjectInitWASI(WasiObject,Argv+1,Argc-1,NULL,0, &dirs,1);


    /* Create the import object. */
    WasmEdge_String ExportName = WasmEdge_StringCreateByCString(""extern"");
    WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
    enum WasmEdge_ValType ParamList[1] = { WasmEdge_ValType_I32 };
    enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
    WasmEdge_FunctionTypeContext *FuncType = WasmEdge_FunctionTypeCreate(ParamList, 1, ReturnList, 1);
    WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(FuncType, HostInc, NULL, 0);
    WasmEdge_FunctionTypeDelete(FuncType);
    WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(""host_inc"");
    WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);
    WasmEdge_StringDelete(HostFuncName);

    WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);


	/* The parameters and returns arrays. */
	WasmEdge_Value Params[0];
	WasmEdge_Value Returns[0];
	/* Function name. */
	WasmEdge_String FuncName = WasmEdge_StringCreateByCString(""_start"");
	/* Run the WASM function from file. */
	WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 0, Returns, 0);

	if (WasmEdge_ResultOK(Res)) {
		printf(""\nRuntime(c)=> OK\n"");
	} else {
		printf(""\nRuntime(c)=> Error message: %s\n"", WasmEdge_ResultGetMessage(Res));
	}

	/* Resources deallocations. */
	WasmEdge_VMDelete(VMCxt);
	WasmEdge_ConfigureDelete(ConfCxt);
	WasmEdge_StringDelete(FuncName);
	return 0;
}"
test/fs/test-fs-promises-file-handle-aggregate-errors.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
// Flags: --expose-internals

import common from '../common';
import tmpdir from '../common/tmpdir';

// The following tests validate aggregate errors are thrown correctly
// when both an operation and close throw.

import path from 'path';
import {
  readFile,
  writeFile,
  truncate,
  lchmod,
} from 'fs/promises';
import {
  FileHandle,
} from 'fs';

import assert from 'assert';
const originalFd = Object.getOwnPropertyDescriptor(FileHandle.prototype, 'fd');

let count = 0;
async function createFile() {
  const filePath = path.join(tmpdir.path, `aggregate_errors_${++count}.txt`);
  await writeFile(filePath, 'content');
  return filePath;
}

async function checkAggregateError(op) {
  try {
    const filePath = await createFile();
    Object.defineProperty(FileHandle.prototype, 'fd', {
      get: function() {
        // Close is set by using a setter,
        // so it needs to be set on the instance.
        const originalClose = this.close;
        this.close = async () => {
          // close the file
          await originalClose.call(this);
          const closeError = new Error('CLOSE_ERROR');
          closeError.code = 456;
          throw closeError;
        };
        const opError = new Error('INTERNAL_ERROR');
        opError.code = 123;
        throw opError;
      }
    });

    await assert.rejects(op(filePath), common.mustCall((err) => {
      assert.strictEqual(err.name, 'AggregateError');
      assert.strictEqual(err.code, 123);
      assert.strictEqual(err.errors.length, 2);
      assert.strictEqual(err.errors[0].message, 'INTERNAL_ERROR');
      assert.strictEqual(err.errors[1].message, 'CLOSE_ERROR');
      return true;
    }));
  } finally {
    Object.defineProperty(FileHandle.prototype, 'fd', originalFd);
  }
}
(async function() {
  tmpdir.refresh();
  await checkAggregateError((filePath) => truncate(filePath));
  await checkAggregateError((filePath) => readFile(filePath));
  await checkAggregateError((filePath) => writeFile(filePath, '123'));
  if (common.isOSX) {
    await checkAggregateError((filePath) => lchmod(filePath, 0o777));
  }
})().then(common.mustCall());
"
test/crypto/test-crypto-secure-heap.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

if (common.isWindows)
  common.skip('Not supported on Windows');

if (process.config.variables.asan)
  common.skip('ASAN does not play well with secure heap allocations');

const assert = require('assert');
const { fork } = require('child_process');
const fixtures = require('../common/fixtures');
const {
  secureHeapUsed,
  createDiffieHellman,
} = require('crypto');

if (process.argv[2] === 'child') {

  const a = secureHeapUsed();

  assert(a);
  assert.strictEqual(typeof a, 'object');
  assert.strictEqual(a.total, 65536);
  assert.strictEqual(a.min, 4);
  assert.strictEqual(a.used, 0);

  {
    const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
    const dh1 = createDiffieHellman(size);
    const p1 = dh1.getPrime('buffer');
    const dh2 = createDiffieHellman(p1, 'buffer');
    const key1 = dh1.generateKeys();
    const key2 = dh2.generateKeys('hex');
    dh1.computeSecret(key2, 'hex', 'base64');
    dh2.computeSecret(key1, 'latin1', 'buffer');

    const b = secureHeapUsed();
    assert(b);
    assert.strictEqual(typeof b, 'object');
    assert.strictEqual(b.total, 65536);
    assert.strictEqual(b.min, 4);
    // The amount used can vary on a number of factors
    assert(b.used > 0);
    assert(b.utilization > 0.0);
  }

  return;
}

const child = fork(
  process.argv[1],
  ['child'],
  { execArgv: ['--secure-heap=65536', '--secure-heap-min=4'] });

child.on('exit', common.mustCall((code) => {
  assert.strictEqual(code, 0);
}));

{
  const child = fork(fixtures.path('a.js'), {
    execArgv: ['--secure-heap=3', '--secure-heap-min=3'],
    stdio: 'pipe'
  });
  let res = '';
  child.on('exit', common.mustCall((code) => {
    assert.notStrictEqual(code, 0);
    assert.match(res, /--secure-heap must be a power of 2/);
    assert.match(res, /--secure-heap-min must be a power of 2/);
  }));
  child.stderr.setEncoding('utf8');
  child.stderr.on('data', (chunk) => res += chunk);
}
"
test/common/tmpdir.js,"use strict';

import { rmSync as _rmSync, realpathSync, mkdirSync, readdirSync } from 'fs';
import { resolve, join } from 'path';
const isMainThread = undefined;

function rmSync(pathname) {
  _rmSync(pathname, { maxRetries: 3, recursive: true, force: true });
}

import process from 'process';

const testRoot = process.env.NODE_TEST_DIR ?
  realpathSync(process.env.NODE_TEST_DIR) : resolve(__dirname, '..');

// Using a `.` prefixed name, which is the convention for ""hidden"" on POSIX,
// gets tools to ignore it by default or by simple rules, especially eslint.
const tmpdirName = '.tmp.' +
  (process.env.TEST_SERIAL_ID || process.env.TEST_THREAD_ID || '0');
const tmpPath = join(testRoot, tmpdirName);

let firstRefresh = true;
function refresh() {
  rmSync(tmpPath);
  mkdirSync(tmpPath);

  if (firstRefresh) {
    firstRefresh = false;
    // Clean only when a test uses refresh. This allows for child processes to
    // use the tmpdir and only the parent will clean on exit.
    process.on('exit', onexit);
  }
}

function onexit() {
  // Change directory to avoid possible EBUSY
  if (isMainThread)
    process.chdir(testRoot);

  try {
    rmSync(tmpPath);
  } catch (e) {
    console.error('Can\'t clean tmpdir:', tmpPath);

    const files = readdirSync(tmpPath);
    console.error('Files blocking:', files);

    if (files.some((f) => f.startsWith('.nfs'))) {
      // Warn about NFS ""silly rename""
      console.error('Note: "".nfs*"" might be files that were open and ' +
                    'unlinked but not closed.');
      console.error('See http://nfs.sourceforge.net/#faq_d2 for details.');
    }

    console.error();
    throw e;
  }
}

export default {
  path: tmpPath,
  refresh
};
"
test/fixtures/cycles/root.js,"// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const foo = exports.foo = require('./folder/foo');

exports.hello = 'hello';
exports.sayHello = function() {
  return foo.hello();
};
exports.calledFromFoo = function() {
  return exports.hello;
};
"
example_js/create-react-app-ssr/public/index.html,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""utf-8"" />
    <link rel=""icon"" href=""%PUBLIC_URL%/favicon.ico"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1"" />
    <meta name=""theme-color"" content=""#000000"" />
    <meta
      name=""description""
      content=""Web site created using create-react-app""
    />
    <link rel=""apple-touch-icon"" href=""%PUBLIC_URL%/logo192.png"" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel=""manifest"" href=""%PUBLIC_URL%/manifest.json"" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike ""/favicon.ico"" or ""favicon.ico"", ""%PUBLIC_URL%/favicon.ico"" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id=""root""></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
"
test/fs/test-fs-readv-promises.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs/promises';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

const expected = 'mlaut.       ';
const exptectedBuff = Buffer.from(expected);

let cnt = 0;
function getFileName() {
  return path.join(tmpdir.path, `readv_promises_${++cnt}.txt`);
}

const allocateEmptyBuffers = (combinedLength) => {
  const bufferArr = [];
  // Allocate two buffers, each half the size of exptectedBuff
  bufferArr[0] = Buffer.alloc(Math.floor(combinedLength / 2));
  bufferArr[1] = Buffer.alloc(combinedLength - bufferArr[0].length);

  return bufferArr;
};

(async () => {
  {
    const filename = getFileName();
    await fs.writeFile(filename, exptectedBuff);
    const handle = await fs.open(filename, 'r');
    // const buffer = Buffer.from(expected);
    const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
    const expectedLength = exptectedBuff.length;

    let { bytesRead, buffers } = await handle.readv([Buffer.from('')],
                                                    null);
    assert.strictEqual(bytesRead, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);

    ({ bytesRead, buffers } = await handle.readv(bufferArr, null));
    assert.strictEqual(bytesRead, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }

  {
    const filename = getFileName();
    await fs.writeFile(filename, exptectedBuff);
    const handle = await fs.open(filename, 'r');
    // const buffer = Buffer.from(expected);
    const bufferArr = allocateEmptyBuffers(exptectedBuff.length);
    const expectedLength = exptectedBuff.length;

    let { bytesRead, buffers } = await handle.readv([Buffer.from('')]);
    assert.strictEqual(bytesRead, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);

    ({ bytesRead, buffers } = await handle.readv(bufferArr));
    assert.strictEqual(bytesRead, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }
})().then(common.mustCall());
"
test/fs/test-fs-fchown.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';

function testFd(input, errObj) {
  assert.throws(() => fs.fchown(input), errObj);
  assert.throws(() => fs.fchownSync(input), errObj);
}

function testUid(input, errObj) {
  assert.throws(() => fs.fchown(1, input), errObj);
  assert.throws(() => fs.fchownSync(1, input), errObj);
}

function testGid(input, errObj) {
  assert.throws(() => fs.fchown(1, 1, input), errObj);
  assert.throws(() => fs.fchownSync(1, 1, input), errObj);
}

['', false, null, undefined, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: /fd|uid|gid/
  };
  testFd(input, errObj);
  testUid(input, errObj);
  testGid(input, errObj);
});

[Infinity, NaN].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be an integer. ' +
             `Received ${input}`
  };
  testFd(input, errObj);
  errObj.message = errObj.message.replace('fd', 'uid');
  testUid(input, errObj);
  errObj.message = errObj.message.replace('uid', 'gid');
  testGid(input, errObj);
});

[-2, 2 ** 32].forEach((input) => {
  const errObj = {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""fd"" is out of range. It must be ' +
             `>= 0 && <= 2147483647. Received ${input}`
  };
  testFd(input, errObj);
  errObj.message = 'The value of ""uid"" is out of range. It must be >= -1 && ' +
    `<= 4294967295. Received ${input}`;
  testUid(input, errObj);
  errObj.message = errObj.message.replace('uid', 'gid');
  testGid(input, errObj);
});
"
test/fs/test-fs-lchown.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
const { promises } = fs;

// Validate the path argument.
[false, 1, {}, [], null, undefined].forEach((i) => {
  const err = { name: 'TypeError', code: 'ERR_INVALID_ARG_TYPE' };

  assert.throws(() => fs.lchown(i, 1, 1, common.mustNotCall()), err);
  assert.throws(() => fs.lchownSync(i, 1, 1), err);
  promises.lchown(false, 1, 1)
    .then(common.mustNotCall())
    .catch(common.expectsError(err));
});

// Validate the uid and gid arguments.
[false, 'test', {}, [], null, undefined].forEach((i) => {
  const err = { name: 'TypeError', code: 'ERR_INVALID_ARG_TYPE' };

  assert.throws(
    () => fs.lchown('not_a_file_that_exists', i, 1, common.mustNotCall()),
    err
  );
  assert.throws(
    () => fs.lchown('not_a_file_that_exists', 1, i, common.mustNotCall()),
    err
  );
  assert.throws(() => fs.lchownSync('not_a_file_that_exists', i, 1), err);
  assert.throws(() => fs.lchownSync('not_a_file_that_exists', 1, i), err);

  promises.lchown('not_a_file_that_exists', i, 1)
    .then(common.mustNotCall())
    .catch(common.expectsError(err));

  promises.lchown('not_a_file_that_exists', 1, i)
    .then(common.mustNotCall())
    .catch(common.expectsError(err));
});

// Validate the callback argument.
[false, 1, 'test', {}, [], null, undefined].forEach((i) => {
  assert.throws(() => fs.lchown('not_a_file_that_exists', 1, 1, i), {
    name: 'TypeError',
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

if (!common.isWindows) {
  const testFile = path.join(tmpdir.path, path.basename(__filename));
  const uid = process.geteuid();
  const gid = process.getegid();

  tmpdir.refresh();
  fs.copyFileSync(__filename, testFile);
  fs.lchownSync(testFile, uid, gid);
  fs.lchown(testFile, uid, gid, common.mustSucceed(async (err) => {
    await promises.lchown(testFile, uid, gid);
  }));
}
"
test/path/test-path-relative.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

const failures = [];

const relativeTests = [
  /*[ path.win32.relative,
    // Arguments                     result
    [['c:/blah\\blah', 'd:/games', 'd:\\games'],
     ['c:/aaaa/bbbb', 'c:/aaaa', '..'],
     ['c:/aaaa/bbbb', 'c:/cccc', '..\\..\\cccc'],
     ['c:/aaaa/bbbb', 'c:/aaaa/bbbb', ''],
     ['c:/aaaa/bbbb', 'c:/aaaa/cccc', '..\\cccc'],
     ['c:/aaaa/', 'c:/aaaa/cccc', 'cccc'],
     ['c:/', 'c:\\aaaa\\bbbb', 'aaaa\\bbbb'],
     ['c:/aaaa/bbbb', 'd:\\', 'd:\\'],
     ['c:/AaAa/bbbb', 'c:/aaaa/bbbb', ''],
     ['c:/aaaaa/', 'c:/aaaa/cccc', '..\\aaaa\\cccc'],
     ['C:\\foo\\bar\\baz\\quux', 'C:\\', '..\\..\\..\\..'],
     ['C:\\foo\\test', 'C:\\foo\\test\\bar\\package.json', 'bar\\package.json'],
     ['C:\\foo\\bar\\baz-quux', 'C:\\foo\\bar\\baz', '..\\baz'],
     ['C:\\foo\\bar\\baz', 'C:\\foo\\bar\\baz-quux', '..\\baz-quux'],
     ['\\\\foo\\bar', '\\\\foo\\bar\\baz', 'baz'],
     ['\\\\foo\\bar\\baz', '\\\\foo\\bar', '..'],
     ['\\\\foo\\bar\\baz-quux', '\\\\foo\\bar\\baz', '..\\baz'],
     ['\\\\foo\\bar\\baz', '\\\\foo\\bar\\baz-quux', '..\\baz-quux'],
     ['C:\\baz-quux', 'C:\\baz', '..\\baz'],
     ['C:\\baz', 'C:\\baz-quux', '..\\baz-quux'],
     ['\\\\foo\\baz-quux', '\\\\foo\\baz', '..\\baz'],
     ['\\\\foo\\baz', '\\\\foo\\baz-quux', '..\\baz-quux'],
     ['C:\\baz', '\\\\foo\\bar\\baz', '\\\\foo\\bar\\baz'],
     ['\\\\foo\\bar\\baz', 'C:\\baz', 'C:\\baz'],
    ],
  ],*/
  [ path.posix.relative,
    // Arguments          result
    [['/var/lib', '/var', '..'],
     ['/var/lib', '/bin', '../../bin'],
     ['/var/lib', '/var/lib', ''],
     ['/var/lib', '/var/apache', '../apache'],
     ['/var/', '/var/lib', 'lib'],
     ['/', '/var/lib', 'var/lib'],
     ['/foo/test', '/foo/test/bar/package.json', 'bar/package.json'],
     ['/Users/a/web/b/test/mails', '/Users/a/web/b', '../..'],
     ['/foo/bar/baz-quux', '/foo/bar/baz', '../baz'],
     ['/foo/bar/baz', '/foo/bar/baz-quux', '../baz-quux'],
     ['/baz-quux', '/baz', '../baz'],
     ['/baz', '/baz-quux', '../baz-quux'],
     ['/page1/page2/foo', '/', '../../..'],
    ],
  ],
];
relativeTests.forEach((test) => {
  const relative = test[0];
  test[1].forEach((test) => {
    const actual = relative(test[0], test[1]);
    const expected = test[2];
    if (actual !== expected) {
      const os = /*relative === path.win32.relative ? 'win32' : */'posix';
      const message = `path.${os}.relative(${
        test.slice(0, 2).map(JSON.stringify).join(',')})\n  expect=${
        JSON.stringify(expected)}\n  actual=${JSON.stringify(actual)}`;
      failures.push(`\n${message}`);
    }
  });
});
assert.strictEqual(failures.length, 0, failures.join(''));
"
test/fs/test-fs-writev-promises.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs/promises';
import tmpdir from '../common/tmpdir';
const expected = 'mlaut.       ';
let cnt = 0;

function getFileName() {
  return path.join(tmpdir.path, `writev_promises_${++cnt}.txt`);
}

tmpdir.refresh();

(async () => {
  {
    const filename = getFileName();
    const handle = await fs.open(filename, 'w');
    const buffer = Buffer.from(expected);
    const bufferArr = [buffer, buffer];
    const expectedLength = bufferArr.length * buffer.byteLength;
    let { bytesWritten, buffers } = await handle.writev([Buffer.from('')],
                                                        null);
    assert.strictEqual(bytesWritten, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);
    ({ bytesWritten, buffers } = await handle.writev(bufferArr, null));
    assert.deepStrictEqual(bytesWritten, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }

  // fs.promises.writev() with an array of buffers without position.
  {
    const filename = getFileName();
    const handle = await fs.open(filename, 'w');
    const buffer = Buffer.from(expected);
    const bufferArr = [buffer, buffer, buffer];
    const expectedLength = bufferArr.length * buffer.byteLength;
    let { bytesWritten, buffers } = await handle.writev([Buffer.from('')]);
    assert.strictEqual(bytesWritten, 0);
    assert.deepStrictEqual(buffers, [Buffer.from('')]);
    ({ bytesWritten, buffers } = await handle.writev(bufferArr));
    assert.deepStrictEqual(bytesWritten, expectedLength);
    assert.deepStrictEqual(buffers, bufferArr);
    assert(Buffer.concat(bufferArr).equals(await fs.readFile(filename)));
    handle.close();
  }

  {
    // Writev with empty array behavior
    const handle = await fs.open(getFileName(), 'w');
    const result = await handle.writev([]);
    assert.strictEqual(result.bytesWritten, 0);
    assert.strictEqual(result.buffers.length, 0);
    handle.close();
  }
})().then(common.mustCall());
"
test/crypto/test-crypto-getcipherinfo.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const {
  getCiphers,
  getCipherInfo
} = require('crypto');

const assert = require('assert');

const ciphers = getCiphers();

assert.strictEqual(getCipherInfo(-1), undefined);
assert.strictEqual(getCipherInfo('cipher that does not exist'), undefined);

ciphers.forEach((cipher) => {
  const info = getCipherInfo(cipher);
  assert(info);
  const info2 = getCipherInfo(info.nid);
  assert.deepStrictEqual(info, info2);
});

const info = getCipherInfo('aes-128-cbc');
assert.strictEqual(info.name, 'aes-128-cbc');
assert.strictEqual(info.nid, 419);
assert.strictEqual(info.blockSize, 16);
assert.strictEqual(info.ivLength, 16);
assert.strictEqual(info.keyLength, 16);
assert.strictEqual(info.mode, 'cbc');

[null, undefined, [], {}].forEach((arg) => {
  assert.throws(() => getCipherInfo(arg), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
});

[null, '', 1, true].forEach((options) => {
  assert.throws(
    () => getCipherInfo('aes-192-cbc', options), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
});

[null, '', {}, [], true].forEach((len) => {
  assert.throws(
    () => getCipherInfo('aes-192-cbc', { keyLength: len }), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
  assert.throws(
    () => getCipherInfo('aes-192-cbc', { ivLength: len }), {
      code: 'ERR_INVALID_ARG_TYPE'
    });
});

assert(!getCipherInfo('aes-128-cbc', { keyLength: 12 }));
assert(getCipherInfo('aes-128-cbc', { keyLength: 16 }));
assert(!getCipherInfo('aes-128-cbc', { ivLength: 12 }));
assert(getCipherInfo('aes-128-cbc', { ivLength: 16 }));

assert(!getCipherInfo('aes-128-ccm', { ivLength: 1 }));
assert(!getCipherInfo('aes-128-ccm', { ivLength: 14 }));
for (let n = 7; n <= 13; n++)
  assert(getCipherInfo('aes-128-ccm', { ivLength: n }));

assert(!getCipherInfo('aes-128-ocb', { ivLength: 16 }));
for (let n = 1; n < 16; n++)
  assert(getCipherInfo('aes-128-ocb', { ivLength: n }));
"
test/fs/test-fs-promises-file-handle-close-errors.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
// Flags: --expose-internals

import common from '../common';
import tmpdir from '../common/tmpdir';

// The following tests validate aggregate errors are thrown correctly
// when both an operation and close throw.

import path from 'path';
import {
  readFile,
  writeFile,
  truncate,
  lchmod,
} from 'fs/promises';

import { FileHandle } from 'fs';

import assert from 'assert';
const originalFd = Object.getOwnPropertyDescriptor(FileHandle.prototype, 'fd');

let count = 0;
async function createFile() {
  const filePath = path.join(tmpdir.path, `close_errors_${++count}.txt`);
  await writeFile(filePath, 'content');
  return filePath;
}

async function checkCloseError(op) {
  try {
    const filePath = await createFile();
    Object.defineProperty(FileHandle.prototype, 'fd', {
      get: function() {
        // Close is set by using a setter,
        // so it needs to be set on the instance.
        const originalClose = this.close;
        this.close = async () => {
          // close the file
          await originalClose.call(this);
          const closeError = new Error('CLOSE_ERROR');
          closeError.code = 456;
          throw closeError;
        };
        return originalFd.get.call(this);
      }
    });

    await assert.rejects(op(filePath), {
      name: 'Error',
      message: 'CLOSE_ERROR',
      code: 456,
    });
  } finally {
    Object.defineProperty(FileHandle.prototype, 'fd', originalFd);
  }
}
(async function() {
  tmpdir.refresh();
  await checkCloseError((filePath) => truncate(filePath));
  await checkCloseError((filePath) => readFile(filePath));
  await checkCloseError((filePath) => writeFile(filePath, '123'));
  if (common.isOSX) {
    await checkCloseError((filePath) => lchmod(filePath, 0o777));
  }
})().then(common.mustCall());
"
test/path/test-path-basename.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

const __filename = args[0];

assert.strictEqual(path.basename(__filename), 'test-path-basename.js');
assert.strictEqual(path.basename(__filename, '.js'), 'test-path-basename');
assert.strictEqual(path.basename('.js', '.js'), '');
assert.strictEqual(path.basename(''), '');
assert.strictEqual(path.basename('/dir/basename.ext'), 'basename.ext');
assert.strictEqual(path.basename('/basename.ext'), 'basename.ext');
assert.strictEqual(path.basename('basename.ext'), 'basename.ext');
assert.strictEqual(path.basename('basename.ext/'), 'basename.ext');
assert.strictEqual(path.basename('basename.ext//'), 'basename.ext');
assert.strictEqual(path.basename('aaa/bbb', '/bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb', 'a/bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb', 'bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb//', 'bbb'), 'bbb');
assert.strictEqual(path.basename('aaa/bbb', 'bb'), 'b');
assert.strictEqual(path.basename('aaa/bbb', 'b'), 'bb');
assert.strictEqual(path.basename('/aaa/bbb', '/bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb', 'a/bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb', 'bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb//', 'bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/bbb', 'bb'), 'b');
assert.strictEqual(path.basename('/aaa/bbb', 'b'), 'bb');
assert.strictEqual(path.basename('/aaa/bbb'), 'bbb');
assert.strictEqual(path.basename('/aaa/'), 'aaa');
assert.strictEqual(path.basename('/aaa/b'), 'b');
assert.strictEqual(path.basename('/a/b'), 'b');
assert.strictEqual(path.basename('//a'), 'a');
assert.strictEqual(path.basename('a', 'a'), '');

// On Windows a backslash acts as a path separator.
/*
assert.strictEqual(path.win32.basename('\\dir\\basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('\\basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('basename.ext\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('basename.ext\\\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('foo'), 'foo');
assert.strictEqual(path.win32.basename('aaa\\bbb', '\\bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'a\\bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb\\\\\\\\', 'bbb'), 'bbb');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'bb'), 'b');
assert.strictEqual(path.win32.basename('aaa\\bbb', 'b'), 'bb');
assert.strictEqual(path.win32.basename('C:'), '');
assert.strictEqual(path.win32.basename('C:.'), '.');
assert.strictEqual(path.win32.basename('C:\\'), '');
assert.strictEqual(path.win32.basename('C:\\dir\\base.ext'), 'base.ext');
assert.strictEqual(path.win32.basename('C:\\basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:basename.ext'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:basename.ext\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:basename.ext\\\\'), 'basename.ext');
assert.strictEqual(path.win32.basename('C:foo'), 'foo');
assert.strictEqual(path.win32.basename('file:stream'), 'file:stream');
assert.strictEqual(path.win32.basename('a', 'a'), '');
*/
// On unix a backslash is just treated as any other character.
assert.strictEqual(path.posix.basename('\\dir\\basename.ext'),
                   '\\dir\\basename.ext');
assert.strictEqual(path.posix.basename('\\basename.ext'), '\\basename.ext');
assert.strictEqual(path.posix.basename('basename.ext'), 'basename.ext');
assert.strictEqual(path.posix.basename('basename.ext\\'), 'basename.ext\\');
assert.strictEqual(path.posix.basename('basename.ext\\\\'), 'basename.ext\\\\');
assert.strictEqual(path.posix.basename('foo'), 'foo');

// POSIX filenames may include control characters
// c.f. http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html
const controlCharFilename = `Icon${String.fromCharCode(13)}`;
assert.strictEqual(path.posix.basename(`/a/b/${controlCharFilename}`),
                   controlCharFilename);
"
test/fs/test-fs-read-stream-concurrent-reads.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';

// Test that concurrent file read streams dont interfere with each others
// contents, and that the chunks generated by the reads only retain a
// 'reasonable' amount of memory.

// Refs: https://github.com/nodejs/node/issues/21967

const filename = fixtures.path('loop.js');  // Some small non-homogeneous file.
const content = fs.readFileSync(filename);

const N = 2000;
let started = 0;
let done = 0;

const arrayBuffers = new Set();

function startRead() {
  ++started;
  const chunks = [];
  fs.createReadStream(filename)
    .on('data', (chunk) => {
      chunks.push(chunk);
      arrayBuffers.add(chunk.buffer);
    })
    .on('end', common.mustCall(() => {
      if (started < N)
        startRead();
      assert.deepStrictEqual(Buffer.concat(chunks), content);
      if (++done === N) {
        const retainedMemory =
          [...arrayBuffers].map((ab) => ab.byteLength).reduce((a, b) => a + b);
        assert(retainedMemory / (N * content.length) <= 3,
               `Retaining ${retainedMemory} bytes in ABs for ${N} ` +
               `chunks of size ${content.length}`);
      }
    }));
}

// Dont start the reads all at once  that way we would have to allocate
// a large amount of memory upfront.
for (let i = 0; i < 6; ++i)
  startRead();
"
example_js/react18_ssr/component/data.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import React,{createContext, useContext} from 'react';

// Note: this file does not demonstrate a real data fetching strategy.
// We only use this to simulate data fetching happening on the server
// while the cache is populated on the client. In a real app, you would
// instead use a data fetching library or Server Components for this.

const DataContext = createContext(null);

export function DataProvider({children, data}) {
  return <DataContext.Provider value={data}>{children}</DataContext.Provider>;
}

// In a real implementation the data would be streamed with the HTML.
// We haven't integrated this part yet, so we'll just use fake data.
const fakeData = [
  ""Wait, it doesn't wait for React to load?"",
  'How does this even work?',
  'I like marshmallows',
];

export function useData() {
  const ctx = useContext(DataContext);
  if (ctx !== null) {
    // This context is only provided on the server.
    // It is here to simulate a suspending data fetch.
    ctx.read();
  }
  return fakeData;
}
"
test/path/test-path-zero-length-strings.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// These testcases are specific to one uncommon behavior in path module. Few
// of the functions in path module, treat '' strings as current working
// directory. This test makes sure that the behavior is intact between commits.
// See: https://github.com/nodejs/node/pull/2106

import assert from 'assert';
import path from 'path';
const pwd = "".""; // process.cwd();

// Join will internally ignore all the zero-length strings and it will return
// '.' if the joined string is a zero-length string.
assert.strictEqual(path.posix.join(''), '.');
assert.strictEqual(path.posix.join('', ''), '.');
// assert.strictEqual(path.win32.join(''), '.');
// assert.strictEqual(path.win32.join('', ''), '.');
assert.strictEqual(path.join(pwd), pwd);
assert.strictEqual(path.join(pwd, ''), pwd);

// Normalize will return '.' if the input is a zero-length string
assert.strictEqual(path.posix.normalize(''), '.');
// assert.strictEqual(path.win32.normalize(''), '.');
assert.strictEqual(path.normalize(pwd), pwd);

// Since '' is not a valid path in any of the common environments, return false
assert.strictEqual(path.posix.isAbsolute(''), false);
// assert.strictEqual(path.win32.isAbsolute(''), false);

// Resolve, internally ignores all the zero-length strings and returns the
// current working directory
assert.strictEqual(path.resolve(''), pwd);
assert.strictEqual(path.resolve('', ''), pwd);

// Relative, internally calls resolve. So, '' is actually the current directory
assert.strictEqual(path.relative('', pwd), '');
assert.strictEqual(path.relative(pwd, ''), '');
assert.strictEqual(path.relative(pwd, pwd), '');
"
modules/stream/consumers.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import { Buffer } from ""buffer"";

/**
 * @typedef {import('../_global.d.ts').ReadableStream
 * } ReadableStream
 * @typedef {import('../_stream.d.ts')} Readable
 */


/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<ArrayBuffer>}
 */
async function arrayBuffer(stream) {
    const ret = await blob(stream);
    return ret.arrayBuffer();
}

/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<Buffer>}
 */
async function buffer(stream) {
    return Buffer.from(await arrayBuffer(stream));
}

/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<string>}
 */
async function text(stream) {
    const dec = new TextDecoder();
    let str = """";
    for await (const chunk of stream) {
        if (typeof chunk === ""string"") {
            str += chunk;
        } else {
            str += dec.decode(chunk, { stream: true });
        }
    }
    // Flush the streaming TextDecoder so that any pending
    // incomplete multibyte characters are handled.
    str += dec.decode(undefined, { stream: false });
    return str;
}

/**
 * @param {AsyncIterable|ReadableStream|Readable} stream
 * @returns {Promise<any>}
 */
async function json(stream) {
    const str = await text(stream);
    return JSON.parse(str);
}

export default {
    arrayBuffer,
    buffer,
    json,
    text,
};
export { arrayBuffer, buffer, json, text };"
test/fs/test-fs-watch-enoent.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

// This verifies the error thrown by fs.watch.

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import assert from 'assert';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
import path from 'path';
const nonexistentFile = path.join(tmpdir.path, 'non-existent');
import { internalBinding } from 'internal/test/binding';
const {
  UV_ENODEV,
  UV_ENOENT
} = internalBinding('uv');

tmpdir.refresh();

{
  const validateError = (err) => {
    assert.strictEqual(err.path, nonexistentFile);
    assert.strictEqual(err.filename, nonexistentFile);
    assert.strictEqual(err.syscall, 'watch');
    if (err.code === 'ENOENT') {
      assert.strictEqual(
        err.message,
        `ENOENT: no such file or directory, watch '${nonexistentFile}'`);
      assert.strictEqual(err.errno, UV_ENOENT);
      assert.strictEqual(err.code, 'ENOENT');
    } else {  // AIX
      assert.strictEqual(
        err.message,
        `ENODEV: no such device, watch '${nonexistentFile}'`);
      assert.strictEqual(err.errno, UV_ENODEV);
      assert.strictEqual(err.code, 'ENODEV');
    }
    return true;
  };

  assert.throws(
    () => fs.watch(nonexistentFile, common.mustNotCall()),
    validateError
  );
}

{
  const file = path.join(tmpdir.path, 'file-to-watch');
  fs.writeFileSync(file, 'test');
  const watcher = fs.watch(file, common.mustNotCall());

  const validateError = (err) => {
    assert.strictEqual(err.path, nonexistentFile);
    assert.strictEqual(err.filename, nonexistentFile);
    assert.strictEqual(
      err.message,
      `ENOENT: no such file or directory, watch '${nonexistentFile}'`);
    assert.strictEqual(err.errno, UV_ENOENT);
    assert.strictEqual(err.code, 'ENOENT');
    assert.strictEqual(err.syscall, 'watch');
    fs.unlinkSync(file);
    return true;
  };

  watcher.on('error', common.mustCall(validateError));

  // Simulate the invocation from the binding
  watcher._handle.onchange(UV_ENOENT, 'ENOENT', nonexistentFile);
}
"
test/fs/test-fs-promises-file-handle-close.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-gc --no-warnings
'use strict';

// Test that a runtime warning is emitted when a FileHandle object
// is allowed to close on garbage collection. In the future, this
// test should verify that closing on garbage collection throws a
// process fatal exception.

import common from '../common';
import assert from 'assert';
import fs from 'fs/promises';

const warning =
  'Closing a FileHandle object on garbage collection is deprecated. ' +
  'Please close FileHandle objects explicitly using ' +
  'FileHandle.prototype.close(). In the future, an error will be ' +
  'thrown if a file descriptor is closed during garbage collection.';

async function doOpen() {
  const fh = await fs.open(__filename);

  common.expectWarning({
    Warning: [[`Closing file descriptor ${fh.fd} on garbage collection`]],
    DeprecationWarning: [[warning, 'DEP0137']]
  });

  return fh;
}

doOpen().then(common.mustCall((fd) => {
  assert.strictEqual(typeof fd, 'object');
})).then(common.mustCall(() => {
  setImmediate(() => {
    // The FileHandle should be out-of-scope and no longer accessed now.
    global.gc();

    // Wait an extra event loop turn, as the warning is emitted from the
    // native layer in an unref()'ed setImmediate() callback.
    setImmediate(common.mustCall());
  });
}));
"
test/fs/test-fs-copyfile-respect-permissions.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Test that fs.copyFile() respects file permissions.
// Ref: https://github.com/nodejs/node/issues/26936

import common from '../common';

if (!common.isWindows && process.getuid() === 0)
  common.skip('as this test should not be run as `root`');

if (common.isIBMi)
  common.skip('IBMi has a different access permission mechanism');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

import assert from 'assert';
import fs from 'fs';
import path from 'path';

let n = 0;

function beforeEach() {
  n++;
  const source = path.join(tmpdir.path, `source${n}`);
  const dest = path.join(tmpdir.path, `dest${n}`);
  fs.writeFileSync(source, 'source');
  fs.writeFileSync(dest, 'dest');
  fs.chmodSync(dest, '444');

  const check = (err) => {
    const expected = ['EACCES', 'EPERM'];
    assert(expected.includes(err.code), `${err.code} not in ${expected}`);
    assert.strictEqual(fs.readFileSync(dest, 'utf8'), 'dest');
    return true;
  };

  return { source, dest, check };
}

// Test synchronous API.
{
  const { source, dest, check } = beforeEach();
  assert.throws(() => { fs.copyFileSync(source, dest); }, check);
}

// Test promises API.
{
  const { source, dest, check } = beforeEach();
  (async () => {
    await assert.rejects(fs.promises.copyFile(source, dest), check);
  })().then(common.mustCall());
}

// Test callback API.
{
  const { source, dest, check } = beforeEach();
  fs.copyFile(source, dest, common.mustCall(check));
}
"
example_js/react18_ssr/component/App.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import React,{ Suspense, lazy } from ""react"";
import { ErrorBoundary } from ""react-error-boundary"";
import Html from ""./Html.js"";
import Spinner from ""./Spinner.js"";
import Layout from ""./Layout.js"";
import NavBar from ""./NavBar.js"";

const Comments = lazy(() => import(""./Comments.js"" /* webpackPrefetch: true */));
const Sidebar = lazy(() => import(""./Sidebar.js"" /* webpackPrefetch: true */));
const Post = lazy(() => import(""./Post.js"" /* webpackPrefetch: true */));

export default function App({ assets }) {
  return (
    <Html assets={assets} title=""Hello"">
      <Suspense fallback={<Spinner />}>
        <ErrorBoundary FallbackComponent={Error}>
          <Content />
        </ErrorBoundary>
      </Suspense>
    </Html>
  );
}

function Content() {
  return (
    <Layout>
      <NavBar />
      <aside className=""sidebar"">
        <Suspense fallback={<Spinner />}>
          <Sidebar />
        </Suspense>
      </aside>
      <article className=""post"">
        <Suspense fallback={<Spinner />}>
          <Post />
        </Suspense>
        <section className=""comments"">
          <h2>Comments</h2>
          <Suspense fallback={<Spinner />}>
            <Comments />
          </Suspense>
        </section>
        <h2>Thanks for reading!</h2>
      </article>
    </Layout>
  );
}

function Error({ error }) {
  return (
    <div>
      <h1>Application Error</h1>
      <pre style={{ whiteSpace: ""pre-wrap"" }}>{error.stack}</pre>
    </div>
  );
}
"
test/fs/test-fs-options-immutable.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// These tests make sure that the `options` object passed to these functions are
// never altered.
//
// Refer: https://github.com/nodejs/node/issues/7655

import fs from 'fs';
import path from 'path';

const options = common.mustNotMutateObjectDeep({});
import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const __filename = args[0];

fs.readFile(__filename, options, common.mustSucceed());
fs.readFileSync(__filename, options);

fs.readdir(""./"", options, common.mustSucceed());
fs.readdirSync(""./"", options);

if (false /*common.canCreateSymLink()*/) {
  const sourceFile = path.resolve(tmpdir.path, 'test-readlink');
  const linkFile = path.resolve(tmpdir.path, 'test-readlink-link');

  fs.writeFileSync(sourceFile, '');
  fs.symlinkSync(sourceFile, linkFile);

  fs.readlink(linkFile, options, common.mustSucceed());
  fs.readlinkSync(linkFile, options);
}

{
  const fileName = path.resolve(tmpdir.path, 'writeFile');
  fs.writeFileSync(fileName, 'ABCD', options);
  fs.writeFile(fileName, 'ABCD', options, common.mustSucceed());
}

{
  const fileName = path.resolve(tmpdir.path, 'appendFile');
  fs.appendFileSync(fileName, 'ABCD', options);
  fs.appendFile(fileName, 'ABCD', options, common.mustSucceed());
}

/*if (!common.isIBMi) { // IBMi does not support fs.watch()
  const watch = fs.watch(__filename, options, common.mustNotCall());
  watch.close();
}*/

/*{
  fs.watchFile(__filename, options, common.mustNotCall());
  fs.unwatchFile(__filename);
}*/

/*{
  fs.realpathSync(__filename, options);
  fs.realpath(__filename, options, common.mustSucceed());
}*/

{
  const tempFileName = path.resolve(tmpdir.path, 'mkdtemp-');
  fs.mkdtempSync(tempFileName, options);
  fs.mkdtemp(tempFileName, options, common.mustSucceed());
}

{
  const fileName = path.resolve(tmpdir.path, 'streams');
  fs.WriteStream(fileName, options).once('open', common.mustCall(() => {
    fs.ReadStream(fileName, options).destroy();
  })).end();
}
"
test/fs/test-fs-promises-file-handle-op-errors.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
// Flags: --expose-internals

import common from '../common';
import tmpdir from '../common/tmpdir';

// The following tests validate aggregate errors are thrown correctly
// when both an operation and close throw.

import path from 'path';
import {
  readFile,
  writeFile,
  truncate,
  lchmod,
} from 'fs/promises';
import {
  FileHandle,
} from 'fs';

import assert from 'assert';
const originalFd = Object.getOwnPropertyDescriptor(FileHandle.prototype, 'fd');

let count = 0;
async function createFile() {
  const filePath = path.join(tmpdir.path, `op_errors_${++count}.txt`);
  await writeFile(filePath, 'content');
  return filePath;
}

async function checkOperationError(op) {
  try {
    const filePath = await createFile();
    Object.defineProperty(FileHandle.prototype, 'fd', {
      get: function() {
        // Verify that close is called when an error is thrown
        this.close = common.mustCall(this.close);
        const opError = new Error('INTERNAL_ERROR');
        opError.code = 123;
        throw opError;
      }
    });

    await assert.rejects(op(filePath), {
      name: 'Error',
      message: 'INTERNAL_ERROR',
      code: 123,
    });
  } finally {
    Object.defineProperty(FileHandle.prototype, 'fd', originalFd);
  }
}
(async function() {
  tmpdir.refresh();
  await checkOperationError((filePath) => truncate(filePath));
  await checkOperationError((filePath) => readFile(filePath));
  await checkOperationError((filePath) => writeFile(filePath, '123'));
  if (common.isOSX) {
    await checkOperationError((filePath) => lchmod(filePath, 0o777));
  }
})().then(common.mustCall());
"
test/fs/test-fs-readSync-optional-params.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import { mustNotMutateObjectDeep } from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';
const filepath = fixtures.path('x.txt');

const expected = Buffer.from('xyz\n');

function runTest(defaultBuffer, options) {
  let fd;
  try {
    fd = fs.openSync(filepath, 'r');
    const result = fs.readSync(fd, defaultBuffer, options);
    assert.strictEqual(result, expected.length);
    assert.deepStrictEqual(defaultBuffer, expected);
  } finally {
    if (fd != null) fs.closeSync(fd);
  }
}

for (const options of [

  // Test options object
  { offset: 0 },
  { length: expected.length },
  { position: 0 },
  { offset: 0, length: expected.length },
  { offset: 0, position: 0 },
  { length: expected.length, position: 0 },
  { offset: 0, length: expected.length, position: 0 },

  { offset: null },
  { position: null },
  { position: -1 },
  { position: 0n },

  // Test default params
  {},
  null,
  undefined,

  // Test if bad params are interpreted as default (not mandatory)
  false,
  true,
  Infinity,
  42n,
  Symbol(),

  // Test even more malicious corner cases
  '4'.repeat(expected.length),
  new String('4444'),
  [4, 4, 4, 4],
]) {
  runTest(Buffer.allocUnsafe(expected.length), mustNotMutateObjectDeep(options));
}
"
LICENSE-QuickJS.txt,"QuickJS Javascript Engine
 
Copyright (c) 2017-2021 Fabrice Bellard
Copyright (c) 2017-2021 Charlie Gordon

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE."
test/fs/test-fs-assert-encoding-error.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const options = 'test';
const expectedError = {
  code: 'ERR_INVALID_ARG_VALUE',
  name: 'TypeError',
};

assert.throws(() => {
  fs.readFile('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.readFileSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.readdir('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.readdirSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.readlink('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.readlinkSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.writeFile('path', 'data', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.writeFileSync('path', 'data', options);
}, expectedError);

assert.throws(() => {
  fs.appendFile('path', 'data', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.appendFileSync('path', 'data', options);
}, expectedError);

// unsupport watch
/*
assert.throws(() => {
  fs.watch('path', options, common.mustNotCall());
}, expectedError);
*/

assert.throws(() => {
  fs.realpath('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.realpathSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.mkdtemp('path', options, common.mustNotCall());
}, expectedError);

assert.throws(() => {
  fs.mkdtempSync('path', options);
}, expectedError);

assert.throws(() => {
  fs.createReadStream('path', options);
}, expectedError);

assert.throws(() => {
  fs.createWriteStream('path', options);
}, expectedError);
"
test/fs/test-fs-readfile-flags.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Test of fs.readFile with different flags.
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

{
  const emptyFile = path.join(tmpdir.path, 'empty.txt');
  fs.closeSync(fs.openSync(emptyFile, 'w'));

  fs.readFile(
    emptyFile,
    // With `a+` the file is created if it does not exist
    common.mustNotMutateObjectDeep({ encoding: 'utf8', flag: 'a+' }),
    common.mustCall((err, data) => { assert.strictEqual(data, ''); })
  );

  fs.readFile(
    emptyFile,
    // Like `a+` but fails if the path exists.
    common.mustNotMutateObjectDeep({ encoding: 'utf8', flag: 'ax+' }),
    common.mustCall((err, data) => { assert.strictEqual(err.code, 'EEXIST'); })
  );
}

{
  const willBeCreated = path.join(tmpdir.path, 'will-be-created');

  fs.readFile(
    willBeCreated,
    // With `a+` the file is created if it does not exist
    common.mustNotMutateObjectDeep({ encoding: 'utf8', flag: 'a+' }),
    common.mustCall((err, data) => { assert.strictEqual(data, ''); })
  );
}

{
  const willNotBeCreated = path.join(tmpdir.path, 'will-not-be-created');

  fs.readFile(
    willNotBeCreated,
    // Default flag is `r`. An exception occurs if the file does not exist.
    common.mustNotMutateObjectDeep({ encoding: 'utf8' }),
    common.mustCall((err, data) => { assert.strictEqual(err.code, 'ENOENT'); })
  );
}
"
test/fs/test-fs-write-stream-autoclose-option.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const file = path.join(tmpdir.path, 'write-autoclose-opt1.txt');
tmpdir.refresh();
let stream = fs.createWriteStream(file, { flags: 'w+', autoClose: false });
stream.write('Test1');
stream.end();
stream.on('finish', common.mustCall(function() {
  stream.on('close', common.mustNotCall());
  process.nextTick(common.mustCall(function() {
    assert.strictEqual(stream.closed, false);
    assert.notStrictEqual(stream.fd, null);
    next();
  }));
}));

function next() {
  // This will tell us if the fd is usable again or not
  stream = fs.createWriteStream(null, { fd: stream.fd, start: 0 });
  stream.write('Test2');
  stream.end();
  stream.on('finish', common.mustCall(function() {
    assert.strictEqual(stream.closed, false);
    stream.on('close', common.mustCall(function() {
      assert.strictEqual(stream.fd, null);
      assert.strictEqual(stream.closed, true);
      process.nextTick(next2);
    }));
  }));
}

function next2() {
  // This will test if after reusing the fd data is written properly
  fs.readFile(file, function(err, data) {
    assert.ifError(err);
    assert.strictEqual(data.toString(), 'Test2');
    process.nextTick(common.mustCall(next3));
  });
}

function next3() {
  // This is to test success scenario where autoClose is true
  const stream = fs.createWriteStream(file, { autoClose: true });
  stream.write('Test3');
  stream.end();
  stream.on('finish', common.mustCall(function() {
    assert.strictEqual(stream.closed, false);
    stream.on('close', common.mustCall(function() {
      assert.strictEqual(stream.fd, null);
      assert.strictEqual(stream.closed, true);
    }));
  }));
}
"
example_js/react18_ssr/main.mjs,"import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';
import * as std from 'std';

import App from './component/App.js';
import { DataProvider } from './component/data.js'

let assets = {
  'main.js': '/main.js',
  'main.css': '/main.css',
};

const css = std.loadFile('./public/main.css')

function createServerData() {
  let done = false;
  let promise = null;
  return {
    read() {
      if (done) {
        return;
      }
      if (promise) {
        throw promise;
      }
      promise = new Promise(resolve => {
        setTimeout(() => {
          done = true;
          promise = null;
          resolve();
        }, 2000);
      });
      throw promise;
    },
  };
}

createServer((req, res) => {
  print(req.url)
  if (req.url == '/main.css') {
    res.setHeader('Content-Type', 'text/css; charset=utf-8')
    res.end(css)
  } else if (req.url == '/favicon.ico') {
    res.end()
  } else {
    res.setHeader('Content-type', 'text/html');

    res.on('error', (e) => {
      print('res error', e)
    })
    let data = createServerData()
    print('createServerData')

    const stream = renderToPipeableStream(
      <DataProvider data={data}>
        <App assets={assets} />
      </DataProvider>, {
      onShellReady: () => {
        stream.pipe(res)
      },
      onShellError: (e) => {
        print('onShellError:', e)
      }
    }
    );
  }
}).listen(8002, () => {
  print('listen 8002...')
})"
modules/internal/streams/add-abort-signal.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { AbortError, ERR_INVALID_ARG_TYPE } from ""../errors.js"";
import eos from ""./end-of-stream.js"";

// This method is inlined here for readable-stream
// It also does not allow for signal to not exist on the stream
// https://github.com/nodejs/node/pull/36061#discussion_r533718029
const validateAbortSignal = (signal, name) => {
    if (
        typeof signal !== ""object"" ||
        !(""aborted"" in signal)
    ) {
        throw new ERR_INVALID_ARG_TYPE(name, ""AbortSignal"", signal);
    }
};

function isStream(obj) {
    return !!(obj && typeof obj.pipe === ""function"");
}

function addAbortSignal(signal, stream) {
    validateAbortSignal(signal, ""signal"");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE(""stream"", ""stream.Stream"", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== ""object"" || !(""aborted"" in signal)) {
        return stream;
    }
    const onAbort = () => {
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener(""abort"", onAbort);
        eos(stream, () => signal.removeEventListener(""abort"", onAbort));
    }
    return stream;
}

export default { addAbortSignal, addAbortSignalNoValidate };
export { addAbortSignal, addAbortSignalNoValidate };"
test/crypto/test-crypto-randomuuid.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

if (!common.hasCrypto)
  common.skip('missing crypto');

import assert from 'assert';
import {
  randomUUID,
} from 'crypto';

const last = new Set([
  '00000000-0000-0000-0000-000000000000',
]);

function testMatch(uuid) {
  assert.match(
    uuid,
    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/);
}

// Generate a number of UUID's to make sure we're
// not just generating the same value over and over
// and to make sure the batching changes the random
// bytes.
for (let n = 0; n < 130; n++) {
  const uuid = randomUUID();
  assert(!last.has(uuid));
  last.add(uuid);
  assert.strictEqual(typeof uuid, 'string');
  assert.strictEqual(uuid.length, 36);
  testMatch(uuid);

  // Check that version 4 identifier was populated.
  assert.strictEqual(
    Buffer.from(uuid.substr(14, 2), 'hex')[0] & 0x40, 0x40);

  // Check that clock_seq_hi_and_reserved was populated with reserved bits.
  assert.strictEqual(
    Buffer.from(uuid.substr(19, 2), 'hex')[0] & 0b1100_0000, 0b1000_0000);
}

// Test non-buffered UUID's
{
  testMatch(randomUUID({ disableEntropyCache: true }));
  testMatch(randomUUID({ disableEntropyCache: true }));
  testMatch(randomUUID({ disableEntropyCache: true }));
  testMatch(randomUUID({ disableEntropyCache: true }));

  assert.throws(() => randomUUID(1), {
    code: 'ERR_INVALID_ARG_TYPE'
  });

  assert.throws(() => randomUUID({ disableEntropyCache: '' }), {
    code: 'ERR_INVALID_ARG_TYPE'
  });
}
"
modules/internal/crypto/certificate.js,"use strict';

const {
  certExportChallenge,
  certExportPublicKey,
  certVerifySpkac,
} = internalBinding('crypto');

const {
  getArrayBufferOrView,
} = require('internal/crypto/util');

// The functions contained in this file cover the SPKAC format
// (also referred to as Netscape SPKI). A general description of
// the format can be found at https://en.wikipedia.org/wiki/SPKAC

function verifySpkac(spkac, encoding) {
  return certVerifySpkac(
    getArrayBufferOrView(spkac, 'spkac', encoding));
}

function exportPublicKey(spkac, encoding) {
  return certExportPublicKey(
    getArrayBufferOrView(spkac, 'spkac', encoding));
}

function exportChallenge(spkac, encoding) {
  return certExportChallenge(
    getArrayBufferOrView(spkac, 'spkac', encoding));
}

// The legacy implementation of this exposed the Certificate
// object and required that users create an instance before
// calling the member methods. This API pattern has been
// deprecated, however, as the method implementations do not
// rely on any object state.

// For backwards compatibility reasons, this cannot be converted into a
// ES6 Class.
function Certificate() {
  if (!(this instanceof Certificate))
    return new Certificate();
}

Certificate.prototype.verifySpkac = verifySpkac;
Certificate.prototype.exportPublicKey = exportPublicKey;
Certificate.prototype.exportChallenge = exportChallenge;

Certificate.exportChallenge = exportChallenge;
Certificate.exportPublicKey = exportPublicKey;
Certificate.verifySpkac = verifySpkac;

module.exports = Certificate;
"
test/fs/test-fs-symlink-dir.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Test creating a symbolic link pointing to a directory.
// Ref: https://github.com/nodejs/node/pull/23724
// Ref: https://github.com/nodejs/node/issues/23596


if (!common.canCreateSymLink())
  common.skip('insufficient privileges');

import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const linkTargets = [
  'relative-target',
  // path.join(tmpdir.path, 'absolute-target'),
];
const linkPaths = [
  // path.relative(""./"", path.join(tmpdir.path, 'relative-path')),
  path.join(tmpdir.path, 'relative-path')
  // path.join(tmpdir.path, 'absolute-path'),
];

function testSync(target, path) {
  fs.symlinkSync(target, path);
  fs.readdirSync(path);
}

function testAsync(target, path) {
  fs.symlink(target, path, common.mustSucceed(() => {
    fs.readdirSync(path);
  }));
}

for (const linkTarget of linkTargets) {
  fs.mkdirSync(path.resolve(tmpdir.path, linkTarget));
  for (const linkPath of linkPaths) {
    testSync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-sync`);
    testAsync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-async`);
  }
}

// Test invalid symlink
{
  function testSync(target, path) {
    fs.symlinkSync(target, path);
    assert(!fs.existsSync(path));
  }

  function testAsync(target, path) {
    fs.symlink(target, path, common.mustSucceed(() => {
      assert(!fs.existsSync(path));
    }));
  }

  for (const linkTarget of linkTargets.map((p) => p + '-broken')) {
    for (const linkPath of linkPaths) {
      testSync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-sync`);
      testAsync(linkTarget, `${linkPath}-${path.basename(linkTarget)}-async`);
    }
  }
}
"
modules/internal/url.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
import { fileURLToPath } from ""../url"";
import { Buffer } from ""../buffer"";
import { URL } from ""../url"";

const searchParams = Symbol(""query"");

/**
 * @param {string | Buffer | URL} fileURLOrPath
 * @return {string | Buffer}
 */
export function toPathIfFileURL(
    fileURLOrPath,
) {
    if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
    }
    return fileURLToPath(fileURLOrPath);
}

// Utility function that converts a URL object into an ordinary
// options object as expected by the http.request and https.request
// APIs.
// deno-lint-ignore no-explicit-any
export function urlToHttpOptions(url) {
    // deno-lint-ignore no-explicit-any
    const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === ""string"" &&
            url.hostname.startsWith(""["")
            ? url.hostname.slice(1, -1)
            : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname || """"}${url.search || """"}`,
        href: url.href,
    };
    if (url.port !== """") {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)
            }`;
    }
    return options;
}

export { searchParams as searchParamsSymbol };

export default {
    toPathIfFileURL,
};"
test/fs/test-fs-filehandle.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-gc --no-warnings --expose-internals
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import { internalBinding } from 'internal/test/binding';
const fs = internalBinding('fs');
import { stringToFlags } from 'internal/fs/utils';

// Verifies that the FileHandle object is garbage collected and that a
// warning is emitted if it is not closed.

let fdnum;
{
  const ctx = {};
  fdnum = fs.openFileHandle(path.toNamespacedPath(__filename),
                            stringToFlags('r'), 0o666, undefined, ctx).fd;
  assert.strictEqual(ctx.errno, undefined);
}

const deprecationWarning =
  'Closing a FileHandle object on garbage collection is deprecated. ' +
  'Please close FileHandle objects explicitly using ' +
  'FileHandle.prototype.close(). In the future, an error will be ' +
  'thrown if a file descriptor is closed during garbage collection.';

common.expectWarning({
  'internal/test/binding': [
    'These APIs are for internal testing only. Do not use them.',
  ],
  'Warning': [
    `Closing file descriptor ${fdnum} on garbage collection`,
  ],
  'DeprecationWarning': [[deprecationWarning, 'DEP0137']]
});

global.gc();

setTimeout(() => {}, 10);
"
test/fs/test-fs-stream-construct-compat-graceful-fs.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';
import fixtures from '../common/fixtures';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat with graceful-fs.

  function ReadStream(...args) {
    fs.ReadStream.call(this, ...args);
  }
  Object.setPrototypeOf(ReadStream.prototype, fs.ReadStream.prototype);
  Object.setPrototypeOf(ReadStream, fs.ReadStream);

  ReadStream.prototype.open = common.mustCall(function ReadStream$open() {
    const that = this;
    fs.open(that.path, that.flags, that.mode, (err, fd) => {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  });

  const r = new ReadStream(fixtures.path('x.txt'))
    .on('open', common.mustCall((fd) => {
      assert.strictEqual(fd, r.fd);
      r.destroy();
    }));
}

{
  // Compat with graceful-fs.

  function WriteStream(...args) {
    fs.WriteStream.call(this, ...args);
  }
  Object.setPrototypeOf(WriteStream.prototype, fs.WriteStream.prototype);
  Object.setPrototypeOf(WriteStream, fs.WriteStream);

  WriteStream.prototype.open = common.mustCall(function WriteStream$open() {
    const that = this;
    fs.open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  });

  const w = new WriteStream(`${tmpdir.path}/dummy`)
    .on('open', common.mustCall((fd) => {
      assert.strictEqual(fd, w.fd);
      w.destroy();
    }));
}
"
test/fs/test-fs-promises-file-handle-chmod.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.chmod method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateFilePermission() {
  const filePath = path.resolve(tmpDir, 'tmp-chmod.txt');
  const fileHandle = await open(filePath, 'w+', 0o444);
  // File created with r--r--r-- 444
  const statsBeforeMod = fs.statSync(filePath);
  assert.strictEqual(statsBeforeMod.mode & 0o444, 0o444);

  let expectedAccess;
  const newPermissions = 0o765;

  if (common.isWindows) {
    // Chmod in Windows will only toggle read only/write access. The
    // fs.Stats.mode in Windows is computed using read/write
    // bits (not exec). Read-only at best returns 444; r/w 666.
    // Refer: /deps/uv/src/win/fs.cfs;
    expectedAccess = 0o664;
  } else {
    expectedAccess = newPermissions;
  }

  // Change the permissions to rwxr--r-x
  await fileHandle.chmod(newPermissions);
  const statsAfterMod = fs.statSync(filePath);
  assert.deepStrictEqual(statsAfterMod.mode & expectedAccess, expectedAccess);

  await fileHandle.close();
}

validateFilePermission().then(common.mustCall());
"
example_js/wasi_net_echo.js,"import * as net from 'wasi_net';
import { TextDecoder } from 'util'
import { nextTick, exit } from 'process';

async function handle_client(cs) {
  print('server accept:', cs.peer());
  try {
    while (true) {
      let d = await cs.read();
      if (d == undefined || d.byteLength <= 0) {
        break;
      }
      let s = new TextDecoder().decode(d);
      print('server recv:', s);
      cs.write('echo:' + s);
    }
  } catch (e) {
    print('server handle_client error:', e);
  }
  print('server: conn close');
}

async function server_start() {
  print('listen 8000 ...');
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i < 100; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print('server accept error:', e)
  }
}

server_start();

async function connect_test() {
  try {
    let ss = await net.WasiTcpConn.connect('127.0.0.1', 8000)
    ss.write('hello');
    let msg = await ss.read() || """";
    print('client recv:', new TextDecoder().decode(msg));
  } catch (e) {
    print('client catch:', e);
  } finally {
    nextTick(() => {
      exit(0)
    })
  }
}

connect_test();
"
test/fs/test-fs-promises-file-handle-read-worker.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';
import path from 'path';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'read_stream_filehandle_worker.txt');
const input = 'hello world';
import { Worker, isMainThread, workerData } from 'worker_threads';

if (isMainThread || !workerData) {
  tmpdir.refresh();
  fs.writeFileSync(file, input);

  fs.promises.open(file, 'r').then((handle) => {
    handle.on('close', common.mustNotCall());
    new Worker(__filename, {
      workerData: { handle },
      transferList: [handle]
    });
  });
  fs.promises.open(file, 'r').then(async (handle) => {
    try {
      fs.createReadStream(null, { fd: handle });
      assert.throws(() => {
        new Worker(__filename, {
          workerData: { handle },
          transferList: [handle]
        });
      }, {
        code: 25,
        name: 'DataCloneError',
      });
    } finally {
      await handle.close();
    }
  });
} else {
  let output = '';

  const handle = workerData.handle;
  handle.on('close', common.mustCall());
  const stream = fs.createReadStream(null, { fd: handle });

  stream.on('data', common.mustCallAtLeast((data) => {
    output += data;
  }));

  stream.on('end', common.mustCall(() => {
    handle.close();
    assert.strictEqual(output, input);
  }));

  stream.on('close', common.mustCall());
}
"
test/fs/test-fs-watch-recursive.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';


import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const testDir = tmpdir.path;
const filenameOne = 'watch.txt';

tmpdir.refresh();

const testsubdir = fs.mkdtempSync(testDir + path.sep);
const relativePathOne = path.join(path.basename(testsubdir), filenameOne);
const filepathOne = path.join(testsubdir, filenameOne);

if (!common.isOSX && !common.isWindows) {
  assert.throws(() => { fs.watch(testDir, { recursive: true }); },
                { code: 'ERR_FEATURE_UNAVAILABLE_ON_PLATFORM' });
  return;
}
const watcher = fs.watch(testDir, { recursive: true });

let watcherClosed = false;
watcher.on('change', function(event, filename) {
  assert.ok(event === 'change' || event === 'rename');

  // Ignore stale events generated by mkdir and other tests
  if (filename !== relativePathOne)
    return;

  if (common.isOSX) {
    clearInterval(interval);
  }
  watcher.close();
  watcherClosed = true;
});

let interval;
if (common.isOSX) {
  interval = setInterval(function() {
    fs.writeFileSync(filepathOne, 'world');
  }, 10);
} else {
  fs.writeFileSync(filepathOne, 'world');
}

process.on('exit', function() {
  assert(watcherClosed, 'watcher Object was not closed');
});
"
tests/test-path.rs,"#![allow(dead_code, unused_imports, unused_must_use)]

use std::borrow::{Borrow, BorrowMut};
use wasmedge_quickjs::*;

fn test_js_file(file_path: &str) {
    use wasmedge_quickjs as q;

    let file_path = file_path.to_string();
    let mut rt = q::Runtime::new();
    let fut = rt.async_run_with_context(Box::new(move |ctx| {
        let code = std::fs::read_to_string(&file_path);
        match code {
            Ok(code) => {
                ctx.put_args(vec![file_path.clone()]);
                ctx.eval_module_str(code, &file_path);
                if let JsValue::Bool(false) = ctx.get_global().get(""assertPass"") {
                    assert!(false, ""js assert fail"");
                }
            }
            Err(e) => {
                eprintln!(""{}"", e.to_string());
                assert!(false, ""run js test file fail"");
            }
        }
        JsValue::UnDefined
    }));
    let tokio_rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();

    tokio_rt.block_on(fut);
}

#[test]
fn test_path_basename() {
    test_js_file(""test/path/test-path-basename.js"");
}

#[test]
fn test_path_dirname() {
    test_js_file(""test/path/test-path-dirname.js"");
}

#[test]
fn test_path_extname() {
    test_js_file(""test/path/test-path-extname.js"");
}

#[test]
fn test_path_isabsolute() {
    test_js_file(""test/path/test-path-isabsolute.js"");
}

#[test]
fn test_path_join() {
    test_js_file(""test/path/test-path-join.js"");
}

#[test]
fn test_path_makelong() {
    test_js_file(""test/path/test-path-makelong.js"");
}

#[test]
fn test_path_normalize() {
    test_js_file(""test/path/test-path-normalize.js"");
}

#[test]
fn test_path_parse_format() {
    test_js_file(""test/path/test-path-parse-format.js"");
}

#[test]
fn test_path_relative() {
    test_js_file(""test/path/test-path-relative.js"");
}

#[test]
fn test_path_resolve() {
    test_js_file(""test/path/test-path-resolve.js"");
}

#[test]
fn test_path_zero_length_strings() {
    test_js_file(""test/path/test-path-zero-length-strings.js"");
}

#[test]
fn test_path() {
    test_js_file(""test/path/test-path.js"");
}
"
example_js/ggml_chat.js,"import { GGMLChatCompletionRequest, GGMLChatPrompt } from '_wasi_nn_ggml_template'
import { build_graph_from_cache } from '_wasi_nn_ggml'
function main() {
    let opt = {
        ""enable-log"": true,
        ""ctx_size"": 512,
        ""n-predict"": 1024,
        ""n-gpu-layers"": 100,
        ""batch-size"": 512,
        ""temp"": 0.8,
        ""repeat-penalty"": 1.1
    }

    let graph = build_graph_from_cache(3, JSON.stringify(opt), ""default"")
    let context = graph.init_execution_context()

    let template = new GGMLChatPrompt('llama-2-chat')

    let req = new GGMLChatCompletionRequest()

    let messages = ['hello', 'who are you?']

    for (var i in messages) {
        print(""[YOU]:"", messages[i])
        req.push_message(""user"", messages[i])
        let p = template.build(req)
        context.set_input(0, p, [1], 3)
        var ss = '';

        while (1) {
            try {
                context.compute_single()
                let s = context.get_output_single(0, 1)
                ss += s;
                print('BOT:', s)
            } catch (e) {
                if (e['type'] == ""BackendError"" && e['message'] == ""EndOfSequence"") {
                    print('[log] EndOfSequence!')
                    break
                } else if (e['type'] == ""BackendError"" && e['message'] == ""ContextFull"") {
                    print('[log] ContextFull!')
                    break
                } else {
                    return
                }
            }
        }
        req.push_message(""assistant"", ss)
        print(""[BOT]:"", ss);
    }

    let p = template.build(req);
    print()
    print(p)
}

main()"
test/fs/test-fs-read-stream-fd-leak.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

require('../common');
import assert from 'assert';
import fs from 'fs';
import fixtures from '../common/fixtures';

let openCount = 0;
const _fsopen = fs.open;
const _fsclose = fs.close;

const loopCount = 50;
const totalCheck = 50;
const emptyTxt = fixtures.path('empty.txt');

fs.open = function() {
  openCount++;
  return _fsopen.apply(null, arguments);
};

fs.close = function() {
  openCount--;
  return _fsclose.apply(null, arguments);
};

function testLeak(endFn, callback) {
  console.log(`testing for leaks from fs.createReadStream().${endFn}()...`);

  let i = 0;
  let check = 0;

  function checkFunction() {
    if (openCount !== 0 && check < totalCheck) {
      check++;
      setTimeout(checkFunction, 100);
      return;
    }

    assert.strictEqual(
      openCount,
      0,
      `no leaked file descriptors using ${endFn}() (got ${openCount})`
    );

    openCount = 0;
    callback && setTimeout(callback, 100);
  }

  setInterval(function() {
    const s = fs.createReadStream(emptyTxt);
    s[endFn]();

    if (++i === loopCount) {
      clearTimeout(this);
      setTimeout(checkFunction, 100);
    }
  }, 2);
}

testLeak('close', function() {
  testLeak('destroy');
});
"
modules/stream/promises.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.

import { isIterable, isNodeStream } from ""../internal/streams/utils.js"";
import { pipelineImpl as pl } from ""../internal/streams/pipeline.js"";
import eos from ""../internal/streams/end-of-stream.js"";

function pipeline(...streams) {
    return new Promise((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (
            lastArg && typeof lastArg === ""object"" &&
            !isNodeStream(lastArg) && !isIterable(lastArg)
        ) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }

        pl(streams, (err, value) => {
            if (err) {
                reject(err);
            } else {
                resolve(value);
            }
        }, { signal, end });
    });
}

function finished(stream, opts) {
    return new Promise((resolve, reject) => {
        eos(stream, opts, (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

export default {
    finished,
    pipeline,
};
export { finished, pipeline };"
test/fs/test-fs-syncwritestream.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import { spawn } from 'child_process';
import stream from 'stream';
import fs from 'fs';
import path from 'path';

// require('internal/fs/utils').SyncWriteStream is used as a stdio
// implementation when stdout/stderr point to files.

if (process.argv[2] === 'child') {
  // Note: Calling console.log() is part of this test as it exercises the
  // SyncWriteStream#_write() code path.
  console.log(JSON.stringify([process.stdout, process.stderr].map((stdio) => ({
    instance: stdio instanceof stream.Writable,
    readable: stdio.readable,
    writable: stdio.writable,
  }))));

  return;
}

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = path.join(tmpdir.path, 'stdout');
const stdoutFd = fs.openSync(filename, 'w');

const proc = spawn(process.execPath, [__filename, 'child'], {
  stdio: ['inherit', stdoutFd, stdoutFd ]
});

proc.on('close', common.mustCall(() => {
  fs.closeSync(stdoutFd);

  assert.deepStrictEqual(JSON.parse(fs.readFileSync(filename, 'utf8')), [
    { instance: true, readable: false, writable: true },
    { instance: true, readable: false, writable: true },
  ]);
}));
"
test/fs/test-fs-readfile-pipe-large.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Simulate `cat readfile.js | node readfile.js`

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';
import path from 'path';
import fs from 'fs';

if (process.argv[2] === 'child') {
  fs.readFile('/dev/stdin', function(er, data) {
    assert.ifError(er);
    process.stdout.write(data);
  });
  return;
}

import tmpdir from '../common/tmpdir';

const filename = path.join(tmpdir.path, '/readfile_pipe_large_test.txt');
const dataExpected = 'a'.repeat(999999);
tmpdir.refresh();
fs.writeFileSync(filename, dataExpected);

import { exec } from 'child_process';
const f = JSON.stringify(__filename);
const node = JSON.stringify(process.execPath);
const cmd = `cat ${filename} | ${node} ${f} child`;
exec(cmd, { maxBuffer: 1000000 }, common.mustSucceed((stdout, stderr) => {
  assert.strictEqual(
    stdout,
    dataExpected,
    `expect it reads the file and outputs 999999 'a' but got : ${stdout}`
  );
  assert.strictEqual(
    stderr,
    '',
    `expect that it does not write to stderr, but got : ${stderr}`
  );
  console.log('ok');
}));
"
test/fs/test-fs-promises-writefile-with-fd.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This test makes sure that `writeFile()` always writes from the current
// position of the file, instead of truncating the file.

import common from '../common';
import assert from 'assert';
import path from 'path';
import { readFileSync } from 'fs';
import { open } from 'fs/promises';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = path.join(tmpdir.path, 'test.txt');

async function writeFileTest() {
  const handle = await open(fn, 'w');

  /* Write only five bytes, so that the position moves to five. */
  const buf = Buffer.from('Hello');
  const { bytesWritten } = await handle.write(buf, 0, 5, null);
  assert.strictEqual(bytesWritten, 5);

  /* Write some more with writeFile(). */
  await handle.writeFile('World');

  /* New content should be written at position five, instead of zero. */
  assert.strictEqual(readFileSync(fn).toString(), 'HelloWorld');

  await handle.close();
}


writeFileTest()
  .then(common.mustCall()).catch(err => print(err, err.stack));
"
test/fs/test-fs-readdir.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

const __filename = args[0];

const readdirDir = tmpdir.path;
const files = ['empty', 'files', 'for', 'just', 'testing'];

// Make sure tmp directory is clean
tmpdir.refresh();

// Create the necessary files
files.forEach(function(currentFile) {
  fs.closeSync(fs.openSync(`${readdirDir}/${currentFile}`, 'w'));
});

// Check the readdir Sync version
assert.deepStrictEqual(files, fs.readdirSync(readdirDir).sort());

// Check the readdir async version
fs.readdir(readdirDir, common.mustSucceed((f) => {
  assert.deepStrictEqual(files, f.sort());
}));

// readdir() on file should throw ENOTDIR
// https://github.com/joyent/node/issues/1869
assert.throws(function() {
  fs.readdirSync(__filename);
}, /Error: ENOTDIR: not a directory/);

fs.readdir(__filename, common.mustCall(function(e) {
  assert.strictEqual(e.code, 'ENOTDIR');
}));

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.readdir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.readdirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fs/test-fs-realpath-on-substed-drive.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
if (!common.isWindows)
  common.skip('Test for Windows only');

import fixtures from '../common/fixtures';

import assert from 'assert';
import fs from 'fs';
import { spawnSync } from 'child_process';

let result;

// Create a subst drive
const driveLetters = 'ABCDEFGHIJKLMNOPQRSTUWXYZ';
let drive;
let i;
for (i = 0; i < driveLetters.length; ++i) {
  drive = `${driveLetters[i]}:`;
  result = spawnSync('subst', [drive, fixtures.fixturesDir]);
  if (result.status === 0)
    break;
}
if (i === driveLetters.length)
  common.skip('Cannot create subst drive');

// Schedule cleanup (and check if all callbacks where called)
process.on('exit', function() {
  spawnSync('subst', ['/d', drive]);
});

// test:
const filename = `${drive}\\empty.js`;
const filenameBuffer = Buffer.from(filename);

result = fs.realpathSync(filename);
assert.strictEqual(result, filename);

result = fs.realpathSync(filename, 'buffer');
assert(Buffer.isBuffer(result));
assert(result.equals(filenameBuffer));

fs.realpath(filename, common.mustSucceed((result) => {
  assert.strictEqual(result, filename);
}));

fs.realpath(filename, 'buffer', common.mustSucceed((result) => {
  assert(Buffer.isBuffer(result));
  assert(result.equals(filenameBuffer));
}));
"
test/fs/test-fs-promises-file-handle-stream.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.write method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import { finished } from 'stream/promises';
import { buffer } from 'stream/consumers';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateWrite() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-write.txt');
  const fileHandle = await open(filePathForHandle, 'w');
  const buffer = Buffer.from('Hello world'.repeat(100), 'utf8');

  const stream = fileHandle.createWriteStream();
  stream.end(buffer);
  await finished(stream);

  const readFileData = fs.readFileSync(filePathForHandle);
  assert.deepStrictEqual(buffer, readFileData);
}

async function validateRead() {
  const filePathForHandle = path.resolve(tmpDir, 'tmp-read.txt');
  const buf = Buffer.from('Hello world'.repeat(100), 'utf8');

  fs.writeFileSync(filePathForHandle, buf);

  const fileHandle = await open(filePathForHandle);
  assert.deepStrictEqual(
    await buffer(fileHandle.createReadStream()),
    buf
  );
}

Promise.all([
  validateWrite(),
  validateRead(),
]).then(common.mustCall()).catch(err => print(err, err.stack));
"
example_js/react18_ssr/component/css.js,"const css = `
body {
    font-family: system-ui, sans-serif;
  }
  
  * {
    box-sizing: border-box;
  }
  
  nav {
    padding: 20px;
  }
  
  .sidebar {
    padding: 10px;
    height: 500px;
    float: left;
    width: 30%;
  }
  
  .post {
    padding: 20px;
    float: left;
    width: 60%;
  }
  
  h1, h2 {
    padding: 0;
  }
  
  ul, li {
    margin: 0;
  }
  
  .post p {
    font-size: larger;
    font-family: Georgia, serif;
  }
  
  .comments {
    margin-top: 40px;
  }
  
  .comment {
    border: 2px solid #aaa;
    border-radius: 4px;
    padding: 20px;
  }
  
  /* https://codepen.io/mandelid/pen/vwKoe */
  .spinner {
    display: inline-block;
    transition: opacity linear 0.1s;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(80, 80, 80, 0.5);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
    opacity: 0;
  }
  .spinner--active {
    opacity: 1;
  }
  
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
  `
export default css"
test/fs/test-fs-promises-readfile-with-fd.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This test makes sure that `readFile()` always reads from the current
// position of the file, instead of reading from the beginning of the file.

import common from '../common';
import assert from 'assert';
import path from 'path';
import { writeFileSync } from 'fs';
import { open } from 'fs/promises';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const fn = path.join(tmpdir.path, 'test.txt');
writeFileSync(fn, 'Hello World');

async function readFileTest() {
  const handle = await open(fn, 'r');

  /* Read only five bytes, so that the position moves to five. */
  const buf = Buffer.alloc(5);
  const { bytesRead } = await handle.read(buf, 0, 5, null);
  assert.strictEqual(bytesRead, 5);
  assert.strictEqual(buf.toString(), 'Hello');

  /* readFile() should read from position five, instead of zero. */
  assert.strictEqual((await handle.readFile()).toString(), ' World');

  await handle.close();
}


readFileTest()
  .then(common.mustCall());
"
test/fs/test-fs-stream-construct-compat-error-write.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';

const debuglog = (arg) => {
  console.log(new Date().toLocaleString(), arg);
};

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat error.
  debuglog('start test');

  function WriteStream(...args) {
    debuglog('WriteStream constructor');
    fs.WriteStream.call(this, ...args);
  }
  Object.setPrototypeOf(WriteStream.prototype, fs.WriteStream.prototype);
  Object.setPrototypeOf(WriteStream, fs.WriteStream);

  WriteStream.prototype.open = common.mustCall(function WriteStream$open() {
    debuglog('WriteStream open() callback');
    const that = this;
    fs.open(that.path, that.flags, that.mode, (err, fd) => {
      debuglog('inner fs open() callback');
      that.emit('error', err);
    });
  });

  fs.open(`${tmpdir.path}/dummy`, 'wx+', common.mustCall((err, fd) => {
    debuglog('fs open() callback');
    assert.ifError(err);
    fs.close(fd, () => { debuglog(`closed ${fd}`); });
    const w = new WriteStream(`${tmpdir.path}/dummy`,
                              { flags: 'wx+', emitClose: true })
      .on('error', common.mustCall((err) => {
        debuglog('error event callback');
        assert.strictEqual(err.code, 'EEXIST');
        w.destroy();
        w.on('close', common.mustCall(() => {
          debuglog('close event callback');
        }));
      }));
  }));
  debuglog('waiting for callbacks');
}
"
test/fs/test-fs-mkdir-mode-mask.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that the lower bits of mode > 0o777 still works in fs.mkdir().

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

// mode is unsupported in wasi now
if (common.isWindows) {
  common.skip('mode is not supported in mkdir on Windows');
}

const mode = 0o644;
const maskToIgnore = 0o10000;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function test(mode, asString) {
  const suffix = asString ? 'str' : 'num';
  const input = asString ?
    (mode | maskToIgnore).toString(8) : (mode | maskToIgnore);

  {
    const dir = path.join(tmpdir.path, `mkdirSync-${suffix}`);
    fs.mkdirSync(dir, input);
    assert.strictEqual(fs.statSync(dir).mode & 0o777, mode);
  }

  {
    const dir = path.join(tmpdir.path, `mkdir-${suffix}`);
    fs.mkdir(dir, input, common.mustSucceed(() => {
      assert.strictEqual(fs.statSync(dir).mode & 0o777, mode);
    }));
  }
}

test(mode, true);
test(mode, false);
"
test/fs/test-fs-open-mode-mask.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that the lower bits of mode > 0o777 still works in fs.open().

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

const mode = common.isWindows ? 0o444 : 0o644;

const maskToIgnore = 0o10000;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function test(mode, asString) {
  const suffix = asString ? 'str' : 'num';
  const input = asString ?
    (mode | maskToIgnore).toString(8) : (mode | maskToIgnore);

  {
    const file = path.join(tmpdir.path, `openSync-${suffix}.txt`);
    const fd = fs.openSync(file, 'w+', input);
    assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);
    fs.closeSync(fd);
    assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
  }

  {
    const file = path.join(tmpdir.path, `open-${suffix}.txt`);
    fs.open(file, 'w+', input, common.mustSucceed((fd) => {
      assert.strictEqual(fs.fstatSync(fd).mode & 0o777, mode);
      fs.closeSync(fd);
      assert.strictEqual(fs.statSync(file).mode & 0o777, mode);
    }));
  }
}

test(mode, true);
test(mode, false);
"
modules/internal/streams/lazy_transform.js,"// LazyTransform is a special type of Transform stream that is lazily loaded.
// This is used for performance with bi-API-ship: when two APIs are available
// for the stream, one conventional and one non-conventional.
'use strict';

import Transform from './transform';

import {
  getDefaultEncoding
} from '../crypto/util';

export function LazyTransform(options) {
  this._options = options;
}
Object.setPrototypeOf(LazyTransform.prototype, Transform.prototype);
Object.setPrototypeOf(LazyTransform, Transform);

function makeGetter(name) {
  return function() {
    Transform.call(this, this._options);
    this._writableState.decodeStrings = false;

    if (!this._options || !this._options.defaultEncoding) {
      this._writableState.defaultEncoding = getDefaultEncoding();
    }

    return this[name];
  };
}

function makeSetter(name) {
  return function(val) {
    Object.defineProperty(this, name, {
      __proto__: null,
      value: val,
      enumerable: true,
      configurable: true,
      writable: true
    });
  };
}

Object.defineProperties(LazyTransform.prototype, {
  _readableState: {
    __proto__: null,
    get: makeGetter('_readableState'),
    set: makeSetter('_readableState'),
    configurable: true,
    enumerable: true
  },
  _writableState: {
    __proto__: null,
    get: makeGetter('_writableState'),
    set: makeSetter('_writableState'),
    configurable: true,
    enumerable: true
  }
});
"
test/fs/test-fs-watch-close-when-destroyed.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// This tests that closing a watcher when the underlying handle is
// already destroyed will result in a noop instead of a crash.

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import tmpdir from '../common/tmpdir';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();
const root = path.join(tmpdir.path, 'watched-directory');
fs.mkdirSync(root);

const watcher = fs.watch(root, { persistent: false, recursive: false });

// The following listeners may or may not be invoked.

watcher.addListener('error', () => {
  setTimeout(
    () => { watcher.close(); },  // Should not crash if it's invoked
    common.platformTimeout(10)
  );
});

watcher.addListener('change', () => {
  setTimeout(
    () => { watcher.close(); },
    common.platformTimeout(10)
  );
});

fs.rmdirSync(root);
// Wait for the listener to hit
setTimeout(
  common.mustCall(() => {}),
  common.platformTimeout(100)
);
"
test/fs/test-fs-write-buffer-large.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// fs.write with length > INT32_MAX

common.skipIf32Bits();

let buf;
try {
  buf = Buffer.allocUnsafe(0x7FFFFFFF + 1);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip('skipped due to memory requirements');
}

const filename = path.join(tmpdir.path, 'write9.txt');
fs.open(filename, 'w', 0o644, common.mustSucceed((fd) => {
  assert.throws(() => {
    fs.write(fd,
             buf,
             0,
             0x7FFFFFFF + 1,
             0,
             common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
    name: 'RangeError',
    message: 'The value of ""length"" is out of range. ' +
      'It must be >= 0 && <= 2147483647. Received 2147483648'
  });

  fs.closeSync(fd);
}));
"
test/fs/test-fs-write-negativeoffset.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Tests that passing a negative offset does not crash the process

import common from '../common';

import {
  join,
} from 'path';

import {
  closeSync,
  open,
  write,
  writeSync,
} from 'fs';

import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = join(tmpdir.path, 'test.txt');

open(filename, 'w+', common.mustSucceed((fd) => {
  assert.throws(() => {
    write(fd, Buffer.alloc(0), -1, common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  assert.throws(() => {
    writeSync(fd, Buffer.alloc(0), -1);
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  closeSync(fd);
}));

const filename2 = join(tmpdir.path, 'test2.txt');

// Make sure negative length's don't cause aborts either

open(filename2, 'w+', common.mustSucceed((fd) => {
  assert.throws(() => {
    write(fd, Buffer.alloc(0), 0, -1, common.mustNotCall());
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  assert.throws(() => {
    writeSync(fd, Buffer.alloc(0), 0, -1);
  }, {
    code: 'ERR_OUT_OF_RANGE',
  });
  closeSync(fd);
}));
"
test/crypto/test-crypto-aes-wrap.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const test = [
  {
    algorithm: 'aes128-wrap',
    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
    iv: '3fd838af4093d749',
    text: '12345678123456781234567812345678'
  },
  {
    algorithm: 'id-aes128-wrap-pad',
    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
    iv: '3fd838af',
    text: '12345678123456781234567812345678123'
  },
  {
    algorithm: 'aes192-wrap',
    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
    iv: '3fd838af4093d749',
    text: '12345678123456781234567812345678'
  },
  {
    algorithm: 'id-aes192-wrap-pad',
    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
    iv: '3fd838af',
    text: '12345678123456781234567812345678123'
  },
  {
    algorithm: 'aes256-wrap',
    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
    iv: '3fd838af4093d749',
    text: '12345678123456781234567812345678'
  },
  {
    algorithm: 'id-aes256-wrap-pad',
    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
    iv: '3fd838af',
    text: '12345678123456781234567812345678123'
  },
];

test.forEach((data) => {
  const cipher = crypto.createCipheriv(
    data.algorithm,
    Buffer.from(data.key, 'hex'),
    Buffer.from(data.iv, 'hex'));
  const ciphertext = cipher.update(data.text, 'utf8');

  const decipher = crypto.createDecipheriv(
    data.algorithm,
    Buffer.from(data.key, 'hex'),
    Buffer.from(data.iv, 'hex'));
  const msg = decipher.update(ciphertext, 'buffer', 'utf8');

  assert.strictEqual(msg, data.text, `${data.algorithm} test case failed`);
});
"
test/crypto/test-crypto-op-during-process-exit.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto) { common.skip('missing crypto'); }
const assert = require('assert');
const { generateKeyPair } = require('crypto');

if (common.isWindows) {
  // Remove this conditional once the libuv change is in Node.js.
  common.skip('crashing due to https://github.com/libuv/libuv/pull/2983');
}

// Regression test for a race condition: process.exit() might lead to OpenSSL
// cleaning up state from the exit() call via calling its destructor, but
// running OpenSSL operations on another thread might lead to them attempting
// to initialize OpenSSL, leading to a crash.
// This test crashed consistently on x64 Linux on Node v14.9.0.

generateKeyPair('rsa', {
  modulusLength: 2048,
  privateKeyEncoding: {
    type: 'pkcs1',
    format: 'pem'
  }
}, (err/* , publicKey, privateKey */) => {
  assert.ifError(err);
});

setTimeout(() => process.exit(), common.platformTimeout(10));
"
test/fs/test-fs-link.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Test creating and reading hard link
const srcPath = path.join(tmpdir.path, 'hardlink-target.txt');
const dstPath = path.join(tmpdir.path, 'link1.js');
fs.writeFileSync(srcPath, 'hello world');

function callback(err) {
  assert.ifError(err);
  const dstContent = fs.readFileSync(dstPath, 'utf8');
  assert.strictEqual(dstContent, 'hello world');
}

fs.link(srcPath, dstPath, common.mustCall(callback));

// test error outputs

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.link(i, '', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.link('', i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.linkSync(i, ''),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.linkSync('', i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fs/test-fs-write-reuse-callback.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-gc
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import path from 'path';

// Regression test for https://github.com/nodejs/node-v0.x-archive/issues/814:
// Make sure that Buffers passed to fs.write() are not garbage-collected
// even when the callback is being reused.

import fs from 'fs';

tmpdir.refresh();
const filename = path.join(tmpdir.path, 'test.txt');
const fd = fs.openSync(filename, 'w');

const size = 16 * 1024;
const writes = 1000;
let done = 0;

const ondone = common.mustSucceed(() => {
  if (++done < writes) {
    if (done % 25 === 0) global.gc();
    setImmediate(write);
  } else {
    assert.strictEqual(
      fs.readFileSync(filename, 'utf8'),
      'x'.repeat(writes * size));
    fs.closeSync(fd);
  }
}, writes);

write();
function write() {
  const buf = Buffer.alloc(size, 'x');
  fs.write(fd, buf, 0, buf.length, -1, ondone);
}
"
test/fs/test-fs-write-sigxfsz.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Check that exceeding RLIMIT_FSIZE fails with EFBIG
// rather than terminating the process with SIGXFSZ.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

import assert from 'assert';
import child_process from 'child_process';
import fs from 'fs';
import path from 'path';

if (common.isWindows)
  common.skip('no RLIMIT_FSIZE on Windows');

if (process.config.variables.node_shared)
  common.skip('SIGXFSZ signal handler not installed in shared library mode');

if (process.argv[2] === 'child') {
  const filename = path.join(tmpdir.path, 'efbig.txt');
  tmpdir.refresh();
  fs.writeFileSync(filename, '.'.repeat(1 << 16));  // Exceeds RLIMIT_FSIZE.
} else {
  const cmd = `ulimit -f 1 && '${process.execPath}' '${__filename}' child`;
  const result = child_process.spawnSync('/bin/sh', ['-c', cmd]);
  const haystack = result.stderr.toString();
  const needle = 'Error: EFBIG: file too large, write';
  const ok = haystack.includes(needle);
  if (!ok) console.error(haystack);
  assert(ok);
  assert.strictEqual(result.status, 1);
  assert.strictEqual(result.stdout.toString(), '');
}
"
test/crypto/test-crypto-dh-constructor.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
const dh1 = crypto.createDiffieHellman(size);
const p1 = dh1.getPrime('buffer');

{
  const DiffieHellman = crypto.DiffieHellman;

  const dh = DiffieHellman(p1, 'buffer');
  assert(dh instanceof DiffieHellman, 'DiffieHellman is expected to return a ' +
                                      'new instance when called without `new`');
}

{
  const DiffieHellmanGroup = crypto.DiffieHellmanGroup;
  const dhg = DiffieHellmanGroup('modp5');
  assert(dhg instanceof DiffieHellmanGroup, 'DiffieHellmanGroup is expected ' +
                                            'to return a new instance when ' +
                                            'called without `new`');
}

{
  const ECDH = crypto.ECDH;
  const ecdh = ECDH('prime256v1');
  assert(ecdh instanceof ECDH, 'ECDH is expected to return a new instance ' +
                              'when called without `new`');
}
"
test/fs/test-fs-write-file-invalid-path.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

if (!common.isWindows)
  common.skip('This test is for Windows only.');

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const DATA_VALUE = 'hello';

// Refs: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx
// Ignore '/', '\\' and ':'
const RESERVED_CHARACTERS = '<>""|?*';

[...RESERVED_CHARACTERS].forEach((ch) => {
  const pathname = path.join(tmpdir.path, `somefile_${ch}`);
  assert.throws(
    () => {
      fs.writeFileSync(pathname, DATA_VALUE);
    },
    /^Error: ENOENT: no such file or directory, open '.*'$/,
    `failed with '${ch}'`);
});

// Test for ':' (NTFS data streams).
// Refs: https://msdn.microsoft.com/en-us/library/windows/desktop/bb540537.aspx
const pathname = path.join(tmpdir.path, 'foo:bar');
fs.writeFileSync(pathname, DATA_VALUE);

let content = '';
const fileDataStream = fs.createReadStream(pathname, {
  encoding: 'utf8'
});

fileDataStream.on('data', (data) => {
  content += data;
});

fileDataStream.on('end', common.mustCall(() => {
  assert.strictEqual(content, DATA_VALUE);
}));
"
test/path/test-path-dirname.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';

const __filename = args[0];

assert.strictEqual(path.dirname(__filename).substr(-13),
                   common.isWindows ? 'test\\path' : 'test/path');

assert.strictEqual(path.posix.dirname('/a/b/'), '/a');
assert.strictEqual(path.posix.dirname('/a/b'), '/a');
assert.strictEqual(path.posix.dirname('/a'), '/');
assert.strictEqual(path.posix.dirname(''), '.');
assert.strictEqual(path.posix.dirname('/'), '/');
assert.strictEqual(path.posix.dirname('////'), '/');
assert.strictEqual(path.posix.dirname('//a'), '//');
assert.strictEqual(path.posix.dirname('foo'), '.');
/*
assert.strictEqual(path.win32.dirname('c:\\'), 'c:\\');
assert.strictEqual(path.win32.dirname('c:\\foo'), 'c:\\');
assert.strictEqual(path.win32.dirname('c:\\foo\\'), 'c:\\');
assert.strictEqual(path.win32.dirname('c:\\foo\\bar'), 'c:\\foo');
assert.strictEqual(path.win32.dirname('c:\\foo\\bar\\'), 'c:\\foo');
assert.strictEqual(path.win32.dirname('c:\\foo\\bar\\baz'), 'c:\\foo\\bar');
assert.strictEqual(path.win32.dirname('c:\\foo bar\\baz'), 'c:\\foo bar');
assert.strictEqual(path.win32.dirname('\\'), '\\');
assert.strictEqual(path.win32.dirname('\\foo'), '\\');
assert.strictEqual(path.win32.dirname('\\foo\\'), '\\');
assert.strictEqual(path.win32.dirname('\\foo\\bar'), '\\foo');
assert.strictEqual(path.win32.dirname('\\foo\\bar\\'), '\\foo');
assert.strictEqual(path.win32.dirname('\\foo\\bar\\baz'), '\\foo\\bar');
assert.strictEqual(path.win32.dirname('\\foo bar\\baz'), '\\foo bar');
assert.strictEqual(path.win32.dirname('c:'), 'c:');
assert.strictEqual(path.win32.dirname('c:foo'), 'c:');
assert.strictEqual(path.win32.dirname('c:foo\\'), 'c:');
assert.strictEqual(path.win32.dirname('c:foo\\bar'), 'c:foo');
assert.strictEqual(path.win32.dirname('c:foo\\bar\\'), 'c:foo');
assert.strictEqual(path.win32.dirname('c:foo\\bar\\baz'), 'c:foo\\bar');
assert.strictEqual(path.win32.dirname('c:foo bar\\baz'), 'c:foo bar');
assert.strictEqual(path.win32.dirname('file:stream'), '.');
assert.strictEqual(path.win32.dirname('dir\\file:stream'), 'dir');
assert.strictEqual(path.win32.dirname('\\\\unc\\share'),
                   '\\\\unc\\share');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo'),
                   '\\\\unc\\share\\');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\'),
                   '\\\\unc\\share\\');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\bar'),
                   '\\\\unc\\share\\foo');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\bar\\'),
                   '\\\\unc\\share\\foo');
assert.strictEqual(path.win32.dirname('\\\\unc\\share\\foo\\bar\\baz'),
                   '\\\\unc\\share\\foo\\bar');
assert.strictEqual(path.win32.dirname('/a/b/'), '/a');
assert.strictEqual(path.win32.dirname('/a/b'), '/a');
assert.strictEqual(path.win32.dirname('/a'), '/');
assert.strictEqual(path.win32.dirname(''), '.');
assert.strictEqual(path.win32.dirname('/'), '/');
assert.strictEqual(path.win32.dirname('////'), '/');
assert.strictEqual(path.win32.dirname('foo'), '.');
*/"
example_js/react18_ssr/public/main.css,"body {
    font-family: system-ui, sans-serif;
  }
  
  * {
    box-sizing: border-box;
  }
  
  nav {
    padding: 20px;
  }
  
  .sidebar {
    padding: 10px;
    height: 500px;
    float: left;
    width: 30%;
  }
  
  .post {
    padding: 20px;
    float: left;
    width: 60%;
  }
  
  h1, h2 {
    padding: 0;
  }
  
  ul, li {
    margin: 0;
  }
  
  .post p {
    font-size: larger;
    font-family: Georgia, serif;
  }
  
  .comments {
    margin-top: 40px;
  }
  
  .comment {
    border: 2px solid #aaa;
    border-radius: 4px;
    padding: 20px;
  }
  
  /* https://codepen.io/mandelid/pen/vwKoe */
  .spinner {
    display: inline-block;
    transition: opacity linear 0.1s;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(80, 80, 80, 0.5);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
    opacity: 0;
  }
  .spinner--active {
    opacity: 1;
  }
  
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }"
test/crypto/test-crypto-private-decrypt-gh32240.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// Verify that privateDecrypt() does not leave an error on the
// openssl error stack that is visible to subsequent operations.

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const {
  generateKeyPairSync,
  publicEncrypt,
  privateDecrypt,
} = require('crypto');

const pair = generateKeyPairSync('rsa', { modulusLength: 512 });

const expected = Buffer.from('shibboleth');
const encrypted = publicEncrypt(pair.publicKey, expected);

const pkey = pair.privateKey.export({ type: 'pkcs1', format: 'pem' });
const pkeyEncrypted =
  pair.privateKey.export({
    type: 'pkcs1',
    format: 'pem',
    cipher: 'aes128',
    passphrase: 'secret',
  });

function decrypt(key) {
  const decrypted = privateDecrypt(key, encrypted);
  assert.deepStrictEqual(decrypted, expected);
}

decrypt(pkey);
assert.throws(() => decrypt(pkeyEncrypted), common.hasOpenSSL3 ?
  { message: 'error:07880109:common libcrypto routines::interrupted or ' +
             'cancelled' } :
  { code: 'ERR_MISSING_PASSPHRASE' });
decrypt(pkey);  // Should not throw.
"
test/fs/test-fs-non-number-arguments-throw.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';
const tempFile = path.join(tmpdir.path, 'fs-non-number-arguments-throw');

tmpdir.refresh();
fs.writeFileSync(tempFile, 'abc\ndef');

// A sanity check when using numbers instead of strings
const sanity = 'def';
const saneEmitter = fs.createReadStream(tempFile, { start: 4, end: 6 });

assert.throws(
  () => {
    fs.createReadStream(tempFile, { start: '4', end: 6 });
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.createReadStream(tempFile, { start: 4, end: '6' });
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

assert.throws(
  () => {
    fs.createWriteStream(tempFile, { start: '4' });
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

saneEmitter.on('data', common.mustCall(function(data) {
  assert.strictEqual(
    sanity, data.toString('utf8'),
    `read ${data.toString('utf8')} instead of ${sanity}`);
}));
"
test/fs/test-fs-read-optional-params.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import assert from 'assert';
const filepath = fixtures.path('x.txt');

const expected = Buffer.from('xyz\n');
const defaultBufferAsync = Buffer.alloc(16384);
const bufferAsOption = Buffer.allocUnsafe(expected.byteLength);

function testValid(message, ...options) {
  const paramsMsg = `${message} (as params)`;
  const paramsFilehandle = fs.openSync(filepath, 'r');
  fs.read(paramsFilehandle, ...options, common.mustSucceed((bytesRead, buffer) => {
    assert.strictEqual(bytesRead, expected.byteLength, paramsMsg);
    assert.deepStrictEqual(defaultBufferAsync.byteLength, buffer.byteLength, paramsMsg);
    fs.closeSync(paramsFilehandle);
  }));

  const optionsMsg = `${message} (as options)`;
  const optionsFilehandle = fs.openSync(filepath, 'r');
  fs.read(optionsFilehandle, bufferAsOption, ...options, common.mustSucceed((bytesRead, buffer) => {
    assert.strictEqual(bytesRead, expected.byteLength, optionsMsg);
    assert.deepStrictEqual(bufferAsOption.byteLength, buffer.byteLength, optionsMsg);
    fs.closeSync(optionsFilehandle);
  }));
}

testValid('Not passing in any object');
testValid('Passing in a null', null);
testValid('Passing in an empty object', common.mustNotMutateObjectDeep({}));
testValid('Passing in an object', common.mustNotMutateObjectDeep({
  offset: 0,
  length: bufferAsOption.byteLength,
  position: 0,
}));
"
test/fixtures/keys/fake-startcom-root.cnf,"[ ca ]
default_ca      = CA_default

[ CA_default ]
dir = .
name_opt = CA_default
cert_opt = CA_default
default_crl_days = 9999
default_md = sha256
database = fake-startcom-root-database.txt
serial = fake-startcom-root-serial
private_key = fake-startcom-root-key.pem
certificate = fake-startcom-root-cert.pem
new_certs_dir = fake-startcom-root-issued-certs
email_in_dn = no
policy          = policy_anything

[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
default_bits           = 2048
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = IL
O                      = StartCom Ltd.
OU                     = Secure Digital Certificate Signing
CN                     = StartCom Certification Authority

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
basicConstraints = CA:TRUE
"
test/fs/test-fs-write-file-typedarrays.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const filename = join(tmpdir.path, 'test.txt');

const s = '203111' +
          '' +
          '203' +
          '196179112' +
          '11193' +
          '' +
          '##\n';

// The length of the buffer should be a multiple of 8
// as required by common.getArrayBufferViews()
const inputBuffer = Buffer.from(s.repeat(8), 'utf8');

for (const expectView of common.getArrayBufferViews(inputBuffer)) {
  console.log('Sync test for ', expectView[Symbol.toStringTag]);
  fs.writeFileSync(filename, expectView);
  assert.strictEqual(
    fs.readFileSync(filename, 'utf8'),
    inputBuffer.toString('utf8')
  );
}

for (const expectView of common.getArrayBufferViews(inputBuffer)) {
  console.log('Async test for ', expectView[Symbol.toStringTag]);
  const file = `${filename}-${expectView[Symbol.toStringTag]}`;
  fs.writeFile(file, expectView, common.mustSucceed(() => {
    fs.readFile(file, 'utf8', common.mustSucceed((data) => {
      assert.strictEqual(data, inputBuffer.toString('utf8'));
    }));
  }));
}
"
test/fs/test-fs-rename-type-check.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, [], {}, null, undefined].forEach((input) => {
  const type = 'of type string or an instance of Buffer or URL.' +
               common.invalidArgTypeHelper(input);
  assert.throws(
    () => fs.rename(input, 'does-not-exist', common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""oldPath"" argument must be ${type}`
    }
  );
  assert.throws(
    () => fs.rename('does-not-exist', input, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""newPath"" argument must be ${type}`
    }
  );
  assert.throws(
    () => fs.renameSync(input, 'does-not-exist'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""oldPath"" argument must be ${type}`
    }
  );
  assert.throws(
    () => fs.renameSync('does-not-exist', input),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
      message: `The ""newPath"" argument must be ${type}`
    }
  );
});
"
test/crypto/test-crypto-dh-modp2.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { modp2buf } = require('../common/crypto');
const modp2 = crypto.createDiffieHellmanGroup('modp2');

{
  // Ensure specific generator (buffer) works as expected.
  const exmodp2 = crypto.createDiffieHellman(modp2buf, Buffer.from([2]));
  modp2.generateKeys();
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}

{
  // Ensure specific generator (string without encoding) works as expected.
  const exmodp2 = crypto.createDiffieHellman(modp2buf, '\x02');
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}

{
  // Ensure specific generator (numeric) works as expected.
  const exmodp2 = crypto.createDiffieHellman(modp2buf, 2);
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}
"
test/fs/test-fs-buffer.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

fs.access(Buffer.from(tmpdir.path), common.mustSucceed());

const buf = Buffer.from(path.join(tmpdir.path, 'a.txt'));
fs.open(buf, 'w+', common.mustSucceed((fd) => {
  assert(fd);
  fs.close(fd, common.mustSucceed());
}));

assert.throws(
  () => {
    fs.accessSync(true);
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""path"" argument must be of type string or an instance of ' +
             'Buffer or URL. Received type boolean (true)'
  }
);

const dir = Buffer.from(fixtures.fixturesDir);
fs.readdir(dir, 'hex', common.mustSucceed((hexList) => {
  fs.readdir(dir, common.mustSucceed((stringList) => {
    stringList.forEach((val, idx) => {
      const fromHexList = Buffer.from(hexList[idx], 'hex').toString();
      assert.strictEqual(
        fromHexList,
        val,
        `expected ${val}, got ${fromHexList} by hex decoding ${hexList[idx]}`
      );
    });
  }));
}));
"
test/fs/test-fs-promises-file-handle-append-file.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.appendFile method.

import fs from 'fs';
const { open } = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

async function validateAppendBuffer() {
  const filePath = path.resolve(tmpDir, 'tmp-append-file-buffer.txt');
  const fileHandle = await open(filePath, 'a');
  const buffer = Buffer.from('a&Dp'.repeat(100), 'utf8');

  await fileHandle.appendFile(buffer);
  const appendedFileData = fs.readFileSync(filePath);
  assert.deepStrictEqual(appendedFileData, buffer);

  await fileHandle.close();
}

async function validateAppendString() {
  const filePath = path.resolve(tmpDir, 'tmp-append-file-string.txt');
  const fileHandle = await open(filePath, 'a');
  const string = 'x~yz'.repeat(100);

  await fileHandle.appendFile(string);
  const stringAsBuffer = Buffer.from(string, 'utf8');
  const appendedFileData = fs.readFileSync(filePath);
  assert.deepStrictEqual(appendedFileData, stringAsBuffer);

  await fileHandle.close();
}

validateAppendBuffer()
  .then(validateAppendString)
  .then(common.mustCall());
"
test/fs/test-fs-existssync-false.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';

// This test ensures that fs.existsSync doesn't incorrectly return false.
// (especially on Windows)
// https://github.com/nodejs/node-v0.x-archive/issues/3739

import assert from 'assert';
import fs from 'fs';
import path from 'path';

let dir = path.resolve(tmpdir.path);

// Make sure that the tmp directory is clean
tmpdir.refresh();

// wasmedge no support so long path
// Make a long path.
for (let i = 0; i < 50; i++) {
  dir = `${dir}/1234567890`;
  try {
    fs.mkdirSync(dir, '0777');
  } catch (e) {
    if (e.code !== 'EEXIST') {
      throw e;
    }
  }
}

// Test if file exists synchronously
assert(fs.existsSync(dir), 'Directory is not accessible');

// Test if file exists asynchronously
fs.access(dir, common.mustSucceed());
"
test/fs/test-fs-mkdir-rmdir.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const d = path.join(tmpdir.path, 'dir');

tmpdir.refresh();

// Make sure the directory does not exist
assert(!fs.existsSync(d));
// Create the directory now
fs.mkdirSync(d);
// Make sure the directory exists
assert(fs.existsSync(d));
// Try creating again, it should fail with EEXIST
assert.throws(function() {
  fs.mkdirSync(d);
}, /EEXIST: file already exists, mkdir/);
// Remove the directory now
fs.rmdirSync(d);
// Make sure the directory does not exist
assert(!fs.existsSync(d));

// Similarly test the Async version
fs.mkdir(d, 0o666, common.mustSucceed(() => {
  fs.mkdir(d, 0o666, common.mustCall(function(err) {
    assert.strictEqual(this, undefined);
    assert.ok(err, 'got no error');
    assert.match(err.message, /^EEXIST/);
    assert.strictEqual(err.code, 'EEXIST');
    assert.strictEqual(err.path, d);

    fs.rmdir(d, assert.ifError);
  }));
}));
"
example_js/hello.js,"import * as os from 'os';
import * as std from 'std';
import * as process from 'process'

args = args.slice(1);
print('Hello', ...args);

let id = setTimeout(() => {
    print('setTimeout 2s cancel');
}, 2000);

print(id);
clearTimeout(id);

setTimeout(() => {
    print('setTimeout 2s');
}, 2000);

let env = process.env
for (var k in env) {
    print(k, '=', env[k])
}

let thenable = {
    data: 1,
    then(onFulfilled, onRejected) {
        print(""then:"")
        onFulfilled(2)
    }
}



async function xx() {
    let p = new Promise((r) => {
        nextTick(() => {
            print(""nextTick"")
            r(1)
        })
    })

    let a = sleep(() => {
        print('timeout 1s');
    }, 1000).then((v) => {
        return thenable;
    });
    let x = await p;
    print(""end await p"", x);
    let v = await a;
    print(""end xx"", v);
}

xx()

print('end main')

"
test/fs/test-fs-chown-type-check.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.chown(i, 1, 1, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chownSync(i, 1, 1),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});

[false, 'test', {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.chown('not_a_file_that_exists', i, 1, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chown('not_a_file_that_exists', 1, i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chownSync('not_a_file_that_exists', i, 1),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.chownSync('not_a_file_that_exists', 1, i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
example_js/tensorflow_lite_demo/wasi_nn_main.js,"import { Image } from 'image';
import * as fs from 'fs';
import { NnGraph, NnContext, TENSOR_TYPE_U8 } from 'wasi_nn';

let img = new Image(__dirname + '/food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let data = fs.readFileSync(__dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite')
let graph = new NnGraph([data.buffer], ""tensorflowlite"", ""cpu"");
let context = new NnContext(graph);
context.setInput(0, rgb_pix, [1, 192, 192, 3], TENSOR_TYPE_U8);
context.compute();

let output_view = new Uint8Array(2024);
context.getOutput(0, output_view.buffer)

let max = 0;
let max_idx = 0;
for (var i in output_view) {
    let v = output_view[i];
    if (v > max) {
        max = v;
        max_idx = i;
    }
}

let label_file = fs.readFileSync(__dirname + '/aiy_food_V1_labelmap.txt', 'utf-8');
let lables = label_file.split(/\r?\n/);

let label = lables[max_idx]

print('label:');
print(label);
print('confidence:');
print(max / 255);"
test/fs/test-fs-close-errors.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// This tests that the errors thrown from fs.close and fs.closeSync
// include the desired properties

import common from '../common';
import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

['', false, null, undefined, {}, []].forEach((input) => {
  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
    message: 'The ""fd"" argument must be of type number.' +
             common.invalidArgTypeHelper(input)
  };
  assert.throws(() => fs.close(input), errObj);
  assert.throws(() => fs.closeSync(input), errObj);
});

{
  // Test error when cb is not a function
  const fd = fs.openSync(__filename, 'r');

  const errObj = {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  };

  ['', false, null, {}, []].forEach((input) => {
    assert.throws(() => fs.close(fd, input), errObj);
  });

  fs.closeSync(fd);
}
"
test/fs/test-fs-fmap.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import { join } from 'path';

const {
  O_CREAT = 0,
  O_RDONLY = 0,
  O_TRUNC = 0,
  O_WRONLY = 0,
  UV_FS_O_FILEMAP = 0
} = fs.constants;

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// Run this test on all platforms. While UV_FS_O_FILEMAP is only available on
// Windows, it should be silently ignored on other platforms.

const filename = join(tmpdir.path, 'fmap.txt');
const text = 'Memory File Mapping Test';

const mw = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
const mr = UV_FS_O_FILEMAP | O_RDONLY;

fs.writeFileSync(filename, text, { flag: mw });
const r1 = fs.readFileSync(filename, { encoding: 'utf8', flag: mr });
assert.strictEqual(r1, text);"
test/crypto/test-crypto-keygen-deprecation.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --pending-deprecation

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const DeprecationWarning = [];
DeprecationWarning.push([
  '""options.hash"" is deprecated, use ""options.hashAlgorithm"" instead.',
  'DEP0154']);
DeprecationWarning.push([
  '""options.mgf1Hash"" is deprecated, use ""options.mgf1HashAlgorithm"" instead.',
  'DEP0154']);

common.expectWarning({ DeprecationWarning });

const assert = require('assert');
const { generateKeyPair } = require('crypto');

{
  // This test makes sure deprecated options still work as intended

  generateKeyPair('rsa-pss', {
    modulusLength: 512,
    saltLength: 16,
    hash: 'sha256',
    mgf1Hash: 'sha256'
  }, common.mustSucceed((publicKey, privateKey) => {
    assert.strictEqual(publicKey.type, 'public');
    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(publicKey.asymmetricKeyDetails, {
      modulusLength: 512,
      publicExponent: 65537n,
      hashAlgorithm: 'sha256',
      mgf1HashAlgorithm: 'sha256',
      saltLength: 16
    });

    assert.strictEqual(privateKey.type, 'private');
    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
    assert.deepStrictEqual(privateKey.asymmetricKeyDetails, {
      modulusLength: 512,
      publicExponent: 65537n,
      hashAlgorithm: 'sha256',
      mgf1HashAlgorithm: 'sha256',
      saltLength: 16
    });
  }));
}
"
example_js/wasi_http_echo.js,"import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  print(""server: req.httpVersion="", req.httpVersion);
  print(""server: req.url="", req.url);
  print(""server: req.method="", req.method);
  print(""server: req.headers="", Object.keys(req.headers));

  req.on('data', (body) => {
    print(""server: req.body="", body);
    print()

    resp.write('echo:')
    resp.end(body)
  })
}).listen(8001, () => {
  print('listen 8001 ...\n');
})

async function test_request() {
  let client = request({ href: ""http://127.0.0.1:8001/request"", method: 'POST' }, (resp) => {
    var data = '';
    resp.on('data', (chunk) => {
      data += chunk;
    })
    resp.on('end', () => {
      print('request client recv:', data)
      print()
    })
  })

  client.end('hello server')
}

async function test_fetch() {
  let resp = await fetch('http://127.0.0.1:8001/fetch', { method: 'POST', body: 'hello server' })
  print('fetch client recv:', await resp.text())
  print()
}

async function run_test() {
  await test_request()
  await test_fetch()
  exit(0)
}

run_test()
"
test/fs/test-fs-read-empty-buffer.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');
const fsPromises = fs.promises;

const buffer = new Uint8Array();

assert.throws(
  () => fs.readSync(fd, buffer, 0, 10, 0),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    message: /is empty and cannot be written/
  }
);

assert.throws(
  () => fs.read(fd, buffer, 0, 1, 0, common.mustNotCall()),
  {
    code: 'ERR_INVALID_ARG_VALUE',
    message: /is empty and cannot be written/
  }
);

(async () => {
  const filehandle = await fsPromises.open(filepath, 'r');
  assert.rejects(
    () => filehandle.read(buffer, 0, 1, 0),
    {
      code: 'ERR_INVALID_ARG_VALUE',
      message: /is empty and cannot be written/
    }
  );
})().then(common.mustCall());
"
example_js/react18_ssr/component/Post.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Post() {
  return (
    <>
      <h1>Hello world</h1>
      <p>
        This demo is <b>artificially slowed down</b>. Open{' '}
        <code>server/delays.js</code> to adjust how much different things are
        slowed down.
      </p>
      <p>
        Notice how HTML for comments ""streams in"" before the JS (or React) has
        loaded on the page.
      </p>
      <p>
        Also notice that the JS for comments and sidebar has been code-split,
        but HTML for it is still included in the server output.
      </p>
    </>
  );
}
"
modules/internal/streams/state.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import { ERR_INVALID_ARG_VALUE } from ""../errors.js"";

function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null
        ? options.highWaterMark
        : isDuplex
            ? options[duplexKey]
            : null;
}

function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name = isDuplex ? `options.${duplexKey}` : ""options.highWaterMark"";
            throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }

    // Default value
    return getDefaultHighWaterMark(state.objectMode);
}

export default {
    getHighWaterMark,
    getDefaultHighWaterMark,
};
export { getDefaultHighWaterMark, getHighWaterMark };"
test/crypto/test-crypto-dh-leak.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

// Flags: --expose-gc --noconcurrent_recompilation
'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');
if (process.config.variables.asan)
  common.skip('ASAN messes with memory measurements');

const assert = require('assert');
const crypto = require('crypto');

const before = process.memoryUsage.rss();
{
  const size = common.hasFipsCrypto || common.hasOpenSSL3 ? 1024 : 256;
  const dh = crypto.createDiffieHellman(size);
  const publicKey = dh.generateKeys();
  const privateKey = dh.getPrivateKey();
  for (let i = 0; i < 5e4; i += 1) {
    dh.setPublicKey(publicKey);
    dh.setPrivateKey(privateKey);
  }
}
global.gc();
const after = process.memoryUsage.rss();

// RSS should stay the same, ceteris paribus, but allow for
// some slop because V8 mallocs memory during execution.
assert(after - before < 10 << 20, `before=${before} after=${after}`);
"
test/path/test-path-normalize.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

/*
assert.strictEqual(path.win32.normalize('./fixtures///b/../b/c.js'),
                   'fixtures\\b\\c.js');
assert.strictEqual(path.win32.normalize('/foo/../../../bar'), '\\bar');
assert.strictEqual(path.win32.normalize('a//b//../b'), 'a\\b');
assert.strictEqual(path.win32.normalize('a//b//./c'), 'a\\b\\c');
assert.strictEqual(path.win32.normalize('a//b//.'), 'a\\b');
assert.strictEqual(path.win32.normalize('//server/share/dir/file.ext'),
                   '\\\\server\\share\\dir\\file.ext');
assert.strictEqual(path.win32.normalize('/a/b/c/../../../x/y/z'), '\\x\\y\\z');
assert.strictEqual(path.win32.normalize('C:'), 'C:.');
assert.strictEqual(path.win32.normalize('C:..\\abc'), 'C:..\\abc');
assert.strictEqual(path.win32.normalize('C:..\\..\\abc\\..\\def'),
                   'C:..\\..\\def');
assert.strictEqual(path.win32.normalize('C:\\.'), 'C:\\');
assert.strictEqual(path.win32.normalize('file:stream'), 'file:stream');
assert.strictEqual(path.win32.normalize('bar\\foo..\\..\\'), 'bar\\');
assert.strictEqual(path.win32.normalize('bar\\foo..\\..'), 'bar');
assert.strictEqual(path.win32.normalize('bar\\foo..\\..\\baz'), 'bar\\baz');
assert.strictEqual(path.win32.normalize('bar\\foo..\\'), 'bar\\foo..\\');
assert.strictEqual(path.win32.normalize('bar\\foo..'), 'bar\\foo..');
assert.strictEqual(path.win32.normalize('..\\foo..\\..\\..\\bar'),
                   '..\\..\\bar');
assert.strictEqual(path.win32.normalize('..\\...\\..\\.\\...\\..\\..\\bar'),
                   '..\\..\\bar');
assert.strictEqual(path.win32.normalize('../../../foo/../../../bar'),
                   '..\\..\\..\\..\\..\\bar');
assert.strictEqual(path.win32.normalize('../../../foo/../../../bar/../../'),
                   '..\\..\\..\\..\\..\\..\\');
assert.strictEqual(
  path.win32.normalize('../foobar/barfoo/foo/../../../bar/../../'),
  '..\\..\\'
);
assert.strictEqual(
  path.win32.normalize('../.../../foobar/../../../bar/../../baz'),
  '..\\..\\..\\..\\baz'
);
assert.strictEqual(path.win32.normalize('foo/bar\\baz'), 'foo\\bar\\baz');
*/
assert.strictEqual(path.posix.normalize('./fixtures///b/../b/c.js'),
                   'fixtures/b/c.js');
assert.strictEqual(path.posix.normalize('/foo/../../../bar'), '/bar');
assert.strictEqual(path.posix.normalize('a//b//../b'), 'a/b');
assert.strictEqual(path.posix.normalize('a//b//./c'), 'a/b/c');
assert.strictEqual(path.posix.normalize('a//b//.'), 'a/b');
assert.strictEqual(path.posix.normalize('/a/b/c/../../../x/y/z'), '/x/y/z');
assert.strictEqual(path.posix.normalize('///..//./foo/.//bar'), '/foo/bar');
assert.strictEqual(path.posix.normalize('bar/foo../../'), 'bar/');
assert.strictEqual(path.posix.normalize('bar/foo../..'), 'bar');
assert.strictEqual(path.posix.normalize('bar/foo../../baz'), 'bar/baz');
assert.strictEqual(path.posix.normalize('bar/foo../'), 'bar/foo../');
assert.strictEqual(path.posix.normalize('bar/foo..'), 'bar/foo..');
assert.strictEqual(path.posix.normalize('../foo../../../bar'), '../../bar');
assert.strictEqual(path.posix.normalize('../.../.././.../../../bar'),
                   '../../bar');
assert.strictEqual(path.posix.normalize('../../../foo/../../../bar'),
                   '../../../../../bar');
assert.strictEqual(path.posix.normalize('../../../foo/../../../bar/../../'),
                   '../../../../../../');
assert.strictEqual(
  path.posix.normalize('../foobar/barfoo/foo/../../../bar/../../'),
  '../../'
);
assert.strictEqual(
  path.posix.normalize('../.../../foobar/../../../bar/../../baz'),
  '../../../../baz'
);
assert.strictEqual(path.posix.normalize('foo/bar\\baz'), 'foo/bar\\baz');
"
test/fs/test-fs-write-stream-file-handle-2.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'write_stream_filehandle_test.txt');
const input = 'hello world';

tmpdir.refresh();

fs.promises.open(file, 'w+').then((handle) => {
  let calls = 0;
  const {
    write: originalWriteFunction,
    writev: originalWritevFunction
  } = handle;
  handle.write = function write() {
    calls++;
    return Reflect.apply(originalWriteFunction, this, arguments);
  };
  handle.writev = function writev() {
    calls++;
    return Reflect.apply(originalWritevFunction, this, arguments);
  };
  const stream = fs.createWriteStream(null, { fd: handle });

  stream.end(input);
  stream.on('close', common.mustCall(() => {
    assert(calls > 0, 'expected at least one call to fileHandle.write or ' +
    'fileHandle.writev, got 0');
  }));
}).then(common.mustCall());
"
example_js/tensorflow_lite_demo/main.js,"import {Image} from 'image';
import * as std from 'std';
import {TensorflowLiteSession} from 'tensorflow_lite';

let img = new Image(__dirname + '/food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let session = new TensorflowLiteSession(
    __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite');
session.add_input('input', rgb_pix);
session.run();
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v > max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open(__dirname + '/aiy_food_V1_labelmap.txt', 'r');
let label = '';
for (var i = 0; i <= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max / 255);
"
test/crypto/test-crypto-subtle-zero-length.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto').webcrypto;

(async () => {
  const k = await crypto.subtle.importKey(
    'raw',
    new Uint8Array(32),
    { name: 'AES-GCM' },
    false,
    [ 'encrypt', 'decrypt' ]);
  assert(k instanceof crypto.CryptoKey);

  const e = await crypto.subtle.encrypt({
    name: 'AES-GCM',
    iv: new Uint8Array(12),
  }, k, new Uint8Array(0));
  assert(e instanceof ArrayBuffer);
  assert.deepStrictEqual(
    Buffer.from(e),
    Buffer.from([
      0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9,
      0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b ]));

  const v = await crypto.subtle.decrypt({
    name: 'AES-GCM',
    iv: new Uint8Array(12),
  }, k, e);
  assert(v instanceof ArrayBuffer);
  assert.strictEqual(v.byteLength, 0);
})().then(common.mustCall()).catch((e) => {
  assert.ifError(e);
});
"
example_js/create-react-app-ssr/package.json,"{
  ""name"": ""create-react-app-ssr"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""dependencies"": {
    ""@testing-library/jest-dom"": ""^5.16.2"",
    ""@testing-library/react"": ""^12.1.4"",
    ""@testing-library/user-event"": ""^13.5.0"",
    ""react"": ""^17.0.2"",
    ""react-dom"": ""^17.0.2"",
    ""react-scripts"": ""5.0.0"",
    ""web-vitals"": ""^2.1.4""
  },
  ""scripts"": {
    ""start"": ""react-scripts start"",
    ""build"": ""react-scripts build"",
    ""test"": ""react-scripts test"",
    ""eject"": ""react-scripts eject"",
    ""webpack:build-server"": ""NODE_ENV=development webpack --config webpack.server.js --mode=development"",
    ""rollup:build-server"": ""rollup -c rollup.server.js""
  },
  ""eslintConfig"": {
    ""extends"": [
      ""react-app"",
      ""react-app/jest""
    ]
  },
  ""browserslist"": {
    ""production"": [
      "">0.2%"",
      ""not dead"",
      ""not op_mini all""
    ],
    ""development"": [
      ""last 1 chrome version"",
      ""last 1 firefox version"",
      ""last 1 safari version""
    ]
  },
  ""devDependencies"": {
    ""svg-url-loader"": ""^7.1.1"",
    ""webpack-cli"": ""^4.9.2"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-async"": ""^1.2.0"",
    ""rollup-plugin-import-css"": ""^3.0.3"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-svg"": ""^2.0.0""
  }
}
"
test/fs/test-fs-mkdtemp.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const tmpFolder = fs.mkdtempSync(path.join(tmpdir.path, 'foo.'));

assert.strictEqual(path.basename(tmpFolder).length, 'foo.XXXXXX'.length);
assert(fs.existsSync(tmpFolder));

const utf8 = fs.mkdtempSync(path.join(tmpdir.path, '\u0222abc.'));
assert.strictEqual(Buffer.byteLength(path.basename(utf8)),
                   Buffer.byteLength('\u0222abc.XXXXXX'));
assert(fs.existsSync(utf8));

function handler(err, folder) {
  assert.ifError(err);
  assert(fs.existsSync(folder));
  assert.strictEqual(this, undefined);
}

fs.mkdtemp(path.join(tmpdir.path, 'bar.'), common.mustCall(handler));

// Same test as above, but making sure that passing an options object doesn't
// affect the way the callback function is handled.
fs.mkdtemp(path.join(tmpdir.path, 'bar.'), {}, common.mustCall(handler));

const warningMsg = 'mkdtemp() templates ending with X are not portable. ' +
                   'For details see: https://nodejs.org/api/fs.html';
common.expectWarning('Warning', warningMsg);
fs.mkdtemp(path.join(tmpdir.path, 'bar.X'), common.mustCall(handler));
"
example_js/tensorflow_demo/main.js,"import {Image} from 'image';
import * as std from 'std';
import {TensorflowSession} from 'tensorflow';

let img = new Image('bird.png');
let img_rgb = img.to_rgb().resize(224, 224);
let rgb_pix = img_rgb.pixels_32f();

let session = new TensorflowSession('mobilenet_v2_1.4_224_frozen.pb');
session.add_input_32f('input', rgb_pix, [1, 224, 224, 3]);
session.add_output('MobilenetV2/Predictions/Softmax');
session.run();
let output = session.get_output('MobilenetV2/Predictions/Softmax');
let output_view = new Float32Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v > max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open('imagenet_slim_labels.txt', 'r');
let label = '';
for (var i = 0; i <= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max);
"
test/fs/test-fs-promisified.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';

const read = promisify(fs.read);
const write = promisify(fs.write);
const exists = promisify(fs.exists);

const __filename = args[0];

{
  const fd = fs.openSync(__filename, 'r');
  read(fd, Buffer.alloc(1024), 0, 1024, null).then(common.mustCall((obj) => {
    assert.strictEqual(typeof obj.bytesRead, 'number');
    assert(obj.buffer instanceof Buffer);
    fs.closeSync(fd);
  }));
}

import tmpdir from '../common/tmpdir';
tmpdir.refresh();
{
  const filename = path.join(tmpdir.path, 'write-promise.txt');
  const fd = fs.openSync(filename, 'w');
  write(fd, Buffer.from('foobar')).then(common.mustCall((obj) => {
    assert.strictEqual(typeof obj.bytesWritten, 'number');
    assert.strictEqual(obj.buffer.toString(), 'foobar');
    fs.closeSync(fd);
  }));
}

{
  exists(__filename).then(common.mustCall((x) => {
    assert.strictEqual(x, true);
  }));
}
"
test/fs/test-fs-readfilesync-pipe-large.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// Simulate `cat readfile.js | node readfile.js`

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';
import path from 'path';
import fs from 'fs';

if (process.argv[2] === 'child') {
  process.stdout.write(fs.readFileSync('/dev/stdin', 'utf8'));
  return;
}

import tmpdir from '../common/tmpdir';

const filename = path.join(tmpdir.path, '/readfilesync_pipe_large_test.txt');
const dataExpected = 'a'.repeat(999999);
tmpdir.refresh();
fs.writeFileSync(filename, dataExpected);

import { exec } from 'child_process';
const f = JSON.stringify(__filename);
const node = JSON.stringify(process.execPath);
const cmd = `cat ${filename} | ${node} ${f} child`;
exec(
  cmd,
  { maxBuffer: 1000000 },
  common.mustSucceed((stdout, stderr) => {
    assert.strictEqual(stdout, dataExpected);
    assert.strictEqual(stderr, '');
    console.log('ok');
  })
);
"
src/main.rs,"#![allow(dead_code, unused_imports, unused_must_use)]

use std::borrow::{Borrow, BorrowMut};
use wasmedge_quickjs::*;

fn args_parse() -> (String, Vec<String>) {
    use argparse::ArgumentParser;
    let mut file_path = String::new();
    let mut res_args: Vec<String> = vec![];
    {
        let mut ap = ArgumentParser::new();
        ap.refer(&mut file_path)
            .add_argument(""file"", argparse::Store, ""js file"")
            .required();
        ap.refer(&mut res_args)
            .add_argument(""arg"", argparse::List, ""arg"");
        ap.parse_args_or_exit();
    }
    (file_path, res_args)
}

#[tokio::main(flavor = ""current_thread"")]
async fn main() {
    use wasmedge_quickjs as q;
    env_logger::init();

    let mut rt = q::Runtime::new();

    let r = rt
        .async_run_with_context(Box::new(|ctx| {
            let (file_path, mut rest_arg) = args_parse();
            let code = std::fs::read_to_string(&file_path);
            match code {
                Ok(code) => {
                    rest_arg.insert(0, file_path.clone());
                    ctx.put_args(rest_arg);
                    ctx.eval_buf(code.into_bytes(), &file_path, 1)
                }
                Err(e) => {
                    eprintln!(""{}"", e.to_string());
                    JsValue::UnDefined
                }
            }
        }))
        .await;
    log::info!(""{r:?}"");
}
"
test/fs/test-fs-promises-file-handle-sync.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import fixtures from '../common/fixtures';
import tmpdir from '../common/tmpdir';

import { access, copyFile, open } from 'fs/promises';
import path from 'path';

async function validate() {
  tmpdir.refresh();
  const dest = path.resolve(tmpdir.path, 'baz.js');
  await assert.rejects(
    copyFile(fixtures.path('baz.js'), dest, 'r'),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      message: /mode.*number.*string/
    }
  );
  await copyFile(fixtures.path('baz.js'), dest);
  await assert.rejects(
    access(dest, 'r'),
    { code: 'ERR_INVALID_ARG_TYPE', message: /mode/ }
  );
  await access(dest);
  const handle = await open(dest, 'r+');
  await handle.datasync();
  await handle.sync();
  const buf = Buffer.from('hello world');
  await handle.write(buf);
  const ret = await handle.read(Buffer.alloc(11), 0, 11, 0);
  assert.strictEqual(ret.bytesRead, 11);
  assert.deepStrictEqual(ret.buffer, buf);
  await handle.close();
}

validate();
"
test/common/fixtures.js,"use strict';

import path from 'path';
import fs from 'fs';
import { pathToFileURL } from 'url';

const __dirname = path.join(args[0], '..');

const fixturesDir = path.join(__dirname, '..', 'fixtures');

function fixturesPath(...args) {
  return path.join(fixturesDir, ...args);
}

function fixturesFileURL(...args) {
  return pathToFileURL(fixturesPath(...args));
}

function readFixtureSync(args, enc) {
  if (Array.isArray(args))
    return fs.readFileSync(fixturesPath(...args), enc);
  return fs.readFileSync(fixturesPath(args), enc);
}

function readFixtureKey(name, enc) {
  return fs.readFileSync(fixturesPath('keys', name), enc);
}

function readFixtureKeys(enc, ...names) {
  return names.map((name) => readFixtureKey(name, enc));
}

export {
  fixturesDir,
  fixturesPath as path,
  fixturesFileURL as fileURL,
  readFixtureSync as readSync,
  readFixtureKey as readKey,
  readFixtureKeys as readKeys,
};

export default {
  fixturesDir,
  path: fixturesPath,
  fileURL: fixturesFileURL,
  readSync: readFixtureSync,
  readKey: readFixtureKey,
  readKeys: readFixtureKeys,
}
"
test/fs/test-fs-write-stream-patch-open.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

import assert from 'assert';
import { fork } from 'child_process';

// Run in a child process because 'out' is opened twice, blocking the tmpdir
// and preventing cleanup.
if (process.argv[2] !== 'child') {
  // Parent

  tmpdir.refresh();

  // Run test
  const child = fork(__filename, ['child'], { stdio: 'inherit' });
  child.on('exit', common.mustCall(function(code) {
    assert.strictEqual(code, 0);
  }));

  return;
}

// Child

common.expectWarning(
  'DeprecationWarning',
  'WriteStream.prototype.open() is deprecated', 'DEP0135');
const s = fs.createWriteStream(`${tmpdir.path}/out`);
s.open();

process.nextTick(() => {
  // Allow overriding open().
  fs.WriteStream.prototype.open = common.mustCall();
  fs.createWriteStream('asd');
});
"
example_js/wasi_net_timeout_echo.js,"import * as net from 'wasi_net';
import { TextDecoder } from 'util'


async function handle_client(cs) {
  print(cs.peer());
  let timeout_millis = 5000;
  while (true) {
    try {
      let d = await cs.read(timeout_millis);
      if (d.byteLength <= 0) {
        break;
      }
      let s = new TextDecoder().decode(d)
      print('recv:', s);
      cs.write('echo:' + s);
    } catch (e) {
      print('handle_client err:', e);
      break;
    }
  }
  print('close');
}

async function server_start() {
  print('listen 8000 ...');
  let s = new net.WasiTcpServer(8000);
  let timeout_millis = 5000;
  for (var i = 0; i < 10; i++) {
    try {
      let cs = await s.accept(timeout_millis);
      handle_client(cs);
    } catch (e) {
      print('accept err:', e);
    }
  }
}


server_start();
"
modules/internal/util/colors.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import process from ""process"";

let blue = '';
let green = '';
let white = '';
let red = '';
let clear = '';
let hasColors = false;
export function refresh() {
  if (true || process.stderr.isTTY) {
    hasColors = true || process.stderr.hasColors();
    blue = hasColors ? '\u001b[34m' : '';
    green = hasColors ? '\u001b[32m' : '';
    white = hasColors ? '\u001b[39m' : '';
    red = hasColors ? '\u001b[31m' : '';
    clear = hasColors ? '\u001bc' : '';
    hasColors = hasColors;
  }
}

export {
  blue,
  green,
  white,
  red,
  clear,
  hasColors
}

refresh();
"
test/fs/test-fs-watch-abort-signal.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// Flags: --expose-internals
'use strict';

// Verify that AbortSignal integration works for fs.watch

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import fs from 'fs';
import fixtures from '../common/fixtures';


{
  // Signal aborted after creating the watcher
  const file = fixtures.path('empty.js');
  const ac = new AbortController();
  const { signal } = ac;
  const watcher = fs.watch(file, { signal });
  watcher.once('close', common.mustCall());
  setImmediate(() => ac.abort());
}
{
  // Signal aborted before creating the watcher
  const file = fixtures.path('empty.js');
  const signal = AbortSignal.abort();
  const watcher = fs.watch(file, { signal });
  watcher.once('close', common.mustCall());
}
"
test/fs/test-fs-filehandle-use-after-close.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs/promises';

const __filename = args[0];

(async () => {
  const filehandle = await fs.open(__filename);

  assert.notStrictEqual(filehandle.fd, -1);
  await filehandle.close();
  assert.strictEqual(filehandle.fd, -1);

  // Open another file handle first. This would typically receive the fd
  // that `filehandle` previously used. In earlier versions of Node.js, the
  // .stat() call would then succeed because it still used the original fd;
  // See https://github.com/nodejs/node/issues/31361 for more details.
  const otherFilehandle = await fs.open(""test/fixtures/x.txt"");

  assert.rejects(() => filehandle.stat(), {
    code: 'EBADF',
    syscall: 'fstat'
  });

  await otherFilehandle.close();
})().then(common.mustCall());
"
test/crypto/test-crypto-update-encoding.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const crypto = require('crypto');

const zeros = Buffer.alloc;
const key = zeros(16);
const iv = zeros(16);

const cipher = () => crypto.createCipheriv('aes-128-cbc', key, iv);
const decipher = () => crypto.createDecipheriv('aes-128-cbc', key, iv);
const hash = () => crypto.createSign('sha256');
const hmac = () => crypto.createHmac('sha256', key);
const sign = () => crypto.createSign('sha256');
const verify = () => crypto.createVerify('sha256');

for (const f of [cipher, decipher, hash, hmac, sign, verify])
  for (const n of [15, 16])
    f().update(zeros(n), 'hex');  // Should ignore inputEncoding.
"
test/fs/test-fs-rmdir-recursive-throws-on-file.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

const code = common.isWindows ? 'ENOENT' : 'ENOTDIR';

{
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  assert.throws(() => fs.rmdirSync(filePath, { recursive: true }), { code });
}
{
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  fs.rmdir(filePath, { recursive: true }, common.mustCall((err) => {
    assert.strictEqual(err.code, code);
  }));
}
{
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  assert.rejects(() => fs.promises.rmdir(filePath, { recursive: true }),
                 { code }).then(common.mustCall());
}
"
test/fs/test-fs-symlink-longpath.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();
const tmpDir = tmpdir.path;
const longPath = path.join(...[tmpDir].concat(Array(30).fill('1234567890')));
fs.mkdirSync(longPath, { recursive: true });

// Test if we can have symlinks to files and folders with long filenames
const targetDirectory = path.join(longPath, 'target-directory');
fs.mkdirSync(targetDirectory);
const pathDirectory = path.join(tmpDir, 'new-directory');
fs.symlink(targetDirectory, pathDirectory, 'dir', common.mustSucceed(() => {
  assert(fs.existsSync(pathDirectory));
}));

const targetFile = path.join(longPath, 'target-file');
fs.writeFileSync(targetFile, 'data');
const pathFile = path.join(tmpDir, 'new-file');
fs.symlink(targetFile, pathFile, common.mustSucceed(() => {
  assert(fs.existsSync(pathFile));
}));
"
example_js/wasi_https_fetch.js,"import { fetch } from 'http'

async function test_fetch() {
    try {
        print('test_fetch start')
        let r = await fetch('https://httpbin.org/get?id=1')
        print('test_fetch\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch()

async function test_fetch_post() {
    try {
        print('test_fetch_post start')
        let r = await fetch(""https://httpbin.org/post"", { method: 'post', 'body': 'post_body' })
        print('test_fetch_post\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_post()

async function test_fetch_put() {
    try {
        print('test_fetch_put start')
        let r = await fetch(""https://httpbin.org/put"",
            {
                method: ""put"",
                body: JSON.stringify({ a: 1 }),
                headers: { 'Context-type': 'application/json' }
            })
        print('test_fetch_put\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_put()"
test/fs/test-fs-watch-stop-sync.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// This test checks that the `stop` event is emitted asynchronously.
//
// If it isn't asynchronous, then the listener will be called during the
// execution of `watch.stop()`. That would be a bug.
//
// If it is asynchronous, then the listener will be removed before the event is
// emitted.

import fs from 'fs';

const listener = common.mustNotCall(
  'listener should have been removed before the event was emitted'
);

const watch = fs.watchFile(__filename, common.mustNotCall());
watch.once('stop', listener);
watch.stop();
watch.removeListener('stop', listener);
"
test/fs/test-fs-write-stream-encoding.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import fixtures from '../common/fixtures';
import fs from 'fs';
import path from 'path';
import stream from 'stream';
import tmpdir from '../common/tmpdir';
const firstEncoding = 'base64';
const secondEncoding = 'latin1';

const examplePath = fixtures.path('x.txt');
const dummyPath = path.join(tmpdir.path, 'x.txt');

tmpdir.refresh();

const exampleReadStream = fs.createReadStream(examplePath, {
  encoding: firstEncoding
});

const dummyWriteStream = fs.createWriteStream(dummyPath, {
  encoding: firstEncoding
});

exampleReadStream.pipe(dummyWriteStream).on('finish', function() {
  const assertWriteStream = new stream.Writable({
    write: function(chunk, enc, next) {
      const expected = Buffer.from('xyz\n');
      assert(chunk.equals(expected));
    }
  });
  assertWriteStream.setDefaultEncoding(secondEncoding);
  fs.createReadStream(dummyPath, {
    encoding: secondEncoding
  }).pipe(assertWriteStream);
});
"
test/crypto/test-crypto-classes.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
const assert = require('assert');

if (!common.hasCrypto) {
  common.skip('missing crypto');
  return;
}
const crypto = require('crypto');

// 'ClassName' : ['args', 'for', 'constructor']
const TEST_CASES = {
  'Hash': ['sha1'],
  'Hmac': ['sha1', 'Node'],
  'Cipheriv': ['des-ede3-cbc', '0123456789abcd0123456789', '12345678'],
  'Decipheriv': ['des-ede3-cbc', '0123456789abcd0123456789', '12345678'],
  'Sign': ['RSA-SHA1'],
  'Verify': ['RSA-SHA1'],
  'DiffieHellman': [1024],
  'DiffieHellmanGroup': ['modp5'],
  'ECDH': ['prime256v1'],
};

if (!common.hasFipsCrypto) {
  TEST_CASES.Cipher = ['aes192', 'secret'];
  TEST_CASES.Decipher = ['aes192', 'secret'];
  TEST_CASES.DiffieHellman = [common.hasOpenSSL3 ? 1024 : 256];
}

for (const [clazz, args] of Object.entries(TEST_CASES)) {
  assert(crypto[`create${clazz}`](...args) instanceof crypto[clazz]);
}
"
test/fs/test-fs-open-no-close.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

// Refs: https://github.com/nodejs/node/issues/34266
// Failing to close a file should not keep the event loop open.

import common from '../common';
import assert from 'assert';

import fs from 'fs';

import process from 'process';

const debuglog = (arg) => {
  console.log(new Date().toLocaleString(), arg);
};

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

let openFd;

fs.open(`${tmpdir.path}/dummy`, 'wx+', common.mustCall((err, fd) => {
  debuglog('fs open() callback');
  assert.ifError(err);
  openFd = fd;
}));
debuglog('waiting for callback');

// test_fs's runner will invoke this
globalThis._onExit = common.mustCall(() => {
  if (openFd) {
    fs.closeSync(openFd);
  }
});
"
test/fs/test-fs-readdir-ucs2.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
if (!common.isLinux)
  common.skip('Test is linux specific.');

import path from 'path';
import fs from 'fs';
import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();
const filename = '\uD83D\uDC04';
const root = Buffer.from(`${tmpdir.path}${path.sep}`);
const filebuff = Buffer.from(filename, 'ucs2');
const fullpath = Buffer.concat([root, filebuff]);

try {
  fs.closeSync(fs.openSync(fullpath, 'w+'));
} catch (e) {
  if (e.code === 'EINVAL')
    common.skip('test requires filesystem that supports UCS2');
  throw e;
}

fs.readdir(tmpdir.path, 'ucs2', common.mustSucceed((list) => {
  assert.strictEqual(list.length, 1);
  const fn = list[0];
  assert.deepStrictEqual(Buffer.from(fn, 'ucs2'), filebuff);
  assert.strictEqual(fn, filename);
}));
"
src/internal_module/httpx/core/chunk.rs,"use std::{
    io::{BufRead, Cursor},
    ops::Index,
};

use super::ParseError;

pub struct HttpChunk;

impl HttpChunk {
    pub fn parse(buf: &[u8]) -> Result<(&[u8], usize), ParseError> {
        let mut c = Cursor::new(buf);
        let mut header = String::new();
        let n = c
            .read_line(&mut header)
            .map_err(|_| ParseError::InvalidChunk)?;
        if n == 0 {
            return Err(ParseError::Pending);
        }

        let len = usize::from_str_radix(header.trim(), 16).map_err(|_| ParseError::InvalidChunk)?;

        let r_buf = buf.get(n..n + len).ok_or(ParseError::Pending)?;

        c.set_position((n + len) as u64);

        let mut end = header;
        let end_n = c
            .read_line(&mut end)
            .map_err(|_| ParseError::InvalidChunk)?;

        if end_n == 0 {
            return Err(ParseError::Pending);
        }

        Ok((r_buf, n + len + end_n))
    }
}
"
test/fs/test-fs-write-stream-double-close.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  const s = fs.createWriteStream(path.join(tmpdir.path, 'rw'));

  s.close(common.mustCall());
  s.close(common.mustCall());
}

{
  const s = fs.createWriteStream(path.join(tmpdir.path, 'rw2'));

  let emits = 0;
  s.on('close', () => {
    emits++;
  });

  s.close(common.mustCall(() => {
    assert.strictEqual(emits, 1);
    s.close(common.mustCall(() => {
      assert.strictEqual(emits, 1);
    }));
    process.nextTick(() => {
      s.close(common.mustCall(() => {
        assert.strictEqual(emits, 1);
      }));
    });
  }));
}

{
  const s = fs.createWriteStream(path.join(tmpdir.path, 'rw'), {
    autoClose: false
  });

  s.close(common.mustCall());
  s.close(common.mustCall());
}
"
test/fs/test-fs-promises-writefile-typedarray.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
const fsPromises = fs.promises;
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
const tmpDir = tmpdir.path;

tmpdir.refresh();

const dest = path.resolve(tmpDir, 'tmp.txt');
const buffer = Buffer.from('012'.repeat(2 ** 10));

(async () => {
  for (const Constructor of [Uint8Array, Uint16Array, Uint32Array]) {
    const { BYTES_PER_ELEMENT = 1 } = Constructor;
    const array = new Constructor(buffer.buffer, buffer.byteOffset, buffer.byteLength / BYTES_PER_ELEMENT);
    await fsPromises.writeFile(dest, array);
    const data = await fsPromises.readFile(dest);
    assert.deepStrictEqual(data, buffer);
  }
})().then(common.mustCall());
"
test/fs/test-fs-realpath-pipe.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

if (common.isWindows || common.isAIX)
  common.skip(`No /dev/stdin on ${process.platform}.`);

import assert from 'assert';

import { spawnSync } from 'child_process';

for (const code of [
  `require('fs').realpath('/dev/stdin', (err, resolvedPath) => {
    if (err) {
      console.error(err);
      process.exit(1);
    }
    if (resolvedPath) {
      process.exit(2);
    }
  });`,
  `try {
    if (require('fs').realpathSync('/dev/stdin')) {
      process.exit(2);
    }
  } catch (e) {
    console.error(e);
    process.exit(1);
  }`,
]) {
  const child = spawnSync(process.execPath, ['-e', code], {
    stdio: 'pipe'
  });
  if (child.status !== 2) {
    console.log(code);
    console.log(child.stderr.toString());
  }
  assert.strictEqual(child.status, 2);
}
"
test/fs/test-fs-stream-destroy-emit-error.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  const stream = fs.createReadStream(__filename);
  stream.on('close', common.mustCall());
  test(stream);
}

{
  const stream = fs.createWriteStream(`${tmpdir.path}/dummy`);
  stream.on('close', common.mustCall());
  test(stream);
}

{
  const stream = fs.createReadStream(__filename, { emitClose: true });
  stream.on('close', common.mustCall());
  test(stream);
}

{
  const stream = fs.createWriteStream(`${tmpdir.path}/dummy2`,
                                      { emitClose: true });
  stream.on('close', common.mustCall());
  test(stream);
}


function test(stream) {
  const err = new Error('DESTROYED');
  stream.on('open', function() {
    stream.destroy(err);
  });
  stream.on('error', common.mustCall(function(err_) {
    assert.strictEqual(err_, err);
  }));
}
"
test/fs/test-fs-truncate-fd.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const tmp = tmpdir.path;
tmpdir.refresh();
const filename = path.resolve(tmp, 'truncate-file.txt');

fs.writeFileSync(filename, 'hello world', 'utf8');
const fd = fs.openSync(filename, 'r+');

const msg = 'Using fs.truncate with a file descriptor is deprecated.' +
  ' Please use fs.ftruncate with a file descriptor instead.';


common.expectWarning('DeprecationWarning', msg, 'DEP0081');
fs.truncate(fd, 5, common.mustSucceed(() => {
  assert.strictEqual(fs.readFileSync(filename, 'utf8'), 'hello');
}));

globalThis.commonExitCheck = () => {
  fs.closeSync(fd);
  fs.unlinkSync(filename);
  console.log('ok');
};
"
example_js/react18_ssr/component/Html.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'

export default function Html({ assets, children, title }) {

  return (
    <html lang=""en"">
      <head>
        <meta charSet=""utf-8"" />
        <meta name=""viewport"" content=""width=device-width, initial-scale=1"" />
        <link rel=""stylesheet"" href={assets['main.css']} />
        <title>{title}</title>
      </head>
      <body>
        <noscript
          dangerouslySetInnerHTML={{
            __html: `<b>Enable JavaScript to run this app.</b>`,
          }}
        />
        {children}
        <script
          dangerouslySetInnerHTML={{
            __html: `assetManifest = ${JSON.stringify(assets)};`,
          }}
        />
      </body>
    </html>
  );
}
"
test/fs/test-fs-stream-options.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import { mustNotMutateObjectDeep } from '../common';

import assert from 'assert';
import fs from 'fs';

{
  const fd = 'k';

  assert.throws(
    () => {
      fs.createReadStream(null, mustNotMutateObjectDeep({ fd }));
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => {
      fs.createWriteStream(null, mustNotMutateObjectDeep({ fd }));
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}

{
  const path = 46;

  assert.throws(
    () => {
      fs.createReadStream(path);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });

  assert.throws(
    () => {
      fs.createWriteStream(path);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
}
"
example_js/wasi_http_fetch.js,"import { fetch } from 'http'

async function test_fetch() {
    try {
        let r = await fetch('http://httpbin.org/get?id=1')
        print('test_fetch\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch()

async function test_fetch_post() {
    try {
        let r = await fetch(""http://httpbin.org/post"", { method: 'post', 'body': 'post_body' })
        print('test_fetch_post\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_post()

async function test_fetch_put() {
    try {
        let r = await fetch(""http://httpbin.org/put"",
            {
                method: ""put"",
                body: JSON.stringify({ a: 1 }),
                headers: { 'Context-type': 'application/json' }
            })
        print('test_fetch_put\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_put()"
test/fs/test-fs-readfilesync-enoent.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

// This test is only relevant on Windows.
if (!common.isWindows)
  common.skip('Windows specific test.');

// This test ensures fs.realpathSync works on properly on Windows without
// throwing ENOENT when the path involves a fileserver.
// https://github.com/nodejs/node-v0.x-archive/issues/3542

import assert from 'assert';
import fs from 'fs';
import os from 'os';
import path from 'path';

function test(p) {
  const result = fs.realpathSync(p);
  assert.strictEqual(result.toLowerCase(), path.resolve(p).toLowerCase());

  fs.realpath(p, common.mustSucceed((result) => {
    assert.strictEqual(result.toLowerCase(), path.resolve(p).toLowerCase());
  }));
}

test(`//${os.hostname()}/c$/Windows/System32`);
test(`//${os.hostname()}/c$/Windows`);
test(`//${os.hostname()}/c$/`);
test(`\\\\${os.hostname()}\\c$\\`);
test('C:\\');
test('C:');
test(process.env.windir);
"
test/crypto/test-crypto-dh-modp2-views.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const { modp2buf } = require('../common/crypto');

const modp2 = crypto.createDiffieHellmanGroup('modp2');

const views = common.getArrayBufferViews(modp2buf);
for (const buf of [modp2buf, ...views]) {
  // Ensure specific generator (string with encoding) works as expected with
  // any ArrayBufferViews as the first argument to createDiffieHellman().
  const exmodp2 = crypto.createDiffieHellman(buf, '02', 'hex');
  modp2.generateKeys();
  exmodp2.generateKeys();
  const modp2Secret = modp2.computeSecret(exmodp2.getPublicKey())
      .toString('hex');
  const exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey())
      .toString('hex');
  assert.strictEqual(modp2Secret, exmodp2Secret);
}
"
test/fixtures/keys/ca5.cnf,"[ ca ]
default_ca      = CA_default

[ CA_default ]
serial = ca5-serial
crl = ca5-crl.pem
database = ca5-database.txt
name_opt = CA_default
cert_opt = CA_default
default_crl_days = 999
default_md = sha512
x509_extensions        = v3_ca


[ req ]
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = The Node.js Foundation
OU                     = Node.js
CN                     = ca5
emailAddress           = ca5@example.org

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
basicConstraints = CA:TRUE
"
example_js/create-react-app-ssr/rollup.server.js,"const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');
const css = require(""rollup-plugin-import-css"");
const svg = require('rollup-plugin-svg');

const babelOptions = {
  babelrc: false,
  presets: [
    '@babel/preset-react'
  ],
  babelHelpers: 'bundled'
};

module.exports = [
  {
    input: './server/index.js',
    output: {
      file: 'server-build/index.js',
      format: 'esm',
    },
    external: [ 'std', 'wasi_net','wasi_http'],
    plugins: [
      plugin_async(),
      babel(babelOptions),
      nodeResolve({preferBuiltins: true}),
      commonjs({ignoreDynamicRequires: false}),
      css(),
      svg({base64: true}),
      globals(),
      builtins(),
      replace({
        preventAssignment: true,	
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
"
test/fs/test-fs-read-promises-optional-params.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import { promisify } from 'util';
const read = promisify(fs.read);
import assert from 'assert';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');

const expected = Buffer.from('xyz\n');
const defaultBufferAsync = Buffer.alloc(16384);
const bufferAsOption = Buffer.allocUnsafe(expected.byteLength);

read(fd, common.mustNotMutateObjectDeep({}))
  .then(function({ bytesRead, buffer }) {
    assert.strictEqual(bytesRead, expected.byteLength);
    assert.deepStrictEqual(defaultBufferAsync.byteLength, buffer.byteLength);
  })
  .then(common.mustCall());

read(fd, bufferAsOption, common.mustNotMutateObjectDeep({ position: 0 }))
  .then(function({ bytesRead, buffer }) {
    assert.strictEqual(bytesRead, expected.byteLength);
    assert.deepStrictEqual(bufferAsOption.byteLength, buffer.byteLength);
  })
  .then(common.mustCall());
"
test/crypto/test-crypto-des3-wrap.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

// Test case for des-ede3 wrap/unwrap. des3-wrap needs extra 2x blocksize
// then plaintext to store ciphertext.
const test = {
  key: Buffer.from('3c08e25be22352910671cfe4ba3652b1220a8a7769b490ba', 'hex'),
  iv: Buffer.alloc(0),
  plaintext: '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBG' +
    'WWELweCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZU' +
    'JjAfaFg**'
};

const cipher = crypto.createCipheriv('des3-wrap', test.key, test.iv);
const ciphertext = cipher.update(test.plaintext, 'utf8');

const decipher = crypto.createDecipheriv('des3-wrap', test.key, test.iv);
const msg = decipher.update(ciphertext, 'buffer', 'utf8');

assert.strictEqual(msg, test.plaintext);
"
test/crypto/test-crypto-lazy-transform-writable.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const Stream = require('stream');

const hasher1 = crypto.createHash('sha256');
const hasher2 = crypto.createHash('sha256');

// Calculate the expected result.
hasher1.write(Buffer.from('hello world'));
hasher1.end();

const expected = hasher1.read().toString('hex');

class OldStream extends Stream {
  constructor() {
    super();
    this.readable = true;
  }
}

const stream = new OldStream();

stream.pipe(hasher2).on('finish', common.mustCall(function() {
  const hash = hasher2.read().toString('hex');
  assert.strictEqual(hash, expected);
}));

stream.emit('data', Buffer.from('hello'));
stream.emit('data', Buffer.from(' world'));
stream.emit('end');
"
test/fs/test-fs-write-stream-fs.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import path from 'path';
import fs from 'fs';

import tmpdir from '../common/tmpdir';

tmpdir.refresh();

{
  const file = path.join(tmpdir.path, 'write-end-test0.txt');
  const stream = fs.createWriteStream(file, {
    fs: {
      open: common.mustCall(fs.open),
      write: common.mustCallAtLeast(fs.write, 1),
      close: common.mustCall(fs.close),
    }
  });
  stream.end('asd');
  stream.on('close', common.mustCall());
}


{
  const file = path.join(tmpdir.path, 'write-end-test1.txt');
  const stream = fs.createWriteStream(file, {
    fs: {
      open: common.mustCall(fs.open),
      write: fs.write,
      writev: common.mustCallAtLeast(fs.writev, 1),
      close: common.mustCall(fs.close),
    }
  });
  stream.write('asd');
  stream.write('asd');
  stream.write('asd');
  stream.end();
  stream.on('close', common.mustCall());
}
"
example_js/docker_wasm/server/Dockerfile,"FROM --platform=$BUILDPLATFORM rust:1.64 AS buildbase
WORKDIR /src
RUN <<EOT bash
    set -ex
    apt-get update
    apt-get install -y \
        wget unzip
EOT
# This line installs WasmEdge including the AOT compiler
RUN curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash

FROM buildbase AS build
COPY server.js .
RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm
RUN wget https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/modules.zip
RUN unzip modules.zip
# This line builds the AOT Wasm binary
RUN /root/.wasmedge/bin/wasmedgec wasmedge_quickjs.wasm wasmedge_quickjs.wasm

FROM scratch
ENTRYPOINT [ ""wasmedge_quickjs.wasm"", ""server.js"" ]
COPY --link --from=build /src/wasmedge_quickjs.wasm /wasmedge_quickjs.wasm
COPY --link --from=build /src/server.js /server.js
COPY --link --from=build /src/modules /modules
"
test/fixtures/keys/rsa_cert_foafssl_b.cnf,"# The following 'foafssl' cert is used in test/parallel/test-https-foafssl.js.
# It requires a SAN like 'http://example.com/#me'. More info here:
# https://www.w3.org/wiki/Foaf+ssl

[ req ]
days                   = 99999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = UK
ST                     = ""FOAF+SSL Auth Certificate""
L                      = Rhys Jones
O                      = node.js
OU                     = Test TLS Certificate
CN                     = localhost
emailAddress           = alex@aub.dev

[ req_attributes ]

[ v3_ca ]
basicConstraints       = CA:FALSE
subjectAltName         = @alt_names

[ alt_names ]
URI                    = http://example.com/\#me
"
test/fs/test-fs-makeStatsCallback.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
const callbackThrowValues = [null, true, false, 0, 1, 'foo', /foo/, [], {}];

const __filename = args[0];

function testMakeStatsCallback(cb) {
  return function() {
    // fs.stat() calls makeStatsCallback() on its second argument
    fs.stat(__filename, cb);
  };
}

// Verify the case where a callback function is provided
testMakeStatsCallback(common.mustCall())();

function invalidCallbackThrowsTests() {
  callbackThrowValues.forEach((value) => {
    assert.throws(testMakeStatsCallback(value), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  });
}

invalidCallbackThrowsTests();
"
test/fs/test-fs-rmdir-recursive-sync-warns-not-found.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  // Should warn when trying to delete a nonexistent path
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  assert.throws(
    () => fs.rmdirSync(path.join(tmpdir.path, 'noexist.txt'),
                       { recursive: true }),
    { code: 'ENOENT' }
  );
}
"
test/fs/test-fs-rmdir-recursive-sync-warns-on-file.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  assert.throws(
    () => fs.rmdirSync(filePath, { recursive: true }),
    { code: common.isWindows ? 'ENOENT' : 'ENOTDIR' }
  );
}
"
example_js/docker_wasm/server/README.md,"# Use Docker Wasm image for node js apps

Build the Wasm container image for the node.js server. The total size of the image is less than 2MB.

```bash
docker buildx build --platform wasi/wasm -t secondstate/node-example-server .
```

Publish the Wasm container image to Docker Hub.

```bash
docker push secondstate/node-example-server
```

Run the Wasm container app.

```bash
docker run -dp 8080:8080 --rm --runtime=io.containerd.wasmedge.v1 --platform=wasi/wasm secondstate/node-example-server:latest
```

From another terminal, test the server application.

```bash
$ curl http://localhost:8080/echo -X POST -d ""Hello WasmEdge""
Hello WasmEdge
```
"
test/fs/test-fs-stream-construct-compat-error-read.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import assert from 'assert';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

{
  // Compat error.

  function ReadStream(...args) {
    fs.ReadStream.call(this, ...args);
  }
  Object.setPrototypeOf(ReadStream.prototype, fs.ReadStream.prototype);
  Object.setPrototypeOf(ReadStream, fs.ReadStream);

  ReadStream.prototype.open = common.mustCall(function ReadStream$open() {
    const that = this;
    fs.open(that.path, that.flags, that.mode, (err, fd) => {
      that.emit('error', err);
    });
  });

  const r = new ReadStream('/doesnotexist', { emitClose: true })
    .on('error', common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
      assert.strictEqual(r.destroyed, true);
      r.on('close', common.mustCall());
    }));
}
"
example_js/react_ssr_stream/component/LazyHome.jsx,"import React, { Suspense } from 'react';
import * as LazyPage from './LazyPage.jsx';

async function sleep(ms) {
    return new Promise((r, _) => {
        setTimeout(() => r(), ms)
    });
}

async function loadLazyPage() {
    await sleep(2000);
    return LazyPage
}

class LazyHome extends React.Component {
    render() {
        let LazyPage1 = React.lazy(() => loadLazyPage());
        return (
            <html lang=""en"">
                <head>
                    <meta charSet=""utf-8"" />
                    <title>Title</title>
                </head>
                <body>
                    <div>
                        <div> This is LazyHome </div>
                        <Suspense fallback={<div> loading... </div>}>
                            <LazyPage1 />
                        </Suspense>
                    </div>
                </body>
            </html>
        );
    }
}

export default LazyHome;
"
examples/host_function/src/main.rs,"mod host_extern {
    use wasmedge_quickjs::{Context, JsFn, JsValue};

    #[link(wasm_import_module = ""extern"")]
    extern ""C"" {
        pub fn host_inc(v: i32) -> i32;
    }

    pub struct HostIncFn;
    impl JsFn for HostIncFn {
        fn call(ctx: &mut Context, _this_val: JsValue, argv: &[JsValue]) -> JsValue {
            if let Some(JsValue::Int(i)) = argv.get(0) {
                unsafe {
                    let r = host_inc(*i);
                    r.into()
                }
            } else {
                ctx.throw_type_error(""'v' is not a int"").into()
            }
        }
    }
}

use wasmedge_quickjs::*;

fn main() {
    let mut ctx = Context::new();
    let f = ctx.new_function::<host_extern::HostIncFn>(""host_inc"");
    ctx.get_global().set(""host_inc"", f.into());
    ctx.eval_global_str(""print('js=> host_inc(2)=',host_inc(2))"");
}
"
test/fs/test-fs-rmdir-recursive-warns-on-file.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  const filePath = path.join(tmpdir.path, 'rmdir-recursive.txt');
  fs.writeFileSync(filePath, '');
  fs.rmdir(filePath, { recursive: true }, common.mustCall((err) => {
    assert.strictEqual(err.code, common.isWindows ? 'ENOENT' : 'ENOTDIR');
  }));
}
"
test/fixtures/keys/ca2.cnf,"[ ca ]
default_ca      = CA_default

[ CA_default ]
serial = ca2-serial
crl = ca2-crl.pem
database = ca2-database.txt
name_opt = CA_default
cert_opt = CA_default
default_crl_days = 9999
default_md = sha512


[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = ca2
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
challengePassword              = A challenge password

"
test/fs/test-fs-rmdir-recursive-throws-not-found.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import assert from 'assert';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  assert.throws(
    () =>
      fs.rmdirSync(path.join(tmpdir.path, 'noexist.txt'), { recursive: true }),
    {
      code: 'ENOENT',
    }
  );
}
{
  fs.rmdir(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true },
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
    })
  );
}
{
  assert.rejects(
    () => fs.promises.rmdir(path.join(tmpdir.path, 'noexist.txt'),
                            { recursive: true }),
    {
      code: 'ENOENT',
    }
  ).then(common.mustCall());
}
"
test/fs/test-fs-make-callback.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
const callbackThrowValues = [null, true, false, 0, 1, 'foo', /foo/, [], {}];

import { sep } from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

function testMakeCallback(cb) {
  return function() {
    // fs.mkdtemp() calls makeCallback() on its third argument
    fs.mkdtemp(`${tmpdir.path}${sep}`, {}, cb);
  };
}

function invalidCallbackThrowsTests() {
  callbackThrowValues.forEach((value) => {
    assert.throws(testMakeCallback(value), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
  });
}

invalidCallbackThrowsTests();
"
test/fs/test-fs-write-stream-throw-type-error.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';

const example = path.join(tmpdir.path, 'dummy');

tmpdir.refresh();
// Should not throw.
fs.createWriteStream(example, undefined).end();
fs.createWriteStream(example, null).end();
fs.createWriteStream(example, 'utf8').end();
fs.createWriteStream(example, { encoding: 'utf8' }).end();

const createWriteStreamErr = (path, opt) => {
  assert.throws(
    () => {
      fs.createWriteStream(path, opt);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
};

createWriteStreamErr(example, 123);
createWriteStreamErr(example, 0);
createWriteStreamErr(example, true);
createWriteStreamErr(example, false);
"
test/fs/test-fs-promises-file-handle-truncate.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import path from 'path';
import { open, readFile } from 'fs/promises';
import tmpdir from '../common/tmpdir';

tmpdir.refresh();

async function validateTruncate() {
  const text = 'Hello world';
  const filename = path.resolve(tmpdir.path, 'truncate-file.txt');
  const fileHandle = await open(filename, 'w+');

  const buffer = Buffer.from(text, 'utf8');
  await fileHandle.write(buffer, 0, buffer.length);

  assert.strictEqual((await readFile(filename)).toString(), text);

  await fileHandle.truncate(5);
  assert.strictEqual((await readFile(filename)).toString(), 'Hello');

  await fileHandle.close();
}

validateTruncate().then(common.mustCall());
"
test/fs/test-fs-watchfile-ref-unref.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import fs from 'fs';
import assert from 'assert';

const uncalledListener = common.mustNotCall();
const uncalledListener2 = common.mustNotCall();
const watcher = fs.watchFile(__filename, uncalledListener);

watcher.unref();
watcher.unref();
watcher.ref();
watcher.unref();
watcher.ref();
watcher.ref();
watcher.unref();

fs.unwatchFile(__filename, uncalledListener);

// Watch the file with two different listeners.
fs.watchFile(__filename, uncalledListener);
const watcher2 = fs.watchFile(__filename, uncalledListener2);

setTimeout(
  common.mustCall(() => {
    fs.unwatchFile(__filename, common.mustNotCall());
    assert.strictEqual(watcher2.listenerCount('change'), 2);
    fs.unwatchFile(__filename, uncalledListener);
    assert.strictEqual(watcher2.listenerCount('change'), 1);
    watcher2.unref();
  }),
  common.platformTimeout(100)
);
"
test/crypto/test-crypto-modp1-error.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

assert.throws(
  function() {
    crypto.getDiffieHellman('modp1').setPrivateKey('');
  },
  new RegExp('^TypeError: crypto\\.getDiffieHellman\\(\\.\\.\\.\\)\\.' +
  'setPrivateKey is not a function$'),
  'crypto.getDiffieHellman(\'modp1\').setPrivateKey(\'\') ' +
  'failed to throw the expected error.'
);
assert.throws(
  function() {
    crypto.getDiffieHellman('modp1').setPublicKey('');
  },
  new RegExp('^TypeError: crypto\\.getDiffieHellman\\(\\.\\.\\.\\)\\.' +
  'setPublicKey is not a function$'),
  'crypto.getDiffieHellman(\'modp1\').setPublicKey(\'\') ' +
  'failed to throw the expected error.'
);
"
test/fs/test-fs-promises-file-handle-stat.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';

// The following tests validate base functionality for the fs.promises
// FileHandle.stat method.

import { open } from 'fs/promises';
import path from 'path';
import tmpdir from '../common/tmpdir';
import assert from 'assert';

tmpdir.refresh();

async function validateStat() {
  const filePath = path.resolve(tmpdir.path, 'tmp-read-file.txt');
  const fileHandle = await open(filePath, 'w+');
  const stats = await fileHandle.stat();
  assert.ok(stats.mtime instanceof Date);
  await fileHandle.close();
}

validateStat()
  .then(common.mustCall());
"
test/fs/test-fs-rmdir-recursive-warns-not-found.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import tmpdir from '../common/tmpdir';
import fs from 'fs';
import path from 'path';

tmpdir.refresh();

{
  // Should warn when trying to delete a nonexistent path
  common.expectWarning(
    'DeprecationWarning',
    'In future versions of Node.js, fs.rmdir(path, { recursive: true }) ' +
      'will be removed. Use fs.rm(path, { recursive: true }) instead',
    'DEP0147'
  );
  fs.rmdir(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true },
    common.mustCall()
  );
}
"
test/fs/test-fs-mkdtemp-prefix-check.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const prefixValues = [undefined, null, 0, true, false, 1];

function fail(value) {
  assert.throws(
    () => {
      fs.mkdtempSync(value, {});
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
}

function failAsync(value) {
  assert.throws(
    () => {
      fs.mkdtemp(value, common.mustNotCall());
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
}

prefixValues.forEach((prefixValue) => {
  fail(prefixValue);
  failAsync(prefixValue);
});
"
test/fs/test-fs-ready-event-stream.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import tmpdir from '../common/tmpdir';

const __filename = args[0];

const readStream = fs.createReadStream(__filename);
assert.strictEqual(readStream.pending, true);
readStream.on('ready', common.mustCall(() => {
  assert.strictEqual(readStream.pending, false);
}));

const writeFile = path.join(tmpdir.path, 'write-fsreadyevent.txt');
tmpdir.refresh();
const writeStream = fs.createWriteStream(writeFile, { autoClose: true });
assert.strictEqual(writeStream.pending, true);
writeStream.on('ready', common.mustCall(() => {
  assert.strictEqual(writeStream.pending, false);
  writeStream.end();
}));
"
example_js/react18_ssr/component/Sidebar.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Sidebar() {
  return (
    <>
      <h1>Archive</h1>
      <ul>
        <li>May 2021</li>
        <li>April 2021</li>
        <li>March 2021</li>
        <li>February 2021</li>
        <li>January 2021</li>
        <li>December 2020</li>
        <li>November 2020</li>
        <li>October 2020</li>
        <li>September 2020</li>
      </ul>
    </>
  );
}
"
examples/embed_use_es6_module/src/main.rs,"use wasmedge_quickjs::*;

fn main() {
    let mut ctx = Context::new();

    let code = r#""
    let m = import('es6_module_demo.js')
    m
    ""#;

    let p = ctx.eval_global_str(code);
    println!(""before poll:{:?}"", p);
    ctx.promise_loop_poll();
    println!(""after poll:{:?}"", p);
    if let JsValue::Promise(ref p) = p {
        let m = p.get_result();
        println!(""m = {:?}"", m);
        if let JsValue::Object(mod_obj) = m {
            let f = mod_obj.get(""do_something"");
            println!(""do_something = {:?}"", f);
            if let JsValue::Function(f) = f {
                f.call(&mut [ctx.new_string(""hello"").into()]);
            }
        }
    }
}
"
test/crypto/test-crypto-webcrypto-aes-decrypt-tag-too-small.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto').webcrypto;

crypto.subtle.importKey(
  'raw',
  new Uint8Array(32),
  {
    name: 'AES-GCM'
  },
  false,
  [ 'encrypt', 'decrypt' ])
  .then((k) => {
    assert.rejects(() => {
      return crypto.subtle.decrypt({
        name: 'AES-GCM',
        iv: new Uint8Array(12),
      }, k, new Uint8Array(0));
    }, {
      name: 'OperationError',
      message: /The provided data is too small/,
    });
  });
"
test/fs/test-fs-read-zero-length.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fixtures from '../common/fixtures';
import assert from 'assert';
import fs from 'fs';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');
const bufferAsync = Buffer.alloc(0);
const bufferSync = Buffer.alloc(0);

fs.read(fd, bufferAsync, 0, 0, 0, common.mustCall((err, bytesRead) => {
  assert.strictEqual(bytesRead, 0);
  assert.deepStrictEqual(bufferAsync, Buffer.alloc(0));
}));

const r = fs.readSync(fd, bufferSync, 0, 0, 0);
assert.deepStrictEqual(bufferSync, Buffer.alloc(0));
assert.strictEqual(r, 0);
"
test/fs/test-fs-write-stream-file-handle.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
const file = path.join(tmpdir.path, 'write_stream_filehandle_test.txt');
const input = 'hello world';

tmpdir.refresh();

fs.promises.open(file, 'w+').then((handle) => {
  handle.on('close', common.mustCall());
  const stream = fs.createWriteStream(null, { fd: handle });

  stream.end(input);
  stream.on('close', common.mustCall(() => {
    const output = fs.readFileSync(file, 'utf-8');
    assert.strictEqual(output, input);
  }));
}).then(common.mustCall());
"
example_js/react18_ssr/component/Comments.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
import { useData } from './data';

export default function Comments() {
  const comments = useData();
  return (
    <>
      {comments.map((comment, i) => (
        <p className=""comment"" key={i}>
          {comment}
        </p>
      ))}
    </>
  );
}
"
example_js/simple_common_js_demo/rollup.config.js,"const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');


const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net','std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ignoreDynamicRequires: false}),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];"
examples/host_function/README.md,"# A wasi quickjs binding for rust
this example show how to import a custom host function into quickjs.

# Build

```shell
#build wasm
$ cargo build --target wasm32-wasi --release

#build custom webassembly Runtime
$ cd wasmedge_c

#build a custom Runtime
wasmedge_c/$ gcc demo_wasmedge.c -lwasmedge_c -o demo_wasmedge
```

# Run

```shell
wasmedge_c/$ export LD_LIBRARY_PATH=.

wasmedge_c/$ ./demo_wasmedge ../target/wasm32-wasi/release/host_function.wasm
Runtime(c)=> host_inc call : 3
js=> host_inc(2)= 3

Runtime(c)=> OK
wasmedge_c/$ 
```
"
README.md,"# Run JavaScript in WebAssembly

Checkout the [documentation](https://wasmedge.org/docs/category/develop-wasm-apps-in-javascript)

## Quick start

```
git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs

cargo build --target wasm32-wasi --release

wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
Hello WasmEdge Runtime
```

### Usage with custom ssl certs
```bash
$  wasmedge --dir .:. --dir /etc/ssl:/etc/ssl:readonly --env SSL_CERT_FILE=""/etc/ssl/cert.pem"" target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/wasi_https_fetch.js
```
substitute the value of `/etc/ssl` and `/etc/ssl/cert.pem` with the location of your cert folder and cert file
"
test/crypto/test-crypto-worker-thread.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

// Issue https://github.com/nodejs/node/issues/35263
// Description: Test that passing keyobject to worker thread does not crash.
const { createSecretKey } = require('crypto');

const { Worker, isMainThread, workerData } = require('worker_threads');

if (isMainThread) {
  const key = createSecretKey(Buffer.from('hello'));
  new Worker(__filename, { workerData: key });
} else {
  console.log(workerData);
}
"
test/fixtures/keys/agent1.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = agent1
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
authorityInfoAccess = @issuer_info

[ issuer_info ]
OCSP;URI.0 = http://ocsp.nodejs.org/
caIssuers;URI.0 = http://ca.nodejs.org/ca.cert
"
example_js/react_ssr_stream/rollup.config.js,"const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const plugin_async = require('rollup-plugin-async');


const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './main.mjs',
    output: {
      inlineDynamicImports: true,
      file: 'dist/main.mjs',
      format: 'esm',
    },
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ ignoreDynamicRequires: false }),
      babel(babelOptions),
      globals(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];"
modules/timers/promises.js,"import { promisify } from 'util.js';
import exports from 'timers.js';

function promisifySetTimeout(delay, value, _option) {
    return new Promise((resolve, _reject) => {
        exports.setTimeout(resolve(value), delay)
    })
}

function promisifySetImmediate(delay, value, _option) {
    return new Promise((resolve, _reject) => {
        exports.setImmediate(resolve(value), delay)
    })
}

const setTimeout = promisifySetTimeout,
    setImmediate = promisifySetImmediate,
    setInterval = promisify(exports.setInterval);

var promises = {
    setTimeout,
    setImmediate,
    setInterval
};

export { promises as default, setImmediate, setInterval, setTimeout };
"
test/path/test-path-isabsolute.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import path from 'path';
/*
assert.strictEqual(path.win32.isAbsolute('/'), true);
assert.strictEqual(path.win32.isAbsolute('//'), true);
assert.strictEqual(path.win32.isAbsolute('//server'), true);
assert.strictEqual(path.win32.isAbsolute('//server/file'), true);
assert.strictEqual(path.win32.isAbsolute('\\\\server\\file'), true);
assert.strictEqual(path.win32.isAbsolute('\\\\server'), true);
assert.strictEqual(path.win32.isAbsolute('\\\\'), true);
assert.strictEqual(path.win32.isAbsolute('c'), false);
assert.strictEqual(path.win32.isAbsolute('c:'), false);
assert.strictEqual(path.win32.isAbsolute('c:\\'), true);
assert.strictEqual(path.win32.isAbsolute('c:/'), true);
assert.strictEqual(path.win32.isAbsolute('c://'), true);
assert.strictEqual(path.win32.isAbsolute('C:/Users/'), true);
assert.strictEqual(path.win32.isAbsolute('C:\\Users\\'), true);
assert.strictEqual(path.win32.isAbsolute('C:cwd/another'), false);
assert.strictEqual(path.win32.isAbsolute('C:cwd\\another'), false);
assert.strictEqual(path.win32.isAbsolute('directory/directory'), false);
assert.strictEqual(path.win32.isAbsolute('directory\\directory'), false);
*/
assert.strictEqual(path.posix.isAbsolute('/home/foo'), true);
assert.strictEqual(path.posix.isAbsolute('/home/foo/..'), true);
assert.strictEqual(path.posix.isAbsolute('bar/'), false);
assert.strictEqual(path.posix.isAbsolute('./baz'), false);
"
example_js/create-react-app-ssr/src/App.css,".App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
"
example_js/react_ssr/rollup.config.js,"const { babel } = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals =  require('rollup-plugin-node-globals');
const builtins =  require('rollup-plugin-node-builtins');


const babelOptions = {
  ""presets"": [
    '@babel/preset-env',
    '@babel/preset-react'
  ]
}

module.exports = [
  {
    input: './main.js',
    output: {
      file: 'dist/main.js',
      format: 'umd',
    }, 
    plugins: [
      nodeResolve(),
      commonjs(),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify( 'production' )
      })
    ],
  },
]"
test/fs/test-fs-readv-promisify.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import common from '../common';
import fixtures from '../common/fixtures';
import fs from 'fs';
import { promisify } from 'util';
let readv = promisify(fs.readv);
import assert from 'assert';
const filepath = fixtures.path('x.txt');
const fd = fs.openSync(filepath, 'r');

const expected = [Buffer.from('xyz\n')];

readv(fd, expected)
  .then(function({ bytesRead, buffers }) {
    assert.deepStrictEqual(bytesRead, expected[0].length);
    assert.deepStrictEqual(buffers, expected);
  })
  .then(common.mustCall());
"
example_js/react18_ssr/component/Spinner.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Spinner({active = true}) {
  return (
    <div
      className={['spinner', active && 'spinner--active'].join(' ')}
      role=""progressbar""
      aria-busy={active ? 'true' : 'false'}
    />
  );
}
"
test/fixtures/keys/ca4.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = The Node.js Foundation
OU                     = Node.js
CN                     = ca4
emailAddress           = ca4@example.org

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
basicConstraints = CA:TRUE
"
test/fs/test-fs-timestamp-parsing-error.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';

[Infinity, -Infinity, NaN].forEach((input) => {
  assert.throws(
    () => {
      fs._toUnixTimestamp(input);
    },
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    });
});

assert.throws(
  () => {
    fs._toUnixTimestamp({});
  },
  {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError'
  });

const okInputs = [1, -1, '1', '-1', Date.now()];
okInputs.forEach((input) => {
  fs._toUnixTimestamp(input);
});
"
example_js/react18_ssr/rollup.config.js,"const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const plugin_async = require('rollup-plugin-async');


const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './main.mjs',
    output: {
      inlineDynamicImports: true,
      file: 'dist/main.mjs',
      format: 'esm',
    },
    plugins: [
      babel(babelOptions),
      plugin_async(),
      nodeResolve(),
      commonjs({ignoreDynamicRequires: false}),
      globals(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];"
examples/embed_js_module/src/main.rs,"use wasmedge_quickjs::*;

fn main() {
    let mut ctx = Context::new();

    let code = r#""
    import('async_demo.js').then((demo)=>{
        return demo.wait_simple_val(1)
    })
    ""#;

    let p = ctx.eval_global_str(code);
    println!(""before poll:{:?}"", p);
    if let JsValue::Promise(ref p) = p {
        let v = p.get_result();
        println!(""v = {:?}"", v);
    }
    ctx.promise_loop_poll();
    println!(""after poll:{:?}"", p);
    if let JsValue::Promise(ref p) = p {
        let v = p.get_result();
        println!(""v = {:?}"", v);
    }
}
"
example_js/create-react-app-ssr/webpack.server.js,"const path = require('path');
module.exports = {
  entry: './server/index.js',
  externals: [
    {""wasi_http"": ""wasi_http""},
    {""wasi_net"": ""wasi_net""},
    {""std"": ""std""}
  ],
  output: {
    path: path.resolve('server-build'),
    filename: 'index.js',
    chunkFormat: ""module"",
    library: {
      type: ""module""
    },
  },
  experiments: {
    outputModule: true
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [""css-loader""]
      },
      {
        test: /\.svg$/,
        use: [""svg-url-loader""]
      }
    ]
  }
};
"
test/fixtures/keys/ca1.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = ca1
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
basicConstraints = CA:TRUE
"
test/fixtures/keys/ca3.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = ca3
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
basicConstraints = CA:TRUE
"
test/fixtures/keys/ca6.cnf,"[ req ]
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = The Node.js Foundation
OU                     = Node.js
CN                     = ca6
emailAddress           = ca6@example.org

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
basicConstraints = CA:TRUE
"
test/fs/test-fs-buffertype-writesync.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

// This test ensures that writeSync throws for invalid data input.

import assert from 'assert';
import fs from 'fs';

[
  true, false, 0, 1, Infinity, () => {}, {}, [], undefined, null,
].forEach((value) => {
  assert.throws(
    () => fs.writeSync(1, value),
    { message: /""buffer""/, code: 'ERR_INVALID_ARG_TYPE' }
  );
});
"
test/fs/test-fs-watch-stop-async.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';

import assert from 'assert';
import fs from 'fs';

const watch = fs.watchFile(__filename, common.mustNotCall());
let triggered;
const listener = common.mustCall(() => {
  triggered = true;
});

triggered = false;
watch.once('stop', listener);  // Should trigger.
watch.stop();
assert.strictEqual(triggered, false);
setImmediate(() => {
  assert.strictEqual(triggered, true);
  watch.removeListener('stop', listener);
});
"
modules/internal/streams/passthrough.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent and Node contributors. All rights reserved. MIT license.
// deno-lint-ignore-file

import Transform from ""./transform.js"";

function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }

    Transform.call(this, options);
}

Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);

PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
};

export default PassThrough;"
test/fixtures/keys/rsa_cert.cnf,"[ req ]
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = UK
ST                     = Acknack Ltd
L                      = Rhys Jones
O                      = node.js
0.OU                   = Test TLS Certificate
1.OU                   = Engineering
CN                     = localhost
emailAddress           = alex@aub.dev

[ req_attributes ]

[ v3_ca ]
basicConstraints = CA:TRUE

[ x509_extensions ]
"
test/fixtures/keys/agent5.cnf,"[ req ]
string_mask            = utf8only
utf8                   = yes
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = HU
L                      = Budapest
O                      = Tresorit
CN                     = dm Lippai
emailAddress           = adam.lippai@tresorit.com

[ req_attributes ]
challengePassword              = A challenge password

[ ext_key_usage ]
extendedKeyUsage       = clientAuth
"
test/fixtures/keys/rsa_private_4096.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIJKAIBAAKCAgEAxeStwofbjtZuol4lwKn1w08AzcSNLHfCqNFHa+W7er8is7LQ
sPljtPT4yn4lsao83ngHFvSC3tbMiRNDpUHYqH2wBuUkuOmCtYkZLi0307H0CwcV
V6W5P3tNEt80IJ+PqlRxtTknezUtbOasbIi/aornVWG+psgqDGrFZ4oTsWtiE0Sv
i7sDqN5E2dijmH/YYnlnwqszgzHdtAnARp1bG34E64sqWCmLoGCfPdHtym/CSdxO
LOsDV15jrwODZQ/TJZ5thkwKZRxu7g9fwlhA1PiI5WDP4reXNaqa2bSgrzpAljQE
xYs4N0L7okSVOJQX9BEaoWtq8NLU8MpMdGoHNDU0Xr60Lfr58Z5qn8RGEvlTxoCb
PJzPV2zgzD/lmEqft6NnfTclveA3sd8xSrOBUn4o3S8hS0b9Su7PBukHjM96/e0R
eoIshSwXlQTLr2Ft8KwupyPm1ltNcTDtjqHcIWU6Bg+kPy9mxSVtGGZYAPtqGzNB
A/m+oOja/OSPxAblPdln691DaDuZs5nuZCGwGcLaJWgiyoqvXAcyXDZFyH4OZZh8
rsBLKbnFXHZ/ziG0cAozEygZEPJappw8Lx/ady7WL/SJjxooiKapc7Bnfy8eSLV3
+XAKxhLW/MQ6ChJ+e/8ExAY02ca4MpCvqwIk9TfV6FM8pWGqHzQFj0v3NL0CAwEA
AQKCAgBTb8eTbZS09NRQwUFJql9kqbq9B1I+nYAFjbd/Vq1lY5FOEubKt1vCwEbl
mapq7kwbwJ+8nftP2WEDqouq8chXwialwZdqH4ps4BEt1wLizvUGcUYeXlFs4p/s
hQ+FccExH8mRjzeGSzWL5PZuDHoogchnx36K83pHIf15Wk5TT+NaHGunjoJMgOqm
ryDK+5xQaL/G5Egj2LKRZksbet0fClMovNRtt5aXWCXL+uc3o0dXvPt5FN2jyLhe
4ixUQAfWpKWpKgZ3+zUKSpElb/Bl2yRdEiSUgrPOfNAtWmsldnok2mnooHpjUmqm
UCRaZpZy4YNI6/F6+Gmv3Ju/ubSvHzoxQLlvgUqWAnVshivF1TJImHSIiLIvBKPp
29SD6maWIT1DC9sKC4E1gq7VO4762l1//zEOAY7XK0Z7LrbZO4WXHnsgFOpGthQ3
g9Qi/SeM6mb5xEJTBUBTmkhGs1x8jolzca30mqv8T63W4PXkXHmZdK7vyH5useiI
s0eGUeaYK892WgfxCBo24JCNQiAcH/wTwV4l4yROqeH2V4ShbIYmCzla++7vsPYW
hAwQR9eH0+4ogTkaMQrm16plZk0ezVX9BKK8KTnd4G9/T18VstQbiowF2/cKnGKC
OqrmoR2vHOksQdUJVmnwCRqU1symBxhY0GSIps98v+lUYExKQQKCAQEA/uVYE2/H
eNcV/uWAI9LspANXHJE33TFMZ8SuyOYtp3MYJizmQ1uT7Om2LEanDnNiz+fAQhrE
vo1sDIF9xOAde2qjIH+iDzcLvFPgC3gkQspFjU31M9OO5xAjzBxfL3KDiG2MtmTR
hNuKJX56eCOqkEp6WKaWOA35ccaKYHxNzMS49weCv95ZPpR9q0J1sgzD7HtVh4yu
XI01/BC8F0RmYjtsuUo+PmB6sO2K94uqqo0GPUos7Mhgrbff3L36EkOPgmRiA1AV
Zy1sKKxUKspGQ3m1fg+CA/+GZGckvYkVot1lFrwmrS2dok8EhT1HcVJde+++jx7z
JsRLgFRvKHXklwKCAQEAxsAfxIQjjjKmuyJCzIvxG7lnuzovdy4OEdSuJL4yK5m3
4BHJHn+yHeRIcrDnJKUTUYffcH/OjOnJS94BA6wH1tEuvGQz6LV6UpwApZ1M/2md
nP0eC2L2JtSRL8mdxfyqXDloWMpD7rncBZ6ChLEZ6sWYa6WBQTARmPVePyUpNNG2
qymxN3/vRBGGBunD3j6zX0M0szWK5iU+qsYDy3KzCKG8FU7XxwzRbP7iARRD5Hpt
Zmy2W52EJg1uhmlVXJMm32SEBfrD2oDmlnjAqaZdqi5Mq2e4uB3dhM9RwJppSALG
BY6k9DeanAFbOlawMJri2pk7B0phCn+DN2pg0+W3ywKCAQBeTwzfZCQxmaMRxGg8
2PWlWXcJotFAjdTvL95bho6tve/ZcBNiKKf6qB43E40L07VjpyODUdQpjLnFhsO5
7BH8b+AbTh3v8zXsYDwtAi6oZ56EQavPmR7ubxJPms+9BmmUOLQvZ+39ch0S8lDt
0oRxDp1l330FEGaSqhrYyCUg9khZXfYKd4IdnWNB0j0pu39iJ9/lXy/EHpsywB5X
nX8kKUh45fdRrPC4NauNG6fxomwEkUU99oWOwNGbIs87orOeUvXQs/i3TB8QjXI2
wtBsdsOn+KTqRci7rU3ysp3GvJOCbesBeDcyrnnFsn6Udx0Plgyzd4gPd+FXgeX+
2l/RAoIBAH81FKAY2xD2RlTb1tlIcGeIQWZKFXs4VPUApP0LZt0VI+UcPRdyL7SG
GgCeTTLdHQI/7rj4dGEoeRg/3XJWNyY8+KbHk5nMHaCmDJvzlAaduK10LDipfFba
Epr9dif0Ua15aNn7i4NOHg7Sp0L6f1YOZkHvykzI0VqPIWVVCYyu9TWUF8Mn9SIh
/SCLmjuy8ed1AlP5Xw9yoyt2VZNvtDtAGTuiHOVfxOL4N/rs149y9HZr+kOlC6G3
Uxhgbqwz2tt8YCvblmNRwURpwRZUTvrPa28Bke713oRUlUSrD9txOwDvjZBpzmEv
VQ5/0YEqgSvcizVdW8L2XiunwJWfIAUCggEBALr4RF9TYa37CImZOs+vJ8FGRKMz
h1EUwO2PvuITvkTtu/7E4IjyxAo5dkAokkWQCGABciiDJJEYUWqcUX45qQChOgtm
NU2od6f9tgyDFxN5KS8cE32NXV3rJXs3bBZmIKLSPETf3uIPuEpFPjpdR5v5jlV+
TDjH4RrItE3hDCvypTXhXXMmWp3VfYbgEfIP03uR2iIhL+/g3BUqbrywPEsTViSN
NM/uBDQyamXLXB1bQ2I/Ob41I82PD1iNCqGi7ZvZ3eVYGgUTQyw6Q4O8glTPP9cC
SFVXwE9gHbLe8TqfTZCWrM6crGX6Bb6hV2tqNsA+7J69U9NGuw5GNqXjafU=
-----END RSA PRIVATE KEY-----
"
test/fs/test-fs-read-stream-encoding.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import fs from 'fs';
import stream from 'stream';
import fixtures from '../common/fixtures';
const encoding = 'base64';

const example = fixtures.path('x.txt');
const assertStream = new stream.Writable({
  write: function(chunk, enc, next) {
    const expected = Buffer.from('xyz');
    assert(chunk.equals(expected));
  }
});
assertStream.setDefaultEncoding(encoding);
fs.createReadStream(example, encoding).pipe(assertStream);
"
test/fs/test-fs-read-stream-patch-open.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';

common.expectWarning(
  'DeprecationWarning',
  'ReadStream.prototype.open() is deprecated', 'DEP0135');
const s = fs.createReadStream('asd')
  // We don't care about errors in this test.
  .on('error', () => {});
s.open();

process.nextTick(() => {
  // Allow overriding open().
  fs.ReadStream.prototype.open = common.mustCall();
  fs.createReadStream('asd');
});
"
test/fs/test-fs-readlink-type-check.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.readlink(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.readlinkSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fs/test-fs-rmdir-type-check.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, [], {}, null, undefined].forEach((i) => {
  assert.throws(
    () => fs.rmdir(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.rmdirSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fs/test-fs-unlink-type-check.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

[false, 1, {}, [], null, undefined].forEach((i) => {
  assert.throws(
    () => fs.unlink(i, common.mustNotCall()),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
  assert.throws(
    () => fs.unlinkSync(i),
    {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError'
    }
  );
});
"
test/fixtures/keys/agent4.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = agent4
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
challengePassword              = A challenge password

[ ext_key_usage ]
extendedKeyUsage       = clientAuth
"
src/internal_module/os.rs,"use core::arch;

use crate::quickjs_sys::*;
use crate::EventLoop;

fn memory_size(_ctx: &mut Context, _this_val: JsValue, _argv: &[JsValue]) -> JsValue {
    JsValue::Int(arch::wasm32::memory_size::<0>() as i32)
}

struct OS;

impl ModuleInit for OS {
    fn init_module(ctx: &mut Context, m: &mut JsModuleDef) {
        let f = ctx.wrap_function(""_memorySize"", memory_size);
        m.add_export(""_memorySize\0"", f.into());
    }
}

pub fn init_module(ctx: &mut Context) {
    ctx.register_module(""_node:os\0"", OS, &[""_memorySize\0""])
}
"
test/fixtures/keys/selfsigned-no-keycertsign/https_renew_cert.sh,"#!/usr/bin/env bash
set -euo pipefail
shopt -s inherit_errexit

cd -- ""$(dirname -- ""${BASH_SOURCE[0]}"")""

if [ ! -f key.pem ]; then
  openssl genrsa -out key.pem 2048
fi

openssl req -sha256 -new -key key.pem -subj ""/CN=localhost"" | \
  openssl x509 -req -extfile cert.conf -extensions v3_req -days 3650 -signkey key.pem -out cert.pem
openssl x509 -in cert.pem -noout -text
"
test/fs/test-fs-read-stream-autoClose.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';
import path from 'path';
import assert from 'assert';
import tmpdir from '../common/tmpdir';
const writeFile = path.join(tmpdir.path, 'write-autoClose.txt');
tmpdir.refresh();

const file = fs.createWriteStream(writeFile, { autoClose: true });

file.on('finish', common.mustCall(() => {
  assert.strictEqual(file.destroyed, false);
}));
file.end('asd');
"
test/fixtures/keys/dns-cert1.cnf,"[ CA_default ]
copy_extensions = copy

[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_subject_name
attributes             = req_attributes
prompt                 = no
x509_extensions        = v3_req
req_extensions         = v3_req

[ req_subject_name ]
CN                     = evil.com

[ req_attributes ]
challengePassword              = A challenge password

[ v3_req ]
subjectAltName = @alt_names

[alt_names]
DNS.1 = google.com"
test/fs/test-fs-open-numeric-flags.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

// O_WRONLY without O_CREAT shall fail with ENOENT
const pathNE = path.join(tmpdir.path, 'file-should-not-exist');
assert.throws(
  () => fs.openSync(pathNE, fs.constants.O_WRONLY),
  (e) => e.code === 'ENOENT'
);
"
example_js/react18_ssr/component/NavBar.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function NavBar() {
  return (
    <nav>
      <a href=""/"">Home</a>
    </nav>
  );
}
"
src/event_loop/certs.rs,"use std::{env, io};
use std::fs::File;
use std::io::BufReader;
use rustls::Certificate;


const ENV_CERT_FILE: &str = ""SSL_CERT_FILE"";

pub fn load_certs_from_env() -> io::Result<Vec<Certificate>> {
    let file_name = match env::var(ENV_CERT_FILE) {
        Ok(val) => val,
        Err(_) => {
         return io::Result::Err(io::Error::from(io::ErrorKind::NotFound));
        },
    };
    let file = File::open(file_name)?;
    let mut reader = BufReader::new(file);
    let mut certs = rustls_pemfile::certs(&mut reader)?;
    Ok(certs.into_iter().map(Certificate).collect())
}"
test/fs/test-fs-read-stream-double-close.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import fs from 'fs';

{
  const s = fs.createReadStream(__filename);

  s.close(common.mustCall());
  s.close(common.mustCall());
}

{
  const s = fs.createReadStream(__filename);

  // This is a private API, but it is worth testing. close calls this
  s.destroy(null, common.mustCall());
  s.destroy(null, common.mustCall());
}
"
test/fs/test-fs-truncate-sync.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import tmpdir from '../common/tmpdir';
const tmp = tmpdir.path;

tmpdir.refresh();

const filename = path.resolve(tmp, 'truncate-sync-file.txt');

fs.writeFileSync(filename, 'hello world', 'utf8');

const fd = fs.openSync(filename, 'r+');

fs.truncateSync(fd, 5);
assert(fs.readFileSync(fd).equals(Buffer.from('hello')));

fs.closeSync(fd);
fs.unlinkSync(filename);
"
example_js/react18_ssr/component/index.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
import {hydrateRoot} from 'react-dom';
import App from './App';

hydrateRoot(document, <App assets={window.assetManifest} />);
"
test/crypto/test-crypto-randomfillsync-regression.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
import common from '../common';
if (!common.hasCrypto)
  common.skip('missing crypto');

import { randomFillSync } from 'crypto';
import assert from 'assert';

const ab = new ArrayBuffer(20);
const buf = Buffer.from(ab, 10);

const before = buf.toString('hex');

randomFillSync(buf);

const after = buf.toString('hex');

assert.notStrictEqual(before, after);
"
test/fixtures/keys/agent6.cnf,"[ req ]
string_mask            = utf8only
utf8                   = yes
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = HU
L                      = Budapest
O                      = Tresorit
CN                     = dm Lippai
emailAddress           = adam.lippai@tresorit.com

[ req_attributes ]
challengePassword              = A challenge password
"
test/fixtures/keys/fake-cnnic-root.cnf,"[ req ]
default_bits           = 2048
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no
output_password        = password
x509_extensions        = v3_ca

[ req_distinguished_name ]
C                      = CN
O                      = CNNIC
CN                     = CNNIC ROOT

[ req_attributes ]
challengePassword              = A challenge password

[ v3_ca ]
basicConstraints = CA:TRUE
"
test/fs/test-fs-readdir-buffer.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';

if (!common.isOSX) {
  common.skip('this tests works only on MacOS');
}

import assert from 'assert';

fs.readdir(
  Buffer.from('/dev'),
  { withFileTypes: true, encoding: 'buffer' },
  common.mustCall((e, d) => {
    assert.strictEqual(e, null);
  })
);
"
test/fixtures/keys/agent2.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = agent2
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
challengePassword              = A challenge password

"
test/fixtures/keys/agent3.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = agent3
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
challengePassword              = A challenge password

"
example_js/create-react-app-ssr/src/App.js,"import React from 'react';
import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className=""App"">
      <header className=""App-header"">
        <img src={logo} className=""App-logo"" alt=""logo"" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className=""App-link""
          href=""https://reactjs.org""
          target=""_blank""
          rel=""noopener noreferrer""
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;
"
test/crypto/test-crypto-dh-shared.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';
const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');

const alice = crypto.createDiffieHellmanGroup('modp5');
const bob = crypto.createDiffieHellmanGroup('modp5');
alice.generateKeys();
bob.generateKeys();
const aSecret = alice.computeSecret(bob.getPublicKey()).toString('hex');
const bSecret = bob.computeSecret(alice.getPublicKey()).toString('hex');
assert.strictEqual(aSecret, bSecret);
"
test/fixtures/keys/agent10.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = The Node.js Foundation
OU                     = Node.js
CN                     = agent10.example.com

[ req_attributes ]
challengePassword              = A challenge password
"
example_js/create-react-app-ssr/public/manifest.json,"{
  ""short_name"": ""React App"",
  ""name"": ""Create React App Sample"",
  ""icons"": [
    {
      ""src"": ""favicon.ico"",
      ""sizes"": ""64x64 32x32 24x24 16x16"",
      ""type"": ""image/x-icon""
    },
    {
      ""src"": ""logo192.png"",
      ""type"": ""image/png"",
      ""sizes"": ""192x192""
    },
    {
      ""src"": ""logo512.png"",
      ""type"": ""image/png"",
      ""sizes"": ""512x512""
    }
  ],
  ""start_url"": ""."",
  ""display"": ""standalone"",
  ""theme_color"": ""#000000"",
  ""background_color"": ""#ffffff""
}
"
example_js/react18_ssr/component/Layout.js,"/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import React from 'react'
export default function Layout({children}) {
  return <main>{children}</main>;
}
"
src/internal_module/mod.rs,"pub mod core;
#[cfg(feature = ""nodejs_crypto"")]
pub mod crypto;
pub mod encoding;
pub mod fs;
#[cfg(feature = ""ggml"")]
pub mod ggml;
pub mod httpx;
#[cfg(feature = ""img"")]
pub mod img_module;
pub mod os;
#[cfg(feature = ""tensorflow"")]
pub mod tensorflow_module;
pub mod wasi_net_module;
#[cfg(feature = ""wasi_nn"")]
pub mod wasi_nn;
"
test/fixtures/keys/selfsigned-no-keycertsign/README.md,"# Self-signed certificate without keyCertSign bit
The self-signed certificate ([cert.pem](./cert.pem)) and the key ([key.pem](./key.pem)) in this folder are used by the test [test-https-selfsigned-no-keycertsign-no-crash](../../../parallel/test-https-selfsigned-no-keycertsign-no-crash.js). The config ([cert.conf](./cert.conf)) and the file used to generate key and certificate in this folder ([https-renew-cert.sh](./https_renew_cert.sh)) are not used by the test but for reference.
"
test/fs/test-fs-read-file-assert-encoding.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';
import assert from 'assert';
import fs from 'fs';

const encoding = 'foo-8';
const filename = 'bar.txt';
assert.throws(
  () => fs.readFile(filename, { encoding }, common.mustNotCall()),
  { code: 'ERR_INVALID_ARG_VALUE', name: 'TypeError' }
);
"
test/fixtures/keys/agent7.cnf,"[ req ]
default_bits           = 2048
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = IOJS
OU                     = iojs.org
CN                     = localhost

[ req_attributes ]
challengePassword              = A challenge password
"
test/fixtures/keys/agent8.cnf,"[ req ]
default_bits           = 2048
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = NODEJS
OU                     = agent8
CN                     = localhost

[ req_attributes ]
challengePassword              = A challenge password
"
test/fixtures/keys/agent9.cnf,"[ req ]
default_bits           = 2048
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = NODEJS
OU                     = agent9
CN                     = localhost

[ req_attributes ]
challengePassword              = A challenge password
"
example_js/react18_ssr/package.json,"{
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.5"",
    ""@babel/preset-env"": ""^7.16.5"",
    ""@babel/preset-react"": ""^7.16.5"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-async"": ""^1.2.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  },
  ""dependencies"": {
    ""react"": ""^18.0.0"",
    ""react-dom"": ""^18.0.0"",
    ""react-error-boundary"": ""^3.1.4""
  }
}"
scripts/get_cert.sh,"#!/bin/bash

# Check if a domain is provided as an argument
if [ -z ""$1"" ]; then
    echo ""Usage: $0 <domain>""
    exit 1
fi

# Retrieve and print the combined TLS certificates
openssl s_client -showcerts -connect ""$1"":443 2>/dev/null < /dev/null | awk '/BEGIN CERTIFICATE/,/END CERTIFICATE/{print}'"
test/fixtures/keys/ec.cnf,"[ req ]
default_bits           = 1024
days                   = 9999
distinguished_name     = req_distinguished_name
attributes             = req_attributes
prompt                 = no

[ req_distinguished_name ]
C                      = US
ST                     = CA
L                      = SF
O                      = Joyent
OU                     = Node.js
CN                     = agent2
emailAddress           = ry@tinyclouds.org

[ req_attributes ]
"
example_js/react_ssr_stream/package.json,"{
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.5"",
    ""@babel/preset-env"": ""^7.16.5"",
    ""@babel/preset-react"": ""^7.16.5"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-async"": ""^1.2.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  },
  ""dependencies"": {
    ""react"": ""^18.0.0"",
    ""react-dom"": ""^18.0.0""
  }
}"
example_js/simple_common_js_demo/package.json,"{
  ""dependencies"": {
    ""mathjs"": ""^9.5.1"",
    ""md5"": ""^2.3.0""
  },
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.5"",
    ""@babel/preset-env"": ""^7.16.5"",
    ""@babel/preset-react"": ""^7.16.5"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0"",
    ""rollup-plugin-async"": ""^1.2.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  }
}
"
example_js/tensorflow_demo/mobilenet_v2_1.4_224_frozen.pb,"
	
ConstConst*
dtype0*	
value	B	""	?F?j??`|?B8?/L??F%?
???
??V?lb?8?ek?i\??????wf?Tc?_>/y?[?^?=?8:>$|?3+??j?a?+?0??4??>yj?9W?w)???>k_?m?g?W]
??|e?Hb?v%'?[X?&6?`&?U>B??Jg?Wd?m?y[?l??6K?????j
?!?""???l?d;?
({?rG?0>c?x?ea??_]?Xy?&IC?[?k?>gf?h??>(?a?g?-?F?q?{?A?i?<g??[???Z??H?[?PE?d(i?Q\!?x?`Y?I?B_??!?'??[?I?)NH?3&?<?:?X|K?CP~?_?p??4is?M??X+?|-?*s?T?y?0?>??BT?D?@?R?>9?F
?O?
|?Yf?od?M?88X?\?N>Vq??z7?~?3hy?WD
@8O?t?Xw?#>kk?>']?	t?=??V#???(?6|?H*K?u~`?b?z?[ ?:H?A?R=??>o]>J!?k?;?]P??7?8?V?*wT?C{?B???	?k@?|?_>>F?X?Z7?^??@j+@>?%?}?I?4U?VI?J?xX?`-y?@?*S?e?4S?p??1?v;>?l??o??Q?[R??
u^?QF?-?,4?S?*?cP?gX{?,?3??n?n?7a???G?:?.
?k??h?=?]c?h[?qB?;	??y@?F7?4(?Byn?GA?ic?
?m?l?Sc?
?ur?@P?.T?""J?=3??9?<??

Const_2Const*
valueB""Rznv=w?$z/9u><y]1v>"">?k"
example_js/wasi_http_server.js,"import { createServer, request, fetch } from 'http';

createServer((req, resp) => {
  print(""server: req.httpVersion="", req.httpVersion);
  print(""server: req.url="", req.url);
  print(""server: req.method="", req.method);
  print(""server: req.headers="", Object.keys(req.headers));

  req.on('data', (body) => {
    print(""server: req.body="", body);
    print()

    resp.write('echo:')
    resp.end(body)
  })
}).listen(8001, () => {
  print('listen 8001 ...\n');
})
"
test/fs/test-fs-watch-ref-unref.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

if (common.isIBMi)
  common.skip('IBMi does not support `fs.watch()`');

import fs from 'fs';

const watcher = fs.watch(__filename, common.mustNotCall());

watcher.unref();

setTimeout(
  common.mustCall(() => {
    watcher.ref();
    watcher.unref();
  }),
  common.platformTimeout(100)
);
"
test/fs/test-fs-write-no-fd.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import fs from 'fs';
import assert from 'assert';

assert.throws(function() {
  fs.write(null, Buffer.allocUnsafe(1), 0, 1, common.mustNotCall());
}, /TypeError/);

assert.throws(function() {
  fs.write(null, '1', 0, 1, common.mustNotCall());
}, /TypeError/);
"
test/fs/test-fs-promises-readfile-empty.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs/promises';
import fixtures from '../common/fixtures';

const fn = fixtures.path('empty.txt');

fs.readFile(fn)
  .then(assert.ok);

fs.readFile(fn, 'utf8')
  .then(assert.strictEqual.bind(this, ''));

fs.readFile(fn, { encoding: 'utf8' })
  .then(assert.strictEqual.bind(this, ''));
"
test/fs/test-fs-readdir-stack-overflow.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';

function recurse() {
  fs.readdirSync('.');
  recurse();
}

assert.throws(
  () => recurse(),
  {
    name: 'RangeError',
    message: 'Maximum call stack size exceeded'
  }
);
"
test/fs/test-fs-realpath-native.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';
import common from '../common';
import assert from 'assert';
import fs from 'fs';

const filename = __filename.toLowerCase();

assert.strictEqual(
  fs.realpathSync.native('./test/parallel/test-fs-realpath-native.js')
    .toLowerCase(),
  filename);

fs.realpath.native(
  './test/parallel/test-fs-realpath-native.js',
  common.mustSucceed(function(res) {
    assert.strictEqual(res.toLowerCase(), filename);
    assert.strictEqual(this, undefined);
  }));
"
example_js/react_ssr/package.json,"{
  ""devDependencies"": {
    ""@babel/core"": ""^7.16.0"",
    ""@babel/preset-env"": ""^7.16.4"",
    ""@babel/preset-react"": ""^7.16.0"",
    ""@rollup/plugin-babel"": ""^5.3.0"",
    ""@rollup/plugin-commonjs"": ""^21.0.1"",
    ""@rollup/plugin-node-resolve"": ""^7.1.3"",
    ""@rollup/plugin-replace"": ""^3.0.0"",
    ""rollup"": ""^2.60.1"",
    ""rollup-plugin-babel"": ""^4.4.0"",
    ""rollup-plugin-node-builtins"": ""^2.1.2"",
    ""rollup-plugin-node-globals"": ""^1.4.0""
  },
  ""scripts"": {
    ""build"": ""rollup -c rollup.config.js""
  },
  ""dependencies"": {
    ""react"": ""^17.0.2"",
    ""react-dom"": ""^17.0.2""
  }
}
"
example_js/docker_wasm/server/server.js,"import { createServer } from 'http';

createServer((req, resp) => {
  print(""server: req.httpVersion="", req.httpVersion);
  print(""server: req.url="", req.url);
  print(""server: req.method="", req.method);
  print(""server: req.headers="", Object.keys(req.headers));

  req.on('data', (body) => {
    print(""server: req.body="", body);
    print()

    resp.end(body)
  })
}).listen(8080, () => {
  print('listen 8080 ...\n');
})
"
test/fs/test-fs-close.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import common from '../common';

import assert from 'assert';
import fs from 'fs';

let __filename = args[0];

const fd = fs.openSync(__filename, 'r');

fs.close(fd, common.mustCall(function(...args) {
  assert.deepStrictEqual(args, [null]);
}));
"
example_js/react_ssr_stream/main.mjs,"import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';

import LazyHome from './component/LazyHome.jsx';

createServer((req, res) => {
  res.setHeader('Content-type', 'text/html; charset=utf-8');
  renderToPipeableStream(<LazyHome />).pipe(res);
}).listen(8001, () => {
  print('listen 8001...');
})
"
test/fixtures/keys/selfsigned-no-keycertsign/cert.conf,"[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = DE
CN = localhost

[v3_req]
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = 127.0.0.1
DNS.2 = localhost
IP.1 = 127.0.0.1
"
test/fs/test-fs-constants.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.

'use strict';

import fs from 'fs';
import assert from 'assert';

// Check if the two constants accepted by chmod() on Windows are defined.
assert.notStrictEqual(fs.constants.S_IRUSR, undefined);
assert.notStrictEqual(fs.constants.S_IWUSR, undefined);
"
example_js/react_ssr/component/Home.jsx,"import React from 'react';
import Page from './Page.jsx';

class Home extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      <div>
        <div>This is home</div>
        <Page></Page>
      </div>
    );
  }
}

export default Home;
"
test/fixtures/keys/rsa_private_encrypted.pem,"-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-256-CBC,DB3D20E60E8FDC3356BD79712FF8EF7E

K+vu0U3IFTJBBi6zW5Zng80O1jXq/ZmlOFs/j/SQpPwfW1Do9i/Dwa7ntBlTwrCm
sd3IIPgu2ikfLwxvbxsZN540oCaCqaZ/bmmyzH3MyVDA9MllUu+X8+Q3ATzcYa9R
U5XfF5DAXsSRnstCbmKagWVQpO0oX8k3ratfny6Ixq86Y82tK8+o5YiBFq1kqa+9
4yat7IWQbqV5ifUtUPCHZwEqBt+WKazX05BqERjkckHdpfaDrBvSSPXTwoLm6uRR
ktkUVpO4tHMZ4VlcTfFtpz8gdYYod0nM6vz26hvbESHSwztSgMhmKdsE5eqmYfgu
F4WkEN4bqAiPjKK3jnUKPt/vg2oKYFQlVYFl9QnBjiRqcQTi3e9lwn1hI7uoMb6g
HuaCc57JJHPN/ZLP3ts4ZxFbwUjTGioh5Zh6WozG3L3+Ujwq/sDrAskRyzdcuP7I
Rs3oLbHY03OHyg8IbxR5Iu89l6FLqnR45yvbxXtZ7ImGOPM5Z9pB1CzDhGDx2F6g
J/Kf/7ZF2DmYUVbVKDfESEDhRfuMAVzhasDPTRqipSA5QvJVQY+J/6QDPrNNmHVB
4e4ouHIDWERUf0t1Be7THvP3X8OJozj2HApzqa5ZCaJDo8eaL8TCD5uH75ID5URJ
VscGHaUXT8/sxfHi1x8BibW5W5J/akFsnrnJU/1BZgGznIxjf5tKfHGppSIVdlKP
3ghYNmEIFPNJ6cxuUA0D2IOV4uO3FTCU6seIzvJhYkmXnticcZYGtmGxXKrodtzS
J1YuaNkkO/YRZah285lQ6QCIhCFo4Oa4ILjgoTQISuw7nQj5ESyncauzLUBXKX0c
XDUej64KNTvVF9UXdG48fYvNmSZWCnTye4UmPu17FmwpVra38U+EdoLyWyMIAI5t
rP6Hhgc9BxOo41Im9QpTcAPfKAknP8Rbm3ACJG5T9FKq/c29d1E//eFR6SL51e/a
yWdCgJN/FJOAX60+erPwoVoRFEttAeDPkklgFGdc8F4LIYAig9gEZ92ykFFz3fWz
jIcUVLrL+IokFbPVUBoMihqVyMQsWH+5Qq9wjxf6EDIf0BVtm9U4BJoOkPStFIfF
Kof7OVv7izyL8R/GIil9VQs9ftwkIUPeXx2Hw0bE3HJ3C8K4+mbLg3tKhGnBDU5Z
Xm5mLHoCRBa3ZRFWZtigX7POszdLAzftYo8o65Be4OtPS+tQAORk9gHsXATv7dDB
OGw61x5KA55LHVHhWaRvu3J8E7nhxw0q/HskyZhDC+Y+Xs6vmQSb4nO4ET4NYX1P
m3PMdgGoqRDJ2jZw4eoQdRKCM0EHSepSAYpO1tcAXhPZS4ITogoRgPpVgOebEQUL
nKNeNu/BxMSH/IH15jjDLF3TiEoguF9xdTaCxIBzE1SFpVO0u9m9vXpWdPThVgsb
VcEI487p7v9iImP3BYPT8ZYvytC26EH0hyOrwhahTvTb4vXghkLIyvPUg1lZHc6e
aPHb2AzYAHLnp/ehDQGKWrCOJ1JE2vBv8ZkLa+XZo7YASXBRZitPOMlvykEyzxmR
QAmNhKGvFmeM2mmHAp0aC03rgF3lxNsXQ1CyfEdq3UV9ReSnttq8gtrJfCwxV+wY
-----END RSA PRIVATE KEY-----
"
example_js/create-react-app-ssr/src/index.css,"body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
"
test/fixtures/keys/agent10-cert.pem,"-----BEGIN CERTIFICATE-----
MIICfzCCAeigAwIBAgIJAOyvM6GMZDW6MA0GCSqGSIb3DQEBCwUAMIGIMQswCQYD
VQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMR8wHQYDVQQKDBZUaGUg
Tm9kZS5qcyBGb3VuZGF0aW9uMRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANj
YTQxHjAcBgkqhkiG9w0BCQEWD2NhNEBleGFtcGxlLm9yZzAgFw0xODExMTYxODQy
MjFaGA8yMjkyMDgzMDE4NDIyMVoweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNB
MQswCQYDVQQHDAJTRjEfMB0GA1UECgwWVGhlIE5vZGUuanMgRm91bmRhdGlvbjEQ
MA4GA1UECwwHTm9kZS5qczEcMBoGA1UEAwwTYWdlbnQxMC5leGFtcGxlLmNvbTCB
nzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEArV2diVumrKDS5k81MrcdECnYYVZ5
feQ/FZDqwEHM/zlXvs6vphU3rGmZeASMQEdHg7vUjzzvE8PDqJuJXKrC5lEO1OUY
eUDhaZ/QvYS9tDp7qTJzORxT9im65dQH0Xq5JQwTy30hidQHxOgAkILNive07/Jk
N1vle6TnZX6K/dkCAwEAATANBgkqhkiG9w0BAQsFAAOBgQAAg+FpvhA6coalWxGR
acWiUbc7CJ4RWjlSeA+fhd1G00x0Hl5hjt6IAqEHe4T9fV41U05X1eo5KaN3jXWU
IS56SVX8BxOhU53lr0iID0MpxMqttA9LgjE3fc6uAjThnx1zX50VGR4P8LQqG+HL
WJUW0+3oJrOgRbJ6wAEs0iCcTg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICkzCCAfygAwIBAgIJAJHwBmNgafKbMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2EyMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgzMDE4
NDIyMVowgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0Yx
HzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAOBgNVBAsMB05vZGUu
anMxDDAKBgNVBAMMA2NhNDEeMBwGCSqGSIb3DQEJARYPY2E0QGV4YW1wbGUub3Jn
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDC1M2aGVYsmrBiut1n0nfTU+9v
TNVdAmKQBjnNsv3IIch/PPaEOIEm7dFhgdk86Z+wVCN3sAKu54Bz4JDKdPsFGvDy
18JGuGH1vIVW5285IW7fMrzvAdZtETeBAiPM10Q69ddB4M6FbLiF273ZqCJ+vSsw
kl5Dkas8YTZ0uwqKjQIDAQABoxAwDjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB
CwUAA4GBAGDMGSbPg/B4OripSxT2scXFIwoej47PW1byJgWaGoMJ8zgKUoKE7Z7A
aWQbD22In05F0kBllqpSJWEZpTuVFsyyLeb3R7cuGQWs/puaaPul7sx+PRGhwxYe
nrNIGtsaBf8TO/kb5lMiXWbhM5gZbBtbMMv3xWA4FxqU0AgfO3jM
-----END CERTIFICATE-----
"
test/fixtures/keys/agent6-cert.pem,"-----BEGIN CERTIFICATE-----
MIICbDCCAdWgAwIBAgIJANAIL0WLbvvoMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2EzMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgzMDE4
NDIyMVowdDELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFwZXN0MREwDwYDVQQK
DAhUcmVzb3JpdDEWMBQGA1UEAwwNw4Fkw6FtIExpcHBhaTEnMCUGCSqGSIb3DQEJ
ARYYYWRhbS5saXBwYWlAdHJlc29yaXQuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GN
ADCBiQKBgQDBIF2kWViZb+GpjUKfQ2Jevk68mLWXib66z6vCi+mjpcvZeq6A5Z0M
qNJYftEgSykluxL9EkpRqWr6qCDsSrpazMHG2HB+yip8/lfLWCv/xGAHh9+4XY3s
UPGIGg+LmvhRCZvgxARxY2uG7AB+WZVMby4TCyAFAT7D/ri4L8iZZwIDAQABMA0G
CSqGSIb3DQEBCwUAA4GBAFU3MAVxVCmsaoNxr0y+KK/n0iEAzsOH9r0L3PL2gJtl
p62iOaOPw1/9x8c77RA6z/nXPX9IyAwASv0n8FEdxuIF2+KqFG6bXw5nyfgPIszr
U7YSV2Pi/Heinr76RrI6aWGtvEuD56Qt3Ce5TYiMnzAWtqEcPLGjgsx0MAv+m48B
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIChDCCAe2gAwIBAgIJAOzJuFYnDamnMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2ExMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgzMDE4
NDIyMVowejELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEP
MA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANjYTMx
IDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0GCSqGSIb3DQEB
AQUAA4GNADCBiQKBgQCZ9fF/1UcYaurFIX0QIyAJdojn9+bfsTcjEIoGbsAnQLz2
bsZ4pqRNhZbYJApxqc+oDzZOqJOaxe8mlB5jUZ/sUA9Sp+wfWly95tkEHBMSse4x
UNJVM4vFPfOG4fv9fYGH3pcmAU1QnST4Fh+qZRzrh9wa99ltmB/U2mJEF6NriwID
AQABoxAwDjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4GBAM3CFiDdGEcx
07J6pm4zGX399VxPr50PID110jmX7BRAfqva+wBRhwweSxZ/QRcKe1v/FK3GE87y
RbaXhFfnPRUHoUHQMtGwmZuZcdK65Pim9RPGb7qrEJ2wlPt/C1Q6VjL/fBGqjtJM
Bq/2GR2GoBsE85jGM287hcvXV0eG5OwM
-----END CERTIFICATE-----
"
test/fixtures/keys/rsa_private_pkcs8_bad.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC33FiIiiexwLe/
P8DZx5HsqFlmUO7/lvJ7necJVNwqdZ3ax5jpQB0p6uxfqeOvzcN3k5V7UFb/Am+n
kSNZMAZhsWzCU2Z4Pjh50QYz3f0Hour7/yIGStOLyYY3hgLK2K8TbhgjQPhdkw9+
QtKlpvbL8fLgONAoGrVOFnRQGcr70iFffsm79mgZhKVMgYiHPJqJgGHvCtkGg9zM
gS7p63+Q3ZWedtFS2RhMX3uCBy/mH6EOlRCNBbRmA4xxNzyf5GQaki3T+Iz9tOMj
dPP+CwV2LqEdylmBuik8vrfTb3qIHLKKBAI8lXN26wWtA3kN4L7NP+cbKlCRlqct
vhmylLH1AgMBAAECggEBAJLZ6ti7yDKgY+LcT/NiBDqKyEUBlbMNZIW5vAPnBKbh
JIDO9WIv9Fs7qSpLbnFHnr0OYtGIfMPXtUiYkyw0QJSc+upHZMvbno4llpes0eHc
jWVTBWETON4oywvj/Kz53vRc9eiKhxVuVWyagNcQgYSprjzLA+9UTcWeB67Guyrf
8YJUE2LC23RiMA5nGYoSHfVRl0c75gj7A0X9nwpAI+xw3kcaVHRIhA6WowA3Pj1o
pK2t692+NLVRylpvMMSS4rziDexomFykCFukYWYB/kZOOSSETSsTWoMXXl1KqsoZ
8IW06NR4rXtIgQ3sTfbYKGZNF5nWFgZ+hJVx0We1Qg0CgYEA8UovlB4nrBm7xH+u
7XXBMbqxADQm5vaEZxw9eluc+tP7cIAI4sglMIvL/FMpbd2pEeP/BkR76NTDzzDu
PAZvUGRavgEjy0O9j2NAs/WPK4tZF+vFdunhnSh4EHAF4Ij9kbsUi90NOpbGfVqP
dOaHqzgHKoR23Cuusk9wFQ2XTV8CgYEAwxHdEYT9xrpfrHPqSBQPpO0dWGKJEkrW
Ob+76rSfuL8wGR4OBNmQdhLuU9zTIh22pog+XPnLPAecC+4yu/wtJ2SPCKiKDbJB
re0CKPyRfGqzvA3njXwMxXazU4kGs+2Fg+xu/iKbaIjxXrclBLhkxhBtySrwAFhx
xOk6fFcPLSsCgYEAqS/Mdr5CMRGGMH0bKhPUWEtAixUGZhJaunX5wY71Xoc/Gh4c
nO+b7BNJ/+5L8WZog0vr6PgiLhrqBaCYm2wjpyoG2o2wDHm+NAlzN/wp3G2EFhrS
xdOux+S1c0kpRcyoiAO2n29rNDa+jOzwBBcU8ACEPdLOCQl0IEFFJO33tl8CgYBY
DOIqnEsovsucvh3MNzHwkg8i7CdPGHSmUIN0J9/ItpPxYn2VdtccVOM6+3xZ8+uU
M/9iXGZ+TDkFsZk4/VUsaNmfYOQf1oyLA2ZsNcU90bQbeHNCi/H/19qOJFXgNaCE
sd5P3DMl9lptFGIjRVBHjvbfTQBUR5fi+BusMGfrTQKBgQCTtzMEJP2sef883AJr
XuGVPLzwLi9eTBvPzc5r5pfkvh7mDDmWFxHZm5kctvavqgy32uUPsQgMi1Kz67bU
s5dY9MCVrN2elhTLD8LOiAz8836o3AxFefm5cUWGaU/aZWDYR0QtNqFdyHyRaodo
JJfnfK+oK1Eq7+PvpXfVN9BkYw==
-----END RSA PRIVATE KEY-----
"
test/fs/test-fs-write-stream-close-without-callback.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import fs from 'fs';
import path from 'path';

import tmpdir from '../common/tmpdir';
tmpdir.refresh();

const s = fs.createWriteStream(path.join(tmpdir.path, 'nocallback'));

s.end('hello world');
s.close();
"
test/fixtures/keys/agent7-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAzb4ORHE95EYjgkrRim5qoImQ2zAxgzJkzhVBjKf31IvvFLyU
H0/S8ib4rU/jX3xZfBQdLKRZFzLLnicw2mr70N/LwFqUdFpRrwE7/tRCCKlEaLQe
J0OT9sC400c0jMmvawZgYexm4eQ72KcSoNyqtKVNzQbTPIuvLkt6RFlFOACVemUL
0+wBmXQn6AYDzetSF0P9EONpPiV2qMsrJwe9wwsIhLparROzNgJR1u8yxqB4NxDN
B6sgmQfN8kUZgJ61BHn9+IgrIXVsgIoPbYCekuV+F22ECEtWVhCffgiVgnB2m2ra
aKS1yq8HDiucGETU42PwOoXrVL0Eqv1oJ/k6gwIDAQABAoIBAEvZcmcXHIsotHSX
YrLXTCYNMUMtfENy86jqOzVAw2Qvhp+teiolAo7VgT5bwmZ0cIUG4U6Q9GtSBbEz
n5YWdOmnZ/VtL2fJ2G1dViH3XLTWumqjZK5zAnyoxjrV+HCi9jHNswDG55MF0m5o
Ab0ePSzF+G3Kw1uB376Agv3pr1QacVmMxsYxuUm8Ks0H3hB1E1rYByOcFgljq0EA
E7GuYG1JyjFcGsoyNPykpJ8Ri6mko5sbE7ndaTPqiYkovl02nsqGdiXSyrlC1Q7O
+XjfOO0gig6LFsWiKCWxQzJUOTD7RsqRaZTHnEHEf9iIcFmHh52i9Bt5r/lqNA/Q
D7V7vsECgYEA9pYzzZR4+xSYKfQHEpIdUGQTh1kFIdxHp/W4HD+3NJc+DIeUWGVl
7oUGcZvcEDfQojM3LUNAof/NuPuLinjKKzycRBU05ApuLIP9R1mq8ndxe98jxOIM
sCd/UfKHKAtOlyWnLvLuJZLozVYack+9/ZnEDUuz9u1S3l+IPUNiSmMCgYEA1Ziy
jFvchUecrXz1PFpW95psYMkCcgDYg26UwF8jrEcf26DblXs3O8mPGUqCwHOJHk+6
fEXMGbF7ocr+b2HMKuq5EaCFUJqu5orZLDqFuxCDee2OS/pxfTXaXwrnCKVrYzJU
9HNmuac4pryWnarnGbA56BlXp9mJsAbRcxiZOWECgYEAm1CKOn+9H/Cd0zb4SXMs
8ZjHUCX6/JPhsmIr3+cl/wMQOxYekvrzFCRHpcFVAAYX7EI0C9djW2Zi7pPKFaL1
O/yGNL/iu4vyTymnm4xYBzbCjRJEVltHQKDwKe6HwOo2Sy+VORYceCArcEI+kCe3
9IconHNFXE+pNZWYm3XY8B8CgYBmEHUhBLQ3K6T+cXttv21XG382MFbuyuCqzShf
VBbjt4jNlevXXe1isEmkuCoKdCrNRSPDRkbk8B43jZxO9NhumYKdnaqWfZOdrjNg
IwbMAHQSyyT3wVCBmD4ktDz5sLHD0MUvmgU4KWO0qOD/ri6H4+GHurRcDGLyrg9f
hB2TgQKBgH1WLbZEHvY07coCUdAywMCjcR2zmKrxo2rsmVrfjNNF0X0mh6Tsw8Af
BpL/j2bb7bHIIVKEystD2lx+zmOyLZOmT7nvZ7nFKiRKe4HwHiZW5N3JJjpGfBWU
vzPAbJHWnyctRihxgXbq6eGJEv5Dwgf6ERP83Cnn3JiDUNPuEIa4
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent8-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAvCbXGqz553XQ+W9zsQEaBc1/mhd4TFjivwbK1hSdTuB8vWyO
w6oZuqAJjctcIPmNXf01zV1+cAurpoU8k9SmtetwqaDV0K5ooKUuzgAefRoLJqU0
XonW4VaK0ICQATkxSWdJzYET68NTukv5f9Fh0Jfi2Q6YPKlgUIuoTPQJSErAMsdp
h4KWMP7zsaEZNJhmZ1Lprfm4DdVnwUfYvDhq5VmAHFLjVor/z3DJS+pW9oORDta3
CMvAY5oGcIYWWMxsoG9B9NtTTs58jjeFpJrw/RYJA/CMuRawLWKt/z1zPhzmvknT
KfAIc6SjbBqu8Nx/Xvcd61c2V39U/nZDTs+H9QIDAQABAoIBAQC0gx8EfMgWBLbF
WORKAaCRyKKPl8zWksCYPVAFLCnwLvf+VFRz7JJatofz/hMZn9K9Rd2EdhqELO42
CMYhnneDOasRUzlPyMSgu1m4UezuYTopjX485Um/T2RGvdFrGw/qOKpZ+2i9XNzL
c3Cf7KZHljERxirQqD+7hwGlMsxlCYpIRYbe6orpT0aAiGr1iVioohyk8tT+7iXD
mlPeF9qbWAChgfLzTmHcpxGpiFXS0w6KV1XG8sickm1tnoXbCV5ZJw6HscL5VBp9
SBclRo8AXWBaqhcfj0mvLJWs5E5K3P6dM9X/RcxJwP4Q+kfABYoYjZrZ1/sOJkZr
mHzoYznRAoGBAPeDWWG5RLSlYgs6Llw9ERF3917AiY+eWUCai7faWGP3SEigmPOm
m7rHQcI650DN22aXm8DBSRM1QV0C/UWd1DoDpQAc76GexJhLYRA8/ZGAe24/q1nX
V0aDHzTLC6m8fYGj5ATOotvzYYz6aK9dCuLxPYfWmyZsIXU6K+ypsZOrAoGBAMKa
a+7es33C8aUf6kvBOtPPs9tJW8rhox9gMQxHXuibz+0ZUM7h0DUbsMkDpj4Ydwqr
c7O5sIHUjJLSmw7Oaw6xByK51tZNZeA3bVB2ZUAPILNkF2UqldRYRT7DfLTHEbNV
DMo5P4tR8HxWdrKuhcp+RdPfVmay7iIkFtcKWbLfAoGAR34nKTUMhWln4npRvc7d
yT/vsezHTzab7S82wEpPUcCxnljVFTvAq7i2Y9YDyhIsF3wfPxQVeXjegnFEmwE1
tfQritbQ2Mw1WRAc30XesFJ+VKALbI3o5bMmJmen3MVXM0UVrdXJ8OJiAQiriEvF
wzuPXFc+xWBiYawF1/xEELUCgYAYBm6K2A262gVxSGZpodp8aekfiof9nSvBZOPJ
S0ppV0stT3HNiM1msRt7RasRgX244H/xUVx8Otx8B+pCwrMu5iYmYGEopfeM3eru
Ax/u768u1o2Y3NAQnjE2VXYg7269ACQLF1REBAK3pwkSeD9mR36hcLI/DZoetuvm
8o0uawKBgQCGwazVcS1cOOODw8mP39KIlWNtbpeRI6T4Qz8Z4FO5B324uccRmxL6
gCRTdO0990mYQ/BJQ0EQWyrcnpqSfw1YYQOYpYvPexhKpRV+sU5KqJJkqEBe3WLm
oiaFpuz+NtKkQrCc9AlA3SHlJWPo7jTjIPCpGuVM+FipGTbLGHr7HA==
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent9-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEAtqBDJNhCsCGa8eCDzXBox8OQzrvAPMia3FhuKU4VGna78DCO
20OEMDYB5uD1aW4wD20lLET1/fD1i+hnKaB9JZiffo/QghCBJFvo+cDO4WAV1Ehr
gGWX5Ha6W2R7L8KWI9lN/bH5lMhk9YAWxgZmgMzg4WWqmEpvVXWikuekkTHstz27
MfopMpYIhMjxaESgNeNWbsc9TCosLMyx7ss+qQmSmCu8dXZRBot4d3b5EQHTMnkl
yZGAmRm0uRW5djrluKUlj+J6PzPetLwcBGL7iTw7casRnsxOdaF6eFuJfZPk2Dzn
xiQ1VtDwIPiaX23qS3rYBWjvf3jVnrN+AIRehQIDAQABAoIBAQCxMp0TkfZa+bBi
woqAenJgaeQGg2vKTobcB72TvFyDmfNO4X6rRz5qnOyJfXsBelWNkkSASMU6SWOn
Ba+bV0o2gXk4DwisOqFjiv5p3uedDGMB3+bW5TxVA9JcPQm91JtjW0TuRJK7BxnW
jxsJt0ob7S7B5Kh7LbYLAKHm0nX+HgFcfiaRsVCiCtuYkTOzpkUQsl7psX4VJJQ+
SYr4URsPZI7SGdIeq6ofKH/yGJeoYyhxfNDzNZXqdIC1LEU4BrsrBR6mVRTj35+K
0pHiOQ5Eezi5BnEFUgRR6ompTXQGfnDgEmNyuhzVhuP6nFJ/QPO2KUcIkU4cqViC
7ZTeaLjdAoGBAPNfZbi515DhtwdwDx/Ol0Y6kzyK2NP2FpMlGXwUKXSYbmwbSxSo
zXGyCjxmKtQfbwzVSd/aNdH1lPCHerNFmumhL52wsWi/9EIT+liaxN8Cw/IbUuOy
QlA8BT3Pf1H4Fv/ePIx1DuiPk5jp/eyAK/iPVCyXu7d85ULdfhvwVS7XAoGBAMAZ
/x7dP7qRAUgjvCw8JQVpJPxeVvraKHpzQnceIhd88oTAIYHONNomSBAlqoT00JzW
uFkDbtMZydhorOCUR/d6oHWyg4qEt7F89mssvCFXkROs+ePCuvspYO4F9B7/A7HT
dwErWsvEaRmEO/AWRvHMhjTV4F5ZMNvPj3E1YX4DAoGBAMM/y7oRzrG7hD2BV4Dr
G04KfElcE2ypx56xauqyujeCe0Rb+TZP3tLSRYgDZ2Ta+xrOmv/ubrNNVPpLltLw
isHYwPy/3vTs2yeQI46mTD+mVlGMPknSn4UDQik+qSS35qvMPcNpvlYxqfZJ85+j
jKNTSfKkoMMqfjvQuvXrMEvtAoGAIjZ/EWgmKXwZ1ldG9Dnh/gyz4Z6LrzGbc/OD
KuPa/oPqTWpKjWvETfXzb6zFqdhQLx6uxmuuGTrGkBxUbcr65kCYw11/v/PTI3E2
EfBtsSJ/XBm6h63uzzyXXs0ApWSVq94Vm8e07AWXEkxSwHe3OulKHa7ZvvPzl7Jn
wanYKzECgYEAun2EZ1ETQ10fkQ9RYxeJYd3HjazTfWXUJJeVhPlsLQQyVfZoRwy0
9nzdOclgSvE2/+m3SQFh4UHTddlrU1C/V8pkgImnOyCmBFEv8SAfuvEnhQWA13kA
bfreLGMiDnbK1+7MEq0CJeIUZ1LWeuHlFNJT8bYvyjLiZcJyipgQ3NA=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/fake-cnnic-root-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA0nOFmJ4C0bUucql6YlXHPVyuxh5IxZ0heSjVCJXpVk9JJRPx
pU0Py1tSTW7GJSMRIsvFrrbVfb52YHOzaGwMiJ5OcR1cCVXWR5fci0lS0mTh8Rf+
igHjKe/qrpOoqWzw7a0AHkFbcA5pGOZcB9qW2aMq3+mv4z+K8Jpw/b7G4QGeEfNx
52xM/ygtW51GnmxFJp0eTrIQmJbPFKVrjjdAner+8v9fgmrYiFydFknfEqzFlsO1
hcflw3caVD/usBpHq4VVvzy2fPqx6VJsloMYyNlCJIvrC0woHb/yj7DaJEnHu0Md
EhrxzA+biw0/sgOH3au2FdtPoZlmloyReydiGQIDAQABAoIBAEDF04mcoIuA81HR
PdzEP/Vv8E8EBSvlZ+cNnTvuQAoTjxS9ZbOV21Wgvt0cShomB+EozKgwl9cC5xZa
pg5uqxDlgIkqGyi4ZaJVaEjqgXZGHJCC7RH28L74m8etpMy4vhK5G380aHs9xDUo
uYylR6ampMyT9VHBPfc94acHr9iSguuPlZcO37aBc7BPRTa6MBFtLC8c2K7ybI+b
yeGJypsd3N5aIzM3+JOVJQzD/3jNHODdAZKdCw5ZAfrUBIS4OaI/bC+3Ke/OvTrI
tliXqHemlJNdVbGdOneaUu6Ysq/en4NK3d86b03dGrLnCsWeMa194TXYfLRQEVtn
qbuXroECgYEA75KNQ7Fr7SX9r/TCp7Qro3cVoFxsgntypay3uqoiq2dJTvyBcgYh
eawfY4vE2YVTGRmlwqits0SMr6VBa/BqFwm7D2IDqJDJ4blggmJ6m9qMQLADg2Mc
CX5rRu24NsH8LEcikvXJy/qPUeFm8JDjEcRui66KLaM/IeVh5NZZn2kCgYEA4OHG
84ExUNEXk7qoCd3CSlkFYj/7NgMcEiEeRI1gViaLp7XuI4i1my0JZbvmznyAUsxd
NdDsYpqvETKuXA5G9doJwI5Y4FkMt9nfPniKsHESwvaIardeM42DuUOtnYApi74d
GRd6RipJHFdfv6GNaftx5w2nyIVn1vfYaAsEBzECgYBOIh/MWgr29xL71fm+NDaf
Q3FcMYh6LcTAX8o0KNTRzgfMqPGWvIUiZ459KtJyltb5MrIrAFRWSR8REfZ6O5h+
FwBZDgBfc4lEAu+E1pViSy6+0ijzKtm0BvT51wHjafTShAi0oVDFI9ymObsW7koA
O25KRAxwwfMPHP6GYZotMQKBgCJ5mmV0Ndo8489q+x3gGEwLj667PkjOezwwRZKe
1dj/OcOxOVvLNoQeiGVHRB/9qDKJT/TTHZoUOqh5S4+jRK+mCH6zk9546GE7DmVm
V2SrQQQQhWNOzys6E6qQPIp7vmLE93METWN6UhD9OBmJq8NGn/Sa/FDaWsvy3QM+
RRTRAoGBAKQJMSfuiEB42TtVm0VnIbs+r9iDXgKi0ifDQSQyHjptYL2KF5GCNljY
d9ZZJJsfMmj2pDeggLE9RB8yANQGQ87KfvZ45pZ6qL48Efw5ZknpeSjswHby87Qc
24HmFjQKg6DhN+mRmxRjKe1rQpchRkaoO5kFmE2IUknuIybUkKMV
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/fake-startcom-root-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA1mZ/bufFVPGxKagC8W7hpBephIFIZw9KbX6ska2PXZkyqRTo
U5UFgTYhdBwkCNJMwaYfTqLpc9y/goRpVlLSAFk/t4W6Z0w1b80T149XvmelAUQT
BJR49kkYspN+Jw627pf8tmmSkG5qcHykB9gr/nvoTpXtlk2tum/SL3BQSqXmqffB
M/6VpFvGAB2FNWGQUIxj55e/7p9Opjo8yS4s2lnbovV6OSJ/CnqEYt6Ur4kdLwVO
LKlMKRG3H4q65UXfoVpE+XhFgKADAiMZySSGjBsbjF6ADPnP/zNklvYwcM0phtQi
vmkKEcSOvJNsZodszYhoiwie5OknOo7Mqz9jqQIDAQABAoIBAAcdibcljAAAsW9/
evGGS4jFnEOggsWg1UiC/rkq+GoTzoGcBwXXGUKriDqxQGTmjdOTbtCOSY8l0VlE
ibZqszt9usadco1BEzjtpm3t/Ox9xhUfrD3nq4gI7v/mMzaan2mVs7ZeFJYkg/XN
vSfhfbxJYnFROnxVgaGBWolmgdOoVE1gB/aRlHO9XTF08Rq1+gQFCUxPDKSEtwFQ
L/7Bw4NrbnE7W3WAsSmPjd/tH3UfjCcVaRvMyqFNaeLbmt/6uCbaZbIJVgXhPfKS
Z+ANYWRPi8WSf9bEbj2Xu7hdI/jvFSe44zHvBCnSfjw0RSgoNc5GTT+d37C/Him1
AyAa3z0CgYEA7C+KsqSJM+0xiwyJlRDzlfW3kf/SdobYCQOkXx17w/RjmZsQNwWr
EgHO/xqm+5YSrxeQEFbzHjCWLYw7k1bEBjC/tFAV16+1P275RDnOHzRm3xTWN74P
Q6ECjy6ww9QwyPIdXwKuTp3MFeG4jfTH4glGKGTKC3n5SZ9JZLVu+DMCgYEA6GMU
+gKBnsPH1wtWbpgezBlEApfPiE8E4sNInh5dwDYBVozr4+Es9eP7CQ0Dh2pSnc3U
FgbsJ15J9ojkyL0MA9zS/z/rqVjyybeb86My7GGZJ7zTkBMXoH35H8hzDYAe5blQ
X9N67UJ1dsWb+Vj83mUkw4NzCM958JO3trBAyLMCgYA12yFlWt9uV8fUTSeSNitV
JpKVWCBFprncVFhG2BJAvJl5jUJFSaWYlZD92rX46F+aTWUsVKdbWvjjqfZrwn0w
bC1KkHhqlkZeEJAGXqgBtZE/jSDL1Srl4PEUdTEZdmkpaQwJfjMA+jpvQukydX6e
rD6zN0hbFZUilI/HxxdmwQKBgFyKaGYO7XM936zhFPBBn7IDNbQapEhRv05WGert
iMPsPagrwhwjJXZd7S/zgL5CNtgkiRqkcxJSV/3XEdRmhAxduaBv4fa0Nyrg9TeW
e8bqLsVGSrGLCNOelsBzYG214Zf1re4bF064MnKzyqMHLtuZR4ScKgkOJi8JhBU6
JvJFAoGBAIEmjibErM1/gjh+8MfEZHSuziP0+8bcRSEsKWz1oqqI2gRIzw5ffVOF
xU5FuiYPrY9OZ4Gtva88M9/JGfwQSc8S6gmIWx/eFFSTW/ys/XYH3j0hCUv08Te9
lCTRX9ivVNvmUenLWe30V283TgdoQXlHVJnu2xQLxMrJeUuOKGMi
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/rsa_private.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEAt9xYiIonscC3vz/A2ceR7KhZZlDu/5bye53nCVTcKnWd2seY
6UAdKersX6njr83Dd5OVe1BW/wJvp5EjWTAGYbFswlNmeD44edEGM939B6Lq+/8i
BkrTi8mGN4YCytivE24YI0D4XZMPfkLSpab2y/Hy4DjQKBq1ThZ0UBnK+9IhX37J
u/ZoGYSlTIGIhzyaiYBh7wrZBoPczIEu6et/kN2VnnbRUtkYTF97ggcv5h+hDpUQ
jQW0ZgOMcTc8n+RkGpIt0/iM/bTjI3Tz/gsFdi6hHcpZgbopPL630296iByyigQC
PJVzdusFrQN5DeC+zT/nGypQkZanLb4ZspSx9QIDAQABAoIBAQCS2erYu8gyoGPi
3E/zYgQ6ishFAZWzDWSFubwD5wSm4SSAzvViL/RbO6kqS25xR569DmLRiHzD17VI
mJMsNECUnPrqR2TL256OJZaXrNHh3I1lUwVhEzjeKMsL4/ys+d70XPXoiocVblVs
moDXEIGEqa48ywPvVE3Fngeuxrsq3/GCVBNiwtt0YjAOZxmKEh31UZdHO+YI+wNF
/Z8KQCPscN5HGlR0SIQOlqMANz49aKStrevdvjS1UcpabzDEkuK84g3saJhcpAhb
pGFmAf5GTjkkhE0rE1qDF15dSqrKGfCFtOjUeK17SIEN7E322ChmTReZ1hYGfoSV
cdFntUINAoGBAPFKL5QeJ6wZu8R/ru11wTG6sQA0Jub2hGccPXpbnPrT+3CACOLI
JTCLy/xTKW3dqRHj/wZEe+jUw88w7jwGb1BkWr4BI8tDvY9jQLP1jyuLWRfrxXbp
4Z0oeBBwBeCI/ZG7FIvdDTqWxn1aj3Tmh6s4ByqEdtwrrrJPcBUNl01fAoGBAMMR
3RGE/ca6X6xz6kgUD6TtHVhiiRJK1jm/u+q0n7i/MBkeDgTZkHYS7lPc0yIdtqaI
Plz5yzwHnAvuMrv8LSdkjwioig2yQa3tAij8kXxqs7wN5418DMV2s1OJBrPthYPs
bv4im2iI8V63JQS4ZMYQbckq8ABYccTpOnxXDy0rAoGBAKkvzHa+QjERhjB9GyoT
1FhLQIsVBmYSWrp1+cGO9V6HPxoeHJzvm+wTSf/uS/FmaINL6+j4Ii4a6gWgmJts
I6cqBtqNsAx5vjQJczf8KdxthBYa0sXTrsfktXNJKUXMqIgDtp9vazQ2vozs8AQX
FPAAhD3SzgkJdCBBRSTt97ZfAoGAWAziKpxLKL7LnL4dzDcx8JIPIuwnTxh0plCD
dCffyLaT8WJ9lXbXHFTjOvt8WfPrlDP/Ylxmfkw5BbGZOP1VLGjZn2DkH9aMiwNm
bDXFPdG0G3hzQovx/9fajiRV4DWghLHeT9wzJfZabRRiI0VQR472300AVEeX4vgb
rDBn600CgYEAk7czBCT9rHn/PNwCa17hlTy88C4vXkwbz83Oa+aX5L4e5gw5lhcR
2ZuZHLb2r6oMt9rlD7EIDItSs+u21LOXWPTAlazdnpYUyw/CzogM/PN+qNwMRXn5
uXFFhmlP2mVg2EdELTahXch8kWqHaCSX53yvqCtRKu/j76V31TfQZGM=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/rsa_private_2048.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEArk4OqxBqU5/k0FoUDU7CpZpjz6YJEXUpyqeJmFRVZPMUv/Rc
7U4seLY+Qp6k26T/wlQ2WJWuyY+VJcbQNWLvjJWks5HWknwDuVs6sjuTM8CfHWn1
960JkK5Ec2TjRhCQ1KJy+uc3GJLtWb4rWVgTbbaaC5fiR1/GeuJ8JH1Q50lB3mDs
NGIk1U5jhNaYY82hYvlbErf6Ft5njHK0BOM5OTvQ6BBv7c363WNG7tYlNw1J40du
p9OQPo5JmXN/h+sRbdgG8iUxrkRibuGv7loh52QQgq2snznuRMdKidRfUZjCDGgw
bgK23Q7n8VZ9Y10j8PIvPTLJ83PX4lOEA37JlwIDAQABAoIBACoL2Ev5lLyBaI+9
+vJO2nNaL9OKSMu2SJODIJTnWwYUASBg0P3Jir6/r3sgi8IUJkH5UHbD/LrQcPkA
4X7PU9vEyUsr1efWFIvk7t7JsjOctoVA5z2Mty74arivUIe5PUadvUC6/7Zk0u6A
CjLuJRmlH7nGNKZk+xrvgWTH+fkgc5ddbFxoGH129RcVC+ePbsi1EF60C9KbJvp1
xjUJ5cDtNYnZ/g+ULo6ZJjRG5kUCVSI8H/Nc/DmStKsjN0isKpNGofU5ArEwywGC
Cqxz/tr4hT2haAkVEto04ooYpqDUSqGEfPpLWL+CjFNPfCsWJ1tX5LQRvpu6eukd
FO72oVECgYEA4+Ot7RQtGOtPeaxl3P7sbEzBZk0W/ZhCk+mzE2iYh0QXU44VtjtO
/9CENajTklckiwlxjqBZ5NO1SiMQKBcmqkoA03x/DEujo2rMVuNPoc6ZYp1Gc4qA
4ImkMQNsM7Swum42rKE960WoiWW7dsdEAq6vqgeApZlMU8lcKRAlOZkCgYEAw85H
3bjF7gMatVibsWzj0zp2L4616m2v5Z3YkgohGRAvm1912DI5ku5Nmy9am57Z1EP2
UtDOxahd/Vf6mK9lR4YEbNW1TenykViQJ6lmljOFUeZEZYYO3O+fthkyN/42l5yn
MyUANTTb2rvt8amdRr0ARdRqWJmt5NfJzYBV+q8CgYB1ZjuZoQVCiybcRcYMPX/K
oxgW/avUZPYXgRNx8jZxqNBjiRUCVjdybhdOFXU5NI9s2SaZFV56Fd6VHM8b+CFB
JPKcAMzqpqTccQ5nzJ6fevFl7iP3LekKw53EakD5uiI5SMH92OsvIymZ7sDOhgUx
ZJC2hTrvFLRPjbJerSSgMQKBgAv5iZuduT0dI30DtkHbjvNUF/ZAnA+CNcetJ5mG
1Q9bVg4CgIqAR9UcjdJ3yurJhDjfDylxa7Pa4CSmRMUhtOfy4kJlr3jcXeFVsTs7
uPJmpDimBHjRAgew/+t7Dv8tpNkQ04jlMmYOnYN7CspEvUGePW4H15kjjOb563WN
67QxAoGAdhJPaHVtDBUrobn50ORVkVNJVZPBhEDbR6tNtHsgEevH7iYjxAdxEeUa
c9S2iV9lir3hkrQceiYWAADcphWfO1HyP5Uld4sJzYiEGbSM7a0zRQjYlQgXFbZo
SAc6Gok78kwECPwpmeH4lpGVeKNmzEteSBVYxGb9b6C/SSsu7l0=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/rsa_private_b.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAyb1grrN+29fxeeEbTaSEja6TKDTpT/WXnqrFCS+h7IYcnDoA
VwcsPU5FZeUPvLKMzi9NHSJ34LQCurqHgH8X+cw0YT3gdYS/7qoQiXs+zKv615Nc
ttD3xlQLceY+NwznoPXyyZwOeZqyU5Hiqbrqu6hdr6gQYogMNLn2NxBW2pGegd6+
ZGMCX3+/BtMP/6tXmttYjY+yhN2SrGz5cKhWpcHiC6X+B7uCKoKZy+t2jUxYVKUw
Wr1ZuM8kpSnuVCcv1OoMGEimEHA7v/eaF/y+z/VdQ4Y88GhTnVN4KbtgZ+o9Pohj
xLFU62VeTALixU5mPQKSgSICKfjev0FUUurF6wIDAQABAoIBAQCs11C/PM/iYNfl
mSSAWAStMrWni/Wc6QhXC2422ZV8hMZ8XwEtjtqrR6UTkLXz8HHMsR/7Zy2X2gJA
o1E2mS0ceoUiDxaA+RRL0W7Lq0j5qBsImZukkdLHG/iWRDJnjenhsParHsYUD6Lb
ELFGw/safjyOI4quMGtsvSqisKAJL5ZCPD5JHLhnNP8HXT6icSZrsqGhunb2tsa+
Ogcx1+bZzqdTsbvXdbw07Lnd/LRU0NDhjeEVl4J2yFNYY+OIj7/qrxSnZnGLLG0Y
DFxiD+HCMvTBSooqvWI6FAipfyCGjUznGsVaRv7TuzHPuKE4LtbIC/Ac3Q10rKWq
PmHALir5AoGBAOhGUCToWfYnj2zH0GIZQxnkrv9iRqmdGeCDX6ZM00Bs5tASnRo0
o90UtLbhWjHe1PKRKFyD4I7a8iIWxcWWun2XHgOtItctPN+lbjpTHTyE2yA1iZhe
dKCV3bAo4t+puKrPkZmaBqFD/fQx7DNxYdRERa1giiZGhlMUN3l7/S21AoGBAN5Y
nZ68NkTgklk4YBzsxwsMpQbgbihyG79gtDFxWonxZUQ29EsL01yd30pJNhg1LxDN
0fADfHVzkZ3qYz9knge9a75Yk8UBM3DM+xu+DRkjKhK5mPX5oLvj6061u3Scs6tj
orpU/mV1amz5gqrkefMaelsdHRuGGZQVx9KTV2kfAoGBAN7EAL1E8nK4Qj/r6xkK
bWZ6ArQABxFJELZYiPWvnLOfPka0c2PctIOmBiOXQa+urMDvIqyH9mhL6Al1mbwE
8VreAfU4qb+BLW649FyPteyC5r2fWxV9EZGp6fG3ZM9psShw5o1QQaeM1BTNhGFa
Dp9L0x+TBSvsW4t2SjYDCjA5AoGASzxxGWVWd7gFzWrmGuOD9pkwvkLzA3yZJwjx
8EkK+eJVAeAWic5WluBUzi43v7k/U9BRWYXUd2nDvEuziZ/iWXwfGSmf1umxHlo+
HgURKZBcjDmBKLpvSSS2WsvjwnHD2hq81ZAtBOfWO0myjWECYuByxqHzV3zo6tLz
6q0wxsECgYA26twPrAoRqvfvPnNj6o0LrsE39Tj6jHIVijT7Lbcf2xVnaDiQ18PQ
RC6Tgkz5KZf8GKfMRMA3WopGn9QE2luI4RLIbhLozEDrkk2L7wSYqI9DZ1Hd26wf
v3+3jdpsXkzHwWYz1a2+FhCF5mJJRQl6kd/B0wu00vdfwviK9OVO7w==
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/rsa_pss_private_2048_sha256_sha256_16.pem,"-----BEGIN PRIVATE KEY-----
MIIE7wIBADA9BgkqhkiG9w0BAQowMKANMAsGCWCGSAFlAwQCAaEaMBgGCSqGSIb3
DQEBCDALBglghkgBZQMEAgGiAwIBEASCBKkwggSlAgEAAoIBAQDfqNM4C+QtD73i
ILqOkqfV8ha3O19jpX8UujIk1Z72bbbuwEzh0+sBw0dD0N8CgkXnePOEEd6q7HNm
byCNqRpDK6NDvaCMDWgEaD/PlHkRntvKh81IXSMC5imjRfOcZIE/Gnw7h8tanab0
n75+ODvLJrmEWUG2q79Im1mWMx7Spod+Np6XEY+7I7nAUUWivr35Yx5DeyxY8rxF
GpsLtGsi7JNQO4aHyeBpj8tz0Fhv23uPywE2nGmPHfnkXWbrTcHGbzYBgEbeSH9K
UkRwczqDXNOPhtfaEHEFTm0MoeKCnJe1VOjSywev77dV1KZfpVh3Kh0ZRQIe9YOV
Jhj4lMx3AgMBAAECggEBAIc+IgK5Bg/NfgeXvNdrjPuM+PlxeHvb3h1dfebSGd5v
d3elZpgDug6F07kJO2Db/4M5mx7YY2m9swZU2j1u7MeDQqU6rDMkBCruEu/lmtPx
2Hv+ZD6Gux4MqU7mhKmkCJds34Rr16aCwCsZ0WmnfViZoQKLqnXYIsG31pNBdDjx
gke0HhX1LkA9yTVwlk8xOaHPqI4KfsFAyoiiHzyttGDexzb1PzmM0pybAPDMhpN/
wXp2kLjyzmUmPe2Y2yva69WVWo7qS6joKjY75MQ1t20HYgEL69IApvCPu4CANfi9
j3FAaV/+WrnhKCi6QyUi5PCI/+AJLsjNQmqTXIdBEoECgYEA+XsgFbeZ6+ZzEHa7
HyFH6kiyBLd0q7w+ZLPsoOmEApDaP3yXSC7eJU7M/tPUPj8VQMMSK2D6fgmUDwhb
3mEXFZxf67UlPFsFjweYcBihwy4r8QKBwury6dEbHPSUq4mXFJF5XRQdGqRGkr/F
8OLZ0MwmHLUzczA67PxP/wF8TsECgYEA5YD4RxxJJYfAk1rFbqHRhNB8UeYVL+Wo
wsRET1JeFg+S5grLGUga+KBB8Jn7Ahaip7MVE0Iud1cgaDi4WBEJsbJ6oJTlHJEg
Jq7QAaBafwjeSCSnaEsVBVNvriy2WF7uAomLSKmW6uSUOBBFFt4+G+akG56EfOPc
7YKBfsf5ITcCgYBvjVZzX307tfeNTQmuibsWTxsKcN2CTNG5RZpw+PlGDG8KJDOg
2xQJqoqPBzjH/H0MUC03qE1ZPf8uGZa6gL9JsnpRctYLfselhMfsl5b9JxAO3AgZ
l+S2GAH/mH1BlmwvjjyuGehJmVrVE1r2sviiHCaOf5dZ0h8HCGrco1VqAQKBgQCf
fYkMofOTSUvjG2mpAHuCOQCsSaDfsFIfSBXQqgUIf7ouc8HAyAM2VOh+NAPj56cR
s7opsAxqkvnKc+BoEy8Rdl8RyWeO+qvFNicHelBph9gxeod8SvFIyjsKZ7gwoYf1
63AIBxMCGeeHLodU5Q10hkv1hau8vv2BcPhdCstu8QKBgQDgO4Rr36Pa5rjbNbGN
PsJqALjthTeU0yaU8hdC7Hc7B/T6npEIhw3s1eNq7e0eeDltqz7tDnY8qysazbQZ
p1cV5TJ8+gtwGmDoADBnU1NXqX4Squfml6OhNEucpTdjux7JdLVmmQFraOT2Eu5f
9uuNtA+d8uhBEXhskuvEC552ug==
-----END PRIVATE KEY-----
"
test/fixtures/keys/rsa_pss_private_2048_sha512_sha256_20.pem,"-----BEGIN PRIVATE KEY-----
MIIE5wIBADA4BgkqhkiG9w0BAQowK6ANMAsGCWCGSAFlAwQCA6EaMBgGCSqGSIb3
DQEBCDALBglghkgBZQMEAgEEggSmMIIEogIBAAKCAQEAvM9NgMCDqy5dqj5Ua2cZ
cc4zVr+fCF34bZn63OBeYG8RTJKM3j36lO/yamtfDctDhb87b45CS6ipEr8J57I9
WF55TNngsn6GNpXgwAe0eFXUnKonuqnGEC7x8r3vkAg99PBKhAtFc5oTaaZDAFKM
zc5dIC/J0Y+kxhqjCPNI0ydQgZmKBrmYjM9cvbOYgRQL10GrWeJ+XHk2E33endaF
+4dwjgyrzInt/l6OTkiCL8F59J/htk1GPru9BT6w5yOS/vH6q6FD6uizULVznytd
lHjgnrVaHJmsqVjrYQa9OAZj9GBrTelBWvQ9b6+FBHUFHBp8HSp82lWCZThPrcZ/
QwIDAQABAoIBADDzUfWic8CKuc/sbviVdzxRKHBCJ9oEeub3d9mR9gXsZcDDcfAg
g3nfp6q9gZxS6YOga6llaXyyEnuAufGu/UaO38Xz6tR8BxHZ07YViU11ezTOzJQR
df82HJZBdf2SlXWOYtNPFMd+16+ZYl+QB19INE6m9Rz2r9KIj2I/qM7NPPVhDRF0
G4O0Yf2vaPhjoIaewn7xtQ6wmX7pAGcd8dmYEIGGkBi8aY3BVwrRK1X4AmD+oSmE
wXqR6MQIzD4KdypL4UD1Cb4GoFeVRclXvegOG+EKl0iD+mjTodB4yjoJh98NYe3+
GtpR/2u3Ltq8RqWpIg8ryShQk/MIqGJ5KpkCgYEA80uNEYWlBt6QGNvVIYrhnw+V
2nLJWedioKV4H1sr9OLF/7WFOUfsaflpVybnmwfNV15lEyHb/m/sCM9jTrNk1t/q
qhRnvtmy3kntxWBeoA2o0TRg/XZKWjabZsr/4UE/Ztws2opOvl9x05IYeZlU+PbZ
B1lX2e+vtMOpllvRr28CgYEAxqtfrYv8brp/fAUqGu/MtdHxQdU1+vE+auN17gam
ZM6ojIeasX4k2z0Rd/+8Dga9wPgO7hjtFZ2NWD5UwfBiw5U2PVZ6bp3iKSBPGHEh
RsIR+nw8pFIgsQKoYnVK58tEnfQ31GSupKpYybHbaL5SdId+mfXU86SbKX/MefZX
g20CgYBjn8hAKI2O5ovy4fHALnJ9A5DFRsOUgN8uERPDIz44pLOXJelLr1vreSnd
ehzUqrk20Xxp/S9sXMA2S1XK4EKmikI5KungiJxp0bP/Yprcxzsdj2k34LxJfJrd
2Lo2rtUbdYUYaBIeek7N58EF6feVit8L11XV9APq7UQAQdD3GQKBgBmxuGIdpLw9
apeDo3pwYS1yxZ0aEi0uXkA8wtfSDFslTy89qogiJGomb8fxT0URIiF+849fseoF
wm4TQasDiAJ7ndQ5BwSfbsya3R/wIbmhB+o5fy5RYOED0vtI6DMqWumC2GWjz+KE
FY+gbRwS4V8o1vrajHwmYdrwKGXtskvRAoGADe/EdlCj98r6Zle9giF1C0GDIDTx
8bR2m+Ogh9ZO218GpDMNaQ/WmbYVPDYMbRSOEA7y2gVkd1OeYhJMF6aYffp3aWhN
t9g0uojLY0jfEpWBLBQdlYOTl7hOnLWRRcOAKTlHVg+OuD/O/GmdQ2Rg2H/hAWlI
muuTQPuQTCV1aTc=
-----END PRIVATE KEY-----
"
test/fixtures/keys/selfsigned-no-keycertsign/key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIIEpgIBAAKCAQEA11wz7hAhdN072sp2aTySdsla65aZT10L1o74JNBZmMyeDSq7
Lbbvqq8XuLlwogS0ACAQVEjL7GPVMgJwzRytdaSWdzr26dftPCL3m1h8azU/Bs1n
afHWhi3rx8RQnLfyusq0fThR9Xd3xfjDuaqhoa7Nc36XbG98XWkgxpm2R7wRpLyN
T9K2Ixvry9orZicTxv0Zyq+tD3CzSEch5OCApVZNaqEcIDgiN1zE/zqIe83v9+NY
pLo61yPiqqedCqZaKp037uwJCp/RL9g6bh7IFDGZcNFv3k0xjZB4BVm4BZMpSlbI
49hncVIJZNB7qWt5ilCzEbwOhgLt6Y3Yh8rgMwIDAQABAoIBAQCWK7oeX+skdXxe
RV2qZk1vPVsD+kCvYZ92nr0T1qETdmMjpU9eQjj/GRb+fXi30XW+vJ0GWLix/q9U
LvV/YWbnKLyvKVOxnhrUG0HzdhFUJI3tbV+WNce0SuMlqpPXpEFC1URkKNilxQek
6aF5ny0T9DNZPMXUHC1paXwsYFUF0SwtRalY/UheRvTLZgJJAS13SR4mDZ2MJNiy
NkLOaokGqI+U9euNsbZoJi1Oh4jOoA623NlVntPjfDc1Wzwsp/rMrJFiyfrBHlln
sjAcArcNrAR6GosX4kfQIKdHXZFMhRLm6vJSSbROIIoqOTPJF8kFYKqSQMQCT0sd
v8fVw35pAoGBAO7/LTrKcFth/VuqkyHFCvfIuXrHtEJon0MjsCN+IZu+WFsjjZ/7
mMOHqWPBb1oXBdarWFshdq5zVCcoA/hH1H6BAi4zOlU2vaQdeejbhlWWt5GVRl70
fa2RpyGmzTIbj6QDpv1GROQxhk4lsFp/4Jtd4wnI71P2fF+gTk+VxG1VAoGBAOau
iPMVeNgSHAT0f0ms6+tdyiRf3jo8afd9TSN4g0324Cd/hIzd5ysjf9WfN3xni0tQ
Ho8v1CKvt1xFCG9kgApHE+umLOEF5X1LwZzpPwp9PEN7tj0U6jis/spPqmToSrlB
hcqLVK3DRF268RADZtYCvbCeICUQIydeRzeqL1dnAoGBAORvkRq9flFKQvFIA+Pm
Q8p82BRsJ3bGK1vwE56JI7SKZkeOnwLIZ8aUt6p6rGUu1kzOb+CDBr5Ny6S1kb3R
YmEcDCp+moXykab46ZpRoX/TVFhZlu6RwEKTkm0O0tjPESeSuh0h+h0m3Rl62qpV
yiiWv7iNj3vwgAai4dcd7qcVAoGBAJtNwhG10QfXGVoUqWWWr7ZkDGV0zY5zgfwH
Ndm9ltj0bnDpHvofozSdz8CoUpjEtTjdFdXco3s+xbmvGEC2bqV8uOKbm/dbGufC
CvVy6uhK7DmanlR9Mjs57MeT3unUogobHNIB/96EahCYfRcE00Udz0uLCaUqOiCV
DmlhgEHdAoGBAIBgtzi2mZ7smMEvJqOSeRQT11PBLRasM0Ba/79oebSMFpbZ8mok
8PqfJvWYxISKYMWIHRygGbOmswhRDDrVN1E61NAisIwBc42tSTRafxfVfZ0LYa4I
c967Kr2Krio1rwUQptIhWqQQnLWhycvMKImLLE55J9mmDEf9Rat0TAQJ
-----END RSA PRIVATE KEY-----
"
example_js/react_ssr/component/Page.jsx,"import React from 'react';

class Page extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      <div>
        <div>This is page</div>
      </div>
    );
  }
}

export default Page;"
test/fixtures/keys/rsa_private_pkcs8.pem,"-----BEGIN PRIVATE KEY-----
MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC33FiIiiexwLe/
P8DZx5HsqFlmUO7/lvJ7necJVNwqdZ3ax5jpQB0p6uxfqeOvzcN3k5V7UFb/Am+n
kSNZMAZhsWzCU2Z4Pjh50QYz3f0Hour7/yIGStOLyYY3hgLK2K8TbhgjQPhdkw9+
QtKlpvbL8fLgONAoGrVOFnRQGcr70iFffsm79mgZhKVMgYiHPJqJgGHvCtkGg9zM
gS7p63+Q3ZWedtFS2RhMX3uCBy/mH6EOlRCNBbRmA4xxNzyf5GQaki3T+Iz9tOMj
dPP+CwV2LqEdylmBuik8vrfTb3qIHLKKBAI8lXN26wWtA3kN4L7NP+cbKlCRlqct
vhmylLH1AgMBAAECggEBAJLZ6ti7yDKgY+LcT/NiBDqKyEUBlbMNZIW5vAPnBKbh
JIDO9WIv9Fs7qSpLbnFHnr0OYtGIfMPXtUiYkyw0QJSc+upHZMvbno4llpes0eHc
jWVTBWETON4oywvj/Kz53vRc9eiKhxVuVWyagNcQgYSprjzLA+9UTcWeB67Guyrf
8YJUE2LC23RiMA5nGYoSHfVRl0c75gj7A0X9nwpAI+xw3kcaVHRIhA6WowA3Pj1o
pK2t692+NLVRylpvMMSS4rziDexomFykCFukYWYB/kZOOSSETSsTWoMXXl1KqsoZ
8IW06NR4rXtIgQ3sTfbYKGZNF5nWFgZ+hJVx0We1Qg0CgYEA8UovlB4nrBm7xH+u
7XXBMbqxADQm5vaEZxw9eluc+tP7cIAI4sglMIvL/FMpbd2pEeP/BkR76NTDzzDu
PAZvUGRavgEjy0O9j2NAs/WPK4tZF+vFdunhnSh4EHAF4Ij9kbsUi90NOpbGfVqP
dOaHqzgHKoR23Cuusk9wFQ2XTV8CgYEAwxHdEYT9xrpfrHPqSBQPpO0dWGKJEkrW
Ob+76rSfuL8wGR4OBNmQdhLuU9zTIh22pog+XPnLPAecC+4yu/wtJ2SPCKiKDbJB
re0CKPyRfGqzvA3njXwMxXazU4kGs+2Fg+xu/iKbaIjxXrclBLhkxhBtySrwAFhx
xOk6fFcPLSsCgYEAqS/Mdr5CMRGGMH0bKhPUWEtAixUGZhJaunX5wY71Xoc/Gh4c
nO+b7BNJ/+5L8WZog0vr6PgiLhrqBaCYm2wjpyoG2o2wDHm+NAlzN/wp3G2EFhrS
xdOux+S1c0kpRcyoiAO2n29rNDa+jOzwBBcU8ACEPdLOCQl0IEFFJO33tl8CgYBY
DOIqnEsovsucvh3MNzHwkg8i7CdPGHSmUIN0J9/ItpPxYn2VdtccVOM6+3xZ8+uU
M/9iXGZ+TDkFsZk4/VUsaNmfYOQf1oyLA2ZsNcU90bQbeHNCi/H/19qOJFXgNaCE
sd5P3DMl9lptFGIjRVBHjvbfTQBUR5fi+BusMGfrTQKBgQCTtzMEJP2sef883AJr
XuGVPLzwLi9eTBvPzc5r5pfkvh7mDDmWFxHZm5kctvavqgy32uUPsQgMi1Kz67bU
s5dY9MCVrN2elhTLD8LOiAz8836o3AxFefm5cUWGaU/aZWDYR0QtNqFdyHyRaodo
JJfnfK+oK1Eq7+PvpXfVN9BkYw==
-----END PRIVATE KEY-----
"
test/fixtures/keys/rsa_pss_private_2048.pem,"-----BEGIN PRIVATE KEY-----
MIIEvAIBADALBgkqhkiG9w0BAQoEggSoMIIEpAIBAAKCAQEAy4OMdS84PlgI5CRL
bdbud9Ru7vprFr2YNNUmdT7D3YgApiv8CjzKXLiVDnbMET+lwmtag/EcZsxVCKov
su30pYASBriHOiMVYui9+ZaJoQ9yI6lOjG1RbuUBJXNSjHBJxqBqmcgZOb1mdRr/
eXzpAMWJ3hfuLojU2+zUSJ3/rvepepcLFG2q9nA0+PJskJ7Pnh3L0ydnv3U3hduM
n5OVfm/Jx1FPyZpD184tJff+N+MY3s3hIcfuOnL9Pl4RPGeaTC4T1o460NaG6bG7
c2Whg6NOaVgaFIaiNbrTTNCpVjeTyalsTXYlQQ3hiKjst0Q7pfFEkJDo8qiqLad1
Msl59wIDAQABAoIBAQC6G8aqs0/f02nuGDLSc6cH9kCsUlz0ItW6GuJcfdVoFSNi
0v5d7lGwkSveWk0ryOSw8rOHzUqHx3xLvDZ6jpkXcBMMClu/kq3QEb8JK90YaKOc
cQvf52h83Pc7ZEatH1KYTcKudwp6fvXfSZ0vYEdD6WG2tHOgIollxSIsdjCHs1qi
7baNHdK9T4DveuEZNcZ+LraZ1haHmFeqIPcy+KvpGuTaLCg5FPhH2jsIkw9apr7i
iFLi+IJ7S5Bn/8XShmJWk4hPyx0jtIkC5r2iJnHf4x+XYWZfdo7oew3Dg6Pa7T6r
I164Nnaw0u0LvO4gQdvYaJ/j9A602nHTp7Tsq8chAoGBAOtVHgIqpmdzwR5KjotW
LuGXDdO9X6Xfge9ca2MlWH1jOj+zqEV7JtrjnZAzzOgP2kgqzpIR71Njs8wkaxTJ
Tle0Ke6R/ghU9YOQgRByKjqJfQXHZnYFPsMg0diNYLroJ4SG8LO4+2SygTYZ4eKL
qU0bda3QvQ7FL+rTNQBy01b9AoGBAN1jEQI80JxCT7AMvXE6nObIhbkASHte4yOE
1CBwcOuBEGcuvMOvQVMzKITgea6+kgsu4ids4dM5PTPapQgpKqIIQ2/eSesaf56g
73clGGSTPHJP0v+EfKg4+GYJf8o2swT0xDHkgWLgjjdsncB9hATc2j6DvHeau18d
pgCLz9kDAoGAXl/SGvhTp2UqayVnKMW1I07agrGNLA4II5+iiS4u4InskCNSNhr/
KATj6TJ82AuTdCGGmdmLapuvPQzVzI42VsGvlzcA8wJvOwW2XIwMF1GPy8N9eZL8
6m+89+Uqh4oWXvVmjgx+9JEJdFLI3Xs4t+1tMfll+AhoAPoWZUmnK1kCgYAvEBxR
iXQfg8lE97BeHcO1G/OxfGnsMCPBLT+bFcwrhGhkRv9B6kPM2BdJCB9WEpUhY3oY
P4FSUdy85UIoFfhGMdOEOJEmNZ/jrPq7LVueJd63vlhwkU2exV2o82QDLNWpvA7p
PFZ1Gp+hEKoIfaZPElQi7gZmtrIWaksb2pz42QKBgQCct9NP2qJfqeS4206RDnfv
M238/O2lNhLWdSwY0g+tcN+I1sGs3+4vvrm95cxwAmXZyIM11wjdMcAPNxibodY7
vufsebPHDBA0j0yuTjGkXefUKd1GdO88i5fppzxB7prDX9//DsWWrFhIMMRNYe0Q
aeHd/NPuHcjZKcnaVBgukQ==
-----END PRIVATE KEY-----
"
test/fixtures/keys/rsa_pss_private_2048_sha1_sha1_20.pem,"-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQowAASCBKcwggSjAgEAAoIBAQCpdutzsPFQ1100
ouR5aAwYry8aAtG0c+zX9UqNXGCpRDWzPPpXHUZSB1BmTTL4EhK2tkAfblYNqzRu
CAYlKHbFpFLs2zLEorfp0WsFNPaBHE9JHpLIM4oXxPCUypZ7JAn56ZYonYCZ8Il5
8SzD9aoF41RTEmpcx3XkL2RQa022RiSccYZKx/yzskUUAdTvTvYyujH1MkvsfVP+
Ns5bRL6IVqowFd3xv6ctvfQMxz0rltgTC+wOm3CFtn+G63y6P/Z0U2DRdacsNkN6
PFGXAIB0kSvKzs8gVocEBiSwMkcT/KD3R68PY18b2auqaGcm8gA+gaVJ36KAW4dO
AjbY+YitAgMBAAECggEAfPvfFXln0Ra1gE+vMDdjzITPuWBg57Uj9fbMIEwEYnKT
JHmRrNRDe9Y3HuxK7hjuQmFSE5xdzUD6rzgtyBP63TOfkV7tJ4dXGxS/2JxCPeDy
PNxWp18Ttwoh4as0pudikDYN8DCRm3eC/TO5r2EtH6CVHZuUZI8bTMsDMiihrQ8F
B8+KucBG5DDy/OlDeieAZxZA4Y0/c+W0DNZ/LIPGwaqMzYCSZJXyV0t33HytUwM2
QZ+RbWqcUcrCI3lFAO8IyEULCi+RnSByZeJ0xwUkdQTI5jT6+G8BrO70Oiab8g+Q
Rx2s7PxWpIMVS7/JD1PsL4hLrVh3uqh8PZl3/FG9IQKBgQDZWkOR2LA+ixmD6XJb
Q+7zW2guHnK6wDrQFKmBGLaDdAER64WL1Unt6Umu7FPxth2niYMEgRexBgnj5hQN
LfPYTiIeXs5ErrU96fVQABsV0Hra1M2Rhve5nynjFFpbHjDXtizzLpE30MsC7YkN
EqD4YYzjWHrbk/UlQ7tx3eAvtQKBgQDHmNM4TRuyH2yaYxDqnho6fgJv7Z4KgbM0
1wcUxi5kPDQsFtaVOzFhNserzsWvotQjLkC2+CK5qlCdm59ZlpUqszF6+YyUs5Gq
WmHdqryduT1VxSV/pd6wGEQo27fxFV7LsT1JhVMh9Iri8MK0b1BD6+kVUf5NcKDB
Od2o8A1gGQKBgA5Y3Pj1mrymJesFL91CYLWDpR7WN7CIG9m8Y2v4G6QVtjRenZQb
YiPoMErxoqDj6pUyiIl1lADFa0W13ED6dYwjrDDhBTCXb7NEjELZnvATsOhc/6zJ
gfSowvUQVN6K4aJ7jgAHZOKQT7ZDw7YvMpzyo4AmSQXRgG8TR34+rRu5AoGACApP
9+SjSPmbFl0HQWw9Aj4xOvEHfMTcwzQmRN/23nLOZzhETJ6lzpS2VmVt8TVN9lzW
nohAXdpOhQrP0HwQZjfxtlJ3J0ZUh9g8OQG3t2LO5bWbXRkBb3aKyFqRflSuDOaG
4X9NagC/14R7U2loglPuf71d0SDIWQBLvZJt94ECgYEAnY7aKHnWdLszcB8uyEkJ
EJkUEaa+K/nTqOzqffZ01cTWJmUG7a2KuvQ+UQM2BHk2+wBmUo45Iz/dyePOJY0B
Fu2agiV4+R4z2XVQnIvXgY5HaPxvLz0THksY/pD58gBmFaLMx4ADEwQ+s4Y2g12H
ABsKNRHfSnKTwOm/dYvcVqs=
-----END PRIVATE KEY-----
"
test/fixtures/keys/ec10-cert.pem,"-----BEGIN CERTIFICATE-----
MIIB9zCCAZ6gAwIBAgIJAKl1NQOcXpYrMAoGCCqGSM49BAMCMIGIMQswCQYDVQQG
EwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMR8wHQYDVQQKDBZUaGUgTm9k
ZS5qcyBGb3VuZGF0aW9uMRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANjYTYx
HjAcBgkqhkiG9w0BCQEWD2NhNkBleGFtcGxlLm9yZzAgFw0xODExMTYxODQyMjFa
GA8yMjkyMDgzMDE4NDIyMVoweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQsw
CQYDVQQHDAJTRjEfMB0GA1UECgwWVGhlIE5vZGUuanMgRm91bmRhdGlvbjEQMA4G
A1UECwwHTm9kZS5qczEcMBoGA1UEAwwTYWdlbnQxMC5leGFtcGxlLmNvbTBZMBMG
ByqGSM49AgEGCCqGSM49AwEHA0IABDuWsQNVJ8wPZjqFqkkVeuYfYrfgstcPO7Ai
cGrgfQKeFvz+oLd6+U+OGFMFh0+LkI6oTADserWMFyuaiqDIFzAwCgYIKoZIzj0E
AwIDRwAwRAIgM0oqALjQXRlxmJlje71j0AX22Dq732dH0/oBEHiTDBcCIBbOfILG
vtveS9DMkz5VVlqQJ2TsDcSerhXHcLowXt5i
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICGzCCAcGgAwIBAgIJAMTCBUQ4OI4+MAoGCCqGSM49BAMCMIGIMQswCQYDVQQG
EwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMR8wHQYDVQQKDBZUaGUgTm9k
ZS5qcyBGb3VuZGF0aW9uMRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANjYTUx
HjAcBgkqhkiG9w0BCQEWD2NhNUBleGFtcGxlLm9yZzAgFw0xODExMTYxODQyMjFa
GA8yMjkyMDgzMDE4NDIyMVowgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEL
MAkGA1UEBwwCU0YxHzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAO
BgNVBAsMB05vZGUuanMxDDAKBgNVBAMMA2NhNjEeMBwGCSqGSIb3DQEJARYPY2E2
QGV4YW1wbGUub3JnMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEa7HfEgyVTPWY
ku9cWGRSym5OdB7zqFihL8+k93EfWViJph72fJH3sOZypUgDXS/sEyUaLhbxtLYz
sMbECzEDwaMQMA4wDAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAgNIADBFAiEA+NIP
zuqh2e3/59QndyPqRH2CZ4V4ipU6rf6ZZmwPApUCIBMABWesJfwdrETIjN6dT8gc
STrYyR4ovD8Aofubqjd0
-----END CERTIFICATE-----
"
test/path/test-path-posix-relative-on-windows.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import path from 'path';

// Refs: https://github.com/nodejs/node/issues/13683

const relativePath = path.posix.relative('a/b/c', '../../x');
assert.match(relativePath, /^(\.\.\/){3,5}x$/);
"
test/fixtures/keys/dsa_private_encrypted.pem,"-----BEGIN DSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-256-CBC,FABA263DD471F214EF3E02699B837C20

Tj2+4x9MEIaQGFQ4o7hk12MriVYyvLO5aCbqq7LG5uhVk546/+bJc6hewdSwb6oT
MYPbuV+QTdtqshqFESA0McyGlj4w1tOg5TomP84NTKvwTO1EirVLMukfF3dqaguw
C117AZJkGbqgbi6lZ2bG0Hta6HRbhI5+ODFtOp3rKQ2KwVmtL7zw6vt3PCISeMHN
fLqikDc2+YoI9V1FJis9/FATyqV8yrJYYQQpP1RQN+gDY4SSs/eUr+Me7RNy6Lz7
oH0tDaPGbiafwrZe1okksjxT2JQz1Q3hciBPikgdQIoE2NWTUlOeRYX0T0N2n37S
6Odbcr522e+2XjcLj34Ozthp+Q5mIDcLuakazxkXhq0RyhJ7vo+xA2YiP7Q3vH7g
oAnsJPFNVY6wJhprZi2VofKIUJUiajAXGDVX2yEIG/DOA9rnx0ZP+zopXMi4ptu0
RzWyAL+P4jn0b8vgPf9CYJmn4VNfOcVmomZ1Bw6hzqTE2FnThJCXU3l2eaC/wcSR
uMRp8c6IM8AR5DUzUBKIckkvXj1m5iSZoKuR8dB7s9BhrRtBAI7K3G254G06sByv
0pnft8r+BkMqgdfG4rJQoQJw7tVYln+pL/gYPDuYsqyJ9kFuHDqtBvlozqXY5AL1
XQaXoD6xMACEoJSIv5y+TzFzXwFQrDW+G1724YOSbiioUfGD0tRfjj2ei63PThQr
Z50SryfKQQf4UgcJeokMhmRWT2vPXEFWEP1b2FMEQxBy6fyKcqwZBAbhqF6usGEB
nwr/S1HXQAGEsWoc/Z4yynB7uhOwWu/Vpj+V6B98NmC7EUX15Why8zCsT9gzaIgC
M6sZafHhcmjfwc+lL9xFlU/wnAOz0LeKZWry3D0sXZn1r2FRlOJdtLLx01Sve/MU
ZRsgEDTkzv8E9dDltMeq8HQDCgLT1USTMWcY1kMELBj7y7ZdCWjH1QhTq2KlId+o
1X28zJOsOL/XRseUSlpjmSSLRw1QQEypNCY2+tcvViAvn3AifipBbdzUNhvygLhc
a2+5rYsd8BBEFnMJx7lDiyqXGnZkBbhbCSIudppNcjC+akFlFp6fBzkp4mKBuKpc
hwBBdfqdEyzqu6SVHM8nGV/aDoRuu9shV6MX0y/KnIgLedudn8aN2eLgjR5k1+99
-----END DSA PRIVATE KEY-----
"
example_js/es6_module_demo/demo.js,"import {hello as module_def_hello} from './module_def.js';

module_def_hello();

var f = async () => {
  let {hello, something} = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
"
test/fs/test-fs-promises-exists.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';
import fs from 'fs';
import fsPromises from 'fs/promises';

assert.strictEqual(fsPromises, fs.promises);
assert.strictEqual(fsPromises.constants, fs.constants);
"
example_js/create-react-app-ssr/src/App.test.js,"import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
"
example_js/react_ssr_stream/component/LazyPage.jsx,"import React from 'react';

class LazyPage extends React.Component {
    render() {
        return (
            <div>
                <div>
                    This is lazy page
                </div>
            </div>
        );
    }
}

export default LazyPage;
"
examples/embed_js_module/async_demo.js,"import * as std from 'std'

async function simple_val (){
    return ""abc""
}

export async function wait_simple_val (a){
    let x = await simple_val()
    print(""wait_simple_val:"",a,':',x)
    return 12345
}
"
examples/host_function/Cargo.toml,"[package]
name = ""host_function""
version = ""0.1.0""
authors = [""csh <458761603@qq.com>""]
edition = ""2018""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasmedge_quickjs = ""0.2.0""
"
build.rs,"use std::path::Path;

fn main() {
    let out_dir = std::env::var(""OUT_DIR"").unwrap();
    let out_dir_path = Path::new(&out_dir);
    std::fs::copy(""lib/libquickjs.a"", out_dir_path.join(""libquickjs.a""))
        .expect(""Could not copy libquickjs.a to output directory"");
    println!(""cargo:rustc-link-search={}"", &out_dir);
    println!(""cargo:rustc-link-lib=quickjs"");
}
"
example_js/create-react-app-ssr/src/setupTests.js,"// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
"
modules/internal/assert.js,"/**
 * 
 * @param {unknown} expr 
 * @param {string} msg 
 */
export function assert(expr, msg = """") {
    if (!expr) {
        throw new Error(msg);
    }
}
"
modules/util/types.js,"// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
import * as types from ""../internal/util/types.js"";
export * from ""../internal/util/types.js"";

export default { ...types };"
test/fixtures/keys/dsa_private.pem,"-----BEGIN DSA PRIVATE KEY-----
MIIDVwIBAAKCAQEAoSw3Ghf02sMSmd5k2rvSqf6eJPFO7fHDRyvDDbifjO6/BKSI
kXM43qyCqddC04arKg7wc1QDEQ8gb13pCmnC0RBiljE6ke4yK46Q5JjiEKH9U1eC
btTrhcGrLDgwbqvRM06EN6IfAL3OBF6YzS9wn3/EfSwW2Z8gAIkjZrTjEUTV+/gE
AdfEgd/WAZxcc9zYKOwPy0/LjjldQw5fsPlIEkS1yJFlWMokSsZVYlJLR06h1S4k
QoE3BqELirH/FQfJ36RMRFsaKZ6nQYS66Qc8rybQw2VlOJsqiRoTSDwREPz6j9oL
Yh1Ee86j5Xt9jbiBrK33UbkTr/jBtO0J2PR0+wIhAIXIexS5LQJPSoi96k6OU4yr
LLmAIY8gS9mdYTdbpwcdAoIBAQCCN3gTjFiPgBQ/bj/Edp9w90SA+dQ/VnnYDTMc
z+Mi/8sgtlQ3O9CCFb0327YnOLwvxsmSadT9XrIq1/5jGD2VtjFDVlridjYASrje
zR2kdr781G+bxtVNQuIOKZl9xqruCmHUSSRL/vuCR6pKsA81ZPfpdcLh3RYYxDIo
TK6tVX4GrX5bcxGDIUCQiTaqKv9Nzpm1liBLRm6LHczBsFk2OVrRyMsT3gh0J6DS
Uw+dw/Vru1J6glkrr0CxBWoJ65btcqtFyQV/76btor9Qgc/z9suYBoJZ3Ua0yAfv
3J2ErOs1CAbh4LWNULA9eJObY2R4sAV7Q8wOMT5jmjKo4unpAoIBAQCE1m+DUb9L
T58u6XV/L1p6K9T2mc6jAmzD51fPiUwsRov9sDGJmSnQjQ5pt3hVp8inVfNkhqOI
1rpdKmx5W00fPu6VCiPuximuHSNHzJpCAVUrIH8YasS+AurCOwGMdvODLF6dx7yR
MdxbiszrBry8J0TdvqElHZ1YmQDwoHH7R4pUd31jsk4gnE6pkqLgWwVAy0LXXGsg
2JfnDvdQY8fIHkuezLdhOyO9pRlXSYv4fLdMaSjHyEcwr2hnm5tm5RsBwM+u0sDc
yBqUjwoN8NTuLLasfJzzmjeHWDcRGFbzKt/xlUkQ7pf+xdelnLOstuPDGglB1U85
REhx4rQGKg7nAiA0FX4e4Ms3OXUnmtsTALk5YMiMF3jUp4pRDhHFKBgsYQ==
-----END DSA PRIVATE KEY-----
"
test/fixtures/keys/rsa_ca.crt,"-----BEGIN CERTIFICATE-----
MIIEAjCCAuqgAwIBAgIUf4Z4DKj5kJW60NE+9PaucYFlft8wDQYJKoZIhvcNAQEL
BQAwgbAxCzAJBgNVBAYTAlVLMRQwEgYDVQQIDAtBY2tuYWNrIEx0ZDETMBEGA1UE
BwwKUmh5cyBKb25lczEQMA4GA1UECgwHbm9kZS5qczEdMBsGA1UECwwUVGVzdCBU
TFMgQ2VydGlmaWNhdGUxFDASBgNVBAsMC0VuZ2luZWVyaW5nMRIwEAYDVQQDDAls
b2NhbGhvc3QxGzAZBgkqhkiG9w0BCQEWDGFsZXhAYXViLmRldjAgFw0xOTA2Mjgy
MTM2NDhaGA8yMjkzMDQxMTIxMzY0OFowgbAxCzAJBgNVBAYTAlVLMRQwEgYDVQQI
DAtBY2tuYWNrIEx0ZDETMBEGA1UEBwwKUmh5cyBKb25lczEQMA4GA1UECgwHbm9k
ZS5qczEdMBsGA1UECwwUVGVzdCBUTFMgQ2VydGlmaWNhdGUxFDASBgNVBAsMC0Vu
Z2luZWVyaW5nMRIwEAYDVQQDDAlsb2NhbGhvc3QxGzAZBgkqhkiG9w0BCQEWDGFs
ZXhAYXViLmRldjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALfcWIiK
J7HAt78/wNnHkeyoWWZQ7v+W8nud5wlU3Cp1ndrHmOlAHSnq7F+p46/Nw3eTlXtQ
Vv8Cb6eRI1kwBmGxbMJTZng+OHnRBjPd/Qei6vv/IgZK04vJhjeGAsrYrxNuGCNA
+F2TD35C0qWm9svx8uA40CgatU4WdFAZyvvSIV9+ybv2aBmEpUyBiIc8momAYe8K
2QaD3MyBLunrf5DdlZ520VLZGExfe4IHL+YfoQ6VEI0FtGYDjHE3PJ/kZBqSLdP4
jP204yN08/4LBXYuoR3KWYG6KTy+t9NveogcsooEAjyVc3brBa0DeQ3gvs0/5xsq
UJGWpy2+GbKUsfUCAwEAAaMQMA4wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsF
AAOCAQEAD2FBwUO9iV4VBrpTdUEd0Y39ajJsdbbnNkJ/N1ZbJgdymCLfVpzCqB+s
qRjpq9JqGtcxwzPG7GGu+OIXCGMfeMzFkk2cjLeZic5uKcynFgru4bzrhGdb26Wq
s8rQeXFOO6aRdpTVvIO+Vq5goRTXJhbtEzA9efmYWIOXcL5WDYhwApOc8rwfz9fm
q8VZCW+KK23EU3gfyOcO14E0Al/K6lewX15K1Hh4P8cSnFtjtCqRRWmQi9JfdasS
A0YJd8rN47dplRylTtXu5VFKL+XXa/jmlzsgtxBHX14onpVKqfGCvCLqj+AeZA3Y
iX4iQjxnLr5DRtykOz+bKEYgX8AV8g==
-----END CERTIFICATE-----
"
test/fixtures/keys/rsa_cert.crt,"-----BEGIN CERTIFICATE-----
MIIEAjCCAuqgAwIBAgIUf4Z4DKj5kJW60NE+9PaucYFlft8wDQYJKoZIhvcNAQEL
BQAwgbAxCzAJBgNVBAYTAlVLMRQwEgYDVQQIDAtBY2tuYWNrIEx0ZDETMBEGA1UE
BwwKUmh5cyBKb25lczEQMA4GA1UECgwHbm9kZS5qczEdMBsGA1UECwwUVGVzdCBU
TFMgQ2VydGlmaWNhdGUxFDASBgNVBAsMC0VuZ2luZWVyaW5nMRIwEAYDVQQDDAls
b2NhbGhvc3QxGzAZBgkqhkiG9w0BCQEWDGFsZXhAYXViLmRldjAgFw0xOTA2Mjgy
MTM2NDhaGA8yMjkzMDQxMTIxMzY0OFowgbAxCzAJBgNVBAYTAlVLMRQwEgYDVQQI
DAtBY2tuYWNrIEx0ZDETMBEGA1UEBwwKUmh5cyBKb25lczEQMA4GA1UECgwHbm9k
ZS5qczEdMBsGA1UECwwUVGVzdCBUTFMgQ2VydGlmaWNhdGUxFDASBgNVBAsMC0Vu
Z2luZWVyaW5nMRIwEAYDVQQDDAlsb2NhbGhvc3QxGzAZBgkqhkiG9w0BCQEWDGFs
ZXhAYXViLmRldjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALfcWIiK
J7HAt78/wNnHkeyoWWZQ7v+W8nud5wlU3Cp1ndrHmOlAHSnq7F+p46/Nw3eTlXtQ
Vv8Cb6eRI1kwBmGxbMJTZng+OHnRBjPd/Qei6vv/IgZK04vJhjeGAsrYrxNuGCNA
+F2TD35C0qWm9svx8uA40CgatU4WdFAZyvvSIV9+ybv2aBmEpUyBiIc8momAYe8K
2QaD3MyBLunrf5DdlZ520VLZGExfe4IHL+YfoQ6VEI0FtGYDjHE3PJ/kZBqSLdP4
jP204yN08/4LBXYuoR3KWYG6KTy+t9NveogcsooEAjyVc3brBa0DeQ3gvs0/5xsq
UJGWpy2+GbKUsfUCAwEAAaMQMA4wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsF
AAOCAQEAD2FBwUO9iV4VBrpTdUEd0Y39ajJsdbbnNkJ/N1ZbJgdymCLfVpzCqB+s
qRjpq9JqGtcxwzPG7GGu+OIXCGMfeMzFkk2cjLeZic5uKcynFgru4bzrhGdb26Wq
s8rQeXFOO6aRdpTVvIO+Vq5goRTXJhbtEzA9efmYWIOXcL5WDYhwApOc8rwfz9fm
q8VZCW+KK23EU3gfyOcO14E0Al/K6lewX15K1Hh4P8cSnFtjtCqRRWmQi9JfdasS
A0YJd8rN47dplRylTtXu5VFKL+XXa/jmlzsgtxBHX14onpVKqfGCvCLqj+AeZA3Y
iX4iQjxnLr5DRtykOz+bKEYgX8AV8g==
-----END CERTIFICATE-----
"
test/fixtures/keys/rsa_cert_foafssl_b.crt,"-----BEGIN CERTIFICATE-----
MIIEEjCCAvqgAwIBAgIUCi0fIToueeHu6wSjX9cgjUKzgc8wDQYJKoZIhvcNAQEL
BQAwgagxCzAJBgNVBAYTAlVLMSIwIAYDVQQIDBlGT0FGK1NTTCBBdXRoIENlcnRp
ZmljYXRlMRMwEQYDVQQHDApSaHlzIEpvbmVzMRAwDgYDVQQKDAdub2RlLmpzMR0w
GwYDVQQLDBRUZXN0IFRMUyBDZXJ0aWZpY2F0ZTESMBAGA1UEAwwJbG9jYWxob3N0
MRswGQYJKoZIhvcNAQkBFgxhbGV4QGF1Yi5kZXYwIBcNMTkwNjI4MjEyNzE0WhgP
MjI5MzA0MTEyMTI3MTRaMIGoMQswCQYDVQQGEwJVSzEiMCAGA1UECAwZRk9BRitT
U0wgQXV0aCBDZXJ0aWZpY2F0ZTETMBEGA1UEBwwKUmh5cyBKb25lczEQMA4GA1UE
CgwHbm9kZS5qczEdMBsGA1UECwwUVGVzdCBUTFMgQ2VydGlmaWNhdGUxEjAQBgNV
BAMMCWxvY2FsaG9zdDEbMBkGCSqGSIb3DQEJARYMYWxleEBhdWIuZGV2MIIBIjAN
BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyb1grrN+29fxeeEbTaSEja6TKDTp
T/WXnqrFCS+h7IYcnDoAVwcsPU5FZeUPvLKMzi9NHSJ34LQCurqHgH8X+cw0YT3g
dYS/7qoQiXs+zKv615NcttD3xlQLceY+NwznoPXyyZwOeZqyU5Hiqbrqu6hdr6gQ
YogMNLn2NxBW2pGegd6+ZGMCX3+/BtMP/6tXmttYjY+yhN2SrGz5cKhWpcHiC6X+
B7uCKoKZy+t2jUxYVKUwWr1ZuM8kpSnuVCcv1OoMGEimEHA7v/eaF/y+z/VdQ4Y8
8GhTnVN4KbtgZ+o9PohjxLFU62VeTALixU5mPQKSgSICKfjev0FUUurF6wIDAQAB
ozAwLjAJBgNVHRMEAjAAMCEGA1UdEQQaMBiGFmh0dHA6Ly9leGFtcGxlLmNvbS8j
bWUwDQYJKoZIhvcNAQELBQADggEBAFBCx6BoYUdrjqgFDFAGTMqj6sG0nfZ5a8b4
Im82kKKUeSMnK5nnI8mG14tcAZqph4OewC3mc1S3ufBnJKOLZnae+xyIQiM046ZI
b2g/6vk0C3lrvp7S+UZS3ueJNt6UewlubmTembs7t2T1MdDoBwmMuYRph4jcFHp+
BFNGdoNSipkBSSrYRb55oTIBMOYNHNeSFHnOLVyZNeR4qaGBr4ae6r+Z4kkfqiTV
Z0j4ta/7mXrIEX3RarQEdTEwAqYz9LioKSXfP9eye8NTt2zinu4pM9JZ3UU08P7f
DT7VyxCDdegaGb0Uaqjs0cRU7JRYkv/YaK7V5KNdIpjHuG3SlF8=
-----END CERTIFICATE-----
"
example_js/simple_common_js_demo/es6_code_module.js,"import * as std from 'std';

export function run() {
    print('write file');
    let f = std.open('hello.txt', 'w');
    let x = f.puts('hello wasm');
    f.flush();
    f.close();
}"
examples/embed_js/Cargo.toml,"[package]
name = ""embed_js""
version = ""0.1.0""
authors = [""ubuntu""]
edition = ""2018""

[[bin]]
name = ""embed_js""
path = ""src/main.rs""

[dependencies]
wasmedge_quickjs = ""0.2.0""

"
examples/embed_js_module/Cargo.toml,"[package]
name = ""embed_js_module""
version = ""0.1.0""
authors = [""ubuntu""]
edition = ""2018""

[[bin]]
name = ""embed_js_module""
path = ""src/main.rs""

[dependencies]
wasmedge_quickjs = ""0.2.0""

"
examples/embed_rust_module/Cargo.toml,"[package]
name = ""embed_rust_module""
version = ""0.1.0""
authors = [""ubuntu""]
edition = ""2018""

[[bin]]
name = ""embed_rust_module""
path = ""src/main.rs""

[dependencies]
wasmedge_quickjs = ""0.2.0""

"
test/fixtures/keys/ca1-key.pem,"-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIC1DBOBgkqhkiG9w0BBQ0wQTApBgkqhkiG9w0BBQwwHAQIO9cMY0yHJGgCAggA
MAwGCCqGSIb3DQIJBQAwFAYIKoZIhvcNAwcECAKYHSZXK7beBIICgHkIYlgRIfZt
QZxMoahaz4Bu6t5F24ud9rdrpT8qKCnffj71z5mtwucE7sXMslcejgo4QEP5V3lS
zFWQDY5B0p9al+M9DIsseSz8L9StqgQo3FfYLGVs8njO4PFyaWSdbPWWpaXRUmdm
32CbOKwdvOMFhcR8G+jlezkm4uyQ9yCC5bERdrpsaaPJTlt8aMdrvxMytHw60OZo
VVF88fRm9x4kUT+sKyiwG0JWTRDueeFoJR4oa5xlw1AVmEYBBQee9Tc73wqtOr2r
4dnL/zwc6c9ZoTTDOGZNgBvxswVzg04K/qp9LIt3uOeHXqfnmzfmJ4eT5fG71pir
pSfZPIYXJwgC1NjWvsWudI/kE1Wj0JnGYuPY/Vea9RSSrRqq9nL9kqTSa1jgo8l1
zTR/uZHZH2wCMlH09tiz7uOiPihsO8qeYWIe+vkgC2xCm6O/B1vMuqQY36LOxeVt
igi9hDLjWxNth9lEcC/0wsrft8Y1/CF5h3/j86h1IcgQKFrePu40kols/yBxp7/n
MIzm4oUoClGe3q+a3aajEYL5Cos+7tu2jSM3MKVMiNZ5aTICQ9Sr/OOz+tYZOdJd
hCDF/oncBALJ7nhe77mf1j+Qy/vZzCvDIl/ki3zK/S83U9InZW3oKFv4u3brh+77
2zruIZ6l/zId8fFARdh6PvXz5avz2eC//EM1zNJiV6IC9DvB3xibvA05rmoK4g9V
DIIIWJsTJUPPvEXszMAtb1zR+MhDs71RF6KvM67KCasI0k07hGY0rgDjlzeoWe/3
SLgXPda5/WCkRcpgznzRu53HJwq27tUsh74hXPbqaQREDrX0bBBokAMCGBxCFrJi
Btmo/ouOp4w=
-----END ENCRYPTED PRIVATE KEY-----
"
test/fixtures/keys/ca2-key.pem,"-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIC1DBOBgkqhkiG9w0BBQ0wQTApBgkqhkiG9w0BBQwwHAQI0/0Q5tLDQW0CAggA
MAwGCCqGSIb3DQIJBQAwFAYIKoZIhvcNAwcECHCRfosVTaMUBIICgHq2VKpOxq8W
+KZ7bVFuWx/gJvE1FAJokIZogK52LH3oEk9kMlEujwYAMovEew4lPMgAnyQh5Mbx
BXIm8Arww9hUZlRPuHmeQQuikbz/Sy5LVFbrzRsM0xGZxeWkpq3iKj3Z4W1OneRd
HAtBADAlID1a4r5f/BxiuNBGn5X54x66qbC94mJ2b02zHJJaRVd6OQM5iZURlcbi
N1E/LtQ3/I9qWqGYfiVCZf39ItxbrBkIEk65BbCackpDpVxzOfEbvC8RdBZcHxZm
8g4XZ6p1rCmzLi22l7usgEhd4QSMQyT9JTnMfM1QFzaqAVTqWr4ZFP108a2vH574
T/HFKBkI+DEUsKQTLmYqZ05mg0wx80KGP/+1jOB1yx0tGnxCihGJVhqqGoFqgBSm
aqC5arQIZSUt2eN4OamakgU4iLzrKFb6bWGwTNUoHZNh4TsYz4CvFkPcM5tOyX+l
RoUyPAyfu348Z2IKBzUwYUfXJ5WFW2xq+RiOmlt4zF1Lym+aktEP6REQZYTGZZZx
l1YsvIUDd0pj5AJ3/PSTZN+VzkKz5lJdKEDEqpoOkEZnE/FL5VJHnRLOANyNf1zl
qZFgLGRZgZQwGkwj2hAF3auRJWJyvjuQW57v86F3U6XKKKejgBVb2ohMk7U6WW8B
wPtYyEa2zW1hSCLWhMEaek5Y2/2NX/dPryHNZ5XJ1UD0SGrPumN4lbErKDWGmAoK
jH6bpX/xVdmur2BwgGdqt6S1BW9B2F+cXz46UNiFKPYL49iBe13xM5EFKk9N9DL3
HWPWrExlmi+p4PASL6cR5t9sDw8wUYp5cyC/M1RHDJPvjgBX987F17fI6GkNNToE
ZIbM6M/EuKg=
-----END ENCRYPTED PRIVATE KEY-----
"
test/fixtures/keys/dsa_public.pem,"-----BEGIN PUBLIC KEY-----
MIIDSDCCAjoGByqGSM44BAEwggItAoIBAQChLDcaF/TawxKZ3mTau9Kp/p4k8U7t
8cNHK8MNuJ+M7r8EpIiRczjerIKp10LThqsqDvBzVAMRDyBvXekKacLREGKWMTqR
7jIrjpDkmOIQof1TV4Ju1OuFwassODBuq9EzToQ3oh8Avc4EXpjNL3Cff8R9LBbZ
nyAAiSNmtOMRRNX7+AQB18SB39YBnFxz3Ngo7A/LT8uOOV1DDl+w+UgSRLXIkWVY
yiRKxlViUktHTqHVLiRCgTcGoQuKsf8VB8nfpExEWxopnqdBhLrpBzyvJtDDZWU4
myqJGhNIPBEQ/PqP2gtiHUR7zqPle32NuIGsrfdRuROv+MG07QnY9HT7AiEAhch7
FLktAk9KiL3qTo5TjKssuYAhjyBL2Z1hN1unBx0CggEBAII3eBOMWI+AFD9uP8R2
n3D3RID51D9WedgNMxzP4yL/yyC2VDc70IIVvTfbtic4vC/GyZJp1P1esirX/mMY
PZW2MUNWWuJ2NgBKuN7NHaR2vvzUb5vG1U1C4g4pmX3Gqu4KYdRJJEv++4JHqkqw
DzVk9+l1wuHdFhjEMihMrq1VfgatfltzEYMhQJCJNqoq/03OmbWWIEtGbosdzMGw
WTY5WtHIyxPeCHQnoNJTD53D9Wu7UnqCWSuvQLEFagnrlu1yq0XJBX/vpu2iv1CB
z/P2y5gGglndRrTIB+/cnYSs6zUIBuHgtY1QsD14k5tjZHiwBXtDzA4xPmOaMqji
6ekDggEGAAKCAQEAhNZvg1G/S0+fLul1fy9aeivU9pnOowJsw+dXz4lMLEaL/bAx
iZkp0I0Oabd4VafIp1XzZIajiNa6XSpseVtNHz7ulQoj7sYprh0jR8yaQgFVKyB/
GGrEvgLqwjsBjHbzgyxence8kTHcW4rM6wa8vCdE3b6hJR2dWJkA8KBx+0eKVHd9
Y7JOIJxOqZKi4FsFQMtC11xrINiX5w73UGPHyB5Lnsy3YTsjvaUZV0mL+Hy3TGko
x8hHMK9oZ5ubZuUbAcDPrtLA3MgalI8KDfDU7iy2rHyc85o3h1g3ERhW8yrf8ZVJ
EO6X/sXXpZyzrLbjwxoJQdVPOURIceK0BioO5w==
-----END PUBLIC KEY-----
"
test/fixtures/keys/fake-startcom-root-cert.pem,"-----BEGIN CERTIFICATE-----
MIIDjzCCAnegAwIBAgIJAIIPb0xPNcgKMA0GCSqGSIb3DQEBCwUAMH0xCzAJBgNV
BAYTAklMMRYwFAYDVQQKDA1TdGFydENvbSBMdGQuMSswKQYDVQQLDCJTZWN1cmUg
RGlnaXRhbCBDZXJ0aWZpY2F0ZSBTaWduaW5nMSkwJwYDVQQDDCBTdGFydENvbSBD
ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgz
MDE4NDIyMVowfTELMAkGA1UEBhMCSUwxFjAUBgNVBAoMDVN0YXJ0Q29tIEx0ZC4x
KzApBgNVBAsMIlNlY3VyZSBEaWdpdGFsIENlcnRpZmljYXRlIFNpZ25pbmcxKTAn
BgNVBAMMIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkq
hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1mZ/bufFVPGxKagC8W7hpBephIFIZw9K
bX6ska2PXZkyqRToU5UFgTYhdBwkCNJMwaYfTqLpc9y/goRpVlLSAFk/t4W6Z0w1
b80T149XvmelAUQTBJR49kkYspN+Jw627pf8tmmSkG5qcHykB9gr/nvoTpXtlk2t
um/SL3BQSqXmqffBM/6VpFvGAB2FNWGQUIxj55e/7p9Opjo8yS4s2lnbovV6OSJ/
CnqEYt6Ur4kdLwVOLKlMKRG3H4q65UXfoVpE+XhFgKADAiMZySSGjBsbjF6ADPnP
/zNklvYwcM0phtQivmkKEcSOvJNsZodszYhoiwie5OknOo7Mqz9jqQIDAQABoxAw
DjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQBrsLtF6MEMCWQF6YXP
DLw4friQhYzoB7w1W+fgksOOIyLyRmUEEA9X0FSfNW2a6KLmMtSoNYn3y5cLkmGr
+JE4U3ovvXDU8C3r09dynuHywcib4oFRaG8NKNqldUryO3abk+kbdxMvxQlA/NHb
33ABKPX7UTnTr6CexZ5Qr0ss62w0ELwxC3eVugJrVtDOmFt/yZF75lc0OgifK4Nj
dii7g+sQvzymIgdWLAIbbrc3r/NfymFgmTEMPY/M17QEIdr9YS1qAHmqA6vGvmBz
v2fCr+xrOQRzq+HO1atOmz8gOdtYJwDfUl2CWgJ2r8iMRsOTE7QgEl/+zpOM3fe+
JU1b
-----END CERTIFICATE-----
"
examples/embed_use_es6_module/Cargo.toml,"[package]
name = ""embed_use_es6_module""
version = ""0.1.0""
edition = ""2018""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasmedge_quickjs = ""0.2.0"""
modules/ACKNOWLEDGEMENT.md,"Some files in the `modules` directory are reused from or inspired by the [Deno project](https://github.com/denoland/deno/), which is [licensed under the MIT license](https://github.com/denoland/deno/blob/main/LICENSE.md).
"
test/fixtures/keys/agent8-cert.pem,"-----BEGIN CERTIFICATE-----
MIIDUDCCAjgCAQEwDQYJKoZIhvcNAQELBQAwfTELMAkGA1UEBhMCSUwxFjAUBgNV
BAoMDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsMIlNlY3VyZSBEaWdpdGFsIENlcnRp
ZmljYXRlIFNpZ25pbmcxKTAnBgNVBAMMIFN0YXJ0Q29tIENlcnRpZmljYXRpb24g
QXV0aG9yaXR5MCAXDTE2MTAyMDIzNTk1OVoYDzIyOTIwODMwMTg0MjIxWjBdMQsw
CQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQ8wDQYDVQQKDAZO
T0RFSlMxDzANBgNVBAsMBmFnZW50ODESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjAN
BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvCbXGqz553XQ+W9zsQEaBc1/mhd4
TFjivwbK1hSdTuB8vWyOw6oZuqAJjctcIPmNXf01zV1+cAurpoU8k9SmtetwqaDV
0K5ooKUuzgAefRoLJqU0XonW4VaK0ICQATkxSWdJzYET68NTukv5f9Fh0Jfi2Q6Y
PKlgUIuoTPQJSErAMsdph4KWMP7zsaEZNJhmZ1Lprfm4DdVnwUfYvDhq5VmAHFLj
Vor/z3DJS+pW9oORDta3CMvAY5oGcIYWWMxsoG9B9NtTTs58jjeFpJrw/RYJA/CM
uRawLWKt/z1zPhzmvknTKfAIc6SjbBqu8Nx/Xvcd61c2V39U/nZDTs+H9QIDAQAB
MA0GCSqGSIb3DQEBCwUAA4IBAQBfy91+ceZDfZ0DnHHAlm8e+26V5sdrdOXZJtkc
AacDcCX6AD1iMK+0axBgG6ZJs6m87cmFdaq23pLpBLQ+KHSdG5YgRCEuWW+RaJGj
/vVn9AS4eB3EmX0RhhJgYyVbN7ye8qjfAv0NtHzUsdMS8ay3HbdUCtrcsHonGDR3
t/0BGsYny9Kt2f2PNN32UEkx/jhcssXwnNGxyxR/04heJUe6LI5ErdQoxxvaZtrd
u9ZgjSxix4dFH4nTYEYe3oXM1U7PakbzOzJvRMmDh8vYyK7/ih0w8/DcsK0d1Oej
mgtTF/IyJqy8T9goFf9U2uSshia+sKJBfrrzRaUHZMx+ZobA
-----END CERTIFICATE-----
"
test/fixtures/keys/agent9-cert.pem,"-----BEGIN CERTIFICATE-----
MIIDUjCCAjoCAQIwDQYJKoZIhvcNAQELBQAwfTELMAkGA1UEBhMCSUwxFjAUBgNV
BAoMDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsMIlNlY3VyZSBEaWdpdGFsIENlcnRp
ZmljYXRlIFNpZ25pbmcxKTAnBgNVBAMMIFN0YXJ0Q29tIENlcnRpZmljYXRpb24g
QXV0aG9yaXR5MCIYDzIwMTYxMDIxMDAwMDAxWhgPMjI5MjA4MzAxODQyMjFaMF0x
CzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoM
Bk5PREVKUzEPMA0GA1UECwwGYWdlbnQ5MRIwEAYDVQQDDAlsb2NhbGhvc3QwggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC2oEMk2EKwIZrx4IPNcGjHw5DO
u8A8yJrcWG4pThUadrvwMI7bQ4QwNgHm4PVpbjAPbSUsRPX98PWL6GcpoH0lmJ9+
j9CCEIEkW+j5wM7hYBXUSGuAZZfkdrpbZHsvwpYj2U39sfmUyGT1gBbGBmaAzODh
ZaqYSm9VdaKS56SRMey3Pbsx+ikylgiEyPFoRKA141Zuxz1MKiwszLHuyz6pCZKY
K7x1dlEGi3h3dvkRAdMyeSXJkYCZGbS5Fbl2OuW4pSWP4no/M960vBwEYvuJPDtx
qxGezE51oXp4W4l9k+TYPOfGJDVW0PAg+JpfbepLetgFaO9/eNWes34AhF6FAgMB
AAEwDQYJKoZIhvcNAQELBQADggEBAD8ojlI4FdXLCyHVYwwTP6BncF4tfeGP82/i
Zcr8U9k28T2vlsLwdCGu8UVqGWfYrSY5oZqZmHPcDfZmv6Uc39eQ72aweoyLedk3
UF1Ucwq+MxEM98doLlqL4lnPO1+TcpdhtoHAgT28WkddbR3alfsu+GRU3br3s4lS
DHcm6UzdA/lkgZtC8wFUSW04WhzSHB78gm8VOl+1JGY0pp/T+ae5swkfj45Q3jOd
H6jdZiUrU+LJQwLlXYniF4qzmH0SN8Gd3djVNzWJtNF+LFKXzCOYSK8AFaQ6Ta+s
Pd6Rqa8Hl6cMmlsDu1NLumstvGna5wsc7ks1VZwtWt6WfIyIN2k=
-----END CERTIFICATE-----
"
test/fixtures/keys/fake-startcom-root-issued-certs/01.pem,"-----BEGIN CERTIFICATE-----
MIIDUDCCAjgCAQEwDQYJKoZIhvcNAQELBQAwfTELMAkGA1UEBhMCSUwxFjAUBgNV
BAoMDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsMIlNlY3VyZSBEaWdpdGFsIENlcnRp
ZmljYXRlIFNpZ25pbmcxKTAnBgNVBAMMIFN0YXJ0Q29tIENlcnRpZmljYXRpb24g
QXV0aG9yaXR5MCAXDTE2MTAyMDIzNTk1OVoYDzIyOTIwODMwMTg0MjIxWjBdMQsw
CQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQ8wDQYDVQQKDAZO
T0RFSlMxDzANBgNVBAsMBmFnZW50ODESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjAN
BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvCbXGqz553XQ+W9zsQEaBc1/mhd4
TFjivwbK1hSdTuB8vWyOw6oZuqAJjctcIPmNXf01zV1+cAurpoU8k9SmtetwqaDV
0K5ooKUuzgAefRoLJqU0XonW4VaK0ICQATkxSWdJzYET68NTukv5f9Fh0Jfi2Q6Y
PKlgUIuoTPQJSErAMsdph4KWMP7zsaEZNJhmZ1Lprfm4DdVnwUfYvDhq5VmAHFLj
Vor/z3DJS+pW9oORDta3CMvAY5oGcIYWWMxsoG9B9NtTTs58jjeFpJrw/RYJA/CM
uRawLWKt/z1zPhzmvknTKfAIc6SjbBqu8Nx/Xvcd61c2V39U/nZDTs+H9QIDAQAB
MA0GCSqGSIb3DQEBCwUAA4IBAQBfy91+ceZDfZ0DnHHAlm8e+26V5sdrdOXZJtkc
AacDcCX6AD1iMK+0axBgG6ZJs6m87cmFdaq23pLpBLQ+KHSdG5YgRCEuWW+RaJGj
/vVn9AS4eB3EmX0RhhJgYyVbN7ye8qjfAv0NtHzUsdMS8ay3HbdUCtrcsHonGDR3
t/0BGsYny9Kt2f2PNN32UEkx/jhcssXwnNGxyxR/04heJUe6LI5ErdQoxxvaZtrd
u9ZgjSxix4dFH4nTYEYe3oXM1U7PakbzOzJvRMmDh8vYyK7/ih0w8/DcsK0d1Oej
mgtTF/IyJqy8T9goFf9U2uSshia+sKJBfrrzRaUHZMx+ZobA
-----END CERTIFICATE-----
"
test/fixtures/keys/fake-startcom-root-issued-certs/02.pem,"-----BEGIN CERTIFICATE-----
MIIDUjCCAjoCAQIwDQYJKoZIhvcNAQELBQAwfTELMAkGA1UEBhMCSUwxFjAUBgNV
BAoMDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsMIlNlY3VyZSBEaWdpdGFsIENlcnRp
ZmljYXRlIFNpZ25pbmcxKTAnBgNVBAMMIFN0YXJ0Q29tIENlcnRpZmljYXRpb24g
QXV0aG9yaXR5MCIYDzIwMTYxMDIxMDAwMDAxWhgPMjI5MjA4MzAxODQyMjFaMF0x
CzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoM
Bk5PREVKUzEPMA0GA1UECwwGYWdlbnQ5MRIwEAYDVQQDDAlsb2NhbGhvc3QwggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC2oEMk2EKwIZrx4IPNcGjHw5DO
u8A8yJrcWG4pThUadrvwMI7bQ4QwNgHm4PVpbjAPbSUsRPX98PWL6GcpoH0lmJ9+
j9CCEIEkW+j5wM7hYBXUSGuAZZfkdrpbZHsvwpYj2U39sfmUyGT1gBbGBmaAzODh
ZaqYSm9VdaKS56SRMey3Pbsx+ikylgiEyPFoRKA141Zuxz1MKiwszLHuyz6pCZKY
K7x1dlEGi3h3dvkRAdMyeSXJkYCZGbS5Fbl2OuW4pSWP4no/M960vBwEYvuJPDtx
qxGezE51oXp4W4l9k+TYPOfGJDVW0PAg+JpfbepLetgFaO9/eNWes34AhF6FAgMB
AAEwDQYJKoZIhvcNAQELBQADggEBAD8ojlI4FdXLCyHVYwwTP6BncF4tfeGP82/i
Zcr8U9k28T2vlsLwdCGu8UVqGWfYrSY5oZqZmHPcDfZmv6Uc39eQ72aweoyLedk3
UF1Ucwq+MxEM98doLlqL4lnPO1+TcpdhtoHAgT28WkddbR3alfsu+GRU3br3s4lS
DHcm6UzdA/lkgZtC8wFUSW04WhzSHB78gm8VOl+1JGY0pp/T+ae5swkfj45Q3jOd
H6jdZiUrU+LJQwLlXYniF4qzmH0SN8Gd3djVNzWJtNF+LFKXzCOYSK8AFaQ6Ta+s
Pd6Rqa8Hl6cMmlsDu1NLumstvGna5wsc7ks1VZwtWt6WfIyIN2k=
-----END CERTIFICATE-----
"
test/fixtures/keys/agent1-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDvVEBwFjfiirsDjlZB+CjYNMNCqdJe27hqK/b72AnLjgN6mLcX
COABJC5N61TGFkiF9Zndh6IyFXRZVb4gQX4zxNDRuAydo95BmiYHGV0vt1ZXsLv7
XrfQu6USLRtpZMe1cNULjsAB7raN+1hEN1CPMSmSjWc7MKPgv09QYJ5jcQIDAQAB
AoGAbqk3TlyHpKFfDarf6Yr0X9wtuQJK+n+ACt+fSR3AkbVtmF9KsUTyRrTTEEZT
IXCmQgKpDYysi5nt/WyvB70gu6xGYbT6PzZaf1RmcpWd1pLcdyBOppY6y7nTMZA3
BVFfmIPSmAvtCuzZwQFFnNoKH3d6cqna+ZQJ0zvCLCSLcw0CQQD6tswNlhCIfguh
tvhw7hJB5vZPWWEzyTQl8nVdY6SbxAT8FTx0UjxsKgOiJFzAGAVoCi40oRKIHhrw
pKwHsEqTAkEA9GABbi2xqAmhPn66e0AiU8t2uv69PISBSt2tXbUAburJFj+4rYZW
71QIbSKEYceveb7wm0NP+adgZqJlxn7oawJBAOjfK4+fCIJPWWx+8Cqs5yZxae1w
HrokNBzfJSZ2bCoGm36uFvYQgHETYUaUsdX3OeZWNm7KAdWO6QUGX4fQtqMCQGXv
OgmEY+utAKZ55D2PFgKQB1me8r6wouHgr/U7kA+0Peba86TmOZMhIVaspD3JNqf4
/pI1NMH1kF+fdAalXzsCQQCelwr9I3FWhx336CWrfAY20xbiMOWMyAhrjVrexgUD
53Y6AhSaRC725pZTgO2PQ4AjkGLIP61sZKgTrXS85KmJ
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent10-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQCtXZ2JW6asoNLmTzUytx0QKdhhVnl95D8VkOrAQcz/OVe+zq+m
FTesaZl4BIxAR0eDu9SPPO8Tw8Oom4lcqsLmUQ7U5Rh5QOFpn9C9hL20OnupMnM5
HFP2Kbrl1AfRerklDBPLfSGJ1AfE6ACQgs2K97Tv8mQ3W+V7pOdlfor92QIDAQAB
AoGAIAjiaVVEMTXugpw0SlDH0ArLbwEZpgedGJEUr7348VhZPGrYzimxhexlbWX5
vI7vSgpVNrqduts7tlY3RaZQKQzFkSqkUUb432bXkJLHNIspd0XHOO2Hy/ZbTg0n
OIQes7C91Z/OLUi9esXoh4AMsAoxiHoVee0dkEJt8RoywNkCQQDk39QND1rQ2eJq
Fcfj/v6fXgsHmQT16w2Ii9P5uPAeIGrGcrsCoVWrsh+wjSlYc7emGV8JINiltNhZ
fSg6ux8/AkEAwemf5LryUDCoZ68MlAYMcH+G7gtm06d+FUFpBclT3hJeXnUAdlyU
6kCvazcVTQQKDTWIS1oIBuleVmc/VWc05wJBAMVRZyq/QydtwTJ+hq+8pl5VIKMz
PECbnjZLfrv7wh/nCMcAINRarVZyIbn/aVbVpM3xb6qaA82QxTkZmvZPXtcCQFqx
pjMYrNSMrXcxDDT/Tzoeq0ES3BkKMZJHcZNfQnaPKMwM9RZm3s9hSapfrPrEdN8Q
tppnlXGGHLVUvO54wukCQBKbjspQONRZFBh9Fdeyf/rX+inBLhuMSnsY3FeBp0c6
TAPbyuiezn7axr9kILojdjZgXK1b+MTHSEjqCpHwIvg=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent2-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQCrYG2i9zCUhQ1UCLe6RvJC95k2DdWSTEHoiH4IvvRURffSOLkS
lCoaPCTlRvq1Fh+4YfAFZI7z5bY/C12mUNu4g6grkwCn7CQNEILwfWXiLxx04D3s
R3DedFToyI+tSKKtXW7aWIdinpgMtaLHzRSI2cfoQ4sV3lbLmzsJK3isSQIDAQAB
AoGAbaqNPiXUjpX+C3Jwr+FKkhQDlRWRP8dQvc7qaApaK7uCdKIbvInXz2YBbj7X
nB4GOmVhxPGukODEmN9bFFzV3NbQVcAO8iPI6ldkYCmpmwfeEA1UJnBfBC2IYVFr
0TSuq7OdniiO+FLhZvSAJXN+5yDv66nZEnojMuu1oqpG/gECQQDdxzSeNbOY2ak8
Db2ZYKSBWjxVbW+UC8mYA7jHVpcUxlNnamcJrhg6hEfJqax6c/vAefECFsngG7yy
XVTYX6rpAkEAxdI83zQz4NqYkZmFlCElNDRF7S1Sa2eX1HzzJYlOEMx3P1iE/z4U
HOQh9py2jlY1th3GdbChF1VWMIOqGCtaYQJAJwxS/GQyKgBw5qz4rA+zBz9vDg+F
rMhih0xodViOo07EEppOaArqIyt1RFGGl8ziD6Kox5hhlP7tO25paOt3OQJBALSL
6y60EF06ZWENwxKtJa19wAx1/vEz/SjcWXZ62JsQYg2Yltn2KJktxam04hEKsb7j
cgxcBsqrAh0JLicc+kECQDmH1wTvulw3E59jqOaKEbYNQFi18zzFkIIoNRVqMhtt
zTJx8NYT9NUS3YE4OcUX0dQtVO3W+NIVrniaY8i29UM=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent3-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQC/6HB9JW4l8cNA5eYXYP8ewjYlmSyl+s9AT9kvW0gjZxdGe6wi
pZm8uD2/shVjSBK/HmBYwfGaqporvkxxUm87VcTMtilr0N2ePTrGo1aXqHAsec9t
yVGLafrcKzrNIzzSvWJDXqi9nSHJY+NdoGVaZvvVB54GnrKfGEH7IDR5mwIDAQAB
AoGAa94V5HH2kMNskXznsPpnS/2z+7w2OXFZrvdyx0iSqruWfJqlLbBRUp9orehG
V1C6oMxNMXaJ+/qqv62uQAAq3oCPHRrN5a1fLzYKk/ixUbk0F7saNvOsmWqbSIzv
OEtsHBt3zJxEkgLFzuaFnfoBoFL7lvJYol+4QPVvxYj2exkCQQDqVRGFbhRmKBZ+
ienF9JpUOruKEsW4lmSKP2fUAL4rH40cJEFD0OI80/WdN/34USPOEqSsFTZITvFH
+y+45PD/AkEA0acinvAAb0FLlMlhcG0LGzIwcYUWcEpPxwkioGgwGaEPLR276gHv
NvgtL7xgLi4QMKB0n48zz4W4Usww6QmbZQJBAOGIZoipXfDEfIHlcp4XwcF3lbBa
SPpTpQh55hBhdqZCg6mmKzp9/IDW7/oVPdaVIYTg5KTK9ae6cvb4hwHJNzkCQE3p
YclVAaRWzKK/b/Ga5Gy36x7UybDzPNCHyZF5Bp8PppcqnKHrFB4GfqxlwgyHW8bm
alC9pBBz7jr+3RJNWq0CQFHxhrjdhQFhYJoW8b+pqE1ryNSSSf/1yBEug6Xsqsjn
MSuyCTLXRpoS/LAdL95ENCX3ULsu/5nlpKZmy99yY2M=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent4-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQCvcVH69FzdPGCUXgwowuBz4lLAV+COzishbuyNGF5lJ6mw6eY8
gizLmpxh0r6d/REnlzKRy3Uy9FdZEQZKKfeK63MxLU6BYaHX0fnqz2y1oCaA2eW4
yeGOLaSBcjEKHIs964Ik9VKEDnioYtoObbFihRbcS6QLNajQR9ij+7hlpQIDAQAB
AoGASgLVIbf6gP4ahByUppFnXJuqayfnPHcu7MC9m9we3i94P4C8tuP3f8Dunbno
3f9HQFthYu3guCkpvBIZhCnmGgrge/Rm5IYN9Jktc8gTSQ0NlJbr3hjgHEkJXhca
6zE/sFEgZVWF/yCIunyU3umbWBJE9R+suk+mpe1wZ9T+AXUCQQDU208b7AvW9Yoo
8SomHE5B1FJOwnyEWHBJ9W0myGXOrJbf6zNJ4eOLQsn1UWSsI9tzgeh49f6smc7B
bhWhHqoLAkEA0wCs6zyKs0pbzGfGYQFafDbjSUBbT+nn4tXR+3O7Z8K6x3gt7DBx
VtlbJtfBBWCCrIgYsrU3TUwtweDV6umtDwJBAJN7tU+SeQ2jKex+VQb8+9gu5iy+
IwqMQJluHQgPOENAYHWcAPiDNGdMiqSYldmUKrzY2RvezmwHUjPCM+hkV8sCQQCF
MQL2RrQi8sg5ojQmXa1ZhWg5gAdjzXnTxTcUa/ybRd+TNDiAxB93PCL+xOiR1VcH
Q62beSqcf37OyHcgHztfAkAEHZwjVSRXFELBQDPzespHXVC3rwpQlbd1tqOybmPd
tpqmlWjvFxdvEDQZnemPUCtXNhMOaXcSOeeSYcUkIVX6
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent5-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQCksphKSkbE4aCa68r2o7j2xWbxbWP+bjAGwWWYQwnacQ6p5tlh
aN10ebDAmPVakLo8xxPEXMqWFxCU2AWg0Wtd6TgqIQtIMNXQz6cif5Ufxo3lhus+
dLhsflz+yTpFD5vREvn0kQ9ce+jVjVzh8bK5qfpaNlaIqQc64WpJKQe+8QIDAQAB
AoGASLj7ecI2YXTnP8DiC+nbIEul2vDceFobJsB6pbLkROoq+WaPke2F64pYO5LO
s8C4G2IkHk6CvadNkQuZ4JrX9xgNdxWRHGAbDedEFnN8gi0inHQjHITj62Il9civ
JB8cR5fJxzAKZS23elrocrzU6lU90V4gm4VUUJ6dQhZYO2ECQQDYoC6r+Qf9YCNU
89/RnGdUzL26l1S/GmUw5VfIDorMNbwH1xfg6Z8MukF42Q9kZQdtoh+HVLG7Ljok
2cLmmBA9AkEAwqIlSsiGSjfJlzQoDi13X2ZgVp6/nicKan1eKCPq+EnWhA5CP1u1
5WaYBbLjlDl7A7VA7gMd19tSNGHzRQRAxQJBAJe4kRe3wsXOqNBeQnuf7Kty/suK
JDv4s7jsWG/w53uhgwGGv92yIsiaRzLp7CLns60wqJ5zTkwIU4bt0dkJ1g0CQD9D
YQe7whqho37oTxS8po51wl6lXvdTDUmr0k0Nz7RAm990mwfpEWitPkCr8tkdDeUY
pzA2Bx9AhKnOJLqMNVkCQAwJYI4fS7Mec2f2Kv5SInxjMeasGivzDxe99EyLS8jz
dWfNwtCGA+gmpqcWqpT/JNnJgG4ljseW7Xk6YogngVU=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent6-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQDBIF2kWViZb+GpjUKfQ2Jevk68mLWXib66z6vCi+mjpcvZeq6A
5Z0MqNJYftEgSykluxL9EkpRqWr6qCDsSrpazMHG2HB+yip8/lfLWCv/xGAHh9+4
XY3sUPGIGg+LmvhRCZvgxARxY2uG7AB+WZVMby4TCyAFAT7D/ri4L8iZZwIDAQAB
AoGAIfEMRBwnxB+zq1bWRKNVII2VzPORxqZAzRg+eZyZXVeAMiKrlJ/GMDljboYr
Pt+2xZjRR4T1ZtC9qnvt/VlM0uWTEIgyzo29ZO0Bd9yMnIF2EUlzVtW07UnN6+VW
z1/RxOgBiAvkrSTgN4SOQJJIgOZYAt2Xhrkz/0CLwEOis1ECQQD+1hQkEYwvNH6Y
qUVoWvlNg0Q4kozNQCrwUrkHCtIOxCmr/KxcwcPBaVmEypcCnwf78KbgUQ/5oIgZ
OReuNcWjAkEAwgIk38VZRxSyBP1RThbKrK5h+GIwkEO7RW7lZ9yoVKhV6YDMWof0
xCl23YwdpflaTUHuBVOYa3EPegkOGCfxbQJAdCTDpzCsMHN/Yzp6nLYhu3chJ5t7
OqyNJVy+YXxIAlzbFTyind/dxQ+rsf7XVmV+sQ+cLs4jNsU4Yi6IIWj2ewJBAKRH
OH4bF9vulEdRUTV0ay4Jg3/VdRXTpJHIs4xc9lSpLgZJP8Ew+nvYOISlDr3qBSMC
PtBX1uqzk81cOYkO2YkCQBUVMew70XetUXgh/2KOWyG/87uYy/s/NZ/LGImvo+tq
FUapBPapob9I7WA6gRYVseiE+mSGPAciGIFg/d6iyxI=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/agent7-cert.pem,"-----BEGIN CERTIFICATE-----
MIIDEjCCAfqgAwIBAgIJAJ4TtCDh9ccYMA0GCSqGSIb3DQEBCwUAMDIxCzAJBgNV
BAYTAkNOMQ4wDAYDVQQKDAVDTk5JQzETMBEGA1UEAwwKQ05OSUMgUk9PVDAgFw0x
ODExMTYxODQyMjFaGA8yMjkyMDgzMDE4NDIyMVowXTELMAkGA1UEBhMCVVMxCzAJ
BgNVBAgMAkNBMQswCQYDVQQHDAJTRjENMAsGA1UECgwESU9KUzERMA8GA1UECwwI
aW9qcy5vcmcxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAM2+DkRxPeRGI4JK0YpuaqCJkNswMYMyZM4VQYyn99SL7xS8
lB9P0vIm+K1P4198WXwUHSykWRcyy54nMNpq+9Dfy8BalHRaUa8BO/7UQgipRGi0
HidDk/bAuNNHNIzJr2sGYGHsZuHkO9inEqDcqrSlTc0G0zyLry5LekRZRTgAlXpl
C9PsAZl0J+gGA83rUhdD/RDjaT4ldqjLKycHvcMLCIS6Wq0TszYCUdbvMsageDcQ
zQerIJkHzfJFGYCetQR5/fiIKyF1bICKD22AnpLlfhdthAhLVlYQn34IlYJwdptq
2miktcqvBw4rnBhE1ONj8DqF61S9BKr9aCf5OoMCAwEAATANBgkqhkiG9w0BAQsF
AAOCAQEAbek4GyLi+vVeUg3Od17lr8qT108iP3esUJ5cfPrXaexxcypRAmYPB7r4
NA/vVeOTNkxbb07Ct8dmz+rTn+FflI9h5eKRC7hbH/rFTDEfnoS66eSlxr/jJgtv
LWuKTMJhzXjgliHleaBDGzo3mR5hcJbQvj9qyK4pXjxlt2QvkPdx2H9H76+nBh1g
TY5bW4+3NFaHfaR2p2T20bY3no25/vfV7K5endff6pgzcZR3/SptGTywC4EZzIcz
9Q0JnALQtxAAxq1yrljQcvpjM/aAYY7BxwFHJuLmb/FpMulkzZ2vJALluF/3G5ne
RT9QhxJdwUz+Juv5QKH2i+nnb2Ur6g==
-----END CERTIFICATE-----
"
test/fixtures/keys/agent7-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIICxzCCAa8CAQAwXTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjENMAsGA1UECgwESU9KUzERMA8GA1UECwwIaW9qcy5vcmcxEjAQBgNVBAMM
CWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM2+DkRx
PeRGI4JK0YpuaqCJkNswMYMyZM4VQYyn99SL7xS8lB9P0vIm+K1P4198WXwUHSyk
WRcyy54nMNpq+9Dfy8BalHRaUa8BO/7UQgipRGi0HidDk/bAuNNHNIzJr2sGYGHs
ZuHkO9inEqDcqrSlTc0G0zyLry5LekRZRTgAlXplC9PsAZl0J+gGA83rUhdD/RDj
aT4ldqjLKycHvcMLCIS6Wq0TszYCUdbvMsageDcQzQerIJkHzfJFGYCetQR5/fiI
KyF1bICKD22AnpLlfhdthAhLVlYQn34IlYJwdptq2miktcqvBw4rnBhE1ONj8DqF
61S9BKr9aCf5OoMCAwEAAaAlMCMGCSqGSIb3DQEJBzEWDBRBIGNoYWxsZW5nZSBw
YXNzd29yZDANBgkqhkiG9w0BAQsFAAOCAQEAKcwglrFyAj+pc26WqHv5R9NToUKF
1Yd5zkExZHWH5glrAprCdRhUY575KcY1Sz4KCCRADdYo7KGUFHi4B/N+iyIS9m3t
TWpJQVq4o98hF0+FalhdYyIND2FdiTmdxzmi788JFcTKZT1ryKyoB7vAj0kvXdED
3VU2mDoxPc17ZInR5x0A8hJHDHY9SlDL96n6QTEAByXfqNq/c8S7bkBPEJJUln7G
L/8YWxQJ25971PEX/QLbWADMkSPGkHCHF0znZhtJ6wxTFRkdQJSa9FASKpVgDMMu
wQVEnOa10z2aQ3PayZUHh43zq441FakE7LAseeOoJChPb00lFrN3ph+TnQ==
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent8-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIICxzCCAa8CAQAwXTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEPMA0GA1UECgwGTk9ERUpTMQ8wDQYDVQQLDAZhZ2VudDgxEjAQBgNVBAMM
CWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALwm1xqs
+ed10Plvc7EBGgXNf5oXeExY4r8GytYUnU7gfL1sjsOqGbqgCY3LXCD5jV39Nc1d
fnALq6aFPJPUprXrcKmg1dCuaKClLs4AHn0aCyalNF6J1uFWitCAkAE5MUlnSc2B
E+vDU7pL+X/RYdCX4tkOmDypYFCLqEz0CUhKwDLHaYeCljD+87GhGTSYZmdS6a35
uA3VZ8FH2Lw4auVZgBxS41aK/89wyUvqVvaDkQ7WtwjLwGOaBnCGFljMbKBvQfTb
U07OfI43haSa8P0WCQPwjLkWsC1irf89cz4c5r5J0ynwCHOko2warvDcf173HetX
Nld/VP52Q07Ph/UCAwEAAaAlMCMGCSqGSIb3DQEJBzEWDBRBIGNoYWxsZW5nZSBw
YXNzd29yZDANBgkqhkiG9w0BAQsFAAOCAQEAsLb6+50b2ck7DOop0M+EitLaY3H2
PWZBS6A86RU+5y30pJsFKCtefN8Hb21DwSwqhkcFukHzZRcKuGA8IsMhlE2u7YAU
Bx8pX5jOBhFWbUG+mAoe563XPCQNZ3GbKg3pGOCJ8b6gflmGvIxXlzQlR8lg1RG2
dT5q/sWTOXOsDyu49bObDw0jEFM/HgHzpFyHdrnh3P2vEULx7qdRVUXQ9JIsuPjB
bys9FhjDmV9yEabWfHRXqrFY318CPit25Q6Cl9G4EFMCYkUX2nVzjLojExkwJHdf
y4wDaEzxtqJgEEaQwMu+j68v3wgYAGk0yKMFNDQ0gaSZkAQ6u8I5unTGYQ==
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent9-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIICxzCCAa8CAQAwXTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEPMA0GA1UECgwGTk9ERUpTMQ8wDQYDVQQLDAZhZ2VudDkxEjAQBgNVBAMM
CWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALagQyTY
QrAhmvHgg81waMfDkM67wDzImtxYbilOFRp2u/AwjttDhDA2Aebg9WluMA9tJSxE
9f3w9YvoZymgfSWYn36P0IIQgSRb6PnAzuFgFdRIa4Bll+R2ultkey/CliPZTf2x
+ZTIZPWAFsYGZoDM4OFlqphKb1V1opLnpJEx7Lc9uzH6KTKWCITI8WhEoDXjVm7H
PUwqLCzMse7LPqkJkpgrvHV2UQaLeHd2+REB0zJ5JcmRgJkZtLkVuXY65bilJY/i
ej8z3rS8HARi+4k8O3GrEZ7MTnWhenhbiX2T5Ng858YkNVbQ8CD4ml9t6kt62AVo
73941Z6zfgCEXoUCAwEAAaAlMCMGCSqGSIb3DQEJBzEWDBRBIGNoYWxsZW5nZSBw
YXNzd29yZDANBgkqhkiG9w0BAQsFAAOCAQEAms/rMyW2wVfNtBHZ7HAUxUlWl8ow
0dlZgVmAXF0WBnfOGn31CQcGPyj9btJ48tmaTXmhIw96KqQDIi8KmYXDrDm0JmEp
d+6Q704A0Qjwq4OmMqSobNHRVZUM24niF+U/oGuI8J5nSbCp/6m6chwM+R015cfl
1yNqqQXYYIogcHQZVdofeKvGmrQhBfsEt5cdk2riGqfWVBwY6rfXW+MSHIw6cHIn
vVFYG32Gk8ZU+MoWPQ/DLAy8B7Azo7ePMnidfaOxPAox6IGzCcZOfnCu2tZ09S5t
gqcpdnecBLuQdIybhKhCbM7GOmIricDeIJXkVhmwmjpcu1WdQWUIUsD18A==
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/ca3-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQCZ9fF/1UcYaurFIX0QIyAJdojn9+bfsTcjEIoGbsAnQLz2bsZ4
pqRNhZbYJApxqc+oDzZOqJOaxe8mlB5jUZ/sUA9Sp+wfWly95tkEHBMSse4xUNJV
M4vFPfOG4fv9fYGH3pcmAU1QnST4Fh+qZRzrh9wa99ltmB/U2mJEF6NriwIDAQAB
AoGAOfsmdNb0TFzPh2fiOnaP9SBf1MRGfU23DwyGfn+s+9tkjoYPVpajX9KEiWeh
S0cBPjBkamEQHYSXWPcFLrApwnaS8A3Tkp1Voas1dg9Bu3WmDzIIsmBseMgMW00C
6yETeYFtZ8/2nnpK/G7+N8eeseA63LUqg6ANw+BMH3o3dcECQQDNKW6ZfhDtn94+
PWeXmxJWU6bm30U4othIo3iZKIswDhxVnlZhZ0mrgs0mc9c4CzTmyogvLKN0/nJF
gknvEcdrAkEAwByJR63E5Wg8OR/d0HgZAkrXVZGkGz33ZddGygrdUGvk4dfYYALB
A6/aCDc99gn4cUkzcOGOUGGEn3m38BeUYQJAUfyytChK/4sZt2m2kkFoTJNVaYHk
GcQKBs09DofDR8r7y8Ng5b/vEtlMvocghMcFtw1M6v09vS1J4Tk17pH+TQJBAJYZ
dbU4cv+e6nbjjAam3ztoSEjGK0dRqiu7AMc5p+N++WzvnVKetDnyOtNyfgnvjlrN
C9ElmnD5UIrdqjZ/5eECQHhcQsKgsWGRKPKxyf7f/sFHpkSeAEZSAPdh8ouzIdUS
xSRbK9UF+ckIop5cYjnBbmFa/BjWr4m9NcEKE8rXYxk=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/ca4-key.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQDC1M2aGVYsmrBiut1n0nfTU+9vTNVdAmKQBjnNsv3IIch/PPaE
OIEm7dFhgdk86Z+wVCN3sAKu54Bz4JDKdPsFGvDy18JGuGH1vIVW5285IW7fMrzv
AdZtETeBAiPM10Q69ddB4M6FbLiF273ZqCJ+vSswkl5Dkas8YTZ0uwqKjQIDAQAB
AoGALnr8Tf4ra9q/p94ywfkZMyZ8Ic5vvI+8GeYSVjuUhfFhVtGhcivUzAfCgwOq
YvjNaxC3oW8xRK7gG0UA5fwAgm24RkwazqYgcT2OTqoffRhd3lmyOUcR7fWB6FAN
p7mx9ctW83HBPCwc7SIFaWxMULi3O38A7jXMMJrjIzhEsVUCQQDiKJF8sE6Ep7cr
ARDcWxKP5INa7+UdsPdpR+wKxdrReQuhIF5V0hA6QbyCsNpqhqrO7e4El194qCMk
NfYnz1nPAkEA3IoHlwMOquisd6/KcurFbUHguKH6CWzpxRU6QfLqUkNf+MPPozU1
qYOm7nukWyJq+dDt5hrmaSuZny6I9zWY4wJBALcq8kJRrRZFm9VppJVD8bG2+ygw
uZkllgyf4q4K9yHG7sNOKvlJDDmSujIDOLMkZLz5+VegngNj8ipGxhoSFwMCQGwv
VdvRhx919izcUk6fNmwLVgachsCa6e5hJGv3ktT58hlhTPk9/+4BBCGXC6AdOScF
Q76OUZsj5T8+H7hNVYsCQCahB/XNbok2MgfB8ABdqVPcAOMLtaGZH4gbE2M3p/Fh
Y6BHQ25FT3LPKEzU89XJuyRoxea3CXqioJngt3JxN1I=
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/rsa_private_1024.pem,"-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDRMGk0Tp+sGoU4FbTF76l7g3uOdSpqLBnP4UDKSdhv3p+lfr6F
piJh8KnXIPKMq5b4EX+X4Ghz7PKDMEs24ihiqwUMl89exvFtW2bXwqq0XpMqdF6R
CxbbBYy3DFPTCTvoHaoAfmwHzwBfelHt2PaYl4ZNxhpD4UcP3/lrUB5KhwIDAQAB
AoGAYK4gIUWpNDB5m4ckqkpuqSAGbbum47UIJPR1Lkjc2C8q16DxSvGSeHNy+3NF
xk/TkUj9EGNtww4isxER4ga6JLH5WNkF3k92ET2wSn6G9/CtPZRe6wRP593ZO5vd
KXLCXRNprlRVHQbE6VysIQToZKVH2sqoFhIH62RDdhXvQNECQQDq8PQsLd1szeKf
iaJSlPxfuPG9yEZO7YY3QygpTmzRjLfN5560SejEvctMiO4hlwnWNbQzGbgQfhfA
JbgK6Z0fAkEA4/CKKcR8JJe/8vukfTLDlgnp3DPMa1HOVFnKWF6QeCPk5aOehDcf
CFm4E+A6NAbtG0oor6e4Bsr4ASOpLxE9mQJBAK4oAYiCU0JleFm1CAvZfx9iFGkP
ffbiIfzzHmFITmgjvNi4mq+gnhjBbGOGmadytAsDclny9bvcDLUWANCuDhcCQCNE
aFwmBn8y64QQ41ZrsE9aoVBsw0gnlCEA84nQt9Ge3B+bvT7/uFF2cEDDBL5gA/eg
9cKX1KVYah7jAZ5CsKECQQCJFqYwEewb3G7aKjtAzVCsNfQSC64xT2EnMg47va9t
GK5DXshigVNpMHJ52N4QxWIRtUs5LOCeGaZP/vTkTQ+z
-----END RSA PRIVATE KEY-----
"
test/fixtures/keys/selfsigned-no-keycertsign/cert.pem,"-----BEGIN CERTIFICATE-----
MIIDATCCAemgAwIBAgIUb32MablwTzVJh3UQXwdun9pBoF0wDQYJKoZIhvcNAQEL
BQAwFDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTIyMDMxNTE2MzQwOFoXDTMyMDMx
MjE2MzQwOFowFDESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEF
AAOCAQ8AMIIBCgKCAQEA11wz7hAhdN072sp2aTySdsla65aZT10L1o74JNBZmMye
DSq7Lbbvqq8XuLlwogS0ACAQVEjL7GPVMgJwzRytdaSWdzr26dftPCL3m1h8azU/
Bs1nafHWhi3rx8RQnLfyusq0fThR9Xd3xfjDuaqhoa7Nc36XbG98XWkgxpm2R7wR
pLyNT9K2Ixvry9orZicTxv0Zyq+tD3CzSEch5OCApVZNaqEcIDgiN1zE/zqIe83v
9+NYpLo61yPiqqedCqZaKp037uwJCp/RL9g6bh7IFDGZcNFv3k0xjZB4BVm4BZMp
SlbI49hncVIJZNB7qWt5ilCzEbwOhgLt6Y3Yh8rgMwIDAQABo0swSTALBgNVHQ8E
BAMCBaAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwJQYDVR0RBB4wHIIJMTI3LjAuMC4x
gglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQELBQADggEBAEEXVnMzax6vmGPY
TNNK6HJuN8xUUbEKVHKPDTwKbn2ZPQRGNOs4CJ5vVc1h2tU1mfgg20FZzPqZ+y9N
hIFIaESTpX881NXM87aE21Gqo4rS66lubcoEUHWeY1+/LcdD6Gh/Ur0V4CBORZjA
W/H1nASZQKQLMHIkriopbclMQPOsUYM11JxLsTH6hOPCJRM5cl1K1KsHWY2yJ656
Gw9IX0NBTak0flEAL/JQkFlm2PRFJhWShPBHsC8/AWBcvgJH/0noNnDS5vAtCWa6
rJO6SoHFJwWK3xCVU2YsC6No2DrAukyqEdN8arifJ/2hEjx1XAfockNsWzrT1mB5
EpLq2L0=
-----END CERTIFICATE-----
"
example_js/es6_module_demo/module_def_async.js,"export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
"
test/fixtures/keys/agent1-cert.pem,"-----BEGIN CERTIFICATE-----
MIIC2DCCAkGgAwIBAgIJAOzJuFYnDamoMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2ExMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgzMDE4
NDIyMVowfTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEP
MA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQ8wDQYDVQQDDAZhZ2Vu
dDExIDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0GCSqGSIb3
DQEBAQUAA4GNADCBiQKBgQDvVEBwFjfiirsDjlZB+CjYNMNCqdJe27hqK/b72AnL
jgN6mLcXCOABJC5N61TGFkiF9Zndh6IyFXRZVb4gQX4zxNDRuAydo95BmiYHGV0v
t1ZXsLv7XrfQu6USLRtpZMe1cNULjsAB7raN+1hEN1CPMSmSjWc7MKPgv09QYJ5j
cQIDAQABo2EwXzBdBggrBgEFBQcBAQRRME8wIwYIKwYBBQUHMAGGF2h0dHA6Ly9v
Y3NwLm5vZGVqcy5vcmcvMCgGCCsGAQUFBzAChhxodHRwOi8vY2Eubm9kZWpzLm9y
Zy9jYS5jZXJ0MA0GCSqGSIb3DQEBCwUAA4GBAHrKvx2Z4fsF7b3VRgiIbdbFCfxY
ICvoJ0+BObYPjqIZZm9+/5c36SpzKzGO9CN9qUEj3KxPmijnb+Zjsm1CSCrG1m04
C73+AjAIPnQ+eWZnF1K4L2kuEDTpv8nQzYKYiGxsmW58PSMeAq1TmaFwtSW3TxHX
7ROnqBX0uXQlOo1m
-----END CERTIFICATE-----
"
test/fixtures/keys/fake-cnnic-root-cert.pem,"-----BEGIN CERTIFICATE-----
MIIC+TCCAeGgAwIBAgIJAJfD0pHVqYGkMA0GCSqGSIb3DQEBCwUAMDIxCzAJBgNV
BAYTAkNOMQ4wDAYDVQQKDAVDTk5JQzETMBEGA1UEAwwKQ05OSUMgUk9PVDAgFw0x
ODExMTYxODQyMjFaGA8yMjkyMDgzMDE4NDIyMVowMjELMAkGA1UEBhMCQ04xDjAM
BgNVBAoMBUNOTklDMRMwEQYDVQQDDApDTk5JQyBST09UMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEA0nOFmJ4C0bUucql6YlXHPVyuxh5IxZ0heSjVCJXp
Vk9JJRPxpU0Py1tSTW7GJSMRIsvFrrbVfb52YHOzaGwMiJ5OcR1cCVXWR5fci0lS
0mTh8Rf+igHjKe/qrpOoqWzw7a0AHkFbcA5pGOZcB9qW2aMq3+mv4z+K8Jpw/b7G
4QGeEfNx52xM/ygtW51GnmxFJp0eTrIQmJbPFKVrjjdAner+8v9fgmrYiFydFknf
EqzFlsO1hcflw3caVD/usBpHq4VVvzy2fPqx6VJsloMYyNlCJIvrC0woHb/yj7Da
JEnHu0MdEhrxzA+biw0/sgOH3au2FdtPoZlmloyReydiGQIDAQABoxAwDjAMBgNV
HRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQAMz67MddcgXRPkTEiRhVFrTIqr
rny80Smrz9byJx7KhK0ciaDm+KvJavm7e6rrzuedOmbOdhZ3oN5wVo55v1fZqhL1
dpt1/BlzyCBADE4FM2pDyvLKxbGGcpCzFCbi2K5WsKFJspm6Zr43R1y9UtyInNXB
GLYwcbGqUrhbtLgnGMBccS/rEgasN3RGbADnZulfzkoGSCTAHJP6B+pFIW6T3kyr
Sa+Wuvs0UeoaicOzMz8vTySpJPF+8kW/7MSuW26XZyc966Ht1dUuosv9Umg2VNcF
SxRoUuaQKyHkyh/p4JmrDu2I9J25VE3FNvH7YoJCyaVrF213LvVA92FtDqzp
-----END CERTIFICATE-----
"
example_js/create-react-app-ssr/src/index.js,"import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
ReactDOM.hydrate(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);"
src/lib.rs,"#![allow(dead_code, unused_imports, unused_must_use)]
#[macro_use]
extern crate lazy_static;

mod event_loop;
mod internal_module;
mod quickjs_sys;

pub use event_loop::EventLoop;

pub use quickjs_sys::*;
"
test/fixtures/keys/dsa_private_pkcs8.pem,"-----BEGIN PRIVATE KEY-----
MIICZQIBADCCAjoGByqGSM44BAEwggItAoIBAQChLDcaF/TawxKZ3mTau9Kp/p4k
8U7t8cNHK8MNuJ+M7r8EpIiRczjerIKp10LThqsqDvBzVAMRDyBvXekKacLREGKW
MTqR7jIrjpDkmOIQof1TV4Ju1OuFwassODBuq9EzToQ3oh8Avc4EXpjNL3Cff8R9
LBbZnyAAiSNmtOMRRNX7+AQB18SB39YBnFxz3Ngo7A/LT8uOOV1DDl+w+UgSRLXI
kWVYyiRKxlViUktHTqHVLiRCgTcGoQuKsf8VB8nfpExEWxopnqdBhLrpBzyvJtDD
ZWU4myqJGhNIPBEQ/PqP2gtiHUR7zqPle32NuIGsrfdRuROv+MG07QnY9HT7AiEA
hch7FLktAk9KiL3qTo5TjKssuYAhjyBL2Z1hN1unBx0CggEBAII3eBOMWI+AFD9u
P8R2n3D3RID51D9WedgNMxzP4yL/yyC2VDc70IIVvTfbtic4vC/GyZJp1P1esirX
/mMYPZW2MUNWWuJ2NgBKuN7NHaR2vvzUb5vG1U1C4g4pmX3Gqu4KYdRJJEv++4JH
qkqwDzVk9+l1wuHdFhjEMihMrq1VfgatfltzEYMhQJCJNqoq/03OmbWWIEtGbosd
zMGwWTY5WtHIyxPeCHQnoNJTD53D9Wu7UnqCWSuvQLEFagnrlu1yq0XJBX/vpu2i
v1CBz/P2y5gGglndRrTIB+/cnYSs6zUIBuHgtY1QsD14k5tjZHiwBXtDzA4xPmOa
Mqji6ekEIgIgNBV+HuDLNzl1J5rbEwC5OWDIjBd41KeKUQ4RxSgYLGE=
-----END PRIVATE KEY-----
"
test/path/test-path-posix-exists.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';

assert.strictEqual(require('path/posix'), require('path').posix);
"
test/path/test-path-win32-exists.js,"// Copyright Joyent and Node contributors. All rights reserved. MIT license.
'use strict';

import assert from 'assert';

assert.strictEqual(require('path/win32'), require('path').win32);
"
example_js/image.js,"import {Image} from 'image';
let img = new Image(__dirname + '/bird.png');
let img_luma = img.to_luma();
img_luma.save_to_file(__dirname + '/bird_luma.png')
"
example_js/simple_common_js_demo/npm_main.js,"const md5 = require('md5');
console.log(__dirname);
console.log('md5(message)=', md5('message'));
const {sqrt} = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
const {run} = require('./es6_code_module.js')
run()"
examples/embed_use_es6_module/es6_module_demo.js,"import * as std from 'std';

export function do_something(a) {
  print('[es6_module_demo.js]=> do_something: a =', a);
  return a;
}
"
test/fixtures/keys/agent2-cert.pem,"-----BEGIN CERTIFICATE-----
MIICczCCAdwCCQCtrfdcbYDS0jANBgkqhkiG9w0BAQsFADB9MQswCQYDVQQGEwJV
UzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQ8wDQYDVQQKDAZKb3llbnQxEDAO
BgNVBAsMB05vZGUuanMxDzANBgNVBAMMBmFnZW50MjEgMB4GCSqGSIb3DQEJARYR
cnlAdGlueWNsb3Vkcy5vcmcwIBcNMTgxMTE2MTg0MjIxWhgPMjI5MjA4MzAxODQy
MjFaMH0xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzAN
BgNVBAoMBkpveWVudDEQMA4GA1UECwwHTm9kZS5qczEPMA0GA1UEAwwGYWdlbnQy
MSAwHgYJKoZIhvcNAQkBFhFyeUB0aW55Y2xvdWRzLm9yZzCBnzANBgkqhkiG9w0B
AQEFAAOBjQAwgYkCgYEAq2BtovcwlIUNVAi3ukbyQveZNg3VkkxB6Ih+CL70VEX3
0ji5EpQqGjwk5Ub6tRYfuGHwBWSO8+W2PwtdplDbuIOoK5MAp+wkDRCC8H1l4i8c
dOA97Edw3nRU6MiPrUiirV1u2liHYp6YDLWix80UiNnH6EOLFd5Wy5s7CSt4rEkC
AwEAATANBgkqhkiG9w0BAQsFAAOBgQCg75WmaDjpwBmMAl/+5oK8D7p2V98ChhyV
bIwhpLPo9jf7iPW9VayxQKvV5HXuiT1vpIjuvhbRRH3wGj3by0TtI+sqECcPKu1v
5bg2e+bX8s1OXFJh+x93KCnrcFNEwOVk9VjUX+ilJdTkdcGA75N4ZO7qEV5wKl9g
658PRZl3KA==
-----END CERTIFICATE-----
"
test/fixtures/keys/agent3-cert.pem,"-----BEGIN CERTIFICATE-----
MIICcDCCAdkCCQCR8AZjYGnynDANBgkqhkiG9w0BAQsFADB6MQswCQYDVQQGEwJV
UzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQ8wDQYDVQQKDAZKb3llbnQxEDAO
BgNVBAsMB05vZGUuanMxDDAKBgNVBAMMA2NhMjEgMB4GCSqGSIb3DQEJARYRcnlA
dGlueWNsb3Vkcy5vcmcwIBcNMTgxMTE2MTg0MjIxWhgPMjI5MjA4MzAxODQyMjFa
MH0xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNV
BAoMBkpveWVudDEQMA4GA1UECwwHTm9kZS5qczEPMA0GA1UEAwwGYWdlbnQzMSAw
HgYJKoZIhvcNAQkBFhFyeUB0aW55Y2xvdWRzLm9yZzCBnzANBgkqhkiG9w0BAQEF
AAOBjQAwgYkCgYEAv+hwfSVuJfHDQOXmF2D/HsI2JZkspfrPQE/ZL1tII2cXRnus
IqWZvLg9v7IVY0gSvx5gWMHxmqqaK75McVJvO1XEzLYpa9Ddnj06xqNWl6hwLHnP
bclRi2n63Cs6zSM80r1iQ16ovZ0hyWPjXaBlWmb71QeeBp6ynxhB+yA0eZsCAwEA
ATANBgkqhkiG9w0BAQsFAAOBgQA/C2xJIYA3Vo8pr1cfmzN+os9uvbMQEAegg6W+
6/t82tLGnrCEglMTFHFp7MJCNiKCY16Ixi5WCZoUrGCfbh+Obtd4bP/wAlR8AS67
lYZDvjADGU4e7Aqu0o0AHeb4MiRUQbkD0EUioyD8091Qhzlrx43UtdojPvakwAXM
N/LFEw==
-----END CERTIFICATE-----
"
test/fixtures/keys/agent4-cert.pem,"-----BEGIN CERTIFICATE-----
MIICjjCCAfegAwIBAgIJAJHwBmNgafKaMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2EyMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjBaGA8yMjkyMDgzMDE4
NDIyMFowfTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEP
MA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQ8wDQYDVQQDDAZhZ2Vu
dDQxIDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0GCSqGSIb3
DQEBAQUAA4GNADCBiQKBgQCvcVH69FzdPGCUXgwowuBz4lLAV+COzishbuyNGF5l
J6mw6eY8gizLmpxh0r6d/REnlzKRy3Uy9FdZEQZKKfeK63MxLU6BYaHX0fnqz2y1
oCaA2eW4yeGOLaSBcjEKHIs964Ik9VKEDnioYtoObbFihRbcS6QLNajQR9ij+7hl
pQIDAQABoxcwFTATBgNVHSUEDDAKBggrBgEFBQcDAjANBgkqhkiG9w0BAQsFAAOB
gQAykzKtLG++xAfLoq2AZ3OKlEYGC4RuOCy9J75RYWNRuy18UnYl0HGSepeqQ/4c
0r+dy/SLUVKxC7e87hs7gP8UX+f9UaVM7dvqvZbZMVH+A6w2nIAcO3zwtSJlfQ8H
NJAdQl1lZ6qc97APtBlfeTMTdi/hTghqZLah21/hIE5lFw==
-----END CERTIFICATE-----
"
test/fixtures/keys/agent5-cert.pem,"-----BEGIN CERTIFICATE-----
MIIChTCCAe6gAwIBAgIJAJHwBmNgafKdMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2EyMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgzMDE4
NDIyMVowdDELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFwZXN0MREwDwYDVQQK
DAhUcmVzb3JpdDEWMBQGA1UEAwwNw4Fkw6FtIExpcHBhaTEnMCUGCSqGSIb3DQEJ
ARYYYWRhbS5saXBwYWlAdHJlc29yaXQuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GN
ADCBiQKBgQCksphKSkbE4aCa68r2o7j2xWbxbWP+bjAGwWWYQwnacQ6p5tlhaN10
ebDAmPVakLo8xxPEXMqWFxCU2AWg0Wtd6TgqIQtIMNXQz6cif5Ufxo3lhus+dLhs
flz+yTpFD5vREvn0kQ9ce+jVjVzh8bK5qfpaNlaIqQc64WpJKQe+8QIDAQABoxcw
FTATBgNVHSUEDDAKBggrBgEFBQcDAjANBgkqhkiG9w0BAQsFAAOBgQAYcJ8LyVUB
5GNqnVdJW4dndeUvllYW3txxuUXhcxgvT7b0glDXSp/cRq0yxZb1jRCLqESsHer0
o064S5GCWCktZWwbDo75YFE2Vo1R8TChhmD1txFcAi2J161yn9QVoHVbOhyyIHXz
Yw9zhrnJURZA+1lUpIarcRmkUsbSR25gyg==
-----END CERTIFICATE-----
"
test/fixtures/keys/ca1-cert.pem,"-----BEGIN CERTIFICATE-----
MIIChDCCAe2gAwIBAgIJAMsVOuISYJ/GMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2ExMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjBaGA8yMjkyMDgzMDE4
NDIyMFowejELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEP
MA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANjYTEx
IDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0GCSqGSIb3DQEB
AQUAA4GNADCBiQKBgQDrNdKjVKhbxKbrDRLdy45u9vsU3IH8C3qFcLF5wqf+g7OC
vMOOrFDM6mL5iYwuYaLRvAtsC0mtGPzBGyFflxGhiBYaOhi7nCKEsUkFuNYlCzX+
FflT04JYT3qWPLL7rT32GXpABND/8DEnj5D5liYYNR05PjV1fUnGg1gPqXVxbwID
AQABoxAwDjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4GBAHhsWFy6m6VO
AjK14n0XCSM66ltk9qMKpOryXneLhmmkOQbJd7oavueUWzMdszWLMKhrBoXjmvuW
QceutP9IUq1Kzw7a/B+lLPD90xfLMr7tNLAxZoJmq/NAUI63M3nJGpX0HkjnYwoU
ekzNkKt5TggwcqqzK+cCSG1wDvJ+wjiD
-----END CERTIFICATE-----
"
test/fixtures/keys/ca2-cert.pem,"-----BEGIN CERTIFICATE-----
MIICbTCCAdYCCQDRrfgRk8tC1zANBgkqhkiG9w0BAQsFADB6MQswCQYDVQQGEwJV
UzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQ8wDQYDVQQKDAZKb3llbnQxEDAO
BgNVBAsMB05vZGUuanMxDDAKBgNVBAMMA2NhMjEgMB4GCSqGSIb3DQEJARYRcnlA
dGlueWNsb3Vkcy5vcmcwIBcNMTgxMTE2MTg0MjIwWhgPMjI5MjA4MzAxODQyMjBa
MHoxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNV
BAoMBkpveWVudDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2EyMSAwHgYJ
KoZIhvcNAQkBFhFyeUB0aW55Y2xvdWRzLm9yZzCBnzANBgkqhkiG9w0BAQEFAAOB
jQAwgYkCgYEAv61gNiLff+zxCdAwdzlVoucGu5L+LFFN9TXzcT3ZD8U1H6CiLp3Q
02IlbK1JRHwpJBXgYOFvMWd9LD6JiJgJsp61kpZShl2qZSUIfhzeExWH7kkuPHWC
IEkiP/aDp5wuqbFBkNUJu8opYr0E6/t9sIzl4IK7WNDXWgQvv8cqin8CAwEAATAN
BgkqhkiG9w0BAQsFAAOBgQB80WTJ9neA5yVaDVV+hZtOasLiZlUT8m49ImQMnInA
jdoAkxgySNOJP8IrsilleAGeHF+JPy042z8NZ5C+xL9REaB1/OaQ7+nwHP0O0f+l
kXHgZATQ3YVf6db5euK3R1mdO1Vv++R4Nu4NYBu0cmfMpdl/uKdYpXMjPVn21iB7
5w==
-----END CERTIFICATE-----
"
test/fixtures/keys/ca3-cert.pem,"-----BEGIN CERTIFICATE-----
MIIChDCCAe2gAwIBAgIJAOzJuFYnDamnMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2ExMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgzMDE4
NDIyMVowejELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEP
MA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANjYTMx
IDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0GCSqGSIb3DQEB
AQUAA4GNADCBiQKBgQCZ9fF/1UcYaurFIX0QIyAJdojn9+bfsTcjEIoGbsAnQLz2
bsZ4pqRNhZbYJApxqc+oDzZOqJOaxe8mlB5jUZ/sUA9Sp+wfWly95tkEHBMSse4x
UNJVM4vFPfOG4fv9fYGH3pcmAU1QnST4Fh+qZRzrh9wa99ltmB/U2mJEF6NriwID
AQABoxAwDjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4GBAM3CFiDdGEcx
07J6pm4zGX399VxPr50PID110jmX7BRAfqva+wBRhwweSxZ/QRcKe1v/FK3GE87y
RbaXhFfnPRUHoUHQMtGwmZuZcdK65Pim9RPGb7qrEJ2wlPt/C1Q6VjL/fBGqjtJM
Bq/2GR2GoBsE85jGM287hcvXV0eG5OwM
-----END CERTIFICATE-----
"
test/fixtures/keys/ca4-cert.pem,"-----BEGIN CERTIFICATE-----
MIICkzCCAfygAwIBAgIJAJHwBmNgafKbMA0GCSqGSIb3DQEBCwUAMHoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNVBAoMBkpveWVu
dDEQMA4GA1UECwwHTm9kZS5qczEMMAoGA1UEAwwDY2EyMSAwHgYJKoZIhvcNAQkB
FhFyeUB0aW55Y2xvdWRzLm9yZzAgFw0xODExMTYxODQyMjFaGA8yMjkyMDgzMDE4
NDIyMVowgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0Yx
HzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAOBgNVBAsMB05vZGUu
anMxDDAKBgNVBAMMA2NhNDEeMBwGCSqGSIb3DQEJARYPY2E0QGV4YW1wbGUub3Jn
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDC1M2aGVYsmrBiut1n0nfTU+9v
TNVdAmKQBjnNsv3IIch/PPaEOIEm7dFhgdk86Z+wVCN3sAKu54Bz4JDKdPsFGvDy
18JGuGH1vIVW5285IW7fMrzvAdZtETeBAiPM10Q69ddB4M6FbLiF273ZqCJ+vSsw
kl5Dkas8YTZ0uwqKjQIDAQABoxAwDjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB
CwUAA4GBAGDMGSbPg/B4OripSxT2scXFIwoej47PW1byJgWaGoMJ8zgKUoKE7Z7A
aWQbD22In05F0kBllqpSJWEZpTuVFsyyLeb3R7cuGQWs/puaaPul7sx+PRGhwxYe
nrNIGtsaBf8TO/kb5lMiXWbhM5gZbBtbMMv3xWA4FxqU0AgfO3jM
-----END CERTIFICATE-----
"
test/fixtures/keys/ca5-key.pem,"-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEINQRYMZO9+WwFZsKDa03DHkQfraKyJ3EcAfYkgtyYtX3oAoGCCqGSM49
AwEHoUQDQgAE6qDnQ6qm6hN+zbym76EK+spOKstEmqj9WzdA/tRBHhzZijXq1l90
yQmRfmgclAKZw843qzMfj8VjRMRXdZyyYA==
-----END EC PRIVATE KEY-----
"
test/fixtures/keys/ca6-key.pem,"-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIFbxtF4Zc09n/2w7z5SMQLFNTdxg4QPSm1WgyffHtJFIoAoGCCqGSM49
AwEHoUQDQgAEa7HfEgyVTPWYku9cWGRSym5OdB7zqFihL8+k93EfWViJph72fJH3
sOZypUgDXS/sEyUaLhbxtLYzsMbECzEDwQ==
-----END EC PRIVATE KEY-----
"
test/fixtures/keys/dsa_params.pem,"-----BEGIN DSA PARAMETERS-----
MIICLQKCAQEAoSw3Ghf02sMSmd5k2rvSqf6eJPFO7fHDRyvDDbifjO6/BKSIkXM4
3qyCqddC04arKg7wc1QDEQ8gb13pCmnC0RBiljE6ke4yK46Q5JjiEKH9U1eCbtTr
hcGrLDgwbqvRM06EN6IfAL3OBF6YzS9wn3/EfSwW2Z8gAIkjZrTjEUTV+/gEAdfE
gd/WAZxcc9zYKOwPy0/LjjldQw5fsPlIEkS1yJFlWMokSsZVYlJLR06h1S4kQoE3
BqELirH/FQfJ36RMRFsaKZ6nQYS66Qc8rybQw2VlOJsqiRoTSDwREPz6j9oLYh1E
e86j5Xt9jbiBrK33UbkTr/jBtO0J2PR0+wIhAIXIexS5LQJPSoi96k6OU4yrLLmA
IY8gS9mdYTdbpwcdAoIBAQCCN3gTjFiPgBQ/bj/Edp9w90SA+dQ/VnnYDTMcz+Mi
/8sgtlQ3O9CCFb0327YnOLwvxsmSadT9XrIq1/5jGD2VtjFDVlridjYASrjezR2k
dr781G+bxtVNQuIOKZl9xqruCmHUSSRL/vuCR6pKsA81ZPfpdcLh3RYYxDIoTK6t
VX4GrX5bcxGDIUCQiTaqKv9Nzpm1liBLRm6LHczBsFk2OVrRyMsT3gh0J6DSUw+d
w/Vru1J6glkrr0CxBWoJ65btcqtFyQV/76btor9Qgc/z9suYBoJZ3Ua0yAfv3J2E
rOs1CAbh4LWNULA9eJObY2R4sAV7Q8wOMT5jmjKo4unp
-----END DSA PARAMETERS-----
"
test/fixtures/keys/dsa_private_1025.pem,"-----BEGIN DSA PRIVATE KEY-----
MIIB0gIBAAKBiQDp3xGIsNcKZWSpur2Ab2f5rirhu5AsYGLI/XZvzueoO4kLPp3s
zKHXabBObdxU07kRFkfpV9lftdXT3a6E/Wxb+w2d7g0F7pWTdwpmmofcRtwgbynm
JKvqWt/OwfVFsdUvvpVci9AxY/5rdM/K54Srp6iSpfteBYKGqCpPnswikND0GxKM
1MbzAhUAqAPKCZ4hxromirUu33tn3Nhsq20CgYgf0tH2nwzWlPLoN4OJvC5dVLPv
MRyJTQekW8tR0oY6PeshmZOaoI0L3e/M4KeZ/4qiY7IRNksP2YGJxjfS6W+h+MNj
PO5r0aYYFYCPQ8JbhBO7l0hdXmkTY3FcdyRHeh2gwe3bBX6Auev2MGgL616Cgd/K
H8PAX9EHmrNPcQOWHem4KcfJXqouAoGIcZ/4bJurOAw5OL4+5BsE4jfSVFq4nmNl
+m6Iy6ls3hOHOZ9sJlw0Fi+ZtdeddOTYnIngW/kH09XGoF5JJOaLQv2O4GmZfDfn
la+vfHZPsOxmYqeEbSwA2pqlhOn/dCshBOymhwNLXp1FJ3JUEyh8i605X06XmWoj
4ZIu/tr1xbnZDLHuFjBmXAIURbB5/IDf2h0sW+qL5gHFO8bgr+E=
-----END DSA PRIVATE KEY-----
"
test/fixtures/keys/dsa_private_encrypted_1025.pem,"-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIBvTBXBgkqhkiG9w0BBQ0wSjApBgkqhkiG9w0BBQwwHAQIqTW00yecdxMCAggA
MAwGCCqGSIb3DQIJBQAwHQYJYIZIAWUDBAEqBBBKgO4UF0LfCkPyS+iCvSrtBIIB
YD3W6FyEZ97/crnoyRqjPUtr2Mm4KJMtaB5ZiGFzZEzd6AH7N/dbtAAMIibtsjmd
RYdIptpET6xTpUhM8TvpULyYaZnhZJKTpVUrTVdvFTS3DYDutu7aWRLTrle6LzcY
XpIppeP8ZmYFdRBQxhF+KoDsP4O0QA+vWl2W2VmRfr+sK9R+qV89w0YMjEWHsYY+
VZsDbJBGKkj9gzIvxIsRyack/+RsbiSDrh6WTw+D0jrX/IMbgPjvYfBFhpxGC7zR
hDn9r3JaO2KdHh9kMtvQfshA1n636kb0X6ewY57BhEs3J4hpMg46c6YFry94to24
jxl5KutM0CFea7mYGtNf6WJXBsm7JSW03kjlqYoZGK43KNgZhzKAsXaNkoRkA5cw
BzGfgmG6dHTpeAY9G4vM4inhCmGFA8Tx189g+xzRv16uFXRb8WFIllne1fEFaXRr
1Rz2G6SPJkA3fsrl8zUIB0Y=
-----END ENCRYPTED PRIVATE KEY-----
"
test/fixtures/keys/ec-key.pem,"-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIBxOoTv4SYyESx2cM2ittkAS3z3YGQsPp38otS0PpkqhoAoGCCqGSM49
AwEHoUQDQgAESmnBRzFlBzaptPGSjxURgC0qEw9vPOSEyULeKq/4Mkb2BdEncq3y
/Pf8e4FXqAYOO5pM5ui7/+nuwGM529xNcA==
-----END EC PRIVATE KEY-----
"
test/fixtures/keys/ec10-key.pem,"-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIAAaqQ4/ivoch4lwve3fjDLeycYlB3q15IoxsA3fEBA7oAoGCCqGSM49
AwEHoUQDQgAEO5axA1UnzA9mOoWqSRV65h9it+Cy1w87sCJwauB9Ap4W/P6gt3r5
T44YUwWHT4uQjqhMAOx6tYwXK5qKoMgXMA==
-----END EC PRIVATE KEY-----
"
test/fixtures/keys/rsa_public_4096.pem,"-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxeStwofbjtZuol4lwKn1
w08AzcSNLHfCqNFHa+W7er8is7LQsPljtPT4yn4lsao83ngHFvSC3tbMiRNDpUHY
qH2wBuUkuOmCtYkZLi0307H0CwcVV6W5P3tNEt80IJ+PqlRxtTknezUtbOasbIi/
aornVWG+psgqDGrFZ4oTsWtiE0Svi7sDqN5E2dijmH/YYnlnwqszgzHdtAnARp1b
G34E64sqWCmLoGCfPdHtym/CSdxOLOsDV15jrwODZQ/TJZ5thkwKZRxu7g9fwlhA
1PiI5WDP4reXNaqa2bSgrzpAljQExYs4N0L7okSVOJQX9BEaoWtq8NLU8MpMdGoH
NDU0Xr60Lfr58Z5qn8RGEvlTxoCbPJzPV2zgzD/lmEqft6NnfTclveA3sd8xSrOB
Un4o3S8hS0b9Su7PBukHjM96/e0ReoIshSwXlQTLr2Ft8KwupyPm1ltNcTDtjqHc
IWU6Bg+kPy9mxSVtGGZYAPtqGzNBA/m+oOja/OSPxAblPdln691DaDuZs5nuZCGw
GcLaJWgiyoqvXAcyXDZFyH4OZZh8rsBLKbnFXHZ/ziG0cAozEygZEPJappw8Lx/a
dy7WL/SJjxooiKapc7Bnfy8eSLV3+XAKxhLW/MQ6ChJ+e/8ExAY02ca4MpCvqwIk
9TfV6FM8pWGqHzQFj0v3NL0CAwEAAQ==
-----END PUBLIC KEY-----
"
example_js/react_ssr/main.js,"import React from 'react';
import {renderToString} from 'react-dom/server';

import Home from './component/Home.jsx';

const content = renderToString(React.createElement(Home));
console.log(content);
"
examples/embed_js/README.md,"
## Build

```
cargo build --target wasm32-wasi --release
```

## Run

```
wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm
```
"
examples/embed_js_module/README.md,"
## Build

```
cargo build --target wasm32-wasi --release
```

## Run

```
wasmedge --dir .:. target/wasm32-wasi/release/embed_js_module.wasm
```
"
examples/embed_rust_module/README.md,"
## Build

```
cargo build --target wasm32-wasi --release
```

## Run

```
wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm
```
"
modules/internal/test/binding.js,"import uv from ""../../internal_binding/uv"";

export function internalBinding(mod) {
    if (mod === ""uv"") {
        return uv;
    }
}"
test/fixtures/keys/agent1-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB4jCCAUsCAQAwfTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEPMA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQ8wDQYDVQQD
DAZhZ2VudDExIDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0G
CSqGSIb3DQEBAQUAA4GNADCBiQKBgQDvVEBwFjfiirsDjlZB+CjYNMNCqdJe27hq
K/b72AnLjgN6mLcXCOABJC5N61TGFkiF9Zndh6IyFXRZVb4gQX4zxNDRuAydo95B
miYHGV0vt1ZXsLv7XrfQu6USLRtpZMe1cNULjsAB7raN+1hEN1CPMSmSjWc7MKPg
v09QYJ5jcQIDAQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hhbGxlbmdlIHBhc3N3
b3JkMA0GCSqGSIb3DQEBCwUAA4GBAN3UIAdShj7eA91fH8m8UQBJndgigNwt88qk
S2kS3XfZqkEawMu2HF/y5yWX7EyGs7OkRXZxJSR67GlgdrTi82qCBC3H2xF7fKXr
s5b6ges5NZFjEA9JTvX5PFSAfo5APbXuuhRWBdxvagi00szTnYiaKgGU4C/dZWAz
E0/tTFT4
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent10-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB3TCCAUYCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEfMB0GA1UECgwWVGhlIE5vZGUuanMgRm91bmRhdGlvbjEQMA4GA1UECwwH
Tm9kZS5qczEcMBoGA1UEAwwTYWdlbnQxMC5leGFtcGxlLmNvbTCBnzANBgkqhkiG
9w0BAQEFAAOBjQAwgYkCgYEArV2diVumrKDS5k81MrcdECnYYVZ5feQ/FZDqwEHM
/zlXvs6vphU3rGmZeASMQEdHg7vUjzzvE8PDqJuJXKrC5lEO1OUYeUDhaZ/QvYS9
tDp7qTJzORxT9im65dQH0Xq5JQwTy30hidQHxOgAkILNive07/JkN1vle6TnZX6K
/dkCAwEAAaAlMCMGCSqGSIb3DQEJBzEWDBRBIGNoYWxsZW5nZSBwYXNzd29yZDAN
BgkqhkiG9w0BAQsFAAOBgQBeyxGhHnFF0ifHhWUbqqMM9zJ5OhLjGsQ0gvmK/LHL
vmGJ43XgeYiN/U6xREQ7DZMss+C14mfQvp5oM0zQRWwQhLgV7YlIIIe09CYTKTfC
xxc18OJewNQUje5cG5aSMZb2HfHmLDaavAJqK0Yaoj69e+iEnAkVFVZALqlhezS+
xQ==
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent2-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB4jCCAUsCAQAwfTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEPMA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQ8wDQYDVQQD
DAZhZ2VudDIxIDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0G
CSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrYG2i9zCUhQ1UCLe6RvJC95k2DdWSTEHo
iH4IvvRURffSOLkSlCoaPCTlRvq1Fh+4YfAFZI7z5bY/C12mUNu4g6grkwCn7CQN
EILwfWXiLxx04D3sR3DedFToyI+tSKKtXW7aWIdinpgMtaLHzRSI2cfoQ4sV3lbL
mzsJK3isSQIDAQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hhbGxlbmdlIHBhc3N3
b3JkMA0GCSqGSIb3DQEBCwUAA4GBAJqJXQdhuPxsJA6O/yWt9t9lQIgoYCQyCG2w
Xl0n84f14WDi/N9rF0IfGMSVWoLDCc5gcoqKal0X/vQI4lpPiZ0hctU5cXru1Pvi
yfDbIPB0td7POf3Q3Ge3a3RHf4I4cfRuzA6jfzMlorpgQmAKL+sstC94LZZnDiNp
ihciaeK7
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent3-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB4jCCAUsCAQAwfTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEPMA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQ8wDQYDVQQD
DAZhZ2VudDMxIDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0G
CSqGSIb3DQEBAQUAA4GNADCBiQKBgQC/6HB9JW4l8cNA5eYXYP8ewjYlmSyl+s9A
T9kvW0gjZxdGe6wipZm8uD2/shVjSBK/HmBYwfGaqporvkxxUm87VcTMtilr0N2e
PTrGo1aXqHAsec9tyVGLafrcKzrNIzzSvWJDXqi9nSHJY+NdoGVaZvvVB54GnrKf
GEH7IDR5mwIDAQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hhbGxlbmdlIHBhc3N3
b3JkMA0GCSqGSIb3DQEBCwUAA4GBAFHJUONDqOhZpGN8ZCFkWkGyD4iDPGdJyR1f
lh1N2vSf9vx663ni6lG9XQrQZXyPH8n7vvyyX1bJE5X6dAKuiD4GYlcGUUCnsvcA
r+JzSBrbtwD57bPnn21YSUl2QEoG2b+/6uPKWxKr8e1sreMxHOLwsPgSavnQ84Bc
GvSLlIcR
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent4-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB4jCCAUsCAQAwfTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEPMA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQ8wDQYDVQQD
DAZhZ2VudDQxIDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0G
CSqGSIb3DQEBAQUAA4GNADCBiQKBgQCvcVH69FzdPGCUXgwowuBz4lLAV+COzish
buyNGF5lJ6mw6eY8gizLmpxh0r6d/REnlzKRy3Uy9FdZEQZKKfeK63MxLU6BYaHX
0fnqz2y1oCaA2eW4yeGOLaSBcjEKHIs964Ik9VKEDnioYtoObbFihRbcS6QLNajQ
R9ij+7hlpQIDAQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hhbGxlbmdlIHBhc3N3
b3JkMA0GCSqGSIb3DQEBCwUAA4GBAJ4tZ0hFXYqGQ0BDpcI6QIjufzoFHXMHBmE0
wHU1f8jVM2v9Df5eInArMvAVya4gXtuZnMpRZKNrcbnwPUK9spwIzHxPyw7qjeCP
SG+TusJoFFIGgpZBo6zVdtpRCRbTxNfKteK+y34g+sYZolt88AmlzY8H2QYeQabI
1SBuLdBH
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/ca3-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB3zCCAUgCAQAwejELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQH
DAJTRjEPMA0GA1UECgwGSm95ZW50MRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQD
DANjYTMxIDAeBgkqhkiG9w0BCQEWEXJ5QHRpbnljbG91ZHMub3JnMIGfMA0GCSqG
SIb3DQEBAQUAA4GNADCBiQKBgQCZ9fF/1UcYaurFIX0QIyAJdojn9+bfsTcjEIoG
bsAnQLz2bsZ4pqRNhZbYJApxqc+oDzZOqJOaxe8mlB5jUZ/sUA9Sp+wfWly95tkE
HBMSse4xUNJVM4vFPfOG4fv9fYGH3pcmAU1QnST4Fh+qZRzrh9wa99ltmB/U2mJE
F6NriwIDAQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hhbGxlbmdlIHBhc3N3b3Jk
MA0GCSqGSIb3DQEBCwUAA4GBACeDmANyVHX/zFlz0OhqXzFw2C76/AjoNsR7cY6b
Mdl8R27MexPxkhD2IOzESxDkxFTzv+aVAz4gQIxDmdea307/P5LvRQXucAtNkAWi
2j6hB0Oq1BNKyBnevRTv28X7rhUp5OGDhRPP5lt1+PPA0zTurw+zJIaInePM//sT
7Ckh
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/ca4-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB7jCCAVcCAQAwgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UE
BwwCU0YxHzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAOBgNVBAsM
B05vZGUuanMxDDAKBgNVBAMMA2NhNDEeMBwGCSqGSIb3DQEJARYPY2E0QGV4YW1w
bGUub3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDC1M2aGVYsmrBiut1n
0nfTU+9vTNVdAmKQBjnNsv3IIch/PPaEOIEm7dFhgdk86Z+wVCN3sAKu54Bz4JDK
dPsFGvDy18JGuGH1vIVW5285IW7fMrzvAdZtETeBAiPM10Q69ddB4M6FbLiF273Z
qCJ+vSswkl5Dkas8YTZ0uwqKjQIDAQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hh
bGxlbmdlIHBhc3N3b3JkMA0GCSqGSIb3DQEBCwUAA4GBAJoKIMOK0sCoXAa/cCaJ
oTYLHee1aJBWmt8XTUqREdFIIAjjrgY0/ZGEeA9OEczbFgSTMPXemir4Ks3ib3kr
MeJkOWSUgKL2gdV4jPZIUEdeTYaMQ5utiTvL2oKN4R51mSNg5ZEFIf+vZpK6UTpR
LCERUC79Hsj13NrHK2Lf8jhy
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent5-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB2TCCAUICAQAwdDELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFwZXN0MREw
DwYDVQQKDAhUcmVzb3JpdDEWMBQGA1UEAwwNw4Fkw6FtIExpcHBhaTEnMCUGCSqG
SIb3DQEJARYYYWRhbS5saXBwYWlAdHJlc29yaXQuY29tMIGfMA0GCSqGSIb3DQEB
AQUAA4GNADCBiQKBgQCksphKSkbE4aCa68r2o7j2xWbxbWP+bjAGwWWYQwnacQ6p
5tlhaN10ebDAmPVakLo8xxPEXMqWFxCU2AWg0Wtd6TgqIQtIMNXQz6cif5Ufxo3l
hus+dLhsflz+yTpFD5vREvn0kQ9ce+jVjVzh8bK5qfpaNlaIqQc64WpJKQe+8QID
AQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hhbGxlbmdlIHBhc3N3b3JkMA0GCSqG
SIb3DQEBCwUAA4GBABmDywVdbouxznVhI5cnTB2cZTGKMDYCnYx+0pFOZw6ux1eR
oUF59E/QCIfibOI6b1+Dd7O3hK81aCQxd6oBiWWg8gyCjFcoCVqOkR/Ug176asZv
72+l6pBLYoZlmPrQXkxtfL+FtLM3/xLdt6hDSZEWyznWcraanDqKx9M4NEgG
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/agent6-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIB2TCCAUICAQAwdDELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFwZXN0MREw
DwYDVQQKDAhUcmVzb3JpdDEWMBQGA1UEAwwNw4Fkw6FtIExpcHBhaTEnMCUGCSqG
SIb3DQEJARYYYWRhbS5saXBwYWlAdHJlc29yaXQuY29tMIGfMA0GCSqGSIb3DQEB
AQUAA4GNADCBiQKBgQDBIF2kWViZb+GpjUKfQ2Jevk68mLWXib66z6vCi+mjpcvZ
eq6A5Z0MqNJYftEgSykluxL9EkpRqWr6qCDsSrpazMHG2HB+yip8/lfLWCv/xGAH
h9+4XY3sUPGIGg+LmvhRCZvgxARxY2uG7AB+WZVMby4TCyAFAT7D/ri4L8iZZwID
AQABoCUwIwYJKoZIhvcNAQkHMRYMFEEgY2hhbGxlbmdlIHBhc3N3b3JkMA0GCSqG
SIb3DQEBCwUAA4GBAAX9mbfgDULEA541c1teuG+eW0KLghFaaotFb0+R6WD1ZQLO
Url8y1iz6T/qqfuoAWu5OA8/7sKDdta/0mzV6UoGnDOcnWnH5FURmnQPUS/hBJ6A
mJBslJx6y0z4Rl/fxJUy5K31YbeRHHLEneM211usTv8QguAD0y2BNAQ0Mno0
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/ca5-cert.pem,"-----BEGIN CERTIFICATE-----
MIICHDCCAcGgAwIBAgIJANUB/0ZUgBZhMAoGCCqGSM49BAMCMIGIMQswCQYDVQQG
EwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMR8wHQYDVQQKDBZUaGUgTm9k
ZS5qcyBGb3VuZGF0aW9uMRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANjYTUx
HjAcBgkqhkiG9w0BCQEWD2NhNUBleGFtcGxlLm9yZzAgFw0xODExMTYxODQyMjFa
GA8yMjkyMDgzMDE4NDIyMVowgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEL
MAkGA1UEBwwCU0YxHzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAO
BgNVBAsMB05vZGUuanMxDDAKBgNVBAMMA2NhNTEeMBwGCSqGSIb3DQEJARYPY2E1
QGV4YW1wbGUub3JnMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6qDnQ6qm6hN+
zbym76EK+spOKstEmqj9WzdA/tRBHhzZijXq1l90yQmRfmgclAKZw843qzMfj8Vj
RMRXdZyyYKMQMA4wDAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAgNJADBGAiEA4nCM
yQUkViSEvBeL3cLzRnak68tXTIkdRMekRFgdsOMCIQDFnkeCyB4S9u2gz1u/syEq
usBaxJpZkN5nyTLapTQGqA==
-----END CERTIFICATE-----
"
test/fixtures/keys/ca6-cert.pem,"-----BEGIN CERTIFICATE-----
MIICGzCCAcGgAwIBAgIJAMTCBUQ4OI4+MAoGCCqGSM49BAMCMIGIMQswCQYDVQQG
EwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMR8wHQYDVQQKDBZUaGUgTm9k
ZS5qcyBGb3VuZGF0aW9uMRAwDgYDVQQLDAdOb2RlLmpzMQwwCgYDVQQDDANjYTUx
HjAcBgkqhkiG9w0BCQEWD2NhNUBleGFtcGxlLm9yZzAgFw0xODExMTYxODQyMjFa
GA8yMjkyMDgzMDE4NDIyMVowgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEL
MAkGA1UEBwwCU0YxHzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAO
BgNVBAsMB05vZGUuanMxDDAKBgNVBAMMA2NhNjEeMBwGCSqGSIb3DQEJARYPY2E2
QGV4YW1wbGUub3JnMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEa7HfEgyVTPWY
ku9cWGRSym5OdB7zqFihL8+k93EfWViJph72fJH3sOZypUgDXS/sEyUaLhbxtLYz
sMbECzEDwaMQMA4wDAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAgNIADBFAiEA+NIP
zuqh2e3/59QndyPqRH2CZ4V4ipU6rf6ZZmwPApUCIBMABWesJfwdrETIjN6dT8gc
STrYyR4ovD8Aofubqjd0
-----END CERTIFICATE-----
"
test/fixtures/keys/dsa_public_1025.pem,"-----BEGIN PUBLIC KEY-----
MIIBzjCCATsGByqGSM44BAEwggEuAoGJAOnfEYiw1wplZKm6vYBvZ/muKuG7kCxg
Ysj9dm/O56g7iQs+nezModdpsE5t3FTTuREWR+lX2V+11dPdroT9bFv7DZ3uDQXu
lZN3Cmaah9xG3CBvKeYkq+pa387B9UWx1S++lVyL0DFj/mt0z8rnhKunqJKl+14F
goaoKk+ezCKQ0PQbEozUxvMCFQCoA8oJniHGuiaKtS7fe2fc2GyrbQKBiB/S0faf
DNaU8ug3g4m8Ll1Us+8xHIlNB6Rby1HShjo96yGZk5qgjQvd78zgp5n/iqJjshE2
Sw/ZgYnGN9Lpb6H4w2M87mvRphgVgI9DwluEE7uXSF1eaRNjcVx3JEd6HaDB7dsF
foC56/YwaAvrXoKB38ofw8Bf0Qeas09xA5Yd6bgpx8leqi4DgYwAAoGIcZ/4bJur
OAw5OL4+5BsE4jfSVFq4nmNl+m6Iy6ls3hOHOZ9sJlw0Fi+ZtdeddOTYnIngW/kH
09XGoF5JJOaLQv2O4GmZfDfnla+vfHZPsOxmYqeEbSwA2pqlhOn/dCshBOymhwNL
Xp1FJ3JUEyh8i605X06XmWoj4ZIu/tr1xbnZDLHuFjBmXA==
-----END PUBLIC KEY-----
"
example_js/add.js,"// add.js
function add(a, b) {
  return a + b;
}

print('haha');

export default add;
"
test/fixtures/keys/ec-cert.pem,"-----BEGIN CERTIFICATE-----
MIIB6zCCAZICCQDB6nsD1ZVtUjAKBggqhkjOPQQDAjB9MQswCQYDVQQGEwJVUzEL
MAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQ8wDQYDVQQKDAZKb3llbnQxEDAOBgNV
BAsMB05vZGUuanMxDzANBgNVBAMMBmFnZW50MjEgMB4GCSqGSIb3DQEJARYRcnlA
dGlueWNsb3Vkcy5vcmcwIBcNMTgxMTE2MTg0MzE0WhgPMjI5MjA4MzAxODQzMTRa
MH0xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCU0YxDzANBgNV
BAoMBkpveWVudDEQMA4GA1UECwwHTm9kZS5qczEPMA0GA1UEAwwGYWdlbnQyMSAw
HgYJKoZIhvcNAQkBFhFyeUB0aW55Y2xvdWRzLm9yZzBZMBMGByqGSM49AgEGCCqG
SM49AwEHA0IABEppwUcxZQc2qbTxko8VEYAtKhMPbzzkhMlC3iqv+DJG9gXRJ3Kt
8vz3/HuBV6gGDjuaTObou//p7sBjOdvcTXAwCgYIKoZIzj0EAwIDRwAwRAIgAmC2
Xfpv1zjKePs3xAAWGP3Xp9+1lOdHpA3mTjlAFOoCIAJagVrpr8rWOf73fdN31xrs
8IdbV8S1DDlqYzANVPnA
-----END CERTIFICATE-----
"
.cargo/config.toml,"[build]
target = ""wasm32-wasi""
rustflags = ""-C target-feature=+bulk-memory""

[target.wasm32-wasi]
runner = ""wasmedge --dir=.:. ""
"
example_js/module_demo/demo.js,"import { hello_mod_1 } from 'my_mod_1'
import { hello_mod_2 } from 'my_mod_2'

hello_mod_1()
hello_mod_2()"
test/fixtures/keys/ca2-crl.pem,"-----BEGIN X509 CRL-----
MIIBXTCBxzANBgkqhkiG9w0BAQ0FADB6MQswCQYDVQQGEwJVUzELMAkGA1UECAwC
Q0ExCzAJBgNVBAcMAlNGMQ8wDQYDVQQKDAZKb3llbnQxEDAOBgNVBAsMB05vZGUu
anMxDDAKBgNVBAMMA2NhMjEgMB4GCSqGSIb3DQEJARYRcnlAdGlueWNsb3Vkcy5v
cmcXDTE4MTExNjE4NDIyMFoXDTQ2MDQwMjE4NDIyMFowHDAaAgkAkfAGY2Bp8poX
DTE4MTExNjE4NDIyMFowDQYJKoZIhvcNAQENBQADgYEAiZKSPllC/hi1S9jedRFt
eah65RINSkGZt40AuxPIFfyu5qSeKU+9p8zdXELtPqywSr2k6JjBP40yRIc5/odZ
CxFM5XR/AIoeNspplxb+Qg1v1KlbGxzfeBHRIn91QpKcvsMCEYF8nu3xKOJmYrTR
3Kj0gniNHbiLe/HTpEY7YOA=
-----END X509 CRL-----
"
test/fixtures/keys/ca5-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIBaTCCARACAQAwgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UE
BwwCU0YxHzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAOBgNVBAsM
B05vZGUuanMxDDAKBgNVBAMMA2NhNTEeMBwGCSqGSIb3DQEJARYPY2E1QGV4YW1w
bGUub3JnMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6qDnQ6qm6hN+zbym76EK
+spOKstEmqj9WzdA/tRBHhzZijXq1l90yQmRfmgclAKZw843qzMfj8VjRMRXdZyy
YKAlMCMGCSqGSIb3DQEJBzEWDBRBIGNoYWxsZW5nZSBwYXNzd29yZDAKBggqhkjO
PQQDAgNHADBEAiABtQaxoQqAdrK8rjMh4wPB14/+uxMtJ7mY+QwJ411XywIgERcz
HrcyJDqk2CS8B9mHwzD+ERUZ1CgThc15bnBleN0=
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/ca6-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIBaTCCARACAQAwgYgxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UE
BwwCU0YxHzAdBgNVBAoMFlRoZSBOb2RlLmpzIEZvdW5kYXRpb24xEDAOBgNVBAsM
B05vZGUuanMxDDAKBgNVBAMMA2NhNjEeMBwGCSqGSIb3DQEJARYPY2E2QGV4YW1w
bGUub3JnMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEa7HfEgyVTPWYku9cWGRS
ym5OdB7zqFihL8+k93EfWViJph72fJH3sOZypUgDXS/sEyUaLhbxtLYzsMbECzED
waAlMCMGCSqGSIb3DQEJBzEWDBRBIGNoYWxsZW5nZSBwYXNzd29yZDAKBggqhkjO
PQQDAgNHADBEAiAH69eeaDguTPAqGhWJbhFPEw7zXyZl6TgxoMIeZOouRgIge+Ft
kXO05md30kbq6s559B45rYoH4iHxFOJZqHso7Yc=
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/ec10-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIBWDCB/wIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcM
AlNGMR8wHQYDVQQKDBZUaGUgTm9kZS5qcyBGb3VuZGF0aW9uMRAwDgYDVQQLDAdO
b2RlLmpzMRwwGgYDVQQDDBNhZ2VudDEwLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0C
AQYIKoZIzj0DAQcDQgAEO5axA1UnzA9mOoWqSRV65h9it+Cy1w87sCJwauB9Ap4W
/P6gt3r5T44YUwWHT4uQjqhMAOx6tYwXK5qKoMgXMKAlMCMGCSqGSIb3DQEJBzEW
DBRBIGNoYWxsZW5nZSBwYXNzd29yZDAKBggqhkjOPQQDAgNIADBFAiEAgyYiDWmr
Ks1RAQAsxR91PFzxJRa7dgclWPmuDTGTxhcCIFLtalcAOlD+4Wa06SvgGWN/R4V2
u/JZjWD+lWFZjOC5
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/rsa_pss_public_2048_sha256_sha256_16.pem,"-----BEGIN PUBLIC KEY-----
MIIBUjA9BgkqhkiG9w0BAQowMKANMAsGCWCGSAFlAwQCAaEaMBgGCSqGSIb3DQEB
CDALBglghkgBZQMEAgGiAwIBEAOCAQ8AMIIBCgKCAQEA36jTOAvkLQ+94iC6jpKn
1fIWtztfY6V/FLoyJNWe9m227sBM4dPrAcNHQ9DfAoJF53jzhBHequxzZm8gjaka
QyujQ72gjA1oBGg/z5R5EZ7byofNSF0jAuYpo0XznGSBPxp8O4fLWp2m9J++fjg7
yya5hFlBtqu/SJtZljMe0qaHfjaelxGPuyO5wFFFor69+WMeQ3ssWPK8RRqbC7Rr
IuyTUDuGh8ngaY/Lc9BYb9t7j8sBNpxpjx355F1m603Bxm82AYBG3kh/SlJEcHM6
g1zTj4bX2hBxBU5tDKHigpyXtVTo0ssHr++3VdSmX6VYdyodGUUCHvWDlSYY+JTM
dwIDAQAB
-----END PUBLIC KEY-----
"
test/fixtures/keys/rsa_pss_public_2048_sha512_sha256_20.pem,"-----BEGIN PUBLIC KEY-----
MIIBTTA4BgkqhkiG9w0BAQowK6ANMAsGCWCGSAFlAwQCA6EaMBgGCSqGSIb3DQEB
CDALBglghkgBZQMEAgEDggEPADCCAQoCggEBALzPTYDAg6suXao+VGtnGXHOM1a/
nwhd+G2Z+tzgXmBvEUySjN49+pTv8mprXw3LQ4W/O2+OQkuoqRK/CeeyPVheeUzZ
4LJ+hjaV4MAHtHhV1JyqJ7qpxhAu8fK975AIPfTwSoQLRXOaE2mmQwBSjM3OXSAv
ydGPpMYaowjzSNMnUIGZiga5mIzPXL2zmIEUC9dBq1niflx5NhN93p3WhfuHcI4M
q8yJ7f5ejk5Igi/BefSf4bZNRj67vQU+sOcjkv7x+quhQ+ros1C1c58rXZR44J61
WhyZrKlY62EGvTgGY/Rga03pQVr0PW+vhQR1BRwafB0qfNpVgmU4T63Gf0MCAwEA
AQ==
-----END PUBLIC KEY-----
"
src/event_loop/wasi_sock.rs,"use std::os::wasi::prelude::RawFd;
pub use wasmedge_wasi_socket::nslookup;
pub use wasmedge_wasi_socket::socket::*;
pub type RawSocket = RawFd;
"
test/fixtures/keys/dsa1025.pem,"-----BEGIN DSA PARAMETERS-----
MIIBLgKBiQDp3xGIsNcKZWSpur2Ab2f5rirhu5AsYGLI/XZvzueoO4kLPp3szKHX
abBObdxU07kRFkfpV9lftdXT3a6E/Wxb+w2d7g0F7pWTdwpmmofcRtwgbynmJKvq
Wt/OwfVFsdUvvpVci9AxY/5rdM/K54Srp6iSpfteBYKGqCpPnswikND0GxKM1Mbz
AhUAqAPKCZ4hxromirUu33tn3Nhsq20CgYgf0tH2nwzWlPLoN4OJvC5dVLPvMRyJ
TQekW8tR0oY6PeshmZOaoI0L3e/M4KeZ/4qiY7IRNksP2YGJxjfS6W+h+MNjPO5r
0aYYFYCPQ8JbhBO7l0hdXmkTY3FcdyRHeh2gwe3bBX6Auev2MGgL616Cgd/KH8PA
X9EHmrNPcQOWHem4KcfJXqou
-----END DSA PARAMETERS-----
"
test/fixtures/keys/ec-csr.pem,"-----BEGIN CERTIFICATE REQUEST-----
MIIBODCB3wIBADB9MQswCQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcM
AlNGMQ8wDQYDVQQKDAZKb3llbnQxEDAOBgNVBAsMB05vZGUuanMxDzANBgNVBAMM
BmFnZW50MjEgMB4GCSqGSIb3DQEJARYRcnlAdGlueWNsb3Vkcy5vcmcwWTATBgcq
hkjOPQIBBggqhkjOPQMBBwNCAARKacFHMWUHNqm08ZKPFRGALSoTD2885ITJQt4q
r/gyRvYF0SdyrfL89/x7gVeoBg47mkzm6Lv/6e7AYznb3E1woAAwCgYIKoZIzj0E
AwIDSAAwRQIhANc8OD4E9EhR8SBrvdgA6n0rg9x6cpWst4cMkR59wkSJAiAD+kOE
X4RCKkmFxRysPaXrbwEQRCVYV/ynrCsYm5kbnA==
-----END CERTIFICATE REQUEST-----
"
test/fixtures/keys/incorrect_san_correct_subject-cert.pem,"-----BEGIN CERTIFICATE-----
MIIBqDCCAU6gAwIBAgIUE3Kx4WUjkwuKy/fBOM+UJkb9aSAwCgYIKoZIzj0EAwIw
GzEZMBcGA1UEAwwQZ29vZC5leGFtcGxlLmNvbTAeFw0yMTEyMTExNjUxNDVaFw0z
MTEyMDkxNjUxNDVaMBsxGTAXBgNVBAMMEGdvb2QuZXhhbXBsZS5jb20wWTATBgcq
hkjOPQIBBggqhkjOPQMBBwNCAASQ/CKa5uMZuLYssnNOm7DPdw3I5Doa0Qpyf3cS
7aGatfK3tuY8qG7nJ5OGtl1WOL/gN0vRRN0/KA/iRJyjafzzo3AwbjAdBgNVHQ4E
FgQUFkpgPzE1ePjK5UsPcR0gk5uLsTUwHwYDVR0jBBgwFoAUFkpgPzE1ePjK5UsP
cR0gk5uLsTUwDwYDVR0TAQH/BAUwAwEB/zAbBgNVHREEFDASghBldmlsLmV4YW1w
bGUuY29tMAoGCCqGSM49BAMCA0gAMEUCIQCMZAinQXkOEhfp+moxVnLbcUPAAqsl
1KCq3NRG91TGCgIgC4grmOhCRqJMF1RPNWobGogX/yNrYNjiGzNVyJzMR0s=
-----END CERTIFICATE-----
"
test/fixtures/keys/irrelevant_san_correct_subject-cert.pem,"-----BEGIN CERTIFICATE-----
MIIBnTCCAUKgAwIBAgIUa28EJmmQ7yZOq3WWNP3SLiJnzcAwCgYIKoZIzj0EAwIw
GzEZMBcGA1UEAwwQZ29vZC5leGFtcGxlLmNvbTAeFw0yMTEyMTExNzE0NDVaFw0z
MTEyMDkxNzE0NDVaMBsxGTAXBgNVBAMMEGdvb2QuZXhhbXBsZS5jb20wWTATBgcq
hkjOPQIBBggqhkjOPQMBBwNCAATEKoJfDvKQ6dD+yvc4DaeH0ZlG8VuGJUVi6iIb
ugY3dKHdmXUIuwwUScgztLc6W8FfvbTxfTF2q90ZBJlr/Klvo2QwYjAdBgNVHQ4E
FgQUu55oRZI5tdQDmViwAvPEbzZuY2owHwYDVR0jBBgwFoAUu55oRZI5tdQDmViw
AvPEbzZuY2owDwYDVR0TAQH/BAUwAwEB/zAPBgNVHREECDAGhwQBAgMEMAoGCCqG
SM49BAMCA0kAMEYCIQDw8z8d7ToB14yxMJxEDF1dhUqMReJFFwPVnvzkr174igIh
AKJ9XL+02sGOE7xZd5C0KqUXeHoIE9shnejnhm3WBrB/
-----END CERTIFICATE-----
"
test/fixtures/keys/rsa_pss_public_2048.pem,"-----BEGIN PUBLIC KEY-----
MIIBIDALBgkqhkiG9w0BAQoDggEPADCCAQoCggEBAMuDjHUvOD5YCOQkS23W7nfU
bu76axa9mDTVJnU+w92IAKYr/Ao8yly4lQ52zBE/pcJrWoPxHGbMVQiqL7Lt9KWA
Ega4hzojFWLovfmWiaEPciOpToxtUW7lASVzUoxwScagapnIGTm9ZnUa/3l86QDF
id4X7i6I1Nvs1Eid/673qXqXCxRtqvZwNPjybJCez54dy9MnZ791N4XbjJ+TlX5v
ycdRT8maQ9fOLSX3/jfjGN7N4SHH7jpy/T5eETxnmkwuE9aOOtDWhumxu3NloYOj
TmlYGhSGojW600zQqVY3k8mpbE12JUEN4Yio7LdEO6XxRJCQ6PKoqi2ndTLJefcC
AwEAAQ==
-----END PUBLIC KEY-----
"
test/fixtures/keys/rsa_pss_public_2048_sha1_sha1_20.pem,"-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQowAAOCAQ8AMIIBCgKCAQEAqXbrc7DxUNddNKLkeWgM
GK8vGgLRtHPs1/VKjVxgqUQ1szz6Vx1GUgdQZk0y+BIStrZAH25WDas0bggGJSh2
xaRS7NsyxKK36dFrBTT2gRxPSR6SyDOKF8TwlMqWeyQJ+emWKJ2AmfCJefEsw/Wq
BeNUUxJqXMd15C9kUGtNtkYknHGGSsf8s7JFFAHU7072Mrox9TJL7H1T/jbOW0S+
iFaqMBXd8b+nLb30DMc9K5bYEwvsDptwhbZ/hut8uj/2dFNg0XWnLDZDejxRlwCA
dJErys7PIFaHBAYksDJHE/yg90evD2NfG9mrqmhnJvIAPoGlSd+igFuHTgI22PmI
rQIDAQAB
-----END PUBLIC KEY-----
"
test/fixtures/keys/rsa_public.pem,"-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt9xYiIonscC3vz/A2ceR
7KhZZlDu/5bye53nCVTcKnWd2seY6UAdKersX6njr83Dd5OVe1BW/wJvp5EjWTAG
YbFswlNmeD44edEGM939B6Lq+/8iBkrTi8mGN4YCytivE24YI0D4XZMPfkLSpab2
y/Hy4DjQKBq1ThZ0UBnK+9IhX37Ju/ZoGYSlTIGIhzyaiYBh7wrZBoPczIEu6et/
kN2VnnbRUtkYTF97ggcv5h+hDpUQjQW0ZgOMcTc8n+RkGpIt0/iM/bTjI3Tz/gsF
di6hHcpZgbopPL630296iByyigQCPJVzdusFrQN5DeC+zT/nGypQkZanLb4ZspSx
9QIDAQAB
-----END PUBLIC KEY-----
"
test/fixtures/keys/rsa_public_2048.pem,"-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArk4OqxBqU5/k0FoUDU7C
pZpjz6YJEXUpyqeJmFRVZPMUv/Rc7U4seLY+Qp6k26T/wlQ2WJWuyY+VJcbQNWLv
jJWks5HWknwDuVs6sjuTM8CfHWn1960JkK5Ec2TjRhCQ1KJy+uc3GJLtWb4rWVgT
bbaaC5fiR1/GeuJ8JH1Q50lB3mDsNGIk1U5jhNaYY82hYvlbErf6Ft5njHK0BOM5
OTvQ6BBv7c363WNG7tYlNw1J40dup9OQPo5JmXN/h+sRbdgG8iUxrkRibuGv7loh
52QQgq2snznuRMdKidRfUZjCDGgwbgK23Q7n8VZ9Y10j8PIvPTLJ83PX4lOEA37J
lwIDAQAB
-----END PUBLIC KEY-----
"
test/fixtures/keys/rsa_public_b.pem,"-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyb1grrN+29fxeeEbTaSE
ja6TKDTpT/WXnqrFCS+h7IYcnDoAVwcsPU5FZeUPvLKMzi9NHSJ34LQCurqHgH8X
+cw0YT3gdYS/7qoQiXs+zKv615NcttD3xlQLceY+NwznoPXyyZwOeZqyU5Hiqbrq
u6hdr6gQYogMNLn2NxBW2pGegd6+ZGMCX3+/BtMP/6tXmttYjY+yhN2SrGz5cKhW
pcHiC6X+B7uCKoKZy+t2jUxYVKUwWr1ZuM8kpSnuVCcv1OoMGEimEHA7v/eaF/y+
z/VdQ4Y88GhTnVN4KbtgZ+o9PohjxLFU62VeTALixU5mPQKSgSICKfjev0FUUurF
6wIDAQAB
-----END PUBLIC KEY-----
"
test/fixtures/keys/dh2048.pem,"-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEA+/OlXG2eqOsd9oA6Rg9KDbU22adIXuuwSaVLiUFNIc4WYnzPuyd0
WcLajZzhXoUpN6GCLqXE+jBphHTh+xx6Y0ztlMldx0mnrLzacd236LCrTX5smojO
CQ3BFmbDn7naG2famOZXF3gLRkcAmUtHrn2hYRbEk+1+GD3yXUm/JgFcnAX2HUQa
b4sDL5NHMJ61+qE65qIIht9jOVovl4b7yOoyDu+JrheV0XBrc8WU03AGKcJnjW6i
YqKXQlpamVvL/QqWfhg3SztBxYADAURePTUmS1H1FTnxSdRoUK9ZwKoTeZFL6krT
3HK76Y0HXhwtjk3aXKTJyEDDLdYaltOCOwIBAg==
-----END DH PARAMETERS-----
"
test/fixtures/keys/ec_p521_private.pem,"-----BEGIN PRIVATE KEY-----
MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIAEghuafcab9jXW4gO
QLeDaKOlHEiskQFjiL8klijk6i6DNOXcFfaJ9GW48kxpodw16ttAf9Z1WQstfzpK
GUetHImhgYkDgYYABAGixYI8Gbc5zNze6rH2/OmsFV3unOnY1GDqG9RTfpJZXpL9
ChF1dG8HA4zxkM+X+jMSwm4THh0Wr1Euj9dK7E7QZwHd35XsQXgH13Hjc0QR9dvJ
BWzlg+luNTY8CkaqiBdur5oFv/AjpXRimYxZDkhAEsTwXLwNohSUVMkN8IQtNI9D
aQ==
-----END PRIVATE KEY-----
"
test/fixtures/keys/rsa_public_sha1_signature_signedby_rsa_private.sha1,"yfF4}x=e	Z'`a%Z>Ytmxd4Ec(9kL2+qSi2:[dfj/59O<8'. OeL82t/3K,lZt[4f#*	Y	w/2fXha<T;Z`F#<wIGi6fwE<4evb.
"
test/fixtures/keys/rsa_public_sha1_signature_signedby_rsa_private_pkcs8.sha1,"yfF4}x=e	Z'`a%Z>Ytmxd4Ec(9kL2+qSi2:[dfj/59O<8'. OeL82t/3K,lZt[4f#*	Y	w/2fXha<T;Z`F#<wIGi6fwE<4evb.
"
test/fixtures/keys/incorrect_san_correct_subject-key.pem,"-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIOOVRgLS3H2T2fUhj4ASCFq60ySwO6yvSK6rvZHldAHuoAoGCCqGSM49
AwEHoUQDQgAEkPwimubjGbi2LLJzTpuwz3cNyOQ6GtEKcn93Eu2hmrXyt7bmPKhu
5yeThrZdVji/4DdL0UTdPygP4kSco2n88w==
-----END EC PRIVATE KEY-----
"
test/fixtures/keys/irrelevant_san_correct_subject-key.pem,"-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIDsijdVlHMNTvJ4eqeUbpjMMnl72+HLtEIEcbauckCP6oAoGCCqGSM49
AwEHoUQDQgAExCqCXw7ykOnQ/sr3OA2nh9GZRvFbhiVFYuoiG7oGN3Sh3Zl1CLsM
FEnIM7S3OlvBX7208X0xdqvdGQSZa/ypbw==
-----END EC PRIVATE KEY-----
"
test/fixtures/keys/agent1.pfx,"0	0	O	*H
	@	<0	807	*H
(0$"
test/fixtures/keys/agent10.pfx,"00	*H
00	*H
0"
test/fixtures/keys/agent6.pfx,"00	*H
00	*H
p0l"
test/fixtures/keys/ec_p384_private.pem,"-----BEGIN PRIVATE KEY-----
MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDB3B+4e4C1OUxGftkEI
Gb/SCulzUP/iE940CB6+B6WWO4LT76T8sMWiwOAGUsuZmyKhZANiAASE43efMYmC
/7Tx90elDGBEkVnOUr4ZkMZrl/cqe8zfVy++MmayPhR46Ah3LesMCNV+J0eG15w0
IYJ8uqasuMN6drU1LNbNYfW7+hR0woajldJpvHMPv7wlnGOlzyxH1yU=
-----END PRIVATE KEY-----
"
test/fixtures/keys/ec_p521_public.pem,"-----BEGIN PUBLIC KEY-----
MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBosWCPBm3Oczc3uqx9vzprBVd7pzp
2NRg6hvUU36SWV6S/QoRdXRvBwOM8ZDPl/ozEsJuEx4dFq9RLo/XSuxO0GcB3d+V
7EF4B9dx43NEEfXbyQVs5YPpbjU2PApGqogXbq+aBb/wI6V0YpmMWQ5IQBLE8Fy8
DaIUlFTJDfCELTSPQ2k=
-----END PUBLIC KEY-----
"
test/fixtures/keys/fake-startcom-root-database.txt,"V	22920830184221Z		01	unknown	/C=US/ST=CA/L=SF/O=NODEJS/OU=agent8/CN=localhost
V	22920830184221Z		02	unknown	/C=US/ST=CA/L=SF/O=NODEJS/OU=agent9/CN=localhost
"
test/fixtures/keys/rsa_cert.pfx,"0
A0
	*H
		0	0	*H
0"
test/fixtures/keys/rsa_public_1024.pem,"-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRMGk0Tp+sGoU4FbTF76l7g3uO
dSpqLBnP4UDKSdhv3p+lfr6FpiJh8KnXIPKMq5b4EX+X4Ghz7PKDMEs24ihiqwUM
l89exvFtW2bXwqq0XpMqdF6RCxbbBYy3DFPTCTvoHaoAfmwHzwBfelHt2PaYl4ZN
xhpD4UcP3/lrUB5KhwIDAQAB
-----END PUBLIC KEY-----
"
example_js/es6_module_demo/module_def.js,"function hello() {
  console.log('hello from module_def.js');
}

export {hello};
"
test/fixtures/keys/dh1024.pem,"-----BEGIN DH PARAMETERS-----
MIGHAoGBAOJ2igPYPdXULPSXaeR40pdGRdQmiWchzxDbzExdaJ4Q/landa7K9jfj
KNV2heMpFoXa6+GkCxXSli+99j0W/ARK1nnZ9YaB42sp3g2oTmMevWyk9hfZTTUC
Pc3AyioJGTQV/5wqYPdSNAu5KdHFZkP26EhbGgnDZ2hg5vFQT6EjAgEC
-----END DH PARAMETERS-----
"
test/fixtures/keys/ec_p256_private.pem,"-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgDxBsPQPIgMuMyQbx
zbb9toew6Ev6e9O6ZhpxLNgmAEqhRANCAARfSYxhH+6V5lIg+M3O0iQBLf+53kuE
2luIgWnp81/Ya1Gybj8tl4tJVu1GEwcTyt8hoA7vRACmCHnI5B1+bNpS
-----END PRIVATE KEY-----
"
test/fixtures/keys/ec_p384_public.pem,"-----BEGIN PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEhON3nzGJgv+08fdHpQxgRJFZzlK+GZDG
a5f3KnvM31cvvjJmsj4UeOgIdy3rDAjVfidHhtecNCGCfLqmrLjDena1NSzWzWH1
u/oUdMKGo5XSabxzD7+8JZxjpc8sR9cl
-----END PUBLIC KEY-----
"
test/fixtures/keys/ec_secp256k1_private.pem,"-----BEGIN PRIVATE KEY-----
MIGEAgEAMBAGByqGSM49AgEGBSuBBAAKBG0wawIBAQQgc34ocwTwpFa9NZZh3l88
qXyrkoYSxvC0FEsU5v1v4IOhRANCAARw7OEVKlbGFqUJtY10/Yf/JSR0LzUL1PZ1
4Ol/ErujAPgNwwGU5PSD6aTfn9NycnYB2hby9XwB2qF3+El+DV8q
-----END PRIVATE KEY-----
"
lib/libquickjs.a,"!<arch>
/               0           0     0     0       7934      `
"
test/fixtures/keys/dh512.pem,"-----BEGIN DH PARAMETERS-----
MEYCQQDItkdipTrinQp7aKt0GtwY7QE6tMKpg+r1zeucMrq9uNp8uLhHkF1OtqnL
StFTzxQIkjN2s8exIvoWZWiy/9DTAgEC
-----END DH PARAMETERS-----
"
test/fixtures/keys/dherror.pem,"-----BEGIN DH PARAMETERS-----
AAAAAAAAAA
AAAAAAAAAA
-----END DH PARAMETERS-----
"
test/fixtures/keys/ec_p256_public.pem,"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEX0mMYR/uleZSIPjNztIkAS3/ud5L
hNpbiIFp6fNf2GtRsm4/LZeLSVbtRhMHE8rfIaAO70QApgh5yOQdfmzaUg==
-----END PUBLIC KEY-----
"
test/fixtures/keys/ec_secp256k1_public.pem,"-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEcOzhFSpWxhalCbWNdP2H/yUkdC81C9T2
deDpfxK7owD4DcMBlOT0g+mk35/TcnJ2AdoW8vV8Adqhd/hJfg1fKg==
-----END PUBLIC KEY-----
"
test/fixtures/keys/ed448_private.pem,"-----BEGIN PRIVATE KEY-----
MEcCAQAwBQYDK2VxBDsEOdOtCnu9bDdBqSHNNZ5xoDA5KdLBTUNPcKFaOADNX32s
dfpo52pCtPqfku/l3/OfUHsF43EfZsaaWA==
-----END PRIVATE KEY-----
"
test/fixtures/keys/ed448_public.pem,"-----BEGIN PUBLIC KEY-----
MEMwBQYDK2VxAzoAoX/ee5+jlcU53+BbGRsGIzly0V+SZtJ/oGXY0udf84q2hTW2
RdstLktvwpkVJOoNb7oDgc2V5ZUA
-----END PUBLIC KEY-----
"
test/fixtures/keys/x448_private.pem,"-----BEGIN PRIVATE KEY-----
MEYCAQAwBQYDK2VvBDoEOLTDbazv6vHZWOmODQ3kk8TUOQgApB4j75rpInT5zSLl
/xJHK8ixF7f+4uo+mGTCrK1sktI5UmCZ
-----END PRIVATE KEY-----
"
test/fixtures/keys/x448_public.pem,"-----BEGIN PUBLIC KEY-----
MEIwBQYDK2VvAzkAioHSHVpTs6hMvghosEJDIR7ceFiE3+Xccxati64oOVJ7NWjf
ozE7ae31PXIUFq6cVYgvSKsDFPA=
-----END PUBLIC KEY-----
"
.gitignore,"/target
/.idea
/example_js/*/node_modules/
/example_js/*/dist
/example_js/*/build
/example_js/*/server-build
/test/.tmp.0"
example_js/create-react-app-ssr/.babelrc.json,"{
	""presets"": [
	  ""@babel/preset-env"",
	  ""@babel/preset-react""
	]
}
  "
example_js/module_demo/modules/my_mod_1.js,"export function hello_mod_1(){
    console.log('hello from ""my_mod_1.js""')
}"
example_js/module_demo/modules/my_mod_2.js,"export function hello_mod_2(){
    console.log('hello from ""my_mod_2.js""')
}"
src/internal_module/httpx/mod.rs,"mod core;
mod js_module;

pub use js_module::init_module;
"
test/fixtures/copy/kitchen-sink/a/b/index.js,"module.exports = {
  purpose: 'testing copy'
};
"
test/fixtures/copy/kitchen-sink/a/c/d/index.js,"module.exports = {
  purpose: 'testing copy'
};
"
test/fixtures/copy/kitchen-sink/a/c/index.js,"module.exports = {
  purpose: 'testing copy'
};
"
test/fixtures/copy/kitchen-sink/a/index.js,"module.exports = {
  purpose: 'testing copy'
};
"
test/fixtures/copy/kitchen-sink/index.js,"module.exports = {
  purpose: 'testing copy'
};
"
test/fixtures/keys/ed25519_private.pem,"-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEIMFSujN0jIUIdzSvuxka0lfgVVkMdRTuaVvIYUHrvzXQ
-----END PRIVATE KEY-----
"
test/fixtures/keys/ed25519_public.pem,"-----BEGIN PUBLIC KEY-----
MCowBQYDK2VwAyEAK1wIouqnuiA04b3WrMa+xKIKIpfHetNZRv3h9fBf768=
-----END PUBLIC KEY-----
"
test/fixtures/keys/x25519_private.pem,"-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VuBCIEIJi/yFpueUawC1BkXyWM8ONIBGFjL7UZHrD/Zo/KPDpn
-----END PRIVATE KEY-----
"
test/fixtures/keys/x25519_public.pem,"-----BEGIN PUBLIC KEY-----
MCowBQYDK2VuAyEAaSb8Q+RndwfNnPeOYGYPDUN3uhAPnMLzXyfi+mqfhig=
-----END PUBLIC KEY-----
"
test/fixtures/keys/.gitattributes,"* -text

Makefile text
*.cnf text
"
test/fixtures/keys/ca2-database.txt,"R	22920830184220Z	181116184220Z	91F006636069F29A	unknown	/C=US/ST=CA/L=SF/O=Joyent/OU=Node.js/CN=agent4/emailAddress=ry@tinyclouds.org
"
example_js/create-react-app-ssr/public/robots.txt,"# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
"
test/fixtures/baz.js,"module.exports = 'perhaps I work';
"
test/fixtures/keys/ec.pfx,"00	*H
00	*H
0|"
test/fixtures/keys/ec10.pfx,"00X	*H
IE0A07	*H
(0$"
test/fixtures/keys/fake-startcom-root-database.txt.old,"V	22920830184221Z		01	unknown	/C=US/ST=CA/L=SF/O=NODEJS/OU=agent8/CN=localhost
"
src/event_loop/poll.rs,"pub use wasmedge_wasi_socket::wasi_poll::*;
"
test/fixtures/keys/ca2-database.txt.attr,"unique_subject = no
"
test/fixtures/keys/ca2-database.txt.attr.old,"unique_subject = no
"
test/fixtures/keys/fake-startcom-root-database.txt.attr,"unique_subject = no
"
test/fixtures/keys/fake-startcom-root-database.txt.attr.old,"unique_subject = no
"
example_js/bird.png,"PNG

"
example_js/create-react-app-ssr/public/logo192.png,"PNG

"
example_js/create-react-app-ssr/public/logo512.png,"PNG

"
example_js/tensorflow_demo/bird.png,"PNG

"
test/fixtures/copy/kitchen-sink/README.md,"# Hello
"
test/fixtures/copy/kitchen-sink/a/b/README2.md,"# Hello
"
test/fixtures/copy/kitchen-sink/a/c/README2.md,"# Hello
"
test/fixtures/copy/kitchen-sink/a/c/d/README3.md,"# Hello
"
example_js/tensorflow_lite_demo/food.jpg,
examples/host_function/wasmedge_c/demo_wasmedge,ELF
examples/host_function/wasmedge_c/libwasmedge_c.so,ELF
test/fixtures/elipses.txt,
test/fixtures/keys/I_AM_THE_WALRUS_sha256_signature_signedby_rsa_private_b.sha256,"$6HjbhR(h[R8Xo@=oce:>\M!O~L""=`2"
test/fixtures/keys/ca1-cert.srl,"ECC9B856270DA9A8
"
test/fixtures/keys/ca2-cert.srl,"91F006636069F29D
"
test/fixtures/keys/ca2-serial,1
test/fixtures/keys/ca3-cert.srl,"D0082F458B6EFBE8
"
test/fixtures/keys/ca4-cert.srl,"ECAF33A18C6435BA
"
test/fixtures/keys/ca5-cert.srl,"C4C2054438388E3E
"
test/fixtures/keys/ca6-cert.srl,"A97535039C5E962B
"
test/fixtures/keys/fake-cnnic-root-cert.srl,"9E13B420E1F5C718
"
test/fixtures/keys/fake-startcom-root-serial,3
test/fixtures/keys/fake-startcom-root-serial.old,2
test/fixtures/keys/rsa_cert_foafssl_b.exponent,"0x10001
"
test/fixtures/keys/rsa_cert_foafssl_b.modulus,"C9BD60AEB37EDBD7F179E11B4DA4848DAE932834E94FF5979EAAC5092FA1EC861C9C3A0057072C3D4E4565E50FBCB28CCE2F4D1D2277E0B402BABA87807F17F9CC34613DE07584BFEEAA10897B3ECCABFAD7935CB6D0F7C6540B71E63E370CE7A0F5F2C99C0E799AB25391E2A9BAEABBA85DAFA81062880C34B9F6371056DA919E81DEBE6463025F7FBF06D30FFFAB579ADB588D8FB284DD92AC6CF970A856A5C1E20BA5FE07BB822A8299CBEB768D4C5854A5305ABD59B8CF24A529EE54272FD4EA0C1848A610703BBFF79A17FCBECFF55D43863CF068539D537829BB6067EA3D3E8863C4B154EB655E4C02E2C54E663D029281220229F8DEBF415452EAC5EB
"
test/fixtures/keys/rsa_spkac.spkac,"MIICUzCCATswggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC33FiIiiexwLe/P8DZx5HsqFlmUO7/lvJ7necJVNwqdZ3ax5jpQB0p6uxfqeOvzcN3k5V7UFb/Am+nkSNZMAZhsWzCU2Z4Pjh50QYz3f0Hour7/yIGStOLyYY3hgLK2K8TbhgjQPhdkw9+QtKlpvbL8fLgONAoGrVOFnRQGcr70iFffsm79mgZhKVMgYiHPJqJgGHvCtkGg9zMgS7p63+Q3ZWedtFS2RhMX3uCBy/mH6EOlRCNBbRmA4xxNzyf5GQaki3T+Iz9tOMjdPP+CwV2LqEdylmBuik8vrfTb3qIHLKKBAI8lXN26wWtA3kN4L7NP+cbKlCRlqctvhmylLH1AgMBAAEWE3RoaXMtaXMtYS1jaGFsbGVuZ2UwDQYJKoZIhvcNAQEEBQADggEBAIozmeW1kfDfAVwRQKileZGLRGCD7AjdHLYEe16xTBPve8Af1bDOyuWsAm4qQLYA4FAFROiKeGqxCtIErEvm87/09tCfF1My/1Uj+INjAk39DK9J9alLlTsrwSgd1lb3YlXY7TyitCmh7iXLo4pVhA2chNA3njiMq3CUpSvGbpzrESL2dv97lv590gUD988wkTDVyYsf0T8+X0Kww3AgPWGji+2f2i5/jTfD/s1lK1nqi7ZxFm0pGZoy1MJ51SCEy7Y82ajroI+5786nC02mo9ak7samca4YDZOoxN4d3tax4B/HDF5dqJSm1/31xYLDTfujCM5FkSjRc4m6hnriEkc=
"
test/fixtures/keys/rsa_spkac_invalid.spkac,"UzCCATswggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC33FiIiiexwLe/P8DZx5HsqFlmUO7/lvJ7necJVNwqdZ3ax5jpQB0p6uxfqeOvzcN3k5V7UFb/Am+nkSNZMAZhsWzCU2Z4Pjh50QYz3f0Hour7/yIGStOLyYY3hgLK2K8TbhgjQPhdkw9+QtKlpvbL8fLgONAoGrVOFnRQGcr70iFffsm79mgZhKVMgYiHPJqJgGHvCtkGg9zMgS7p63+Q3ZWedtFS2RhMX3uCBy/mH6EOlRCNBbRmA4xxNzyf5GQaki3T+Iz9tOMjdPP+CwV2LqEdylmBuik8vrfTb3qIHLKKBAI8lXN26wWtA3kN4L7NP+cbKlCRlqctvhmylLH1AgMBAAEWE3RoaXMtaXMtYS1jaGFsbGVuZ2UwDQYJKoZIhvcNAQEEBQADggEBAIozmeW1kfDfAVwRQKileZGLRGCD7AjdHLYEe16xTBPve8Af1bDOyuWsAm4qQLYA4FAFROiKeGqxCtIErEvm87/09tCfF1My/1Uj+INjAk39DK9J9alLlTsrwSgd1lb3YlXY7TyitCmh7iXLo4pVhA2chNA3njiMq3CUpSvGbpzrESL2dv97lv590gUD988wkTDVyYsf0T8+X0Kww3AgPWGji+2f2i5/jTfD/s1lK1nqi7ZxFm0pGZoy1MJ51SCEy7Y82ajroI+5786nC02mo9ak7samca4YDZOoxN4d3tax4B/HDF5dqJSm1/31xYLDTfujCM5FkSjRc4m6hnriEkc=
"
test/fixtures/x.txt,"xyz
"
example_js/create-react-app-ssr/public/favicon.ico,
example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite,
test/fixtures/empty.txt,
test/fixtures/keys/ca2-database.txt.old,
test/fixtures/keys/emptydir,